import Foundation
import Tea
import TeaUtils
import AlibabacloudOpenApi
import AlibabaCloudOpenApiUtil
import AlibabacloudEndpointUtil

public class AckConfig : Tea.TeaModel {
    public var ackInstanceId: String?

    public var customAnnotations: [Tag]?

    public var customLabels: [Tag]?

    public var dataDiskSize: Int32?

    public var dataDiskStorageClass: String?

    public var limitCpu: Double?

    public var limitMemory: Double?

    public var mountHostCgroup: Bool?

    public var namespace: String?

    public var nodeSelectors: [Tag]?

    public var requestCpu: Double?

    public var requestMemory: Double?

    public var tolerations: [Toleration]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ackInstanceId != nil {
            map["AckInstanceId"] = self.ackInstanceId!
        }
        if self.customAnnotations != nil {
            var tmp : [Any] = []
            for k in self.customAnnotations! {
                tmp.append(k.toMap())
            }
            map["CustomAnnotations"] = tmp
        }
        if self.customLabels != nil {
            var tmp : [Any] = []
            for k in self.customLabels! {
                tmp.append(k.toMap())
            }
            map["CustomLabels"] = tmp
        }
        if self.dataDiskSize != nil {
            map["DataDiskSize"] = self.dataDiskSize!
        }
        if self.dataDiskStorageClass != nil {
            map["DataDiskStorageClass"] = self.dataDiskStorageClass!
        }
        if self.limitCpu != nil {
            map["LimitCpu"] = self.limitCpu!
        }
        if self.limitMemory != nil {
            map["LimitMemory"] = self.limitMemory!
        }
        if self.mountHostCgroup != nil {
            map["MountHostCgroup"] = self.mountHostCgroup!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.nodeSelectors != nil {
            var tmp : [Any] = []
            for k in self.nodeSelectors! {
                tmp.append(k.toMap())
            }
            map["NodeSelectors"] = tmp
        }
        if self.requestCpu != nil {
            map["RequestCpu"] = self.requestCpu!
        }
        if self.requestMemory != nil {
            map["RequestMemory"] = self.requestMemory!
        }
        if self.tolerations != nil {
            var tmp : [Any] = []
            for k in self.tolerations! {
                tmp.append(k.toMap())
            }
            map["Tolerations"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AckInstanceId") {
            self.ackInstanceId = dict["AckInstanceId"] as! String
        }
        if dict.keys.contains("CustomAnnotations") {
            var tmp : [Tag] = []
            for v in dict["CustomAnnotations"] as! [Any] {
                var model = Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.customAnnotations = tmp
        }
        if dict.keys.contains("CustomLabels") {
            var tmp : [Tag] = []
            for v in dict["CustomLabels"] as! [Any] {
                var model = Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.customLabels = tmp
        }
        if dict.keys.contains("DataDiskSize") {
            self.dataDiskSize = dict["DataDiskSize"] as! Int32
        }
        if dict.keys.contains("DataDiskStorageClass") {
            self.dataDiskStorageClass = dict["DataDiskStorageClass"] as! String
        }
        if dict.keys.contains("LimitCpu") {
            self.limitCpu = dict["LimitCpu"] as! Double
        }
        if dict.keys.contains("LimitMemory") {
            self.limitMemory = dict["LimitMemory"] as! Double
        }
        if dict.keys.contains("MountHostCgroup") {
            self.mountHostCgroup = dict["MountHostCgroup"] as! Bool
        }
        if dict.keys.contains("Namespace") {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("NodeSelectors") {
            var tmp : [Tag] = []
            for v in dict["NodeSelectors"] as! [Any] {
                var model = Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.nodeSelectors = tmp
        }
        if dict.keys.contains("RequestCpu") {
            self.requestCpu = dict["RequestCpu"] as! Double
        }
        if dict.keys.contains("RequestMemory") {
            self.requestMemory = dict["RequestMemory"] as! Double
        }
        if dict.keys.contains("Tolerations") {
            var tmp : [Toleration] = []
            for v in dict["Tolerations"] as! [Any] {
                var model = Toleration()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tolerations = tmp
        }
    }
}

public class AckNode : Tea.TeaModel {
    public var nodeId: String?

    public var nodeSelector: AckNodeSelector?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.nodeSelector?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.nodeSelector != nil {
            map["NodeSelector"] = self.nodeSelector?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NodeId") {
            self.nodeId = dict["NodeId"] as! String
        }
        if dict.keys.contains("NodeSelector") {
            var model = AckNodeSelector()
            model.fromMap(dict["NodeSelector"] as! [String: Any])
            self.nodeSelector = model
        }
    }
}

public class AckNodePool : Tea.TeaModel {
    public var nodePoolId: String?

    public var nodeSelector: AckNodeSelector?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.nodeSelector?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nodePoolId != nil {
            map["NodePoolId"] = self.nodePoolId!
        }
        if self.nodeSelector != nil {
            map["NodeSelector"] = self.nodeSelector?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NodePoolId") {
            self.nodePoolId = dict["NodePoolId"] as! String
        }
        if dict.keys.contains("NodeSelector") {
            var model = AckNodeSelector()
            model.fromMap(dict["NodeSelector"] as! [String: Any])
            self.nodeSelector = model
        }
    }
}

public class AckNodeSelector : Tea.TeaModel {
    public class Labels : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public class Taints : Tea.TeaModel {
        public var effect: String?

        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.effect != nil {
                map["Effect"] = self.effect!
            }
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Effect") {
                self.effect = dict["Effect"] as! String
            }
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var labels: [AckNodeSelector.Labels]?

    public var taints: [AckNodeSelector.Taints]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.labels != nil {
            var tmp : [Any] = []
            for k in self.labels! {
                tmp.append(k.toMap())
            }
            map["Labels"] = tmp
        }
        if self.taints != nil {
            var tmp : [Any] = []
            for k in self.taints! {
                tmp.append(k.toMap())
            }
            map["Taints"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Labels") {
            var tmp : [AckNodeSelector.Labels] = []
            for v in dict["Labels"] as! [Any] {
                var model = AckNodeSelector.Labels()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.labels = tmp
        }
        if dict.keys.contains("Taints") {
            var tmp : [AckNodeSelector.Taints] = []
            for v in dict["Taints"] as! [Any] {
                var model = AckNodeSelector.Taints()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.taints = tmp
        }
    }
}

public class ApiTemplate : Tea.TeaModel {
    public var apiName: String?

    public var content: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var status: String?

    public var templateId: String?

    public var templateName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiName != nil {
            map["ApiName"] = self.apiName!
        }
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.templateName != nil {
            map["TemplateName"] = self.templateName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiName") {
            self.apiName = dict["ApiName"] as! String
        }
        if dict.keys.contains("Content") {
            self.content = dict["Content"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("TemplateName") {
            self.templateName = dict["TemplateName"] as! String
        }
    }
}

public class Application : Tea.TeaModel {
    public var applicationName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationName != nil {
            map["ApplicationName"] = self.applicationName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApplicationName") {
            self.applicationName = dict["ApplicationName"] as! String
        }
    }
}

public class ApplicationConfig : Tea.TeaModel {
    public var applicationName: String?

    public var configFileName: String?

    public var configItemKey: String?

    public var configItemValue: String?

    public var configScope: String?

    public var nodeGroupId: String?

    public var nodeGroupName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationName != nil {
            map["ApplicationName"] = self.applicationName!
        }
        if self.configFileName != nil {
            map["ConfigFileName"] = self.configFileName!
        }
        if self.configItemKey != nil {
            map["ConfigItemKey"] = self.configItemKey!
        }
        if self.configItemValue != nil {
            map["ConfigItemValue"] = self.configItemValue!
        }
        if self.configScope != nil {
            map["ConfigScope"] = self.configScope!
        }
        if self.nodeGroupId != nil {
            map["NodeGroupId"] = self.nodeGroupId!
        }
        if self.nodeGroupName != nil {
            map["NodeGroupName"] = self.nodeGroupName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApplicationName") {
            self.applicationName = dict["ApplicationName"] as! String
        }
        if dict.keys.contains("ConfigFileName") {
            self.configFileName = dict["ConfigFileName"] as! String
        }
        if dict.keys.contains("ConfigItemKey") {
            self.configItemKey = dict["ConfigItemKey"] as! String
        }
        if dict.keys.contains("ConfigItemValue") {
            self.configItemValue = dict["ConfigItemValue"] as! String
        }
        if dict.keys.contains("ConfigScope") {
            self.configScope = dict["ConfigScope"] as! String
        }
        if dict.keys.contains("NodeGroupId") {
            self.nodeGroupId = dict["NodeGroupId"] as! String
        }
        if dict.keys.contains("NodeGroupName") {
            self.nodeGroupName = dict["NodeGroupName"] as! String
        }
    }
}

public class ApplicationConfigFile : Tea.TeaModel {
    public var applicationName: String?

    public var configFileName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationName != nil {
            map["ApplicationName"] = self.applicationName!
        }
        if self.configFileName != nil {
            map["ConfigFileName"] = self.configFileName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApplicationName") {
            self.applicationName = dict["ApplicationName"] as! String
        }
        if dict.keys.contains("ConfigFileName") {
            self.configFileName = dict["ConfigFileName"] as! String
        }
    }
}

public class ApplicationConfigParam : Tea.TeaModel {
    public var configAction: String?

    public var configFileName: String?

    public var configItemDescription: String?

    public var configItemKey: String?

    public var configItemValue: String?

    public var configScope: String?

    public var effectiveActions: String?

    public var effectiveType: String?

    public var nodeGroupId: String?

    public var nodeId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configAction != nil {
            map["ConfigAction"] = self.configAction!
        }
        if self.configFileName != nil {
            map["ConfigFileName"] = self.configFileName!
        }
        if self.configItemDescription != nil {
            map["ConfigItemDescription"] = self.configItemDescription!
        }
        if self.configItemKey != nil {
            map["ConfigItemKey"] = self.configItemKey!
        }
        if self.configItemValue != nil {
            map["ConfigItemValue"] = self.configItemValue!
        }
        if self.configScope != nil {
            map["ConfigScope"] = self.configScope!
        }
        if self.effectiveActions != nil {
            map["EffectiveActions"] = self.effectiveActions!
        }
        if self.effectiveType != nil {
            map["EffectiveType"] = self.effectiveType!
        }
        if self.nodeGroupId != nil {
            map["NodeGroupId"] = self.nodeGroupId!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConfigAction") {
            self.configAction = dict["ConfigAction"] as! String
        }
        if dict.keys.contains("ConfigFileName") {
            self.configFileName = dict["ConfigFileName"] as! String
        }
        if dict.keys.contains("ConfigItemDescription") {
            self.configItemDescription = dict["ConfigItemDescription"] as! String
        }
        if dict.keys.contains("ConfigItemKey") {
            self.configItemKey = dict["ConfigItemKey"] as! String
        }
        if dict.keys.contains("ConfigItemValue") {
            self.configItemValue = dict["ConfigItemValue"] as! String
        }
        if dict.keys.contains("ConfigScope") {
            self.configScope = dict["ConfigScope"] as! String
        }
        if dict.keys.contains("EffectiveActions") {
            self.effectiveActions = dict["EffectiveActions"] as! String
        }
        if dict.keys.contains("EffectiveType") {
            self.effectiveType = dict["EffectiveType"] as! String
        }
        if dict.keys.contains("NodeGroupId") {
            self.nodeGroupId = dict["NodeGroupId"] as! String
        }
        if dict.keys.contains("NodeId") {
            self.nodeId = dict["NodeId"] as! String
        }
    }
}

public class Attribute : Tea.TeaModel {
    public var key: String?

    public var value: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.key != nil {
            map["Key"] = self.key!
        }
        if self.value != nil {
            map["Value"] = self.value!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Key") {
            self.key = dict["Key"] as! String
        }
        if dict.keys.contains("Value") {
            self.value = dict["Value"] as! String
        }
    }
}

public class AutoRenewInstance : Tea.TeaModel {
    public var autoRenew: Bool?

    public var autoRenewDuration: Int32?

    public var autoRenewDurationUnit: String?

    public var emrAutoRenewDuration: Int32?

    public var emrAutoRenewDurationUnit: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoRenew != nil {
            map["AutoRenew"] = self.autoRenew!
        }
        if self.autoRenewDuration != nil {
            map["AutoRenewDuration"] = self.autoRenewDuration!
        }
        if self.autoRenewDurationUnit != nil {
            map["AutoRenewDurationUnit"] = self.autoRenewDurationUnit!
        }
        if self.emrAutoRenewDuration != nil {
            map["EmrAutoRenewDuration"] = self.emrAutoRenewDuration!
        }
        if self.emrAutoRenewDurationUnit != nil {
            map["EmrAutoRenewDurationUnit"] = self.emrAutoRenewDurationUnit!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoRenew") {
            self.autoRenew = dict["AutoRenew"] as! Bool
        }
        if dict.keys.contains("AutoRenewDuration") {
            self.autoRenewDuration = dict["AutoRenewDuration"] as! Int32
        }
        if dict.keys.contains("AutoRenewDurationUnit") {
            self.autoRenewDurationUnit = dict["AutoRenewDurationUnit"] as! String
        }
        if dict.keys.contains("EmrAutoRenewDuration") {
            self.emrAutoRenewDuration = dict["EmrAutoRenewDuration"] as! Int32
        }
        if dict.keys.contains("EmrAutoRenewDurationUnit") {
            self.emrAutoRenewDurationUnit = dict["EmrAutoRenewDurationUnit"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class AutoRenewInstanceParam : Tea.TeaModel {
    public var autoRenew: String?

    public var autoRenewDuration: String?

    public var autoRenewDurationUnit: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoRenew != nil {
            map["AutoRenew"] = self.autoRenew!
        }
        if self.autoRenewDuration != nil {
            map["AutoRenewDuration"] = self.autoRenewDuration!
        }
        if self.autoRenewDurationUnit != nil {
            map["AutoRenewDurationUnit"] = self.autoRenewDurationUnit!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoRenew") {
            self.autoRenew = dict["AutoRenew"] as! String
        }
        if dict.keys.contains("AutoRenewDuration") {
            self.autoRenewDuration = dict["AutoRenewDuration"] as! String
        }
        if dict.keys.contains("AutoRenewDurationUnit") {
            self.autoRenewDurationUnit = dict["AutoRenewDurationUnit"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class AutoScalingConstraints : Tea.TeaModel {
    public class SupportMetricTags : Tea.TeaModel {
        public var metricName: String?

        public var tags: [Tag]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.metricName != nil {
                map["MetricName"] = self.metricName!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MetricName") {
                self.metricName = dict["MetricName"] as! String
            }
            if dict.keys.contains("Tags") {
                var tmp : [Tag] = []
                for v in dict["Tags"] as! [Any] {
                    var model = Tag()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tags = tmp
            }
        }
    }
    public var autoScalingMetricUnits: [MetricUnitValue]?

    public var defaultMetricTriggeredRules: [ScalingRule]?

    public var maxAdjustmentValue: Int32?

    public var maxByLoadRuleCount: Int32?

    public var maxByTimeRuleCount: Int32?

    public var supportMetricTags: [AutoScalingConstraints.SupportMetricTags]?

    public var supportMetrics: [String]?

    public var supportRuleTypes: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoScalingMetricUnits != nil {
            var tmp : [Any] = []
            for k in self.autoScalingMetricUnits! {
                tmp.append(k.toMap())
            }
            map["AutoScalingMetricUnits"] = tmp
        }
        if self.defaultMetricTriggeredRules != nil {
            var tmp : [Any] = []
            for k in self.defaultMetricTriggeredRules! {
                tmp.append(k.toMap())
            }
            map["DefaultMetricTriggeredRules"] = tmp
        }
        if self.maxAdjustmentValue != nil {
            map["MaxAdjustmentValue"] = self.maxAdjustmentValue!
        }
        if self.maxByLoadRuleCount != nil {
            map["MaxByLoadRuleCount"] = self.maxByLoadRuleCount!
        }
        if self.maxByTimeRuleCount != nil {
            map["MaxByTimeRuleCount"] = self.maxByTimeRuleCount!
        }
        if self.supportMetricTags != nil {
            var tmp : [Any] = []
            for k in self.supportMetricTags! {
                tmp.append(k.toMap())
            }
            map["SupportMetricTags"] = tmp
        }
        if self.supportMetrics != nil {
            map["SupportMetrics"] = self.supportMetrics!
        }
        if self.supportRuleTypes != nil {
            map["SupportRuleTypes"] = self.supportRuleTypes!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoScalingMetricUnits") {
            var tmp : [MetricUnitValue] = []
            for v in dict["AutoScalingMetricUnits"] as! [Any] {
                var model = MetricUnitValue()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.autoScalingMetricUnits = tmp
        }
        if dict.keys.contains("DefaultMetricTriggeredRules") {
            var tmp : [ScalingRule] = []
            for v in dict["DefaultMetricTriggeredRules"] as! [Any] {
                var model = ScalingRule()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.defaultMetricTriggeredRules = tmp
        }
        if dict.keys.contains("MaxAdjustmentValue") {
            self.maxAdjustmentValue = dict["MaxAdjustmentValue"] as! Int32
        }
        if dict.keys.contains("MaxByLoadRuleCount") {
            self.maxByLoadRuleCount = dict["MaxByLoadRuleCount"] as! Int32
        }
        if dict.keys.contains("MaxByTimeRuleCount") {
            self.maxByTimeRuleCount = dict["MaxByTimeRuleCount"] as! Int32
        }
        if dict.keys.contains("SupportMetricTags") {
            var tmp : [AutoScalingConstraints.SupportMetricTags] = []
            for v in dict["SupportMetricTags"] as! [Any] {
                var model = AutoScalingConstraints.SupportMetricTags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.supportMetricTags = tmp
        }
        if dict.keys.contains("SupportMetrics") {
            self.supportMetrics = dict["SupportMetrics"] as! [String]
        }
        if dict.keys.contains("SupportRuleTypes") {
            self.supportRuleTypes = dict["SupportRuleTypes"] as! [String]
        }
    }
}

public class AutoScalingPolicy : Tea.TeaModel {
    public class Constraints : Tea.TeaModel {
        public var maxCapacity: Int32?

        public var minCapacity: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.maxCapacity != nil {
                map["maxCapacity"] = self.maxCapacity!
            }
            if self.minCapacity != nil {
                map["minCapacity"] = self.minCapacity!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("maxCapacity") {
                self.maxCapacity = dict["maxCapacity"] as! Int32
            }
            if dict.keys.contains("minCapacity") {
                self.minCapacity = dict["minCapacity"] as! Int32
            }
        }
    }
    public var constraints: AutoScalingPolicy.Constraints?

    public var scalingRules: [ScalingRule]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.constraints?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.constraints != nil {
            map["constraints"] = self.constraints?.toMap()
        }
        if self.scalingRules != nil {
            var tmp : [Any] = []
            for k in self.scalingRules! {
                tmp.append(k.toMap())
            }
            map["scalingRules"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("constraints") {
            var model = AutoScalingPolicy.Constraints()
            model.fromMap(dict["constraints"] as! [String: Any])
            self.constraints = model
        }
        if dict.keys.contains("scalingRules") {
            var tmp : [ScalingRule] = []
            for v in dict["scalingRules"] as! [Any] {
                var model = ScalingRule()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.scalingRules = tmp
        }
    }
}

public class ByLoadScalingRule : Tea.TeaModel {
    public var comparisonOperator: String?

    public var coolDownInterval: Int32?

    public var evaluationCount: Int32?

    public var metricName: String?

    public var statistics: String?

    public var threshold: Double?

    public var timeWindow: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.comparisonOperator != nil {
            map["ComparisonOperator"] = self.comparisonOperator!
        }
        if self.coolDownInterval != nil {
            map["CoolDownInterval"] = self.coolDownInterval!
        }
        if self.evaluationCount != nil {
            map["EvaluationCount"] = self.evaluationCount!
        }
        if self.metricName != nil {
            map["MetricName"] = self.metricName!
        }
        if self.statistics != nil {
            map["Statistics"] = self.statistics!
        }
        if self.threshold != nil {
            map["Threshold"] = self.threshold!
        }
        if self.timeWindow != nil {
            map["TimeWindow"] = self.timeWindow!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ComparisonOperator") {
            self.comparisonOperator = dict["ComparisonOperator"] as! String
        }
        if dict.keys.contains("CoolDownInterval") {
            self.coolDownInterval = dict["CoolDownInterval"] as! Int32
        }
        if dict.keys.contains("EvaluationCount") {
            self.evaluationCount = dict["EvaluationCount"] as! Int32
        }
        if dict.keys.contains("MetricName") {
            self.metricName = dict["MetricName"] as! String
        }
        if dict.keys.contains("Statistics") {
            self.statistics = dict["Statistics"] as! String
        }
        if dict.keys.contains("Threshold") {
            self.threshold = dict["Threshold"] as! Double
        }
        if dict.keys.contains("TimeWindow") {
            self.timeWindow = dict["TimeWindow"] as! Int32
        }
    }
}

public class ByLoadScalingRuleSpec : Tea.TeaModel {
    public var comparisonOperator: String?

    public var evaluationCount: Int32?

    public var metricName: String?

    public var statistics: String?

    public var threshold: Double?

    public var timeWindow: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.comparisonOperator != nil {
            map["ComparisonOperator"] = self.comparisonOperator!
        }
        if self.evaluationCount != nil {
            map["EvaluationCount"] = self.evaluationCount!
        }
        if self.metricName != nil {
            map["MetricName"] = self.metricName!
        }
        if self.statistics != nil {
            map["Statistics"] = self.statistics!
        }
        if self.threshold != nil {
            map["Threshold"] = self.threshold!
        }
        if self.timeWindow != nil {
            map["TimeWindow"] = self.timeWindow!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ComparisonOperator") {
            self.comparisonOperator = dict["ComparisonOperator"] as! String
        }
        if dict.keys.contains("EvaluationCount") {
            self.evaluationCount = dict["EvaluationCount"] as! Int32
        }
        if dict.keys.contains("MetricName") {
            self.metricName = dict["MetricName"] as! String
        }
        if dict.keys.contains("Statistics") {
            self.statistics = dict["Statistics"] as! String
        }
        if dict.keys.contains("Threshold") {
            self.threshold = dict["Threshold"] as! Double
        }
        if dict.keys.contains("TimeWindow") {
            self.timeWindow = dict["TimeWindow"] as! Int32
        }
    }
}

public class ByTimeScalingRule : Tea.TeaModel {
    public var endTime: Int64?

    public var launchExpirationTime: Int32?

    public var launchTime: Int64?

    public var recurrenceType: String?

    public var recurrenceValue: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.launchExpirationTime != nil {
            map["LaunchExpirationTime"] = self.launchExpirationTime!
        }
        if self.launchTime != nil {
            map["LaunchTime"] = self.launchTime!
        }
        if self.recurrenceType != nil {
            map["RecurrenceType"] = self.recurrenceType!
        }
        if self.recurrenceValue != nil {
            map["RecurrenceValue"] = self.recurrenceValue!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("LaunchExpirationTime") {
            self.launchExpirationTime = dict["LaunchExpirationTime"] as! Int32
        }
        if dict.keys.contains("LaunchTime") {
            self.launchTime = dict["LaunchTime"] as! Int64
        }
        if dict.keys.contains("RecurrenceType") {
            self.recurrenceType = dict["RecurrenceType"] as! String
        }
        if dict.keys.contains("RecurrenceValue") {
            self.recurrenceValue = dict["RecurrenceValue"] as! String
        }
    }
}

public class ByTimeScalingRuleSpec : Tea.TeaModel {
    public var endTime: Int64?

    public var launchTime: Int64?

    public var recurrenceType: String?

    public var recurrenceValue: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.launchTime != nil {
            map["LaunchTime"] = self.launchTime!
        }
        if self.recurrenceType != nil {
            map["RecurrenceType"] = self.recurrenceType!
        }
        if self.recurrenceValue != nil {
            map["RecurrenceValue"] = self.recurrenceValue!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("LaunchTime") {
            self.launchTime = dict["LaunchTime"] as! Int64
        }
        if dict.keys.contains("RecurrenceType") {
            self.recurrenceType = dict["RecurrenceType"] as! String
        }
        if dict.keys.contains("RecurrenceValue") {
            self.recurrenceValue = dict["RecurrenceValue"] as! String
        }
    }
}

public class ClickhouseConf : Tea.TeaModel {
    public var initialReplica: Int32?

    public var initialShard: Int32?

    public var newNodeCount: Int32?

    public var resizeType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.initialReplica != nil {
            map["InitialReplica"] = self.initialReplica!
        }
        if self.initialShard != nil {
            map["InitialShard"] = self.initialShard!
        }
        if self.newNodeCount != nil {
            map["NewNodeCount"] = self.newNodeCount!
        }
        if self.resizeType != nil {
            map["ResizeType"] = self.resizeType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InitialReplica") {
            self.initialReplica = dict["InitialReplica"] as! Int32
        }
        if dict.keys.contains("InitialShard") {
            self.initialShard = dict["InitialShard"] as! Int32
        }
        if dict.keys.contains("NewNodeCount") {
            self.newNodeCount = dict["NewNodeCount"] as! Int32
        }
        if dict.keys.contains("ResizeType") {
            self.resizeType = dict["ResizeType"] as! String
        }
    }
}

public class Cluster : Tea.TeaModel {
    public var clusterId: String?

    public var clusterName: String?

    public var clusterState: String?

    public var clusterType: String?

    public var createTime: Int64?

    public var deployMode: String?

    public var emrDefaultRole: String?

    public var endTime: Int64?

    public var expireTime: Int64?

    public var nodeAttributes: NodeAttributes?

    public var paymentType: String?

    public var readyTime: Int64?

    public var regionId: String?

    public var releaseVersion: String?

    public var resourceGroupId: String?

    public var securityMode: String?

    public var stateChangeReason: ClusterStateChangeReason?

    public var subscriptionConfig: SubscriptionConfig?

    public var tags: [Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.nodeAttributes?.validate()
        try self.stateChangeReason?.validate()
        try self.subscriptionConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.clusterName != nil {
            map["ClusterName"] = self.clusterName!
        }
        if self.clusterState != nil {
            map["ClusterState"] = self.clusterState!
        }
        if self.clusterType != nil {
            map["ClusterType"] = self.clusterType!
        }
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.deployMode != nil {
            map["DeployMode"] = self.deployMode!
        }
        if self.emrDefaultRole != nil {
            map["EmrDefaultRole"] = self.emrDefaultRole!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.expireTime != nil {
            map["ExpireTime"] = self.expireTime!
        }
        if self.nodeAttributes != nil {
            map["NodeAttributes"] = self.nodeAttributes?.toMap()
        }
        if self.paymentType != nil {
            map["PaymentType"] = self.paymentType!
        }
        if self.readyTime != nil {
            map["ReadyTime"] = self.readyTime!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.releaseVersion != nil {
            map["ReleaseVersion"] = self.releaseVersion!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.securityMode != nil {
            map["SecurityMode"] = self.securityMode!
        }
        if self.stateChangeReason != nil {
            map["StateChangeReason"] = self.stateChangeReason?.toMap()
        }
        if self.subscriptionConfig != nil {
            map["SubscriptionConfig"] = self.subscriptionConfig?.toMap()
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("ClusterName") {
            self.clusterName = dict["ClusterName"] as! String
        }
        if dict.keys.contains("ClusterState") {
            self.clusterState = dict["ClusterState"] as! String
        }
        if dict.keys.contains("ClusterType") {
            self.clusterType = dict["ClusterType"] as! String
        }
        if dict.keys.contains("CreateTime") {
            self.createTime = dict["CreateTime"] as! Int64
        }
        if dict.keys.contains("DeployMode") {
            self.deployMode = dict["DeployMode"] as! String
        }
        if dict.keys.contains("EmrDefaultRole") {
            self.emrDefaultRole = dict["EmrDefaultRole"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("ExpireTime") {
            self.expireTime = dict["ExpireTime"] as! Int64
        }
        if dict.keys.contains("NodeAttributes") {
            var model = NodeAttributes()
            model.fromMap(dict["NodeAttributes"] as! [String: Any])
            self.nodeAttributes = model
        }
        if dict.keys.contains("PaymentType") {
            self.paymentType = dict["PaymentType"] as! String
        }
        if dict.keys.contains("ReadyTime") {
            self.readyTime = dict["ReadyTime"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ReleaseVersion") {
            self.releaseVersion = dict["ReleaseVersion"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("SecurityMode") {
            self.securityMode = dict["SecurityMode"] as! String
        }
        if dict.keys.contains("StateChangeReason") {
            var model = ClusterStateChangeReason()
            model.fromMap(dict["StateChangeReason"] as! [String: Any])
            self.stateChangeReason = model
        }
        if dict.keys.contains("SubscriptionConfig") {
            var model = SubscriptionConfig()
            model.fromMap(dict["SubscriptionConfig"] as! [String: Any])
            self.subscriptionConfig = model
        }
        if dict.keys.contains("Tags") {
            var tmp : [Tag] = []
            for v in dict["Tags"] as! [Any] {
                var model = Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
    }
}

public class ClusterScript : Tea.TeaModel {
    public var executionFailStrategy: String?

    public var executionMoment: String?

    public var nodeSelect: NodeSelector?

    public var priority: Int32?

    public var scriptArgs: String?

    public var scriptName: String?

    public var scriptPath: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.nodeSelect?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.executionFailStrategy != nil {
            map["ExecutionFailStrategy"] = self.executionFailStrategy!
        }
        if self.executionMoment != nil {
            map["ExecutionMoment"] = self.executionMoment!
        }
        if self.nodeSelect != nil {
            map["NodeSelect"] = self.nodeSelect?.toMap()
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.scriptArgs != nil {
            map["ScriptArgs"] = self.scriptArgs!
        }
        if self.scriptName != nil {
            map["ScriptName"] = self.scriptName!
        }
        if self.scriptPath != nil {
            map["ScriptPath"] = self.scriptPath!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ExecutionFailStrategy") {
            self.executionFailStrategy = dict["ExecutionFailStrategy"] as! String
        }
        if dict.keys.contains("ExecutionMoment") {
            self.executionMoment = dict["ExecutionMoment"] as! String
        }
        if dict.keys.contains("NodeSelect") {
            var model = NodeSelector()
            model.fromMap(dict["NodeSelect"] as! [String: Any])
            self.nodeSelect = model
        }
        if dict.keys.contains("Priority") {
            self.priority = dict["Priority"] as! Int32
        }
        if dict.keys.contains("ScriptArgs") {
            self.scriptArgs = dict["ScriptArgs"] as! String
        }
        if dict.keys.contains("ScriptName") {
            self.scriptName = dict["ScriptName"] as! String
        }
        if dict.keys.contains("ScriptPath") {
            self.scriptPath = dict["ScriptPath"] as! String
        }
    }
}

public class ClusterStateChangeReason : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
    }
}

public class ClusterSummary : Tea.TeaModel {
    public var clusterId: String?

    public var clusterName: String?

    public var clusterState: String?

    public var clusterType: String?

    public var createTime: Int64?

    public var emrDefaultRole: String?

    public var endTime: Int64?

    public var expireTime: Int64?

    public var paymentType: String?

    public var readyTime: Int64?

    public var releaseVersion: String?

    public var resourceGroupId: String?

    public var stateChangeReason: ClusterStateChangeReason?

    public var tags: [Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.stateChangeReason?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.clusterName != nil {
            map["ClusterName"] = self.clusterName!
        }
        if self.clusterState != nil {
            map["ClusterState"] = self.clusterState!
        }
        if self.clusterType != nil {
            map["ClusterType"] = self.clusterType!
        }
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.emrDefaultRole != nil {
            map["EmrDefaultRole"] = self.emrDefaultRole!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.expireTime != nil {
            map["ExpireTime"] = self.expireTime!
        }
        if self.paymentType != nil {
            map["PaymentType"] = self.paymentType!
        }
        if self.readyTime != nil {
            map["ReadyTime"] = self.readyTime!
        }
        if self.releaseVersion != nil {
            map["ReleaseVersion"] = self.releaseVersion!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.stateChangeReason != nil {
            map["StateChangeReason"] = self.stateChangeReason?.toMap()
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("ClusterName") {
            self.clusterName = dict["ClusterName"] as! String
        }
        if dict.keys.contains("ClusterState") {
            self.clusterState = dict["ClusterState"] as! String
        }
        if dict.keys.contains("ClusterType") {
            self.clusterType = dict["ClusterType"] as! String
        }
        if dict.keys.contains("CreateTime") {
            self.createTime = dict["CreateTime"] as! Int64
        }
        if dict.keys.contains("EmrDefaultRole") {
            self.emrDefaultRole = dict["EmrDefaultRole"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("ExpireTime") {
            self.expireTime = dict["ExpireTime"] as! Int64
        }
        if dict.keys.contains("PaymentType") {
            self.paymentType = dict["PaymentType"] as! String
        }
        if dict.keys.contains("ReadyTime") {
            self.readyTime = dict["ReadyTime"] as! Int64
        }
        if dict.keys.contains("ReleaseVersion") {
            self.releaseVersion = dict["ReleaseVersion"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("StateChangeReason") {
            var model = ClusterStateChangeReason()
            model.fromMap(dict["StateChangeReason"] as! [String: Any])
            self.stateChangeReason = model
        }
        if dict.keys.contains("Tags") {
            var tmp : [Tag] = []
            for v in dict["Tags"] as! [Any] {
                var model = Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
    }
}

public class ComponentInstanceSelector : Tea.TeaModel {
    public class ComponentInstances : Tea.TeaModel {
        public var applicationName: String?

        public var componentName: String?

        public var nodeId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.applicationName != nil {
                map["ApplicationName"] = self.applicationName!
            }
            if self.componentName != nil {
                map["ComponentName"] = self.componentName!
            }
            if self.nodeId != nil {
                map["NodeId"] = self.nodeId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApplicationName") {
                self.applicationName = dict["ApplicationName"] as! String
            }
            if dict.keys.contains("ComponentName") {
                self.componentName = dict["ComponentName"] as! String
            }
            if dict.keys.contains("NodeId") {
                self.nodeId = dict["NodeId"] as! String
            }
        }
    }
    public class Components : Tea.TeaModel {
        public var applicationName: String?

        public var componentName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.applicationName != nil {
                map["ApplicationName"] = self.applicationName!
            }
            if self.componentName != nil {
                map["ComponentName"] = self.componentName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApplicationName") {
                self.applicationName = dict["ApplicationName"] as! String
            }
            if dict.keys.contains("ComponentName") {
                self.componentName = dict["ComponentName"] as! String
            }
        }
    }
    public var actionScope: String?

    public var applicationName: String?

    public var componentInstances: [ComponentInstanceSelector.ComponentInstances]?

    public var components: [ComponentInstanceSelector.Components]?

    public var runActionScope: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.actionScope != nil {
            map["ActionScope"] = self.actionScope!
        }
        if self.applicationName != nil {
            map["ApplicationName"] = self.applicationName!
        }
        if self.componentInstances != nil {
            var tmp : [Any] = []
            for k in self.componentInstances! {
                tmp.append(k.toMap())
            }
            map["ComponentInstances"] = tmp
        }
        if self.components != nil {
            var tmp : [Any] = []
            for k in self.components! {
                tmp.append(k.toMap())
            }
            map["Components"] = tmp
        }
        if self.runActionScope != nil {
            map["RunActionScope"] = self.runActionScope!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ActionScope") {
            self.actionScope = dict["ActionScope"] as! String
        }
        if dict.keys.contains("ApplicationName") {
            self.applicationName = dict["ApplicationName"] as! String
        }
        if dict.keys.contains("ComponentInstances") {
            var tmp : [ComponentInstanceSelector.ComponentInstances] = []
            for v in dict["ComponentInstances"] as! [Any] {
                var model = ComponentInstanceSelector.ComponentInstances()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.componentInstances = tmp
        }
        if dict.keys.contains("Components") {
            var tmp : [ComponentInstanceSelector.Components] = []
            for v in dict["Components"] as! [Any] {
                var model = ComponentInstanceSelector.Components()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.components = tmp
        }
        if dict.keys.contains("RunActionScope") {
            self.runActionScope = dict["RunActionScope"] as! String
        }
    }
}

public class ComponentLayout : Tea.TeaModel {
    public class NodeSelector : Tea.TeaModel {
        public var nodeEndIndex: Int32?

        public var nodeGroupId: String?

        public var nodeGroupIndex: Int32?

        public var nodeGroupName: String?

        public var nodeGroupTypes: [String]?

        public var nodeNames: [String]?

        public var nodeSelectType: String?

        public var nodeStartIndex: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.nodeEndIndex != nil {
                map["NodeEndIndex"] = self.nodeEndIndex!
            }
            if self.nodeGroupId != nil {
                map["NodeGroupId"] = self.nodeGroupId!
            }
            if self.nodeGroupIndex != nil {
                map["NodeGroupIndex"] = self.nodeGroupIndex!
            }
            if self.nodeGroupName != nil {
                map["NodeGroupName"] = self.nodeGroupName!
            }
            if self.nodeGroupTypes != nil {
                map["NodeGroupTypes"] = self.nodeGroupTypes!
            }
            if self.nodeNames != nil {
                map["NodeNames"] = self.nodeNames!
            }
            if self.nodeSelectType != nil {
                map["NodeSelectType"] = self.nodeSelectType!
            }
            if self.nodeStartIndex != nil {
                map["NodeStartIndex"] = self.nodeStartIndex!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("NodeEndIndex") {
                self.nodeEndIndex = dict["NodeEndIndex"] as! Int32
            }
            if dict.keys.contains("NodeGroupId") {
                self.nodeGroupId = dict["NodeGroupId"] as! String
            }
            if dict.keys.contains("NodeGroupIndex") {
                self.nodeGroupIndex = dict["NodeGroupIndex"] as! Int32
            }
            if dict.keys.contains("NodeGroupName") {
                self.nodeGroupName = dict["NodeGroupName"] as! String
            }
            if dict.keys.contains("NodeGroupTypes") {
                self.nodeGroupTypes = dict["NodeGroupTypes"] as! [String]
            }
            if dict.keys.contains("NodeNames") {
                self.nodeNames = dict["NodeNames"] as! [String]
            }
            if dict.keys.contains("NodeSelectType") {
                self.nodeSelectType = dict["NodeSelectType"] as! String
            }
            if dict.keys.contains("NodeStartIndex") {
                self.nodeStartIndex = dict["NodeStartIndex"] as! Int32
            }
        }
    }
    public var applicationName: String?

    public var componentName: String?

    public var nodeSelector: ComponentLayout.NodeSelector?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.nodeSelector?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationName != nil {
            map["ApplicationName"] = self.applicationName!
        }
        if self.componentName != nil {
            map["ComponentName"] = self.componentName!
        }
        if self.nodeSelector != nil {
            map["NodeSelector"] = self.nodeSelector?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApplicationName") {
            self.applicationName = dict["ApplicationName"] as! String
        }
        if dict.keys.contains("ComponentName") {
            self.componentName = dict["ComponentName"] as! String
        }
        if dict.keys.contains("NodeSelector") {
            var model = ComponentLayout.NodeSelector()
            model.fromMap(dict["NodeSelector"] as! [String: Any])
            self.nodeSelector = model
        }
    }
}

public class ConfigEffectActions : Tea.TeaModel {
    public var configEffectAction: String?

    public var configFiles: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configEffectAction != nil {
            map["ConfigEffectAction"] = self.configEffectAction!
        }
        if self.configFiles != nil {
            map["ConfigFiles"] = self.configFiles!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConfigEffectAction") {
            self.configEffectAction = dict["ConfigEffectAction"] as! String
        }
        if dict.keys.contains("ConfigFiles") {
            self.configFiles = dict["ConfigFiles"] as! [String]
        }
    }
}

public class ConvertNodeGroup : Tea.TeaModel {
    public var nodeGroupId: String?

    public var paymentDuration: Int32?

    public var paymentDurationUnit: String?

    public var paymentType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nodeGroupId != nil {
            map["NodeGroupId"] = self.nodeGroupId!
        }
        if self.paymentDuration != nil {
            map["PaymentDuration"] = self.paymentDuration!
        }
        if self.paymentDurationUnit != nil {
            map["PaymentDurationUnit"] = self.paymentDurationUnit!
        }
        if self.paymentType != nil {
            map["PaymentType"] = self.paymentType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NodeGroupId") {
            self.nodeGroupId = dict["NodeGroupId"] as! String
        }
        if dict.keys.contains("PaymentDuration") {
            self.paymentDuration = dict["PaymentDuration"] as! Int32
        }
        if dict.keys.contains("PaymentDurationUnit") {
            self.paymentDurationUnit = dict["PaymentDurationUnit"] as! String
        }
        if dict.keys.contains("PaymentType") {
            self.paymentType = dict["PaymentType"] as! String
        }
    }
}

public class ConvertNodeGroupParam : Tea.TeaModel {
    public var nodeGroupId: String?

    public var paymentDuration: Int64?

    public var paymentDurationUnit: String?

    public var paymentType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nodeGroupId != nil {
            map["NodeGroupId"] = self.nodeGroupId!
        }
        if self.paymentDuration != nil {
            map["PaymentDuration"] = self.paymentDuration!
        }
        if self.paymentDurationUnit != nil {
            map["PaymentDurationUnit"] = self.paymentDurationUnit!
        }
        if self.paymentType != nil {
            map["PaymentType"] = self.paymentType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NodeGroupId") {
            self.nodeGroupId = dict["NodeGroupId"] as! String
        }
        if dict.keys.contains("PaymentDuration") {
            self.paymentDuration = dict["PaymentDuration"] as! Int64
        }
        if dict.keys.contains("PaymentDurationUnit") {
            self.paymentDurationUnit = dict["PaymentDurationUnit"] as! String
        }
        if dict.keys.contains("PaymentType") {
            self.paymentType = dict["PaymentType"] as! String
        }
    }
}

public class CostOptimizedConfig : Tea.TeaModel {
    public var onDemandBaseCapacity: Int32?

    public var onDemandPercentageAboveBaseCapacity: Int32?

    public var spotInstancePools: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.onDemandBaseCapacity != nil {
            map["OnDemandBaseCapacity"] = self.onDemandBaseCapacity!
        }
        if self.onDemandPercentageAboveBaseCapacity != nil {
            map["OnDemandPercentageAboveBaseCapacity"] = self.onDemandPercentageAboveBaseCapacity!
        }
        if self.spotInstancePools != nil {
            map["SpotInstancePools"] = self.spotInstancePools!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OnDemandBaseCapacity") {
            self.onDemandBaseCapacity = dict["OnDemandBaseCapacity"] as! Int32
        }
        if dict.keys.contains("OnDemandPercentageAboveBaseCapacity") {
            self.onDemandPercentageAboveBaseCapacity = dict["OnDemandPercentageAboveBaseCapacity"] as! Int32
        }
        if dict.keys.contains("SpotInstancePools") {
            self.spotInstancePools = dict["SpotInstancePools"] as! Int32
        }
    }
}

public class CreateNodeGroupParam : Tea.TeaModel {
    public var autoRenew: Bool?

    public var autoRenewDuration: Int32?

    public var autoRenewDurationUnit: String?

    public var dataDisks: [DiskInfo]?

    public var instanceTypes: [String]?

    public var nodeCount: Int32?

    public var nodeGroupName: String?

    public var nodeGroupType: String?

    public var nodeKeyPairName: String?

    public var nodeRamRole: String?

    public var nodeRootPassword: String?

    public var paymentDuration: Int32?

    public var paymentDurationUnit: String?

    public var paymentType: String?

    public var securityGroupId: String?

    public var spotStrategy: String?

    public var systemDisk: SystemDiskParam?

    public var vSwitchIds: [String]?

    public var withPublicIp: Bool?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.systemDisk?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoRenew != nil {
            map["AutoRenew"] = self.autoRenew!
        }
        if self.autoRenewDuration != nil {
            map["AutoRenewDuration"] = self.autoRenewDuration!
        }
        if self.autoRenewDurationUnit != nil {
            map["AutoRenewDurationUnit"] = self.autoRenewDurationUnit!
        }
        if self.dataDisks != nil {
            var tmp : [Any] = []
            for k in self.dataDisks! {
                tmp.append(k.toMap())
            }
            map["DataDisks"] = tmp
        }
        if self.instanceTypes != nil {
            map["InstanceTypes"] = self.instanceTypes!
        }
        if self.nodeCount != nil {
            map["NodeCount"] = self.nodeCount!
        }
        if self.nodeGroupName != nil {
            map["NodeGroupName"] = self.nodeGroupName!
        }
        if self.nodeGroupType != nil {
            map["NodeGroupType"] = self.nodeGroupType!
        }
        if self.nodeKeyPairName != nil {
            map["NodeKeyPairName"] = self.nodeKeyPairName!
        }
        if self.nodeRamRole != nil {
            map["NodeRamRole"] = self.nodeRamRole!
        }
        if self.nodeRootPassword != nil {
            map["NodeRootPassword"] = self.nodeRootPassword!
        }
        if self.paymentDuration != nil {
            map["PaymentDuration"] = self.paymentDuration!
        }
        if self.paymentDurationUnit != nil {
            map["PaymentDurationUnit"] = self.paymentDurationUnit!
        }
        if self.paymentType != nil {
            map["PaymentType"] = self.paymentType!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.spotStrategy != nil {
            map["SpotStrategy"] = self.spotStrategy!
        }
        if self.systemDisk != nil {
            map["SystemDisk"] = self.systemDisk?.toMap()
        }
        if self.vSwitchIds != nil {
            map["VSwitchIds"] = self.vSwitchIds!
        }
        if self.withPublicIp != nil {
            map["WithPublicIp"] = self.withPublicIp!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoRenew") {
            self.autoRenew = dict["AutoRenew"] as! Bool
        }
        if dict.keys.contains("AutoRenewDuration") {
            self.autoRenewDuration = dict["AutoRenewDuration"] as! Int32
        }
        if dict.keys.contains("AutoRenewDurationUnit") {
            self.autoRenewDurationUnit = dict["AutoRenewDurationUnit"] as! String
        }
        if dict.keys.contains("DataDisks") {
            var tmp : [DiskInfo] = []
            for v in dict["DataDisks"] as! [Any] {
                var model = DiskInfo()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.dataDisks = tmp
        }
        if dict.keys.contains("InstanceTypes") {
            self.instanceTypes = dict["InstanceTypes"] as! [String]
        }
        if dict.keys.contains("NodeCount") {
            self.nodeCount = dict["NodeCount"] as! Int32
        }
        if dict.keys.contains("NodeGroupName") {
            self.nodeGroupName = dict["NodeGroupName"] as! String
        }
        if dict.keys.contains("NodeGroupType") {
            self.nodeGroupType = dict["NodeGroupType"] as! String
        }
        if dict.keys.contains("NodeKeyPairName") {
            self.nodeKeyPairName = dict["NodeKeyPairName"] as! String
        }
        if dict.keys.contains("NodeRamRole") {
            self.nodeRamRole = dict["NodeRamRole"] as! String
        }
        if dict.keys.contains("NodeRootPassword") {
            self.nodeRootPassword = dict["NodeRootPassword"] as! String
        }
        if dict.keys.contains("PaymentDuration") {
            self.paymentDuration = dict["PaymentDuration"] as! Int32
        }
        if dict.keys.contains("PaymentDurationUnit") {
            self.paymentDurationUnit = dict["PaymentDurationUnit"] as! String
        }
        if dict.keys.contains("PaymentType") {
            self.paymentType = dict["PaymentType"] as! String
        }
        if dict.keys.contains("SecurityGroupId") {
            self.securityGroupId = dict["SecurityGroupId"] as! String
        }
        if dict.keys.contains("SpotStrategy") {
            self.spotStrategy = dict["SpotStrategy"] as! String
        }
        if dict.keys.contains("SystemDisk") {
            var model = SystemDiskParam()
            model.fromMap(dict["SystemDisk"] as! [String: Any])
            self.systemDisk = model
        }
        if dict.keys.contains("VSwitchIds") {
            self.vSwitchIds = dict["VSwitchIds"] as! [String]
        }
        if dict.keys.contains("WithPublicIp") {
            self.withPublicIp = dict["WithPublicIp"] as! Bool
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! String
        }
    }
}

public class DataDisk : Tea.TeaModel {
    public var category: String?

    public var count: Int32?

    public var performanceLevel: String?

    public var size: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.category != nil {
            map["Category"] = self.category!
        }
        if self.count != nil {
            map["Count"] = self.count!
        }
        if self.performanceLevel != nil {
            map["PerformanceLevel"] = self.performanceLevel!
        }
        if self.size != nil {
            map["Size"] = self.size!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Category") {
            self.category = dict["Category"] as! String
        }
        if dict.keys.contains("Count") {
            self.count = dict["Count"] as! Int32
        }
        if dict.keys.contains("PerformanceLevel") {
            self.performanceLevel = dict["PerformanceLevel"] as! String
        }
        if dict.keys.contains("Size") {
            self.size = dict["Size"] as! Int32
        }
    }
}

public class DecreaseNodeGroupParam : Tea.TeaModel {
    public var nodeGroupId: String?

    public var releaseInstanceIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nodeGroupId != nil {
            map["NodeGroupId"] = self.nodeGroupId!
        }
        if self.releaseInstanceIds != nil {
            map["ReleaseInstanceIds"] = self.releaseInstanceIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NodeGroupId") {
            self.nodeGroupId = dict["NodeGroupId"] as! String
        }
        if dict.keys.contains("ReleaseInstanceIds") {
            self.releaseInstanceIds = dict["ReleaseInstanceIds"] as! [String]
        }
    }
}

public class DeploymentLayout : Tea.TeaModel {
    public var applicationName: String?

    public var componentName: String?

    public var nodeSelector: NodeSelector?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.nodeSelector?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationName != nil {
            map["ApplicationName"] = self.applicationName!
        }
        if self.componentName != nil {
            map["ComponentName"] = self.componentName!
        }
        if self.nodeSelector != nil {
            map["NodeSelector"] = self.nodeSelector?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApplicationName") {
            self.applicationName = dict["ApplicationName"] as! String
        }
        if dict.keys.contains("ComponentName") {
            self.componentName = dict["ComponentName"] as! String
        }
        if dict.keys.contains("NodeSelector") {
            var model = NodeSelector()
            model.fromMap(dict["NodeSelector"] as! [String: Any])
            self.nodeSelector = model
        }
    }
}

public class DeploymentSetConstraints : Tea.TeaModel {
    public var defaultValue: String?

    public var enableState: String?

    public var replacementStrategy: ReplacementStrategy?

    public var values: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.replacementStrategy?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.defaultValue != nil {
            map["DefaultValue"] = self.defaultValue!
        }
        if self.enableState != nil {
            map["EnableState"] = self.enableState!
        }
        if self.replacementStrategy != nil {
            map["ReplacementStrategy"] = self.replacementStrategy?.toMap()
        }
        if self.values != nil {
            map["Values"] = self.values!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DefaultValue") {
            self.defaultValue = dict["DefaultValue"] as! String
        }
        if dict.keys.contains("EnableState") {
            self.enableState = dict["EnableState"] as! String
        }
        if dict.keys.contains("ReplacementStrategy") {
            var model = ReplacementStrategy()
            model.fromMap(dict["ReplacementStrategy"] as! [String: Any])
            self.replacementStrategy = model
        }
        if dict.keys.contains("Values") {
            self.values = dict["Values"] as! [String]
        }
    }
}

public class Disk : Tea.TeaModel {
    public var category: String?

    public var count: Int32?

    public var performanceLevel: String?

    public var size: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.category != nil {
            map["Category"] = self.category!
        }
        if self.count != nil {
            map["Count"] = self.count!
        }
        if self.performanceLevel != nil {
            map["PerformanceLevel"] = self.performanceLevel!
        }
        if self.size != nil {
            map["Size"] = self.size!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Category") {
            self.category = dict["Category"] as! String
        }
        if dict.keys.contains("Count") {
            self.count = dict["Count"] as! Int32
        }
        if dict.keys.contains("PerformanceLevel") {
            self.performanceLevel = dict["PerformanceLevel"] as! String
        }
        if dict.keys.contains("Size") {
            self.size = dict["Size"] as! Int32
        }
    }
}

public class DiskConstraints : Tea.TeaModel {
    public var categories: [String]?

    public var countConstraint: ValueConstraints?

    public var sizeConstraint: ValueConstraints?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.countConstraint?.validate()
        try self.sizeConstraint?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.categories != nil {
            map["Categories"] = self.categories!
        }
        if self.countConstraint != nil {
            map["CountConstraint"] = self.countConstraint?.toMap()
        }
        if self.sizeConstraint != nil {
            map["SizeConstraint"] = self.sizeConstraint?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Categories") {
            self.categories = dict["Categories"] as! [String]
        }
        if dict.keys.contains("CountConstraint") {
            var model = ValueConstraints()
            model.fromMap(dict["CountConstraint"] as! [String: Any])
            self.countConstraint = model
        }
        if dict.keys.contains("SizeConstraint") {
            var model = ValueConstraints()
            model.fromMap(dict["SizeConstraint"] as! [String: Any])
            self.sizeConstraint = model
        }
    }
}

public class DiskInfo : Tea.TeaModel {
    public var category: String?

    public var count: Int32?

    public var performanceLevel: String?

    public var size: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.category != nil {
            map["Category"] = self.category!
        }
        if self.count != nil {
            map["Count"] = self.count!
        }
        if self.performanceLevel != nil {
            map["PerformanceLevel"] = self.performanceLevel!
        }
        if self.size != nil {
            map["Size"] = self.size!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Category") {
            self.category = dict["Category"] as! String
        }
        if dict.keys.contains("Count") {
            self.count = dict["Count"] as! Int32
        }
        if dict.keys.contains("PerformanceLevel") {
            self.performanceLevel = dict["PerformanceLevel"] as! String
        }
        if dict.keys.contains("Size") {
            self.size = dict["Size"] as! Int32
        }
    }
}

public class DiskSize : Tea.TeaModel {
    public var category: String?

    public var size: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.category != nil {
            map["Category"] = self.category!
        }
        if self.size != nil {
            map["Size"] = self.size!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Category") {
            self.category = dict["Category"] as! String
        }
        if dict.keys.contains("Size") {
            self.size = dict["Size"] as! Int32
        }
    }
}

public class FailedReason : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class HealthSummary : Tea.TeaModel {
    public var badCount: Int64?

    public var goodCount: Int64?

    public var noneCount: Int64?

    public var stoppedCount: Int64?

    public var totalCount: Int64?

    public var unknownCount: Int64?

    public var warningCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.badCount != nil {
            map["BadCount"] = self.badCount!
        }
        if self.goodCount != nil {
            map["GoodCount"] = self.goodCount!
        }
        if self.noneCount != nil {
            map["NoneCount"] = self.noneCount!
        }
        if self.stoppedCount != nil {
            map["StoppedCount"] = self.stoppedCount!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.unknownCount != nil {
            map["UnknownCount"] = self.unknownCount!
        }
        if self.warningCount != nil {
            map["WarningCount"] = self.warningCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BadCount") {
            self.badCount = dict["BadCount"] as! Int64
        }
        if dict.keys.contains("GoodCount") {
            self.goodCount = dict["GoodCount"] as! Int64
        }
        if dict.keys.contains("NoneCount") {
            self.noneCount = dict["NoneCount"] as! Int64
        }
        if dict.keys.contains("StoppedCount") {
            self.stoppedCount = dict["StoppedCount"] as! Int64
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
        if dict.keys.contains("UnknownCount") {
            self.unknownCount = dict["UnknownCount"] as! Int64
        }
        if dict.keys.contains("WarningCount") {
            self.warningCount = dict["WarningCount"] as! Int64
        }
    }
}

public class IncreaseNodeGroup : Tea.TeaModel {
    public var description_: String?

    public var nodeCount: Int32?

    public var nodeGroupId: String?

    public var paymentDuration: Int32?

    public var paymentDurationUnit: String?

    public var vSwitchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.nodeCount != nil {
            map["NodeCount"] = self.nodeCount!
        }
        if self.nodeGroupId != nil {
            map["NodeGroupId"] = self.nodeGroupId!
        }
        if self.paymentDuration != nil {
            map["PaymentDuration"] = self.paymentDuration!
        }
        if self.paymentDurationUnit != nil {
            map["PaymentDurationUnit"] = self.paymentDurationUnit!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("NodeCount") {
            self.nodeCount = dict["NodeCount"] as! Int32
        }
        if dict.keys.contains("NodeGroupId") {
            self.nodeGroupId = dict["NodeGroupId"] as! String
        }
        if dict.keys.contains("PaymentDuration") {
            self.paymentDuration = dict["PaymentDuration"] as! Int32
        }
        if dict.keys.contains("PaymentDurationUnit") {
            self.paymentDurationUnit = dict["PaymentDurationUnit"] as! String
        }
        if dict.keys.contains("VSwitchId") {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
    }
}

public class IncreaseNodeGroupParam : Tea.TeaModel {
    public var nodeCount: Int64?

    public var nodeGroupId: String?

    public var paymentDuration: Int32?

    public var paymentDurationUnit: String?

    public var vSwitchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nodeCount != nil {
            map["NodeCount"] = self.nodeCount!
        }
        if self.nodeGroupId != nil {
            map["NodeGroupId"] = self.nodeGroupId!
        }
        if self.paymentDuration != nil {
            map["PaymentDuration"] = self.paymentDuration!
        }
        if self.paymentDurationUnit != nil {
            map["PaymentDurationUnit"] = self.paymentDurationUnit!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NodeCount") {
            self.nodeCount = dict["NodeCount"] as! Int64
        }
        if dict.keys.contains("NodeGroupId") {
            self.nodeGroupId = dict["NodeGroupId"] as! String
        }
        if dict.keys.contains("PaymentDuration") {
            self.paymentDuration = dict["PaymentDuration"] as! Int32
        }
        if dict.keys.contains("PaymentDurationUnit") {
            self.paymentDurationUnit = dict["PaymentDurationUnit"] as! String
        }
        if dict.keys.contains("VSwitchId") {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
    }
}

public class InstanceCategory : Tea.TeaModel {
    public var defaultValue: String?

    public var keys: [String]?

    public var values: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.defaultValue != nil {
            map["DefaultValue"] = self.defaultValue!
        }
        if self.keys != nil {
            map["Keys"] = self.keys!
        }
        if self.values != nil {
            map["Values"] = self.values!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DefaultValue") {
            self.defaultValue = dict["DefaultValue"] as! String
        }
        if dict.keys.contains("Keys") {
            self.keys = dict["Keys"] as! [String]
        }
        if dict.keys.contains("Values") {
            self.values = dict["Values"] as! [String]
        }
    }
}

public class InstanceType : Tea.TeaModel {
    public var cpuArchitecture: String?

    public var cpuCore: Int32?

    public var instanceCategory: String?

    public var instanceType: String?

    public var instanceTypeFamily: String?

    public var localStorageAmount: Int32?

    public var localStorageCapacity: Int64?

    public var optimized: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cpuArchitecture != nil {
            map["CpuArchitecture"] = self.cpuArchitecture!
        }
        if self.cpuCore != nil {
            map["CpuCore"] = self.cpuCore!
        }
        if self.instanceCategory != nil {
            map["InstanceCategory"] = self.instanceCategory!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.instanceTypeFamily != nil {
            map["InstanceTypeFamily"] = self.instanceTypeFamily!
        }
        if self.localStorageAmount != nil {
            map["LocalStorageAmount"] = self.localStorageAmount!
        }
        if self.localStorageCapacity != nil {
            map["LocalStorageCapacity"] = self.localStorageCapacity!
        }
        if self.optimized != nil {
            map["Optimized"] = self.optimized!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CpuArchitecture") {
            self.cpuArchitecture = dict["CpuArchitecture"] as! String
        }
        if dict.keys.contains("CpuCore") {
            self.cpuCore = dict["CpuCore"] as! Int32
        }
        if dict.keys.contains("InstanceCategory") {
            self.instanceCategory = dict["InstanceCategory"] as! String
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("InstanceTypeFamily") {
            self.instanceTypeFamily = dict["InstanceTypeFamily"] as! String
        }
        if dict.keys.contains("LocalStorageAmount") {
            self.localStorageAmount = dict["LocalStorageAmount"] as! Int32
        }
        if dict.keys.contains("LocalStorageCapacity") {
            self.localStorageCapacity = dict["LocalStorageCapacity"] as! Int64
        }
        if dict.keys.contains("Optimized") {
            self.optimized = dict["Optimized"] as! Bool
        }
    }
}

public class KeyValue : Tea.TeaModel {
    public var key: String?

    public var value: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.key != nil {
            map["Key"] = self.key!
        }
        if self.value != nil {
            map["Value"] = self.value!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Key") {
            self.key = dict["Key"] as! String
        }
        if dict.keys.contains("Value") {
            self.value = dict["Value"] as! String
        }
    }
}

public class ListApiTemplatesDTO : Tea.TeaModel {
    public var apiName: String?

    public var content: String?

    public var gmtCreate: Int64?

    public var gmtModified: Int64?

    public var id: Int64?

    public var operatorId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var status: String?

    public var templateId: String?

    public var templateName: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiName != nil {
            map["ApiName"] = self.apiName!
        }
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.gmtCreate != nil {
            map["GmtCreate"] = self.gmtCreate!
        }
        if self.gmtModified != nil {
            map["GmtModified"] = self.gmtModified!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.operatorId != nil {
            map["OperatorId"] = self.operatorId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.templateName != nil {
            map["TemplateName"] = self.templateName!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiName") {
            self.apiName = dict["ApiName"] as! String
        }
        if dict.keys.contains("Content") {
            self.content = dict["Content"] as! String
        }
        if dict.keys.contains("GmtCreate") {
            self.gmtCreate = dict["GmtCreate"] as! Int64
        }
        if dict.keys.contains("GmtModified") {
            self.gmtModified = dict["GmtModified"] as! Int64
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("OperatorId") {
            self.operatorId = dict["OperatorId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("TemplateName") {
            self.templateName = dict["TemplateName"] as! String
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class MetaStoreConf : Tea.TeaModel {
    public var dbPassword: String?

    public var dbUrl: String?

    public var dbUserName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dbPassword != nil {
            map["DbPassword"] = self.dbPassword!
        }
        if self.dbUrl != nil {
            map["DbUrl"] = self.dbUrl!
        }
        if self.dbUserName != nil {
            map["DbUserName"] = self.dbUserName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DbPassword") {
            self.dbPassword = dict["DbPassword"] as! String
        }
        if dict.keys.contains("DbUrl") {
            self.dbUrl = dict["DbUrl"] as! String
        }
        if dict.keys.contains("DbUserName") {
            self.dbUserName = dict["DbUserName"] as! String
        }
    }
}

public class MetricUnitValue : Tea.TeaModel {
    public var metricName: String?

    public var metricUnit: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.metricName != nil {
            map["MetricName"] = self.metricName!
        }
        if self.metricUnit != nil {
            map["MetricUnit"] = self.metricUnit!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MetricName") {
            self.metricName = dict["MetricName"] as! String
        }
        if dict.keys.contains("MetricUnit") {
            self.metricUnit = dict["MetricUnit"] as! String
        }
    }
}

public class MetricsTrigger : Tea.TeaModel {
    public var conditionLogicOperator: String?

    public var conditions: [TriggerCondition]?

    public var coolDownInterval: Int32?

    public var evaluationCount: Int32?

    public var timeConstraints: [TimeConstraint]?

    public var timeWindow: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.conditionLogicOperator != nil {
            map["ConditionLogicOperator"] = self.conditionLogicOperator!
        }
        if self.conditions != nil {
            var tmp : [Any] = []
            for k in self.conditions! {
                tmp.append(k.toMap())
            }
            map["Conditions"] = tmp
        }
        if self.coolDownInterval != nil {
            map["CoolDownInterval"] = self.coolDownInterval!
        }
        if self.evaluationCount != nil {
            map["EvaluationCount"] = self.evaluationCount!
        }
        if self.timeConstraints != nil {
            var tmp : [Any] = []
            for k in self.timeConstraints! {
                tmp.append(k.toMap())
            }
            map["TimeConstraints"] = tmp
        }
        if self.timeWindow != nil {
            map["TimeWindow"] = self.timeWindow!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConditionLogicOperator") {
            self.conditionLogicOperator = dict["ConditionLogicOperator"] as! String
        }
        if dict.keys.contains("Conditions") {
            var tmp : [TriggerCondition] = []
            for v in dict["Conditions"] as! [Any] {
                var model = TriggerCondition()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.conditions = tmp
        }
        if dict.keys.contains("CoolDownInterval") {
            self.coolDownInterval = dict["CoolDownInterval"] as! Int32
        }
        if dict.keys.contains("EvaluationCount") {
            self.evaluationCount = dict["EvaluationCount"] as! Int32
        }
        if dict.keys.contains("TimeConstraints") {
            var tmp : [TimeConstraint] = []
            for v in dict["TimeConstraints"] as! [Any] {
                var model = TimeConstraint()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.timeConstraints = tmp
        }
        if dict.keys.contains("TimeWindow") {
            self.timeWindow = dict["TimeWindow"] as! Int32
        }
    }
}

public class Node : Tea.TeaModel {
    public var autoRenew: Bool?

    public var autoRenewDuration: Int32?

    public var autoRenewDurationUnit: String?

    public var createTime: Int64?

    public var expireTime: Int64?

    public var instanceType: String?

    public var maintenanceStatus: String?

    public var nodeGroupId: String?

    public var nodeGroupType: String?

    public var nodeId: String?

    public var nodeName: String?

    public var nodeState: String?

    public var privateIp: String?

    public var publicIp: String?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoRenew != nil {
            map["AutoRenew"] = self.autoRenew!
        }
        if self.autoRenewDuration != nil {
            map["AutoRenewDuration"] = self.autoRenewDuration!
        }
        if self.autoRenewDurationUnit != nil {
            map["AutoRenewDurationUnit"] = self.autoRenewDurationUnit!
        }
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.expireTime != nil {
            map["ExpireTime"] = self.expireTime!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.maintenanceStatus != nil {
            map["MaintenanceStatus"] = self.maintenanceStatus!
        }
        if self.nodeGroupId != nil {
            map["NodeGroupId"] = self.nodeGroupId!
        }
        if self.nodeGroupType != nil {
            map["NodeGroupType"] = self.nodeGroupType!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.nodeName != nil {
            map["NodeName"] = self.nodeName!
        }
        if self.nodeState != nil {
            map["NodeState"] = self.nodeState!
        }
        if self.privateIp != nil {
            map["PrivateIp"] = self.privateIp!
        }
        if self.publicIp != nil {
            map["PublicIp"] = self.publicIp!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoRenew") {
            self.autoRenew = dict["AutoRenew"] as! Bool
        }
        if dict.keys.contains("AutoRenewDuration") {
            self.autoRenewDuration = dict["AutoRenewDuration"] as! Int32
        }
        if dict.keys.contains("AutoRenewDurationUnit") {
            self.autoRenewDurationUnit = dict["AutoRenewDurationUnit"] as! String
        }
        if dict.keys.contains("CreateTime") {
            self.createTime = dict["CreateTime"] as! Int64
        }
        if dict.keys.contains("ExpireTime") {
            self.expireTime = dict["ExpireTime"] as! Int64
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("MaintenanceStatus") {
            self.maintenanceStatus = dict["MaintenanceStatus"] as! String
        }
        if dict.keys.contains("NodeGroupId") {
            self.nodeGroupId = dict["NodeGroupId"] as! String
        }
        if dict.keys.contains("NodeGroupType") {
            self.nodeGroupType = dict["NodeGroupType"] as! String
        }
        if dict.keys.contains("NodeId") {
            self.nodeId = dict["NodeId"] as! String
        }
        if dict.keys.contains("NodeName") {
            self.nodeName = dict["NodeName"] as! String
        }
        if dict.keys.contains("NodeState") {
            self.nodeState = dict["NodeState"] as! String
        }
        if dict.keys.contains("PrivateIp") {
            self.privateIp = dict["PrivateIp"] as! String
        }
        if dict.keys.contains("PublicIp") {
            self.publicIp = dict["PublicIp"] as! String
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! String
        }
    }
}

public class NodeAttributes : Tea.TeaModel {
    public var keyPairName: String?

    public var masterRootPassword: String?

    public var ramRole: String?

    public var securityGroupId: String?

    public var vpcId: String?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.keyPairName != nil {
            map["KeyPairName"] = self.keyPairName!
        }
        if self.masterRootPassword != nil {
            map["MasterRootPassword"] = self.masterRootPassword!
        }
        if self.ramRole != nil {
            map["RamRole"] = self.ramRole!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("KeyPairName") {
            self.keyPairName = dict["KeyPairName"] as! String
        }
        if dict.keys.contains("MasterRootPassword") {
            self.masterRootPassword = dict["MasterRootPassword"] as! String
        }
        if dict.keys.contains("RamRole") {
            self.ramRole = dict["RamRole"] as! String
        }
        if dict.keys.contains("SecurityGroupId") {
            self.securityGroupId = dict["SecurityGroupId"] as! String
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! String
        }
    }
}

public class NodeCountConstraint : Tea.TeaModel {
    public var max: Int32?

    public var min: Int32?

    public var type: String?

    public var values: [Int32]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.max != nil {
            map["Max"] = self.max!
        }
        if self.min != nil {
            map["Min"] = self.min!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.values != nil {
            map["Values"] = self.values!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Max") {
            self.max = dict["Max"] as! Int32
        }
        if dict.keys.contains("Min") {
            self.min = dict["Min"] as! Int32
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("Values") {
            self.values = dict["Values"] as! [Int32]
        }
    }
}

public class NodeGroup : Tea.TeaModel {
    public var additionalSecurityGroupIds: [String]?

    public var costOptimizedConfig: CostOptimizedConfig?

    public var dataDisks: [DataDisk]?

    public var deploymentSetStrategy: String?

    public var gracefulShutdown: Bool?

    public var instanceTypes: [String]?

    public var nodeGroupId: String?

    public var nodeGroupName: String?

    public var nodeGroupState: String?

    public var nodeGroupType: String?

    public var nodeResizeStrategy: String?

    public var paymentType: String?

    public var runningNodeCount: Int32?

    public var spotBidPrices: [SpotBidPrice]?

    public var spotInstanceRemedy: Bool?

    public var spotStrategy: String?

    public var stateChangeReason: NodeGroupStateChangeReason?

    public var status: String?

    public var systemDisk: SystemDisk?

    public var vSwitchIds: [String]?

    public var withPublicIp: Bool?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.costOptimizedConfig?.validate()
        try self.stateChangeReason?.validate()
        try self.systemDisk?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.additionalSecurityGroupIds != nil {
            map["AdditionalSecurityGroupIds"] = self.additionalSecurityGroupIds!
        }
        if self.costOptimizedConfig != nil {
            map["CostOptimizedConfig"] = self.costOptimizedConfig?.toMap()
        }
        if self.dataDisks != nil {
            var tmp : [Any] = []
            for k in self.dataDisks! {
                tmp.append(k.toMap())
            }
            map["DataDisks"] = tmp
        }
        if self.deploymentSetStrategy != nil {
            map["DeploymentSetStrategy"] = self.deploymentSetStrategy!
        }
        if self.gracefulShutdown != nil {
            map["GracefulShutdown"] = self.gracefulShutdown!
        }
        if self.instanceTypes != nil {
            map["InstanceTypes"] = self.instanceTypes!
        }
        if self.nodeGroupId != nil {
            map["NodeGroupId"] = self.nodeGroupId!
        }
        if self.nodeGroupName != nil {
            map["NodeGroupName"] = self.nodeGroupName!
        }
        if self.nodeGroupState != nil {
            map["NodeGroupState"] = self.nodeGroupState!
        }
        if self.nodeGroupType != nil {
            map["NodeGroupType"] = self.nodeGroupType!
        }
        if self.nodeResizeStrategy != nil {
            map["NodeResizeStrategy"] = self.nodeResizeStrategy!
        }
        if self.paymentType != nil {
            map["PaymentType"] = self.paymentType!
        }
        if self.runningNodeCount != nil {
            map["RunningNodeCount"] = self.runningNodeCount!
        }
        if self.spotBidPrices != nil {
            var tmp : [Any] = []
            for k in self.spotBidPrices! {
                tmp.append(k.toMap())
            }
            map["SpotBidPrices"] = tmp
        }
        if self.spotInstanceRemedy != nil {
            map["SpotInstanceRemedy"] = self.spotInstanceRemedy!
        }
        if self.spotStrategy != nil {
            map["SpotStrategy"] = self.spotStrategy!
        }
        if self.stateChangeReason != nil {
            map["StateChangeReason"] = self.stateChangeReason?.toMap()
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.systemDisk != nil {
            map["SystemDisk"] = self.systemDisk?.toMap()
        }
        if self.vSwitchIds != nil {
            map["VSwitchIds"] = self.vSwitchIds!
        }
        if self.withPublicIp != nil {
            map["WithPublicIp"] = self.withPublicIp!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AdditionalSecurityGroupIds") {
            self.additionalSecurityGroupIds = dict["AdditionalSecurityGroupIds"] as! [String]
        }
        if dict.keys.contains("CostOptimizedConfig") {
            var model = CostOptimizedConfig()
            model.fromMap(dict["CostOptimizedConfig"] as! [String: Any])
            self.costOptimizedConfig = model
        }
        if dict.keys.contains("DataDisks") {
            var tmp : [DataDisk] = []
            for v in dict["DataDisks"] as! [Any] {
                var model = DataDisk()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.dataDisks = tmp
        }
        if dict.keys.contains("DeploymentSetStrategy") {
            self.deploymentSetStrategy = dict["DeploymentSetStrategy"] as! String
        }
        if dict.keys.contains("GracefulShutdown") {
            self.gracefulShutdown = dict["GracefulShutdown"] as! Bool
        }
        if dict.keys.contains("InstanceTypes") {
            self.instanceTypes = dict["InstanceTypes"] as! [String]
        }
        if dict.keys.contains("NodeGroupId") {
            self.nodeGroupId = dict["NodeGroupId"] as! String
        }
        if dict.keys.contains("NodeGroupName") {
            self.nodeGroupName = dict["NodeGroupName"] as! String
        }
        if dict.keys.contains("NodeGroupState") {
            self.nodeGroupState = dict["NodeGroupState"] as! String
        }
        if dict.keys.contains("NodeGroupType") {
            self.nodeGroupType = dict["NodeGroupType"] as! String
        }
        if dict.keys.contains("NodeResizeStrategy") {
            self.nodeResizeStrategy = dict["NodeResizeStrategy"] as! String
        }
        if dict.keys.contains("PaymentType") {
            self.paymentType = dict["PaymentType"] as! String
        }
        if dict.keys.contains("RunningNodeCount") {
            self.runningNodeCount = dict["RunningNodeCount"] as! Int32
        }
        if dict.keys.contains("SpotBidPrices") {
            var tmp : [SpotBidPrice] = []
            for v in dict["SpotBidPrices"] as! [Any] {
                var model = SpotBidPrice()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.spotBidPrices = tmp
        }
        if dict.keys.contains("SpotInstanceRemedy") {
            self.spotInstanceRemedy = dict["SpotInstanceRemedy"] as! Bool
        }
        if dict.keys.contains("SpotStrategy") {
            self.spotStrategy = dict["SpotStrategy"] as! String
        }
        if dict.keys.contains("StateChangeReason") {
            var model = NodeGroupStateChangeReason()
            model.fromMap(dict["StateChangeReason"] as! [String: Any])
            self.stateChangeReason = model
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("SystemDisk") {
            var model = SystemDisk()
            model.fromMap(dict["SystemDisk"] as! [String: Any])
            self.systemDisk = model
        }
        if dict.keys.contains("VSwitchIds") {
            self.vSwitchIds = dict["VSwitchIds"] as! [String]
        }
        if dict.keys.contains("WithPublicIp") {
            self.withPublicIp = dict["WithPublicIp"] as! Bool
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! String
        }
    }
}

public class NodeGroupConfig : Tea.TeaModel {
    public var additionalSecurityGroupIds: [String]?

    public var componentTags: [String]?

    public var costOptimizedConfig: CostOptimizedConfig?

    public var dataDisks: [DataDisk]?

    public var deploymentSetStrategy: String?

    public var gracefulShutdown: Bool?

    public var instanceTypes: [String]?

    public var nodeCount: Int32?

    public var nodeGroupName: String?

    public var nodeGroupType: String?

    public var nodeResizeStrategy: String?

    public var paymentType: String?

    public var spotBidPrices: [SpotBidPrice]?

    public var spotInstanceRemedy: Bool?

    public var spotStrategy: String?

    public var subscriptionConfig: SubscriptionConfig?

    public var systemDisk: SystemDisk?

    public var vSwitchIds: [String]?

    public var withPublicIp: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.costOptimizedConfig?.validate()
        try self.subscriptionConfig?.validate()
        try self.systemDisk?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.additionalSecurityGroupIds != nil {
            map["AdditionalSecurityGroupIds"] = self.additionalSecurityGroupIds!
        }
        if self.componentTags != nil {
            map["ComponentTags"] = self.componentTags!
        }
        if self.costOptimizedConfig != nil {
            map["CostOptimizedConfig"] = self.costOptimizedConfig?.toMap()
        }
        if self.dataDisks != nil {
            var tmp : [Any] = []
            for k in self.dataDisks! {
                tmp.append(k.toMap())
            }
            map["DataDisks"] = tmp
        }
        if self.deploymentSetStrategy != nil {
            map["DeploymentSetStrategy"] = self.deploymentSetStrategy!
        }
        if self.gracefulShutdown != nil {
            map["GracefulShutdown"] = self.gracefulShutdown!
        }
        if self.instanceTypes != nil {
            map["InstanceTypes"] = self.instanceTypes!
        }
        if self.nodeCount != nil {
            map["NodeCount"] = self.nodeCount!
        }
        if self.nodeGroupName != nil {
            map["NodeGroupName"] = self.nodeGroupName!
        }
        if self.nodeGroupType != nil {
            map["NodeGroupType"] = self.nodeGroupType!
        }
        if self.nodeResizeStrategy != nil {
            map["NodeResizeStrategy"] = self.nodeResizeStrategy!
        }
        if self.paymentType != nil {
            map["PaymentType"] = self.paymentType!
        }
        if self.spotBidPrices != nil {
            var tmp : [Any] = []
            for k in self.spotBidPrices! {
                tmp.append(k.toMap())
            }
            map["SpotBidPrices"] = tmp
        }
        if self.spotInstanceRemedy != nil {
            map["SpotInstanceRemedy"] = self.spotInstanceRemedy!
        }
        if self.spotStrategy != nil {
            map["SpotStrategy"] = self.spotStrategy!
        }
        if self.subscriptionConfig != nil {
            map["SubscriptionConfig"] = self.subscriptionConfig?.toMap()
        }
        if self.systemDisk != nil {
            map["SystemDisk"] = self.systemDisk?.toMap()
        }
        if self.vSwitchIds != nil {
            map["VSwitchIds"] = self.vSwitchIds!
        }
        if self.withPublicIp != nil {
            map["WithPublicIp"] = self.withPublicIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AdditionalSecurityGroupIds") {
            self.additionalSecurityGroupIds = dict["AdditionalSecurityGroupIds"] as! [String]
        }
        if dict.keys.contains("ComponentTags") {
            self.componentTags = dict["ComponentTags"] as! [String]
        }
        if dict.keys.contains("CostOptimizedConfig") {
            var model = CostOptimizedConfig()
            model.fromMap(dict["CostOptimizedConfig"] as! [String: Any])
            self.costOptimizedConfig = model
        }
        if dict.keys.contains("DataDisks") {
            var tmp : [DataDisk] = []
            for v in dict["DataDisks"] as! [Any] {
                var model = DataDisk()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.dataDisks = tmp
        }
        if dict.keys.contains("DeploymentSetStrategy") {
            self.deploymentSetStrategy = dict["DeploymentSetStrategy"] as! String
        }
        if dict.keys.contains("GracefulShutdown") {
            self.gracefulShutdown = dict["GracefulShutdown"] as! Bool
        }
        if dict.keys.contains("InstanceTypes") {
            self.instanceTypes = dict["InstanceTypes"] as! [String]
        }
        if dict.keys.contains("NodeCount") {
            self.nodeCount = dict["NodeCount"] as! Int32
        }
        if dict.keys.contains("NodeGroupName") {
            self.nodeGroupName = dict["NodeGroupName"] as! String
        }
        if dict.keys.contains("NodeGroupType") {
            self.nodeGroupType = dict["NodeGroupType"] as! String
        }
        if dict.keys.contains("NodeResizeStrategy") {
            self.nodeResizeStrategy = dict["NodeResizeStrategy"] as! String
        }
        if dict.keys.contains("PaymentType") {
            self.paymentType = dict["PaymentType"] as! String
        }
        if dict.keys.contains("SpotBidPrices") {
            var tmp : [SpotBidPrice] = []
            for v in dict["SpotBidPrices"] as! [Any] {
                var model = SpotBidPrice()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.spotBidPrices = tmp
        }
        if dict.keys.contains("SpotInstanceRemedy") {
            self.spotInstanceRemedy = dict["SpotInstanceRemedy"] as! Bool
        }
        if dict.keys.contains("SpotStrategy") {
            self.spotStrategy = dict["SpotStrategy"] as! String
        }
        if dict.keys.contains("SubscriptionConfig") {
            var model = SubscriptionConfig()
            model.fromMap(dict["SubscriptionConfig"] as! [String: Any])
            self.subscriptionConfig = model
        }
        if dict.keys.contains("SystemDisk") {
            var model = SystemDisk()
            model.fromMap(dict["SystemDisk"] as! [String: Any])
            self.systemDisk = model
        }
        if dict.keys.contains("VSwitchIds") {
            self.vSwitchIds = dict["VSwitchIds"] as! [String]
        }
        if dict.keys.contains("WithPublicIp") {
            self.withPublicIp = dict["WithPublicIp"] as! Bool
        }
    }
}

public class NodeGroupParam : Tea.TeaModel {
    public var autoPayOrder: Bool?

    public var autoRenew: Bool?

    public var autoRenewDuration: Int32?

    public var autoRenewDurationUnit: String?

    public var dataDisks: [DiskInfo]?

    public var description_: String?

    public var instanceTypes: [String]?

    public var nodeCount: Int32?

    public var nodeGroupIndex: Int32?

    public var nodeGroupName: String?

    public var nodeGroupType: String?

    public var paymentDuration: Int32?

    public var paymentDurationUnit: String?

    public var paymentType: String?

    public var systemDisk: SystemDiskParam?

    public var vSwitchIds: [String]?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.systemDisk?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoPayOrder != nil {
            map["AutoPayOrder"] = self.autoPayOrder!
        }
        if self.autoRenew != nil {
            map["AutoRenew"] = self.autoRenew!
        }
        if self.autoRenewDuration != nil {
            map["AutoRenewDuration"] = self.autoRenewDuration!
        }
        if self.autoRenewDurationUnit != nil {
            map["AutoRenewDurationUnit"] = self.autoRenewDurationUnit!
        }
        if self.dataDisks != nil {
            var tmp : [Any] = []
            for k in self.dataDisks! {
                tmp.append(k.toMap())
            }
            map["DataDisks"] = tmp
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.instanceTypes != nil {
            map["InstanceTypes"] = self.instanceTypes!
        }
        if self.nodeCount != nil {
            map["NodeCount"] = self.nodeCount!
        }
        if self.nodeGroupIndex != nil {
            map["NodeGroupIndex"] = self.nodeGroupIndex!
        }
        if self.nodeGroupName != nil {
            map["NodeGroupName"] = self.nodeGroupName!
        }
        if self.nodeGroupType != nil {
            map["NodeGroupType"] = self.nodeGroupType!
        }
        if self.paymentDuration != nil {
            map["PaymentDuration"] = self.paymentDuration!
        }
        if self.paymentDurationUnit != nil {
            map["PaymentDurationUnit"] = self.paymentDurationUnit!
        }
        if self.paymentType != nil {
            map["PaymentType"] = self.paymentType!
        }
        if self.systemDisk != nil {
            map["SystemDisk"] = self.systemDisk?.toMap()
        }
        if self.vSwitchIds != nil {
            map["VSwitchIds"] = self.vSwitchIds!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoPayOrder") {
            self.autoPayOrder = dict["AutoPayOrder"] as! Bool
        }
        if dict.keys.contains("AutoRenew") {
            self.autoRenew = dict["AutoRenew"] as! Bool
        }
        if dict.keys.contains("AutoRenewDuration") {
            self.autoRenewDuration = dict["AutoRenewDuration"] as! Int32
        }
        if dict.keys.contains("AutoRenewDurationUnit") {
            self.autoRenewDurationUnit = dict["AutoRenewDurationUnit"] as! String
        }
        if dict.keys.contains("DataDisks") {
            var tmp : [DiskInfo] = []
            for v in dict["DataDisks"] as! [Any] {
                var model = DiskInfo()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.dataDisks = tmp
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("InstanceTypes") {
            self.instanceTypes = dict["InstanceTypes"] as! [String]
        }
        if dict.keys.contains("NodeCount") {
            self.nodeCount = dict["NodeCount"] as! Int32
        }
        if dict.keys.contains("NodeGroupIndex") {
            self.nodeGroupIndex = dict["NodeGroupIndex"] as! Int32
        }
        if dict.keys.contains("NodeGroupName") {
            self.nodeGroupName = dict["NodeGroupName"] as! String
        }
        if dict.keys.contains("NodeGroupType") {
            self.nodeGroupType = dict["NodeGroupType"] as! String
        }
        if dict.keys.contains("PaymentDuration") {
            self.paymentDuration = dict["PaymentDuration"] as! Int32
        }
        if dict.keys.contains("PaymentDurationUnit") {
            self.paymentDurationUnit = dict["PaymentDurationUnit"] as! String
        }
        if dict.keys.contains("PaymentType") {
            self.paymentType = dict["PaymentType"] as! String
        }
        if dict.keys.contains("SystemDisk") {
            var model = SystemDiskParam()
            model.fromMap(dict["SystemDisk"] as! [String: Any])
            self.systemDisk = model
        }
        if dict.keys.contains("VSwitchIds") {
            self.vSwitchIds = dict["VSwitchIds"] as! [String]
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! String
        }
    }
}

public class NodeGroupStateChangeReason : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
    }
}

public class NodeSelector : Tea.TeaModel {
    public var nodeGroupId: String?

    public var nodeGroupIds: [String]?

    public var nodeGroupName: String?

    public var nodeGroupNames: [String]?

    public var nodeGroupTypes: [String]?

    public var nodeNames: [String]?

    public var nodeSelectType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nodeGroupId != nil {
            map["NodeGroupId"] = self.nodeGroupId!
        }
        if self.nodeGroupIds != nil {
            map["NodeGroupIds"] = self.nodeGroupIds!
        }
        if self.nodeGroupName != nil {
            map["NodeGroupName"] = self.nodeGroupName!
        }
        if self.nodeGroupNames != nil {
            map["NodeGroupNames"] = self.nodeGroupNames!
        }
        if self.nodeGroupTypes != nil {
            map["NodeGroupTypes"] = self.nodeGroupTypes!
        }
        if self.nodeNames != nil {
            map["NodeNames"] = self.nodeNames!
        }
        if self.nodeSelectType != nil {
            map["NodeSelectType"] = self.nodeSelectType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NodeGroupId") {
            self.nodeGroupId = dict["NodeGroupId"] as! String
        }
        if dict.keys.contains("NodeGroupIds") {
            self.nodeGroupIds = dict["NodeGroupIds"] as! [String]
        }
        if dict.keys.contains("NodeGroupName") {
            self.nodeGroupName = dict["NodeGroupName"] as! String
        }
        if dict.keys.contains("NodeGroupNames") {
            self.nodeGroupNames = dict["NodeGroupNames"] as! [String]
        }
        if dict.keys.contains("NodeGroupTypes") {
            self.nodeGroupTypes = dict["NodeGroupTypes"] as! [String]
        }
        if dict.keys.contains("NodeNames") {
            self.nodeNames = dict["NodeNames"] as! [String]
        }
        if dict.keys.contains("NodeSelectType") {
            self.nodeSelectType = dict["NodeSelectType"] as! String
        }
    }
}

public class OSUser : Tea.TeaModel {
    public var group: String?

    public var password: String?

    public var user: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.group != nil {
            map["Group"] = self.group!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        if self.user != nil {
            map["User"] = self.user!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Group") {
            self.group = dict["Group"] as! String
        }
        if dict.keys.contains("Password") {
            self.password = dict["Password"] as! String
        }
        if dict.keys.contains("User") {
            self.user = dict["User"] as! String
        }
    }
}

public class OnKubeClusterResource : Tea.TeaModel {
    public var cpu: String?

    public var memory: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cpu != nil {
            map["Cpu"] = self.cpu!
        }
        if self.memory != nil {
            map["Memory"] = self.memory!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Cpu") {
            self.cpu = dict["Cpu"] as! String
        }
        if dict.keys.contains("Memory") {
            self.memory = dict["Memory"] as! String
        }
    }
}

public class Operation : Tea.TeaModel {
    public var clusterId: String?

    public var createTime: Int64?

    public var description_: String?

    public var endTime: Int64?

    public var operationId: String?

    public var operationState: String?

    public var operationType: String?

    public var startTime: Int64?

    public var stateChangeReason: OperationStateChangeReason?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.stateChangeReason?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.operationId != nil {
            map["OperationId"] = self.operationId!
        }
        if self.operationState != nil {
            map["OperationState"] = self.operationState!
        }
        if self.operationType != nil {
            map["OperationType"] = self.operationType!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.stateChangeReason != nil {
            map["StateChangeReason"] = self.stateChangeReason?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("CreateTime") {
            self.createTime = dict["CreateTime"] as! Int64
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("OperationId") {
            self.operationId = dict["OperationId"] as! String
        }
        if dict.keys.contains("OperationState") {
            self.operationState = dict["OperationState"] as! String
        }
        if dict.keys.contains("OperationType") {
            self.operationType = dict["OperationType"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("StateChangeReason") {
            var model = OperationStateChangeReason()
            model.fromMap(dict["StateChangeReason"] as! [String: Any])
            self.stateChangeReason = model
        }
    }
}

public class OperationData : Tea.TeaModel {
    public var actualDeliveredAmounts: Int32?

    public var toBeDeliveredAmounts: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.actualDeliveredAmounts != nil {
            map["actualDeliveredAmounts"] = self.actualDeliveredAmounts!
        }
        if self.toBeDeliveredAmounts != nil {
            map["toBeDeliveredAmounts"] = self.toBeDeliveredAmounts!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("actualDeliveredAmounts") {
            self.actualDeliveredAmounts = dict["actualDeliveredAmounts"] as! Int32
        }
        if dict.keys.contains("toBeDeliveredAmounts") {
            self.toBeDeliveredAmounts = dict["toBeDeliveredAmounts"] as! Int32
        }
    }
}

public class OperationStateChangeReason : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
    }
}

public class Order : Tea.TeaModel {
    public var createTime: String?

    public var orderId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateTime") {
            self.createTime = dict["CreateTime"] as! String
        }
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! String
        }
    }
}

public class Page : Tea.TeaModel {
    public var items: [String]?

    public var maxResults: Int64?

    public var nextToken: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.items != nil {
            map["Items"] = self.items!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Items") {
            self.items = dict["Items"] as! [String]
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int64
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class Pod : Tea.TeaModel {
    public var message: String?

    public var podName: String?

    public var podStatus: String?

    public var reason: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.podName != nil {
            map["PodName"] = self.podName!
        }
        if self.podStatus != nil {
            map["PodStatus"] = self.podStatus!
        }
        if self.reason != nil {
            map["Reason"] = self.reason!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PodName") {
            self.podName = dict["PodName"] as! String
        }
        if dict.keys.contains("PodStatus") {
            self.podStatus = dict["PodStatus"] as! String
        }
        if dict.keys.contains("Reason") {
            self.reason = dict["Reason"] as! String
        }
    }
}

public class PriceInfo : Tea.TeaModel {
    public var currency: String?

    public var discountPrice: String?

    public var originalPrice: String?

    public var payType: String?

    public var promotionResults: [PromotionInfo]?

    public var resourceType: String?

    public var spotInstanceTypeOriginalPrice: String?

    public var spotInstanceTypePrice: String?

    public var spotOriginalPrice: String?

    public var spotPrice: String?

    public var taxPrice: String?

    public var tradePrice: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currency != nil {
            map["Currency"] = self.currency!
        }
        if self.discountPrice != nil {
            map["DiscountPrice"] = self.discountPrice!
        }
        if self.originalPrice != nil {
            map["OriginalPrice"] = self.originalPrice!
        }
        if self.payType != nil {
            map["PayType"] = self.payType!
        }
        if self.promotionResults != nil {
            var tmp : [Any] = []
            for k in self.promotionResults! {
                tmp.append(k.toMap())
            }
            map["PromotionResults"] = tmp
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.spotInstanceTypeOriginalPrice != nil {
            map["SpotInstanceTypeOriginalPrice"] = self.spotInstanceTypeOriginalPrice!
        }
        if self.spotInstanceTypePrice != nil {
            map["SpotInstanceTypePrice"] = self.spotInstanceTypePrice!
        }
        if self.spotOriginalPrice != nil {
            map["SpotOriginalPrice"] = self.spotOriginalPrice!
        }
        if self.spotPrice != nil {
            map["SpotPrice"] = self.spotPrice!
        }
        if self.taxPrice != nil {
            map["TaxPrice"] = self.taxPrice!
        }
        if self.tradePrice != nil {
            map["TradePrice"] = self.tradePrice!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Currency") {
            self.currency = dict["Currency"] as! String
        }
        if dict.keys.contains("DiscountPrice") {
            self.discountPrice = dict["DiscountPrice"] as! String
        }
        if dict.keys.contains("OriginalPrice") {
            self.originalPrice = dict["OriginalPrice"] as! String
        }
        if dict.keys.contains("PayType") {
            self.payType = dict["PayType"] as! String
        }
        if dict.keys.contains("PromotionResults") {
            var tmp : [PromotionInfo] = []
            for v in dict["PromotionResults"] as! [Any] {
                var model = PromotionInfo()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.promotionResults = tmp
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("SpotInstanceTypeOriginalPrice") {
            self.spotInstanceTypeOriginalPrice = dict["SpotInstanceTypeOriginalPrice"] as! String
        }
        if dict.keys.contains("SpotInstanceTypePrice") {
            self.spotInstanceTypePrice = dict["SpotInstanceTypePrice"] as! String
        }
        if dict.keys.contains("SpotOriginalPrice") {
            self.spotOriginalPrice = dict["SpotOriginalPrice"] as! String
        }
        if dict.keys.contains("SpotPrice") {
            self.spotPrice = dict["SpotPrice"] as! String
        }
        if dict.keys.contains("TaxPrice") {
            self.taxPrice = dict["TaxPrice"] as! String
        }
        if dict.keys.contains("TradePrice") {
            self.tradePrice = dict["TradePrice"] as! String
        }
    }
}

public class Promotion : Tea.TeaModel {
    public var productCode: String?

    public var promotionDesc: String?

    public var promotionName: String?

    public var promotionOptionCode: String?

    public var promotionOptionNo: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.productCode != nil {
            map["ProductCode"] = self.productCode!
        }
        if self.promotionDesc != nil {
            map["PromotionDesc"] = self.promotionDesc!
        }
        if self.promotionName != nil {
            map["PromotionName"] = self.promotionName!
        }
        if self.promotionOptionCode != nil {
            map["PromotionOptionCode"] = self.promotionOptionCode!
        }
        if self.promotionOptionNo != nil {
            map["PromotionOptionNo"] = self.promotionOptionNo!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ProductCode") {
            self.productCode = dict["ProductCode"] as! String
        }
        if dict.keys.contains("PromotionDesc") {
            self.promotionDesc = dict["PromotionDesc"] as! String
        }
        if dict.keys.contains("PromotionName") {
            self.promotionName = dict["PromotionName"] as! String
        }
        if dict.keys.contains("PromotionOptionCode") {
            self.promotionOptionCode = dict["PromotionOptionCode"] as! String
        }
        if dict.keys.contains("PromotionOptionNo") {
            self.promotionOptionNo = dict["PromotionOptionNo"] as! String
        }
    }
}

public class PromotionInfo : Tea.TeaModel {
    public var canPromFee: String?

    public var isSelected: String?

    public var promotionDesc: String?

    public var promotionName: String?

    public var promotionOptionCode: String?

    public var promotionOptionNo: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.canPromFee != nil {
            map["CanPromFee"] = self.canPromFee!
        }
        if self.isSelected != nil {
            map["IsSelected"] = self.isSelected!
        }
        if self.promotionDesc != nil {
            map["PromotionDesc"] = self.promotionDesc!
        }
        if self.promotionName != nil {
            map["PromotionName"] = self.promotionName!
        }
        if self.promotionOptionCode != nil {
            map["PromotionOptionCode"] = self.promotionOptionCode!
        }
        if self.promotionOptionNo != nil {
            map["PromotionOptionNo"] = self.promotionOptionNo!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CanPromFee") {
            self.canPromFee = dict["CanPromFee"] as! String
        }
        if dict.keys.contains("IsSelected") {
            self.isSelected = dict["IsSelected"] as! String
        }
        if dict.keys.contains("PromotionDesc") {
            self.promotionDesc = dict["PromotionDesc"] as! String
        }
        if dict.keys.contains("PromotionName") {
            self.promotionName = dict["PromotionName"] as! String
        }
        if dict.keys.contains("PromotionOptionCode") {
            self.promotionOptionCode = dict["PromotionOptionCode"] as! String
        }
        if dict.keys.contains("PromotionOptionNo") {
            self.promotionOptionNo = dict["PromotionOptionNo"] as! String
        }
    }
}

public class PromotionParam : Tea.TeaModel {
    public var productCode: String?

    public var promotionOptionCode: String?

    public var promotionOptionNo: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.productCode != nil {
            map["ProductCode"] = self.productCode!
        }
        if self.promotionOptionCode != nil {
            map["PromotionOptionCode"] = self.promotionOptionCode!
        }
        if self.promotionOptionNo != nil {
            map["PromotionOptionNo"] = self.promotionOptionNo!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ProductCode") {
            self.productCode = dict["ProductCode"] as! String
        }
        if dict.keys.contains("PromotionOptionCode") {
            self.promotionOptionCode = dict["PromotionOptionCode"] as! String
        }
        if dict.keys.contains("PromotionOptionNo") {
            self.promotionOptionNo = dict["PromotionOptionNo"] as! String
        }
    }
}

public class RecommendScalingRule : Tea.TeaModel {
    public var activityType: String?

    public var adjustmentValue: Int32?

    public var instanceType: String?

    public var maxSave: Double?

    public var metricsTrigger: MetricsTrigger?

    public var ruleName: String?

    public var timeTrigger: TimeTrigger?

    public var triggerType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.metricsTrigger?.validate()
        try self.timeTrigger?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.activityType != nil {
            map["ActivityType"] = self.activityType!
        }
        if self.adjustmentValue != nil {
            map["AdjustmentValue"] = self.adjustmentValue!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.maxSave != nil {
            map["MaxSave"] = self.maxSave!
        }
        if self.metricsTrigger != nil {
            map["MetricsTrigger"] = self.metricsTrigger?.toMap()
        }
        if self.ruleName != nil {
            map["RuleName"] = self.ruleName!
        }
        if self.timeTrigger != nil {
            map["TimeTrigger"] = self.timeTrigger?.toMap()
        }
        if self.triggerType != nil {
            map["TriggerType"] = self.triggerType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ActivityType") {
            self.activityType = dict["ActivityType"] as! String
        }
        if dict.keys.contains("AdjustmentValue") {
            self.adjustmentValue = dict["AdjustmentValue"] as! Int32
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("MaxSave") {
            self.maxSave = dict["MaxSave"] as! Double
        }
        if dict.keys.contains("MetricsTrigger") {
            var model = MetricsTrigger()
            model.fromMap(dict["MetricsTrigger"] as! [String: Any])
            self.metricsTrigger = model
        }
        if dict.keys.contains("RuleName") {
            self.ruleName = dict["RuleName"] as! String
        }
        if dict.keys.contains("TimeTrigger") {
            var model = TimeTrigger()
            model.fromMap(dict["TimeTrigger"] as! [String: Any])
            self.timeTrigger = model
        }
        if dict.keys.contains("TriggerType") {
            self.triggerType = dict["TriggerType"] as! String
        }
    }
}

public class RenewInstance : Tea.TeaModel {
    public var emrRenewDuration: Int32?

    public var emrRenewDurationUnit: String?

    public var instanceId: String?

    public var renewDuration: Int32?

    public var renewDurationUnit: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.emrRenewDuration != nil {
            map["EmrRenewDuration"] = self.emrRenewDuration!
        }
        if self.emrRenewDurationUnit != nil {
            map["EmrRenewDurationUnit"] = self.emrRenewDurationUnit!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.renewDuration != nil {
            map["RenewDuration"] = self.renewDuration!
        }
        if self.renewDurationUnit != nil {
            map["RenewDurationUnit"] = self.renewDurationUnit!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EmrRenewDuration") {
            self.emrRenewDuration = dict["EmrRenewDuration"] as! Int32
        }
        if dict.keys.contains("EmrRenewDurationUnit") {
            self.emrRenewDurationUnit = dict["EmrRenewDurationUnit"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("RenewDuration") {
            self.renewDuration = dict["RenewDuration"] as! Int32
        }
        if dict.keys.contains("RenewDurationUnit") {
            self.renewDurationUnit = dict["RenewDurationUnit"] as! String
        }
    }
}

public class RenewInstanceParam : Tea.TeaModel {
    public var instanceId: String?

    public var renewDuration: Int64?

    public var renewDurationUnit: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.renewDuration != nil {
            map["RenewDuration"] = self.renewDuration!
        }
        if self.renewDurationUnit != nil {
            map["RenewDurationUnit"] = self.renewDurationUnit!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("RenewDuration") {
            self.renewDuration = dict["RenewDuration"] as! Int64
        }
        if dict.keys.contains("RenewDurationUnit") {
            self.renewDurationUnit = dict["RenewDurationUnit"] as! String
        }
    }
}

public class ReplacementStrategy : Tea.TeaModel {
    public var instanceCategories: [InstanceCategory]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceCategories != nil {
            var tmp : [Any] = []
            for k in self.instanceCategories! {
                tmp.append(k.toMap())
            }
            map["InstanceCategories"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceCategories") {
            var tmp : [InstanceCategory] = []
            for v in dict["InstanceCategories"] as! [Any] {
                var model = InstanceCategory()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.instanceCategories = tmp
        }
    }
}

public class RequestTag : Tea.TeaModel {
    public var key: String?

    public var value: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.key != nil {
            map["Key"] = self.key!
        }
        if self.value != nil {
            map["Value"] = self.value!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Key") {
            self.key = dict["Key"] as! String
        }
        if dict.keys.contains("Value") {
            self.value = dict["Value"] as! String
        }
    }
}

public class ResizeDiskNodeGroupParam : Tea.TeaModel {
    public var dataDiskCapacity: Int64?

    public var nodeGroupId: String?

    public var rollingRestart: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataDiskCapacity != nil {
            map["DataDiskCapacity"] = self.dataDiskCapacity!
        }
        if self.nodeGroupId != nil {
            map["NodeGroupId"] = self.nodeGroupId!
        }
        if self.rollingRestart != nil {
            map["RollingRestart"] = self.rollingRestart!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataDiskCapacity") {
            self.dataDiskCapacity = dict["DataDiskCapacity"] as! Int64
        }
        if dict.keys.contains("NodeGroupId") {
            self.nodeGroupId = dict["NodeGroupId"] as! String
        }
        if dict.keys.contains("RollingRestart") {
            self.rollingRestart = dict["RollingRestart"] as! Bool
        }
    }
}

public class ScalingActivity : Tea.TeaModel {
    public var cause: String?

    public var description_: String?

    public var endTime: Int64?

    public var essScalingRuleId: String?

    public var expectNum: Int32?

    public var hostGroupName: String?

    public var id: String?

    public var instanceIds: String?

    public var scalingGroupId: String?

    public var scalingRuleName: String?

    public var startTime: Int64?

    public var status: String?

    public var totalCapacity: Int32?

    public var transition: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cause != nil {
            map["Cause"] = self.cause!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.essScalingRuleId != nil {
            map["EssScalingRuleId"] = self.essScalingRuleId!
        }
        if self.expectNum != nil {
            map["ExpectNum"] = self.expectNum!
        }
        if self.hostGroupName != nil {
            map["HostGroupName"] = self.hostGroupName!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        if self.scalingRuleName != nil {
            map["ScalingRuleName"] = self.scalingRuleName!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.totalCapacity != nil {
            map["TotalCapacity"] = self.totalCapacity!
        }
        if self.transition != nil {
            map["Transition"] = self.transition!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Cause") {
            self.cause = dict["Cause"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("EssScalingRuleId") {
            self.essScalingRuleId = dict["EssScalingRuleId"] as! String
        }
        if dict.keys.contains("ExpectNum") {
            self.expectNum = dict["ExpectNum"] as! Int32
        }
        if dict.keys.contains("HostGroupName") {
            self.hostGroupName = dict["HostGroupName"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("InstanceIds") {
            self.instanceIds = dict["InstanceIds"] as! String
        }
        if dict.keys.contains("ScalingGroupId") {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
        if dict.keys.contains("ScalingRuleName") {
            self.scalingRuleName = dict["ScalingRuleName"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("TotalCapacity") {
            self.totalCapacity = dict["TotalCapacity"] as! Int32
        }
        if dict.keys.contains("Transition") {
            self.transition = dict["Transition"] as! String
        }
    }
}

public class ScalingActivityResult : Tea.TeaModel {
    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class ScalingActivityResultDTO : Tea.TeaModel {
    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class ScalingAnalyzeResult : Tea.TeaModel {
    public var actualUsage: Double?

    public var idealUsage: Double?

    public var releaseCores: Int32?

    public var reservedCores: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.actualUsage != nil {
            map["ActualUsage"] = self.actualUsage!
        }
        if self.idealUsage != nil {
            map["IdealUsage"] = self.idealUsage!
        }
        if self.releaseCores != nil {
            map["ReleaseCores"] = self.releaseCores!
        }
        if self.reservedCores != nil {
            map["ReservedCores"] = self.reservedCores!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ActualUsage") {
            self.actualUsage = dict["ActualUsage"] as! Double
        }
        if dict.keys.contains("IdealUsage") {
            self.idealUsage = dict["IdealUsage"] as! Double
        }
        if dict.keys.contains("ReleaseCores") {
            self.releaseCores = dict["ReleaseCores"] as! Int32
        }
        if dict.keys.contains("ReservedCores") {
            self.reservedCores = dict["ReservedCores"] as! Int32
        }
    }
}

public class ScalingAnalyzeTimeRange : Tea.TeaModel {
    public var endTime: Int64?

    public var startTime: Int64?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class ScalingConstraints : Tea.TeaModel {
    public var maxCapacity: Int32?

    public var minCapacity: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxCapacity != nil {
            map["MaxCapacity"] = self.maxCapacity!
        }
        if self.minCapacity != nil {
            map["MinCapacity"] = self.minCapacity!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxCapacity") {
            self.maxCapacity = dict["MaxCapacity"] as! Int32
        }
        if dict.keys.contains("MinCapacity") {
            self.minCapacity = dict["MinCapacity"] as! Int32
        }
    }
}

public class ScalingGroupConfig : Tea.TeaModel {
    public class InstanceTypeList : Tea.TeaModel {
        public var instanceType: String?

        public var spotPriceLimit: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.spotPriceLimit != nil {
                map["SpotPriceLimit"] = self.spotPriceLimit!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceType") {
                self.instanceType = dict["InstanceType"] as! String
            }
            if dict.keys.contains("SpotPriceLimit") {
                self.spotPriceLimit = dict["SpotPriceLimit"] as! Double
            }
        }
    }
    public class MultiAvailablePolicy : Tea.TeaModel {
        public class PolicyParam : Tea.TeaModel {
            public var onDemandBaseCapacity: Int32?

            public var onDemandPercentageAboveBaseCapacity: Int32?

            public var spotInstancePools: Int32?

            public var spotInstanceRemedy: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.onDemandBaseCapacity != nil {
                    map["OnDemandBaseCapacity"] = self.onDemandBaseCapacity!
                }
                if self.onDemandPercentageAboveBaseCapacity != nil {
                    map["OnDemandPercentageAboveBaseCapacity"] = self.onDemandPercentageAboveBaseCapacity!
                }
                if self.spotInstancePools != nil {
                    map["SpotInstancePools"] = self.spotInstancePools!
                }
                if self.spotInstanceRemedy != nil {
                    map["SpotInstanceRemedy"] = self.spotInstanceRemedy!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("OnDemandBaseCapacity") {
                    self.onDemandBaseCapacity = dict["OnDemandBaseCapacity"] as! Int32
                }
                if dict.keys.contains("OnDemandPercentageAboveBaseCapacity") {
                    self.onDemandPercentageAboveBaseCapacity = dict["OnDemandPercentageAboveBaseCapacity"] as! Int32
                }
                if dict.keys.contains("SpotInstancePools") {
                    self.spotInstancePools = dict["SpotInstancePools"] as! Int32
                }
                if dict.keys.contains("SpotInstanceRemedy") {
                    self.spotInstanceRemedy = dict["SpotInstanceRemedy"] as! Bool
                }
            }
        }
        public var policyParam: ScalingGroupConfig.MultiAvailablePolicy.PolicyParam?

        public var policyType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.policyParam?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.policyParam != nil {
                map["PolicyParam"] = self.policyParam?.toMap()
            }
            if self.policyType != nil {
                map["PolicyType"] = self.policyType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PolicyParam") {
                var model = ScalingGroupConfig.MultiAvailablePolicy.PolicyParam()
                model.fromMap(dict["PolicyParam"] as! [String: Any])
                self.policyParam = model
            }
            if dict.keys.contains("PolicyType") {
                self.policyType = dict["PolicyType"] as! String
            }
        }
    }
    public class NodeOfflinePolicy : Tea.TeaModel {
        public var mode: String?

        public var timeoutMs: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.mode != nil {
                map["Mode"] = self.mode!
            }
            if self.timeoutMs != nil {
                map["TimeoutMs"] = self.timeoutMs!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Mode") {
                self.mode = dict["Mode"] as! String
            }
            if dict.keys.contains("TimeoutMs") {
                self.timeoutMs = dict["TimeoutMs"] as! Int64
            }
        }
    }
    public class PrivatePoolOptions : Tea.TeaModel {
        public var id: String?

        public var matchCriteria: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.matchCriteria != nil {
                map["MatchCriteria"] = self.matchCriteria!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("MatchCriteria") {
                self.matchCriteria = dict["MatchCriteria"] as! String
            }
        }
    }
    public var dataDiskCategory: String?

    public var dataDiskCount: Int32?

    public var dataDiskSize: Int64?

    public var defaultCoolDownTime: Int64?

    public var instanceTypeList: [ScalingGroupConfig.InstanceTypeList]?

    public var multiAvailablePolicy: ScalingGroupConfig.MultiAvailablePolicy?

    public var nodeOfflinePolicy: ScalingGroupConfig.NodeOfflinePolicy?

    public var privatePoolOptions: ScalingGroupConfig.PrivatePoolOptions?

    public var scalingMaxSize: Int32?

    public var scalingMinSize: Int32?

    public var spotStrategy: String?

    public var sysDiskCategory: String?

    public var sysDiskSize: Int64?

    public var triggerMode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.multiAvailablePolicy?.validate()
        try self.nodeOfflinePolicy?.validate()
        try self.privatePoolOptions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataDiskCategory != nil {
            map["DataDiskCategory"] = self.dataDiskCategory!
        }
        if self.dataDiskCount != nil {
            map["DataDiskCount"] = self.dataDiskCount!
        }
        if self.dataDiskSize != nil {
            map["DataDiskSize"] = self.dataDiskSize!
        }
        if self.defaultCoolDownTime != nil {
            map["DefaultCoolDownTime"] = self.defaultCoolDownTime!
        }
        if self.instanceTypeList != nil {
            var tmp : [Any] = []
            for k in self.instanceTypeList! {
                tmp.append(k.toMap())
            }
            map["InstanceTypeList"] = tmp
        }
        if self.multiAvailablePolicy != nil {
            map["MultiAvailablePolicy"] = self.multiAvailablePolicy?.toMap()
        }
        if self.nodeOfflinePolicy != nil {
            map["NodeOfflinePolicy"] = self.nodeOfflinePolicy?.toMap()
        }
        if self.privatePoolOptions != nil {
            map["PrivatePoolOptions"] = self.privatePoolOptions?.toMap()
        }
        if self.scalingMaxSize != nil {
            map["ScalingMaxSize"] = self.scalingMaxSize!
        }
        if self.scalingMinSize != nil {
            map["ScalingMinSize"] = self.scalingMinSize!
        }
        if self.spotStrategy != nil {
            map["SpotStrategy"] = self.spotStrategy!
        }
        if self.sysDiskCategory != nil {
            map["SysDiskCategory"] = self.sysDiskCategory!
        }
        if self.sysDiskSize != nil {
            map["SysDiskSize"] = self.sysDiskSize!
        }
        if self.triggerMode != nil {
            map["TriggerMode"] = self.triggerMode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataDiskCategory") {
            self.dataDiskCategory = dict["DataDiskCategory"] as! String
        }
        if dict.keys.contains("DataDiskCount") {
            self.dataDiskCount = dict["DataDiskCount"] as! Int32
        }
        if dict.keys.contains("DataDiskSize") {
            self.dataDiskSize = dict["DataDiskSize"] as! Int64
        }
        if dict.keys.contains("DefaultCoolDownTime") {
            self.defaultCoolDownTime = dict["DefaultCoolDownTime"] as! Int64
        }
        if dict.keys.contains("InstanceTypeList") {
            var tmp : [ScalingGroupConfig.InstanceTypeList] = []
            for v in dict["InstanceTypeList"] as! [Any] {
                var model = ScalingGroupConfig.InstanceTypeList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.instanceTypeList = tmp
        }
        if dict.keys.contains("MultiAvailablePolicy") {
            var model = ScalingGroupConfig.MultiAvailablePolicy()
            model.fromMap(dict["MultiAvailablePolicy"] as! [String: Any])
            self.multiAvailablePolicy = model
        }
        if dict.keys.contains("NodeOfflinePolicy") {
            var model = ScalingGroupConfig.NodeOfflinePolicy()
            model.fromMap(dict["NodeOfflinePolicy"] as! [String: Any])
            self.nodeOfflinePolicy = model
        }
        if dict.keys.contains("PrivatePoolOptions") {
            var model = ScalingGroupConfig.PrivatePoolOptions()
            model.fromMap(dict["PrivatePoolOptions"] as! [String: Any])
            self.privatePoolOptions = model
        }
        if dict.keys.contains("ScalingMaxSize") {
            self.scalingMaxSize = dict["ScalingMaxSize"] as! Int32
        }
        if dict.keys.contains("ScalingMinSize") {
            self.scalingMinSize = dict["ScalingMinSize"] as! Int32
        }
        if dict.keys.contains("SpotStrategy") {
            self.spotStrategy = dict["SpotStrategy"] as! String
        }
        if dict.keys.contains("SysDiskCategory") {
            self.sysDiskCategory = dict["SysDiskCategory"] as! String
        }
        if dict.keys.contains("SysDiskSize") {
            self.sysDiskSize = dict["SysDiskSize"] as! Int64
        }
        if dict.keys.contains("TriggerMode") {
            self.triggerMode = dict["TriggerMode"] as! String
        }
    }
}

public class ScalingRule : Tea.TeaModel {
    public var activityType: String?

    public var adjustmentValue: Int32?

    public var metricsTrigger: MetricsTrigger?

    public var ruleName: String?

    public var timeTrigger: TimeTrigger?

    public var triggerType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.metricsTrigger?.validate()
        try self.timeTrigger?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.activityType != nil {
            map["ActivityType"] = self.activityType!
        }
        if self.adjustmentValue != nil {
            map["AdjustmentValue"] = self.adjustmentValue!
        }
        if self.metricsTrigger != nil {
            map["MetricsTrigger"] = self.metricsTrigger?.toMap()
        }
        if self.ruleName != nil {
            map["RuleName"] = self.ruleName!
        }
        if self.timeTrigger != nil {
            map["TimeTrigger"] = self.timeTrigger?.toMap()
        }
        if self.triggerType != nil {
            map["TriggerType"] = self.triggerType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ActivityType") {
            self.activityType = dict["ActivityType"] as! String
        }
        if dict.keys.contains("AdjustmentValue") {
            self.adjustmentValue = dict["AdjustmentValue"] as! Int32
        }
        if dict.keys.contains("MetricsTrigger") {
            var model = MetricsTrigger()
            model.fromMap(dict["MetricsTrigger"] as! [String: Any])
            self.metricsTrigger = model
        }
        if dict.keys.contains("RuleName") {
            self.ruleName = dict["RuleName"] as! String
        }
        if dict.keys.contains("TimeTrigger") {
            var model = TimeTrigger()
            model.fromMap(dict["TimeTrigger"] as! [String: Any])
            self.timeTrigger = model
        }
        if dict.keys.contains("TriggerType") {
            self.triggerType = dict["TriggerType"] as! String
        }
    }
}

public class ScalingRuleSpec : Tea.TeaModel {
    public class ByLoadScalingRuleSpec : Tea.TeaModel {
        public var comparisonOperator: String?

        public var evaluationCount: Int32?

        public var metricName: String?

        public var statistics: String?

        public var threshold: Double?

        public var timeWindow: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.comparisonOperator != nil {
                map["ComparisonOperator"] = self.comparisonOperator!
            }
            if self.evaluationCount != nil {
                map["EvaluationCount"] = self.evaluationCount!
            }
            if self.metricName != nil {
                map["MetricName"] = self.metricName!
            }
            if self.statistics != nil {
                map["Statistics"] = self.statistics!
            }
            if self.threshold != nil {
                map["Threshold"] = self.threshold!
            }
            if self.timeWindow != nil {
                map["TimeWindow"] = self.timeWindow!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ComparisonOperator") {
                self.comparisonOperator = dict["ComparisonOperator"] as! String
            }
            if dict.keys.contains("EvaluationCount") {
                self.evaluationCount = dict["EvaluationCount"] as! Int32
            }
            if dict.keys.contains("MetricName") {
                self.metricName = dict["MetricName"] as! String
            }
            if dict.keys.contains("Statistics") {
                self.statistics = dict["Statistics"] as! String
            }
            if dict.keys.contains("Threshold") {
                self.threshold = dict["Threshold"] as! Double
            }
            if dict.keys.contains("TimeWindow") {
                self.timeWindow = dict["TimeWindow"] as! Int32
            }
        }
    }
    public class ByTimeScalingRuleSpec : Tea.TeaModel {
        public var endTime: Int64?

        public var launchTime: Int64?

        public var recurrenceType: String?

        public var recurrenceValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.launchTime != nil {
                map["LaunchTime"] = self.launchTime!
            }
            if self.recurrenceType != nil {
                map["RecurrenceType"] = self.recurrenceType!
            }
            if self.recurrenceValue != nil {
                map["RecurrenceValue"] = self.recurrenceValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EndTime") {
                self.endTime = dict["EndTime"] as! Int64
            }
            if dict.keys.contains("LaunchTime") {
                self.launchTime = dict["LaunchTime"] as! Int64
            }
            if dict.keys.contains("RecurrenceType") {
                self.recurrenceType = dict["RecurrenceType"] as! String
            }
            if dict.keys.contains("RecurrenceValue") {
                self.recurrenceValue = dict["RecurrenceValue"] as! String
            }
        }
    }
    public var adjustmentValue: Int32?

    public var byLoadScalingRuleSpec: ScalingRuleSpec.ByLoadScalingRuleSpec?

    public var byTimeScalingRuleSpec: ScalingRuleSpec.ByTimeScalingRuleSpec?

    public var coolDownInterval: Int32?

    public var scalingActivityType: String?

    public var scalingRuleName: String?

    public var scalingRuleType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.byLoadScalingRuleSpec?.validate()
        try self.byTimeScalingRuleSpec?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.adjustmentValue != nil {
            map["AdjustmentValue"] = self.adjustmentValue!
        }
        if self.byLoadScalingRuleSpec != nil {
            map["ByLoadScalingRuleSpec"] = self.byLoadScalingRuleSpec?.toMap()
        }
        if self.byTimeScalingRuleSpec != nil {
            map["ByTimeScalingRuleSpec"] = self.byTimeScalingRuleSpec?.toMap()
        }
        if self.coolDownInterval != nil {
            map["CoolDownInterval"] = self.coolDownInterval!
        }
        if self.scalingActivityType != nil {
            map["ScalingActivityType"] = self.scalingActivityType!
        }
        if self.scalingRuleName != nil {
            map["ScalingRuleName"] = self.scalingRuleName!
        }
        if self.scalingRuleType != nil {
            map["ScalingRuleType"] = self.scalingRuleType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AdjustmentValue") {
            self.adjustmentValue = dict["AdjustmentValue"] as! Int32
        }
        if dict.keys.contains("ByLoadScalingRuleSpec") {
            var model = ScalingRuleSpec.ByLoadScalingRuleSpec()
            model.fromMap(dict["ByLoadScalingRuleSpec"] as! [String: Any])
            self.byLoadScalingRuleSpec = model
        }
        if dict.keys.contains("ByTimeScalingRuleSpec") {
            var model = ScalingRuleSpec.ByTimeScalingRuleSpec()
            model.fromMap(dict["ByTimeScalingRuleSpec"] as! [String: Any])
            self.byTimeScalingRuleSpec = model
        }
        if dict.keys.contains("CoolDownInterval") {
            self.coolDownInterval = dict["CoolDownInterval"] as! Int32
        }
        if dict.keys.contains("ScalingActivityType") {
            self.scalingActivityType = dict["ScalingActivityType"] as! String
        }
        if dict.keys.contains("ScalingRuleName") {
            self.scalingRuleName = dict["ScalingRuleName"] as! String
        }
        if dict.keys.contains("ScalingRuleType") {
            self.scalingRuleType = dict["ScalingRuleType"] as! String
        }
    }
}

public class ScalingRuleV1 : Tea.TeaModel {
    public class RuleParam : Tea.TeaModel {
        public var comparisonOperator: String?

        public var evaluationCount: Int32?

        public var launchExpirationTime: Int32?

        public var launchTime: String?

        public var metricName: String?

        public var period: Int32?

        public var recurrenceEndTime: String?

        public var recurrenceType: String?

        public var recurrenceValue: String?

        public var statistics: String?

        public var threshold: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.comparisonOperator != nil {
                map["ComparisonOperator"] = self.comparisonOperator!
            }
            if self.evaluationCount != nil {
                map["EvaluationCount"] = self.evaluationCount!
            }
            if self.launchExpirationTime != nil {
                map["LaunchExpirationTime"] = self.launchExpirationTime!
            }
            if self.launchTime != nil {
                map["LaunchTime"] = self.launchTime!
            }
            if self.metricName != nil {
                map["MetricName"] = self.metricName!
            }
            if self.period != nil {
                map["Period"] = self.period!
            }
            if self.recurrenceEndTime != nil {
                map["RecurrenceEndTime"] = self.recurrenceEndTime!
            }
            if self.recurrenceType != nil {
                map["RecurrenceType"] = self.recurrenceType!
            }
            if self.recurrenceValue != nil {
                map["RecurrenceValue"] = self.recurrenceValue!
            }
            if self.statistics != nil {
                map["Statistics"] = self.statistics!
            }
            if self.threshold != nil {
                map["Threshold"] = self.threshold!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ComparisonOperator") {
                self.comparisonOperator = dict["ComparisonOperator"] as! String
            }
            if dict.keys.contains("EvaluationCount") {
                self.evaluationCount = dict["EvaluationCount"] as! Int32
            }
            if dict.keys.contains("LaunchExpirationTime") {
                self.launchExpirationTime = dict["LaunchExpirationTime"] as! Int32
            }
            if dict.keys.contains("LaunchTime") {
                self.launchTime = dict["LaunchTime"] as! String
            }
            if dict.keys.contains("MetricName") {
                self.metricName = dict["MetricName"] as! String
            }
            if dict.keys.contains("Period") {
                self.period = dict["Period"] as! Int32
            }
            if dict.keys.contains("RecurrenceEndTime") {
                self.recurrenceEndTime = dict["RecurrenceEndTime"] as! String
            }
            if dict.keys.contains("RecurrenceType") {
                self.recurrenceType = dict["RecurrenceType"] as! String
            }
            if dict.keys.contains("RecurrenceValue") {
                self.recurrenceValue = dict["RecurrenceValue"] as! String
            }
            if dict.keys.contains("Statistics") {
                self.statistics = dict["Statistics"] as! String
            }
            if dict.keys.contains("Threshold") {
                self.threshold = dict["Threshold"] as! Int32
            }
        }
    }
    public var adjustmentType: String?

    public var adjustmentValue: Int32?

    public var coolDownTime: Int32?

    public var ruleName: String?

    public var ruleParam: ScalingRuleV1.RuleParam?

    public var ruleType: String?

    public var scalingConfigBizId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.ruleParam?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.adjustmentType != nil {
            map["AdjustmentType"] = self.adjustmentType!
        }
        if self.adjustmentValue != nil {
            map["AdjustmentValue"] = self.adjustmentValue!
        }
        if self.coolDownTime != nil {
            map["CoolDownTime"] = self.coolDownTime!
        }
        if self.ruleName != nil {
            map["RuleName"] = self.ruleName!
        }
        if self.ruleParam != nil {
            map["RuleParam"] = self.ruleParam?.toMap()
        }
        if self.ruleType != nil {
            map["RuleType"] = self.ruleType!
        }
        if self.scalingConfigBizId != nil {
            map["ScalingConfigBizId"] = self.scalingConfigBizId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AdjustmentType") {
            self.adjustmentType = dict["AdjustmentType"] as! String
        }
        if dict.keys.contains("AdjustmentValue") {
            self.adjustmentValue = dict["AdjustmentValue"] as! Int32
        }
        if dict.keys.contains("CoolDownTime") {
            self.coolDownTime = dict["CoolDownTime"] as! Int32
        }
        if dict.keys.contains("RuleName") {
            self.ruleName = dict["RuleName"] as! String
        }
        if dict.keys.contains("RuleParam") {
            var model = ScalingRuleV1.RuleParam()
            model.fromMap(dict["RuleParam"] as! [String: Any])
            self.ruleParam = model
        }
        if dict.keys.contains("RuleType") {
            self.ruleType = dict["RuleType"] as! String
        }
        if dict.keys.contains("ScalingConfigBizId") {
            self.scalingConfigBizId = dict["ScalingConfigBizId"] as! String
        }
    }
}

public class Script : Tea.TeaModel {
    public var executionFailStrategy: String?

    public var executionMoment: String?

    public var nodeSelector: NodeSelector?

    public var priority: Int32?

    public var scriptArgs: String?

    public var scriptName: String?

    public var scriptPath: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.nodeSelector?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.executionFailStrategy != nil {
            map["ExecutionFailStrategy"] = self.executionFailStrategy!
        }
        if self.executionMoment != nil {
            map["ExecutionMoment"] = self.executionMoment!
        }
        if self.nodeSelector != nil {
            map["NodeSelector"] = self.nodeSelector?.toMap()
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.scriptArgs != nil {
            map["ScriptArgs"] = self.scriptArgs!
        }
        if self.scriptName != nil {
            map["ScriptName"] = self.scriptName!
        }
        if self.scriptPath != nil {
            map["ScriptPath"] = self.scriptPath!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ExecutionFailStrategy") {
            self.executionFailStrategy = dict["ExecutionFailStrategy"] as! String
        }
        if dict.keys.contains("ExecutionMoment") {
            self.executionMoment = dict["ExecutionMoment"] as! String
        }
        if dict.keys.contains("NodeSelector") {
            var model = NodeSelector()
            model.fromMap(dict["NodeSelector"] as! [String: Any])
            self.nodeSelector = model
        }
        if dict.keys.contains("Priority") {
            self.priority = dict["Priority"] as! Int32
        }
        if dict.keys.contains("ScriptArgs") {
            self.scriptArgs = dict["ScriptArgs"] as! String
        }
        if dict.keys.contains("ScriptName") {
            self.scriptName = dict["ScriptName"] as! String
        }
        if dict.keys.contains("ScriptPath") {
            self.scriptPath = dict["ScriptPath"] as! String
        }
    }
}

public class SpotBidPrice : Tea.TeaModel {
    public var bidPrice: Double?

    public var instanceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bidPrice != nil {
            map["BidPrice"] = self.bidPrice!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BidPrice") {
            self.bidPrice = dict["BidPrice"] as! Double
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
    }
}

public class SpotPriceLimit : Tea.TeaModel {
    public var instanceType: String?

    public var priceLimit: Double?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.priceLimit != nil {
            map["PriceLimit"] = self.priceLimit!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("PriceLimit") {
            self.priceLimit = dict["PriceLimit"] as! Double
        }
    }
}

public class StateChangeReason : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
    }
}

public class SubscriptionConfig : Tea.TeaModel {
    public var autoRenew: Bool?

    public var autoRenewDuration: Int32?

    public var autoRenewDurationUnit: String?

    public var paymentDuration: Int32?

    public var paymentDurationUnit: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoRenew != nil {
            map["AutoRenew"] = self.autoRenew!
        }
        if self.autoRenewDuration != nil {
            map["AutoRenewDuration"] = self.autoRenewDuration!
        }
        if self.autoRenewDurationUnit != nil {
            map["AutoRenewDurationUnit"] = self.autoRenewDurationUnit!
        }
        if self.paymentDuration != nil {
            map["PaymentDuration"] = self.paymentDuration!
        }
        if self.paymentDurationUnit != nil {
            map["PaymentDurationUnit"] = self.paymentDurationUnit!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoRenew") {
            self.autoRenew = dict["AutoRenew"] as! Bool
        }
        if dict.keys.contains("AutoRenewDuration") {
            self.autoRenewDuration = dict["AutoRenewDuration"] as! Int32
        }
        if dict.keys.contains("AutoRenewDurationUnit") {
            self.autoRenewDurationUnit = dict["AutoRenewDurationUnit"] as! String
        }
        if dict.keys.contains("PaymentDuration") {
            self.paymentDuration = dict["PaymentDuration"] as! Int32
        }
        if dict.keys.contains("PaymentDurationUnit") {
            self.paymentDurationUnit = dict["PaymentDurationUnit"] as! String
        }
    }
}

public class SystemDisk : Tea.TeaModel {
    public var category: String?

    public var count: Int32?

    public var performanceLevel: String?

    public var size: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.category != nil {
            map["Category"] = self.category!
        }
        if self.count != nil {
            map["Count"] = self.count!
        }
        if self.performanceLevel != nil {
            map["PerformanceLevel"] = self.performanceLevel!
        }
        if self.size != nil {
            map["Size"] = self.size!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Category") {
            self.category = dict["Category"] as! String
        }
        if dict.keys.contains("Count") {
            self.count = dict["Count"] as! Int32
        }
        if dict.keys.contains("PerformanceLevel") {
            self.performanceLevel = dict["PerformanceLevel"] as! String
        }
        if dict.keys.contains("Size") {
            self.size = dict["Size"] as! Int32
        }
    }
}

public class SystemDiskParam : Tea.TeaModel {
    public var category: String?

    public var performanceLevel: String?

    public var size: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.category != nil {
            map["Category"] = self.category!
        }
        if self.performanceLevel != nil {
            map["PerformanceLevel"] = self.performanceLevel!
        }
        if self.size != nil {
            map["Size"] = self.size!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Category") {
            self.category = dict["Category"] as! String
        }
        if dict.keys.contains("PerformanceLevel") {
            self.performanceLevel = dict["PerformanceLevel"] as! String
        }
        if dict.keys.contains("Size") {
            self.size = dict["Size"] as! Int32
        }
    }
}

public class Tag : Tea.TeaModel {
    public var key: String?

    public var value: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.key != nil {
            map["Key"] = self.key!
        }
        if self.value != nil {
            map["Value"] = self.value!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Key") {
            self.key = dict["Key"] as! String
        }
        if dict.keys.contains("Value") {
            self.value = dict["Value"] as! String
        }
    }
}

public class TagResource : Tea.TeaModel {
    public var resourceId: String?

    public var resourceType: String?

    public var tagKey: String?

    public var tagValue: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tagKey != nil {
            map["TagKey"] = self.tagKey!
        }
        if self.tagValue != nil {
            map["TagValue"] = self.tagValue!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! String
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("TagKey") {
            self.tagKey = dict["TagKey"] as! String
        }
        if dict.keys.contains("TagValue") {
            self.tagValue = dict["TagValue"] as! String
        }
    }
}

public class TimeConstraint : Tea.TeaModel {
    public var endTime: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class TimeRange : Tea.TeaModel {
    public var endTime: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class TimeTrigger : Tea.TeaModel {
    public var endTime: Int64?

    public var launchExpirationTime: Int32?

    public var launchTime: String?

    public var recurrenceType: String?

    public var recurrenceValue: String?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.launchExpirationTime != nil {
            map["LaunchExpirationTime"] = self.launchExpirationTime!
        }
        if self.launchTime != nil {
            map["LaunchTime"] = self.launchTime!
        }
        if self.recurrenceType != nil {
            map["RecurrenceType"] = self.recurrenceType!
        }
        if self.recurrenceValue != nil {
            map["RecurrenceValue"] = self.recurrenceValue!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("LaunchExpirationTime") {
            self.launchExpirationTime = dict["LaunchExpirationTime"] as! Int32
        }
        if dict.keys.contains("LaunchTime") {
            self.launchTime = dict["LaunchTime"] as! String
        }
        if dict.keys.contains("RecurrenceType") {
            self.recurrenceType = dict["RecurrenceType"] as! String
        }
        if dict.keys.contains("RecurrenceValue") {
            self.recurrenceValue = dict["RecurrenceValue"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
    }
}

public class Toleration : Tea.TeaModel {
    public var effect: String?

    public var key: String?

    public var operator_: String?

    public var value: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.effect != nil {
            map["Effect"] = self.effect!
        }
        if self.key != nil {
            map["Key"] = self.key!
        }
        if self.operator_ != nil {
            map["Operator"] = self.operator_!
        }
        if self.value != nil {
            map["Value"] = self.value!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Effect") {
            self.effect = dict["Effect"] as! String
        }
        if dict.keys.contains("Key") {
            self.key = dict["Key"] as! String
        }
        if dict.keys.contains("Operator") {
            self.operator_ = dict["Operator"] as! String
        }
        if dict.keys.contains("Value") {
            self.value = dict["Value"] as! String
        }
    }
}

public class TriggerCondition : Tea.TeaModel {
    public var comparisonOperator: String?

    public var metricName: String?

    public var statistics: String?

    public var tags: [Tag]?

    public var threshold: Double?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.comparisonOperator != nil {
            map["ComparisonOperator"] = self.comparisonOperator!
        }
        if self.metricName != nil {
            map["MetricName"] = self.metricName!
        }
        if self.statistics != nil {
            map["Statistics"] = self.statistics!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        if self.threshold != nil {
            map["Threshold"] = self.threshold!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ComparisonOperator") {
            self.comparisonOperator = dict["ComparisonOperator"] as! String
        }
        if dict.keys.contains("MetricName") {
            self.metricName = dict["MetricName"] as! String
        }
        if dict.keys.contains("Statistics") {
            self.statistics = dict["Statistics"] as! String
        }
        if dict.keys.contains("Tags") {
            var tmp : [Tag] = []
            for v in dict["Tags"] as! [Any] {
                var model = Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
        if dict.keys.contains("Threshold") {
            self.threshold = dict["Threshold"] as! Double
        }
    }
}

public class UpdateApplicationConfig : Tea.TeaModel {
    public var configDescription: String?

    public var configFileName: String?

    public var configItemKey: String?

    public var configItemValue: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configDescription != nil {
            map["ConfigDescription"] = self.configDescription!
        }
        if self.configFileName != nil {
            map["ConfigFileName"] = self.configFileName!
        }
        if self.configItemKey != nil {
            map["ConfigItemKey"] = self.configItemKey!
        }
        if self.configItemValue != nil {
            map["ConfigItemValue"] = self.configItemValue!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConfigDescription") {
            self.configDescription = dict["ConfigDescription"] as! String
        }
        if dict.keys.contains("ConfigFileName") {
            self.configFileName = dict["ConfigFileName"] as! String
        }
        if dict.keys.contains("ConfigItemKey") {
            self.configItemKey = dict["ConfigItemKey"] as! String
        }
        if dict.keys.contains("ConfigItemValue") {
            self.configItemValue = dict["ConfigItemValue"] as! String
        }
    }
}

public class UpdateSpecNodeGroup : Tea.TeaModel {
    public var newInstanceType: String?

    public var nodeGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.newInstanceType != nil {
            map["NewInstanceType"] = self.newInstanceType!
        }
        if self.nodeGroupId != nil {
            map["NodeGroupId"] = self.nodeGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NewInstanceType") {
            self.newInstanceType = dict["NewInstanceType"] as! String
        }
        if dict.keys.contains("NodeGroupId") {
            self.nodeGroupId = dict["NodeGroupId"] as! String
        }
    }
}

public class UpdateSpecNodeGroupParam : Tea.TeaModel {
    public var newInstanceType: String?

    public var nodeGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.newInstanceType != nil {
            map["NewInstanceType"] = self.newInstanceType!
        }
        if self.nodeGroupId != nil {
            map["NodeGroupId"] = self.nodeGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NewInstanceType") {
            self.newInstanceType = dict["NewInstanceType"] as! String
        }
        if dict.keys.contains("NodeGroupId") {
            self.nodeGroupId = dict["NodeGroupId"] as! String
        }
    }
}

public class User : Tea.TeaModel {
    public var group: String?

    public var password: String?

    public var userId: String?

    public var userName: String?

    public var userType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.group != nil {
            map["Group"] = self.group!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        if self.userName != nil {
            map["UserName"] = self.userName!
        }
        if self.userType != nil {
            map["UserType"] = self.userType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Group") {
            self.group = dict["Group"] as! String
        }
        if dict.keys.contains("Password") {
            self.password = dict["Password"] as! String
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
        if dict.keys.contains("UserName") {
            self.userName = dict["UserName"] as! String
        }
        if dict.keys.contains("UserType") {
            self.userType = dict["UserType"] as! String
        }
    }
}

public class UserParam : Tea.TeaModel {
    public var password: String?

    public var userId: String?

    public var userName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.password != nil {
            map["Password"] = self.password!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        if self.userName != nil {
            map["UserName"] = self.userName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Password") {
            self.password = dict["Password"] as! String
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
        if dict.keys.contains("UserName") {
            self.userName = dict["UserName"] as! String
        }
    }
}

public class ValueConstraints : Tea.TeaModel {
    public var defaultValue: Int32?

    public var end: Int32?

    public var start: Int32?

    public var step: Int32?

    public var type: String?

    public var values: [Int32]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.defaultValue != nil {
            map["DefaultValue"] = self.defaultValue!
        }
        if self.end != nil {
            map["End"] = self.end!
        }
        if self.start != nil {
            map["Start"] = self.start!
        }
        if self.step != nil {
            map["Step"] = self.step!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.values != nil {
            map["Values"] = self.values!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DefaultValue") {
            self.defaultValue = dict["DefaultValue"] as! Int32
        }
        if dict.keys.contains("End") {
            self.end = dict["End"] as! Int32
        }
        if dict.keys.contains("Start") {
            self.start = dict["Start"] as! Int32
        }
        if dict.keys.contains("Step") {
            self.step = dict["Step"] as! Int32
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("Values") {
            self.values = dict["Values"] as! [Int32]
        }
    }
}

public class CreateApiTemplateRequest : Tea.TeaModel {
    public var apiName: String?

    public var content: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var templateName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiName != nil {
            map["ApiName"] = self.apiName!
        }
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.templateName != nil {
            map["TemplateName"] = self.templateName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiName") {
            self.apiName = dict["ApiName"] as! String
        }
        if dict.keys.contains("Content") {
            self.content = dict["Content"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("TemplateName") {
            self.templateName = dict["TemplateName"] as! String
        }
    }
}

public class CreateApiTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class CreateApiTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateApiTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateApiTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateClusterRequest : Tea.TeaModel {
    public var applicationConfigs: [ApplicationConfig]?

    public var applications: [Application]?

    public var bootstrapScripts: [Script]?

    public var clientToken: String?

    public var clusterName: String?

    public var clusterType: String?

    public var deployMode: String?

    public var nodeAttributes: NodeAttributes?

    public var nodeGroups: [NodeGroupConfig]?

    public var paymentType: String?

    public var regionId: String?

    public var releaseVersion: String?

    public var resourceGroupId: String?

    public var securityMode: String?

    public var subscriptionConfig: SubscriptionConfig?

    public var tags: [Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.nodeAttributes?.validate()
        try self.subscriptionConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationConfigs != nil {
            var tmp : [Any] = []
            for k in self.applicationConfigs! {
                tmp.append(k.toMap())
            }
            map["ApplicationConfigs"] = tmp
        }
        if self.applications != nil {
            var tmp : [Any] = []
            for k in self.applications! {
                tmp.append(k.toMap())
            }
            map["Applications"] = tmp
        }
        if self.bootstrapScripts != nil {
            var tmp : [Any] = []
            for k in self.bootstrapScripts! {
                tmp.append(k.toMap())
            }
            map["BootstrapScripts"] = tmp
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.clusterName != nil {
            map["ClusterName"] = self.clusterName!
        }
        if self.clusterType != nil {
            map["ClusterType"] = self.clusterType!
        }
        if self.deployMode != nil {
            map["DeployMode"] = self.deployMode!
        }
        if self.nodeAttributes != nil {
            map["NodeAttributes"] = self.nodeAttributes?.toMap()
        }
        if self.nodeGroups != nil {
            var tmp : [Any] = []
            for k in self.nodeGroups! {
                tmp.append(k.toMap())
            }
            map["NodeGroups"] = tmp
        }
        if self.paymentType != nil {
            map["PaymentType"] = self.paymentType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.releaseVersion != nil {
            map["ReleaseVersion"] = self.releaseVersion!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.securityMode != nil {
            map["SecurityMode"] = self.securityMode!
        }
        if self.subscriptionConfig != nil {
            map["SubscriptionConfig"] = self.subscriptionConfig?.toMap()
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApplicationConfigs") {
            var tmp : [ApplicationConfig] = []
            for v in dict["ApplicationConfigs"] as! [Any] {
                var model = ApplicationConfig()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.applicationConfigs = tmp
        }
        if dict.keys.contains("Applications") {
            var tmp : [Application] = []
            for v in dict["Applications"] as! [Any] {
                var model = Application()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.applications = tmp
        }
        if dict.keys.contains("BootstrapScripts") {
            var tmp : [Script] = []
            for v in dict["BootstrapScripts"] as! [Any] {
                var model = Script()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.bootstrapScripts = tmp
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("ClusterName") {
            self.clusterName = dict["ClusterName"] as! String
        }
        if dict.keys.contains("ClusterType") {
            self.clusterType = dict["ClusterType"] as! String
        }
        if dict.keys.contains("DeployMode") {
            self.deployMode = dict["DeployMode"] as! String
        }
        if dict.keys.contains("NodeAttributes") {
            var model = NodeAttributes()
            model.fromMap(dict["NodeAttributes"] as! [String: Any])
            self.nodeAttributes = model
        }
        if dict.keys.contains("NodeGroups") {
            var tmp : [NodeGroupConfig] = []
            for v in dict["NodeGroups"] as! [Any] {
                var model = NodeGroupConfig()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.nodeGroups = tmp
        }
        if dict.keys.contains("PaymentType") {
            self.paymentType = dict["PaymentType"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ReleaseVersion") {
            self.releaseVersion = dict["ReleaseVersion"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("SecurityMode") {
            self.securityMode = dict["SecurityMode"] as! String
        }
        if dict.keys.contains("SubscriptionConfig") {
            var model = SubscriptionConfig()
            model.fromMap(dict["SubscriptionConfig"] as! [String: Any])
            self.subscriptionConfig = model
        }
        if dict.keys.contains("Tags") {
            var tmp : [Tag] = []
            for v in dict["Tags"] as! [Any] {
                var model = Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
    }
}

public class CreateClusterResponseBody : Tea.TeaModel {
    public var clusterId: String?

    public var operationId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.operationId != nil {
            map["OperationId"] = self.operationId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("OperationId") {
            self.operationId = dict["OperationId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateClusterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateClusterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateClusterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateNodeGroupRequest : Tea.TeaModel {
    public var clusterId: String?

    public var nodeGroup: NodeGroupConfig?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.nodeGroup?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.nodeGroup != nil {
            map["NodeGroup"] = self.nodeGroup?.toMap()
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("NodeGroup") {
            var model = NodeGroupConfig()
            model.fromMap(dict["NodeGroup"] as! [String: Any])
            self.nodeGroup = model
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class CreateNodeGroupResponseBody : Tea.TeaModel {
    public var nodeGroupId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nodeGroupId != nil {
            map["NodeGroupId"] = self.nodeGroupId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NodeGroupId") {
            self.nodeGroupId = dict["NodeGroupId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateNodeGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateNodeGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateNodeGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateScriptRequest : Tea.TeaModel {
    public var clusterId: String?

    public var regionId: String?

    public var scriptType: String?

    public var scripts: [Script]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.scriptType != nil {
            map["ScriptType"] = self.scriptType!
        }
        if self.scripts != nil {
            var tmp : [Any] = []
            for k in self.scripts! {
                tmp.append(k.toMap())
            }
            map["Scripts"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ScriptType") {
            self.scriptType = dict["ScriptType"] as! String
        }
        if dict.keys.contains("Scripts") {
            var tmp : [Script] = []
            for v in dict["Scripts"] as! [Any] {
                var model = Script()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.scripts = tmp
        }
    }
}

public class CreateScriptResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var scriptId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scriptId != nil {
            map["ScriptId"] = self.scriptId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScriptId") {
            self.scriptId = dict["ScriptId"] as! String
        }
    }
}

public class CreateScriptResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateScriptResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateScriptResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DecreaseNodesRequest : Tea.TeaModel {
    public var clusterId: String?

    public var decreaseNodeCount: Int32?

    public var nodeGroupId: String?

    public var nodeIds: [String]?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.decreaseNodeCount != nil {
            map["DecreaseNodeCount"] = self.decreaseNodeCount!
        }
        if self.nodeGroupId != nil {
            map["NodeGroupId"] = self.nodeGroupId!
        }
        if self.nodeIds != nil {
            map["NodeIds"] = self.nodeIds!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("DecreaseNodeCount") {
            self.decreaseNodeCount = dict["DecreaseNodeCount"] as! Int32
        }
        if dict.keys.contains("NodeGroupId") {
            self.nodeGroupId = dict["NodeGroupId"] as! String
        }
        if dict.keys.contains("NodeIds") {
            self.nodeIds = dict["NodeIds"] as! [String]
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DecreaseNodesResponseBody : Tea.TeaModel {
    public var operationId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.operationId != nil {
            map["OperationId"] = self.operationId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OperationId") {
            self.operationId = dict["OperationId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DecreaseNodesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DecreaseNodesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DecreaseNodesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteApiTemplateRequest : Tea.TeaModel {
    public var apiName: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiName != nil {
            map["ApiName"] = self.apiName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiName") {
            self.apiName = dict["ApiName"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class DeleteApiTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteApiTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteApiTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteApiTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteClusterRequest : Tea.TeaModel {
    public var clusterId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DeleteClusterResponseBody : Tea.TeaModel {
    public var operationId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.operationId != nil {
            map["OperationId"] = self.operationId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OperationId") {
            self.operationId = dict["OperationId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteClusterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteClusterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteClusterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteScriptRequest : Tea.TeaModel {
    public var clusterId: String?

    public var regionId: String?

    public var scriptId: String?

    public var scriptType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.scriptId != nil {
            map["ScriptId"] = self.scriptId!
        }
        if self.scriptType != nil {
            map["ScriptType"] = self.scriptType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ScriptId") {
            self.scriptId = dict["ScriptId"] as! String
        }
        if dict.keys.contains("ScriptType") {
            self.scriptType = dict["ScriptType"] as! String
        }
    }
}

public class DeleteScriptResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteScriptResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteScriptResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteScriptResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetApiTemplateRequest : Tea.TeaModel {
    public var regionId: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class GetApiTemplateResponseBody : Tea.TeaModel {
    public var data: ApiTemplate?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = ApiTemplate()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetApiTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetApiTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetApiTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetApplicationRequest : Tea.TeaModel {
    public var applicationName: String?

    public var clusterId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationName != nil {
            map["ApplicationName"] = self.applicationName!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApplicationName") {
            self.applicationName = dict["ApplicationName"] as! String
        }
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class GetApplicationResponseBody : Tea.TeaModel {
    public class Application : Tea.TeaModel {
        public class Actions : Tea.TeaModel {
            public class ActionParams : Tea.TeaModel {
                public class ValueAttribute : Tea.TeaModel {
                    public var description_: String?

                    public var valueIncrementStep: String?

                    public var valueMaximum: String?

                    public var valueMinimum: String?

                    public var valueType: String?

                    public var valueUnit: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.description_ != nil {
                            map["Description"] = self.description_!
                        }
                        if self.valueIncrementStep != nil {
                            map["ValueIncrementStep"] = self.valueIncrementStep!
                        }
                        if self.valueMaximum != nil {
                            map["ValueMaximum"] = self.valueMaximum!
                        }
                        if self.valueMinimum != nil {
                            map["ValueMinimum"] = self.valueMinimum!
                        }
                        if self.valueType != nil {
                            map["ValueType"] = self.valueType!
                        }
                        if self.valueUnit != nil {
                            map["ValueUnit"] = self.valueUnit!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Description") {
                            self.description_ = dict["Description"] as! String
                        }
                        if dict.keys.contains("ValueIncrementStep") {
                            self.valueIncrementStep = dict["ValueIncrementStep"] as! String
                        }
                        if dict.keys.contains("ValueMaximum") {
                            self.valueMaximum = dict["ValueMaximum"] as! String
                        }
                        if dict.keys.contains("ValueMinimum") {
                            self.valueMinimum = dict["ValueMinimum"] as! String
                        }
                        if dict.keys.contains("ValueType") {
                            self.valueType = dict["ValueType"] as! String
                        }
                        if dict.keys.contains("ValueUnit") {
                            self.valueUnit = dict["ValueUnit"] as! String
                        }
                    }
                }
                public var description_: String?

                public var key: String?

                public var valueAttribute: GetApplicationResponseBody.Application.Actions.ActionParams.ValueAttribute?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.valueAttribute?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.valueAttribute != nil {
                        map["ValueAttribute"] = self.valueAttribute?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Key") {
                        self.key = dict["Key"] as! String
                    }
                    if dict.keys.contains("ValueAttribute") {
                        var model = GetApplicationResponseBody.Application.Actions.ActionParams.ValueAttribute()
                        model.fromMap(dict["ValueAttribute"] as! [String: Any])
                        self.valueAttribute = model
                    }
                }
            }
            public var actionName: String?

            public var actionParams: [GetApplicationResponseBody.Application.Actions.ActionParams]?

            public var command: String?

            public var componentName: String?

            public var description_: String?

            public var runActionScope: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.actionName != nil {
                    map["ActionName"] = self.actionName!
                }
                if self.actionParams != nil {
                    var tmp : [Any] = []
                    for k in self.actionParams! {
                        tmp.append(k.toMap())
                    }
                    map["ActionParams"] = tmp
                }
                if self.command != nil {
                    map["Command"] = self.command!
                }
                if self.componentName != nil {
                    map["ComponentName"] = self.componentName!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.runActionScope != nil {
                    map["RunActionScope"] = self.runActionScope!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ActionName") {
                    self.actionName = dict["ActionName"] as! String
                }
                if dict.keys.contains("ActionParams") {
                    var tmp : [GetApplicationResponseBody.Application.Actions.ActionParams] = []
                    for v in dict["ActionParams"] as! [Any] {
                        var model = GetApplicationResponseBody.Application.Actions.ActionParams()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.actionParams = tmp
                }
                if dict.keys.contains("Command") {
                    self.command = dict["Command"] as! String
                }
                if dict.keys.contains("ComponentName") {
                    self.componentName = dict["ComponentName"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("RunActionScope") {
                    self.runActionScope = dict["RunActionScope"] as! String
                }
            }
        }
        public var actions: [GetApplicationResponseBody.Application.Actions]?

        public var applicationName: String?

        public var applicationState: String?

        public var applicationVersion: String?

        public var communityVersion: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.actions != nil {
                var tmp : [Any] = []
                for k in self.actions! {
                    tmp.append(k.toMap())
                }
                map["Actions"] = tmp
            }
            if self.applicationName != nil {
                map["ApplicationName"] = self.applicationName!
            }
            if self.applicationState != nil {
                map["ApplicationState"] = self.applicationState!
            }
            if self.applicationVersion != nil {
                map["ApplicationVersion"] = self.applicationVersion!
            }
            if self.communityVersion != nil {
                map["CommunityVersion"] = self.communityVersion!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Actions") {
                var tmp : [GetApplicationResponseBody.Application.Actions] = []
                for v in dict["Actions"] as! [Any] {
                    var model = GetApplicationResponseBody.Application.Actions()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.actions = tmp
            }
            if dict.keys.contains("ApplicationName") {
                self.applicationName = dict["ApplicationName"] as! String
            }
            if dict.keys.contains("ApplicationState") {
                self.applicationState = dict["ApplicationState"] as! String
            }
            if dict.keys.contains("ApplicationVersion") {
                self.applicationVersion = dict["ApplicationVersion"] as! String
            }
            if dict.keys.contains("CommunityVersion") {
                self.communityVersion = dict["CommunityVersion"] as! String
            }
        }
    }
    public var application: GetApplicationResponseBody.Application?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.application?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.application != nil {
            map["Application"] = self.application?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Application") {
            var model = GetApplicationResponseBody.Application()
            model.fromMap(dict["Application"] as! [String: Any])
            self.application = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetApplicationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetAutoScalingActivityRequest : Tea.TeaModel {
    public var clusterId: String?

    public var regionId: String?

    public var scalingActivityId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.scalingActivityId != nil {
            map["ScalingActivityId"] = self.scalingActivityId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ScalingActivityId") {
            self.scalingActivityId = dict["ScalingActivityId"] as! String
        }
    }
}

public class GetAutoScalingActivityResponseBody : Tea.TeaModel {
    public class ScalingActivity : Tea.TeaModel {
        public var activityId: String?

        public var activityResults: [ScalingActivityResult]?

        public var activityState: String?

        public var activityType: String?

        public var clusterId: String?

        public var description_: String?

        public var endTime: Int64?

        public var expectNum: Int32?

        public var nodeGroupId: String?

        public var nodeGroupName: String?

        public var operationId: String?

        public var ruleDetail: ScalingRule?

        public var ruleName: String?

        public var startTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.ruleDetail?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.activityId != nil {
                map["ActivityId"] = self.activityId!
            }
            if self.activityResults != nil {
                var tmp : [Any] = []
                for k in self.activityResults! {
                    tmp.append(k.toMap())
                }
                map["ActivityResults"] = tmp
            }
            if self.activityState != nil {
                map["ActivityState"] = self.activityState!
            }
            if self.activityType != nil {
                map["ActivityType"] = self.activityType!
            }
            if self.clusterId != nil {
                map["ClusterId"] = self.clusterId!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.expectNum != nil {
                map["ExpectNum"] = self.expectNum!
            }
            if self.nodeGroupId != nil {
                map["NodeGroupId"] = self.nodeGroupId!
            }
            if self.nodeGroupName != nil {
                map["NodeGroupName"] = self.nodeGroupName!
            }
            if self.operationId != nil {
                map["OperationId"] = self.operationId!
            }
            if self.ruleDetail != nil {
                map["RuleDetail"] = self.ruleDetail?.toMap()
            }
            if self.ruleName != nil {
                map["RuleName"] = self.ruleName!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ActivityId") {
                self.activityId = dict["ActivityId"] as! String
            }
            if dict.keys.contains("ActivityResults") {
                var tmp : [ScalingActivityResult] = []
                for v in dict["ActivityResults"] as! [Any] {
                    var model = ScalingActivityResult()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.activityResults = tmp
            }
            if dict.keys.contains("ActivityState") {
                self.activityState = dict["ActivityState"] as! String
            }
            if dict.keys.contains("ActivityType") {
                self.activityType = dict["ActivityType"] as! String
            }
            if dict.keys.contains("ClusterId") {
                self.clusterId = dict["ClusterId"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("EndTime") {
                self.endTime = dict["EndTime"] as! Int64
            }
            if dict.keys.contains("ExpectNum") {
                self.expectNum = dict["ExpectNum"] as! Int32
            }
            if dict.keys.contains("NodeGroupId") {
                self.nodeGroupId = dict["NodeGroupId"] as! String
            }
            if dict.keys.contains("NodeGroupName") {
                self.nodeGroupName = dict["NodeGroupName"] as! String
            }
            if dict.keys.contains("OperationId") {
                self.operationId = dict["OperationId"] as! String
            }
            if dict.keys.contains("RuleDetail") {
                var model = ScalingRule()
                model.fromMap(dict["RuleDetail"] as! [String: Any])
                self.ruleDetail = model
            }
            if dict.keys.contains("RuleName") {
                self.ruleName = dict["RuleName"] as! String
            }
            if dict.keys.contains("StartTime") {
                self.startTime = dict["StartTime"] as! Int64
            }
        }
    }
    public var requestId: String?

    public var scalingActivity: GetAutoScalingActivityResponseBody.ScalingActivity?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.scalingActivity?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingActivity != nil {
            map["ScalingActivity"] = self.scalingActivity?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScalingActivity") {
            var model = GetAutoScalingActivityResponseBody.ScalingActivity()
            model.fromMap(dict["ScalingActivity"] as! [String: Any])
            self.scalingActivity = model
        }
    }
}

public class GetAutoScalingActivityResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAutoScalingActivityResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetAutoScalingActivityResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetAutoScalingPolicyRequest : Tea.TeaModel {
    public var clusterId: String?

    public var nodeGroupId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.nodeGroupId != nil {
            map["NodeGroupId"] = self.nodeGroupId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("NodeGroupId") {
            self.nodeGroupId = dict["NodeGroupId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class GetAutoScalingPolicyResponseBody : Tea.TeaModel {
    public class ScalingPolicy : Tea.TeaModel {
        public class Constraints : Tea.TeaModel {
            public var maxCapacity: Int32?

            public var minCapacity: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.maxCapacity != nil {
                    map["MaxCapacity"] = self.maxCapacity!
                }
                if self.minCapacity != nil {
                    map["MinCapacity"] = self.minCapacity!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("MaxCapacity") {
                    self.maxCapacity = dict["MaxCapacity"] as! Int32
                }
                if dict.keys.contains("MinCapacity") {
                    self.minCapacity = dict["MinCapacity"] as! Int32
                }
            }
        }
        public class ScalingRules : Tea.TeaModel {
            public var activityType: String?

            public var adjustmentType: String?

            public var adjustmentValue: Int32?

            public var metricsTrigger: MetricsTrigger?

            public var ruleName: String?

            public var timeTrigger: TimeTrigger?

            public var triggerType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.metricsTrigger?.validate()
                try self.timeTrigger?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.activityType != nil {
                    map["ActivityType"] = self.activityType!
                }
                if self.adjustmentType != nil {
                    map["AdjustmentType"] = self.adjustmentType!
                }
                if self.adjustmentValue != nil {
                    map["AdjustmentValue"] = self.adjustmentValue!
                }
                if self.metricsTrigger != nil {
                    map["MetricsTrigger"] = self.metricsTrigger?.toMap()
                }
                if self.ruleName != nil {
                    map["RuleName"] = self.ruleName!
                }
                if self.timeTrigger != nil {
                    map["TimeTrigger"] = self.timeTrigger?.toMap()
                }
                if self.triggerType != nil {
                    map["TriggerType"] = self.triggerType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ActivityType") {
                    self.activityType = dict["ActivityType"] as! String
                }
                if dict.keys.contains("AdjustmentType") {
                    self.adjustmentType = dict["AdjustmentType"] as! String
                }
                if dict.keys.contains("AdjustmentValue") {
                    self.adjustmentValue = dict["AdjustmentValue"] as! Int32
                }
                if dict.keys.contains("MetricsTrigger") {
                    var model = MetricsTrigger()
                    model.fromMap(dict["MetricsTrigger"] as! [String: Any])
                    self.metricsTrigger = model
                }
                if dict.keys.contains("RuleName") {
                    self.ruleName = dict["RuleName"] as! String
                }
                if dict.keys.contains("TimeTrigger") {
                    var model = TimeTrigger()
                    model.fromMap(dict["TimeTrigger"] as! [String: Any])
                    self.timeTrigger = model
                }
                if dict.keys.contains("TriggerType") {
                    self.triggerType = dict["TriggerType"] as! String
                }
            }
        }
        public var clusterId: String?

        public var constraints: GetAutoScalingPolicyResponseBody.ScalingPolicy.Constraints?

        public var nodeGroupId: String?

        public var scalingPolicyId: String?

        public var scalingRules: [GetAutoScalingPolicyResponseBody.ScalingPolicy.ScalingRules]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.constraints?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clusterId != nil {
                map["ClusterId"] = self.clusterId!
            }
            if self.constraints != nil {
                map["Constraints"] = self.constraints?.toMap()
            }
            if self.nodeGroupId != nil {
                map["NodeGroupId"] = self.nodeGroupId!
            }
            if self.scalingPolicyId != nil {
                map["ScalingPolicyId"] = self.scalingPolicyId!
            }
            if self.scalingRules != nil {
                var tmp : [Any] = []
                for k in self.scalingRules! {
                    tmp.append(k.toMap())
                }
                map["ScalingRules"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClusterId") {
                self.clusterId = dict["ClusterId"] as! String
            }
            if dict.keys.contains("Constraints") {
                var model = GetAutoScalingPolicyResponseBody.ScalingPolicy.Constraints()
                model.fromMap(dict["Constraints"] as! [String: Any])
                self.constraints = model
            }
            if dict.keys.contains("NodeGroupId") {
                self.nodeGroupId = dict["NodeGroupId"] as! String
            }
            if dict.keys.contains("ScalingPolicyId") {
                self.scalingPolicyId = dict["ScalingPolicyId"] as! String
            }
            if dict.keys.contains("ScalingRules") {
                var tmp : [GetAutoScalingPolicyResponseBody.ScalingPolicy.ScalingRules] = []
                for v in dict["ScalingRules"] as! [Any] {
                    var model = GetAutoScalingPolicyResponseBody.ScalingPolicy.ScalingRules()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.scalingRules = tmp
            }
        }
    }
    public var requestId: String?

    public var scalingPolicy: GetAutoScalingPolicyResponseBody.ScalingPolicy?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.scalingPolicy?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingPolicy != nil {
            map["ScalingPolicy"] = self.scalingPolicy?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScalingPolicy") {
            var model = GetAutoScalingPolicyResponseBody.ScalingPolicy()
            model.fromMap(dict["ScalingPolicy"] as! [String: Any])
            self.scalingPolicy = model
        }
    }
}

public class GetAutoScalingPolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAutoScalingPolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetAutoScalingPolicyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetClusterRequest : Tea.TeaModel {
    public var clusterId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class GetClusterResponseBody : Tea.TeaModel {
    public var cluster: Cluster?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.cluster?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cluster != nil {
            map["Cluster"] = self.cluster?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Cluster") {
            var model = Cluster()
            model.fromMap(dict["Cluster"] as! [String: Any])
            self.cluster = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetClusterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetClusterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetClusterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDoctorApplicationRequest : Tea.TeaModel {
    public var appId: String?

    public var clusterId: String?

    public var dateTime: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.dateTime != nil {
            map["DateTime"] = self.dateTime!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("DateTime") {
            self.dateTime = dict["DateTime"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class GetDoctorApplicationResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Analysis : Tea.TeaModel {
            public var score: Int32?

            public var suggestion: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.score != nil {
                    map["Score"] = self.score!
                }
                if self.suggestion != nil {
                    map["Suggestion"] = self.suggestion!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Score") {
                    self.score = dict["Score"] as! Int32
                }
                if dict.keys.contains("Suggestion") {
                    self.suggestion = dict["Suggestion"] as! String
                }
            }
        }
        public class Metrics : Tea.TeaModel {
            public class MemSeconds : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class MemUtilization : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class VcoreSeconds : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class VcoreUtilization : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public var memSeconds: GetDoctorApplicationResponseBody.Data.Metrics.MemSeconds?

            public var memUtilization: GetDoctorApplicationResponseBody.Data.Metrics.MemUtilization?

            public var vcoreSeconds: GetDoctorApplicationResponseBody.Data.Metrics.VcoreSeconds?

            public var vcoreUtilization: GetDoctorApplicationResponseBody.Data.Metrics.VcoreUtilization?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.memSeconds?.validate()
                try self.memUtilization?.validate()
                try self.vcoreSeconds?.validate()
                try self.vcoreUtilization?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.memSeconds != nil {
                    map["MemSeconds"] = self.memSeconds?.toMap()
                }
                if self.memUtilization != nil {
                    map["MemUtilization"] = self.memUtilization?.toMap()
                }
                if self.vcoreSeconds != nil {
                    map["VcoreSeconds"] = self.vcoreSeconds?.toMap()
                }
                if self.vcoreUtilization != nil {
                    map["VcoreUtilization"] = self.vcoreUtilization?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("MemSeconds") {
                    var model = GetDoctorApplicationResponseBody.Data.Metrics.MemSeconds()
                    model.fromMap(dict["MemSeconds"] as! [String: Any])
                    self.memSeconds = model
                }
                if dict.keys.contains("MemUtilization") {
                    var model = GetDoctorApplicationResponseBody.Data.Metrics.MemUtilization()
                    model.fromMap(dict["MemUtilization"] as! [String: Any])
                    self.memUtilization = model
                }
                if dict.keys.contains("VcoreSeconds") {
                    var model = GetDoctorApplicationResponseBody.Data.Metrics.VcoreSeconds()
                    model.fromMap(dict["VcoreSeconds"] as! [String: Any])
                    self.vcoreSeconds = model
                }
                if dict.keys.contains("VcoreUtilization") {
                    var model = GetDoctorApplicationResponseBody.Data.Metrics.VcoreUtilization()
                    model.fromMap(dict["VcoreUtilization"] as! [String: Any])
                    self.vcoreUtilization = model
                }
            }
        }
        public var analysis: GetDoctorApplicationResponseBody.Data.Analysis?

        public var appName: String?

        public var endTime: Int64?

        public var ids: [String]?

        public var metrics: GetDoctorApplicationResponseBody.Data.Metrics?

        public var querySql: String?

        public var queue: String?

        public var startTime: Int64?

        public var type: String?

        public var user: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.analysis?.validate()
            try self.metrics?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.analysis != nil {
                map["Analysis"] = self.analysis?.toMap()
            }
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.ids != nil {
                map["Ids"] = self.ids!
            }
            if self.metrics != nil {
                map["Metrics"] = self.metrics?.toMap()
            }
            if self.querySql != nil {
                map["QuerySql"] = self.querySql!
            }
            if self.queue != nil {
                map["Queue"] = self.queue!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.user != nil {
                map["User"] = self.user!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Analysis") {
                var model = GetDoctorApplicationResponseBody.Data.Analysis()
                model.fromMap(dict["Analysis"] as! [String: Any])
                self.analysis = model
            }
            if dict.keys.contains("AppName") {
                self.appName = dict["AppName"] as! String
            }
            if dict.keys.contains("EndTime") {
                self.endTime = dict["EndTime"] as! Int64
            }
            if dict.keys.contains("Ids") {
                self.ids = dict["Ids"] as! [String]
            }
            if dict.keys.contains("Metrics") {
                var model = GetDoctorApplicationResponseBody.Data.Metrics()
                model.fromMap(dict["Metrics"] as! [String: Any])
                self.metrics = model
            }
            if dict.keys.contains("QuerySql") {
                self.querySql = dict["QuerySql"] as! String
            }
            if dict.keys.contains("Queue") {
                self.queue = dict["Queue"] as! String
            }
            if dict.keys.contains("StartTime") {
                self.startTime = dict["StartTime"] as! Int64
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("User") {
                self.user = dict["User"] as! String
            }
        }
    }
    public var data: GetDoctorApplicationResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = GetDoctorApplicationResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetDoctorApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDoctorApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDoctorApplicationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDoctorComputeSummaryRequest : Tea.TeaModel {
    public class ComponentInfo : Tea.TeaModel {
        public var componentName: String?

        public var componentType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.componentName != nil {
                map["ComponentName"] = self.componentName!
            }
            if self.componentType != nil {
                map["ComponentType"] = self.componentType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ComponentName") {
                self.componentName = dict["ComponentName"] as! String
            }
            if dict.keys.contains("ComponentType") {
                self.componentType = dict["ComponentType"] as! String
            }
        }
    }
    public var clusterId: String?

    public var componentInfo: GetDoctorComputeSummaryRequest.ComponentInfo?

    public var dateTime: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.componentInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.componentInfo != nil {
            map["ComponentInfo"] = self.componentInfo?.toMap()
        }
        if self.dateTime != nil {
            map["DateTime"] = self.dateTime!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("ComponentInfo") {
            var model = GetDoctorComputeSummaryRequest.ComponentInfo()
            model.fromMap(dict["ComponentInfo"] as! [String: Any])
            self.componentInfo = model
        }
        if dict.keys.contains("DateTime") {
            self.dateTime = dict["DateTime"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class GetDoctorComputeSummaryResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Analysis : Tea.TeaModel {
            public var healthyJobCount: Int64?

            public var needAttentionJobCount: Int64?

            public var score: Int32?

            public var scoreDayGrowthRatio: Double?

            public var subHealthyJobCount: Int64?

            public var unhealthyJobCount: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.healthyJobCount != nil {
                    map["HealthyJobCount"] = self.healthyJobCount!
                }
                if self.needAttentionJobCount != nil {
                    map["NeedAttentionJobCount"] = self.needAttentionJobCount!
                }
                if self.score != nil {
                    map["Score"] = self.score!
                }
                if self.scoreDayGrowthRatio != nil {
                    map["ScoreDayGrowthRatio"] = self.scoreDayGrowthRatio!
                }
                if self.subHealthyJobCount != nil {
                    map["SubHealthyJobCount"] = self.subHealthyJobCount!
                }
                if self.unhealthyJobCount != nil {
                    map["UnhealthyJobCount"] = self.unhealthyJobCount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("HealthyJobCount") {
                    self.healthyJobCount = dict["HealthyJobCount"] as! Int64
                }
                if dict.keys.contains("NeedAttentionJobCount") {
                    self.needAttentionJobCount = dict["NeedAttentionJobCount"] as! Int64
                }
                if dict.keys.contains("Score") {
                    self.score = dict["Score"] as! Int32
                }
                if dict.keys.contains("ScoreDayGrowthRatio") {
                    self.scoreDayGrowthRatio = dict["ScoreDayGrowthRatio"] as! Double
                }
                if dict.keys.contains("SubHealthyJobCount") {
                    self.subHealthyJobCount = dict["SubHealthyJobCount"] as! Int64
                }
                if dict.keys.contains("UnhealthyJobCount") {
                    self.unhealthyJobCount = dict["UnhealthyJobCount"] as! Int64
                }
            }
        }
        public class Metrics : Tea.TeaModel {
            public class MemSeconds : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class MemSecondsDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class MemUtilization : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class ReadSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class VcoreSeconds : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class VcoreSecondsDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class VcoreUtilization : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class WriteSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public var memSeconds: GetDoctorComputeSummaryResponseBody.Data.Metrics.MemSeconds?

            public var memSecondsDayGrowthRatio: GetDoctorComputeSummaryResponseBody.Data.Metrics.MemSecondsDayGrowthRatio?

            public var memUtilization: GetDoctorComputeSummaryResponseBody.Data.Metrics.MemUtilization?

            public var readSize: GetDoctorComputeSummaryResponseBody.Data.Metrics.ReadSize?

            public var vcoreSeconds: GetDoctorComputeSummaryResponseBody.Data.Metrics.VcoreSeconds?

            public var vcoreSecondsDayGrowthRatio: GetDoctorComputeSummaryResponseBody.Data.Metrics.VcoreSecondsDayGrowthRatio?

            public var vcoreUtilization: GetDoctorComputeSummaryResponseBody.Data.Metrics.VcoreUtilization?

            public var writeSize: GetDoctorComputeSummaryResponseBody.Data.Metrics.WriteSize?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.memSeconds?.validate()
                try self.memSecondsDayGrowthRatio?.validate()
                try self.memUtilization?.validate()
                try self.readSize?.validate()
                try self.vcoreSeconds?.validate()
                try self.vcoreSecondsDayGrowthRatio?.validate()
                try self.vcoreUtilization?.validate()
                try self.writeSize?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.memSeconds != nil {
                    map["MemSeconds"] = self.memSeconds?.toMap()
                }
                if self.memSecondsDayGrowthRatio != nil {
                    map["MemSecondsDayGrowthRatio"] = self.memSecondsDayGrowthRatio?.toMap()
                }
                if self.memUtilization != nil {
                    map["MemUtilization"] = self.memUtilization?.toMap()
                }
                if self.readSize != nil {
                    map["ReadSize"] = self.readSize?.toMap()
                }
                if self.vcoreSeconds != nil {
                    map["VcoreSeconds"] = self.vcoreSeconds?.toMap()
                }
                if self.vcoreSecondsDayGrowthRatio != nil {
                    map["VcoreSecondsDayGrowthRatio"] = self.vcoreSecondsDayGrowthRatio?.toMap()
                }
                if self.vcoreUtilization != nil {
                    map["VcoreUtilization"] = self.vcoreUtilization?.toMap()
                }
                if self.writeSize != nil {
                    map["WriteSize"] = self.writeSize?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("MemSeconds") {
                    var model = GetDoctorComputeSummaryResponseBody.Data.Metrics.MemSeconds()
                    model.fromMap(dict["MemSeconds"] as! [String: Any])
                    self.memSeconds = model
                }
                if dict.keys.contains("MemSecondsDayGrowthRatio") {
                    var model = GetDoctorComputeSummaryResponseBody.Data.Metrics.MemSecondsDayGrowthRatio()
                    model.fromMap(dict["MemSecondsDayGrowthRatio"] as! [String: Any])
                    self.memSecondsDayGrowthRatio = model
                }
                if dict.keys.contains("MemUtilization") {
                    var model = GetDoctorComputeSummaryResponseBody.Data.Metrics.MemUtilization()
                    model.fromMap(dict["MemUtilization"] as! [String: Any])
                    self.memUtilization = model
                }
                if dict.keys.contains("ReadSize") {
                    var model = GetDoctorComputeSummaryResponseBody.Data.Metrics.ReadSize()
                    model.fromMap(dict["ReadSize"] as! [String: Any])
                    self.readSize = model
                }
                if dict.keys.contains("VcoreSeconds") {
                    var model = GetDoctorComputeSummaryResponseBody.Data.Metrics.VcoreSeconds()
                    model.fromMap(dict["VcoreSeconds"] as! [String: Any])
                    self.vcoreSeconds = model
                }
                if dict.keys.contains("VcoreSecondsDayGrowthRatio") {
                    var model = GetDoctorComputeSummaryResponseBody.Data.Metrics.VcoreSecondsDayGrowthRatio()
                    model.fromMap(dict["VcoreSecondsDayGrowthRatio"] as! [String: Any])
                    self.vcoreSecondsDayGrowthRatio = model
                }
                if dict.keys.contains("VcoreUtilization") {
                    var model = GetDoctorComputeSummaryResponseBody.Data.Metrics.VcoreUtilization()
                    model.fromMap(dict["VcoreUtilization"] as! [String: Any])
                    self.vcoreUtilization = model
                }
                if dict.keys.contains("WriteSize") {
                    var model = GetDoctorComputeSummaryResponseBody.Data.Metrics.WriteSize()
                    model.fromMap(dict["WriteSize"] as! [String: Any])
                    self.writeSize = model
                }
            }
        }
        public var analysis: GetDoctorComputeSummaryResponseBody.Data.Analysis?

        public var metrics: GetDoctorComputeSummaryResponseBody.Data.Metrics?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.analysis?.validate()
            try self.metrics?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.analysis != nil {
                map["Analysis"] = self.analysis?.toMap()
            }
            if self.metrics != nil {
                map["Metrics"] = self.metrics?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Analysis") {
                var model = GetDoctorComputeSummaryResponseBody.Data.Analysis()
                model.fromMap(dict["Analysis"] as! [String: Any])
                self.analysis = model
            }
            if dict.keys.contains("Metrics") {
                var model = GetDoctorComputeSummaryResponseBody.Data.Metrics()
                model.fromMap(dict["Metrics"] as! [String: Any])
                self.metrics = model
            }
        }
    }
    public var data: GetDoctorComputeSummaryResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = GetDoctorComputeSummaryResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetDoctorComputeSummaryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDoctorComputeSummaryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDoctorComputeSummaryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDoctorHBaseClusterRequest : Tea.TeaModel {
    public var clusterId: String?

    public var dateTime: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.dateTime != nil {
            map["DateTime"] = self.dateTime!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("DateTime") {
            self.dateTime = dict["DateTime"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class GetDoctorHBaseClusterResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Analysis : Tea.TeaModel {
            public var hbaseScore: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.hbaseScore != nil {
                    map["HbaseScore"] = self.hbaseScore!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("HbaseScore") {
                    self.hbaseScore = dict["HbaseScore"] as! Int32
                }
            }
        }
        public class Metrics : Tea.TeaModel {
            public class AvgLoad : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class DailyReadRequest : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class DailyWriteRequest : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class MemHeap : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class NormalAvgLoad : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class RegionBalance : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class RegionCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class RegionServerCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class StoreFileCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class TableCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class TotalDataSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class TotalReadRequest : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class TotalRequest : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class TotalWriteRequest : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public var avgLoad: GetDoctorHBaseClusterResponseBody.Data.Metrics.AvgLoad?

            public var dailyReadRequest: GetDoctorHBaseClusterResponseBody.Data.Metrics.DailyReadRequest?

            public var dailyWriteRequest: GetDoctorHBaseClusterResponseBody.Data.Metrics.DailyWriteRequest?

            public var memHeap: GetDoctorHBaseClusterResponseBody.Data.Metrics.MemHeap?

            public var normalAvgLoad: GetDoctorHBaseClusterResponseBody.Data.Metrics.NormalAvgLoad?

            public var regionBalance: GetDoctorHBaseClusterResponseBody.Data.Metrics.RegionBalance?

            public var regionCount: GetDoctorHBaseClusterResponseBody.Data.Metrics.RegionCount?

            public var regionServerCount: GetDoctorHBaseClusterResponseBody.Data.Metrics.RegionServerCount?

            public var storeFileCount: GetDoctorHBaseClusterResponseBody.Data.Metrics.StoreFileCount?

            public var tableCount: GetDoctorHBaseClusterResponseBody.Data.Metrics.TableCount?

            public var totalDataSize: GetDoctorHBaseClusterResponseBody.Data.Metrics.TotalDataSize?

            public var totalReadRequest: GetDoctorHBaseClusterResponseBody.Data.Metrics.TotalReadRequest?

            public var totalRequest: GetDoctorHBaseClusterResponseBody.Data.Metrics.TotalRequest?

            public var totalWriteRequest: GetDoctorHBaseClusterResponseBody.Data.Metrics.TotalWriteRequest?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.avgLoad?.validate()
                try self.dailyReadRequest?.validate()
                try self.dailyWriteRequest?.validate()
                try self.memHeap?.validate()
                try self.normalAvgLoad?.validate()
                try self.regionBalance?.validate()
                try self.regionCount?.validate()
                try self.regionServerCount?.validate()
                try self.storeFileCount?.validate()
                try self.tableCount?.validate()
                try self.totalDataSize?.validate()
                try self.totalReadRequest?.validate()
                try self.totalRequest?.validate()
                try self.totalWriteRequest?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.avgLoad != nil {
                    map["AvgLoad"] = self.avgLoad?.toMap()
                }
                if self.dailyReadRequest != nil {
                    map["DailyReadRequest"] = self.dailyReadRequest?.toMap()
                }
                if self.dailyWriteRequest != nil {
                    map["DailyWriteRequest"] = self.dailyWriteRequest?.toMap()
                }
                if self.memHeap != nil {
                    map["MemHeap"] = self.memHeap?.toMap()
                }
                if self.normalAvgLoad != nil {
                    map["NormalAvgLoad"] = self.normalAvgLoad?.toMap()
                }
                if self.regionBalance != nil {
                    map["RegionBalance"] = self.regionBalance?.toMap()
                }
                if self.regionCount != nil {
                    map["RegionCount"] = self.regionCount?.toMap()
                }
                if self.regionServerCount != nil {
                    map["RegionServerCount"] = self.regionServerCount?.toMap()
                }
                if self.storeFileCount != nil {
                    map["StoreFileCount"] = self.storeFileCount?.toMap()
                }
                if self.tableCount != nil {
                    map["TableCount"] = self.tableCount?.toMap()
                }
                if self.totalDataSize != nil {
                    map["TotalDataSize"] = self.totalDataSize?.toMap()
                }
                if self.totalReadRequest != nil {
                    map["TotalReadRequest"] = self.totalReadRequest?.toMap()
                }
                if self.totalRequest != nil {
                    map["TotalRequest"] = self.totalRequest?.toMap()
                }
                if self.totalWriteRequest != nil {
                    map["TotalWriteRequest"] = self.totalWriteRequest?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AvgLoad") {
                    var model = GetDoctorHBaseClusterResponseBody.Data.Metrics.AvgLoad()
                    model.fromMap(dict["AvgLoad"] as! [String: Any])
                    self.avgLoad = model
                }
                if dict.keys.contains("DailyReadRequest") {
                    var model = GetDoctorHBaseClusterResponseBody.Data.Metrics.DailyReadRequest()
                    model.fromMap(dict["DailyReadRequest"] as! [String: Any])
                    self.dailyReadRequest = model
                }
                if dict.keys.contains("DailyWriteRequest") {
                    var model = GetDoctorHBaseClusterResponseBody.Data.Metrics.DailyWriteRequest()
                    model.fromMap(dict["DailyWriteRequest"] as! [String: Any])
                    self.dailyWriteRequest = model
                }
                if dict.keys.contains("MemHeap") {
                    var model = GetDoctorHBaseClusterResponseBody.Data.Metrics.MemHeap()
                    model.fromMap(dict["MemHeap"] as! [String: Any])
                    self.memHeap = model
                }
                if dict.keys.contains("NormalAvgLoad") {
                    var model = GetDoctorHBaseClusterResponseBody.Data.Metrics.NormalAvgLoad()
                    model.fromMap(dict["NormalAvgLoad"] as! [String: Any])
                    self.normalAvgLoad = model
                }
                if dict.keys.contains("RegionBalance") {
                    var model = GetDoctorHBaseClusterResponseBody.Data.Metrics.RegionBalance()
                    model.fromMap(dict["RegionBalance"] as! [String: Any])
                    self.regionBalance = model
                }
                if dict.keys.contains("RegionCount") {
                    var model = GetDoctorHBaseClusterResponseBody.Data.Metrics.RegionCount()
                    model.fromMap(dict["RegionCount"] as! [String: Any])
                    self.regionCount = model
                }
                if dict.keys.contains("RegionServerCount") {
                    var model = GetDoctorHBaseClusterResponseBody.Data.Metrics.RegionServerCount()
                    model.fromMap(dict["RegionServerCount"] as! [String: Any])
                    self.regionServerCount = model
                }
                if dict.keys.contains("StoreFileCount") {
                    var model = GetDoctorHBaseClusterResponseBody.Data.Metrics.StoreFileCount()
                    model.fromMap(dict["StoreFileCount"] as! [String: Any])
                    self.storeFileCount = model
                }
                if dict.keys.contains("TableCount") {
                    var model = GetDoctorHBaseClusterResponseBody.Data.Metrics.TableCount()
                    model.fromMap(dict["TableCount"] as! [String: Any])
                    self.tableCount = model
                }
                if dict.keys.contains("TotalDataSize") {
                    var model = GetDoctorHBaseClusterResponseBody.Data.Metrics.TotalDataSize()
                    model.fromMap(dict["TotalDataSize"] as! [String: Any])
                    self.totalDataSize = model
                }
                if dict.keys.contains("TotalReadRequest") {
                    var model = GetDoctorHBaseClusterResponseBody.Data.Metrics.TotalReadRequest()
                    model.fromMap(dict["TotalReadRequest"] as! [String: Any])
                    self.totalReadRequest = model
                }
                if dict.keys.contains("TotalRequest") {
                    var model = GetDoctorHBaseClusterResponseBody.Data.Metrics.TotalRequest()
                    model.fromMap(dict["TotalRequest"] as! [String: Any])
                    self.totalRequest = model
                }
                if dict.keys.contains("TotalWriteRequest") {
                    var model = GetDoctorHBaseClusterResponseBody.Data.Metrics.TotalWriteRequest()
                    model.fromMap(dict["TotalWriteRequest"] as! [String: Any])
                    self.totalWriteRequest = model
                }
            }
        }
        public var analysis: GetDoctorHBaseClusterResponseBody.Data.Analysis?

        public var metrics: GetDoctorHBaseClusterResponseBody.Data.Metrics?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.analysis?.validate()
            try self.metrics?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.analysis != nil {
                map["Analysis"] = self.analysis?.toMap()
            }
            if self.metrics != nil {
                map["Metrics"] = self.metrics?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Analysis") {
                var model = GetDoctorHBaseClusterResponseBody.Data.Analysis()
                model.fromMap(dict["Analysis"] as! [String: Any])
                self.analysis = model
            }
            if dict.keys.contains("Metrics") {
                var model = GetDoctorHBaseClusterResponseBody.Data.Metrics()
                model.fromMap(dict["Metrics"] as! [String: Any])
                self.metrics = model
            }
        }
    }
    public var data: GetDoctorHBaseClusterResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = GetDoctorHBaseClusterResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetDoctorHBaseClusterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDoctorHBaseClusterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDoctorHBaseClusterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDoctorHBaseRegionRequest : Tea.TeaModel {
    public var clusterId: String?

    public var dateTime: String?

    public var hbaseRegionId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.dateTime != nil {
            map["DateTime"] = self.dateTime!
        }
        if self.hbaseRegionId != nil {
            map["HbaseRegionId"] = self.hbaseRegionId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("DateTime") {
            self.dateTime = dict["DateTime"] as! String
        }
        if dict.keys.contains("HbaseRegionId") {
            self.hbaseRegionId = dict["HbaseRegionId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class GetDoctorHBaseRegionResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Metrics : Tea.TeaModel {
            public class DailyReadRequest : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class DailyWriteRequest : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class StoreFileCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class TotalReadRequest : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class TotalWriteRequest : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public var dailyReadRequest: GetDoctorHBaseRegionResponseBody.Data.Metrics.DailyReadRequest?

            public var dailyWriteRequest: GetDoctorHBaseRegionResponseBody.Data.Metrics.DailyWriteRequest?

            public var storeFileCount: GetDoctorHBaseRegionResponseBody.Data.Metrics.StoreFileCount?

            public var totalReadRequest: GetDoctorHBaseRegionResponseBody.Data.Metrics.TotalReadRequest?

            public var totalWriteRequest: GetDoctorHBaseRegionResponseBody.Data.Metrics.TotalWriteRequest?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.dailyReadRequest?.validate()
                try self.dailyWriteRequest?.validate()
                try self.storeFileCount?.validate()
                try self.totalReadRequest?.validate()
                try self.totalWriteRequest?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dailyReadRequest != nil {
                    map["DailyReadRequest"] = self.dailyReadRequest?.toMap()
                }
                if self.dailyWriteRequest != nil {
                    map["DailyWriteRequest"] = self.dailyWriteRequest?.toMap()
                }
                if self.storeFileCount != nil {
                    map["StoreFileCount"] = self.storeFileCount?.toMap()
                }
                if self.totalReadRequest != nil {
                    map["TotalReadRequest"] = self.totalReadRequest?.toMap()
                }
                if self.totalWriteRequest != nil {
                    map["TotalWriteRequest"] = self.totalWriteRequest?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DailyReadRequest") {
                    var model = GetDoctorHBaseRegionResponseBody.Data.Metrics.DailyReadRequest()
                    model.fromMap(dict["DailyReadRequest"] as! [String: Any])
                    self.dailyReadRequest = model
                }
                if dict.keys.contains("DailyWriteRequest") {
                    var model = GetDoctorHBaseRegionResponseBody.Data.Metrics.DailyWriteRequest()
                    model.fromMap(dict["DailyWriteRequest"] as! [String: Any])
                    self.dailyWriteRequest = model
                }
                if dict.keys.contains("StoreFileCount") {
                    var model = GetDoctorHBaseRegionResponseBody.Data.Metrics.StoreFileCount()
                    model.fromMap(dict["StoreFileCount"] as! [String: Any])
                    self.storeFileCount = model
                }
                if dict.keys.contains("TotalReadRequest") {
                    var model = GetDoctorHBaseRegionResponseBody.Data.Metrics.TotalReadRequest()
                    model.fromMap(dict["TotalReadRequest"] as! [String: Any])
                    self.totalReadRequest = model
                }
                if dict.keys.contains("TotalWriteRequest") {
                    var model = GetDoctorHBaseRegionResponseBody.Data.Metrics.TotalWriteRequest()
                    model.fromMap(dict["TotalWriteRequest"] as! [String: Any])
                    self.totalWriteRequest = model
                }
            }
        }
        public var metrics: GetDoctorHBaseRegionResponseBody.Data.Metrics?

        public var regionServerHost: String?

        public var tableName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.metrics?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.metrics != nil {
                map["Metrics"] = self.metrics?.toMap()
            }
            if self.regionServerHost != nil {
                map["RegionServerHost"] = self.regionServerHost!
            }
            if self.tableName != nil {
                map["TableName"] = self.tableName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Metrics") {
                var model = GetDoctorHBaseRegionResponseBody.Data.Metrics()
                model.fromMap(dict["Metrics"] as! [String: Any])
                self.metrics = model
            }
            if dict.keys.contains("RegionServerHost") {
                self.regionServerHost = dict["RegionServerHost"] as! String
            }
            if dict.keys.contains("TableName") {
                self.tableName = dict["TableName"] as! String
            }
        }
    }
    public var data: GetDoctorHBaseRegionResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = GetDoctorHBaseRegionResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetDoctorHBaseRegionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDoctorHBaseRegionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDoctorHBaseRegionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDoctorHBaseRegionServerRequest : Tea.TeaModel {
    public var clusterId: String?

    public var dateTime: String?

    public var regionId: String?

    public var regionServerHost: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.dateTime != nil {
            map["DateTime"] = self.dateTime!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.regionServerHost != nil {
            map["RegionServerHost"] = self.regionServerHost!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("DateTime") {
            self.dateTime = dict["DateTime"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RegionServerHost") {
            self.regionServerHost = dict["RegionServerHost"] as! String
        }
    }
}

public class GetDoctorHBaseRegionServerResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Metrics : Tea.TeaModel {
            public class AvgGc : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class CacheRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class DailyReadRequest : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class DailyReadRequestDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class DailyWriteRequest : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class DailyWriteRequestDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class RegionCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class TotalReadRequest : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class TotalRequest : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class TotalWriteRequest : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public var avgGc: GetDoctorHBaseRegionServerResponseBody.Data.Metrics.AvgGc?

            public var cacheRatio: GetDoctorHBaseRegionServerResponseBody.Data.Metrics.CacheRatio?

            public var dailyReadRequest: GetDoctorHBaseRegionServerResponseBody.Data.Metrics.DailyReadRequest?

            public var dailyReadRequestDayGrowthRatio: GetDoctorHBaseRegionServerResponseBody.Data.Metrics.DailyReadRequestDayGrowthRatio?

            public var dailyWriteRequest: GetDoctorHBaseRegionServerResponseBody.Data.Metrics.DailyWriteRequest?

            public var dailyWriteRequestDayGrowthRatio: GetDoctorHBaseRegionServerResponseBody.Data.Metrics.DailyWriteRequestDayGrowthRatio?

            public var regionCount: GetDoctorHBaseRegionServerResponseBody.Data.Metrics.RegionCount?

            public var totalReadRequest: GetDoctorHBaseRegionServerResponseBody.Data.Metrics.TotalReadRequest?

            public var totalRequest: GetDoctorHBaseRegionServerResponseBody.Data.Metrics.TotalRequest?

            public var totalWriteRequest: GetDoctorHBaseRegionServerResponseBody.Data.Metrics.TotalWriteRequest?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.avgGc?.validate()
                try self.cacheRatio?.validate()
                try self.dailyReadRequest?.validate()
                try self.dailyReadRequestDayGrowthRatio?.validate()
                try self.dailyWriteRequest?.validate()
                try self.dailyWriteRequestDayGrowthRatio?.validate()
                try self.regionCount?.validate()
                try self.totalReadRequest?.validate()
                try self.totalRequest?.validate()
                try self.totalWriteRequest?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.avgGc != nil {
                    map["AvgGc"] = self.avgGc?.toMap()
                }
                if self.cacheRatio != nil {
                    map["CacheRatio"] = self.cacheRatio?.toMap()
                }
                if self.dailyReadRequest != nil {
                    map["DailyReadRequest"] = self.dailyReadRequest?.toMap()
                }
                if self.dailyReadRequestDayGrowthRatio != nil {
                    map["DailyReadRequestDayGrowthRatio"] = self.dailyReadRequestDayGrowthRatio?.toMap()
                }
                if self.dailyWriteRequest != nil {
                    map["DailyWriteRequest"] = self.dailyWriteRequest?.toMap()
                }
                if self.dailyWriteRequestDayGrowthRatio != nil {
                    map["DailyWriteRequestDayGrowthRatio"] = self.dailyWriteRequestDayGrowthRatio?.toMap()
                }
                if self.regionCount != nil {
                    map["RegionCount"] = self.regionCount?.toMap()
                }
                if self.totalReadRequest != nil {
                    map["TotalReadRequest"] = self.totalReadRequest?.toMap()
                }
                if self.totalRequest != nil {
                    map["TotalRequest"] = self.totalRequest?.toMap()
                }
                if self.totalWriteRequest != nil {
                    map["TotalWriteRequest"] = self.totalWriteRequest?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AvgGc") {
                    var model = GetDoctorHBaseRegionServerResponseBody.Data.Metrics.AvgGc()
                    model.fromMap(dict["AvgGc"] as! [String: Any])
                    self.avgGc = model
                }
                if dict.keys.contains("CacheRatio") {
                    var model = GetDoctorHBaseRegionServerResponseBody.Data.Metrics.CacheRatio()
                    model.fromMap(dict["CacheRatio"] as! [String: Any])
                    self.cacheRatio = model
                }
                if dict.keys.contains("DailyReadRequest") {
                    var model = GetDoctorHBaseRegionServerResponseBody.Data.Metrics.DailyReadRequest()
                    model.fromMap(dict["DailyReadRequest"] as! [String: Any])
                    self.dailyReadRequest = model
                }
                if dict.keys.contains("DailyReadRequestDayGrowthRatio") {
                    var model = GetDoctorHBaseRegionServerResponseBody.Data.Metrics.DailyReadRequestDayGrowthRatio()
                    model.fromMap(dict["DailyReadRequestDayGrowthRatio"] as! [String: Any])
                    self.dailyReadRequestDayGrowthRatio = model
                }
                if dict.keys.contains("DailyWriteRequest") {
                    var model = GetDoctorHBaseRegionServerResponseBody.Data.Metrics.DailyWriteRequest()
                    model.fromMap(dict["DailyWriteRequest"] as! [String: Any])
                    self.dailyWriteRequest = model
                }
                if dict.keys.contains("DailyWriteRequestDayGrowthRatio") {
                    var model = GetDoctorHBaseRegionServerResponseBody.Data.Metrics.DailyWriteRequestDayGrowthRatio()
                    model.fromMap(dict["DailyWriteRequestDayGrowthRatio"] as! [String: Any])
                    self.dailyWriteRequestDayGrowthRatio = model
                }
                if dict.keys.contains("RegionCount") {
                    var model = GetDoctorHBaseRegionServerResponseBody.Data.Metrics.RegionCount()
                    model.fromMap(dict["RegionCount"] as! [String: Any])
                    self.regionCount = model
                }
                if dict.keys.contains("TotalReadRequest") {
                    var model = GetDoctorHBaseRegionServerResponseBody.Data.Metrics.TotalReadRequest()
                    model.fromMap(dict["TotalReadRequest"] as! [String: Any])
                    self.totalReadRequest = model
                }
                if dict.keys.contains("TotalRequest") {
                    var model = GetDoctorHBaseRegionServerResponseBody.Data.Metrics.TotalRequest()
                    model.fromMap(dict["TotalRequest"] as! [String: Any])
                    self.totalRequest = model
                }
                if dict.keys.contains("TotalWriteRequest") {
                    var model = GetDoctorHBaseRegionServerResponseBody.Data.Metrics.TotalWriteRequest()
                    model.fromMap(dict["TotalWriteRequest"] as! [String: Any])
                    self.totalWriteRequest = model
                }
            }
        }
        public var metrics: GetDoctorHBaseRegionServerResponseBody.Data.Metrics?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.metrics?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.metrics != nil {
                map["Metrics"] = self.metrics?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Metrics") {
                var model = GetDoctorHBaseRegionServerResponseBody.Data.Metrics()
                model.fromMap(dict["Metrics"] as! [String: Any])
                self.metrics = model
            }
        }
    }
    public var data: GetDoctorHBaseRegionServerResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = GetDoctorHBaseRegionServerResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetDoctorHBaseRegionServerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDoctorHBaseRegionServerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDoctorHBaseRegionServerResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDoctorHBaseTableRequest : Tea.TeaModel {
    public var clusterId: String?

    public var dateTime: String?

    public var regionId: String?

    public var tableName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.dateTime != nil {
            map["DateTime"] = self.dateTime!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("DateTime") {
            self.dateTime = dict["DateTime"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("TableName") {
            self.tableName = dict["TableName"] as! String
        }
    }
}

public class GetDoctorHBaseTableResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Analysis : Tea.TeaModel {
            public var readRequestHotspotRegionList: [String]?

            public var readRequestUnbalanceSuggestion: String?

            public var requestHotspotRegionList: [String]?

            public var requestUnbalanceSuggestion: String?

            public var tableScore: Int32?

            public var writeRequestHotspotRegionList: [String]?

            public var writeRequestUnbalanceSuggestion: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.readRequestHotspotRegionList != nil {
                    map["ReadRequestHotspotRegionList"] = self.readRequestHotspotRegionList!
                }
                if self.readRequestUnbalanceSuggestion != nil {
                    map["ReadRequestUnbalanceSuggestion"] = self.readRequestUnbalanceSuggestion!
                }
                if self.requestHotspotRegionList != nil {
                    map["RequestHotspotRegionList"] = self.requestHotspotRegionList!
                }
                if self.requestUnbalanceSuggestion != nil {
                    map["RequestUnbalanceSuggestion"] = self.requestUnbalanceSuggestion!
                }
                if self.tableScore != nil {
                    map["TableScore"] = self.tableScore!
                }
                if self.writeRequestHotspotRegionList != nil {
                    map["WriteRequestHotspotRegionList"] = self.writeRequestHotspotRegionList!
                }
                if self.writeRequestUnbalanceSuggestion != nil {
                    map["WriteRequestUnbalanceSuggestion"] = self.writeRequestUnbalanceSuggestion!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ReadRequestHotspotRegionList") {
                    self.readRequestHotspotRegionList = dict["ReadRequestHotspotRegionList"] as! [String]
                }
                if dict.keys.contains("ReadRequestUnbalanceSuggestion") {
                    self.readRequestUnbalanceSuggestion = dict["ReadRequestUnbalanceSuggestion"] as! String
                }
                if dict.keys.contains("RequestHotspotRegionList") {
                    self.requestHotspotRegionList = dict["RequestHotspotRegionList"] as! [String]
                }
                if dict.keys.contains("RequestUnbalanceSuggestion") {
                    self.requestUnbalanceSuggestion = dict["RequestUnbalanceSuggestion"] as! String
                }
                if dict.keys.contains("TableScore") {
                    self.tableScore = dict["TableScore"] as! Int32
                }
                if dict.keys.contains("WriteRequestHotspotRegionList") {
                    self.writeRequestHotspotRegionList = dict["WriteRequestHotspotRegionList"] as! [String]
                }
                if dict.keys.contains("WriteRequestUnbalanceSuggestion") {
                    self.writeRequestUnbalanceSuggestion = dict["WriteRequestUnbalanceSuggestion"] as! String
                }
            }
        }
        public class Metrics : Tea.TeaModel {
            public class ColdAccessDay : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class ColdConfigDay : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class ColdDataSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class DailyReadRequest : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class DailyReadRequestDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class DailyWriteRequest : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class DailyWriteRequestDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class FreezeConfigDay : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class FreezeDataSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class HotDataSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class Locality : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class ReadRequestBalance : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class RegionBalance : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class RegionCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class RegionCountDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class RegionServerCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class RequestBalance : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class StoreFileCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class StoreFileCountDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class TableSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class TableSizeDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class WarmConfigDay : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class WarmDataSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class WriteRequestBalance : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public var coldAccessDay: GetDoctorHBaseTableResponseBody.Data.Metrics.ColdAccessDay?

            public var coldConfigDay: GetDoctorHBaseTableResponseBody.Data.Metrics.ColdConfigDay?

            public var coldDataSize: GetDoctorHBaseTableResponseBody.Data.Metrics.ColdDataSize?

            public var dailyReadRequest: GetDoctorHBaseTableResponseBody.Data.Metrics.DailyReadRequest?

            public var dailyReadRequestDayGrowthRatio: GetDoctorHBaseTableResponseBody.Data.Metrics.DailyReadRequestDayGrowthRatio?

            public var dailyWriteRequest: GetDoctorHBaseTableResponseBody.Data.Metrics.DailyWriteRequest?

            public var dailyWriteRequestDayGrowthRatio: GetDoctorHBaseTableResponseBody.Data.Metrics.DailyWriteRequestDayGrowthRatio?

            public var freezeConfigDay: GetDoctorHBaseTableResponseBody.Data.Metrics.FreezeConfigDay?

            public var freezeDataSize: GetDoctorHBaseTableResponseBody.Data.Metrics.FreezeDataSize?

            public var hotDataSize: GetDoctorHBaseTableResponseBody.Data.Metrics.HotDataSize?

            public var locality: GetDoctorHBaseTableResponseBody.Data.Metrics.Locality?

            public var readRequestBalance: GetDoctorHBaseTableResponseBody.Data.Metrics.ReadRequestBalance?

            public var regionBalance: GetDoctorHBaseTableResponseBody.Data.Metrics.RegionBalance?

            public var regionCount: GetDoctorHBaseTableResponseBody.Data.Metrics.RegionCount?

            public var regionCountDayGrowthRatio: GetDoctorHBaseTableResponseBody.Data.Metrics.RegionCountDayGrowthRatio?

            public var regionServerCount: GetDoctorHBaseTableResponseBody.Data.Metrics.RegionServerCount?

            public var requestBalance: GetDoctorHBaseTableResponseBody.Data.Metrics.RequestBalance?

            public var storeFileCount: GetDoctorHBaseTableResponseBody.Data.Metrics.StoreFileCount?

            public var storeFileCountDayGrowthRatio: GetDoctorHBaseTableResponseBody.Data.Metrics.StoreFileCountDayGrowthRatio?

            public var tableSize: GetDoctorHBaseTableResponseBody.Data.Metrics.TableSize?

            public var tableSizeDayGrowthRatio: GetDoctorHBaseTableResponseBody.Data.Metrics.TableSizeDayGrowthRatio?

            public var warmConfigDay: GetDoctorHBaseTableResponseBody.Data.Metrics.WarmConfigDay?

            public var warmDataSize: GetDoctorHBaseTableResponseBody.Data.Metrics.WarmDataSize?

            public var writeRequestBalance: GetDoctorHBaseTableResponseBody.Data.Metrics.WriteRequestBalance?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.coldAccessDay?.validate()
                try self.coldConfigDay?.validate()
                try self.coldDataSize?.validate()
                try self.dailyReadRequest?.validate()
                try self.dailyReadRequestDayGrowthRatio?.validate()
                try self.dailyWriteRequest?.validate()
                try self.dailyWriteRequestDayGrowthRatio?.validate()
                try self.freezeConfigDay?.validate()
                try self.freezeDataSize?.validate()
                try self.hotDataSize?.validate()
                try self.locality?.validate()
                try self.readRequestBalance?.validate()
                try self.regionBalance?.validate()
                try self.regionCount?.validate()
                try self.regionCountDayGrowthRatio?.validate()
                try self.regionServerCount?.validate()
                try self.requestBalance?.validate()
                try self.storeFileCount?.validate()
                try self.storeFileCountDayGrowthRatio?.validate()
                try self.tableSize?.validate()
                try self.tableSizeDayGrowthRatio?.validate()
                try self.warmConfigDay?.validate()
                try self.warmDataSize?.validate()
                try self.writeRequestBalance?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.coldAccessDay != nil {
                    map["ColdAccessDay"] = self.coldAccessDay?.toMap()
                }
                if self.coldConfigDay != nil {
                    map["ColdConfigDay"] = self.coldConfigDay?.toMap()
                }
                if self.coldDataSize != nil {
                    map["ColdDataSize"] = self.coldDataSize?.toMap()
                }
                if self.dailyReadRequest != nil {
                    map["DailyReadRequest"] = self.dailyReadRequest?.toMap()
                }
                if self.dailyReadRequestDayGrowthRatio != nil {
                    map["DailyReadRequestDayGrowthRatio"] = self.dailyReadRequestDayGrowthRatio?.toMap()
                }
                if self.dailyWriteRequest != nil {
                    map["DailyWriteRequest"] = self.dailyWriteRequest?.toMap()
                }
                if self.dailyWriteRequestDayGrowthRatio != nil {
                    map["DailyWriteRequestDayGrowthRatio"] = self.dailyWriteRequestDayGrowthRatio?.toMap()
                }
                if self.freezeConfigDay != nil {
                    map["FreezeConfigDay"] = self.freezeConfigDay?.toMap()
                }
                if self.freezeDataSize != nil {
                    map["FreezeDataSize"] = self.freezeDataSize?.toMap()
                }
                if self.hotDataSize != nil {
                    map["HotDataSize"] = self.hotDataSize?.toMap()
                }
                if self.locality != nil {
                    map["Locality"] = self.locality?.toMap()
                }
                if self.readRequestBalance != nil {
                    map["ReadRequestBalance"] = self.readRequestBalance?.toMap()
                }
                if self.regionBalance != nil {
                    map["RegionBalance"] = self.regionBalance?.toMap()
                }
                if self.regionCount != nil {
                    map["RegionCount"] = self.regionCount?.toMap()
                }
                if self.regionCountDayGrowthRatio != nil {
                    map["RegionCountDayGrowthRatio"] = self.regionCountDayGrowthRatio?.toMap()
                }
                if self.regionServerCount != nil {
                    map["RegionServerCount"] = self.regionServerCount?.toMap()
                }
                if self.requestBalance != nil {
                    map["RequestBalance"] = self.requestBalance?.toMap()
                }
                if self.storeFileCount != nil {
                    map["StoreFileCount"] = self.storeFileCount?.toMap()
                }
                if self.storeFileCountDayGrowthRatio != nil {
                    map["StoreFileCountDayGrowthRatio"] = self.storeFileCountDayGrowthRatio?.toMap()
                }
                if self.tableSize != nil {
                    map["TableSize"] = self.tableSize?.toMap()
                }
                if self.tableSizeDayGrowthRatio != nil {
                    map["TableSizeDayGrowthRatio"] = self.tableSizeDayGrowthRatio?.toMap()
                }
                if self.warmConfigDay != nil {
                    map["WarmConfigDay"] = self.warmConfigDay?.toMap()
                }
                if self.warmDataSize != nil {
                    map["WarmDataSize"] = self.warmDataSize?.toMap()
                }
                if self.writeRequestBalance != nil {
                    map["WriteRequestBalance"] = self.writeRequestBalance?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ColdAccessDay") {
                    var model = GetDoctorHBaseTableResponseBody.Data.Metrics.ColdAccessDay()
                    model.fromMap(dict["ColdAccessDay"] as! [String: Any])
                    self.coldAccessDay = model
                }
                if dict.keys.contains("ColdConfigDay") {
                    var model = GetDoctorHBaseTableResponseBody.Data.Metrics.ColdConfigDay()
                    model.fromMap(dict["ColdConfigDay"] as! [String: Any])
                    self.coldConfigDay = model
                }
                if dict.keys.contains("ColdDataSize") {
                    var model = GetDoctorHBaseTableResponseBody.Data.Metrics.ColdDataSize()
                    model.fromMap(dict["ColdDataSize"] as! [String: Any])
                    self.coldDataSize = model
                }
                if dict.keys.contains("DailyReadRequest") {
                    var model = GetDoctorHBaseTableResponseBody.Data.Metrics.DailyReadRequest()
                    model.fromMap(dict["DailyReadRequest"] as! [String: Any])
                    self.dailyReadRequest = model
                }
                if dict.keys.contains("DailyReadRequestDayGrowthRatio") {
                    var model = GetDoctorHBaseTableResponseBody.Data.Metrics.DailyReadRequestDayGrowthRatio()
                    model.fromMap(dict["DailyReadRequestDayGrowthRatio"] as! [String: Any])
                    self.dailyReadRequestDayGrowthRatio = model
                }
                if dict.keys.contains("DailyWriteRequest") {
                    var model = GetDoctorHBaseTableResponseBody.Data.Metrics.DailyWriteRequest()
                    model.fromMap(dict["DailyWriteRequest"] as! [String: Any])
                    self.dailyWriteRequest = model
                }
                if dict.keys.contains("DailyWriteRequestDayGrowthRatio") {
                    var model = GetDoctorHBaseTableResponseBody.Data.Metrics.DailyWriteRequestDayGrowthRatio()
                    model.fromMap(dict["DailyWriteRequestDayGrowthRatio"] as! [String: Any])
                    self.dailyWriteRequestDayGrowthRatio = model
                }
                if dict.keys.contains("FreezeConfigDay") {
                    var model = GetDoctorHBaseTableResponseBody.Data.Metrics.FreezeConfigDay()
                    model.fromMap(dict["FreezeConfigDay"] as! [String: Any])
                    self.freezeConfigDay = model
                }
                if dict.keys.contains("FreezeDataSize") {
                    var model = GetDoctorHBaseTableResponseBody.Data.Metrics.FreezeDataSize()
                    model.fromMap(dict["FreezeDataSize"] as! [String: Any])
                    self.freezeDataSize = model
                }
                if dict.keys.contains("HotDataSize") {
                    var model = GetDoctorHBaseTableResponseBody.Data.Metrics.HotDataSize()
                    model.fromMap(dict["HotDataSize"] as! [String: Any])
                    self.hotDataSize = model
                }
                if dict.keys.contains("Locality") {
                    var model = GetDoctorHBaseTableResponseBody.Data.Metrics.Locality()
                    model.fromMap(dict["Locality"] as! [String: Any])
                    self.locality = model
                }
                if dict.keys.contains("ReadRequestBalance") {
                    var model = GetDoctorHBaseTableResponseBody.Data.Metrics.ReadRequestBalance()
                    model.fromMap(dict["ReadRequestBalance"] as! [String: Any])
                    self.readRequestBalance = model
                }
                if dict.keys.contains("RegionBalance") {
                    var model = GetDoctorHBaseTableResponseBody.Data.Metrics.RegionBalance()
                    model.fromMap(dict["RegionBalance"] as! [String: Any])
                    self.regionBalance = model
                }
                if dict.keys.contains("RegionCount") {
                    var model = GetDoctorHBaseTableResponseBody.Data.Metrics.RegionCount()
                    model.fromMap(dict["RegionCount"] as! [String: Any])
                    self.regionCount = model
                }
                if dict.keys.contains("RegionCountDayGrowthRatio") {
                    var model = GetDoctorHBaseTableResponseBody.Data.Metrics.RegionCountDayGrowthRatio()
                    model.fromMap(dict["RegionCountDayGrowthRatio"] as! [String: Any])
                    self.regionCountDayGrowthRatio = model
                }
                if dict.keys.contains("RegionServerCount") {
                    var model = GetDoctorHBaseTableResponseBody.Data.Metrics.RegionServerCount()
                    model.fromMap(dict["RegionServerCount"] as! [String: Any])
                    self.regionServerCount = model
                }
                if dict.keys.contains("RequestBalance") {
                    var model = GetDoctorHBaseTableResponseBody.Data.Metrics.RequestBalance()
                    model.fromMap(dict["RequestBalance"] as! [String: Any])
                    self.requestBalance = model
                }
                if dict.keys.contains("StoreFileCount") {
                    var model = GetDoctorHBaseTableResponseBody.Data.Metrics.StoreFileCount()
                    model.fromMap(dict["StoreFileCount"] as! [String: Any])
                    self.storeFileCount = model
                }
                if dict.keys.contains("StoreFileCountDayGrowthRatio") {
                    var model = GetDoctorHBaseTableResponseBody.Data.Metrics.StoreFileCountDayGrowthRatio()
                    model.fromMap(dict["StoreFileCountDayGrowthRatio"] as! [String: Any])
                    self.storeFileCountDayGrowthRatio = model
                }
                if dict.keys.contains("TableSize") {
                    var model = GetDoctorHBaseTableResponseBody.Data.Metrics.TableSize()
                    model.fromMap(dict["TableSize"] as! [String: Any])
                    self.tableSize = model
                }
                if dict.keys.contains("TableSizeDayGrowthRatio") {
                    var model = GetDoctorHBaseTableResponseBody.Data.Metrics.TableSizeDayGrowthRatio()
                    model.fromMap(dict["TableSizeDayGrowthRatio"] as! [String: Any])
                    self.tableSizeDayGrowthRatio = model
                }
                if dict.keys.contains("WarmConfigDay") {
                    var model = GetDoctorHBaseTableResponseBody.Data.Metrics.WarmConfigDay()
                    model.fromMap(dict["WarmConfigDay"] as! [String: Any])
                    self.warmConfigDay = model
                }
                if dict.keys.contains("WarmDataSize") {
                    var model = GetDoctorHBaseTableResponseBody.Data.Metrics.WarmDataSize()
                    model.fromMap(dict["WarmDataSize"] as! [String: Any])
                    self.warmDataSize = model
                }
                if dict.keys.contains("WriteRequestBalance") {
                    var model = GetDoctorHBaseTableResponseBody.Data.Metrics.WriteRequestBalance()
                    model.fromMap(dict["WriteRequestBalance"] as! [String: Any])
                    self.writeRequestBalance = model
                }
            }
        }
        public var analysis: GetDoctorHBaseTableResponseBody.Data.Analysis?

        public var metrics: GetDoctorHBaseTableResponseBody.Data.Metrics?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.analysis?.validate()
            try self.metrics?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.analysis != nil {
                map["Analysis"] = self.analysis?.toMap()
            }
            if self.metrics != nil {
                map["Metrics"] = self.metrics?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Analysis") {
                var model = GetDoctorHBaseTableResponseBody.Data.Analysis()
                model.fromMap(dict["Analysis"] as! [String: Any])
                self.analysis = model
            }
            if dict.keys.contains("Metrics") {
                var model = GetDoctorHBaseTableResponseBody.Data.Metrics()
                model.fromMap(dict["Metrics"] as! [String: Any])
                self.metrics = model
            }
        }
    }
    public var data: GetDoctorHBaseTableResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = GetDoctorHBaseTableResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetDoctorHBaseTableResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDoctorHBaseTableResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDoctorHBaseTableResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDoctorHDFSClusterRequest : Tea.TeaModel {
    public var clusterId: String?

    public var dateTime: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.dateTime != nil {
            map["DateTime"] = self.dateTime!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("DateTime") {
            self.dateTime = dict["DateTime"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class GetDoctorHDFSClusterResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Analysis : Tea.TeaModel {
            public var hdfsScore: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.hdfsScore != nil {
                    map["HdfsScore"] = self.hdfsScore!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("HdfsScore") {
                    self.hdfsScore = dict["HdfsScore"] as! Int32
                }
            }
        }
        public class Metrics : Tea.TeaModel {
            public class ColdDataDayGrowthSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class ColdDataRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class ColdDataSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class ColdDataSizeDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class EmptyFileCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class EmptyFileCountDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class EmptyFileDayGrowthCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class EmptyFileRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class FreezeDataDayGrowthSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class FreezeDataRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class FreezeDataSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class FreezeDataSizeDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class HotDataDayGrowthSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class HotDataRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class HotDataSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class HotDataSizeDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class LargeFileCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class LargeFileCountDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class LargeFileDayGrowthCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class LargeFileRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class MediumFileCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class MediumFileCountDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class MediumFileDayGrowthCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class MediumFileRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class SmallFileCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class SmallFileCountDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class SmallFileDayGrowthCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class SmallFileRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class TinyFileCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class TinyFileCountDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class TinyFileDayGrowthCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class TinyFileRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class TotalDataDayGrowthSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class TotalDataSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class TotalDataSizeDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class TotalFileCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class TotalFileCountDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class TotalFileDayGrowthCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class WarmDataDayGrowthSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class WarmDataRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class WarmDataSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class WarmDataSizeDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public var coldDataDayGrowthSize: GetDoctorHDFSClusterResponseBody.Data.Metrics.ColdDataDayGrowthSize?

            public var coldDataRatio: GetDoctorHDFSClusterResponseBody.Data.Metrics.ColdDataRatio?

            public var coldDataSize: GetDoctorHDFSClusterResponseBody.Data.Metrics.ColdDataSize?

            public var coldDataSizeDayGrowthRatio: GetDoctorHDFSClusterResponseBody.Data.Metrics.ColdDataSizeDayGrowthRatio?

            public var emptyFileCount: GetDoctorHDFSClusterResponseBody.Data.Metrics.EmptyFileCount?

            public var emptyFileCountDayGrowthRatio: GetDoctorHDFSClusterResponseBody.Data.Metrics.EmptyFileCountDayGrowthRatio?

            public var emptyFileDayGrowthCount: GetDoctorHDFSClusterResponseBody.Data.Metrics.EmptyFileDayGrowthCount?

            public var emptyFileRatio: GetDoctorHDFSClusterResponseBody.Data.Metrics.EmptyFileRatio?

            public var freezeDataDayGrowthSize: GetDoctorHDFSClusterResponseBody.Data.Metrics.FreezeDataDayGrowthSize?

            public var freezeDataRatio: GetDoctorHDFSClusterResponseBody.Data.Metrics.FreezeDataRatio?

            public var freezeDataSize: GetDoctorHDFSClusterResponseBody.Data.Metrics.FreezeDataSize?

            public var freezeDataSizeDayGrowthRatio: GetDoctorHDFSClusterResponseBody.Data.Metrics.FreezeDataSizeDayGrowthRatio?

            public var hotDataDayGrowthSize: GetDoctorHDFSClusterResponseBody.Data.Metrics.HotDataDayGrowthSize?

            public var hotDataRatio: GetDoctorHDFSClusterResponseBody.Data.Metrics.HotDataRatio?

            public var hotDataSize: GetDoctorHDFSClusterResponseBody.Data.Metrics.HotDataSize?

            public var hotDataSizeDayGrowthRatio: GetDoctorHDFSClusterResponseBody.Data.Metrics.HotDataSizeDayGrowthRatio?

            public var largeFileCount: GetDoctorHDFSClusterResponseBody.Data.Metrics.LargeFileCount?

            public var largeFileCountDayGrowthRatio: GetDoctorHDFSClusterResponseBody.Data.Metrics.LargeFileCountDayGrowthRatio?

            public var largeFileDayGrowthCount: GetDoctorHDFSClusterResponseBody.Data.Metrics.LargeFileDayGrowthCount?

            public var largeFileRatio: GetDoctorHDFSClusterResponseBody.Data.Metrics.LargeFileRatio?

            public var mediumFileCount: GetDoctorHDFSClusterResponseBody.Data.Metrics.MediumFileCount?

            public var mediumFileCountDayGrowthRatio: GetDoctorHDFSClusterResponseBody.Data.Metrics.MediumFileCountDayGrowthRatio?

            public var mediumFileDayGrowthCount: GetDoctorHDFSClusterResponseBody.Data.Metrics.MediumFileDayGrowthCount?

            public var mediumFileRatio: GetDoctorHDFSClusterResponseBody.Data.Metrics.MediumFileRatio?

            public var smallFileCount: GetDoctorHDFSClusterResponseBody.Data.Metrics.SmallFileCount?

            public var smallFileCountDayGrowthRatio: GetDoctorHDFSClusterResponseBody.Data.Metrics.SmallFileCountDayGrowthRatio?

            public var smallFileDayGrowthCount: GetDoctorHDFSClusterResponseBody.Data.Metrics.SmallFileDayGrowthCount?

            public var smallFileRatio: GetDoctorHDFSClusterResponseBody.Data.Metrics.SmallFileRatio?

            public var tinyFileCount: GetDoctorHDFSClusterResponseBody.Data.Metrics.TinyFileCount?

            public var tinyFileCountDayGrowthRatio: GetDoctorHDFSClusterResponseBody.Data.Metrics.TinyFileCountDayGrowthRatio?

            public var tinyFileDayGrowthCount: GetDoctorHDFSClusterResponseBody.Data.Metrics.TinyFileDayGrowthCount?

            public var tinyFileRatio: GetDoctorHDFSClusterResponseBody.Data.Metrics.TinyFileRatio?

            public var totalDataDayGrowthSize: GetDoctorHDFSClusterResponseBody.Data.Metrics.TotalDataDayGrowthSize?

            public var totalDataSize: GetDoctorHDFSClusterResponseBody.Data.Metrics.TotalDataSize?

            public var totalDataSizeDayGrowthRatio: GetDoctorHDFSClusterResponseBody.Data.Metrics.TotalDataSizeDayGrowthRatio?

            public var totalFileCount: GetDoctorHDFSClusterResponseBody.Data.Metrics.TotalFileCount?

            public var totalFileCountDayGrowthRatio: GetDoctorHDFSClusterResponseBody.Data.Metrics.TotalFileCountDayGrowthRatio?

            public var totalFileDayGrowthCount: GetDoctorHDFSClusterResponseBody.Data.Metrics.TotalFileDayGrowthCount?

            public var warmDataDayGrowthSize: GetDoctorHDFSClusterResponseBody.Data.Metrics.WarmDataDayGrowthSize?

            public var warmDataRatio: GetDoctorHDFSClusterResponseBody.Data.Metrics.WarmDataRatio?

            public var warmDataSize: GetDoctorHDFSClusterResponseBody.Data.Metrics.WarmDataSize?

            public var warmDataSizeDayGrowthRatio: GetDoctorHDFSClusterResponseBody.Data.Metrics.WarmDataSizeDayGrowthRatio?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.coldDataDayGrowthSize?.validate()
                try self.coldDataRatio?.validate()
                try self.coldDataSize?.validate()
                try self.coldDataSizeDayGrowthRatio?.validate()
                try self.emptyFileCount?.validate()
                try self.emptyFileCountDayGrowthRatio?.validate()
                try self.emptyFileDayGrowthCount?.validate()
                try self.emptyFileRatio?.validate()
                try self.freezeDataDayGrowthSize?.validate()
                try self.freezeDataRatio?.validate()
                try self.freezeDataSize?.validate()
                try self.freezeDataSizeDayGrowthRatio?.validate()
                try self.hotDataDayGrowthSize?.validate()
                try self.hotDataRatio?.validate()
                try self.hotDataSize?.validate()
                try self.hotDataSizeDayGrowthRatio?.validate()
                try self.largeFileCount?.validate()
                try self.largeFileCountDayGrowthRatio?.validate()
                try self.largeFileDayGrowthCount?.validate()
                try self.largeFileRatio?.validate()
                try self.mediumFileCount?.validate()
                try self.mediumFileCountDayGrowthRatio?.validate()
                try self.mediumFileDayGrowthCount?.validate()
                try self.mediumFileRatio?.validate()
                try self.smallFileCount?.validate()
                try self.smallFileCountDayGrowthRatio?.validate()
                try self.smallFileDayGrowthCount?.validate()
                try self.smallFileRatio?.validate()
                try self.tinyFileCount?.validate()
                try self.tinyFileCountDayGrowthRatio?.validate()
                try self.tinyFileDayGrowthCount?.validate()
                try self.tinyFileRatio?.validate()
                try self.totalDataDayGrowthSize?.validate()
                try self.totalDataSize?.validate()
                try self.totalDataSizeDayGrowthRatio?.validate()
                try self.totalFileCount?.validate()
                try self.totalFileCountDayGrowthRatio?.validate()
                try self.totalFileDayGrowthCount?.validate()
                try self.warmDataDayGrowthSize?.validate()
                try self.warmDataRatio?.validate()
                try self.warmDataSize?.validate()
                try self.warmDataSizeDayGrowthRatio?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.coldDataDayGrowthSize != nil {
                    map["ColdDataDayGrowthSize"] = self.coldDataDayGrowthSize?.toMap()
                }
                if self.coldDataRatio != nil {
                    map["ColdDataRatio"] = self.coldDataRatio?.toMap()
                }
                if self.coldDataSize != nil {
                    map["ColdDataSize"] = self.coldDataSize?.toMap()
                }
                if self.coldDataSizeDayGrowthRatio != nil {
                    map["ColdDataSizeDayGrowthRatio"] = self.coldDataSizeDayGrowthRatio?.toMap()
                }
                if self.emptyFileCount != nil {
                    map["EmptyFileCount"] = self.emptyFileCount?.toMap()
                }
                if self.emptyFileCountDayGrowthRatio != nil {
                    map["EmptyFileCountDayGrowthRatio"] = self.emptyFileCountDayGrowthRatio?.toMap()
                }
                if self.emptyFileDayGrowthCount != nil {
                    map["EmptyFileDayGrowthCount"] = self.emptyFileDayGrowthCount?.toMap()
                }
                if self.emptyFileRatio != nil {
                    map["EmptyFileRatio"] = self.emptyFileRatio?.toMap()
                }
                if self.freezeDataDayGrowthSize != nil {
                    map["FreezeDataDayGrowthSize"] = self.freezeDataDayGrowthSize?.toMap()
                }
                if self.freezeDataRatio != nil {
                    map["FreezeDataRatio"] = self.freezeDataRatio?.toMap()
                }
                if self.freezeDataSize != nil {
                    map["FreezeDataSize"] = self.freezeDataSize?.toMap()
                }
                if self.freezeDataSizeDayGrowthRatio != nil {
                    map["FreezeDataSizeDayGrowthRatio"] = self.freezeDataSizeDayGrowthRatio?.toMap()
                }
                if self.hotDataDayGrowthSize != nil {
                    map["HotDataDayGrowthSize"] = self.hotDataDayGrowthSize?.toMap()
                }
                if self.hotDataRatio != nil {
                    map["HotDataRatio"] = self.hotDataRatio?.toMap()
                }
                if self.hotDataSize != nil {
                    map["HotDataSize"] = self.hotDataSize?.toMap()
                }
                if self.hotDataSizeDayGrowthRatio != nil {
                    map["HotDataSizeDayGrowthRatio"] = self.hotDataSizeDayGrowthRatio?.toMap()
                }
                if self.largeFileCount != nil {
                    map["LargeFileCount"] = self.largeFileCount?.toMap()
                }
                if self.largeFileCountDayGrowthRatio != nil {
                    map["LargeFileCountDayGrowthRatio"] = self.largeFileCountDayGrowthRatio?.toMap()
                }
                if self.largeFileDayGrowthCount != nil {
                    map["LargeFileDayGrowthCount"] = self.largeFileDayGrowthCount?.toMap()
                }
                if self.largeFileRatio != nil {
                    map["LargeFileRatio"] = self.largeFileRatio?.toMap()
                }
                if self.mediumFileCount != nil {
                    map["MediumFileCount"] = self.mediumFileCount?.toMap()
                }
                if self.mediumFileCountDayGrowthRatio != nil {
                    map["MediumFileCountDayGrowthRatio"] = self.mediumFileCountDayGrowthRatio?.toMap()
                }
                if self.mediumFileDayGrowthCount != nil {
                    map["MediumFileDayGrowthCount"] = self.mediumFileDayGrowthCount?.toMap()
                }
                if self.mediumFileRatio != nil {
                    map["MediumFileRatio"] = self.mediumFileRatio?.toMap()
                }
                if self.smallFileCount != nil {
                    map["SmallFileCount"] = self.smallFileCount?.toMap()
                }
                if self.smallFileCountDayGrowthRatio != nil {
                    map["SmallFileCountDayGrowthRatio"] = self.smallFileCountDayGrowthRatio?.toMap()
                }
                if self.smallFileDayGrowthCount != nil {
                    map["SmallFileDayGrowthCount"] = self.smallFileDayGrowthCount?.toMap()
                }
                if self.smallFileRatio != nil {
                    map["SmallFileRatio"] = self.smallFileRatio?.toMap()
                }
                if self.tinyFileCount != nil {
                    map["TinyFileCount"] = self.tinyFileCount?.toMap()
                }
                if self.tinyFileCountDayGrowthRatio != nil {
                    map["TinyFileCountDayGrowthRatio"] = self.tinyFileCountDayGrowthRatio?.toMap()
                }
                if self.tinyFileDayGrowthCount != nil {
                    map["TinyFileDayGrowthCount"] = self.tinyFileDayGrowthCount?.toMap()
                }
                if self.tinyFileRatio != nil {
                    map["TinyFileRatio"] = self.tinyFileRatio?.toMap()
                }
                if self.totalDataDayGrowthSize != nil {
                    map["TotalDataDayGrowthSize"] = self.totalDataDayGrowthSize?.toMap()
                }
                if self.totalDataSize != nil {
                    map["TotalDataSize"] = self.totalDataSize?.toMap()
                }
                if self.totalDataSizeDayGrowthRatio != nil {
                    map["TotalDataSizeDayGrowthRatio"] = self.totalDataSizeDayGrowthRatio?.toMap()
                }
                if self.totalFileCount != nil {
                    map["TotalFileCount"] = self.totalFileCount?.toMap()
                }
                if self.totalFileCountDayGrowthRatio != nil {
                    map["TotalFileCountDayGrowthRatio"] = self.totalFileCountDayGrowthRatio?.toMap()
                }
                if self.totalFileDayGrowthCount != nil {
                    map["TotalFileDayGrowthCount"] = self.totalFileDayGrowthCount?.toMap()
                }
                if self.warmDataDayGrowthSize != nil {
                    map["WarmDataDayGrowthSize"] = self.warmDataDayGrowthSize?.toMap()
                }
                if self.warmDataRatio != nil {
                    map["WarmDataRatio"] = self.warmDataRatio?.toMap()
                }
                if self.warmDataSize != nil {
                    map["WarmDataSize"] = self.warmDataSize?.toMap()
                }
                if self.warmDataSizeDayGrowthRatio != nil {
                    map["WarmDataSizeDayGrowthRatio"] = self.warmDataSizeDayGrowthRatio?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ColdDataDayGrowthSize") {
                    var model = GetDoctorHDFSClusterResponseBody.Data.Metrics.ColdDataDayGrowthSize()
                    model.fromMap(dict["ColdDataDayGrowthSize"] as! [String: Any])
                    self.coldDataDayGrowthSize = model
                }
                if dict.keys.contains("ColdDataRatio") {
                    var model = GetDoctorHDFSClusterResponseBody.Data.Metrics.ColdDataRatio()
                    model.fromMap(dict["ColdDataRatio"] as! [String: Any])
                    self.coldDataRatio = model
                }
                if dict.keys.contains("ColdDataSize") {
                    var model = GetDoctorHDFSClusterResponseBody.Data.Metrics.ColdDataSize()
                    model.fromMap(dict["ColdDataSize"] as! [String: Any])
                    self.coldDataSize = model
                }
                if dict.keys.contains("ColdDataSizeDayGrowthRatio") {
                    var model = GetDoctorHDFSClusterResponseBody.Data.Metrics.ColdDataSizeDayGrowthRatio()
                    model.fromMap(dict["ColdDataSizeDayGrowthRatio"] as! [String: Any])
                    self.coldDataSizeDayGrowthRatio = model
                }
                if dict.keys.contains("EmptyFileCount") {
                    var model = GetDoctorHDFSClusterResponseBody.Data.Metrics.EmptyFileCount()
                    model.fromMap(dict["EmptyFileCount"] as! [String: Any])
                    self.emptyFileCount = model
                }
                if dict.keys.contains("EmptyFileCountDayGrowthRatio") {
                    var model = GetDoctorHDFSClusterResponseBody.Data.Metrics.EmptyFileCountDayGrowthRatio()
                    model.fromMap(dict["EmptyFileCountDayGrowthRatio"] as! [String: Any])
                    self.emptyFileCountDayGrowthRatio = model
                }
                if dict.keys.contains("EmptyFileDayGrowthCount") {
                    var model = GetDoctorHDFSClusterResponseBody.Data.Metrics.EmptyFileDayGrowthCount()
                    model.fromMap(dict["EmptyFileDayGrowthCount"] as! [String: Any])
                    self.emptyFileDayGrowthCount = model
                }
                if dict.keys.contains("EmptyFileRatio") {
                    var model = GetDoctorHDFSClusterResponseBody.Data.Metrics.EmptyFileRatio()
                    model.fromMap(dict["EmptyFileRatio"] as! [String: Any])
                    self.emptyFileRatio = model
                }
                if dict.keys.contains("FreezeDataDayGrowthSize") {
                    var model = GetDoctorHDFSClusterResponseBody.Data.Metrics.FreezeDataDayGrowthSize()
                    model.fromMap(dict["FreezeDataDayGrowthSize"] as! [String: Any])
                    self.freezeDataDayGrowthSize = model
                }
                if dict.keys.contains("FreezeDataRatio") {
                    var model = GetDoctorHDFSClusterResponseBody.Data.Metrics.FreezeDataRatio()
                    model.fromMap(dict["FreezeDataRatio"] as! [String: Any])
                    self.freezeDataRatio = model
                }
                if dict.keys.contains("FreezeDataSize") {
                    var model = GetDoctorHDFSClusterResponseBody.Data.Metrics.FreezeDataSize()
                    model.fromMap(dict["FreezeDataSize"] as! [String: Any])
                    self.freezeDataSize = model
                }
                if dict.keys.contains("FreezeDataSizeDayGrowthRatio") {
                    var model = GetDoctorHDFSClusterResponseBody.Data.Metrics.FreezeDataSizeDayGrowthRatio()
                    model.fromMap(dict["FreezeDataSizeDayGrowthRatio"] as! [String: Any])
                    self.freezeDataSizeDayGrowthRatio = model
                }
                if dict.keys.contains("HotDataDayGrowthSize") {
                    var model = GetDoctorHDFSClusterResponseBody.Data.Metrics.HotDataDayGrowthSize()
                    model.fromMap(dict["HotDataDayGrowthSize"] as! [String: Any])
                    self.hotDataDayGrowthSize = model
                }
                if dict.keys.contains("HotDataRatio") {
                    var model = GetDoctorHDFSClusterResponseBody.Data.Metrics.HotDataRatio()
                    model.fromMap(dict["HotDataRatio"] as! [String: Any])
                    self.hotDataRatio = model
                }
                if dict.keys.contains("HotDataSize") {
                    var model = GetDoctorHDFSClusterResponseBody.Data.Metrics.HotDataSize()
                    model.fromMap(dict["HotDataSize"] as! [String: Any])
                    self.hotDataSize = model
                }
                if dict.keys.contains("HotDataSizeDayGrowthRatio") {
                    var model = GetDoctorHDFSClusterResponseBody.Data.Metrics.HotDataSizeDayGrowthRatio()
                    model.fromMap(dict["HotDataSizeDayGrowthRatio"] as! [String: Any])
                    self.hotDataSizeDayGrowthRatio = model
                }
                if dict.keys.contains("LargeFileCount") {
                    var model = GetDoctorHDFSClusterResponseBody.Data.Metrics.LargeFileCount()
                    model.fromMap(dict["LargeFileCount"] as! [String: Any])
                    self.largeFileCount = model
                }
                if dict.keys.contains("LargeFileCountDayGrowthRatio") {
                    var model = GetDoctorHDFSClusterResponseBody.Data.Metrics.LargeFileCountDayGrowthRatio()
                    model.fromMap(dict["LargeFileCountDayGrowthRatio"] as! [String: Any])
                    self.largeFileCountDayGrowthRatio = model
                }
                if dict.keys.contains("LargeFileDayGrowthCount") {
                    var model = GetDoctorHDFSClusterResponseBody.Data.Metrics.LargeFileDayGrowthCount()
                    model.fromMap(dict["LargeFileDayGrowthCount"] as! [String: Any])
                    self.largeFileDayGrowthCount = model
                }
                if dict.keys.contains("LargeFileRatio") {
                    var model = GetDoctorHDFSClusterResponseBody.Data.Metrics.LargeFileRatio()
                    model.fromMap(dict["LargeFileRatio"] as! [String: Any])
                    self.largeFileRatio = model
                }
                if dict.keys.contains("MediumFileCount") {
                    var model = GetDoctorHDFSClusterResponseBody.Data.Metrics.MediumFileCount()
                    model.fromMap(dict["MediumFileCount"] as! [String: Any])
                    self.mediumFileCount = model
                }
                if dict.keys.contains("MediumFileCountDayGrowthRatio") {
                    var model = GetDoctorHDFSClusterResponseBody.Data.Metrics.MediumFileCountDayGrowthRatio()
                    model.fromMap(dict["MediumFileCountDayGrowthRatio"] as! [String: Any])
                    self.mediumFileCountDayGrowthRatio = model
                }
                if dict.keys.contains("MediumFileDayGrowthCount") {
                    var model = GetDoctorHDFSClusterResponseBody.Data.Metrics.MediumFileDayGrowthCount()
                    model.fromMap(dict["MediumFileDayGrowthCount"] as! [String: Any])
                    self.mediumFileDayGrowthCount = model
                }
                if dict.keys.contains("MediumFileRatio") {
                    var model = GetDoctorHDFSClusterResponseBody.Data.Metrics.MediumFileRatio()
                    model.fromMap(dict["MediumFileRatio"] as! [String: Any])
                    self.mediumFileRatio = model
                }
                if dict.keys.contains("SmallFileCount") {
                    var model = GetDoctorHDFSClusterResponseBody.Data.Metrics.SmallFileCount()
                    model.fromMap(dict["SmallFileCount"] as! [String: Any])
                    self.smallFileCount = model
                }
                if dict.keys.contains("SmallFileCountDayGrowthRatio") {
                    var model = GetDoctorHDFSClusterResponseBody.Data.Metrics.SmallFileCountDayGrowthRatio()
                    model.fromMap(dict["SmallFileCountDayGrowthRatio"] as! [String: Any])
                    self.smallFileCountDayGrowthRatio = model
                }
                if dict.keys.contains("SmallFileDayGrowthCount") {
                    var model = GetDoctorHDFSClusterResponseBody.Data.Metrics.SmallFileDayGrowthCount()
                    model.fromMap(dict["SmallFileDayGrowthCount"] as! [String: Any])
                    self.smallFileDayGrowthCount = model
                }
                if dict.keys.contains("SmallFileRatio") {
                    var model = GetDoctorHDFSClusterResponseBody.Data.Metrics.SmallFileRatio()
                    model.fromMap(dict["SmallFileRatio"] as! [String: Any])
                    self.smallFileRatio = model
                }
                if dict.keys.contains("TinyFileCount") {
                    var model = GetDoctorHDFSClusterResponseBody.Data.Metrics.TinyFileCount()
                    model.fromMap(dict["TinyFileCount"] as! [String: Any])
                    self.tinyFileCount = model
                }
                if dict.keys.contains("TinyFileCountDayGrowthRatio") {
                    var model = GetDoctorHDFSClusterResponseBody.Data.Metrics.TinyFileCountDayGrowthRatio()
                    model.fromMap(dict["TinyFileCountDayGrowthRatio"] as! [String: Any])
                    self.tinyFileCountDayGrowthRatio = model
                }
                if dict.keys.contains("TinyFileDayGrowthCount") {
                    var model = GetDoctorHDFSClusterResponseBody.Data.Metrics.TinyFileDayGrowthCount()
                    model.fromMap(dict["TinyFileDayGrowthCount"] as! [String: Any])
                    self.tinyFileDayGrowthCount = model
                }
                if dict.keys.contains("TinyFileRatio") {
                    var model = GetDoctorHDFSClusterResponseBody.Data.Metrics.TinyFileRatio()
                    model.fromMap(dict["TinyFileRatio"] as! [String: Any])
                    self.tinyFileRatio = model
                }
                if dict.keys.contains("TotalDataDayGrowthSize") {
                    var model = GetDoctorHDFSClusterResponseBody.Data.Metrics.TotalDataDayGrowthSize()
                    model.fromMap(dict["TotalDataDayGrowthSize"] as! [String: Any])
                    self.totalDataDayGrowthSize = model
                }
                if dict.keys.contains("TotalDataSize") {
                    var model = GetDoctorHDFSClusterResponseBody.Data.Metrics.TotalDataSize()
                    model.fromMap(dict["TotalDataSize"] as! [String: Any])
                    self.totalDataSize = model
                }
                if dict.keys.contains("TotalDataSizeDayGrowthRatio") {
                    var model = GetDoctorHDFSClusterResponseBody.Data.Metrics.TotalDataSizeDayGrowthRatio()
                    model.fromMap(dict["TotalDataSizeDayGrowthRatio"] as! [String: Any])
                    self.totalDataSizeDayGrowthRatio = model
                }
                if dict.keys.contains("TotalFileCount") {
                    var model = GetDoctorHDFSClusterResponseBody.Data.Metrics.TotalFileCount()
                    model.fromMap(dict["TotalFileCount"] as! [String: Any])
                    self.totalFileCount = model
                }
                if dict.keys.contains("TotalFileCountDayGrowthRatio") {
                    var model = GetDoctorHDFSClusterResponseBody.Data.Metrics.TotalFileCountDayGrowthRatio()
                    model.fromMap(dict["TotalFileCountDayGrowthRatio"] as! [String: Any])
                    self.totalFileCountDayGrowthRatio = model
                }
                if dict.keys.contains("TotalFileDayGrowthCount") {
                    var model = GetDoctorHDFSClusterResponseBody.Data.Metrics.TotalFileDayGrowthCount()
                    model.fromMap(dict["TotalFileDayGrowthCount"] as! [String: Any])
                    self.totalFileDayGrowthCount = model
                }
                if dict.keys.contains("WarmDataDayGrowthSize") {
                    var model = GetDoctorHDFSClusterResponseBody.Data.Metrics.WarmDataDayGrowthSize()
                    model.fromMap(dict["WarmDataDayGrowthSize"] as! [String: Any])
                    self.warmDataDayGrowthSize = model
                }
                if dict.keys.contains("WarmDataRatio") {
                    var model = GetDoctorHDFSClusterResponseBody.Data.Metrics.WarmDataRatio()
                    model.fromMap(dict["WarmDataRatio"] as! [String: Any])
                    self.warmDataRatio = model
                }
                if dict.keys.contains("WarmDataSize") {
                    var model = GetDoctorHDFSClusterResponseBody.Data.Metrics.WarmDataSize()
                    model.fromMap(dict["WarmDataSize"] as! [String: Any])
                    self.warmDataSize = model
                }
                if dict.keys.contains("WarmDataSizeDayGrowthRatio") {
                    var model = GetDoctorHDFSClusterResponseBody.Data.Metrics.WarmDataSizeDayGrowthRatio()
                    model.fromMap(dict["WarmDataSizeDayGrowthRatio"] as! [String: Any])
                    self.warmDataSizeDayGrowthRatio = model
                }
            }
        }
        public var analysis: GetDoctorHDFSClusterResponseBody.Data.Analysis?

        public var metrics: GetDoctorHDFSClusterResponseBody.Data.Metrics?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.analysis?.validate()
            try self.metrics?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.analysis != nil {
                map["Analysis"] = self.analysis?.toMap()
            }
            if self.metrics != nil {
                map["Metrics"] = self.metrics?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Analysis") {
                var model = GetDoctorHDFSClusterResponseBody.Data.Analysis()
                model.fromMap(dict["Analysis"] as! [String: Any])
                self.analysis = model
            }
            if dict.keys.contains("Metrics") {
                var model = GetDoctorHDFSClusterResponseBody.Data.Metrics()
                model.fromMap(dict["Metrics"] as! [String: Any])
                self.metrics = model
            }
        }
    }
    public var data: GetDoctorHDFSClusterResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = GetDoctorHDFSClusterResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetDoctorHDFSClusterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDoctorHDFSClusterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDoctorHDFSClusterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDoctorHDFSDirectoryRequest : Tea.TeaModel {
    public var clusterId: String?

    public var dateTime: String?

    public var dirPath: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.dateTime != nil {
            map["DateTime"] = self.dateTime!
        }
        if self.dirPath != nil {
            map["DirPath"] = self.dirPath!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("DateTime") {
            self.dateTime = dict["DateTime"] as! String
        }
        if dict.keys.contains("DirPath") {
            self.dirPath = dict["DirPath"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class GetDoctorHDFSDirectoryResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Metrics : Tea.TeaModel {
            public class ColdDataDayGrowthSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class ColdDataSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class ColdDataSizeDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class EmptyFileCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class EmptyFileCountDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class EmptyFileDayGrowthCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class FreezeDataDayGrowthSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class FreezeDataSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class FreezeDataSizeDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class HotDataDayGrowthSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class HotDataSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class HotDataSizeDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class LargeFileCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class LargeFileCountDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class LargeFileDayGrowthCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class MediumFileCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class MediumFileCountDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class MediumFileDayGrowthCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class SmallFileCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class SmallFileCountDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class SmallFileDayGrowthCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class TinyFileCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class TinyFileCountDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class TinyFileDayGrowthCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class TotalDataDayGrowthSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class TotalDataSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class TotalDataSizeDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class TotalFileCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class TotalFileCountDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class TotalFileDayGrowthCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class WarmDataDayGrowthSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class WarmDataSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class WarmDataSizeDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public var coldDataDayGrowthSize: GetDoctorHDFSDirectoryResponseBody.Data.Metrics.ColdDataDayGrowthSize?

            public var coldDataSize: GetDoctorHDFSDirectoryResponseBody.Data.Metrics.ColdDataSize?

            public var coldDataSizeDayGrowthRatio: GetDoctorHDFSDirectoryResponseBody.Data.Metrics.ColdDataSizeDayGrowthRatio?

            public var emptyFileCount: GetDoctorHDFSDirectoryResponseBody.Data.Metrics.EmptyFileCount?

            public var emptyFileCountDayGrowthRatio: GetDoctorHDFSDirectoryResponseBody.Data.Metrics.EmptyFileCountDayGrowthRatio?

            public var emptyFileDayGrowthCount: GetDoctorHDFSDirectoryResponseBody.Data.Metrics.EmptyFileDayGrowthCount?

            public var freezeDataDayGrowthSize: GetDoctorHDFSDirectoryResponseBody.Data.Metrics.FreezeDataDayGrowthSize?

            public var freezeDataSize: GetDoctorHDFSDirectoryResponseBody.Data.Metrics.FreezeDataSize?

            public var freezeDataSizeDayGrowthRatio: GetDoctorHDFSDirectoryResponseBody.Data.Metrics.FreezeDataSizeDayGrowthRatio?

            public var hotDataDayGrowthSize: GetDoctorHDFSDirectoryResponseBody.Data.Metrics.HotDataDayGrowthSize?

            public var hotDataSize: GetDoctorHDFSDirectoryResponseBody.Data.Metrics.HotDataSize?

            public var hotDataSizeDayGrowthRatio: GetDoctorHDFSDirectoryResponseBody.Data.Metrics.HotDataSizeDayGrowthRatio?

            public var largeFileCount: GetDoctorHDFSDirectoryResponseBody.Data.Metrics.LargeFileCount?

            public var largeFileCountDayGrowthRatio: GetDoctorHDFSDirectoryResponseBody.Data.Metrics.LargeFileCountDayGrowthRatio?

            public var largeFileDayGrowthCount: GetDoctorHDFSDirectoryResponseBody.Data.Metrics.LargeFileDayGrowthCount?

            public var mediumFileCount: GetDoctorHDFSDirectoryResponseBody.Data.Metrics.MediumFileCount?

            public var mediumFileCountDayGrowthRatio: GetDoctorHDFSDirectoryResponseBody.Data.Metrics.MediumFileCountDayGrowthRatio?

            public var mediumFileDayGrowthCount: GetDoctorHDFSDirectoryResponseBody.Data.Metrics.MediumFileDayGrowthCount?

            public var smallFileCount: GetDoctorHDFSDirectoryResponseBody.Data.Metrics.SmallFileCount?

            public var smallFileCountDayGrowthRatio: GetDoctorHDFSDirectoryResponseBody.Data.Metrics.SmallFileCountDayGrowthRatio?

            public var smallFileDayGrowthCount: GetDoctorHDFSDirectoryResponseBody.Data.Metrics.SmallFileDayGrowthCount?

            public var tinyFileCount: GetDoctorHDFSDirectoryResponseBody.Data.Metrics.TinyFileCount?

            public var tinyFileCountDayGrowthRatio: GetDoctorHDFSDirectoryResponseBody.Data.Metrics.TinyFileCountDayGrowthRatio?

            public var tinyFileDayGrowthCount: GetDoctorHDFSDirectoryResponseBody.Data.Metrics.TinyFileDayGrowthCount?

            public var totalDataDayGrowthSize: GetDoctorHDFSDirectoryResponseBody.Data.Metrics.TotalDataDayGrowthSize?

            public var totalDataSize: GetDoctorHDFSDirectoryResponseBody.Data.Metrics.TotalDataSize?

            public var totalDataSizeDayGrowthRatio: GetDoctorHDFSDirectoryResponseBody.Data.Metrics.TotalDataSizeDayGrowthRatio?

            public var totalFileCount: GetDoctorHDFSDirectoryResponseBody.Data.Metrics.TotalFileCount?

            public var totalFileCountDayGrowthRatio: GetDoctorHDFSDirectoryResponseBody.Data.Metrics.TotalFileCountDayGrowthRatio?

            public var totalFileDayGrowthCount: GetDoctorHDFSDirectoryResponseBody.Data.Metrics.TotalFileDayGrowthCount?

            public var warmDataDayGrowthSize: GetDoctorHDFSDirectoryResponseBody.Data.Metrics.WarmDataDayGrowthSize?

            public var warmDataSize: GetDoctorHDFSDirectoryResponseBody.Data.Metrics.WarmDataSize?

            public var warmDataSizeDayGrowthRatio: GetDoctorHDFSDirectoryResponseBody.Data.Metrics.WarmDataSizeDayGrowthRatio?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.coldDataDayGrowthSize?.validate()
                try self.coldDataSize?.validate()
                try self.coldDataSizeDayGrowthRatio?.validate()
                try self.emptyFileCount?.validate()
                try self.emptyFileCountDayGrowthRatio?.validate()
                try self.emptyFileDayGrowthCount?.validate()
                try self.freezeDataDayGrowthSize?.validate()
                try self.freezeDataSize?.validate()
                try self.freezeDataSizeDayGrowthRatio?.validate()
                try self.hotDataDayGrowthSize?.validate()
                try self.hotDataSize?.validate()
                try self.hotDataSizeDayGrowthRatio?.validate()
                try self.largeFileCount?.validate()
                try self.largeFileCountDayGrowthRatio?.validate()
                try self.largeFileDayGrowthCount?.validate()
                try self.mediumFileCount?.validate()
                try self.mediumFileCountDayGrowthRatio?.validate()
                try self.mediumFileDayGrowthCount?.validate()
                try self.smallFileCount?.validate()
                try self.smallFileCountDayGrowthRatio?.validate()
                try self.smallFileDayGrowthCount?.validate()
                try self.tinyFileCount?.validate()
                try self.tinyFileCountDayGrowthRatio?.validate()
                try self.tinyFileDayGrowthCount?.validate()
                try self.totalDataDayGrowthSize?.validate()
                try self.totalDataSize?.validate()
                try self.totalDataSizeDayGrowthRatio?.validate()
                try self.totalFileCount?.validate()
                try self.totalFileCountDayGrowthRatio?.validate()
                try self.totalFileDayGrowthCount?.validate()
                try self.warmDataDayGrowthSize?.validate()
                try self.warmDataSize?.validate()
                try self.warmDataSizeDayGrowthRatio?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.coldDataDayGrowthSize != nil {
                    map["ColdDataDayGrowthSize"] = self.coldDataDayGrowthSize?.toMap()
                }
                if self.coldDataSize != nil {
                    map["ColdDataSize"] = self.coldDataSize?.toMap()
                }
                if self.coldDataSizeDayGrowthRatio != nil {
                    map["ColdDataSizeDayGrowthRatio"] = self.coldDataSizeDayGrowthRatio?.toMap()
                }
                if self.emptyFileCount != nil {
                    map["EmptyFileCount"] = self.emptyFileCount?.toMap()
                }
                if self.emptyFileCountDayGrowthRatio != nil {
                    map["EmptyFileCountDayGrowthRatio"] = self.emptyFileCountDayGrowthRatio?.toMap()
                }
                if self.emptyFileDayGrowthCount != nil {
                    map["EmptyFileDayGrowthCount"] = self.emptyFileDayGrowthCount?.toMap()
                }
                if self.freezeDataDayGrowthSize != nil {
                    map["FreezeDataDayGrowthSize"] = self.freezeDataDayGrowthSize?.toMap()
                }
                if self.freezeDataSize != nil {
                    map["FreezeDataSize"] = self.freezeDataSize?.toMap()
                }
                if self.freezeDataSizeDayGrowthRatio != nil {
                    map["FreezeDataSizeDayGrowthRatio"] = self.freezeDataSizeDayGrowthRatio?.toMap()
                }
                if self.hotDataDayGrowthSize != nil {
                    map["HotDataDayGrowthSize"] = self.hotDataDayGrowthSize?.toMap()
                }
                if self.hotDataSize != nil {
                    map["HotDataSize"] = self.hotDataSize?.toMap()
                }
                if self.hotDataSizeDayGrowthRatio != nil {
                    map["HotDataSizeDayGrowthRatio"] = self.hotDataSizeDayGrowthRatio?.toMap()
                }
                if self.largeFileCount != nil {
                    map["LargeFileCount"] = self.largeFileCount?.toMap()
                }
                if self.largeFileCountDayGrowthRatio != nil {
                    map["LargeFileCountDayGrowthRatio"] = self.largeFileCountDayGrowthRatio?.toMap()
                }
                if self.largeFileDayGrowthCount != nil {
                    map["LargeFileDayGrowthCount"] = self.largeFileDayGrowthCount?.toMap()
                }
                if self.mediumFileCount != nil {
                    map["MediumFileCount"] = self.mediumFileCount?.toMap()
                }
                if self.mediumFileCountDayGrowthRatio != nil {
                    map["MediumFileCountDayGrowthRatio"] = self.mediumFileCountDayGrowthRatio?.toMap()
                }
                if self.mediumFileDayGrowthCount != nil {
                    map["MediumFileDayGrowthCount"] = self.mediumFileDayGrowthCount?.toMap()
                }
                if self.smallFileCount != nil {
                    map["SmallFileCount"] = self.smallFileCount?.toMap()
                }
                if self.smallFileCountDayGrowthRatio != nil {
                    map["SmallFileCountDayGrowthRatio"] = self.smallFileCountDayGrowthRatio?.toMap()
                }
                if self.smallFileDayGrowthCount != nil {
                    map["SmallFileDayGrowthCount"] = self.smallFileDayGrowthCount?.toMap()
                }
                if self.tinyFileCount != nil {
                    map["TinyFileCount"] = self.tinyFileCount?.toMap()
                }
                if self.tinyFileCountDayGrowthRatio != nil {
                    map["TinyFileCountDayGrowthRatio"] = self.tinyFileCountDayGrowthRatio?.toMap()
                }
                if self.tinyFileDayGrowthCount != nil {
                    map["TinyFileDayGrowthCount"] = self.tinyFileDayGrowthCount?.toMap()
                }
                if self.totalDataDayGrowthSize != nil {
                    map["TotalDataDayGrowthSize"] = self.totalDataDayGrowthSize?.toMap()
                }
                if self.totalDataSize != nil {
                    map["TotalDataSize"] = self.totalDataSize?.toMap()
                }
                if self.totalDataSizeDayGrowthRatio != nil {
                    map["TotalDataSizeDayGrowthRatio"] = self.totalDataSizeDayGrowthRatio?.toMap()
                }
                if self.totalFileCount != nil {
                    map["TotalFileCount"] = self.totalFileCount?.toMap()
                }
                if self.totalFileCountDayGrowthRatio != nil {
                    map["TotalFileCountDayGrowthRatio"] = self.totalFileCountDayGrowthRatio?.toMap()
                }
                if self.totalFileDayGrowthCount != nil {
                    map["TotalFileDayGrowthCount"] = self.totalFileDayGrowthCount?.toMap()
                }
                if self.warmDataDayGrowthSize != nil {
                    map["WarmDataDayGrowthSize"] = self.warmDataDayGrowthSize?.toMap()
                }
                if self.warmDataSize != nil {
                    map["WarmDataSize"] = self.warmDataSize?.toMap()
                }
                if self.warmDataSizeDayGrowthRatio != nil {
                    map["WarmDataSizeDayGrowthRatio"] = self.warmDataSizeDayGrowthRatio?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ColdDataDayGrowthSize") {
                    var model = GetDoctorHDFSDirectoryResponseBody.Data.Metrics.ColdDataDayGrowthSize()
                    model.fromMap(dict["ColdDataDayGrowthSize"] as! [String: Any])
                    self.coldDataDayGrowthSize = model
                }
                if dict.keys.contains("ColdDataSize") {
                    var model = GetDoctorHDFSDirectoryResponseBody.Data.Metrics.ColdDataSize()
                    model.fromMap(dict["ColdDataSize"] as! [String: Any])
                    self.coldDataSize = model
                }
                if dict.keys.contains("ColdDataSizeDayGrowthRatio") {
                    var model = GetDoctorHDFSDirectoryResponseBody.Data.Metrics.ColdDataSizeDayGrowthRatio()
                    model.fromMap(dict["ColdDataSizeDayGrowthRatio"] as! [String: Any])
                    self.coldDataSizeDayGrowthRatio = model
                }
                if dict.keys.contains("EmptyFileCount") {
                    var model = GetDoctorHDFSDirectoryResponseBody.Data.Metrics.EmptyFileCount()
                    model.fromMap(dict["EmptyFileCount"] as! [String: Any])
                    self.emptyFileCount = model
                }
                if dict.keys.contains("EmptyFileCountDayGrowthRatio") {
                    var model = GetDoctorHDFSDirectoryResponseBody.Data.Metrics.EmptyFileCountDayGrowthRatio()
                    model.fromMap(dict["EmptyFileCountDayGrowthRatio"] as! [String: Any])
                    self.emptyFileCountDayGrowthRatio = model
                }
                if dict.keys.contains("EmptyFileDayGrowthCount") {
                    var model = GetDoctorHDFSDirectoryResponseBody.Data.Metrics.EmptyFileDayGrowthCount()
                    model.fromMap(dict["EmptyFileDayGrowthCount"] as! [String: Any])
                    self.emptyFileDayGrowthCount = model
                }
                if dict.keys.contains("FreezeDataDayGrowthSize") {
                    var model = GetDoctorHDFSDirectoryResponseBody.Data.Metrics.FreezeDataDayGrowthSize()
                    model.fromMap(dict["FreezeDataDayGrowthSize"] as! [String: Any])
                    self.freezeDataDayGrowthSize = model
                }
                if dict.keys.contains("FreezeDataSize") {
                    var model = GetDoctorHDFSDirectoryResponseBody.Data.Metrics.FreezeDataSize()
                    model.fromMap(dict["FreezeDataSize"] as! [String: Any])
                    self.freezeDataSize = model
                }
                if dict.keys.contains("FreezeDataSizeDayGrowthRatio") {
                    var model = GetDoctorHDFSDirectoryResponseBody.Data.Metrics.FreezeDataSizeDayGrowthRatio()
                    model.fromMap(dict["FreezeDataSizeDayGrowthRatio"] as! [String: Any])
                    self.freezeDataSizeDayGrowthRatio = model
                }
                if dict.keys.contains("HotDataDayGrowthSize") {
                    var model = GetDoctorHDFSDirectoryResponseBody.Data.Metrics.HotDataDayGrowthSize()
                    model.fromMap(dict["HotDataDayGrowthSize"] as! [String: Any])
                    self.hotDataDayGrowthSize = model
                }
                if dict.keys.contains("HotDataSize") {
                    var model = GetDoctorHDFSDirectoryResponseBody.Data.Metrics.HotDataSize()
                    model.fromMap(dict["HotDataSize"] as! [String: Any])
                    self.hotDataSize = model
                }
                if dict.keys.contains("HotDataSizeDayGrowthRatio") {
                    var model = GetDoctorHDFSDirectoryResponseBody.Data.Metrics.HotDataSizeDayGrowthRatio()
                    model.fromMap(dict["HotDataSizeDayGrowthRatio"] as! [String: Any])
                    self.hotDataSizeDayGrowthRatio = model
                }
                if dict.keys.contains("LargeFileCount") {
                    var model = GetDoctorHDFSDirectoryResponseBody.Data.Metrics.LargeFileCount()
                    model.fromMap(dict["LargeFileCount"] as! [String: Any])
                    self.largeFileCount = model
                }
                if dict.keys.contains("LargeFileCountDayGrowthRatio") {
                    var model = GetDoctorHDFSDirectoryResponseBody.Data.Metrics.LargeFileCountDayGrowthRatio()
                    model.fromMap(dict["LargeFileCountDayGrowthRatio"] as! [String: Any])
                    self.largeFileCountDayGrowthRatio = model
                }
                if dict.keys.contains("LargeFileDayGrowthCount") {
                    var model = GetDoctorHDFSDirectoryResponseBody.Data.Metrics.LargeFileDayGrowthCount()
                    model.fromMap(dict["LargeFileDayGrowthCount"] as! [String: Any])
                    self.largeFileDayGrowthCount = model
                }
                if dict.keys.contains("MediumFileCount") {
                    var model = GetDoctorHDFSDirectoryResponseBody.Data.Metrics.MediumFileCount()
                    model.fromMap(dict["MediumFileCount"] as! [String: Any])
                    self.mediumFileCount = model
                }
                if dict.keys.contains("MediumFileCountDayGrowthRatio") {
                    var model = GetDoctorHDFSDirectoryResponseBody.Data.Metrics.MediumFileCountDayGrowthRatio()
                    model.fromMap(dict["MediumFileCountDayGrowthRatio"] as! [String: Any])
                    self.mediumFileCountDayGrowthRatio = model
                }
                if dict.keys.contains("MediumFileDayGrowthCount") {
                    var model = GetDoctorHDFSDirectoryResponseBody.Data.Metrics.MediumFileDayGrowthCount()
                    model.fromMap(dict["MediumFileDayGrowthCount"] as! [String: Any])
                    self.mediumFileDayGrowthCount = model
                }
                if dict.keys.contains("SmallFileCount") {
                    var model = GetDoctorHDFSDirectoryResponseBody.Data.Metrics.SmallFileCount()
                    model.fromMap(dict["SmallFileCount"] as! [String: Any])
                    self.smallFileCount = model
                }
                if dict.keys.contains("SmallFileCountDayGrowthRatio") {
                    var model = GetDoctorHDFSDirectoryResponseBody.Data.Metrics.SmallFileCountDayGrowthRatio()
                    model.fromMap(dict["SmallFileCountDayGrowthRatio"] as! [String: Any])
                    self.smallFileCountDayGrowthRatio = model
                }
                if dict.keys.contains("SmallFileDayGrowthCount") {
                    var model = GetDoctorHDFSDirectoryResponseBody.Data.Metrics.SmallFileDayGrowthCount()
                    model.fromMap(dict["SmallFileDayGrowthCount"] as! [String: Any])
                    self.smallFileDayGrowthCount = model
                }
                if dict.keys.contains("TinyFileCount") {
                    var model = GetDoctorHDFSDirectoryResponseBody.Data.Metrics.TinyFileCount()
                    model.fromMap(dict["TinyFileCount"] as! [String: Any])
                    self.tinyFileCount = model
                }
                if dict.keys.contains("TinyFileCountDayGrowthRatio") {
                    var model = GetDoctorHDFSDirectoryResponseBody.Data.Metrics.TinyFileCountDayGrowthRatio()
                    model.fromMap(dict["TinyFileCountDayGrowthRatio"] as! [String: Any])
                    self.tinyFileCountDayGrowthRatio = model
                }
                if dict.keys.contains("TinyFileDayGrowthCount") {
                    var model = GetDoctorHDFSDirectoryResponseBody.Data.Metrics.TinyFileDayGrowthCount()
                    model.fromMap(dict["TinyFileDayGrowthCount"] as! [String: Any])
                    self.tinyFileDayGrowthCount = model
                }
                if dict.keys.contains("TotalDataDayGrowthSize") {
                    var model = GetDoctorHDFSDirectoryResponseBody.Data.Metrics.TotalDataDayGrowthSize()
                    model.fromMap(dict["TotalDataDayGrowthSize"] as! [String: Any])
                    self.totalDataDayGrowthSize = model
                }
                if dict.keys.contains("TotalDataSize") {
                    var model = GetDoctorHDFSDirectoryResponseBody.Data.Metrics.TotalDataSize()
                    model.fromMap(dict["TotalDataSize"] as! [String: Any])
                    self.totalDataSize = model
                }
                if dict.keys.contains("TotalDataSizeDayGrowthRatio") {
                    var model = GetDoctorHDFSDirectoryResponseBody.Data.Metrics.TotalDataSizeDayGrowthRatio()
                    model.fromMap(dict["TotalDataSizeDayGrowthRatio"] as! [String: Any])
                    self.totalDataSizeDayGrowthRatio = model
                }
                if dict.keys.contains("TotalFileCount") {
                    var model = GetDoctorHDFSDirectoryResponseBody.Data.Metrics.TotalFileCount()
                    model.fromMap(dict["TotalFileCount"] as! [String: Any])
                    self.totalFileCount = model
                }
                if dict.keys.contains("TotalFileCountDayGrowthRatio") {
                    var model = GetDoctorHDFSDirectoryResponseBody.Data.Metrics.TotalFileCountDayGrowthRatio()
                    model.fromMap(dict["TotalFileCountDayGrowthRatio"] as! [String: Any])
                    self.totalFileCountDayGrowthRatio = model
                }
                if dict.keys.contains("TotalFileDayGrowthCount") {
                    var model = GetDoctorHDFSDirectoryResponseBody.Data.Metrics.TotalFileDayGrowthCount()
                    model.fromMap(dict["TotalFileDayGrowthCount"] as! [String: Any])
                    self.totalFileDayGrowthCount = model
                }
                if dict.keys.contains("WarmDataDayGrowthSize") {
                    var model = GetDoctorHDFSDirectoryResponseBody.Data.Metrics.WarmDataDayGrowthSize()
                    model.fromMap(dict["WarmDataDayGrowthSize"] as! [String: Any])
                    self.warmDataDayGrowthSize = model
                }
                if dict.keys.contains("WarmDataSize") {
                    var model = GetDoctorHDFSDirectoryResponseBody.Data.Metrics.WarmDataSize()
                    model.fromMap(dict["WarmDataSize"] as! [String: Any])
                    self.warmDataSize = model
                }
                if dict.keys.contains("WarmDataSizeDayGrowthRatio") {
                    var model = GetDoctorHDFSDirectoryResponseBody.Data.Metrics.WarmDataSizeDayGrowthRatio()
                    model.fromMap(dict["WarmDataSizeDayGrowthRatio"] as! [String: Any])
                    self.warmDataSizeDayGrowthRatio = model
                }
            }
        }
        public var depth: Int32?

        public var group: String?

        public var metrics: GetDoctorHDFSDirectoryResponseBody.Data.Metrics?

        public var user: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.metrics?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.depth != nil {
                map["Depth"] = self.depth!
            }
            if self.group != nil {
                map["Group"] = self.group!
            }
            if self.metrics != nil {
                map["Metrics"] = self.metrics?.toMap()
            }
            if self.user != nil {
                map["User"] = self.user!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Depth") {
                self.depth = dict["Depth"] as! Int32
            }
            if dict.keys.contains("Group") {
                self.group = dict["Group"] as! String
            }
            if dict.keys.contains("Metrics") {
                var model = GetDoctorHDFSDirectoryResponseBody.Data.Metrics()
                model.fromMap(dict["Metrics"] as! [String: Any])
                self.metrics = model
            }
            if dict.keys.contains("User") {
                self.user = dict["User"] as! String
            }
        }
    }
    public var data: GetDoctorHDFSDirectoryResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = GetDoctorHDFSDirectoryResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetDoctorHDFSDirectoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDoctorHDFSDirectoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDoctorHDFSDirectoryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDoctorHDFSUGIRequest : Tea.TeaModel {
    public var clusterId: String?

    public var dateTime: String?

    public var name: String?

    public var regionId: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.dateTime != nil {
            map["DateTime"] = self.dateTime!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("DateTime") {
            self.dateTime = dict["DateTime"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class GetDoctorHDFSUGIResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Metrics : Tea.TeaModel {
            public class TotalDataSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class TotalDirCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class TotalFileCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public var totalDataSize: GetDoctorHDFSUGIResponseBody.Data.Metrics.TotalDataSize?

            public var totalDirCount: GetDoctorHDFSUGIResponseBody.Data.Metrics.TotalDirCount?

            public var totalFileCount: GetDoctorHDFSUGIResponseBody.Data.Metrics.TotalFileCount?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.totalDataSize?.validate()
                try self.totalDirCount?.validate()
                try self.totalFileCount?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.totalDataSize != nil {
                    map["TotalDataSize"] = self.totalDataSize?.toMap()
                }
                if self.totalDirCount != nil {
                    map["TotalDirCount"] = self.totalDirCount?.toMap()
                }
                if self.totalFileCount != nil {
                    map["TotalFileCount"] = self.totalFileCount?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("TotalDataSize") {
                    var model = GetDoctorHDFSUGIResponseBody.Data.Metrics.TotalDataSize()
                    model.fromMap(dict["TotalDataSize"] as! [String: Any])
                    self.totalDataSize = model
                }
                if dict.keys.contains("TotalDirCount") {
                    var model = GetDoctorHDFSUGIResponseBody.Data.Metrics.TotalDirCount()
                    model.fromMap(dict["TotalDirCount"] as! [String: Any])
                    self.totalDirCount = model
                }
                if dict.keys.contains("TotalFileCount") {
                    var model = GetDoctorHDFSUGIResponseBody.Data.Metrics.TotalFileCount()
                    model.fromMap(dict["TotalFileCount"] as! [String: Any])
                    self.totalFileCount = model
                }
            }
        }
        public var metrics: GetDoctorHDFSUGIResponseBody.Data.Metrics?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.metrics?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.metrics != nil {
                map["Metrics"] = self.metrics?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Metrics") {
                var model = GetDoctorHDFSUGIResponseBody.Data.Metrics()
                model.fromMap(dict["Metrics"] as! [String: Any])
                self.metrics = model
            }
        }
    }
    public var data: GetDoctorHDFSUGIResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = GetDoctorHDFSUGIResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetDoctorHDFSUGIResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDoctorHDFSUGIResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDoctorHDFSUGIResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDoctorHiveClusterRequest : Tea.TeaModel {
    public var clusterId: String?

    public var dateTime: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.dateTime != nil {
            map["DateTime"] = self.dateTime!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("DateTime") {
            self.dateTime = dict["DateTime"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class GetDoctorHiveClusterResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Analysis : Tea.TeaModel {
            public var hiveDistributionScore: Int32?

            public var hiveFormatScore: Int32?

            public var hiveFrequencyScore: Int32?

            public var hiveScore: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.hiveDistributionScore != nil {
                    map["HiveDistributionScore"] = self.hiveDistributionScore!
                }
                if self.hiveFormatScore != nil {
                    map["HiveFormatScore"] = self.hiveFormatScore!
                }
                if self.hiveFrequencyScore != nil {
                    map["HiveFrequencyScore"] = self.hiveFrequencyScore!
                }
                if self.hiveScore != nil {
                    map["HiveScore"] = self.hiveScore!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("HiveDistributionScore") {
                    self.hiveDistributionScore = dict["HiveDistributionScore"] as! Int32
                }
                if dict.keys.contains("HiveFormatScore") {
                    self.hiveFormatScore = dict["HiveFormatScore"] as! Int32
                }
                if dict.keys.contains("HiveFrequencyScore") {
                    self.hiveFrequencyScore = dict["HiveFrequencyScore"] as! Int32
                }
                if dict.keys.contains("HiveScore") {
                    self.hiveScore = dict["HiveScore"] as! Int32
                }
            }
        }
        public class Formats : Tea.TeaModel {
            public var formatName: String?

            public var formatRatio: Double?

            public var formatSize: Int64?

            public var formatSizeUnit: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.formatName != nil {
                    map["FormatName"] = self.formatName!
                }
                if self.formatRatio != nil {
                    map["FormatRatio"] = self.formatRatio!
                }
                if self.formatSize != nil {
                    map["FormatSize"] = self.formatSize!
                }
                if self.formatSizeUnit != nil {
                    map["FormatSizeUnit"] = self.formatSizeUnit!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FormatName") {
                    self.formatName = dict["FormatName"] as! String
                }
                if dict.keys.contains("FormatRatio") {
                    self.formatRatio = dict["FormatRatio"] as! Double
                }
                if dict.keys.contains("FormatSize") {
                    self.formatSize = dict["FormatSize"] as! Int64
                }
                if dict.keys.contains("FormatSizeUnit") {
                    self.formatSizeUnit = dict["FormatSizeUnit"] as! String
                }
            }
        }
        public class Metrics : Tea.TeaModel {
            public class ColdDataDayGrowthSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class ColdDataRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class ColdDataSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class ColdDataSizeDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class DatabaseCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class EmptyFileCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class EmptyFileCountDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class EmptyFileDayGrowthCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class EmptyFileRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class FreezeDataDayGrowthSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class FreezeDataRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class FreezeDataSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class FreezeDataSizeDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class HotDataDayGrowthSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class HotDataRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class HotDataSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class HotDataSizeDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class LargeFileCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class LargeFileCountDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class LargeFileDayGrowthCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class LargeFileRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class MediumFileCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class MediumFileCountDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class MediumFileDayGrowthCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class MediumFileRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class PartitionNum : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class SmallFileCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class SmallFileCountDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class SmallFileDayGrowthCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class SmallFileRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class TableCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class TinyFileCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class TinyFileCountDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class TinyFileDayGrowthCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class TinyFileRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class TotalDataDayGrowthSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class TotalDataSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class TotalDataSizeDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class TotalFileCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class TotalFileCountDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class TotalFileDayGrowthCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class WarmDataDayGrowthSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class WarmDataRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class WarmDataSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class WarmDataSizeDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public var coldDataDayGrowthSize: GetDoctorHiveClusterResponseBody.Data.Metrics.ColdDataDayGrowthSize?

            public var coldDataRatio: GetDoctorHiveClusterResponseBody.Data.Metrics.ColdDataRatio?

            public var coldDataSize: GetDoctorHiveClusterResponseBody.Data.Metrics.ColdDataSize?

            public var coldDataSizeDayGrowthRatio: GetDoctorHiveClusterResponseBody.Data.Metrics.ColdDataSizeDayGrowthRatio?

            public var databaseCount: GetDoctorHiveClusterResponseBody.Data.Metrics.DatabaseCount?

            public var emptyFileCount: GetDoctorHiveClusterResponseBody.Data.Metrics.EmptyFileCount?

            public var emptyFileCountDayGrowthRatio: GetDoctorHiveClusterResponseBody.Data.Metrics.EmptyFileCountDayGrowthRatio?

            public var emptyFileDayGrowthCount: GetDoctorHiveClusterResponseBody.Data.Metrics.EmptyFileDayGrowthCount?

            public var emptyFileRatio: GetDoctorHiveClusterResponseBody.Data.Metrics.EmptyFileRatio?

            public var freezeDataDayGrowthSize: GetDoctorHiveClusterResponseBody.Data.Metrics.FreezeDataDayGrowthSize?

            public var freezeDataRatio: GetDoctorHiveClusterResponseBody.Data.Metrics.FreezeDataRatio?

            public var freezeDataSize: GetDoctorHiveClusterResponseBody.Data.Metrics.FreezeDataSize?

            public var freezeDataSizeDayGrowthRatio: GetDoctorHiveClusterResponseBody.Data.Metrics.FreezeDataSizeDayGrowthRatio?

            public var hotDataDayGrowthSize: GetDoctorHiveClusterResponseBody.Data.Metrics.HotDataDayGrowthSize?

            public var hotDataRatio: GetDoctorHiveClusterResponseBody.Data.Metrics.HotDataRatio?

            public var hotDataSize: GetDoctorHiveClusterResponseBody.Data.Metrics.HotDataSize?

            public var hotDataSizeDayGrowthRatio: GetDoctorHiveClusterResponseBody.Data.Metrics.HotDataSizeDayGrowthRatio?

            public var largeFileCount: GetDoctorHiveClusterResponseBody.Data.Metrics.LargeFileCount?

            public var largeFileCountDayGrowthRatio: GetDoctorHiveClusterResponseBody.Data.Metrics.LargeFileCountDayGrowthRatio?

            public var largeFileDayGrowthCount: GetDoctorHiveClusterResponseBody.Data.Metrics.LargeFileDayGrowthCount?

            public var largeFileRatio: GetDoctorHiveClusterResponseBody.Data.Metrics.LargeFileRatio?

            public var mediumFileCount: GetDoctorHiveClusterResponseBody.Data.Metrics.MediumFileCount?

            public var mediumFileCountDayGrowthRatio: GetDoctorHiveClusterResponseBody.Data.Metrics.MediumFileCountDayGrowthRatio?

            public var mediumFileDayGrowthCount: GetDoctorHiveClusterResponseBody.Data.Metrics.MediumFileDayGrowthCount?

            public var mediumFileRatio: GetDoctorHiveClusterResponseBody.Data.Metrics.MediumFileRatio?

            public var partitionNum: GetDoctorHiveClusterResponseBody.Data.Metrics.PartitionNum?

            public var smallFileCount: GetDoctorHiveClusterResponseBody.Data.Metrics.SmallFileCount?

            public var smallFileCountDayGrowthRatio: GetDoctorHiveClusterResponseBody.Data.Metrics.SmallFileCountDayGrowthRatio?

            public var smallFileDayGrowthCount: GetDoctorHiveClusterResponseBody.Data.Metrics.SmallFileDayGrowthCount?

            public var smallFileRatio: GetDoctorHiveClusterResponseBody.Data.Metrics.SmallFileRatio?

            public var tableCount: GetDoctorHiveClusterResponseBody.Data.Metrics.TableCount?

            public var tinyFileCount: GetDoctorHiveClusterResponseBody.Data.Metrics.TinyFileCount?

            public var tinyFileCountDayGrowthRatio: GetDoctorHiveClusterResponseBody.Data.Metrics.TinyFileCountDayGrowthRatio?

            public var tinyFileDayGrowthCount: GetDoctorHiveClusterResponseBody.Data.Metrics.TinyFileDayGrowthCount?

            public var tinyFileRatio: GetDoctorHiveClusterResponseBody.Data.Metrics.TinyFileRatio?

            public var totalDataDayGrowthSize: GetDoctorHiveClusterResponseBody.Data.Metrics.TotalDataDayGrowthSize?

            public var totalDataSize: GetDoctorHiveClusterResponseBody.Data.Metrics.TotalDataSize?

            public var totalDataSizeDayGrowthRatio: GetDoctorHiveClusterResponseBody.Data.Metrics.TotalDataSizeDayGrowthRatio?

            public var totalFileCount: GetDoctorHiveClusterResponseBody.Data.Metrics.TotalFileCount?

            public var totalFileCountDayGrowthRatio: GetDoctorHiveClusterResponseBody.Data.Metrics.TotalFileCountDayGrowthRatio?

            public var totalFileDayGrowthCount: GetDoctorHiveClusterResponseBody.Data.Metrics.TotalFileDayGrowthCount?

            public var warmDataDayGrowthSize: GetDoctorHiveClusterResponseBody.Data.Metrics.WarmDataDayGrowthSize?

            public var warmDataRatio: GetDoctorHiveClusterResponseBody.Data.Metrics.WarmDataRatio?

            public var warmDataSize: GetDoctorHiveClusterResponseBody.Data.Metrics.WarmDataSize?

            public var warmDataSizeDayGrowthRatio: GetDoctorHiveClusterResponseBody.Data.Metrics.WarmDataSizeDayGrowthRatio?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.coldDataDayGrowthSize?.validate()
                try self.coldDataRatio?.validate()
                try self.coldDataSize?.validate()
                try self.coldDataSizeDayGrowthRatio?.validate()
                try self.databaseCount?.validate()
                try self.emptyFileCount?.validate()
                try self.emptyFileCountDayGrowthRatio?.validate()
                try self.emptyFileDayGrowthCount?.validate()
                try self.emptyFileRatio?.validate()
                try self.freezeDataDayGrowthSize?.validate()
                try self.freezeDataRatio?.validate()
                try self.freezeDataSize?.validate()
                try self.freezeDataSizeDayGrowthRatio?.validate()
                try self.hotDataDayGrowthSize?.validate()
                try self.hotDataRatio?.validate()
                try self.hotDataSize?.validate()
                try self.hotDataSizeDayGrowthRatio?.validate()
                try self.largeFileCount?.validate()
                try self.largeFileCountDayGrowthRatio?.validate()
                try self.largeFileDayGrowthCount?.validate()
                try self.largeFileRatio?.validate()
                try self.mediumFileCount?.validate()
                try self.mediumFileCountDayGrowthRatio?.validate()
                try self.mediumFileDayGrowthCount?.validate()
                try self.mediumFileRatio?.validate()
                try self.partitionNum?.validate()
                try self.smallFileCount?.validate()
                try self.smallFileCountDayGrowthRatio?.validate()
                try self.smallFileDayGrowthCount?.validate()
                try self.smallFileRatio?.validate()
                try self.tableCount?.validate()
                try self.tinyFileCount?.validate()
                try self.tinyFileCountDayGrowthRatio?.validate()
                try self.tinyFileDayGrowthCount?.validate()
                try self.tinyFileRatio?.validate()
                try self.totalDataDayGrowthSize?.validate()
                try self.totalDataSize?.validate()
                try self.totalDataSizeDayGrowthRatio?.validate()
                try self.totalFileCount?.validate()
                try self.totalFileCountDayGrowthRatio?.validate()
                try self.totalFileDayGrowthCount?.validate()
                try self.warmDataDayGrowthSize?.validate()
                try self.warmDataRatio?.validate()
                try self.warmDataSize?.validate()
                try self.warmDataSizeDayGrowthRatio?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.coldDataDayGrowthSize != nil {
                    map["ColdDataDayGrowthSize"] = self.coldDataDayGrowthSize?.toMap()
                }
                if self.coldDataRatio != nil {
                    map["ColdDataRatio"] = self.coldDataRatio?.toMap()
                }
                if self.coldDataSize != nil {
                    map["ColdDataSize"] = self.coldDataSize?.toMap()
                }
                if self.coldDataSizeDayGrowthRatio != nil {
                    map["ColdDataSizeDayGrowthRatio"] = self.coldDataSizeDayGrowthRatio?.toMap()
                }
                if self.databaseCount != nil {
                    map["DatabaseCount"] = self.databaseCount?.toMap()
                }
                if self.emptyFileCount != nil {
                    map["EmptyFileCount"] = self.emptyFileCount?.toMap()
                }
                if self.emptyFileCountDayGrowthRatio != nil {
                    map["EmptyFileCountDayGrowthRatio"] = self.emptyFileCountDayGrowthRatio?.toMap()
                }
                if self.emptyFileDayGrowthCount != nil {
                    map["EmptyFileDayGrowthCount"] = self.emptyFileDayGrowthCount?.toMap()
                }
                if self.emptyFileRatio != nil {
                    map["EmptyFileRatio"] = self.emptyFileRatio?.toMap()
                }
                if self.freezeDataDayGrowthSize != nil {
                    map["FreezeDataDayGrowthSize"] = self.freezeDataDayGrowthSize?.toMap()
                }
                if self.freezeDataRatio != nil {
                    map["FreezeDataRatio"] = self.freezeDataRatio?.toMap()
                }
                if self.freezeDataSize != nil {
                    map["FreezeDataSize"] = self.freezeDataSize?.toMap()
                }
                if self.freezeDataSizeDayGrowthRatio != nil {
                    map["FreezeDataSizeDayGrowthRatio"] = self.freezeDataSizeDayGrowthRatio?.toMap()
                }
                if self.hotDataDayGrowthSize != nil {
                    map["HotDataDayGrowthSize"] = self.hotDataDayGrowthSize?.toMap()
                }
                if self.hotDataRatio != nil {
                    map["HotDataRatio"] = self.hotDataRatio?.toMap()
                }
                if self.hotDataSize != nil {
                    map["HotDataSize"] = self.hotDataSize?.toMap()
                }
                if self.hotDataSizeDayGrowthRatio != nil {
                    map["HotDataSizeDayGrowthRatio"] = self.hotDataSizeDayGrowthRatio?.toMap()
                }
                if self.largeFileCount != nil {
                    map["LargeFileCount"] = self.largeFileCount?.toMap()
                }
                if self.largeFileCountDayGrowthRatio != nil {
                    map["LargeFileCountDayGrowthRatio"] = self.largeFileCountDayGrowthRatio?.toMap()
                }
                if self.largeFileDayGrowthCount != nil {
                    map["LargeFileDayGrowthCount"] = self.largeFileDayGrowthCount?.toMap()
                }
                if self.largeFileRatio != nil {
                    map["LargeFileRatio"] = self.largeFileRatio?.toMap()
                }
                if self.mediumFileCount != nil {
                    map["MediumFileCount"] = self.mediumFileCount?.toMap()
                }
                if self.mediumFileCountDayGrowthRatio != nil {
                    map["MediumFileCountDayGrowthRatio"] = self.mediumFileCountDayGrowthRatio?.toMap()
                }
                if self.mediumFileDayGrowthCount != nil {
                    map["MediumFileDayGrowthCount"] = self.mediumFileDayGrowthCount?.toMap()
                }
                if self.mediumFileRatio != nil {
                    map["MediumFileRatio"] = self.mediumFileRatio?.toMap()
                }
                if self.partitionNum != nil {
                    map["PartitionNum"] = self.partitionNum?.toMap()
                }
                if self.smallFileCount != nil {
                    map["SmallFileCount"] = self.smallFileCount?.toMap()
                }
                if self.smallFileCountDayGrowthRatio != nil {
                    map["SmallFileCountDayGrowthRatio"] = self.smallFileCountDayGrowthRatio?.toMap()
                }
                if self.smallFileDayGrowthCount != nil {
                    map["SmallFileDayGrowthCount"] = self.smallFileDayGrowthCount?.toMap()
                }
                if self.smallFileRatio != nil {
                    map["SmallFileRatio"] = self.smallFileRatio?.toMap()
                }
                if self.tableCount != nil {
                    map["TableCount"] = self.tableCount?.toMap()
                }
                if self.tinyFileCount != nil {
                    map["TinyFileCount"] = self.tinyFileCount?.toMap()
                }
                if self.tinyFileCountDayGrowthRatio != nil {
                    map["TinyFileCountDayGrowthRatio"] = self.tinyFileCountDayGrowthRatio?.toMap()
                }
                if self.tinyFileDayGrowthCount != nil {
                    map["TinyFileDayGrowthCount"] = self.tinyFileDayGrowthCount?.toMap()
                }
                if self.tinyFileRatio != nil {
                    map["TinyFileRatio"] = self.tinyFileRatio?.toMap()
                }
                if self.totalDataDayGrowthSize != nil {
                    map["TotalDataDayGrowthSize"] = self.totalDataDayGrowthSize?.toMap()
                }
                if self.totalDataSize != nil {
                    map["TotalDataSize"] = self.totalDataSize?.toMap()
                }
                if self.totalDataSizeDayGrowthRatio != nil {
                    map["TotalDataSizeDayGrowthRatio"] = self.totalDataSizeDayGrowthRatio?.toMap()
                }
                if self.totalFileCount != nil {
                    map["TotalFileCount"] = self.totalFileCount?.toMap()
                }
                if self.totalFileCountDayGrowthRatio != nil {
                    map["TotalFileCountDayGrowthRatio"] = self.totalFileCountDayGrowthRatio?.toMap()
                }
                if self.totalFileDayGrowthCount != nil {
                    map["TotalFileDayGrowthCount"] = self.totalFileDayGrowthCount?.toMap()
                }
                if self.warmDataDayGrowthSize != nil {
                    map["WarmDataDayGrowthSize"] = self.warmDataDayGrowthSize?.toMap()
                }
                if self.warmDataRatio != nil {
                    map["WarmDataRatio"] = self.warmDataRatio?.toMap()
                }
                if self.warmDataSize != nil {
                    map["WarmDataSize"] = self.warmDataSize?.toMap()
                }
                if self.warmDataSizeDayGrowthRatio != nil {
                    map["WarmDataSizeDayGrowthRatio"] = self.warmDataSizeDayGrowthRatio?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ColdDataDayGrowthSize") {
                    var model = GetDoctorHiveClusterResponseBody.Data.Metrics.ColdDataDayGrowthSize()
                    model.fromMap(dict["ColdDataDayGrowthSize"] as! [String: Any])
                    self.coldDataDayGrowthSize = model
                }
                if dict.keys.contains("ColdDataRatio") {
                    var model = GetDoctorHiveClusterResponseBody.Data.Metrics.ColdDataRatio()
                    model.fromMap(dict["ColdDataRatio"] as! [String: Any])
                    self.coldDataRatio = model
                }
                if dict.keys.contains("ColdDataSize") {
                    var model = GetDoctorHiveClusterResponseBody.Data.Metrics.ColdDataSize()
                    model.fromMap(dict["ColdDataSize"] as! [String: Any])
                    self.coldDataSize = model
                }
                if dict.keys.contains("ColdDataSizeDayGrowthRatio") {
                    var model = GetDoctorHiveClusterResponseBody.Data.Metrics.ColdDataSizeDayGrowthRatio()
                    model.fromMap(dict["ColdDataSizeDayGrowthRatio"] as! [String: Any])
                    self.coldDataSizeDayGrowthRatio = model
                }
                if dict.keys.contains("DatabaseCount") {
                    var model = GetDoctorHiveClusterResponseBody.Data.Metrics.DatabaseCount()
                    model.fromMap(dict["DatabaseCount"] as! [String: Any])
                    self.databaseCount = model
                }
                if dict.keys.contains("EmptyFileCount") {
                    var model = GetDoctorHiveClusterResponseBody.Data.Metrics.EmptyFileCount()
                    model.fromMap(dict["EmptyFileCount"] as! [String: Any])
                    self.emptyFileCount = model
                }
                if dict.keys.contains("EmptyFileCountDayGrowthRatio") {
                    var model = GetDoctorHiveClusterResponseBody.Data.Metrics.EmptyFileCountDayGrowthRatio()
                    model.fromMap(dict["EmptyFileCountDayGrowthRatio"] as! [String: Any])
                    self.emptyFileCountDayGrowthRatio = model
                }
                if dict.keys.contains("EmptyFileDayGrowthCount") {
                    var model = GetDoctorHiveClusterResponseBody.Data.Metrics.EmptyFileDayGrowthCount()
                    model.fromMap(dict["EmptyFileDayGrowthCount"] as! [String: Any])
                    self.emptyFileDayGrowthCount = model
                }
                if dict.keys.contains("EmptyFileRatio") {
                    var model = GetDoctorHiveClusterResponseBody.Data.Metrics.EmptyFileRatio()
                    model.fromMap(dict["EmptyFileRatio"] as! [String: Any])
                    self.emptyFileRatio = model
                }
                if dict.keys.contains("FreezeDataDayGrowthSize") {
                    var model = GetDoctorHiveClusterResponseBody.Data.Metrics.FreezeDataDayGrowthSize()
                    model.fromMap(dict["FreezeDataDayGrowthSize"] as! [String: Any])
                    self.freezeDataDayGrowthSize = model
                }
                if dict.keys.contains("FreezeDataRatio") {
                    var model = GetDoctorHiveClusterResponseBody.Data.Metrics.FreezeDataRatio()
                    model.fromMap(dict["FreezeDataRatio"] as! [String: Any])
                    self.freezeDataRatio = model
                }
                if dict.keys.contains("FreezeDataSize") {
                    var model = GetDoctorHiveClusterResponseBody.Data.Metrics.FreezeDataSize()
                    model.fromMap(dict["FreezeDataSize"] as! [String: Any])
                    self.freezeDataSize = model
                }
                if dict.keys.contains("FreezeDataSizeDayGrowthRatio") {
                    var model = GetDoctorHiveClusterResponseBody.Data.Metrics.FreezeDataSizeDayGrowthRatio()
                    model.fromMap(dict["FreezeDataSizeDayGrowthRatio"] as! [String: Any])
                    self.freezeDataSizeDayGrowthRatio = model
                }
                if dict.keys.contains("HotDataDayGrowthSize") {
                    var model = GetDoctorHiveClusterResponseBody.Data.Metrics.HotDataDayGrowthSize()
                    model.fromMap(dict["HotDataDayGrowthSize"] as! [String: Any])
                    self.hotDataDayGrowthSize = model
                }
                if dict.keys.contains("HotDataRatio") {
                    var model = GetDoctorHiveClusterResponseBody.Data.Metrics.HotDataRatio()
                    model.fromMap(dict["HotDataRatio"] as! [String: Any])
                    self.hotDataRatio = model
                }
                if dict.keys.contains("HotDataSize") {
                    var model = GetDoctorHiveClusterResponseBody.Data.Metrics.HotDataSize()
                    model.fromMap(dict["HotDataSize"] as! [String: Any])
                    self.hotDataSize = model
                }
                if dict.keys.contains("HotDataSizeDayGrowthRatio") {
                    var model = GetDoctorHiveClusterResponseBody.Data.Metrics.HotDataSizeDayGrowthRatio()
                    model.fromMap(dict["HotDataSizeDayGrowthRatio"] as! [String: Any])
                    self.hotDataSizeDayGrowthRatio = model
                }
                if dict.keys.contains("LargeFileCount") {
                    var model = GetDoctorHiveClusterResponseBody.Data.Metrics.LargeFileCount()
                    model.fromMap(dict["LargeFileCount"] as! [String: Any])
                    self.largeFileCount = model
                }
                if dict.keys.contains("LargeFileCountDayGrowthRatio") {
                    var model = GetDoctorHiveClusterResponseBody.Data.Metrics.LargeFileCountDayGrowthRatio()
                    model.fromMap(dict["LargeFileCountDayGrowthRatio"] as! [String: Any])
                    self.largeFileCountDayGrowthRatio = model
                }
                if dict.keys.contains("LargeFileDayGrowthCount") {
                    var model = GetDoctorHiveClusterResponseBody.Data.Metrics.LargeFileDayGrowthCount()
                    model.fromMap(dict["LargeFileDayGrowthCount"] as! [String: Any])
                    self.largeFileDayGrowthCount = model
                }
                if dict.keys.contains("LargeFileRatio") {
                    var model = GetDoctorHiveClusterResponseBody.Data.Metrics.LargeFileRatio()
                    model.fromMap(dict["LargeFileRatio"] as! [String: Any])
                    self.largeFileRatio = model
                }
                if dict.keys.contains("MediumFileCount") {
                    var model = GetDoctorHiveClusterResponseBody.Data.Metrics.MediumFileCount()
                    model.fromMap(dict["MediumFileCount"] as! [String: Any])
                    self.mediumFileCount = model
                }
                if dict.keys.contains("MediumFileCountDayGrowthRatio") {
                    var model = GetDoctorHiveClusterResponseBody.Data.Metrics.MediumFileCountDayGrowthRatio()
                    model.fromMap(dict["MediumFileCountDayGrowthRatio"] as! [String: Any])
                    self.mediumFileCountDayGrowthRatio = model
                }
                if dict.keys.contains("MediumFileDayGrowthCount") {
                    var model = GetDoctorHiveClusterResponseBody.Data.Metrics.MediumFileDayGrowthCount()
                    model.fromMap(dict["MediumFileDayGrowthCount"] as! [String: Any])
                    self.mediumFileDayGrowthCount = model
                }
                if dict.keys.contains("MediumFileRatio") {
                    var model = GetDoctorHiveClusterResponseBody.Data.Metrics.MediumFileRatio()
                    model.fromMap(dict["MediumFileRatio"] as! [String: Any])
                    self.mediumFileRatio = model
                }
                if dict.keys.contains("PartitionNum") {
                    var model = GetDoctorHiveClusterResponseBody.Data.Metrics.PartitionNum()
                    model.fromMap(dict["PartitionNum"] as! [String: Any])
                    self.partitionNum = model
                }
                if dict.keys.contains("SmallFileCount") {
                    var model = GetDoctorHiveClusterResponseBody.Data.Metrics.SmallFileCount()
                    model.fromMap(dict["SmallFileCount"] as! [String: Any])
                    self.smallFileCount = model
                }
                if dict.keys.contains("SmallFileCountDayGrowthRatio") {
                    var model = GetDoctorHiveClusterResponseBody.Data.Metrics.SmallFileCountDayGrowthRatio()
                    model.fromMap(dict["SmallFileCountDayGrowthRatio"] as! [String: Any])
                    self.smallFileCountDayGrowthRatio = model
                }
                if dict.keys.contains("SmallFileDayGrowthCount") {
                    var model = GetDoctorHiveClusterResponseBody.Data.Metrics.SmallFileDayGrowthCount()
                    model.fromMap(dict["SmallFileDayGrowthCount"] as! [String: Any])
                    self.smallFileDayGrowthCount = model
                }
                if dict.keys.contains("SmallFileRatio") {
                    var model = GetDoctorHiveClusterResponseBody.Data.Metrics.SmallFileRatio()
                    model.fromMap(dict["SmallFileRatio"] as! [String: Any])
                    self.smallFileRatio = model
                }
                if dict.keys.contains("TableCount") {
                    var model = GetDoctorHiveClusterResponseBody.Data.Metrics.TableCount()
                    model.fromMap(dict["TableCount"] as! [String: Any])
                    self.tableCount = model
                }
                if dict.keys.contains("TinyFileCount") {
                    var model = GetDoctorHiveClusterResponseBody.Data.Metrics.TinyFileCount()
                    model.fromMap(dict["TinyFileCount"] as! [String: Any])
                    self.tinyFileCount = model
                }
                if dict.keys.contains("TinyFileCountDayGrowthRatio") {
                    var model = GetDoctorHiveClusterResponseBody.Data.Metrics.TinyFileCountDayGrowthRatio()
                    model.fromMap(dict["TinyFileCountDayGrowthRatio"] as! [String: Any])
                    self.tinyFileCountDayGrowthRatio = model
                }
                if dict.keys.contains("TinyFileDayGrowthCount") {
                    var model = GetDoctorHiveClusterResponseBody.Data.Metrics.TinyFileDayGrowthCount()
                    model.fromMap(dict["TinyFileDayGrowthCount"] as! [String: Any])
                    self.tinyFileDayGrowthCount = model
                }
                if dict.keys.contains("TinyFileRatio") {
                    var model = GetDoctorHiveClusterResponseBody.Data.Metrics.TinyFileRatio()
                    model.fromMap(dict["TinyFileRatio"] as! [String: Any])
                    self.tinyFileRatio = model
                }
                if dict.keys.contains("TotalDataDayGrowthSize") {
                    var model = GetDoctorHiveClusterResponseBody.Data.Metrics.TotalDataDayGrowthSize()
                    model.fromMap(dict["TotalDataDayGrowthSize"] as! [String: Any])
                    self.totalDataDayGrowthSize = model
                }
                if dict.keys.contains("TotalDataSize") {
                    var model = GetDoctorHiveClusterResponseBody.Data.Metrics.TotalDataSize()
                    model.fromMap(dict["TotalDataSize"] as! [String: Any])
                    self.totalDataSize = model
                }
                if dict.keys.contains("TotalDataSizeDayGrowthRatio") {
                    var model = GetDoctorHiveClusterResponseBody.Data.Metrics.TotalDataSizeDayGrowthRatio()
                    model.fromMap(dict["TotalDataSizeDayGrowthRatio"] as! [String: Any])
                    self.totalDataSizeDayGrowthRatio = model
                }
                if dict.keys.contains("TotalFileCount") {
                    var model = GetDoctorHiveClusterResponseBody.Data.Metrics.TotalFileCount()
                    model.fromMap(dict["TotalFileCount"] as! [String: Any])
                    self.totalFileCount = model
                }
                if dict.keys.contains("TotalFileCountDayGrowthRatio") {
                    var model = GetDoctorHiveClusterResponseBody.Data.Metrics.TotalFileCountDayGrowthRatio()
                    model.fromMap(dict["TotalFileCountDayGrowthRatio"] as! [String: Any])
                    self.totalFileCountDayGrowthRatio = model
                }
                if dict.keys.contains("TotalFileDayGrowthCount") {
                    var model = GetDoctorHiveClusterResponseBody.Data.Metrics.TotalFileDayGrowthCount()
                    model.fromMap(dict["TotalFileDayGrowthCount"] as! [String: Any])
                    self.totalFileDayGrowthCount = model
                }
                if dict.keys.contains("WarmDataDayGrowthSize") {
                    var model = GetDoctorHiveClusterResponseBody.Data.Metrics.WarmDataDayGrowthSize()
                    model.fromMap(dict["WarmDataDayGrowthSize"] as! [String: Any])
                    self.warmDataDayGrowthSize = model
                }
                if dict.keys.contains("WarmDataRatio") {
                    var model = GetDoctorHiveClusterResponseBody.Data.Metrics.WarmDataRatio()
                    model.fromMap(dict["WarmDataRatio"] as! [String: Any])
                    self.warmDataRatio = model
                }
                if dict.keys.contains("WarmDataSize") {
                    var model = GetDoctorHiveClusterResponseBody.Data.Metrics.WarmDataSize()
                    model.fromMap(dict["WarmDataSize"] as! [String: Any])
                    self.warmDataSize = model
                }
                if dict.keys.contains("WarmDataSizeDayGrowthRatio") {
                    var model = GetDoctorHiveClusterResponseBody.Data.Metrics.WarmDataSizeDayGrowthRatio()
                    model.fromMap(dict["WarmDataSizeDayGrowthRatio"] as! [String: Any])
                    self.warmDataSizeDayGrowthRatio = model
                }
            }
        }
        public var analysis: GetDoctorHiveClusterResponseBody.Data.Analysis?

        public var formats: [GetDoctorHiveClusterResponseBody.Data.Formats]?

        public var metrics: GetDoctorHiveClusterResponseBody.Data.Metrics?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.analysis?.validate()
            try self.metrics?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.analysis != nil {
                map["Analysis"] = self.analysis?.toMap()
            }
            if self.formats != nil {
                var tmp : [Any] = []
                for k in self.formats! {
                    tmp.append(k.toMap())
                }
                map["Formats"] = tmp
            }
            if self.metrics != nil {
                map["Metrics"] = self.metrics?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Analysis") {
                var model = GetDoctorHiveClusterResponseBody.Data.Analysis()
                model.fromMap(dict["Analysis"] as! [String: Any])
                self.analysis = model
            }
            if dict.keys.contains("Formats") {
                var tmp : [GetDoctorHiveClusterResponseBody.Data.Formats] = []
                for v in dict["Formats"] as! [Any] {
                    var model = GetDoctorHiveClusterResponseBody.Data.Formats()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.formats = tmp
            }
            if dict.keys.contains("Metrics") {
                var model = GetDoctorHiveClusterResponseBody.Data.Metrics()
                model.fromMap(dict["Metrics"] as! [String: Any])
                self.metrics = model
            }
        }
    }
    public var data: GetDoctorHiveClusterResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = GetDoctorHiveClusterResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetDoctorHiveClusterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDoctorHiveClusterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDoctorHiveClusterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDoctorHiveDatabaseRequest : Tea.TeaModel {
    public var clusterId: String?

    public var databaseName: String?

    public var dateTime: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.databaseName != nil {
            map["DatabaseName"] = self.databaseName!
        }
        if self.dateTime != nil {
            map["DateTime"] = self.dateTime!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("DatabaseName") {
            self.databaseName = dict["DatabaseName"] as! String
        }
        if dict.keys.contains("DateTime") {
            self.dateTime = dict["DateTime"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class GetDoctorHiveDatabaseResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Analysis : Tea.TeaModel {
            public var hiveDistributionScore: Int32?

            public var hiveFormatScore: Int32?

            public var hiveFrequencyScore: Int32?

            public var hiveScore: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.hiveDistributionScore != nil {
                    map["HiveDistributionScore"] = self.hiveDistributionScore!
                }
                if self.hiveFormatScore != nil {
                    map["HiveFormatScore"] = self.hiveFormatScore!
                }
                if self.hiveFrequencyScore != nil {
                    map["HiveFrequencyScore"] = self.hiveFrequencyScore!
                }
                if self.hiveScore != nil {
                    map["HiveScore"] = self.hiveScore!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("HiveDistributionScore") {
                    self.hiveDistributionScore = dict["HiveDistributionScore"] as! Int32
                }
                if dict.keys.contains("HiveFormatScore") {
                    self.hiveFormatScore = dict["HiveFormatScore"] as! Int32
                }
                if dict.keys.contains("HiveFrequencyScore") {
                    self.hiveFrequencyScore = dict["HiveFrequencyScore"] as! Int32
                }
                if dict.keys.contains("HiveScore") {
                    self.hiveScore = dict["HiveScore"] as! Int32
                }
            }
        }
        public class Formats : Tea.TeaModel {
            public var formatDayGrowthSize: Int64?

            public var formatName: String?

            public var formatRatio: Double?

            public var formatSize: Int64?

            public var formatSizeDayGrowthRatio: Double?

            public var formatSizeUnit: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.formatDayGrowthSize != nil {
                    map["FormatDayGrowthSize"] = self.formatDayGrowthSize!
                }
                if self.formatName != nil {
                    map["FormatName"] = self.formatName!
                }
                if self.formatRatio != nil {
                    map["FormatRatio"] = self.formatRatio!
                }
                if self.formatSize != nil {
                    map["FormatSize"] = self.formatSize!
                }
                if self.formatSizeDayGrowthRatio != nil {
                    map["FormatSizeDayGrowthRatio"] = self.formatSizeDayGrowthRatio!
                }
                if self.formatSizeUnit != nil {
                    map["FormatSizeUnit"] = self.formatSizeUnit!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FormatDayGrowthSize") {
                    self.formatDayGrowthSize = dict["FormatDayGrowthSize"] as! Int64
                }
                if dict.keys.contains("FormatName") {
                    self.formatName = dict["FormatName"] as! String
                }
                if dict.keys.contains("FormatRatio") {
                    self.formatRatio = dict["FormatRatio"] as! Double
                }
                if dict.keys.contains("FormatSize") {
                    self.formatSize = dict["FormatSize"] as! Int64
                }
                if dict.keys.contains("FormatSizeDayGrowthRatio") {
                    self.formatSizeDayGrowthRatio = dict["FormatSizeDayGrowthRatio"] as! Double
                }
                if dict.keys.contains("FormatSizeUnit") {
                    self.formatSizeUnit = dict["FormatSizeUnit"] as! String
                }
            }
        }
        public class Metrics : Tea.TeaModel {
            public class ColdDataDayGrowthSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class ColdDataRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class ColdDataSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class ColdDataSizeDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class EmptyFileCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class EmptyFileCountDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class EmptyFileDayGrowthCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class EmptyFileRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class FreezeDataDayGrowthSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class FreezeDataRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class FreezeDataSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class FreezeDataSizeDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class HotDataDayGrowthSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class HotDataRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class HotDataSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class HotDataSizeDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class LargeFileCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class LargeFileCountDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class LargeFileDayGrowthCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class LargeFileRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class MediumFileCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class MediumFileCountDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class MediumFileDayGrowthCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class MediumFileRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class PartitionNum : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class SmallFileCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class SmallFileCountDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class SmallFileDayGrowthCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class SmallFileRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class TableCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class TinyFileCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class TinyFileCountDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class TinyFileDayGrowthCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class TinyFileRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class TotalDataDayGrowthSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class TotalDataSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class TotalDataSizeDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class TotalFileCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class TotalFileCountDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class TotalFileDayGrowthCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class WarmDataDayGrowthSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class WarmDataRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class WarmDataSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class WarmDataSizeDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public var coldDataDayGrowthSize: GetDoctorHiveDatabaseResponseBody.Data.Metrics.ColdDataDayGrowthSize?

            public var coldDataRatio: GetDoctorHiveDatabaseResponseBody.Data.Metrics.ColdDataRatio?

            public var coldDataSize: GetDoctorHiveDatabaseResponseBody.Data.Metrics.ColdDataSize?

            public var coldDataSizeDayGrowthRatio: GetDoctorHiveDatabaseResponseBody.Data.Metrics.ColdDataSizeDayGrowthRatio?

            public var emptyFileCount: GetDoctorHiveDatabaseResponseBody.Data.Metrics.EmptyFileCount?

            public var emptyFileCountDayGrowthRatio: GetDoctorHiveDatabaseResponseBody.Data.Metrics.EmptyFileCountDayGrowthRatio?

            public var emptyFileDayGrowthCount: GetDoctorHiveDatabaseResponseBody.Data.Metrics.EmptyFileDayGrowthCount?

            public var emptyFileRatio: GetDoctorHiveDatabaseResponseBody.Data.Metrics.EmptyFileRatio?

            public var freezeDataDayGrowthSize: GetDoctorHiveDatabaseResponseBody.Data.Metrics.FreezeDataDayGrowthSize?

            public var freezeDataRatio: GetDoctorHiveDatabaseResponseBody.Data.Metrics.FreezeDataRatio?

            public var freezeDataSize: GetDoctorHiveDatabaseResponseBody.Data.Metrics.FreezeDataSize?

            public var freezeDataSizeDayGrowthRatio: GetDoctorHiveDatabaseResponseBody.Data.Metrics.FreezeDataSizeDayGrowthRatio?

            public var hotDataDayGrowthSize: GetDoctorHiveDatabaseResponseBody.Data.Metrics.HotDataDayGrowthSize?

            public var hotDataRatio: GetDoctorHiveDatabaseResponseBody.Data.Metrics.HotDataRatio?

            public var hotDataSize: GetDoctorHiveDatabaseResponseBody.Data.Metrics.HotDataSize?

            public var hotDataSizeDayGrowthRatio: GetDoctorHiveDatabaseResponseBody.Data.Metrics.HotDataSizeDayGrowthRatio?

            public var largeFileCount: GetDoctorHiveDatabaseResponseBody.Data.Metrics.LargeFileCount?

            public var largeFileCountDayGrowthRatio: GetDoctorHiveDatabaseResponseBody.Data.Metrics.LargeFileCountDayGrowthRatio?

            public var largeFileDayGrowthCount: GetDoctorHiveDatabaseResponseBody.Data.Metrics.LargeFileDayGrowthCount?

            public var largeFileRatio: GetDoctorHiveDatabaseResponseBody.Data.Metrics.LargeFileRatio?

            public var mediumFileCount: GetDoctorHiveDatabaseResponseBody.Data.Metrics.MediumFileCount?

            public var mediumFileCountDayGrowthRatio: GetDoctorHiveDatabaseResponseBody.Data.Metrics.MediumFileCountDayGrowthRatio?

            public var mediumFileDayGrowthCount: GetDoctorHiveDatabaseResponseBody.Data.Metrics.MediumFileDayGrowthCount?

            public var mediumFileRatio: GetDoctorHiveDatabaseResponseBody.Data.Metrics.MediumFileRatio?

            public var partitionNum: GetDoctorHiveDatabaseResponseBody.Data.Metrics.PartitionNum?

            public var smallFileCount: GetDoctorHiveDatabaseResponseBody.Data.Metrics.SmallFileCount?

            public var smallFileCountDayGrowthRatio: GetDoctorHiveDatabaseResponseBody.Data.Metrics.SmallFileCountDayGrowthRatio?

            public var smallFileDayGrowthCount: GetDoctorHiveDatabaseResponseBody.Data.Metrics.SmallFileDayGrowthCount?

            public var smallFileRatio: GetDoctorHiveDatabaseResponseBody.Data.Metrics.SmallFileRatio?

            public var tableCount: GetDoctorHiveDatabaseResponseBody.Data.Metrics.TableCount?

            public var tinyFileCount: GetDoctorHiveDatabaseResponseBody.Data.Metrics.TinyFileCount?

            public var tinyFileCountDayGrowthRatio: GetDoctorHiveDatabaseResponseBody.Data.Metrics.TinyFileCountDayGrowthRatio?

            public var tinyFileDayGrowthCount: GetDoctorHiveDatabaseResponseBody.Data.Metrics.TinyFileDayGrowthCount?

            public var tinyFileRatio: GetDoctorHiveDatabaseResponseBody.Data.Metrics.TinyFileRatio?

            public var totalDataDayGrowthSize: GetDoctorHiveDatabaseResponseBody.Data.Metrics.TotalDataDayGrowthSize?

            public var totalDataSize: GetDoctorHiveDatabaseResponseBody.Data.Metrics.TotalDataSize?

            public var totalDataSizeDayGrowthRatio: GetDoctorHiveDatabaseResponseBody.Data.Metrics.TotalDataSizeDayGrowthRatio?

            public var totalFileCount: GetDoctorHiveDatabaseResponseBody.Data.Metrics.TotalFileCount?

            public var totalFileCountDayGrowthRatio: GetDoctorHiveDatabaseResponseBody.Data.Metrics.TotalFileCountDayGrowthRatio?

            public var totalFileDayGrowthCount: GetDoctorHiveDatabaseResponseBody.Data.Metrics.TotalFileDayGrowthCount?

            public var warmDataDayGrowthSize: GetDoctorHiveDatabaseResponseBody.Data.Metrics.WarmDataDayGrowthSize?

            public var warmDataRatio: GetDoctorHiveDatabaseResponseBody.Data.Metrics.WarmDataRatio?

            public var warmDataSize: GetDoctorHiveDatabaseResponseBody.Data.Metrics.WarmDataSize?

            public var warmDataSizeDayGrowthRatio: GetDoctorHiveDatabaseResponseBody.Data.Metrics.WarmDataSizeDayGrowthRatio?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.coldDataDayGrowthSize?.validate()
                try self.coldDataRatio?.validate()
                try self.coldDataSize?.validate()
                try self.coldDataSizeDayGrowthRatio?.validate()
                try self.emptyFileCount?.validate()
                try self.emptyFileCountDayGrowthRatio?.validate()
                try self.emptyFileDayGrowthCount?.validate()
                try self.emptyFileRatio?.validate()
                try self.freezeDataDayGrowthSize?.validate()
                try self.freezeDataRatio?.validate()
                try self.freezeDataSize?.validate()
                try self.freezeDataSizeDayGrowthRatio?.validate()
                try self.hotDataDayGrowthSize?.validate()
                try self.hotDataRatio?.validate()
                try self.hotDataSize?.validate()
                try self.hotDataSizeDayGrowthRatio?.validate()
                try self.largeFileCount?.validate()
                try self.largeFileCountDayGrowthRatio?.validate()
                try self.largeFileDayGrowthCount?.validate()
                try self.largeFileRatio?.validate()
                try self.mediumFileCount?.validate()
                try self.mediumFileCountDayGrowthRatio?.validate()
                try self.mediumFileDayGrowthCount?.validate()
                try self.mediumFileRatio?.validate()
                try self.partitionNum?.validate()
                try self.smallFileCount?.validate()
                try self.smallFileCountDayGrowthRatio?.validate()
                try self.smallFileDayGrowthCount?.validate()
                try self.smallFileRatio?.validate()
                try self.tableCount?.validate()
                try self.tinyFileCount?.validate()
                try self.tinyFileCountDayGrowthRatio?.validate()
                try self.tinyFileDayGrowthCount?.validate()
                try self.tinyFileRatio?.validate()
                try self.totalDataDayGrowthSize?.validate()
                try self.totalDataSize?.validate()
                try self.totalDataSizeDayGrowthRatio?.validate()
                try self.totalFileCount?.validate()
                try self.totalFileCountDayGrowthRatio?.validate()
                try self.totalFileDayGrowthCount?.validate()
                try self.warmDataDayGrowthSize?.validate()
                try self.warmDataRatio?.validate()
                try self.warmDataSize?.validate()
                try self.warmDataSizeDayGrowthRatio?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.coldDataDayGrowthSize != nil {
                    map["ColdDataDayGrowthSize"] = self.coldDataDayGrowthSize?.toMap()
                }
                if self.coldDataRatio != nil {
                    map["ColdDataRatio"] = self.coldDataRatio?.toMap()
                }
                if self.coldDataSize != nil {
                    map["ColdDataSize"] = self.coldDataSize?.toMap()
                }
                if self.coldDataSizeDayGrowthRatio != nil {
                    map["ColdDataSizeDayGrowthRatio"] = self.coldDataSizeDayGrowthRatio?.toMap()
                }
                if self.emptyFileCount != nil {
                    map["EmptyFileCount"] = self.emptyFileCount?.toMap()
                }
                if self.emptyFileCountDayGrowthRatio != nil {
                    map["EmptyFileCountDayGrowthRatio"] = self.emptyFileCountDayGrowthRatio?.toMap()
                }
                if self.emptyFileDayGrowthCount != nil {
                    map["EmptyFileDayGrowthCount"] = self.emptyFileDayGrowthCount?.toMap()
                }
                if self.emptyFileRatio != nil {
                    map["EmptyFileRatio"] = self.emptyFileRatio?.toMap()
                }
                if self.freezeDataDayGrowthSize != nil {
                    map["FreezeDataDayGrowthSize"] = self.freezeDataDayGrowthSize?.toMap()
                }
                if self.freezeDataRatio != nil {
                    map["FreezeDataRatio"] = self.freezeDataRatio?.toMap()
                }
                if self.freezeDataSize != nil {
                    map["FreezeDataSize"] = self.freezeDataSize?.toMap()
                }
                if self.freezeDataSizeDayGrowthRatio != nil {
                    map["FreezeDataSizeDayGrowthRatio"] = self.freezeDataSizeDayGrowthRatio?.toMap()
                }
                if self.hotDataDayGrowthSize != nil {
                    map["HotDataDayGrowthSize"] = self.hotDataDayGrowthSize?.toMap()
                }
                if self.hotDataRatio != nil {
                    map["HotDataRatio"] = self.hotDataRatio?.toMap()
                }
                if self.hotDataSize != nil {
                    map["HotDataSize"] = self.hotDataSize?.toMap()
                }
                if self.hotDataSizeDayGrowthRatio != nil {
                    map["HotDataSizeDayGrowthRatio"] = self.hotDataSizeDayGrowthRatio?.toMap()
                }
                if self.largeFileCount != nil {
                    map["LargeFileCount"] = self.largeFileCount?.toMap()
                }
                if self.largeFileCountDayGrowthRatio != nil {
                    map["LargeFileCountDayGrowthRatio"] = self.largeFileCountDayGrowthRatio?.toMap()
                }
                if self.largeFileDayGrowthCount != nil {
                    map["LargeFileDayGrowthCount"] = self.largeFileDayGrowthCount?.toMap()
                }
                if self.largeFileRatio != nil {
                    map["LargeFileRatio"] = self.largeFileRatio?.toMap()
                }
                if self.mediumFileCount != nil {
                    map["MediumFileCount"] = self.mediumFileCount?.toMap()
                }
                if self.mediumFileCountDayGrowthRatio != nil {
                    map["MediumFileCountDayGrowthRatio"] = self.mediumFileCountDayGrowthRatio?.toMap()
                }
                if self.mediumFileDayGrowthCount != nil {
                    map["MediumFileDayGrowthCount"] = self.mediumFileDayGrowthCount?.toMap()
                }
                if self.mediumFileRatio != nil {
                    map["MediumFileRatio"] = self.mediumFileRatio?.toMap()
                }
                if self.partitionNum != nil {
                    map["PartitionNum"] = self.partitionNum?.toMap()
                }
                if self.smallFileCount != nil {
                    map["SmallFileCount"] = self.smallFileCount?.toMap()
                }
                if self.smallFileCountDayGrowthRatio != nil {
                    map["SmallFileCountDayGrowthRatio"] = self.smallFileCountDayGrowthRatio?.toMap()
                }
                if self.smallFileDayGrowthCount != nil {
                    map["SmallFileDayGrowthCount"] = self.smallFileDayGrowthCount?.toMap()
                }
                if self.smallFileRatio != nil {
                    map["SmallFileRatio"] = self.smallFileRatio?.toMap()
                }
                if self.tableCount != nil {
                    map["TableCount"] = self.tableCount?.toMap()
                }
                if self.tinyFileCount != nil {
                    map["TinyFileCount"] = self.tinyFileCount?.toMap()
                }
                if self.tinyFileCountDayGrowthRatio != nil {
                    map["TinyFileCountDayGrowthRatio"] = self.tinyFileCountDayGrowthRatio?.toMap()
                }
                if self.tinyFileDayGrowthCount != nil {
                    map["TinyFileDayGrowthCount"] = self.tinyFileDayGrowthCount?.toMap()
                }
                if self.tinyFileRatio != nil {
                    map["TinyFileRatio"] = self.tinyFileRatio?.toMap()
                }
                if self.totalDataDayGrowthSize != nil {
                    map["TotalDataDayGrowthSize"] = self.totalDataDayGrowthSize?.toMap()
                }
                if self.totalDataSize != nil {
                    map["TotalDataSize"] = self.totalDataSize?.toMap()
                }
                if self.totalDataSizeDayGrowthRatio != nil {
                    map["TotalDataSizeDayGrowthRatio"] = self.totalDataSizeDayGrowthRatio?.toMap()
                }
                if self.totalFileCount != nil {
                    map["TotalFileCount"] = self.totalFileCount?.toMap()
                }
                if self.totalFileCountDayGrowthRatio != nil {
                    map["TotalFileCountDayGrowthRatio"] = self.totalFileCountDayGrowthRatio?.toMap()
                }
                if self.totalFileDayGrowthCount != nil {
                    map["TotalFileDayGrowthCount"] = self.totalFileDayGrowthCount?.toMap()
                }
                if self.warmDataDayGrowthSize != nil {
                    map["WarmDataDayGrowthSize"] = self.warmDataDayGrowthSize?.toMap()
                }
                if self.warmDataRatio != nil {
                    map["WarmDataRatio"] = self.warmDataRatio?.toMap()
                }
                if self.warmDataSize != nil {
                    map["WarmDataSize"] = self.warmDataSize?.toMap()
                }
                if self.warmDataSizeDayGrowthRatio != nil {
                    map["WarmDataSizeDayGrowthRatio"] = self.warmDataSizeDayGrowthRatio?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ColdDataDayGrowthSize") {
                    var model = GetDoctorHiveDatabaseResponseBody.Data.Metrics.ColdDataDayGrowthSize()
                    model.fromMap(dict["ColdDataDayGrowthSize"] as! [String: Any])
                    self.coldDataDayGrowthSize = model
                }
                if dict.keys.contains("ColdDataRatio") {
                    var model = GetDoctorHiveDatabaseResponseBody.Data.Metrics.ColdDataRatio()
                    model.fromMap(dict["ColdDataRatio"] as! [String: Any])
                    self.coldDataRatio = model
                }
                if dict.keys.contains("ColdDataSize") {
                    var model = GetDoctorHiveDatabaseResponseBody.Data.Metrics.ColdDataSize()
                    model.fromMap(dict["ColdDataSize"] as! [String: Any])
                    self.coldDataSize = model
                }
                if dict.keys.contains("ColdDataSizeDayGrowthRatio") {
                    var model = GetDoctorHiveDatabaseResponseBody.Data.Metrics.ColdDataSizeDayGrowthRatio()
                    model.fromMap(dict["ColdDataSizeDayGrowthRatio"] as! [String: Any])
                    self.coldDataSizeDayGrowthRatio = model
                }
                if dict.keys.contains("EmptyFileCount") {
                    var model = GetDoctorHiveDatabaseResponseBody.Data.Metrics.EmptyFileCount()
                    model.fromMap(dict["EmptyFileCount"] as! [String: Any])
                    self.emptyFileCount = model
                }
                if dict.keys.contains("EmptyFileCountDayGrowthRatio") {
                    var model = GetDoctorHiveDatabaseResponseBody.Data.Metrics.EmptyFileCountDayGrowthRatio()
                    model.fromMap(dict["EmptyFileCountDayGrowthRatio"] as! [String: Any])
                    self.emptyFileCountDayGrowthRatio = model
                }
                if dict.keys.contains("EmptyFileDayGrowthCount") {
                    var model = GetDoctorHiveDatabaseResponseBody.Data.Metrics.EmptyFileDayGrowthCount()
                    model.fromMap(dict["EmptyFileDayGrowthCount"] as! [String: Any])
                    self.emptyFileDayGrowthCount = model
                }
                if dict.keys.contains("EmptyFileRatio") {
                    var model = GetDoctorHiveDatabaseResponseBody.Data.Metrics.EmptyFileRatio()
                    model.fromMap(dict["EmptyFileRatio"] as! [String: Any])
                    self.emptyFileRatio = model
                }
                if dict.keys.contains("FreezeDataDayGrowthSize") {
                    var model = GetDoctorHiveDatabaseResponseBody.Data.Metrics.FreezeDataDayGrowthSize()
                    model.fromMap(dict["FreezeDataDayGrowthSize"] as! [String: Any])
                    self.freezeDataDayGrowthSize = model
                }
                if dict.keys.contains("FreezeDataRatio") {
                    var model = GetDoctorHiveDatabaseResponseBody.Data.Metrics.FreezeDataRatio()
                    model.fromMap(dict["FreezeDataRatio"] as! [String: Any])
                    self.freezeDataRatio = model
                }
                if dict.keys.contains("FreezeDataSize") {
                    var model = GetDoctorHiveDatabaseResponseBody.Data.Metrics.FreezeDataSize()
                    model.fromMap(dict["FreezeDataSize"] as! [String: Any])
                    self.freezeDataSize = model
                }
                if dict.keys.contains("FreezeDataSizeDayGrowthRatio") {
                    var model = GetDoctorHiveDatabaseResponseBody.Data.Metrics.FreezeDataSizeDayGrowthRatio()
                    model.fromMap(dict["FreezeDataSizeDayGrowthRatio"] as! [String: Any])
                    self.freezeDataSizeDayGrowthRatio = model
                }
                if dict.keys.contains("HotDataDayGrowthSize") {
                    var model = GetDoctorHiveDatabaseResponseBody.Data.Metrics.HotDataDayGrowthSize()
                    model.fromMap(dict["HotDataDayGrowthSize"] as! [String: Any])
                    self.hotDataDayGrowthSize = model
                }
                if dict.keys.contains("HotDataRatio") {
                    var model = GetDoctorHiveDatabaseResponseBody.Data.Metrics.HotDataRatio()
                    model.fromMap(dict["HotDataRatio"] as! [String: Any])
                    self.hotDataRatio = model
                }
                if dict.keys.contains("HotDataSize") {
                    var model = GetDoctorHiveDatabaseResponseBody.Data.Metrics.HotDataSize()
                    model.fromMap(dict["HotDataSize"] as! [String: Any])
                    self.hotDataSize = model
                }
                if dict.keys.contains("HotDataSizeDayGrowthRatio") {
                    var model = GetDoctorHiveDatabaseResponseBody.Data.Metrics.HotDataSizeDayGrowthRatio()
                    model.fromMap(dict["HotDataSizeDayGrowthRatio"] as! [String: Any])
                    self.hotDataSizeDayGrowthRatio = model
                }
                if dict.keys.contains("LargeFileCount") {
                    var model = GetDoctorHiveDatabaseResponseBody.Data.Metrics.LargeFileCount()
                    model.fromMap(dict["LargeFileCount"] as! [String: Any])
                    self.largeFileCount = model
                }
                if dict.keys.contains("LargeFileCountDayGrowthRatio") {
                    var model = GetDoctorHiveDatabaseResponseBody.Data.Metrics.LargeFileCountDayGrowthRatio()
                    model.fromMap(dict["LargeFileCountDayGrowthRatio"] as! [String: Any])
                    self.largeFileCountDayGrowthRatio = model
                }
                if dict.keys.contains("LargeFileDayGrowthCount") {
                    var model = GetDoctorHiveDatabaseResponseBody.Data.Metrics.LargeFileDayGrowthCount()
                    model.fromMap(dict["LargeFileDayGrowthCount"] as! [String: Any])
                    self.largeFileDayGrowthCount = model
                }
                if dict.keys.contains("LargeFileRatio") {
                    var model = GetDoctorHiveDatabaseResponseBody.Data.Metrics.LargeFileRatio()
                    model.fromMap(dict["LargeFileRatio"] as! [String: Any])
                    self.largeFileRatio = model
                }
                if dict.keys.contains("MediumFileCount") {
                    var model = GetDoctorHiveDatabaseResponseBody.Data.Metrics.MediumFileCount()
                    model.fromMap(dict["MediumFileCount"] as! [String: Any])
                    self.mediumFileCount = model
                }
                if dict.keys.contains("MediumFileCountDayGrowthRatio") {
                    var model = GetDoctorHiveDatabaseResponseBody.Data.Metrics.MediumFileCountDayGrowthRatio()
                    model.fromMap(dict["MediumFileCountDayGrowthRatio"] as! [String: Any])
                    self.mediumFileCountDayGrowthRatio = model
                }
                if dict.keys.contains("MediumFileDayGrowthCount") {
                    var model = GetDoctorHiveDatabaseResponseBody.Data.Metrics.MediumFileDayGrowthCount()
                    model.fromMap(dict["MediumFileDayGrowthCount"] as! [String: Any])
                    self.mediumFileDayGrowthCount = model
                }
                if dict.keys.contains("MediumFileRatio") {
                    var model = GetDoctorHiveDatabaseResponseBody.Data.Metrics.MediumFileRatio()
                    model.fromMap(dict["MediumFileRatio"] as! [String: Any])
                    self.mediumFileRatio = model
                }
                if dict.keys.contains("PartitionNum") {
                    var model = GetDoctorHiveDatabaseResponseBody.Data.Metrics.PartitionNum()
                    model.fromMap(dict["PartitionNum"] as! [String: Any])
                    self.partitionNum = model
                }
                if dict.keys.contains("SmallFileCount") {
                    var model = GetDoctorHiveDatabaseResponseBody.Data.Metrics.SmallFileCount()
                    model.fromMap(dict["SmallFileCount"] as! [String: Any])
                    self.smallFileCount = model
                }
                if dict.keys.contains("SmallFileCountDayGrowthRatio") {
                    var model = GetDoctorHiveDatabaseResponseBody.Data.Metrics.SmallFileCountDayGrowthRatio()
                    model.fromMap(dict["SmallFileCountDayGrowthRatio"] as! [String: Any])
                    self.smallFileCountDayGrowthRatio = model
                }
                if dict.keys.contains("SmallFileDayGrowthCount") {
                    var model = GetDoctorHiveDatabaseResponseBody.Data.Metrics.SmallFileDayGrowthCount()
                    model.fromMap(dict["SmallFileDayGrowthCount"] as! [String: Any])
                    self.smallFileDayGrowthCount = model
                }
                if dict.keys.contains("SmallFileRatio") {
                    var model = GetDoctorHiveDatabaseResponseBody.Data.Metrics.SmallFileRatio()
                    model.fromMap(dict["SmallFileRatio"] as! [String: Any])
                    self.smallFileRatio = model
                }
                if dict.keys.contains("TableCount") {
                    var model = GetDoctorHiveDatabaseResponseBody.Data.Metrics.TableCount()
                    model.fromMap(dict["TableCount"] as! [String: Any])
                    self.tableCount = model
                }
                if dict.keys.contains("TinyFileCount") {
                    var model = GetDoctorHiveDatabaseResponseBody.Data.Metrics.TinyFileCount()
                    model.fromMap(dict["TinyFileCount"] as! [String: Any])
                    self.tinyFileCount = model
                }
                if dict.keys.contains("TinyFileCountDayGrowthRatio") {
                    var model = GetDoctorHiveDatabaseResponseBody.Data.Metrics.TinyFileCountDayGrowthRatio()
                    model.fromMap(dict["TinyFileCountDayGrowthRatio"] as! [String: Any])
                    self.tinyFileCountDayGrowthRatio = model
                }
                if dict.keys.contains("TinyFileDayGrowthCount") {
                    var model = GetDoctorHiveDatabaseResponseBody.Data.Metrics.TinyFileDayGrowthCount()
                    model.fromMap(dict["TinyFileDayGrowthCount"] as! [String: Any])
                    self.tinyFileDayGrowthCount = model
                }
                if dict.keys.contains("TinyFileRatio") {
                    var model = GetDoctorHiveDatabaseResponseBody.Data.Metrics.TinyFileRatio()
                    model.fromMap(dict["TinyFileRatio"] as! [String: Any])
                    self.tinyFileRatio = model
                }
                if dict.keys.contains("TotalDataDayGrowthSize") {
                    var model = GetDoctorHiveDatabaseResponseBody.Data.Metrics.TotalDataDayGrowthSize()
                    model.fromMap(dict["TotalDataDayGrowthSize"] as! [String: Any])
                    self.totalDataDayGrowthSize = model
                }
                if dict.keys.contains("TotalDataSize") {
                    var model = GetDoctorHiveDatabaseResponseBody.Data.Metrics.TotalDataSize()
                    model.fromMap(dict["TotalDataSize"] as! [String: Any])
                    self.totalDataSize = model
                }
                if dict.keys.contains("TotalDataSizeDayGrowthRatio") {
                    var model = GetDoctorHiveDatabaseResponseBody.Data.Metrics.TotalDataSizeDayGrowthRatio()
                    model.fromMap(dict["TotalDataSizeDayGrowthRatio"] as! [String: Any])
                    self.totalDataSizeDayGrowthRatio = model
                }
                if dict.keys.contains("TotalFileCount") {
                    var model = GetDoctorHiveDatabaseResponseBody.Data.Metrics.TotalFileCount()
                    model.fromMap(dict["TotalFileCount"] as! [String: Any])
                    self.totalFileCount = model
                }
                if dict.keys.contains("TotalFileCountDayGrowthRatio") {
                    var model = GetDoctorHiveDatabaseResponseBody.Data.Metrics.TotalFileCountDayGrowthRatio()
                    model.fromMap(dict["TotalFileCountDayGrowthRatio"] as! [String: Any])
                    self.totalFileCountDayGrowthRatio = model
                }
                if dict.keys.contains("TotalFileDayGrowthCount") {
                    var model = GetDoctorHiveDatabaseResponseBody.Data.Metrics.TotalFileDayGrowthCount()
                    model.fromMap(dict["TotalFileDayGrowthCount"] as! [String: Any])
                    self.totalFileDayGrowthCount = model
                }
                if dict.keys.contains("WarmDataDayGrowthSize") {
                    var model = GetDoctorHiveDatabaseResponseBody.Data.Metrics.WarmDataDayGrowthSize()
                    model.fromMap(dict["WarmDataDayGrowthSize"] as! [String: Any])
                    self.warmDataDayGrowthSize = model
                }
                if dict.keys.contains("WarmDataRatio") {
                    var model = GetDoctorHiveDatabaseResponseBody.Data.Metrics.WarmDataRatio()
                    model.fromMap(dict["WarmDataRatio"] as! [String: Any])
                    self.warmDataRatio = model
                }
                if dict.keys.contains("WarmDataSize") {
                    var model = GetDoctorHiveDatabaseResponseBody.Data.Metrics.WarmDataSize()
                    model.fromMap(dict["WarmDataSize"] as! [String: Any])
                    self.warmDataSize = model
                }
                if dict.keys.contains("WarmDataSizeDayGrowthRatio") {
                    var model = GetDoctorHiveDatabaseResponseBody.Data.Metrics.WarmDataSizeDayGrowthRatio()
                    model.fromMap(dict["WarmDataSizeDayGrowthRatio"] as! [String: Any])
                    self.warmDataSizeDayGrowthRatio = model
                }
            }
        }
        public var analysis: GetDoctorHiveDatabaseResponseBody.Data.Analysis?

        public var formats: [GetDoctorHiveDatabaseResponseBody.Data.Formats]?

        public var metrics: GetDoctorHiveDatabaseResponseBody.Data.Metrics?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.analysis?.validate()
            try self.metrics?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.analysis != nil {
                map["Analysis"] = self.analysis?.toMap()
            }
            if self.formats != nil {
                var tmp : [Any] = []
                for k in self.formats! {
                    tmp.append(k.toMap())
                }
                map["Formats"] = tmp
            }
            if self.metrics != nil {
                map["Metrics"] = self.metrics?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Analysis") {
                var model = GetDoctorHiveDatabaseResponseBody.Data.Analysis()
                model.fromMap(dict["Analysis"] as! [String: Any])
                self.analysis = model
            }
            if dict.keys.contains("Formats") {
                var tmp : [GetDoctorHiveDatabaseResponseBody.Data.Formats] = []
                for v in dict["Formats"] as! [Any] {
                    var model = GetDoctorHiveDatabaseResponseBody.Data.Formats()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.formats = tmp
            }
            if dict.keys.contains("Metrics") {
                var model = GetDoctorHiveDatabaseResponseBody.Data.Metrics()
                model.fromMap(dict["Metrics"] as! [String: Any])
                self.metrics = model
            }
        }
    }
    public var data: GetDoctorHiveDatabaseResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = GetDoctorHiveDatabaseResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetDoctorHiveDatabaseResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDoctorHiveDatabaseResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDoctorHiveDatabaseResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDoctorHiveTableRequest : Tea.TeaModel {
    public var clusterId: String?

    public var dateTime: String?

    public var regionId: String?

    public var tableName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.dateTime != nil {
            map["DateTime"] = self.dateTime!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("DateTime") {
            self.dateTime = dict["DateTime"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("TableName") {
            self.tableName = dict["TableName"] as! String
        }
    }
}

public class GetDoctorHiveTableResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Analysis : Tea.TeaModel {
            public var hiveDistributionScore: Int32?

            public var hiveFormatScore: Int32?

            public var hiveFrequencyScore: Int32?

            public var hiveScore: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.hiveDistributionScore != nil {
                    map["HiveDistributionScore"] = self.hiveDistributionScore!
                }
                if self.hiveFormatScore != nil {
                    map["HiveFormatScore"] = self.hiveFormatScore!
                }
                if self.hiveFrequencyScore != nil {
                    map["HiveFrequencyScore"] = self.hiveFrequencyScore!
                }
                if self.hiveScore != nil {
                    map["HiveScore"] = self.hiveScore!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("HiveDistributionScore") {
                    self.hiveDistributionScore = dict["HiveDistributionScore"] as! Int32
                }
                if dict.keys.contains("HiveFormatScore") {
                    self.hiveFormatScore = dict["HiveFormatScore"] as! Int32
                }
                if dict.keys.contains("HiveFrequencyScore") {
                    self.hiveFrequencyScore = dict["HiveFrequencyScore"] as! Int32
                }
                if dict.keys.contains("HiveScore") {
                    self.hiveScore = dict["HiveScore"] as! Int32
                }
            }
        }
        public class Formats : Tea.TeaModel {
            public var formatDayGrowthSize: Int64?

            public var formatName: String?

            public var formatRatio: Double?

            public var formatSize: Int64?

            public var formatSizeDayGrowthRatio: Double?

            public var formatSizeUnit: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.formatDayGrowthSize != nil {
                    map["FormatDayGrowthSize"] = self.formatDayGrowthSize!
                }
                if self.formatName != nil {
                    map["FormatName"] = self.formatName!
                }
                if self.formatRatio != nil {
                    map["FormatRatio"] = self.formatRatio!
                }
                if self.formatSize != nil {
                    map["FormatSize"] = self.formatSize!
                }
                if self.formatSizeDayGrowthRatio != nil {
                    map["FormatSizeDayGrowthRatio"] = self.formatSizeDayGrowthRatio!
                }
                if self.formatSizeUnit != nil {
                    map["FormatSizeUnit"] = self.formatSizeUnit!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FormatDayGrowthSize") {
                    self.formatDayGrowthSize = dict["FormatDayGrowthSize"] as! Int64
                }
                if dict.keys.contains("FormatName") {
                    self.formatName = dict["FormatName"] as! String
                }
                if dict.keys.contains("FormatRatio") {
                    self.formatRatio = dict["FormatRatio"] as! Double
                }
                if dict.keys.contains("FormatSize") {
                    self.formatSize = dict["FormatSize"] as! Int64
                }
                if dict.keys.contains("FormatSizeDayGrowthRatio") {
                    self.formatSizeDayGrowthRatio = dict["FormatSizeDayGrowthRatio"] as! Double
                }
                if dict.keys.contains("FormatSizeUnit") {
                    self.formatSizeUnit = dict["FormatSizeUnit"] as! String
                }
            }
        }
        public class Metrics : Tea.TeaModel {
            public class ColdDataDayGrowthSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class ColdDataRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class ColdDataSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class ColdDataSizeDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class EmptyFileCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class EmptyFileCountDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class EmptyFileDayGrowthCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class EmptyFileRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class FreezeDataDayGrowthSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class FreezeDataRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class FreezeDataSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class FreezeDataSizeDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class HotDataDayGrowthSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class HotDataRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class HotDataSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class HotDataSizeDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class LargeFileCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class LargeFileCountDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class LargeFileDayGrowthCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class LargeFileRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class MediumFileCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class MediumFileCountDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class MediumFileDayGrowthCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class MediumFileRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class PartitionNum : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class SmallFileCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class SmallFileCountDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class SmallFileDayGrowthCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class SmallFileRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class TinyFileCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class TinyFileCountDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class TinyFileDayGrowthCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class TinyFileRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class TotalDataDayGrowthSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class TotalDataSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class TotalDataSizeDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class TotalFileCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class TotalFileCountDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class TotalFileDayGrowthCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class WarmDataDayGrowthSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class WarmDataRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class WarmDataSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class WarmDataSizeDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public var coldDataDayGrowthSize: GetDoctorHiveTableResponseBody.Data.Metrics.ColdDataDayGrowthSize?

            public var coldDataRatio: GetDoctorHiveTableResponseBody.Data.Metrics.ColdDataRatio?

            public var coldDataSize: GetDoctorHiveTableResponseBody.Data.Metrics.ColdDataSize?

            public var coldDataSizeDayGrowthRatio: GetDoctorHiveTableResponseBody.Data.Metrics.ColdDataSizeDayGrowthRatio?

            public var emptyFileCount: GetDoctorHiveTableResponseBody.Data.Metrics.EmptyFileCount?

            public var emptyFileCountDayGrowthRatio: GetDoctorHiveTableResponseBody.Data.Metrics.EmptyFileCountDayGrowthRatio?

            public var emptyFileDayGrowthCount: GetDoctorHiveTableResponseBody.Data.Metrics.EmptyFileDayGrowthCount?

            public var emptyFileRatio: GetDoctorHiveTableResponseBody.Data.Metrics.EmptyFileRatio?

            public var freezeDataDayGrowthSize: GetDoctorHiveTableResponseBody.Data.Metrics.FreezeDataDayGrowthSize?

            public var freezeDataRatio: GetDoctorHiveTableResponseBody.Data.Metrics.FreezeDataRatio?

            public var freezeDataSize: GetDoctorHiveTableResponseBody.Data.Metrics.FreezeDataSize?

            public var freezeDataSizeDayGrowthRatio: GetDoctorHiveTableResponseBody.Data.Metrics.FreezeDataSizeDayGrowthRatio?

            public var hotDataDayGrowthSize: GetDoctorHiveTableResponseBody.Data.Metrics.HotDataDayGrowthSize?

            public var hotDataRatio: GetDoctorHiveTableResponseBody.Data.Metrics.HotDataRatio?

            public var hotDataSize: GetDoctorHiveTableResponseBody.Data.Metrics.HotDataSize?

            public var hotDataSizeDayGrowthRatio: GetDoctorHiveTableResponseBody.Data.Metrics.HotDataSizeDayGrowthRatio?

            public var largeFileCount: GetDoctorHiveTableResponseBody.Data.Metrics.LargeFileCount?

            public var largeFileCountDayGrowthRatio: GetDoctorHiveTableResponseBody.Data.Metrics.LargeFileCountDayGrowthRatio?

            public var largeFileDayGrowthCount: GetDoctorHiveTableResponseBody.Data.Metrics.LargeFileDayGrowthCount?

            public var largeFileRatio: GetDoctorHiveTableResponseBody.Data.Metrics.LargeFileRatio?

            public var mediumFileCount: GetDoctorHiveTableResponseBody.Data.Metrics.MediumFileCount?

            public var mediumFileCountDayGrowthRatio: GetDoctorHiveTableResponseBody.Data.Metrics.MediumFileCountDayGrowthRatio?

            public var mediumFileDayGrowthCount: GetDoctorHiveTableResponseBody.Data.Metrics.MediumFileDayGrowthCount?

            public var mediumFileRatio: GetDoctorHiveTableResponseBody.Data.Metrics.MediumFileRatio?

            public var partitionNum: GetDoctorHiveTableResponseBody.Data.Metrics.PartitionNum?

            public var smallFileCount: GetDoctorHiveTableResponseBody.Data.Metrics.SmallFileCount?

            public var smallFileCountDayGrowthRatio: GetDoctorHiveTableResponseBody.Data.Metrics.SmallFileCountDayGrowthRatio?

            public var smallFileDayGrowthCount: GetDoctorHiveTableResponseBody.Data.Metrics.SmallFileDayGrowthCount?

            public var smallFileRatio: GetDoctorHiveTableResponseBody.Data.Metrics.SmallFileRatio?

            public var tinyFileCount: GetDoctorHiveTableResponseBody.Data.Metrics.TinyFileCount?

            public var tinyFileCountDayGrowthRatio: GetDoctorHiveTableResponseBody.Data.Metrics.TinyFileCountDayGrowthRatio?

            public var tinyFileDayGrowthCount: GetDoctorHiveTableResponseBody.Data.Metrics.TinyFileDayGrowthCount?

            public var tinyFileRatio: GetDoctorHiveTableResponseBody.Data.Metrics.TinyFileRatio?

            public var totalDataDayGrowthSize: GetDoctorHiveTableResponseBody.Data.Metrics.TotalDataDayGrowthSize?

            public var totalDataSize: GetDoctorHiveTableResponseBody.Data.Metrics.TotalDataSize?

            public var totalDataSizeDayGrowthRatio: GetDoctorHiveTableResponseBody.Data.Metrics.TotalDataSizeDayGrowthRatio?

            public var totalFileCount: GetDoctorHiveTableResponseBody.Data.Metrics.TotalFileCount?

            public var totalFileCountDayGrowthRatio: GetDoctorHiveTableResponseBody.Data.Metrics.TotalFileCountDayGrowthRatio?

            public var totalFileDayGrowthCount: GetDoctorHiveTableResponseBody.Data.Metrics.TotalFileDayGrowthCount?

            public var warmDataDayGrowthSize: GetDoctorHiveTableResponseBody.Data.Metrics.WarmDataDayGrowthSize?

            public var warmDataRatio: GetDoctorHiveTableResponseBody.Data.Metrics.WarmDataRatio?

            public var warmDataSize: GetDoctorHiveTableResponseBody.Data.Metrics.WarmDataSize?

            public var warmDataSizeDayGrowthRatio: GetDoctorHiveTableResponseBody.Data.Metrics.WarmDataSizeDayGrowthRatio?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.coldDataDayGrowthSize?.validate()
                try self.coldDataRatio?.validate()
                try self.coldDataSize?.validate()
                try self.coldDataSizeDayGrowthRatio?.validate()
                try self.emptyFileCount?.validate()
                try self.emptyFileCountDayGrowthRatio?.validate()
                try self.emptyFileDayGrowthCount?.validate()
                try self.emptyFileRatio?.validate()
                try self.freezeDataDayGrowthSize?.validate()
                try self.freezeDataRatio?.validate()
                try self.freezeDataSize?.validate()
                try self.freezeDataSizeDayGrowthRatio?.validate()
                try self.hotDataDayGrowthSize?.validate()
                try self.hotDataRatio?.validate()
                try self.hotDataSize?.validate()
                try self.hotDataSizeDayGrowthRatio?.validate()
                try self.largeFileCount?.validate()
                try self.largeFileCountDayGrowthRatio?.validate()
                try self.largeFileDayGrowthCount?.validate()
                try self.largeFileRatio?.validate()
                try self.mediumFileCount?.validate()
                try self.mediumFileCountDayGrowthRatio?.validate()
                try self.mediumFileDayGrowthCount?.validate()
                try self.mediumFileRatio?.validate()
                try self.partitionNum?.validate()
                try self.smallFileCount?.validate()
                try self.smallFileCountDayGrowthRatio?.validate()
                try self.smallFileDayGrowthCount?.validate()
                try self.smallFileRatio?.validate()
                try self.tinyFileCount?.validate()
                try self.tinyFileCountDayGrowthRatio?.validate()
                try self.tinyFileDayGrowthCount?.validate()
                try self.tinyFileRatio?.validate()
                try self.totalDataDayGrowthSize?.validate()
                try self.totalDataSize?.validate()
                try self.totalDataSizeDayGrowthRatio?.validate()
                try self.totalFileCount?.validate()
                try self.totalFileCountDayGrowthRatio?.validate()
                try self.totalFileDayGrowthCount?.validate()
                try self.warmDataDayGrowthSize?.validate()
                try self.warmDataRatio?.validate()
                try self.warmDataSize?.validate()
                try self.warmDataSizeDayGrowthRatio?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.coldDataDayGrowthSize != nil {
                    map["ColdDataDayGrowthSize"] = self.coldDataDayGrowthSize?.toMap()
                }
                if self.coldDataRatio != nil {
                    map["ColdDataRatio"] = self.coldDataRatio?.toMap()
                }
                if self.coldDataSize != nil {
                    map["ColdDataSize"] = self.coldDataSize?.toMap()
                }
                if self.coldDataSizeDayGrowthRatio != nil {
                    map["ColdDataSizeDayGrowthRatio"] = self.coldDataSizeDayGrowthRatio?.toMap()
                }
                if self.emptyFileCount != nil {
                    map["EmptyFileCount"] = self.emptyFileCount?.toMap()
                }
                if self.emptyFileCountDayGrowthRatio != nil {
                    map["EmptyFileCountDayGrowthRatio"] = self.emptyFileCountDayGrowthRatio?.toMap()
                }
                if self.emptyFileDayGrowthCount != nil {
                    map["EmptyFileDayGrowthCount"] = self.emptyFileDayGrowthCount?.toMap()
                }
                if self.emptyFileRatio != nil {
                    map["EmptyFileRatio"] = self.emptyFileRatio?.toMap()
                }
                if self.freezeDataDayGrowthSize != nil {
                    map["FreezeDataDayGrowthSize"] = self.freezeDataDayGrowthSize?.toMap()
                }
                if self.freezeDataRatio != nil {
                    map["FreezeDataRatio"] = self.freezeDataRatio?.toMap()
                }
                if self.freezeDataSize != nil {
                    map["FreezeDataSize"] = self.freezeDataSize?.toMap()
                }
                if self.freezeDataSizeDayGrowthRatio != nil {
                    map["FreezeDataSizeDayGrowthRatio"] = self.freezeDataSizeDayGrowthRatio?.toMap()
                }
                if self.hotDataDayGrowthSize != nil {
                    map["HotDataDayGrowthSize"] = self.hotDataDayGrowthSize?.toMap()
                }
                if self.hotDataRatio != nil {
                    map["HotDataRatio"] = self.hotDataRatio?.toMap()
                }
                if self.hotDataSize != nil {
                    map["HotDataSize"] = self.hotDataSize?.toMap()
                }
                if self.hotDataSizeDayGrowthRatio != nil {
                    map["HotDataSizeDayGrowthRatio"] = self.hotDataSizeDayGrowthRatio?.toMap()
                }
                if self.largeFileCount != nil {
                    map["LargeFileCount"] = self.largeFileCount?.toMap()
                }
                if self.largeFileCountDayGrowthRatio != nil {
                    map["LargeFileCountDayGrowthRatio"] = self.largeFileCountDayGrowthRatio?.toMap()
                }
                if self.largeFileDayGrowthCount != nil {
                    map["LargeFileDayGrowthCount"] = self.largeFileDayGrowthCount?.toMap()
                }
                if self.largeFileRatio != nil {
                    map["LargeFileRatio"] = self.largeFileRatio?.toMap()
                }
                if self.mediumFileCount != nil {
                    map["MediumFileCount"] = self.mediumFileCount?.toMap()
                }
                if self.mediumFileCountDayGrowthRatio != nil {
                    map["MediumFileCountDayGrowthRatio"] = self.mediumFileCountDayGrowthRatio?.toMap()
                }
                if self.mediumFileDayGrowthCount != nil {
                    map["MediumFileDayGrowthCount"] = self.mediumFileDayGrowthCount?.toMap()
                }
                if self.mediumFileRatio != nil {
                    map["MediumFileRatio"] = self.mediumFileRatio?.toMap()
                }
                if self.partitionNum != nil {
                    map["PartitionNum"] = self.partitionNum?.toMap()
                }
                if self.smallFileCount != nil {
                    map["SmallFileCount"] = self.smallFileCount?.toMap()
                }
                if self.smallFileCountDayGrowthRatio != nil {
                    map["SmallFileCountDayGrowthRatio"] = self.smallFileCountDayGrowthRatio?.toMap()
                }
                if self.smallFileDayGrowthCount != nil {
                    map["SmallFileDayGrowthCount"] = self.smallFileDayGrowthCount?.toMap()
                }
                if self.smallFileRatio != nil {
                    map["SmallFileRatio"] = self.smallFileRatio?.toMap()
                }
                if self.tinyFileCount != nil {
                    map["TinyFileCount"] = self.tinyFileCount?.toMap()
                }
                if self.tinyFileCountDayGrowthRatio != nil {
                    map["TinyFileCountDayGrowthRatio"] = self.tinyFileCountDayGrowthRatio?.toMap()
                }
                if self.tinyFileDayGrowthCount != nil {
                    map["TinyFileDayGrowthCount"] = self.tinyFileDayGrowthCount?.toMap()
                }
                if self.tinyFileRatio != nil {
                    map["TinyFileRatio"] = self.tinyFileRatio?.toMap()
                }
                if self.totalDataDayGrowthSize != nil {
                    map["TotalDataDayGrowthSize"] = self.totalDataDayGrowthSize?.toMap()
                }
                if self.totalDataSize != nil {
                    map["TotalDataSize"] = self.totalDataSize?.toMap()
                }
                if self.totalDataSizeDayGrowthRatio != nil {
                    map["TotalDataSizeDayGrowthRatio"] = self.totalDataSizeDayGrowthRatio?.toMap()
                }
                if self.totalFileCount != nil {
                    map["TotalFileCount"] = self.totalFileCount?.toMap()
                }
                if self.totalFileCountDayGrowthRatio != nil {
                    map["TotalFileCountDayGrowthRatio"] = self.totalFileCountDayGrowthRatio?.toMap()
                }
                if self.totalFileDayGrowthCount != nil {
                    map["TotalFileDayGrowthCount"] = self.totalFileDayGrowthCount?.toMap()
                }
                if self.warmDataDayGrowthSize != nil {
                    map["WarmDataDayGrowthSize"] = self.warmDataDayGrowthSize?.toMap()
                }
                if self.warmDataRatio != nil {
                    map["WarmDataRatio"] = self.warmDataRatio?.toMap()
                }
                if self.warmDataSize != nil {
                    map["WarmDataSize"] = self.warmDataSize?.toMap()
                }
                if self.warmDataSizeDayGrowthRatio != nil {
                    map["WarmDataSizeDayGrowthRatio"] = self.warmDataSizeDayGrowthRatio?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ColdDataDayGrowthSize") {
                    var model = GetDoctorHiveTableResponseBody.Data.Metrics.ColdDataDayGrowthSize()
                    model.fromMap(dict["ColdDataDayGrowthSize"] as! [String: Any])
                    self.coldDataDayGrowthSize = model
                }
                if dict.keys.contains("ColdDataRatio") {
                    var model = GetDoctorHiveTableResponseBody.Data.Metrics.ColdDataRatio()
                    model.fromMap(dict["ColdDataRatio"] as! [String: Any])
                    self.coldDataRatio = model
                }
                if dict.keys.contains("ColdDataSize") {
                    var model = GetDoctorHiveTableResponseBody.Data.Metrics.ColdDataSize()
                    model.fromMap(dict["ColdDataSize"] as! [String: Any])
                    self.coldDataSize = model
                }
                if dict.keys.contains("ColdDataSizeDayGrowthRatio") {
                    var model = GetDoctorHiveTableResponseBody.Data.Metrics.ColdDataSizeDayGrowthRatio()
                    model.fromMap(dict["ColdDataSizeDayGrowthRatio"] as! [String: Any])
                    self.coldDataSizeDayGrowthRatio = model
                }
                if dict.keys.contains("EmptyFileCount") {
                    var model = GetDoctorHiveTableResponseBody.Data.Metrics.EmptyFileCount()
                    model.fromMap(dict["EmptyFileCount"] as! [String: Any])
                    self.emptyFileCount = model
                }
                if dict.keys.contains("EmptyFileCountDayGrowthRatio") {
                    var model = GetDoctorHiveTableResponseBody.Data.Metrics.EmptyFileCountDayGrowthRatio()
                    model.fromMap(dict["EmptyFileCountDayGrowthRatio"] as! [String: Any])
                    self.emptyFileCountDayGrowthRatio = model
                }
                if dict.keys.contains("EmptyFileDayGrowthCount") {
                    var model = GetDoctorHiveTableResponseBody.Data.Metrics.EmptyFileDayGrowthCount()
                    model.fromMap(dict["EmptyFileDayGrowthCount"] as! [String: Any])
                    self.emptyFileDayGrowthCount = model
                }
                if dict.keys.contains("EmptyFileRatio") {
                    var model = GetDoctorHiveTableResponseBody.Data.Metrics.EmptyFileRatio()
                    model.fromMap(dict["EmptyFileRatio"] as! [String: Any])
                    self.emptyFileRatio = model
                }
                if dict.keys.contains("FreezeDataDayGrowthSize") {
                    var model = GetDoctorHiveTableResponseBody.Data.Metrics.FreezeDataDayGrowthSize()
                    model.fromMap(dict["FreezeDataDayGrowthSize"] as! [String: Any])
                    self.freezeDataDayGrowthSize = model
                }
                if dict.keys.contains("FreezeDataRatio") {
                    var model = GetDoctorHiveTableResponseBody.Data.Metrics.FreezeDataRatio()
                    model.fromMap(dict["FreezeDataRatio"] as! [String: Any])
                    self.freezeDataRatio = model
                }
                if dict.keys.contains("FreezeDataSize") {
                    var model = GetDoctorHiveTableResponseBody.Data.Metrics.FreezeDataSize()
                    model.fromMap(dict["FreezeDataSize"] as! [String: Any])
                    self.freezeDataSize = model
                }
                if dict.keys.contains("FreezeDataSizeDayGrowthRatio") {
                    var model = GetDoctorHiveTableResponseBody.Data.Metrics.FreezeDataSizeDayGrowthRatio()
                    model.fromMap(dict["FreezeDataSizeDayGrowthRatio"] as! [String: Any])
                    self.freezeDataSizeDayGrowthRatio = model
                }
                if dict.keys.contains("HotDataDayGrowthSize") {
                    var model = GetDoctorHiveTableResponseBody.Data.Metrics.HotDataDayGrowthSize()
                    model.fromMap(dict["HotDataDayGrowthSize"] as! [String: Any])
                    self.hotDataDayGrowthSize = model
                }
                if dict.keys.contains("HotDataRatio") {
                    var model = GetDoctorHiveTableResponseBody.Data.Metrics.HotDataRatio()
                    model.fromMap(dict["HotDataRatio"] as! [String: Any])
                    self.hotDataRatio = model
                }
                if dict.keys.contains("HotDataSize") {
                    var model = GetDoctorHiveTableResponseBody.Data.Metrics.HotDataSize()
                    model.fromMap(dict["HotDataSize"] as! [String: Any])
                    self.hotDataSize = model
                }
                if dict.keys.contains("HotDataSizeDayGrowthRatio") {
                    var model = GetDoctorHiveTableResponseBody.Data.Metrics.HotDataSizeDayGrowthRatio()
                    model.fromMap(dict["HotDataSizeDayGrowthRatio"] as! [String: Any])
                    self.hotDataSizeDayGrowthRatio = model
                }
                if dict.keys.contains("LargeFileCount") {
                    var model = GetDoctorHiveTableResponseBody.Data.Metrics.LargeFileCount()
                    model.fromMap(dict["LargeFileCount"] as! [String: Any])
                    self.largeFileCount = model
                }
                if dict.keys.contains("LargeFileCountDayGrowthRatio") {
                    var model = GetDoctorHiveTableResponseBody.Data.Metrics.LargeFileCountDayGrowthRatio()
                    model.fromMap(dict["LargeFileCountDayGrowthRatio"] as! [String: Any])
                    self.largeFileCountDayGrowthRatio = model
                }
                if dict.keys.contains("LargeFileDayGrowthCount") {
                    var model = GetDoctorHiveTableResponseBody.Data.Metrics.LargeFileDayGrowthCount()
                    model.fromMap(dict["LargeFileDayGrowthCount"] as! [String: Any])
                    self.largeFileDayGrowthCount = model
                }
                if dict.keys.contains("LargeFileRatio") {
                    var model = GetDoctorHiveTableResponseBody.Data.Metrics.LargeFileRatio()
                    model.fromMap(dict["LargeFileRatio"] as! [String: Any])
                    self.largeFileRatio = model
                }
                if dict.keys.contains("MediumFileCount") {
                    var model = GetDoctorHiveTableResponseBody.Data.Metrics.MediumFileCount()
                    model.fromMap(dict["MediumFileCount"] as! [String: Any])
                    self.mediumFileCount = model
                }
                if dict.keys.contains("MediumFileCountDayGrowthRatio") {
                    var model = GetDoctorHiveTableResponseBody.Data.Metrics.MediumFileCountDayGrowthRatio()
                    model.fromMap(dict["MediumFileCountDayGrowthRatio"] as! [String: Any])
                    self.mediumFileCountDayGrowthRatio = model
                }
                if dict.keys.contains("MediumFileDayGrowthCount") {
                    var model = GetDoctorHiveTableResponseBody.Data.Metrics.MediumFileDayGrowthCount()
                    model.fromMap(dict["MediumFileDayGrowthCount"] as! [String: Any])
                    self.mediumFileDayGrowthCount = model
                }
                if dict.keys.contains("MediumFileRatio") {
                    var model = GetDoctorHiveTableResponseBody.Data.Metrics.MediumFileRatio()
                    model.fromMap(dict["MediumFileRatio"] as! [String: Any])
                    self.mediumFileRatio = model
                }
                if dict.keys.contains("PartitionNum") {
                    var model = GetDoctorHiveTableResponseBody.Data.Metrics.PartitionNum()
                    model.fromMap(dict["PartitionNum"] as! [String: Any])
                    self.partitionNum = model
                }
                if dict.keys.contains("SmallFileCount") {
                    var model = GetDoctorHiveTableResponseBody.Data.Metrics.SmallFileCount()
                    model.fromMap(dict["SmallFileCount"] as! [String: Any])
                    self.smallFileCount = model
                }
                if dict.keys.contains("SmallFileCountDayGrowthRatio") {
                    var model = GetDoctorHiveTableResponseBody.Data.Metrics.SmallFileCountDayGrowthRatio()
                    model.fromMap(dict["SmallFileCountDayGrowthRatio"] as! [String: Any])
                    self.smallFileCountDayGrowthRatio = model
                }
                if dict.keys.contains("SmallFileDayGrowthCount") {
                    var model = GetDoctorHiveTableResponseBody.Data.Metrics.SmallFileDayGrowthCount()
                    model.fromMap(dict["SmallFileDayGrowthCount"] as! [String: Any])
                    self.smallFileDayGrowthCount = model
                }
                if dict.keys.contains("SmallFileRatio") {
                    var model = GetDoctorHiveTableResponseBody.Data.Metrics.SmallFileRatio()
                    model.fromMap(dict["SmallFileRatio"] as! [String: Any])
                    self.smallFileRatio = model
                }
                if dict.keys.contains("TinyFileCount") {
                    var model = GetDoctorHiveTableResponseBody.Data.Metrics.TinyFileCount()
                    model.fromMap(dict["TinyFileCount"] as! [String: Any])
                    self.tinyFileCount = model
                }
                if dict.keys.contains("TinyFileCountDayGrowthRatio") {
                    var model = GetDoctorHiveTableResponseBody.Data.Metrics.TinyFileCountDayGrowthRatio()
                    model.fromMap(dict["TinyFileCountDayGrowthRatio"] as! [String: Any])
                    self.tinyFileCountDayGrowthRatio = model
                }
                if dict.keys.contains("TinyFileDayGrowthCount") {
                    var model = GetDoctorHiveTableResponseBody.Data.Metrics.TinyFileDayGrowthCount()
                    model.fromMap(dict["TinyFileDayGrowthCount"] as! [String: Any])
                    self.tinyFileDayGrowthCount = model
                }
                if dict.keys.contains("TinyFileRatio") {
                    var model = GetDoctorHiveTableResponseBody.Data.Metrics.TinyFileRatio()
                    model.fromMap(dict["TinyFileRatio"] as! [String: Any])
                    self.tinyFileRatio = model
                }
                if dict.keys.contains("TotalDataDayGrowthSize") {
                    var model = GetDoctorHiveTableResponseBody.Data.Metrics.TotalDataDayGrowthSize()
                    model.fromMap(dict["TotalDataDayGrowthSize"] as! [String: Any])
                    self.totalDataDayGrowthSize = model
                }
                if dict.keys.contains("TotalDataSize") {
                    var model = GetDoctorHiveTableResponseBody.Data.Metrics.TotalDataSize()
                    model.fromMap(dict["TotalDataSize"] as! [String: Any])
                    self.totalDataSize = model
                }
                if dict.keys.contains("TotalDataSizeDayGrowthRatio") {
                    var model = GetDoctorHiveTableResponseBody.Data.Metrics.TotalDataSizeDayGrowthRatio()
                    model.fromMap(dict["TotalDataSizeDayGrowthRatio"] as! [String: Any])
                    self.totalDataSizeDayGrowthRatio = model
                }
                if dict.keys.contains("TotalFileCount") {
                    var model = GetDoctorHiveTableResponseBody.Data.Metrics.TotalFileCount()
                    model.fromMap(dict["TotalFileCount"] as! [String: Any])
                    self.totalFileCount = model
                }
                if dict.keys.contains("TotalFileCountDayGrowthRatio") {
                    var model = GetDoctorHiveTableResponseBody.Data.Metrics.TotalFileCountDayGrowthRatio()
                    model.fromMap(dict["TotalFileCountDayGrowthRatio"] as! [String: Any])
                    self.totalFileCountDayGrowthRatio = model
                }
                if dict.keys.contains("TotalFileDayGrowthCount") {
                    var model = GetDoctorHiveTableResponseBody.Data.Metrics.TotalFileDayGrowthCount()
                    model.fromMap(dict["TotalFileDayGrowthCount"] as! [String: Any])
                    self.totalFileDayGrowthCount = model
                }
                if dict.keys.contains("WarmDataDayGrowthSize") {
                    var model = GetDoctorHiveTableResponseBody.Data.Metrics.WarmDataDayGrowthSize()
                    model.fromMap(dict["WarmDataDayGrowthSize"] as! [String: Any])
                    self.warmDataDayGrowthSize = model
                }
                if dict.keys.contains("WarmDataRatio") {
                    var model = GetDoctorHiveTableResponseBody.Data.Metrics.WarmDataRatio()
                    model.fromMap(dict["WarmDataRatio"] as! [String: Any])
                    self.warmDataRatio = model
                }
                if dict.keys.contains("WarmDataSize") {
                    var model = GetDoctorHiveTableResponseBody.Data.Metrics.WarmDataSize()
                    model.fromMap(dict["WarmDataSize"] as! [String: Any])
                    self.warmDataSize = model
                }
                if dict.keys.contains("WarmDataSizeDayGrowthRatio") {
                    var model = GetDoctorHiveTableResponseBody.Data.Metrics.WarmDataSizeDayGrowthRatio()
                    model.fromMap(dict["WarmDataSizeDayGrowthRatio"] as! [String: Any])
                    self.warmDataSizeDayGrowthRatio = model
                }
            }
        }
        public var analysis: GetDoctorHiveTableResponseBody.Data.Analysis?

        public var formats: [GetDoctorHiveTableResponseBody.Data.Formats]?

        public var metrics: GetDoctorHiveTableResponseBody.Data.Metrics?

        public var owner: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.analysis?.validate()
            try self.metrics?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.analysis != nil {
                map["Analysis"] = self.analysis?.toMap()
            }
            if self.formats != nil {
                var tmp : [Any] = []
                for k in self.formats! {
                    tmp.append(k.toMap())
                }
                map["Formats"] = tmp
            }
            if self.metrics != nil {
                map["Metrics"] = self.metrics?.toMap()
            }
            if self.owner != nil {
                map["Owner"] = self.owner!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Analysis") {
                var model = GetDoctorHiveTableResponseBody.Data.Analysis()
                model.fromMap(dict["Analysis"] as! [String: Any])
                self.analysis = model
            }
            if dict.keys.contains("Formats") {
                var tmp : [GetDoctorHiveTableResponseBody.Data.Formats] = []
                for v in dict["Formats"] as! [Any] {
                    var model = GetDoctorHiveTableResponseBody.Data.Formats()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.formats = tmp
            }
            if dict.keys.contains("Metrics") {
                var model = GetDoctorHiveTableResponseBody.Data.Metrics()
                model.fromMap(dict["Metrics"] as! [String: Any])
                self.metrics = model
            }
            if dict.keys.contains("Owner") {
                self.owner = dict["Owner"] as! String
            }
        }
    }
    public var data: GetDoctorHiveTableResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = GetDoctorHiveTableResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetDoctorHiveTableResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDoctorHiveTableResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDoctorHiveTableResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDoctorJobRequest : Tea.TeaModel {
    public var appId: String?

    public var clusterId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class GetDoctorJobResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Metrics : Tea.TeaModel {
            public class MemSeconds : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class VcoreSeconds : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public var memSeconds: GetDoctorJobResponseBody.Data.Metrics.MemSeconds?

            public var vcoreSeconds: GetDoctorJobResponseBody.Data.Metrics.VcoreSeconds?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.memSeconds?.validate()
                try self.vcoreSeconds?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.memSeconds != nil {
                    map["MemSeconds"] = self.memSeconds?.toMap()
                }
                if self.vcoreSeconds != nil {
                    map["VcoreSeconds"] = self.vcoreSeconds?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("MemSeconds") {
                    var model = GetDoctorJobResponseBody.Data.Metrics.MemSeconds()
                    model.fromMap(dict["MemSeconds"] as! [String: Any])
                    self.memSeconds = model
                }
                if dict.keys.contains("VcoreSeconds") {
                    var model = GetDoctorJobResponseBody.Data.Metrics.VcoreSeconds()
                    model.fromMap(dict["VcoreSeconds"] as! [String: Any])
                    self.vcoreSeconds = model
                }
            }
        }
        public var appId: String?

        public var appName: String?

        public var elapsedTime: Int64?

        public var finalStatus: String?

        public var finishTime: Int64?

        public var launchTime: Int64?

        public var metrics: GetDoctorJobResponseBody.Data.Metrics?

        public var queue: String?

        public var startTime: Int64?

        public var state: String?

        public var type: String?

        public var user: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.metrics?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.elapsedTime != nil {
                map["ElapsedTime"] = self.elapsedTime!
            }
            if self.finalStatus != nil {
                map["FinalStatus"] = self.finalStatus!
            }
            if self.finishTime != nil {
                map["FinishTime"] = self.finishTime!
            }
            if self.launchTime != nil {
                map["LaunchTime"] = self.launchTime!
            }
            if self.metrics != nil {
                map["Metrics"] = self.metrics?.toMap()
            }
            if self.queue != nil {
                map["Queue"] = self.queue!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.user != nil {
                map["User"] = self.user!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("AppName") {
                self.appName = dict["AppName"] as! String
            }
            if dict.keys.contains("ElapsedTime") {
                self.elapsedTime = dict["ElapsedTime"] as! Int64
            }
            if dict.keys.contains("FinalStatus") {
                self.finalStatus = dict["FinalStatus"] as! String
            }
            if dict.keys.contains("FinishTime") {
                self.finishTime = dict["FinishTime"] as! Int64
            }
            if dict.keys.contains("LaunchTime") {
                self.launchTime = dict["LaunchTime"] as! Int64
            }
            if dict.keys.contains("Metrics") {
                var model = GetDoctorJobResponseBody.Data.Metrics()
                model.fromMap(dict["Metrics"] as! [String: Any])
                self.metrics = model
            }
            if dict.keys.contains("Queue") {
                self.queue = dict["Queue"] as! String
            }
            if dict.keys.contains("StartTime") {
                self.startTime = dict["StartTime"] as! Int64
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("User") {
                self.user = dict["User"] as! String
            }
        }
    }
    public var data: GetDoctorJobResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = GetDoctorJobResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetDoctorJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDoctorJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDoctorJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDoctorReportComponentSummaryRequest : Tea.TeaModel {
    public var clusterId: String?

    public var componentType: String?

    public var dateTime: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.componentType != nil {
            map["ComponentType"] = self.componentType!
        }
        if self.dateTime != nil {
            map["DateTime"] = self.dateTime!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("ComponentType") {
            self.componentType = dict["ComponentType"] as! String
        }
        if dict.keys.contains("DateTime") {
            self.dateTime = dict["DateTime"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class GetDoctorReportComponentSummaryResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var score: Int32?

        public var suggestion: String?

        public var summary: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.score != nil {
                map["Score"] = self.score!
            }
            if self.suggestion != nil {
                map["Suggestion"] = self.suggestion!
            }
            if self.summary != nil {
                map["Summary"] = self.summary!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Score") {
                self.score = dict["Score"] as! Int32
            }
            if dict.keys.contains("Suggestion") {
                self.suggestion = dict["Suggestion"] as! String
            }
            if dict.keys.contains("Summary") {
                self.summary = dict["Summary"] as! String
            }
        }
    }
    public var data: GetDoctorReportComponentSummaryResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = GetDoctorReportComponentSummaryResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetDoctorReportComponentSummaryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDoctorReportComponentSummaryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDoctorReportComponentSummaryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetNodeGroupRequest : Tea.TeaModel {
    public var clusterId: String?

    public var nodeGroupId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.nodeGroupId != nil {
            map["NodeGroupId"] = self.nodeGroupId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("NodeGroupId") {
            self.nodeGroupId = dict["NodeGroupId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class GetNodeGroupResponseBody : Tea.TeaModel {
    public var nodeGroup: NodeGroup?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.nodeGroup?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nodeGroup != nil {
            map["NodeGroup"] = self.nodeGroup?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NodeGroup") {
            var model = NodeGroup()
            model.fromMap(dict["NodeGroup"] as! [String: Any])
            self.nodeGroup = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetNodeGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetNodeGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetNodeGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetOperationRequest : Tea.TeaModel {
    public var clusterId: String?

    public var operationId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.operationId != nil {
            map["OperationId"] = self.operationId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("OperationId") {
            self.operationId = dict["OperationId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class GetOperationResponseBody : Tea.TeaModel {
    public var operation: Operation?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.operation?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.operation != nil {
            map["Operation"] = self.operation?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Operation") {
            var model = Operation()
            model.fromMap(dict["Operation"] as! [String: Any])
            self.operation = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetOperationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetOperationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetOperationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class IncreaseNodesRequest : Tea.TeaModel {
    public var applicationConfigs: [ApplicationConfig]?

    public var autoPayOrder: Bool?

    public var autoRenew: Bool?

    public var clusterId: String?

    public var increaseNodeCount: Int32?

    public var minIncreaseNodeCount: Int32?

    public var nodeGroupId: String?

    public var paymentDuration: Int32?

    public var paymentDurationUnit: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationConfigs != nil {
            var tmp : [Any] = []
            for k in self.applicationConfigs! {
                tmp.append(k.toMap())
            }
            map["ApplicationConfigs"] = tmp
        }
        if self.autoPayOrder != nil {
            map["AutoPayOrder"] = self.autoPayOrder!
        }
        if self.autoRenew != nil {
            map["AutoRenew"] = self.autoRenew!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.increaseNodeCount != nil {
            map["IncreaseNodeCount"] = self.increaseNodeCount!
        }
        if self.minIncreaseNodeCount != nil {
            map["MinIncreaseNodeCount"] = self.minIncreaseNodeCount!
        }
        if self.nodeGroupId != nil {
            map["NodeGroupId"] = self.nodeGroupId!
        }
        if self.paymentDuration != nil {
            map["PaymentDuration"] = self.paymentDuration!
        }
        if self.paymentDurationUnit != nil {
            map["PaymentDurationUnit"] = self.paymentDurationUnit!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApplicationConfigs") {
            var tmp : [ApplicationConfig] = []
            for v in dict["ApplicationConfigs"] as! [Any] {
                var model = ApplicationConfig()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.applicationConfigs = tmp
        }
        if dict.keys.contains("AutoPayOrder") {
            self.autoPayOrder = dict["AutoPayOrder"] as! Bool
        }
        if dict.keys.contains("AutoRenew") {
            self.autoRenew = dict["AutoRenew"] as! Bool
        }
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("IncreaseNodeCount") {
            self.increaseNodeCount = dict["IncreaseNodeCount"] as! Int32
        }
        if dict.keys.contains("MinIncreaseNodeCount") {
            self.minIncreaseNodeCount = dict["MinIncreaseNodeCount"] as! Int32
        }
        if dict.keys.contains("NodeGroupId") {
            self.nodeGroupId = dict["NodeGroupId"] as! String
        }
        if dict.keys.contains("PaymentDuration") {
            self.paymentDuration = dict["PaymentDuration"] as! Int32
        }
        if dict.keys.contains("PaymentDurationUnit") {
            self.paymentDurationUnit = dict["PaymentDurationUnit"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class IncreaseNodesResponseBody : Tea.TeaModel {
    public var operationId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.operationId != nil {
            map["OperationId"] = self.operationId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OperationId") {
            self.operationId = dict["OperationId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class IncreaseNodesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: IncreaseNodesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = IncreaseNodesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class JoinResourceGroupRequest : Tea.TeaModel {
    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceId: String?

    public var resourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! String
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
    }
}

public class JoinResourceGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class JoinResourceGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: JoinResourceGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = JoinResourceGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListApiTemplatesRequest : Tea.TeaModel {
    public var apiName: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var templateId: String?

    public var templateIds: [String]?

    public var templateName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiName != nil {
            map["ApiName"] = self.apiName!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.templateIds != nil {
            map["TemplateIds"] = self.templateIds!
        }
        if self.templateName != nil {
            map["TemplateName"] = self.templateName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiName") {
            self.apiName = dict["ApiName"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("TemplateIds") {
            self.templateIds = dict["TemplateIds"] as! [String]
        }
        if dict.keys.contains("TemplateName") {
            self.templateName = dict["TemplateName"] as! String
        }
    }
}

public class ListApiTemplatesResponseBody : Tea.TeaModel {
    public var apiTemplates: [ApiTemplate]?

    public var maxResults: Int32?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiTemplates != nil {
            var tmp : [Any] = []
            for k in self.apiTemplates! {
                tmp.append(k.toMap())
            }
            map["ApiTemplates"] = tmp
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiTemplates") {
            var tmp : [ApiTemplate] = []
            for v in dict["ApiTemplates"] as! [Any] {
                var model = ApiTemplate()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.apiTemplates = tmp
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListApiTemplatesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListApiTemplatesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListApiTemplatesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListApplicationConfigsRequest : Tea.TeaModel {
    public var applicationName: String?

    public var clusterId: String?

    public var configFileName: String?

    public var configItemKey: String?

    public var configItemValue: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var nodeGroupId: String?

    public var nodeId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationName != nil {
            map["ApplicationName"] = self.applicationName!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.configFileName != nil {
            map["ConfigFileName"] = self.configFileName!
        }
        if self.configItemKey != nil {
            map["ConfigItemKey"] = self.configItemKey!
        }
        if self.configItemValue != nil {
            map["ConfigItemValue"] = self.configItemValue!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.nodeGroupId != nil {
            map["NodeGroupId"] = self.nodeGroupId!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApplicationName") {
            self.applicationName = dict["ApplicationName"] as! String
        }
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("ConfigFileName") {
            self.configFileName = dict["ConfigFileName"] as! String
        }
        if dict.keys.contains("ConfigItemKey") {
            self.configItemKey = dict["ConfigItemKey"] as! String
        }
        if dict.keys.contains("ConfigItemValue") {
            self.configItemValue = dict["ConfigItemValue"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("NodeGroupId") {
            self.nodeGroupId = dict["NodeGroupId"] as! String
        }
        if dict.keys.contains("NodeId") {
            self.nodeId = dict["NodeId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ListApplicationConfigsResponseBody : Tea.TeaModel {
    public class ApplicationConfigs : Tea.TeaModel {
        public var applicationName: String?

        public var configEffectState: String?

        public var configFileName: String?

        public var configItemKey: String?

        public var configItemValue: String?

        public var createTime: Int64?

        public var custom: Bool?

        public var description_: String?

        public var initValue: String?

        public var modifier: String?

        public var nodeGroupId: String?

        public var nodeId: String?

        public var updateTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.applicationName != nil {
                map["ApplicationName"] = self.applicationName!
            }
            if self.configEffectState != nil {
                map["ConfigEffectState"] = self.configEffectState!
            }
            if self.configFileName != nil {
                map["ConfigFileName"] = self.configFileName!
            }
            if self.configItemKey != nil {
                map["ConfigItemKey"] = self.configItemKey!
            }
            if self.configItemValue != nil {
                map["ConfigItemValue"] = self.configItemValue!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.custom != nil {
                map["Custom"] = self.custom!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.initValue != nil {
                map["InitValue"] = self.initValue!
            }
            if self.modifier != nil {
                map["Modifier"] = self.modifier!
            }
            if self.nodeGroupId != nil {
                map["NodeGroupId"] = self.nodeGroupId!
            }
            if self.nodeId != nil {
                map["NodeId"] = self.nodeId!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApplicationName") {
                self.applicationName = dict["ApplicationName"] as! String
            }
            if dict.keys.contains("ConfigEffectState") {
                self.configEffectState = dict["ConfigEffectState"] as! String
            }
            if dict.keys.contains("ConfigFileName") {
                self.configFileName = dict["ConfigFileName"] as! String
            }
            if dict.keys.contains("ConfigItemKey") {
                self.configItemKey = dict["ConfigItemKey"] as! String
            }
            if dict.keys.contains("ConfigItemValue") {
                self.configItemValue = dict["ConfigItemValue"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("Custom") {
                self.custom = dict["Custom"] as! Bool
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("InitValue") {
                self.initValue = dict["InitValue"] as! String
            }
            if dict.keys.contains("Modifier") {
                self.modifier = dict["Modifier"] as! String
            }
            if dict.keys.contains("NodeGroupId") {
                self.nodeGroupId = dict["NodeGroupId"] as! String
            }
            if dict.keys.contains("NodeId") {
                self.nodeId = dict["NodeId"] as! String
            }
            if dict.keys.contains("UpdateTime") {
                self.updateTime = dict["UpdateTime"] as! Int64
            }
        }
    }
    public var applicationConfigs: [ListApplicationConfigsResponseBody.ApplicationConfigs]?

    public var maxResults: Int32?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationConfigs != nil {
            var tmp : [Any] = []
            for k in self.applicationConfigs! {
                tmp.append(k.toMap())
            }
            map["ApplicationConfigs"] = tmp
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApplicationConfigs") {
            var tmp : [ListApplicationConfigsResponseBody.ApplicationConfigs] = []
            for v in dict["ApplicationConfigs"] as! [Any] {
                var model = ListApplicationConfigsResponseBody.ApplicationConfigs()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.applicationConfigs = tmp
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListApplicationConfigsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListApplicationConfigsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListApplicationConfigsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListApplicationsRequest : Tea.TeaModel {
    public var applicationNames: [String]?

    public var clusterId: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationNames != nil {
            map["ApplicationNames"] = self.applicationNames!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApplicationNames") {
            self.applicationNames = dict["ApplicationNames"] as! [String]
        }
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ListApplicationsResponseBody : Tea.TeaModel {
    public class Applications : Tea.TeaModel {
        public var applicationName: String?

        public var applicationState: String?

        public var applicationVersion: String?

        public var communityVersion: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.applicationName != nil {
                map["ApplicationName"] = self.applicationName!
            }
            if self.applicationState != nil {
                map["ApplicationState"] = self.applicationState!
            }
            if self.applicationVersion != nil {
                map["ApplicationVersion"] = self.applicationVersion!
            }
            if self.communityVersion != nil {
                map["CommunityVersion"] = self.communityVersion!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApplicationName") {
                self.applicationName = dict["ApplicationName"] as! String
            }
            if dict.keys.contains("ApplicationState") {
                self.applicationState = dict["ApplicationState"] as! String
            }
            if dict.keys.contains("ApplicationVersion") {
                self.applicationVersion = dict["ApplicationVersion"] as! String
            }
            if dict.keys.contains("CommunityVersion") {
                self.communityVersion = dict["CommunityVersion"] as! String
            }
        }
    }
    public var applications: [ListApplicationsResponseBody.Applications]?

    public var maxResults: Int32?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applications != nil {
            var tmp : [Any] = []
            for k in self.applications! {
                tmp.append(k.toMap())
            }
            map["Applications"] = tmp
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Applications") {
            var tmp : [ListApplicationsResponseBody.Applications] = []
            for v in dict["Applications"] as! [Any] {
                var model = ListApplicationsResponseBody.Applications()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.applications = tmp
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListApplicationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListApplicationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListApplicationsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAutoScalingActivitiesRequest : Tea.TeaModel {
    public var clusterId: String?

    public var endTime: Int64?

    public var maxResults: Int32?

    public var nextToken: String?

    public var nodeGroupId: String?

    public var regionId: String?

    public var scalingActivityStates: [String]?

    public var scalingActivityType: String?

    public var scalingRuleName: String?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.nodeGroupId != nil {
            map["NodeGroupId"] = self.nodeGroupId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.scalingActivityStates != nil {
            map["ScalingActivityStates"] = self.scalingActivityStates!
        }
        if self.scalingActivityType != nil {
            map["ScalingActivityType"] = self.scalingActivityType!
        }
        if self.scalingRuleName != nil {
            map["ScalingRuleName"] = self.scalingRuleName!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("NodeGroupId") {
            self.nodeGroupId = dict["NodeGroupId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ScalingActivityStates") {
            self.scalingActivityStates = dict["ScalingActivityStates"] as! [String]
        }
        if dict.keys.contains("ScalingActivityType") {
            self.scalingActivityType = dict["ScalingActivityType"] as! String
        }
        if dict.keys.contains("ScalingRuleName") {
            self.scalingRuleName = dict["ScalingRuleName"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
    }
}

public class ListAutoScalingActivitiesResponseBody : Tea.TeaModel {
    public class ScalingActivities : Tea.TeaModel {
        public var activityId: String?

        public var activityState: String?

        public var activityType: String?

        public var clusterId: String?

        public var description_: String?

        public var endTime: Int64?

        public var expectNum: Int32?

        public var nodeGroupId: String?

        public var nodeGroupName: String?

        public var operationId: String?

        public var ruleName: String?

        public var startTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.activityId != nil {
                map["ActivityId"] = self.activityId!
            }
            if self.activityState != nil {
                map["ActivityState"] = self.activityState!
            }
            if self.activityType != nil {
                map["ActivityType"] = self.activityType!
            }
            if self.clusterId != nil {
                map["ClusterId"] = self.clusterId!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.expectNum != nil {
                map["ExpectNum"] = self.expectNum!
            }
            if self.nodeGroupId != nil {
                map["NodeGroupId"] = self.nodeGroupId!
            }
            if self.nodeGroupName != nil {
                map["NodeGroupName"] = self.nodeGroupName!
            }
            if self.operationId != nil {
                map["OperationId"] = self.operationId!
            }
            if self.ruleName != nil {
                map["RuleName"] = self.ruleName!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ActivityId") {
                self.activityId = dict["ActivityId"] as! String
            }
            if dict.keys.contains("ActivityState") {
                self.activityState = dict["ActivityState"] as! String
            }
            if dict.keys.contains("ActivityType") {
                self.activityType = dict["ActivityType"] as! String
            }
            if dict.keys.contains("ClusterId") {
                self.clusterId = dict["ClusterId"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("EndTime") {
                self.endTime = dict["EndTime"] as! Int64
            }
            if dict.keys.contains("ExpectNum") {
                self.expectNum = dict["ExpectNum"] as! Int32
            }
            if dict.keys.contains("NodeGroupId") {
                self.nodeGroupId = dict["NodeGroupId"] as! String
            }
            if dict.keys.contains("NodeGroupName") {
                self.nodeGroupName = dict["NodeGroupName"] as! String
            }
            if dict.keys.contains("OperationId") {
                self.operationId = dict["OperationId"] as! String
            }
            if dict.keys.contains("RuleName") {
                self.ruleName = dict["RuleName"] as! String
            }
            if dict.keys.contains("StartTime") {
                self.startTime = dict["StartTime"] as! Int64
            }
        }
    }
    public var maxResults: Int32?

    public var nextToken: String?

    public var requestId: String?

    public var scalingActivities: [ListAutoScalingActivitiesResponseBody.ScalingActivities]?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingActivities != nil {
            var tmp : [Any] = []
            for k in self.scalingActivities! {
                tmp.append(k.toMap())
            }
            map["ScalingActivities"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScalingActivities") {
            var tmp : [ListAutoScalingActivitiesResponseBody.ScalingActivities] = []
            for v in dict["ScalingActivities"] as! [Any] {
                var model = ListAutoScalingActivitiesResponseBody.ScalingActivities()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.scalingActivities = tmp
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListAutoScalingActivitiesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAutoScalingActivitiesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListAutoScalingActivitiesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListClustersRequest : Tea.TeaModel {
    public var clusterIds: [String]?

    public var clusterName: String?

    public var clusterStates: [String]?

    public var clusterTypes: [String]?

    public var maxResults: Int32?

    public var nextToken: String?

    public var paymentTypes: [String]?

    public var regionId: String?

    public var resourceGroupId: String?

    public var tags: [Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterIds != nil {
            map["ClusterIds"] = self.clusterIds!
        }
        if self.clusterName != nil {
            map["ClusterName"] = self.clusterName!
        }
        if self.clusterStates != nil {
            map["ClusterStates"] = self.clusterStates!
        }
        if self.clusterTypes != nil {
            map["ClusterTypes"] = self.clusterTypes!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.paymentTypes != nil {
            map["PaymentTypes"] = self.paymentTypes!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterIds") {
            self.clusterIds = dict["ClusterIds"] as! [String]
        }
        if dict.keys.contains("ClusterName") {
            self.clusterName = dict["ClusterName"] as! String
        }
        if dict.keys.contains("ClusterStates") {
            self.clusterStates = dict["ClusterStates"] as! [String]
        }
        if dict.keys.contains("ClusterTypes") {
            self.clusterTypes = dict["ClusterTypes"] as! [String]
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("PaymentTypes") {
            self.paymentTypes = dict["PaymentTypes"] as! [String]
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("Tags") {
            var tmp : [Tag] = []
            for v in dict["Tags"] as! [Any] {
                var model = Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
    }
}

public class ListClustersResponseBody : Tea.TeaModel {
    public var clusters: [ClusterSummary]?

    public var maxResults: Int32?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusters != nil {
            var tmp : [Any] = []
            for k in self.clusters! {
                tmp.append(k.toMap())
            }
            map["Clusters"] = tmp
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Clusters") {
            var tmp : [ClusterSummary] = []
            for v in dict["Clusters"] as! [Any] {
                var model = ClusterSummary()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.clusters = tmp
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListClustersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListClustersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListClustersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListComponentInstancesRequest : Tea.TeaModel {
    public var applicationNames: [String]?

    public var clusterId: String?

    public var componentNames: [String]?

    public var componentStates: [String]?

    public var maxResults: Int32?

    public var nextToken: String?

    public var nodeIds: [String]?

    public var nodeNames: [String]?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationNames != nil {
            map["ApplicationNames"] = self.applicationNames!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.componentNames != nil {
            map["ComponentNames"] = self.componentNames!
        }
        if self.componentStates != nil {
            map["ComponentStates"] = self.componentStates!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.nodeIds != nil {
            map["NodeIds"] = self.nodeIds!
        }
        if self.nodeNames != nil {
            map["NodeNames"] = self.nodeNames!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApplicationNames") {
            self.applicationNames = dict["ApplicationNames"] as! [String]
        }
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("ComponentNames") {
            self.componentNames = dict["ComponentNames"] as! [String]
        }
        if dict.keys.contains("ComponentStates") {
            self.componentStates = dict["ComponentStates"] as! [String]
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("NodeIds") {
            self.nodeIds = dict["NodeIds"] as! [String]
        }
        if dict.keys.contains("NodeNames") {
            self.nodeNames = dict["NodeNames"] as! [String]
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ListComponentInstancesResponseBody : Tea.TeaModel {
    public class ComponentInstances : Tea.TeaModel {
        public var applicationName: String?

        public var bizState: String?

        public var commissionState: String?

        public var componentInstanceState: String?

        public var componentName: String?

        public var createTime: Int64?

        public var desiredState: String?

        public var nodeId: String?

        public var nodeName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.applicationName != nil {
                map["ApplicationName"] = self.applicationName!
            }
            if self.bizState != nil {
                map["BizState"] = self.bizState!
            }
            if self.commissionState != nil {
                map["CommissionState"] = self.commissionState!
            }
            if self.componentInstanceState != nil {
                map["ComponentInstanceState"] = self.componentInstanceState!
            }
            if self.componentName != nil {
                map["ComponentName"] = self.componentName!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.desiredState != nil {
                map["DesiredState"] = self.desiredState!
            }
            if self.nodeId != nil {
                map["NodeId"] = self.nodeId!
            }
            if self.nodeName != nil {
                map["NodeName"] = self.nodeName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApplicationName") {
                self.applicationName = dict["ApplicationName"] as! String
            }
            if dict.keys.contains("BizState") {
                self.bizState = dict["BizState"] as! String
            }
            if dict.keys.contains("CommissionState") {
                self.commissionState = dict["CommissionState"] as! String
            }
            if dict.keys.contains("ComponentInstanceState") {
                self.componentInstanceState = dict["ComponentInstanceState"] as! String
            }
            if dict.keys.contains("ComponentName") {
                self.componentName = dict["ComponentName"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("DesiredState") {
                self.desiredState = dict["DesiredState"] as! String
            }
            if dict.keys.contains("NodeId") {
                self.nodeId = dict["NodeId"] as! String
            }
            if dict.keys.contains("NodeName") {
                self.nodeName = dict["NodeName"] as! String
            }
        }
    }
    public var componentInstances: [ListComponentInstancesResponseBody.ComponentInstances]?

    public var maxResults: Int32?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.componentInstances != nil {
            var tmp : [Any] = []
            for k in self.componentInstances! {
                tmp.append(k.toMap())
            }
            map["ComponentInstances"] = tmp
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ComponentInstances") {
            var tmp : [ListComponentInstancesResponseBody.ComponentInstances] = []
            for v in dict["ComponentInstances"] as! [Any] {
                var model = ListComponentInstancesResponseBody.ComponentInstances()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.componentInstances = tmp
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListComponentInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListComponentInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListComponentInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListComponentsRequest : Tea.TeaModel {
    public var applicationNames: [String]?

    public var clusterId: String?

    public var componentNames: [String]?

    public var componentStates: [String]?

    public var includeExpiredConfig: Bool?

    public var maxResults: Int32?

    public var nextToken: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationNames != nil {
            map["ApplicationNames"] = self.applicationNames!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.componentNames != nil {
            map["ComponentNames"] = self.componentNames!
        }
        if self.componentStates != nil {
            map["ComponentStates"] = self.componentStates!
        }
        if self.includeExpiredConfig != nil {
            map["IncludeExpiredConfig"] = self.includeExpiredConfig!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApplicationNames") {
            self.applicationNames = dict["ApplicationNames"] as! [String]
        }
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("ComponentNames") {
            self.componentNames = dict["ComponentNames"] as! [String]
        }
        if dict.keys.contains("ComponentStates") {
            self.componentStates = dict["ComponentStates"] as! [String]
        }
        if dict.keys.contains("IncludeExpiredConfig") {
            self.includeExpiredConfig = dict["IncludeExpiredConfig"] as! Bool
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ListComponentsResponseBody : Tea.TeaModel {
    public class Components : Tea.TeaModel {
        public var applicationName: String?

        public var attributes: [Attribute]?

        public var componentName: String?

        public var namespace: String?

        public var replica: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.applicationName != nil {
                map["ApplicationName"] = self.applicationName!
            }
            if self.attributes != nil {
                var tmp : [Any] = []
                for k in self.attributes! {
                    tmp.append(k.toMap())
                }
                map["Attributes"] = tmp
            }
            if self.componentName != nil {
                map["ComponentName"] = self.componentName!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.replica != nil {
                map["Replica"] = self.replica!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApplicationName") {
                self.applicationName = dict["ApplicationName"] as! String
            }
            if dict.keys.contains("Attributes") {
                var tmp : [Attribute] = []
                for v in dict["Attributes"] as! [Any] {
                    var model = Attribute()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.attributes = tmp
            }
            if dict.keys.contains("ComponentName") {
                self.componentName = dict["ComponentName"] as! String
            }
            if dict.keys.contains("Namespace") {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("Replica") {
                self.replica = dict["Replica"] as! Int32
            }
        }
    }
    public var components: [ListComponentsResponseBody.Components]?

    public var maxResults: Int32?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.components != nil {
            var tmp : [Any] = []
            for k in self.components! {
                tmp.append(k.toMap())
            }
            map["Components"] = tmp
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Components") {
            var tmp : [ListComponentsResponseBody.Components] = []
            for v in dict["Components"] as! [Any] {
                var model = ListComponentsResponseBody.Components()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.components = tmp
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListComponentsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListComponentsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListComponentsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDoctorApplicationsRequest : Tea.TeaModel {
    public var appIds: [String]?

    public var clusterId: String?

    public var dateTime: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var orderBy: String?

    public var orderType: String?

    public var queues: [String]?

    public var regionId: String?

    public var types: [String]?

    public var users: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appIds != nil {
            map["AppIds"] = self.appIds!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.dateTime != nil {
            map["DateTime"] = self.dateTime!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.orderType != nil {
            map["OrderType"] = self.orderType!
        }
        if self.queues != nil {
            map["Queues"] = self.queues!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.types != nil {
            map["Types"] = self.types!
        }
        if self.users != nil {
            map["Users"] = self.users!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppIds") {
            self.appIds = dict["AppIds"] as! [String]
        }
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("DateTime") {
            self.dateTime = dict["DateTime"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OrderBy") {
            self.orderBy = dict["OrderBy"] as! String
        }
        if dict.keys.contains("OrderType") {
            self.orderType = dict["OrderType"] as! String
        }
        if dict.keys.contains("Queues") {
            self.queues = dict["Queues"] as! [String]
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Types") {
            self.types = dict["Types"] as! [String]
        }
        if dict.keys.contains("Users") {
            self.users = dict["Users"] as! [String]
        }
    }
}

public class ListDoctorApplicationsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Analysis : Tea.TeaModel {
            public var score: Int32?

            public var suggestion: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.score != nil {
                    map["Score"] = self.score!
                }
                if self.suggestion != nil {
                    map["Suggestion"] = self.suggestion!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Score") {
                    self.score = dict["Score"] as! Int32
                }
                if dict.keys.contains("Suggestion") {
                    self.suggestion = dict["Suggestion"] as! String
                }
            }
        }
        public class Metrics : Tea.TeaModel {
            public class MemSeconds : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class MemUtilization : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class VcoreSeconds : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class VcoreUtilization : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public var memSeconds: ListDoctorApplicationsResponseBody.Data.Metrics.MemSeconds?

            public var memUtilization: ListDoctorApplicationsResponseBody.Data.Metrics.MemUtilization?

            public var vcoreSeconds: ListDoctorApplicationsResponseBody.Data.Metrics.VcoreSeconds?

            public var vcoreUtilization: ListDoctorApplicationsResponseBody.Data.Metrics.VcoreUtilization?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.memSeconds?.validate()
                try self.memUtilization?.validate()
                try self.vcoreSeconds?.validate()
                try self.vcoreUtilization?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.memSeconds != nil {
                    map["MemSeconds"] = self.memSeconds?.toMap()
                }
                if self.memUtilization != nil {
                    map["MemUtilization"] = self.memUtilization?.toMap()
                }
                if self.vcoreSeconds != nil {
                    map["VcoreSeconds"] = self.vcoreSeconds?.toMap()
                }
                if self.vcoreUtilization != nil {
                    map["VcoreUtilization"] = self.vcoreUtilization?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("MemSeconds") {
                    var model = ListDoctorApplicationsResponseBody.Data.Metrics.MemSeconds()
                    model.fromMap(dict["MemSeconds"] as! [String: Any])
                    self.memSeconds = model
                }
                if dict.keys.contains("MemUtilization") {
                    var model = ListDoctorApplicationsResponseBody.Data.Metrics.MemUtilization()
                    model.fromMap(dict["MemUtilization"] as! [String: Any])
                    self.memUtilization = model
                }
                if dict.keys.contains("VcoreSeconds") {
                    var model = ListDoctorApplicationsResponseBody.Data.Metrics.VcoreSeconds()
                    model.fromMap(dict["VcoreSeconds"] as! [String: Any])
                    self.vcoreSeconds = model
                }
                if dict.keys.contains("VcoreUtilization") {
                    var model = ListDoctorApplicationsResponseBody.Data.Metrics.VcoreUtilization()
                    model.fromMap(dict["VcoreUtilization"] as! [String: Any])
                    self.vcoreUtilization = model
                }
            }
        }
        public var analysis: ListDoctorApplicationsResponseBody.Data.Analysis?

        public var appId: String?

        public var appName: String?

        public var endTime: Int64?

        public var ids: [String]?

        public var metrics: ListDoctorApplicationsResponseBody.Data.Metrics?

        public var querySql: String?

        public var queue: String?

        public var startTime: Int64?

        public var type: String?

        public var user: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.analysis?.validate()
            try self.metrics?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.analysis != nil {
                map["Analysis"] = self.analysis?.toMap()
            }
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.ids != nil {
                map["Ids"] = self.ids!
            }
            if self.metrics != nil {
                map["Metrics"] = self.metrics?.toMap()
            }
            if self.querySql != nil {
                map["QuerySql"] = self.querySql!
            }
            if self.queue != nil {
                map["Queue"] = self.queue!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.user != nil {
                map["User"] = self.user!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Analysis") {
                var model = ListDoctorApplicationsResponseBody.Data.Analysis()
                model.fromMap(dict["Analysis"] as! [String: Any])
                self.analysis = model
            }
            if dict.keys.contains("AppId") {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("AppName") {
                self.appName = dict["AppName"] as! String
            }
            if dict.keys.contains("EndTime") {
                self.endTime = dict["EndTime"] as! Int64
            }
            if dict.keys.contains("Ids") {
                self.ids = dict["Ids"] as! [String]
            }
            if dict.keys.contains("Metrics") {
                var model = ListDoctorApplicationsResponseBody.Data.Metrics()
                model.fromMap(dict["Metrics"] as! [String: Any])
                self.metrics = model
            }
            if dict.keys.contains("QuerySql") {
                self.querySql = dict["QuerySql"] as! String
            }
            if dict.keys.contains("Queue") {
                self.queue = dict["Queue"] as! String
            }
            if dict.keys.contains("StartTime") {
                self.startTime = dict["StartTime"] as! Int64
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("User") {
                self.user = dict["User"] as! String
            }
        }
    }
    public var data: [ListDoctorApplicationsResponseBody.Data]?

    public var maxResults: Int32?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var tmp : [ListDoctorApplicationsResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListDoctorApplicationsResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListDoctorApplicationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDoctorApplicationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDoctorApplicationsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDoctorComputeSummaryRequest : Tea.TeaModel {
    public var clusterId: String?

    public var componentTypes: [String]?

    public var dateTime: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var orderBy: String?

    public var orderType: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.componentTypes != nil {
            map["ComponentTypes"] = self.componentTypes!
        }
        if self.dateTime != nil {
            map["DateTime"] = self.dateTime!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.orderType != nil {
            map["OrderType"] = self.orderType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("ComponentTypes") {
            self.componentTypes = dict["ComponentTypes"] as! [String]
        }
        if dict.keys.contains("DateTime") {
            self.dateTime = dict["DateTime"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OrderBy") {
            self.orderBy = dict["OrderBy"] as! String
        }
        if dict.keys.contains("OrderType") {
            self.orderType = dict["OrderType"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ListDoctorComputeSummaryResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Analysis : Tea.TeaModel {
            public var healthyJobCount: Int64?

            public var needAttentionJobCount: Int64?

            public var score: Int32?

            public var scoreDayGrowthRatio: Double?

            public var subHealthyJobCount: Int64?

            public var unhealthyJobCount: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.healthyJobCount != nil {
                    map["HealthyJobCount"] = self.healthyJobCount!
                }
                if self.needAttentionJobCount != nil {
                    map["NeedAttentionJobCount"] = self.needAttentionJobCount!
                }
                if self.score != nil {
                    map["Score"] = self.score!
                }
                if self.scoreDayGrowthRatio != nil {
                    map["ScoreDayGrowthRatio"] = self.scoreDayGrowthRatio!
                }
                if self.subHealthyJobCount != nil {
                    map["SubHealthyJobCount"] = self.subHealthyJobCount!
                }
                if self.unhealthyJobCount != nil {
                    map["UnhealthyJobCount"] = self.unhealthyJobCount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("HealthyJobCount") {
                    self.healthyJobCount = dict["HealthyJobCount"] as! Int64
                }
                if dict.keys.contains("NeedAttentionJobCount") {
                    self.needAttentionJobCount = dict["NeedAttentionJobCount"] as! Int64
                }
                if dict.keys.contains("Score") {
                    self.score = dict["Score"] as! Int32
                }
                if dict.keys.contains("ScoreDayGrowthRatio") {
                    self.scoreDayGrowthRatio = dict["ScoreDayGrowthRatio"] as! Double
                }
                if dict.keys.contains("SubHealthyJobCount") {
                    self.subHealthyJobCount = dict["SubHealthyJobCount"] as! Int64
                }
                if dict.keys.contains("UnhealthyJobCount") {
                    self.unhealthyJobCount = dict["UnhealthyJobCount"] as! Int64
                }
            }
        }
        public class Metrics : Tea.TeaModel {
            public class MemSeconds : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class MemSecondsDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class MemUtilization : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class ReadSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class VcoreSeconds : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class VcoreSecondsDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class VcoreUtilization : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class WriteSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public var memSeconds: ListDoctorComputeSummaryResponseBody.Data.Metrics.MemSeconds?

            public var memSecondsDayGrowthRatio: ListDoctorComputeSummaryResponseBody.Data.Metrics.MemSecondsDayGrowthRatio?

            public var memUtilization: ListDoctorComputeSummaryResponseBody.Data.Metrics.MemUtilization?

            public var readSize: ListDoctorComputeSummaryResponseBody.Data.Metrics.ReadSize?

            public var vcoreSeconds: ListDoctorComputeSummaryResponseBody.Data.Metrics.VcoreSeconds?

            public var vcoreSecondsDayGrowthRatio: ListDoctorComputeSummaryResponseBody.Data.Metrics.VcoreSecondsDayGrowthRatio?

            public var vcoreUtilization: ListDoctorComputeSummaryResponseBody.Data.Metrics.VcoreUtilization?

            public var writeSize: ListDoctorComputeSummaryResponseBody.Data.Metrics.WriteSize?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.memSeconds?.validate()
                try self.memSecondsDayGrowthRatio?.validate()
                try self.memUtilization?.validate()
                try self.readSize?.validate()
                try self.vcoreSeconds?.validate()
                try self.vcoreSecondsDayGrowthRatio?.validate()
                try self.vcoreUtilization?.validate()
                try self.writeSize?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.memSeconds != nil {
                    map["MemSeconds"] = self.memSeconds?.toMap()
                }
                if self.memSecondsDayGrowthRatio != nil {
                    map["MemSecondsDayGrowthRatio"] = self.memSecondsDayGrowthRatio?.toMap()
                }
                if self.memUtilization != nil {
                    map["MemUtilization"] = self.memUtilization?.toMap()
                }
                if self.readSize != nil {
                    map["ReadSize"] = self.readSize?.toMap()
                }
                if self.vcoreSeconds != nil {
                    map["VcoreSeconds"] = self.vcoreSeconds?.toMap()
                }
                if self.vcoreSecondsDayGrowthRatio != nil {
                    map["VcoreSecondsDayGrowthRatio"] = self.vcoreSecondsDayGrowthRatio?.toMap()
                }
                if self.vcoreUtilization != nil {
                    map["VcoreUtilization"] = self.vcoreUtilization?.toMap()
                }
                if self.writeSize != nil {
                    map["WriteSize"] = self.writeSize?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("MemSeconds") {
                    var model = ListDoctorComputeSummaryResponseBody.Data.Metrics.MemSeconds()
                    model.fromMap(dict["MemSeconds"] as! [String: Any])
                    self.memSeconds = model
                }
                if dict.keys.contains("MemSecondsDayGrowthRatio") {
                    var model = ListDoctorComputeSummaryResponseBody.Data.Metrics.MemSecondsDayGrowthRatio()
                    model.fromMap(dict["MemSecondsDayGrowthRatio"] as! [String: Any])
                    self.memSecondsDayGrowthRatio = model
                }
                if dict.keys.contains("MemUtilization") {
                    var model = ListDoctorComputeSummaryResponseBody.Data.Metrics.MemUtilization()
                    model.fromMap(dict["MemUtilization"] as! [String: Any])
                    self.memUtilization = model
                }
                if dict.keys.contains("ReadSize") {
                    var model = ListDoctorComputeSummaryResponseBody.Data.Metrics.ReadSize()
                    model.fromMap(dict["ReadSize"] as! [String: Any])
                    self.readSize = model
                }
                if dict.keys.contains("VcoreSeconds") {
                    var model = ListDoctorComputeSummaryResponseBody.Data.Metrics.VcoreSeconds()
                    model.fromMap(dict["VcoreSeconds"] as! [String: Any])
                    self.vcoreSeconds = model
                }
                if dict.keys.contains("VcoreSecondsDayGrowthRatio") {
                    var model = ListDoctorComputeSummaryResponseBody.Data.Metrics.VcoreSecondsDayGrowthRatio()
                    model.fromMap(dict["VcoreSecondsDayGrowthRatio"] as! [String: Any])
                    self.vcoreSecondsDayGrowthRatio = model
                }
                if dict.keys.contains("VcoreUtilization") {
                    var model = ListDoctorComputeSummaryResponseBody.Data.Metrics.VcoreUtilization()
                    model.fromMap(dict["VcoreUtilization"] as! [String: Any])
                    self.vcoreUtilization = model
                }
                if dict.keys.contains("WriteSize") {
                    var model = ListDoctorComputeSummaryResponseBody.Data.Metrics.WriteSize()
                    model.fromMap(dict["WriteSize"] as! [String: Any])
                    self.writeSize = model
                }
            }
        }
        public var analysis: ListDoctorComputeSummaryResponseBody.Data.Analysis?

        public var componentName: String?

        public var metrics: ListDoctorComputeSummaryResponseBody.Data.Metrics?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.analysis?.validate()
            try self.metrics?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.analysis != nil {
                map["Analysis"] = self.analysis?.toMap()
            }
            if self.componentName != nil {
                map["ComponentName"] = self.componentName!
            }
            if self.metrics != nil {
                map["Metrics"] = self.metrics?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Analysis") {
                var model = ListDoctorComputeSummaryResponseBody.Data.Analysis()
                model.fromMap(dict["Analysis"] as! [String: Any])
                self.analysis = model
            }
            if dict.keys.contains("ComponentName") {
                self.componentName = dict["ComponentName"] as! String
            }
            if dict.keys.contains("Metrics") {
                var model = ListDoctorComputeSummaryResponseBody.Data.Metrics()
                model.fromMap(dict["Metrics"] as! [String: Any])
                self.metrics = model
            }
        }
    }
    public var data: [ListDoctorComputeSummaryResponseBody.Data]?

    public var maxResults: Int32?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var tmp : [ListDoctorComputeSummaryResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListDoctorComputeSummaryResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListDoctorComputeSummaryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDoctorComputeSummaryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDoctorComputeSummaryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDoctorHBaseRegionServersRequest : Tea.TeaModel {
    public var clusterId: String?

    public var dateTime: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var orderBy: String?

    public var orderType: String?

    public var regionId: String?

    public var regionServerHosts: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.dateTime != nil {
            map["DateTime"] = self.dateTime!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.orderType != nil {
            map["OrderType"] = self.orderType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.regionServerHosts != nil {
            map["RegionServerHosts"] = self.regionServerHosts!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("DateTime") {
            self.dateTime = dict["DateTime"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OrderBy") {
            self.orderBy = dict["OrderBy"] as! String
        }
        if dict.keys.contains("OrderType") {
            self.orderType = dict["OrderType"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RegionServerHosts") {
            self.regionServerHosts = dict["RegionServerHosts"] as! [String]
        }
    }
}

public class ListDoctorHBaseRegionServersResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Metrics : Tea.TeaModel {
            public class AvgGc : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class CacheRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class DailyReadRequest : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class DailyReadRequestDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class DailyWriteRequest : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class DailyWriteRequestDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class RegionCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class TotalReadRequest : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class TotalRequest : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class TotalWriteRequest : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public var avgGc: ListDoctorHBaseRegionServersResponseBody.Data.Metrics.AvgGc?

            public var cacheRatio: ListDoctorHBaseRegionServersResponseBody.Data.Metrics.CacheRatio?

            public var dailyReadRequest: ListDoctorHBaseRegionServersResponseBody.Data.Metrics.DailyReadRequest?

            public var dailyReadRequestDayGrowthRatio: ListDoctorHBaseRegionServersResponseBody.Data.Metrics.DailyReadRequestDayGrowthRatio?

            public var dailyWriteRequest: ListDoctorHBaseRegionServersResponseBody.Data.Metrics.DailyWriteRequest?

            public var dailyWriteRequestDayGrowthRatio: ListDoctorHBaseRegionServersResponseBody.Data.Metrics.DailyWriteRequestDayGrowthRatio?

            public var regionCount: ListDoctorHBaseRegionServersResponseBody.Data.Metrics.RegionCount?

            public var totalReadRequest: ListDoctorHBaseRegionServersResponseBody.Data.Metrics.TotalReadRequest?

            public var totalRequest: ListDoctorHBaseRegionServersResponseBody.Data.Metrics.TotalRequest?

            public var totalWriteRequest: ListDoctorHBaseRegionServersResponseBody.Data.Metrics.TotalWriteRequest?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.avgGc?.validate()
                try self.cacheRatio?.validate()
                try self.dailyReadRequest?.validate()
                try self.dailyReadRequestDayGrowthRatio?.validate()
                try self.dailyWriteRequest?.validate()
                try self.dailyWriteRequestDayGrowthRatio?.validate()
                try self.regionCount?.validate()
                try self.totalReadRequest?.validate()
                try self.totalRequest?.validate()
                try self.totalWriteRequest?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.avgGc != nil {
                    map["AvgGc"] = self.avgGc?.toMap()
                }
                if self.cacheRatio != nil {
                    map["CacheRatio"] = self.cacheRatio?.toMap()
                }
                if self.dailyReadRequest != nil {
                    map["DailyReadRequest"] = self.dailyReadRequest?.toMap()
                }
                if self.dailyReadRequestDayGrowthRatio != nil {
                    map["DailyReadRequestDayGrowthRatio"] = self.dailyReadRequestDayGrowthRatio?.toMap()
                }
                if self.dailyWriteRequest != nil {
                    map["DailyWriteRequest"] = self.dailyWriteRequest?.toMap()
                }
                if self.dailyWriteRequestDayGrowthRatio != nil {
                    map["DailyWriteRequestDayGrowthRatio"] = self.dailyWriteRequestDayGrowthRatio?.toMap()
                }
                if self.regionCount != nil {
                    map["RegionCount"] = self.regionCount?.toMap()
                }
                if self.totalReadRequest != nil {
                    map["TotalReadRequest"] = self.totalReadRequest?.toMap()
                }
                if self.totalRequest != nil {
                    map["TotalRequest"] = self.totalRequest?.toMap()
                }
                if self.totalWriteRequest != nil {
                    map["TotalWriteRequest"] = self.totalWriteRequest?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AvgGc") {
                    var model = ListDoctorHBaseRegionServersResponseBody.Data.Metrics.AvgGc()
                    model.fromMap(dict["AvgGc"] as! [String: Any])
                    self.avgGc = model
                }
                if dict.keys.contains("CacheRatio") {
                    var model = ListDoctorHBaseRegionServersResponseBody.Data.Metrics.CacheRatio()
                    model.fromMap(dict["CacheRatio"] as! [String: Any])
                    self.cacheRatio = model
                }
                if dict.keys.contains("DailyReadRequest") {
                    var model = ListDoctorHBaseRegionServersResponseBody.Data.Metrics.DailyReadRequest()
                    model.fromMap(dict["DailyReadRequest"] as! [String: Any])
                    self.dailyReadRequest = model
                }
                if dict.keys.contains("DailyReadRequestDayGrowthRatio") {
                    var model = ListDoctorHBaseRegionServersResponseBody.Data.Metrics.DailyReadRequestDayGrowthRatio()
                    model.fromMap(dict["DailyReadRequestDayGrowthRatio"] as! [String: Any])
                    self.dailyReadRequestDayGrowthRatio = model
                }
                if dict.keys.contains("DailyWriteRequest") {
                    var model = ListDoctorHBaseRegionServersResponseBody.Data.Metrics.DailyWriteRequest()
                    model.fromMap(dict["DailyWriteRequest"] as! [String: Any])
                    self.dailyWriteRequest = model
                }
                if dict.keys.contains("DailyWriteRequestDayGrowthRatio") {
                    var model = ListDoctorHBaseRegionServersResponseBody.Data.Metrics.DailyWriteRequestDayGrowthRatio()
                    model.fromMap(dict["DailyWriteRequestDayGrowthRatio"] as! [String: Any])
                    self.dailyWriteRequestDayGrowthRatio = model
                }
                if dict.keys.contains("RegionCount") {
                    var model = ListDoctorHBaseRegionServersResponseBody.Data.Metrics.RegionCount()
                    model.fromMap(dict["RegionCount"] as! [String: Any])
                    self.regionCount = model
                }
                if dict.keys.contains("TotalReadRequest") {
                    var model = ListDoctorHBaseRegionServersResponseBody.Data.Metrics.TotalReadRequest()
                    model.fromMap(dict["TotalReadRequest"] as! [String: Any])
                    self.totalReadRequest = model
                }
                if dict.keys.contains("TotalRequest") {
                    var model = ListDoctorHBaseRegionServersResponseBody.Data.Metrics.TotalRequest()
                    model.fromMap(dict["TotalRequest"] as! [String: Any])
                    self.totalRequest = model
                }
                if dict.keys.contains("TotalWriteRequest") {
                    var model = ListDoctorHBaseRegionServersResponseBody.Data.Metrics.TotalWriteRequest()
                    model.fromMap(dict["TotalWriteRequest"] as! [String: Any])
                    self.totalWriteRequest = model
                }
            }
        }
        public var metrics: ListDoctorHBaseRegionServersResponseBody.Data.Metrics?

        public var regionServerHost: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.metrics?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.metrics != nil {
                map["Metrics"] = self.metrics?.toMap()
            }
            if self.regionServerHost != nil {
                map["RegionServerHost"] = self.regionServerHost!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Metrics") {
                var model = ListDoctorHBaseRegionServersResponseBody.Data.Metrics()
                model.fromMap(dict["Metrics"] as! [String: Any])
                self.metrics = model
            }
            if dict.keys.contains("RegionServerHost") {
                self.regionServerHost = dict["RegionServerHost"] as! String
            }
        }
    }
    public var data: [ListDoctorHBaseRegionServersResponseBody.Data]?

    public var maxResults: Int32?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var tmp : [ListDoctorHBaseRegionServersResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListDoctorHBaseRegionServersResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListDoctorHBaseRegionServersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDoctorHBaseRegionServersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDoctorHBaseRegionServersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDoctorHBaseTablesRequest : Tea.TeaModel {
    public var clusterId: String?

    public var dateTime: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var orderBy: String?

    public var orderType: String?

    public var regionId: String?

    public var tableNames: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.dateTime != nil {
            map["DateTime"] = self.dateTime!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.orderType != nil {
            map["OrderType"] = self.orderType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.tableNames != nil {
            map["TableNames"] = self.tableNames!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("DateTime") {
            self.dateTime = dict["DateTime"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OrderBy") {
            self.orderBy = dict["OrderBy"] as! String
        }
        if dict.keys.contains("OrderType") {
            self.orderType = dict["OrderType"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("TableNames") {
            self.tableNames = dict["TableNames"] as! [String]
        }
    }
}

public class ListDoctorHBaseTablesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Analysis : Tea.TeaModel {
            public var readRequestHotspotRegionList: [String]?

            public var readRequestUnbalanceSuggestion: String?

            public var requestHotspotRegionList: [String]?

            public var requestUnbalanceSuggestion: String?

            public var tableScore: Int32?

            public var writeRequestHotspotRegionList: [String]?

            public var writeRequestUnbalanceSuggestion: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.readRequestHotspotRegionList != nil {
                    map["ReadRequestHotspotRegionList"] = self.readRequestHotspotRegionList!
                }
                if self.readRequestUnbalanceSuggestion != nil {
                    map["ReadRequestUnbalanceSuggestion"] = self.readRequestUnbalanceSuggestion!
                }
                if self.requestHotspotRegionList != nil {
                    map["RequestHotspotRegionList"] = self.requestHotspotRegionList!
                }
                if self.requestUnbalanceSuggestion != nil {
                    map["RequestUnbalanceSuggestion"] = self.requestUnbalanceSuggestion!
                }
                if self.tableScore != nil {
                    map["TableScore"] = self.tableScore!
                }
                if self.writeRequestHotspotRegionList != nil {
                    map["WriteRequestHotspotRegionList"] = self.writeRequestHotspotRegionList!
                }
                if self.writeRequestUnbalanceSuggestion != nil {
                    map["WriteRequestUnbalanceSuggestion"] = self.writeRequestUnbalanceSuggestion!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ReadRequestHotspotRegionList") {
                    self.readRequestHotspotRegionList = dict["ReadRequestHotspotRegionList"] as! [String]
                }
                if dict.keys.contains("ReadRequestUnbalanceSuggestion") {
                    self.readRequestUnbalanceSuggestion = dict["ReadRequestUnbalanceSuggestion"] as! String
                }
                if dict.keys.contains("RequestHotspotRegionList") {
                    self.requestHotspotRegionList = dict["RequestHotspotRegionList"] as! [String]
                }
                if dict.keys.contains("RequestUnbalanceSuggestion") {
                    self.requestUnbalanceSuggestion = dict["RequestUnbalanceSuggestion"] as! String
                }
                if dict.keys.contains("TableScore") {
                    self.tableScore = dict["TableScore"] as! Int32
                }
                if dict.keys.contains("WriteRequestHotspotRegionList") {
                    self.writeRequestHotspotRegionList = dict["WriteRequestHotspotRegionList"] as! [String]
                }
                if dict.keys.contains("WriteRequestUnbalanceSuggestion") {
                    self.writeRequestUnbalanceSuggestion = dict["WriteRequestUnbalanceSuggestion"] as! String
                }
            }
        }
        public class Metrics : Tea.TeaModel {
            public class ColdAccessDay : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class ColdConfigDay : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class ColdDataSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class DailyReadRequest : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class DailyReadRequestDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class DailyWriteRequest : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class DailyWriteRequestDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class FreezeConfigDay : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class FreezeDataSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class HotDataSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class Locality : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class ReadRequestBalance : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class RegionBalance : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class RegionCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class RegionCountDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class RegionServerCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class RequestBalance : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class StoreFileCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class StoreFileCountDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class TableSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class TableSizeDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class WarmConfigDay : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class WarmDataSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class WriteRequestBalance : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public var coldAccessDay: ListDoctorHBaseTablesResponseBody.Data.Metrics.ColdAccessDay?

            public var coldConfigDay: ListDoctorHBaseTablesResponseBody.Data.Metrics.ColdConfigDay?

            public var coldDataSize: ListDoctorHBaseTablesResponseBody.Data.Metrics.ColdDataSize?

            public var dailyReadRequest: ListDoctorHBaseTablesResponseBody.Data.Metrics.DailyReadRequest?

            public var dailyReadRequestDayGrowthRatio: ListDoctorHBaseTablesResponseBody.Data.Metrics.DailyReadRequestDayGrowthRatio?

            public var dailyWriteRequest: ListDoctorHBaseTablesResponseBody.Data.Metrics.DailyWriteRequest?

            public var dailyWriteRequestDayGrowthRatio: ListDoctorHBaseTablesResponseBody.Data.Metrics.DailyWriteRequestDayGrowthRatio?

            public var freezeConfigDay: ListDoctorHBaseTablesResponseBody.Data.Metrics.FreezeConfigDay?

            public var freezeDataSize: ListDoctorHBaseTablesResponseBody.Data.Metrics.FreezeDataSize?

            public var hotDataSize: ListDoctorHBaseTablesResponseBody.Data.Metrics.HotDataSize?

            public var locality: ListDoctorHBaseTablesResponseBody.Data.Metrics.Locality?

            public var readRequestBalance: ListDoctorHBaseTablesResponseBody.Data.Metrics.ReadRequestBalance?

            public var regionBalance: ListDoctorHBaseTablesResponseBody.Data.Metrics.RegionBalance?

            public var regionCount: ListDoctorHBaseTablesResponseBody.Data.Metrics.RegionCount?

            public var regionCountDayGrowthRatio: ListDoctorHBaseTablesResponseBody.Data.Metrics.RegionCountDayGrowthRatio?

            public var regionServerCount: ListDoctorHBaseTablesResponseBody.Data.Metrics.RegionServerCount?

            public var requestBalance: ListDoctorHBaseTablesResponseBody.Data.Metrics.RequestBalance?

            public var storeFileCount: ListDoctorHBaseTablesResponseBody.Data.Metrics.StoreFileCount?

            public var storeFileCountDayGrowthRatio: ListDoctorHBaseTablesResponseBody.Data.Metrics.StoreFileCountDayGrowthRatio?

            public var tableSize: ListDoctorHBaseTablesResponseBody.Data.Metrics.TableSize?

            public var tableSizeDayGrowthRatio: ListDoctorHBaseTablesResponseBody.Data.Metrics.TableSizeDayGrowthRatio?

            public var warmConfigDay: ListDoctorHBaseTablesResponseBody.Data.Metrics.WarmConfigDay?

            public var warmDataSize: ListDoctorHBaseTablesResponseBody.Data.Metrics.WarmDataSize?

            public var writeRequestBalance: ListDoctorHBaseTablesResponseBody.Data.Metrics.WriteRequestBalance?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.coldAccessDay?.validate()
                try self.coldConfigDay?.validate()
                try self.coldDataSize?.validate()
                try self.dailyReadRequest?.validate()
                try self.dailyReadRequestDayGrowthRatio?.validate()
                try self.dailyWriteRequest?.validate()
                try self.dailyWriteRequestDayGrowthRatio?.validate()
                try self.freezeConfigDay?.validate()
                try self.freezeDataSize?.validate()
                try self.hotDataSize?.validate()
                try self.locality?.validate()
                try self.readRequestBalance?.validate()
                try self.regionBalance?.validate()
                try self.regionCount?.validate()
                try self.regionCountDayGrowthRatio?.validate()
                try self.regionServerCount?.validate()
                try self.requestBalance?.validate()
                try self.storeFileCount?.validate()
                try self.storeFileCountDayGrowthRatio?.validate()
                try self.tableSize?.validate()
                try self.tableSizeDayGrowthRatio?.validate()
                try self.warmConfigDay?.validate()
                try self.warmDataSize?.validate()
                try self.writeRequestBalance?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.coldAccessDay != nil {
                    map["ColdAccessDay"] = self.coldAccessDay?.toMap()
                }
                if self.coldConfigDay != nil {
                    map["ColdConfigDay"] = self.coldConfigDay?.toMap()
                }
                if self.coldDataSize != nil {
                    map["ColdDataSize"] = self.coldDataSize?.toMap()
                }
                if self.dailyReadRequest != nil {
                    map["DailyReadRequest"] = self.dailyReadRequest?.toMap()
                }
                if self.dailyReadRequestDayGrowthRatio != nil {
                    map["DailyReadRequestDayGrowthRatio"] = self.dailyReadRequestDayGrowthRatio?.toMap()
                }
                if self.dailyWriteRequest != nil {
                    map["DailyWriteRequest"] = self.dailyWriteRequest?.toMap()
                }
                if self.dailyWriteRequestDayGrowthRatio != nil {
                    map["DailyWriteRequestDayGrowthRatio"] = self.dailyWriteRequestDayGrowthRatio?.toMap()
                }
                if self.freezeConfigDay != nil {
                    map["FreezeConfigDay"] = self.freezeConfigDay?.toMap()
                }
                if self.freezeDataSize != nil {
                    map["FreezeDataSize"] = self.freezeDataSize?.toMap()
                }
                if self.hotDataSize != nil {
                    map["HotDataSize"] = self.hotDataSize?.toMap()
                }
                if self.locality != nil {
                    map["Locality"] = self.locality?.toMap()
                }
                if self.readRequestBalance != nil {
                    map["ReadRequestBalance"] = self.readRequestBalance?.toMap()
                }
                if self.regionBalance != nil {
                    map["RegionBalance"] = self.regionBalance?.toMap()
                }
                if self.regionCount != nil {
                    map["RegionCount"] = self.regionCount?.toMap()
                }
                if self.regionCountDayGrowthRatio != nil {
                    map["RegionCountDayGrowthRatio"] = self.regionCountDayGrowthRatio?.toMap()
                }
                if self.regionServerCount != nil {
                    map["RegionServerCount"] = self.regionServerCount?.toMap()
                }
                if self.requestBalance != nil {
                    map["RequestBalance"] = self.requestBalance?.toMap()
                }
                if self.storeFileCount != nil {
                    map["StoreFileCount"] = self.storeFileCount?.toMap()
                }
                if self.storeFileCountDayGrowthRatio != nil {
                    map["StoreFileCountDayGrowthRatio"] = self.storeFileCountDayGrowthRatio?.toMap()
                }
                if self.tableSize != nil {
                    map["TableSize"] = self.tableSize?.toMap()
                }
                if self.tableSizeDayGrowthRatio != nil {
                    map["TableSizeDayGrowthRatio"] = self.tableSizeDayGrowthRatio?.toMap()
                }
                if self.warmConfigDay != nil {
                    map["WarmConfigDay"] = self.warmConfigDay?.toMap()
                }
                if self.warmDataSize != nil {
                    map["WarmDataSize"] = self.warmDataSize?.toMap()
                }
                if self.writeRequestBalance != nil {
                    map["WriteRequestBalance"] = self.writeRequestBalance?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ColdAccessDay") {
                    var model = ListDoctorHBaseTablesResponseBody.Data.Metrics.ColdAccessDay()
                    model.fromMap(dict["ColdAccessDay"] as! [String: Any])
                    self.coldAccessDay = model
                }
                if dict.keys.contains("ColdConfigDay") {
                    var model = ListDoctorHBaseTablesResponseBody.Data.Metrics.ColdConfigDay()
                    model.fromMap(dict["ColdConfigDay"] as! [String: Any])
                    self.coldConfigDay = model
                }
                if dict.keys.contains("ColdDataSize") {
                    var model = ListDoctorHBaseTablesResponseBody.Data.Metrics.ColdDataSize()
                    model.fromMap(dict["ColdDataSize"] as! [String: Any])
                    self.coldDataSize = model
                }
                if dict.keys.contains("DailyReadRequest") {
                    var model = ListDoctorHBaseTablesResponseBody.Data.Metrics.DailyReadRequest()
                    model.fromMap(dict["DailyReadRequest"] as! [String: Any])
                    self.dailyReadRequest = model
                }
                if dict.keys.contains("DailyReadRequestDayGrowthRatio") {
                    var model = ListDoctorHBaseTablesResponseBody.Data.Metrics.DailyReadRequestDayGrowthRatio()
                    model.fromMap(dict["DailyReadRequestDayGrowthRatio"] as! [String: Any])
                    self.dailyReadRequestDayGrowthRatio = model
                }
                if dict.keys.contains("DailyWriteRequest") {
                    var model = ListDoctorHBaseTablesResponseBody.Data.Metrics.DailyWriteRequest()
                    model.fromMap(dict["DailyWriteRequest"] as! [String: Any])
                    self.dailyWriteRequest = model
                }
                if dict.keys.contains("DailyWriteRequestDayGrowthRatio") {
                    var model = ListDoctorHBaseTablesResponseBody.Data.Metrics.DailyWriteRequestDayGrowthRatio()
                    model.fromMap(dict["DailyWriteRequestDayGrowthRatio"] as! [String: Any])
                    self.dailyWriteRequestDayGrowthRatio = model
                }
                if dict.keys.contains("FreezeConfigDay") {
                    var model = ListDoctorHBaseTablesResponseBody.Data.Metrics.FreezeConfigDay()
                    model.fromMap(dict["FreezeConfigDay"] as! [String: Any])
                    self.freezeConfigDay = model
                }
                if dict.keys.contains("FreezeDataSize") {
                    var model = ListDoctorHBaseTablesResponseBody.Data.Metrics.FreezeDataSize()
                    model.fromMap(dict["FreezeDataSize"] as! [String: Any])
                    self.freezeDataSize = model
                }
                if dict.keys.contains("HotDataSize") {
                    var model = ListDoctorHBaseTablesResponseBody.Data.Metrics.HotDataSize()
                    model.fromMap(dict["HotDataSize"] as! [String: Any])
                    self.hotDataSize = model
                }
                if dict.keys.contains("Locality") {
                    var model = ListDoctorHBaseTablesResponseBody.Data.Metrics.Locality()
                    model.fromMap(dict["Locality"] as! [String: Any])
                    self.locality = model
                }
                if dict.keys.contains("ReadRequestBalance") {
                    var model = ListDoctorHBaseTablesResponseBody.Data.Metrics.ReadRequestBalance()
                    model.fromMap(dict["ReadRequestBalance"] as! [String: Any])
                    self.readRequestBalance = model
                }
                if dict.keys.contains("RegionBalance") {
                    var model = ListDoctorHBaseTablesResponseBody.Data.Metrics.RegionBalance()
                    model.fromMap(dict["RegionBalance"] as! [String: Any])
                    self.regionBalance = model
                }
                if dict.keys.contains("RegionCount") {
                    var model = ListDoctorHBaseTablesResponseBody.Data.Metrics.RegionCount()
                    model.fromMap(dict["RegionCount"] as! [String: Any])
                    self.regionCount = model
                }
                if dict.keys.contains("RegionCountDayGrowthRatio") {
                    var model = ListDoctorHBaseTablesResponseBody.Data.Metrics.RegionCountDayGrowthRatio()
                    model.fromMap(dict["RegionCountDayGrowthRatio"] as! [String: Any])
                    self.regionCountDayGrowthRatio = model
                }
                if dict.keys.contains("RegionServerCount") {
                    var model = ListDoctorHBaseTablesResponseBody.Data.Metrics.RegionServerCount()
                    model.fromMap(dict["RegionServerCount"] as! [String: Any])
                    self.regionServerCount = model
                }
                if dict.keys.contains("RequestBalance") {
                    var model = ListDoctorHBaseTablesResponseBody.Data.Metrics.RequestBalance()
                    model.fromMap(dict["RequestBalance"] as! [String: Any])
                    self.requestBalance = model
                }
                if dict.keys.contains("StoreFileCount") {
                    var model = ListDoctorHBaseTablesResponseBody.Data.Metrics.StoreFileCount()
                    model.fromMap(dict["StoreFileCount"] as! [String: Any])
                    self.storeFileCount = model
                }
                if dict.keys.contains("StoreFileCountDayGrowthRatio") {
                    var model = ListDoctorHBaseTablesResponseBody.Data.Metrics.StoreFileCountDayGrowthRatio()
                    model.fromMap(dict["StoreFileCountDayGrowthRatio"] as! [String: Any])
                    self.storeFileCountDayGrowthRatio = model
                }
                if dict.keys.contains("TableSize") {
                    var model = ListDoctorHBaseTablesResponseBody.Data.Metrics.TableSize()
                    model.fromMap(dict["TableSize"] as! [String: Any])
                    self.tableSize = model
                }
                if dict.keys.contains("TableSizeDayGrowthRatio") {
                    var model = ListDoctorHBaseTablesResponseBody.Data.Metrics.TableSizeDayGrowthRatio()
                    model.fromMap(dict["TableSizeDayGrowthRatio"] as! [String: Any])
                    self.tableSizeDayGrowthRatio = model
                }
                if dict.keys.contains("WarmConfigDay") {
                    var model = ListDoctorHBaseTablesResponseBody.Data.Metrics.WarmConfigDay()
                    model.fromMap(dict["WarmConfigDay"] as! [String: Any])
                    self.warmConfigDay = model
                }
                if dict.keys.contains("WarmDataSize") {
                    var model = ListDoctorHBaseTablesResponseBody.Data.Metrics.WarmDataSize()
                    model.fromMap(dict["WarmDataSize"] as! [String: Any])
                    self.warmDataSize = model
                }
                if dict.keys.contains("WriteRequestBalance") {
                    var model = ListDoctorHBaseTablesResponseBody.Data.Metrics.WriteRequestBalance()
                    model.fromMap(dict["WriteRequestBalance"] as! [String: Any])
                    self.writeRequestBalance = model
                }
            }
        }
        public var analysis: ListDoctorHBaseTablesResponseBody.Data.Analysis?

        public var metrics: ListDoctorHBaseTablesResponseBody.Data.Metrics?

        public var tableName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.analysis?.validate()
            try self.metrics?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.analysis != nil {
                map["Analysis"] = self.analysis?.toMap()
            }
            if self.metrics != nil {
                map["Metrics"] = self.metrics?.toMap()
            }
            if self.tableName != nil {
                map["TableName"] = self.tableName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Analysis") {
                var model = ListDoctorHBaseTablesResponseBody.Data.Analysis()
                model.fromMap(dict["Analysis"] as! [String: Any])
                self.analysis = model
            }
            if dict.keys.contains("Metrics") {
                var model = ListDoctorHBaseTablesResponseBody.Data.Metrics()
                model.fromMap(dict["Metrics"] as! [String: Any])
                self.metrics = model
            }
            if dict.keys.contains("TableName") {
                self.tableName = dict["TableName"] as! String
            }
        }
    }
    public var data: [ListDoctorHBaseTablesResponseBody.Data]?

    public var maxResults: Int32?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var tmp : [ListDoctorHBaseTablesResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListDoctorHBaseTablesResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListDoctorHBaseTablesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDoctorHBaseTablesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDoctorHBaseTablesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDoctorHDFSDirectoriesRequest : Tea.TeaModel {
    public var clusterId: String?

    public var dateTime: String?

    public var dirPath: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var orderBy: String?

    public var orderType: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.dateTime != nil {
            map["DateTime"] = self.dateTime!
        }
        if self.dirPath != nil {
            map["DirPath"] = self.dirPath!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.orderType != nil {
            map["OrderType"] = self.orderType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("DateTime") {
            self.dateTime = dict["DateTime"] as! String
        }
        if dict.keys.contains("DirPath") {
            self.dirPath = dict["DirPath"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OrderBy") {
            self.orderBy = dict["OrderBy"] as! String
        }
        if dict.keys.contains("OrderType") {
            self.orderType = dict["OrderType"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ListDoctorHDFSDirectoriesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Metrics : Tea.TeaModel {
            public class ColdDataDayGrowthSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class ColdDataSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class ColdDataSizeDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class EmptyFileCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class EmptyFileCountDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class EmptyFileDayGrowthCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class FreezeDataDayGrowthSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class FreezeDataSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class FreezeDataSizeDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class HotDataDayGrowthSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class HotDataSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class HotDataSizeDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class LargeFileCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class LargeFileCountDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class LargeFileDayGrowthCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class MediumFileCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class MediumFileCountDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class MediumFileDayGrowthCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class SmallFileCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class SmallFileCountDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class SmallFileDayGrowthCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class TinyFileCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class TinyFileCountDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class TinyFileDayGrowthCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class TotalDataDayGrowthSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class TotalDataSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class TotalDataSizeDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class TotalFileCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class TotalFileCountDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class TotalFileDayGrowthCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class WarmDataDayGrowthSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class WarmDataSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class WarmDataSizeDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public var coldDataDayGrowthSize: ListDoctorHDFSDirectoriesResponseBody.Data.Metrics.ColdDataDayGrowthSize?

            public var coldDataSize: ListDoctorHDFSDirectoriesResponseBody.Data.Metrics.ColdDataSize?

            public var coldDataSizeDayGrowthRatio: ListDoctorHDFSDirectoriesResponseBody.Data.Metrics.ColdDataSizeDayGrowthRatio?

            public var emptyFileCount: ListDoctorHDFSDirectoriesResponseBody.Data.Metrics.EmptyFileCount?

            public var emptyFileCountDayGrowthRatio: ListDoctorHDFSDirectoriesResponseBody.Data.Metrics.EmptyFileCountDayGrowthRatio?

            public var emptyFileDayGrowthCount: ListDoctorHDFSDirectoriesResponseBody.Data.Metrics.EmptyFileDayGrowthCount?

            public var freezeDataDayGrowthSize: ListDoctorHDFSDirectoriesResponseBody.Data.Metrics.FreezeDataDayGrowthSize?

            public var freezeDataSize: ListDoctorHDFSDirectoriesResponseBody.Data.Metrics.FreezeDataSize?

            public var freezeDataSizeDayGrowthRatio: ListDoctorHDFSDirectoriesResponseBody.Data.Metrics.FreezeDataSizeDayGrowthRatio?

            public var hotDataDayGrowthSize: ListDoctorHDFSDirectoriesResponseBody.Data.Metrics.HotDataDayGrowthSize?

            public var hotDataSize: ListDoctorHDFSDirectoriesResponseBody.Data.Metrics.HotDataSize?

            public var hotDataSizeDayGrowthRatio: ListDoctorHDFSDirectoriesResponseBody.Data.Metrics.HotDataSizeDayGrowthRatio?

            public var largeFileCount: ListDoctorHDFSDirectoriesResponseBody.Data.Metrics.LargeFileCount?

            public var largeFileCountDayGrowthRatio: ListDoctorHDFSDirectoriesResponseBody.Data.Metrics.LargeFileCountDayGrowthRatio?

            public var largeFileDayGrowthCount: ListDoctorHDFSDirectoriesResponseBody.Data.Metrics.LargeFileDayGrowthCount?

            public var mediumFileCount: ListDoctorHDFSDirectoriesResponseBody.Data.Metrics.MediumFileCount?

            public var mediumFileCountDayGrowthRatio: ListDoctorHDFSDirectoriesResponseBody.Data.Metrics.MediumFileCountDayGrowthRatio?

            public var mediumFileDayGrowthCount: ListDoctorHDFSDirectoriesResponseBody.Data.Metrics.MediumFileDayGrowthCount?

            public var smallFileCount: ListDoctorHDFSDirectoriesResponseBody.Data.Metrics.SmallFileCount?

            public var smallFileCountDayGrowthRatio: ListDoctorHDFSDirectoriesResponseBody.Data.Metrics.SmallFileCountDayGrowthRatio?

            public var smallFileDayGrowthCount: ListDoctorHDFSDirectoriesResponseBody.Data.Metrics.SmallFileDayGrowthCount?

            public var tinyFileCount: ListDoctorHDFSDirectoriesResponseBody.Data.Metrics.TinyFileCount?

            public var tinyFileCountDayGrowthRatio: ListDoctorHDFSDirectoriesResponseBody.Data.Metrics.TinyFileCountDayGrowthRatio?

            public var tinyFileDayGrowthCount: ListDoctorHDFSDirectoriesResponseBody.Data.Metrics.TinyFileDayGrowthCount?

            public var totalDataDayGrowthSize: ListDoctorHDFSDirectoriesResponseBody.Data.Metrics.TotalDataDayGrowthSize?

            public var totalDataSize: ListDoctorHDFSDirectoriesResponseBody.Data.Metrics.TotalDataSize?

            public var totalDataSizeDayGrowthRatio: ListDoctorHDFSDirectoriesResponseBody.Data.Metrics.TotalDataSizeDayGrowthRatio?

            public var totalFileCount: ListDoctorHDFSDirectoriesResponseBody.Data.Metrics.TotalFileCount?

            public var totalFileCountDayGrowthRatio: ListDoctorHDFSDirectoriesResponseBody.Data.Metrics.TotalFileCountDayGrowthRatio?

            public var totalFileDayGrowthCount: ListDoctorHDFSDirectoriesResponseBody.Data.Metrics.TotalFileDayGrowthCount?

            public var warmDataDayGrowthSize: ListDoctorHDFSDirectoriesResponseBody.Data.Metrics.WarmDataDayGrowthSize?

            public var warmDataSize: ListDoctorHDFSDirectoriesResponseBody.Data.Metrics.WarmDataSize?

            public var warmDataSizeDayGrowthRatio: ListDoctorHDFSDirectoriesResponseBody.Data.Metrics.WarmDataSizeDayGrowthRatio?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.coldDataDayGrowthSize?.validate()
                try self.coldDataSize?.validate()
                try self.coldDataSizeDayGrowthRatio?.validate()
                try self.emptyFileCount?.validate()
                try self.emptyFileCountDayGrowthRatio?.validate()
                try self.emptyFileDayGrowthCount?.validate()
                try self.freezeDataDayGrowthSize?.validate()
                try self.freezeDataSize?.validate()
                try self.freezeDataSizeDayGrowthRatio?.validate()
                try self.hotDataDayGrowthSize?.validate()
                try self.hotDataSize?.validate()
                try self.hotDataSizeDayGrowthRatio?.validate()
                try self.largeFileCount?.validate()
                try self.largeFileCountDayGrowthRatio?.validate()
                try self.largeFileDayGrowthCount?.validate()
                try self.mediumFileCount?.validate()
                try self.mediumFileCountDayGrowthRatio?.validate()
                try self.mediumFileDayGrowthCount?.validate()
                try self.smallFileCount?.validate()
                try self.smallFileCountDayGrowthRatio?.validate()
                try self.smallFileDayGrowthCount?.validate()
                try self.tinyFileCount?.validate()
                try self.tinyFileCountDayGrowthRatio?.validate()
                try self.tinyFileDayGrowthCount?.validate()
                try self.totalDataDayGrowthSize?.validate()
                try self.totalDataSize?.validate()
                try self.totalDataSizeDayGrowthRatio?.validate()
                try self.totalFileCount?.validate()
                try self.totalFileCountDayGrowthRatio?.validate()
                try self.totalFileDayGrowthCount?.validate()
                try self.warmDataDayGrowthSize?.validate()
                try self.warmDataSize?.validate()
                try self.warmDataSizeDayGrowthRatio?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.coldDataDayGrowthSize != nil {
                    map["ColdDataDayGrowthSize"] = self.coldDataDayGrowthSize?.toMap()
                }
                if self.coldDataSize != nil {
                    map["ColdDataSize"] = self.coldDataSize?.toMap()
                }
                if self.coldDataSizeDayGrowthRatio != nil {
                    map["ColdDataSizeDayGrowthRatio"] = self.coldDataSizeDayGrowthRatio?.toMap()
                }
                if self.emptyFileCount != nil {
                    map["EmptyFileCount"] = self.emptyFileCount?.toMap()
                }
                if self.emptyFileCountDayGrowthRatio != nil {
                    map["EmptyFileCountDayGrowthRatio"] = self.emptyFileCountDayGrowthRatio?.toMap()
                }
                if self.emptyFileDayGrowthCount != nil {
                    map["EmptyFileDayGrowthCount"] = self.emptyFileDayGrowthCount?.toMap()
                }
                if self.freezeDataDayGrowthSize != nil {
                    map["FreezeDataDayGrowthSize"] = self.freezeDataDayGrowthSize?.toMap()
                }
                if self.freezeDataSize != nil {
                    map["FreezeDataSize"] = self.freezeDataSize?.toMap()
                }
                if self.freezeDataSizeDayGrowthRatio != nil {
                    map["FreezeDataSizeDayGrowthRatio"] = self.freezeDataSizeDayGrowthRatio?.toMap()
                }
                if self.hotDataDayGrowthSize != nil {
                    map["HotDataDayGrowthSize"] = self.hotDataDayGrowthSize?.toMap()
                }
                if self.hotDataSize != nil {
                    map["HotDataSize"] = self.hotDataSize?.toMap()
                }
                if self.hotDataSizeDayGrowthRatio != nil {
                    map["HotDataSizeDayGrowthRatio"] = self.hotDataSizeDayGrowthRatio?.toMap()
                }
                if self.largeFileCount != nil {
                    map["LargeFileCount"] = self.largeFileCount?.toMap()
                }
                if self.largeFileCountDayGrowthRatio != nil {
                    map["LargeFileCountDayGrowthRatio"] = self.largeFileCountDayGrowthRatio?.toMap()
                }
                if self.largeFileDayGrowthCount != nil {
                    map["LargeFileDayGrowthCount"] = self.largeFileDayGrowthCount?.toMap()
                }
                if self.mediumFileCount != nil {
                    map["MediumFileCount"] = self.mediumFileCount?.toMap()
                }
                if self.mediumFileCountDayGrowthRatio != nil {
                    map["MediumFileCountDayGrowthRatio"] = self.mediumFileCountDayGrowthRatio?.toMap()
                }
                if self.mediumFileDayGrowthCount != nil {
                    map["MediumFileDayGrowthCount"] = self.mediumFileDayGrowthCount?.toMap()
                }
                if self.smallFileCount != nil {
                    map["SmallFileCount"] = self.smallFileCount?.toMap()
                }
                if self.smallFileCountDayGrowthRatio != nil {
                    map["SmallFileCountDayGrowthRatio"] = self.smallFileCountDayGrowthRatio?.toMap()
                }
                if self.smallFileDayGrowthCount != nil {
                    map["SmallFileDayGrowthCount"] = self.smallFileDayGrowthCount?.toMap()
                }
                if self.tinyFileCount != nil {
                    map["TinyFileCount"] = self.tinyFileCount?.toMap()
                }
                if self.tinyFileCountDayGrowthRatio != nil {
                    map["TinyFileCountDayGrowthRatio"] = self.tinyFileCountDayGrowthRatio?.toMap()
                }
                if self.tinyFileDayGrowthCount != nil {
                    map["TinyFileDayGrowthCount"] = self.tinyFileDayGrowthCount?.toMap()
                }
                if self.totalDataDayGrowthSize != nil {
                    map["TotalDataDayGrowthSize"] = self.totalDataDayGrowthSize?.toMap()
                }
                if self.totalDataSize != nil {
                    map["TotalDataSize"] = self.totalDataSize?.toMap()
                }
                if self.totalDataSizeDayGrowthRatio != nil {
                    map["TotalDataSizeDayGrowthRatio"] = self.totalDataSizeDayGrowthRatio?.toMap()
                }
                if self.totalFileCount != nil {
                    map["TotalFileCount"] = self.totalFileCount?.toMap()
                }
                if self.totalFileCountDayGrowthRatio != nil {
                    map["TotalFileCountDayGrowthRatio"] = self.totalFileCountDayGrowthRatio?.toMap()
                }
                if self.totalFileDayGrowthCount != nil {
                    map["TotalFileDayGrowthCount"] = self.totalFileDayGrowthCount?.toMap()
                }
                if self.warmDataDayGrowthSize != nil {
                    map["WarmDataDayGrowthSize"] = self.warmDataDayGrowthSize?.toMap()
                }
                if self.warmDataSize != nil {
                    map["WarmDataSize"] = self.warmDataSize?.toMap()
                }
                if self.warmDataSizeDayGrowthRatio != nil {
                    map["WarmDataSizeDayGrowthRatio"] = self.warmDataSizeDayGrowthRatio?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ColdDataDayGrowthSize") {
                    var model = ListDoctorHDFSDirectoriesResponseBody.Data.Metrics.ColdDataDayGrowthSize()
                    model.fromMap(dict["ColdDataDayGrowthSize"] as! [String: Any])
                    self.coldDataDayGrowthSize = model
                }
                if dict.keys.contains("ColdDataSize") {
                    var model = ListDoctorHDFSDirectoriesResponseBody.Data.Metrics.ColdDataSize()
                    model.fromMap(dict["ColdDataSize"] as! [String: Any])
                    self.coldDataSize = model
                }
                if dict.keys.contains("ColdDataSizeDayGrowthRatio") {
                    var model = ListDoctorHDFSDirectoriesResponseBody.Data.Metrics.ColdDataSizeDayGrowthRatio()
                    model.fromMap(dict["ColdDataSizeDayGrowthRatio"] as! [String: Any])
                    self.coldDataSizeDayGrowthRatio = model
                }
                if dict.keys.contains("EmptyFileCount") {
                    var model = ListDoctorHDFSDirectoriesResponseBody.Data.Metrics.EmptyFileCount()
                    model.fromMap(dict["EmptyFileCount"] as! [String: Any])
                    self.emptyFileCount = model
                }
                if dict.keys.contains("EmptyFileCountDayGrowthRatio") {
                    var model = ListDoctorHDFSDirectoriesResponseBody.Data.Metrics.EmptyFileCountDayGrowthRatio()
                    model.fromMap(dict["EmptyFileCountDayGrowthRatio"] as! [String: Any])
                    self.emptyFileCountDayGrowthRatio = model
                }
                if dict.keys.contains("EmptyFileDayGrowthCount") {
                    var model = ListDoctorHDFSDirectoriesResponseBody.Data.Metrics.EmptyFileDayGrowthCount()
                    model.fromMap(dict["EmptyFileDayGrowthCount"] as! [String: Any])
                    self.emptyFileDayGrowthCount = model
                }
                if dict.keys.contains("FreezeDataDayGrowthSize") {
                    var model = ListDoctorHDFSDirectoriesResponseBody.Data.Metrics.FreezeDataDayGrowthSize()
                    model.fromMap(dict["FreezeDataDayGrowthSize"] as! [String: Any])
                    self.freezeDataDayGrowthSize = model
                }
                if dict.keys.contains("FreezeDataSize") {
                    var model = ListDoctorHDFSDirectoriesResponseBody.Data.Metrics.FreezeDataSize()
                    model.fromMap(dict["FreezeDataSize"] as! [String: Any])
                    self.freezeDataSize = model
                }
                if dict.keys.contains("FreezeDataSizeDayGrowthRatio") {
                    var model = ListDoctorHDFSDirectoriesResponseBody.Data.Metrics.FreezeDataSizeDayGrowthRatio()
                    model.fromMap(dict["FreezeDataSizeDayGrowthRatio"] as! [String: Any])
                    self.freezeDataSizeDayGrowthRatio = model
                }
                if dict.keys.contains("HotDataDayGrowthSize") {
                    var model = ListDoctorHDFSDirectoriesResponseBody.Data.Metrics.HotDataDayGrowthSize()
                    model.fromMap(dict["HotDataDayGrowthSize"] as! [String: Any])
                    self.hotDataDayGrowthSize = model
                }
                if dict.keys.contains("HotDataSize") {
                    var model = ListDoctorHDFSDirectoriesResponseBody.Data.Metrics.HotDataSize()
                    model.fromMap(dict["HotDataSize"] as! [String: Any])
                    self.hotDataSize = model
                }
                if dict.keys.contains("HotDataSizeDayGrowthRatio") {
                    var model = ListDoctorHDFSDirectoriesResponseBody.Data.Metrics.HotDataSizeDayGrowthRatio()
                    model.fromMap(dict["HotDataSizeDayGrowthRatio"] as! [String: Any])
                    self.hotDataSizeDayGrowthRatio = model
                }
                if dict.keys.contains("LargeFileCount") {
                    var model = ListDoctorHDFSDirectoriesResponseBody.Data.Metrics.LargeFileCount()
                    model.fromMap(dict["LargeFileCount"] as! [String: Any])
                    self.largeFileCount = model
                }
                if dict.keys.contains("LargeFileCountDayGrowthRatio") {
                    var model = ListDoctorHDFSDirectoriesResponseBody.Data.Metrics.LargeFileCountDayGrowthRatio()
                    model.fromMap(dict["LargeFileCountDayGrowthRatio"] as! [String: Any])
                    self.largeFileCountDayGrowthRatio = model
                }
                if dict.keys.contains("LargeFileDayGrowthCount") {
                    var model = ListDoctorHDFSDirectoriesResponseBody.Data.Metrics.LargeFileDayGrowthCount()
                    model.fromMap(dict["LargeFileDayGrowthCount"] as! [String: Any])
                    self.largeFileDayGrowthCount = model
                }
                if dict.keys.contains("MediumFileCount") {
                    var model = ListDoctorHDFSDirectoriesResponseBody.Data.Metrics.MediumFileCount()
                    model.fromMap(dict["MediumFileCount"] as! [String: Any])
                    self.mediumFileCount = model
                }
                if dict.keys.contains("MediumFileCountDayGrowthRatio") {
                    var model = ListDoctorHDFSDirectoriesResponseBody.Data.Metrics.MediumFileCountDayGrowthRatio()
                    model.fromMap(dict["MediumFileCountDayGrowthRatio"] as! [String: Any])
                    self.mediumFileCountDayGrowthRatio = model
                }
                if dict.keys.contains("MediumFileDayGrowthCount") {
                    var model = ListDoctorHDFSDirectoriesResponseBody.Data.Metrics.MediumFileDayGrowthCount()
                    model.fromMap(dict["MediumFileDayGrowthCount"] as! [String: Any])
                    self.mediumFileDayGrowthCount = model
                }
                if dict.keys.contains("SmallFileCount") {
                    var model = ListDoctorHDFSDirectoriesResponseBody.Data.Metrics.SmallFileCount()
                    model.fromMap(dict["SmallFileCount"] as! [String: Any])
                    self.smallFileCount = model
                }
                if dict.keys.contains("SmallFileCountDayGrowthRatio") {
                    var model = ListDoctorHDFSDirectoriesResponseBody.Data.Metrics.SmallFileCountDayGrowthRatio()
                    model.fromMap(dict["SmallFileCountDayGrowthRatio"] as! [String: Any])
                    self.smallFileCountDayGrowthRatio = model
                }
                if dict.keys.contains("SmallFileDayGrowthCount") {
                    var model = ListDoctorHDFSDirectoriesResponseBody.Data.Metrics.SmallFileDayGrowthCount()
                    model.fromMap(dict["SmallFileDayGrowthCount"] as! [String: Any])
                    self.smallFileDayGrowthCount = model
                }
                if dict.keys.contains("TinyFileCount") {
                    var model = ListDoctorHDFSDirectoriesResponseBody.Data.Metrics.TinyFileCount()
                    model.fromMap(dict["TinyFileCount"] as! [String: Any])
                    self.tinyFileCount = model
                }
                if dict.keys.contains("TinyFileCountDayGrowthRatio") {
                    var model = ListDoctorHDFSDirectoriesResponseBody.Data.Metrics.TinyFileCountDayGrowthRatio()
                    model.fromMap(dict["TinyFileCountDayGrowthRatio"] as! [String: Any])
                    self.tinyFileCountDayGrowthRatio = model
                }
                if dict.keys.contains("TinyFileDayGrowthCount") {
                    var model = ListDoctorHDFSDirectoriesResponseBody.Data.Metrics.TinyFileDayGrowthCount()
                    model.fromMap(dict["TinyFileDayGrowthCount"] as! [String: Any])
                    self.tinyFileDayGrowthCount = model
                }
                if dict.keys.contains("TotalDataDayGrowthSize") {
                    var model = ListDoctorHDFSDirectoriesResponseBody.Data.Metrics.TotalDataDayGrowthSize()
                    model.fromMap(dict["TotalDataDayGrowthSize"] as! [String: Any])
                    self.totalDataDayGrowthSize = model
                }
                if dict.keys.contains("TotalDataSize") {
                    var model = ListDoctorHDFSDirectoriesResponseBody.Data.Metrics.TotalDataSize()
                    model.fromMap(dict["TotalDataSize"] as! [String: Any])
                    self.totalDataSize = model
                }
                if dict.keys.contains("TotalDataSizeDayGrowthRatio") {
                    var model = ListDoctorHDFSDirectoriesResponseBody.Data.Metrics.TotalDataSizeDayGrowthRatio()
                    model.fromMap(dict["TotalDataSizeDayGrowthRatio"] as! [String: Any])
                    self.totalDataSizeDayGrowthRatio = model
                }
                if dict.keys.contains("TotalFileCount") {
                    var model = ListDoctorHDFSDirectoriesResponseBody.Data.Metrics.TotalFileCount()
                    model.fromMap(dict["TotalFileCount"] as! [String: Any])
                    self.totalFileCount = model
                }
                if dict.keys.contains("TotalFileCountDayGrowthRatio") {
                    var model = ListDoctorHDFSDirectoriesResponseBody.Data.Metrics.TotalFileCountDayGrowthRatio()
                    model.fromMap(dict["TotalFileCountDayGrowthRatio"] as! [String: Any])
                    self.totalFileCountDayGrowthRatio = model
                }
                if dict.keys.contains("TotalFileDayGrowthCount") {
                    var model = ListDoctorHDFSDirectoriesResponseBody.Data.Metrics.TotalFileDayGrowthCount()
                    model.fromMap(dict["TotalFileDayGrowthCount"] as! [String: Any])
                    self.totalFileDayGrowthCount = model
                }
                if dict.keys.contains("WarmDataDayGrowthSize") {
                    var model = ListDoctorHDFSDirectoriesResponseBody.Data.Metrics.WarmDataDayGrowthSize()
                    model.fromMap(dict["WarmDataDayGrowthSize"] as! [String: Any])
                    self.warmDataDayGrowthSize = model
                }
                if dict.keys.contains("WarmDataSize") {
                    var model = ListDoctorHDFSDirectoriesResponseBody.Data.Metrics.WarmDataSize()
                    model.fromMap(dict["WarmDataSize"] as! [String: Any])
                    self.warmDataSize = model
                }
                if dict.keys.contains("WarmDataSizeDayGrowthRatio") {
                    var model = ListDoctorHDFSDirectoriesResponseBody.Data.Metrics.WarmDataSizeDayGrowthRatio()
                    model.fromMap(dict["WarmDataSizeDayGrowthRatio"] as! [String: Any])
                    self.warmDataSizeDayGrowthRatio = model
                }
            }
        }
        public var depth: Int32?

        public var dirPath: String?

        public var group: String?

        public var metrics: ListDoctorHDFSDirectoriesResponseBody.Data.Metrics?

        public var user: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.metrics?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.depth != nil {
                map["Depth"] = self.depth!
            }
            if self.dirPath != nil {
                map["DirPath"] = self.dirPath!
            }
            if self.group != nil {
                map["Group"] = self.group!
            }
            if self.metrics != nil {
                map["Metrics"] = self.metrics?.toMap()
            }
            if self.user != nil {
                map["User"] = self.user!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Depth") {
                self.depth = dict["Depth"] as! Int32
            }
            if dict.keys.contains("DirPath") {
                self.dirPath = dict["DirPath"] as! String
            }
            if dict.keys.contains("Group") {
                self.group = dict["Group"] as! String
            }
            if dict.keys.contains("Metrics") {
                var model = ListDoctorHDFSDirectoriesResponseBody.Data.Metrics()
                model.fromMap(dict["Metrics"] as! [String: Any])
                self.metrics = model
            }
            if dict.keys.contains("User") {
                self.user = dict["User"] as! String
            }
        }
    }
    public var data: [ListDoctorHDFSDirectoriesResponseBody.Data]?

    public var maxResults: Int32?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var tmp : [ListDoctorHDFSDirectoriesResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListDoctorHDFSDirectoriesResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListDoctorHDFSDirectoriesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDoctorHDFSDirectoriesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDoctorHDFSDirectoriesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDoctorHDFSUGIRequest : Tea.TeaModel {
    public var clusterId: String?

    public var dateTime: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var orderBy: String?

    public var orderType: String?

    public var regionId: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.dateTime != nil {
            map["DateTime"] = self.dateTime!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.orderType != nil {
            map["OrderType"] = self.orderType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("DateTime") {
            self.dateTime = dict["DateTime"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OrderBy") {
            self.orderBy = dict["OrderBy"] as! String
        }
        if dict.keys.contains("OrderType") {
            self.orderType = dict["OrderType"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class ListDoctorHDFSUGIResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Metrics : Tea.TeaModel {
            public class TotalDataSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class TotalDirCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class TotalFileCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public var totalDataSize: ListDoctorHDFSUGIResponseBody.Data.Metrics.TotalDataSize?

            public var totalDirCount: ListDoctorHDFSUGIResponseBody.Data.Metrics.TotalDirCount?

            public var totalFileCount: ListDoctorHDFSUGIResponseBody.Data.Metrics.TotalFileCount?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.totalDataSize?.validate()
                try self.totalDirCount?.validate()
                try self.totalFileCount?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.totalDataSize != nil {
                    map["TotalDataSize"] = self.totalDataSize?.toMap()
                }
                if self.totalDirCount != nil {
                    map["TotalDirCount"] = self.totalDirCount?.toMap()
                }
                if self.totalFileCount != nil {
                    map["TotalFileCount"] = self.totalFileCount?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("TotalDataSize") {
                    var model = ListDoctorHDFSUGIResponseBody.Data.Metrics.TotalDataSize()
                    model.fromMap(dict["TotalDataSize"] as! [String: Any])
                    self.totalDataSize = model
                }
                if dict.keys.contains("TotalDirCount") {
                    var model = ListDoctorHDFSUGIResponseBody.Data.Metrics.TotalDirCount()
                    model.fromMap(dict["TotalDirCount"] as! [String: Any])
                    self.totalDirCount = model
                }
                if dict.keys.contains("TotalFileCount") {
                    var model = ListDoctorHDFSUGIResponseBody.Data.Metrics.TotalFileCount()
                    model.fromMap(dict["TotalFileCount"] as! [String: Any])
                    self.totalFileCount = model
                }
            }
        }
        public var metrics: ListDoctorHDFSUGIResponseBody.Data.Metrics?

        public var name: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.metrics?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.metrics != nil {
                map["Metrics"] = self.metrics?.toMap()
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Metrics") {
                var model = ListDoctorHDFSUGIResponseBody.Data.Metrics()
                model.fromMap(dict["Metrics"] as! [String: Any])
                self.metrics = model
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
        }
    }
    public var data: [ListDoctorHDFSUGIResponseBody.Data]?

    public var maxResults: Int32?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var tmp : [ListDoctorHDFSUGIResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListDoctorHDFSUGIResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListDoctorHDFSUGIResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDoctorHDFSUGIResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDoctorHDFSUGIResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDoctorHiveDatabasesRequest : Tea.TeaModel {
    public var clusterId: String?

    public var databaseNames: [String]?

    public var dateTime: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var orderBy: String?

    public var orderType: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.databaseNames != nil {
            map["DatabaseNames"] = self.databaseNames!
        }
        if self.dateTime != nil {
            map["DateTime"] = self.dateTime!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.orderType != nil {
            map["OrderType"] = self.orderType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("DatabaseNames") {
            self.databaseNames = dict["DatabaseNames"] as! [String]
        }
        if dict.keys.contains("DateTime") {
            self.dateTime = dict["DateTime"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OrderBy") {
            self.orderBy = dict["OrderBy"] as! String
        }
        if dict.keys.contains("OrderType") {
            self.orderType = dict["OrderType"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ListDoctorHiveDatabasesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Analysis : Tea.TeaModel {
            public var hiveDistributionScore: Int32?

            public var hiveFormatScore: Int32?

            public var hiveFrequencyScore: Int32?

            public var hiveScore: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.hiveDistributionScore != nil {
                    map["HiveDistributionScore"] = self.hiveDistributionScore!
                }
                if self.hiveFormatScore != nil {
                    map["HiveFormatScore"] = self.hiveFormatScore!
                }
                if self.hiveFrequencyScore != nil {
                    map["HiveFrequencyScore"] = self.hiveFrequencyScore!
                }
                if self.hiveScore != nil {
                    map["HiveScore"] = self.hiveScore!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("HiveDistributionScore") {
                    self.hiveDistributionScore = dict["HiveDistributionScore"] as! Int32
                }
                if dict.keys.contains("HiveFormatScore") {
                    self.hiveFormatScore = dict["HiveFormatScore"] as! Int32
                }
                if dict.keys.contains("HiveFrequencyScore") {
                    self.hiveFrequencyScore = dict["HiveFrequencyScore"] as! Int32
                }
                if dict.keys.contains("HiveScore") {
                    self.hiveScore = dict["HiveScore"] as! Int32
                }
            }
        }
        public class Formats : Tea.TeaModel {
            public var formatDayGrowthSize: Int64?

            public var formatName: String?

            public var formatRatio: Double?

            public var formatSize: Int64?

            public var formatSizeDayGrowthRatio: Double?

            public var formatSizeUnit: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.formatDayGrowthSize != nil {
                    map["FormatDayGrowthSize"] = self.formatDayGrowthSize!
                }
                if self.formatName != nil {
                    map["FormatName"] = self.formatName!
                }
                if self.formatRatio != nil {
                    map["FormatRatio"] = self.formatRatio!
                }
                if self.formatSize != nil {
                    map["FormatSize"] = self.formatSize!
                }
                if self.formatSizeDayGrowthRatio != nil {
                    map["FormatSizeDayGrowthRatio"] = self.formatSizeDayGrowthRatio!
                }
                if self.formatSizeUnit != nil {
                    map["FormatSizeUnit"] = self.formatSizeUnit!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FormatDayGrowthSize") {
                    self.formatDayGrowthSize = dict["FormatDayGrowthSize"] as! Int64
                }
                if dict.keys.contains("FormatName") {
                    self.formatName = dict["FormatName"] as! String
                }
                if dict.keys.contains("FormatRatio") {
                    self.formatRatio = dict["FormatRatio"] as! Double
                }
                if dict.keys.contains("FormatSize") {
                    self.formatSize = dict["FormatSize"] as! Int64
                }
                if dict.keys.contains("FormatSizeDayGrowthRatio") {
                    self.formatSizeDayGrowthRatio = dict["FormatSizeDayGrowthRatio"] as! Double
                }
                if dict.keys.contains("FormatSizeUnit") {
                    self.formatSizeUnit = dict["FormatSizeUnit"] as! String
                }
            }
        }
        public class Metrics : Tea.TeaModel {
            public class ColdDataDayGrowthSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class ColdDataRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class ColdDataSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class ColdDataSizeDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class EmptyFileCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class EmptyFileCountDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class EmptyFileDayGrowthCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class EmptyFileRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class FreezeDataDayGrowthSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class FreezeDataRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class FreezeDataSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class FreezeDataSizeDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class HotDataDayGrowthSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class HotDataRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class HotDataSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class HotDataSizeDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class LargeFileCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class LargeFileCountDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class LargeFileDayGrowthCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class LargeFileRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class MediumFileCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class MediumFileCountDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class MediumFileDayGrowthCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class MediumFileRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class PartitionNum : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class SmallFileCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class SmallFileCountDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class SmallFileDayGrowthCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class SmallFileRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class TableCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class TinyFileCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class TinyFileCountDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class TinyFileDayGrowthCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class TinyFileRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class TotalDataDayGrowthSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class TotalDataSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class TotalDataSizeDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class TotalFileCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class TotalFileCountDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class TotalFileDayGrowthCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class WarmDataDayGrowthSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class WarmDataRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class WarmDataSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class WarmDataSizeDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public var coldDataDayGrowthSize: ListDoctorHiveDatabasesResponseBody.Data.Metrics.ColdDataDayGrowthSize?

            public var coldDataRatio: ListDoctorHiveDatabasesResponseBody.Data.Metrics.ColdDataRatio?

            public var coldDataSize: ListDoctorHiveDatabasesResponseBody.Data.Metrics.ColdDataSize?

            public var coldDataSizeDayGrowthRatio: ListDoctorHiveDatabasesResponseBody.Data.Metrics.ColdDataSizeDayGrowthRatio?

            public var emptyFileCount: ListDoctorHiveDatabasesResponseBody.Data.Metrics.EmptyFileCount?

            public var emptyFileCountDayGrowthRatio: ListDoctorHiveDatabasesResponseBody.Data.Metrics.EmptyFileCountDayGrowthRatio?

            public var emptyFileDayGrowthCount: ListDoctorHiveDatabasesResponseBody.Data.Metrics.EmptyFileDayGrowthCount?

            public var emptyFileRatio: ListDoctorHiveDatabasesResponseBody.Data.Metrics.EmptyFileRatio?

            public var freezeDataDayGrowthSize: ListDoctorHiveDatabasesResponseBody.Data.Metrics.FreezeDataDayGrowthSize?

            public var freezeDataRatio: ListDoctorHiveDatabasesResponseBody.Data.Metrics.FreezeDataRatio?

            public var freezeDataSize: ListDoctorHiveDatabasesResponseBody.Data.Metrics.FreezeDataSize?

            public var freezeDataSizeDayGrowthRatio: ListDoctorHiveDatabasesResponseBody.Data.Metrics.FreezeDataSizeDayGrowthRatio?

            public var hotDataDayGrowthSize: ListDoctorHiveDatabasesResponseBody.Data.Metrics.HotDataDayGrowthSize?

            public var hotDataRatio: ListDoctorHiveDatabasesResponseBody.Data.Metrics.HotDataRatio?

            public var hotDataSize: ListDoctorHiveDatabasesResponseBody.Data.Metrics.HotDataSize?

            public var hotDataSizeDayGrowthRatio: ListDoctorHiveDatabasesResponseBody.Data.Metrics.HotDataSizeDayGrowthRatio?

            public var largeFileCount: ListDoctorHiveDatabasesResponseBody.Data.Metrics.LargeFileCount?

            public var largeFileCountDayGrowthRatio: ListDoctorHiveDatabasesResponseBody.Data.Metrics.LargeFileCountDayGrowthRatio?

            public var largeFileDayGrowthCount: ListDoctorHiveDatabasesResponseBody.Data.Metrics.LargeFileDayGrowthCount?

            public var largeFileRatio: ListDoctorHiveDatabasesResponseBody.Data.Metrics.LargeFileRatio?

            public var mediumFileCount: ListDoctorHiveDatabasesResponseBody.Data.Metrics.MediumFileCount?

            public var mediumFileCountDayGrowthRatio: ListDoctorHiveDatabasesResponseBody.Data.Metrics.MediumFileCountDayGrowthRatio?

            public var mediumFileDayGrowthCount: ListDoctorHiveDatabasesResponseBody.Data.Metrics.MediumFileDayGrowthCount?

            public var mediumFileRatio: ListDoctorHiveDatabasesResponseBody.Data.Metrics.MediumFileRatio?

            public var partitionNum: ListDoctorHiveDatabasesResponseBody.Data.Metrics.PartitionNum?

            public var smallFileCount: ListDoctorHiveDatabasesResponseBody.Data.Metrics.SmallFileCount?

            public var smallFileCountDayGrowthRatio: ListDoctorHiveDatabasesResponseBody.Data.Metrics.SmallFileCountDayGrowthRatio?

            public var smallFileDayGrowthCount: ListDoctorHiveDatabasesResponseBody.Data.Metrics.SmallFileDayGrowthCount?

            public var smallFileRatio: ListDoctorHiveDatabasesResponseBody.Data.Metrics.SmallFileRatio?

            public var tableCount: ListDoctorHiveDatabasesResponseBody.Data.Metrics.TableCount?

            public var tinyFileCount: ListDoctorHiveDatabasesResponseBody.Data.Metrics.TinyFileCount?

            public var tinyFileCountDayGrowthRatio: ListDoctorHiveDatabasesResponseBody.Data.Metrics.TinyFileCountDayGrowthRatio?

            public var tinyFileDayGrowthCount: ListDoctorHiveDatabasesResponseBody.Data.Metrics.TinyFileDayGrowthCount?

            public var tinyFileRatio: ListDoctorHiveDatabasesResponseBody.Data.Metrics.TinyFileRatio?

            public var totalDataDayGrowthSize: ListDoctorHiveDatabasesResponseBody.Data.Metrics.TotalDataDayGrowthSize?

            public var totalDataSize: ListDoctorHiveDatabasesResponseBody.Data.Metrics.TotalDataSize?

            public var totalDataSizeDayGrowthRatio: ListDoctorHiveDatabasesResponseBody.Data.Metrics.TotalDataSizeDayGrowthRatio?

            public var totalFileCount: ListDoctorHiveDatabasesResponseBody.Data.Metrics.TotalFileCount?

            public var totalFileCountDayGrowthRatio: ListDoctorHiveDatabasesResponseBody.Data.Metrics.TotalFileCountDayGrowthRatio?

            public var totalFileDayGrowthCount: ListDoctorHiveDatabasesResponseBody.Data.Metrics.TotalFileDayGrowthCount?

            public var warmDataDayGrowthSize: ListDoctorHiveDatabasesResponseBody.Data.Metrics.WarmDataDayGrowthSize?

            public var warmDataRatio: ListDoctorHiveDatabasesResponseBody.Data.Metrics.WarmDataRatio?

            public var warmDataSize: ListDoctorHiveDatabasesResponseBody.Data.Metrics.WarmDataSize?

            public var warmDataSizeDayGrowthRatio: ListDoctorHiveDatabasesResponseBody.Data.Metrics.WarmDataSizeDayGrowthRatio?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.coldDataDayGrowthSize?.validate()
                try self.coldDataRatio?.validate()
                try self.coldDataSize?.validate()
                try self.coldDataSizeDayGrowthRatio?.validate()
                try self.emptyFileCount?.validate()
                try self.emptyFileCountDayGrowthRatio?.validate()
                try self.emptyFileDayGrowthCount?.validate()
                try self.emptyFileRatio?.validate()
                try self.freezeDataDayGrowthSize?.validate()
                try self.freezeDataRatio?.validate()
                try self.freezeDataSize?.validate()
                try self.freezeDataSizeDayGrowthRatio?.validate()
                try self.hotDataDayGrowthSize?.validate()
                try self.hotDataRatio?.validate()
                try self.hotDataSize?.validate()
                try self.hotDataSizeDayGrowthRatio?.validate()
                try self.largeFileCount?.validate()
                try self.largeFileCountDayGrowthRatio?.validate()
                try self.largeFileDayGrowthCount?.validate()
                try self.largeFileRatio?.validate()
                try self.mediumFileCount?.validate()
                try self.mediumFileCountDayGrowthRatio?.validate()
                try self.mediumFileDayGrowthCount?.validate()
                try self.mediumFileRatio?.validate()
                try self.partitionNum?.validate()
                try self.smallFileCount?.validate()
                try self.smallFileCountDayGrowthRatio?.validate()
                try self.smallFileDayGrowthCount?.validate()
                try self.smallFileRatio?.validate()
                try self.tableCount?.validate()
                try self.tinyFileCount?.validate()
                try self.tinyFileCountDayGrowthRatio?.validate()
                try self.tinyFileDayGrowthCount?.validate()
                try self.tinyFileRatio?.validate()
                try self.totalDataDayGrowthSize?.validate()
                try self.totalDataSize?.validate()
                try self.totalDataSizeDayGrowthRatio?.validate()
                try self.totalFileCount?.validate()
                try self.totalFileCountDayGrowthRatio?.validate()
                try self.totalFileDayGrowthCount?.validate()
                try self.warmDataDayGrowthSize?.validate()
                try self.warmDataRatio?.validate()
                try self.warmDataSize?.validate()
                try self.warmDataSizeDayGrowthRatio?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.coldDataDayGrowthSize != nil {
                    map["ColdDataDayGrowthSize"] = self.coldDataDayGrowthSize?.toMap()
                }
                if self.coldDataRatio != nil {
                    map["ColdDataRatio"] = self.coldDataRatio?.toMap()
                }
                if self.coldDataSize != nil {
                    map["ColdDataSize"] = self.coldDataSize?.toMap()
                }
                if self.coldDataSizeDayGrowthRatio != nil {
                    map["ColdDataSizeDayGrowthRatio"] = self.coldDataSizeDayGrowthRatio?.toMap()
                }
                if self.emptyFileCount != nil {
                    map["EmptyFileCount"] = self.emptyFileCount?.toMap()
                }
                if self.emptyFileCountDayGrowthRatio != nil {
                    map["EmptyFileCountDayGrowthRatio"] = self.emptyFileCountDayGrowthRatio?.toMap()
                }
                if self.emptyFileDayGrowthCount != nil {
                    map["EmptyFileDayGrowthCount"] = self.emptyFileDayGrowthCount?.toMap()
                }
                if self.emptyFileRatio != nil {
                    map["EmptyFileRatio"] = self.emptyFileRatio?.toMap()
                }
                if self.freezeDataDayGrowthSize != nil {
                    map["FreezeDataDayGrowthSize"] = self.freezeDataDayGrowthSize?.toMap()
                }
                if self.freezeDataRatio != nil {
                    map["FreezeDataRatio"] = self.freezeDataRatio?.toMap()
                }
                if self.freezeDataSize != nil {
                    map["FreezeDataSize"] = self.freezeDataSize?.toMap()
                }
                if self.freezeDataSizeDayGrowthRatio != nil {
                    map["FreezeDataSizeDayGrowthRatio"] = self.freezeDataSizeDayGrowthRatio?.toMap()
                }
                if self.hotDataDayGrowthSize != nil {
                    map["HotDataDayGrowthSize"] = self.hotDataDayGrowthSize?.toMap()
                }
                if self.hotDataRatio != nil {
                    map["HotDataRatio"] = self.hotDataRatio?.toMap()
                }
                if self.hotDataSize != nil {
                    map["HotDataSize"] = self.hotDataSize?.toMap()
                }
                if self.hotDataSizeDayGrowthRatio != nil {
                    map["HotDataSizeDayGrowthRatio"] = self.hotDataSizeDayGrowthRatio?.toMap()
                }
                if self.largeFileCount != nil {
                    map["LargeFileCount"] = self.largeFileCount?.toMap()
                }
                if self.largeFileCountDayGrowthRatio != nil {
                    map["LargeFileCountDayGrowthRatio"] = self.largeFileCountDayGrowthRatio?.toMap()
                }
                if self.largeFileDayGrowthCount != nil {
                    map["LargeFileDayGrowthCount"] = self.largeFileDayGrowthCount?.toMap()
                }
                if self.largeFileRatio != nil {
                    map["LargeFileRatio"] = self.largeFileRatio?.toMap()
                }
                if self.mediumFileCount != nil {
                    map["MediumFileCount"] = self.mediumFileCount?.toMap()
                }
                if self.mediumFileCountDayGrowthRatio != nil {
                    map["MediumFileCountDayGrowthRatio"] = self.mediumFileCountDayGrowthRatio?.toMap()
                }
                if self.mediumFileDayGrowthCount != nil {
                    map["MediumFileDayGrowthCount"] = self.mediumFileDayGrowthCount?.toMap()
                }
                if self.mediumFileRatio != nil {
                    map["MediumFileRatio"] = self.mediumFileRatio?.toMap()
                }
                if self.partitionNum != nil {
                    map["PartitionNum"] = self.partitionNum?.toMap()
                }
                if self.smallFileCount != nil {
                    map["SmallFileCount"] = self.smallFileCount?.toMap()
                }
                if self.smallFileCountDayGrowthRatio != nil {
                    map["SmallFileCountDayGrowthRatio"] = self.smallFileCountDayGrowthRatio?.toMap()
                }
                if self.smallFileDayGrowthCount != nil {
                    map["SmallFileDayGrowthCount"] = self.smallFileDayGrowthCount?.toMap()
                }
                if self.smallFileRatio != nil {
                    map["SmallFileRatio"] = self.smallFileRatio?.toMap()
                }
                if self.tableCount != nil {
                    map["TableCount"] = self.tableCount?.toMap()
                }
                if self.tinyFileCount != nil {
                    map["TinyFileCount"] = self.tinyFileCount?.toMap()
                }
                if self.tinyFileCountDayGrowthRatio != nil {
                    map["TinyFileCountDayGrowthRatio"] = self.tinyFileCountDayGrowthRatio?.toMap()
                }
                if self.tinyFileDayGrowthCount != nil {
                    map["TinyFileDayGrowthCount"] = self.tinyFileDayGrowthCount?.toMap()
                }
                if self.tinyFileRatio != nil {
                    map["TinyFileRatio"] = self.tinyFileRatio?.toMap()
                }
                if self.totalDataDayGrowthSize != nil {
                    map["TotalDataDayGrowthSize"] = self.totalDataDayGrowthSize?.toMap()
                }
                if self.totalDataSize != nil {
                    map["TotalDataSize"] = self.totalDataSize?.toMap()
                }
                if self.totalDataSizeDayGrowthRatio != nil {
                    map["TotalDataSizeDayGrowthRatio"] = self.totalDataSizeDayGrowthRatio?.toMap()
                }
                if self.totalFileCount != nil {
                    map["TotalFileCount"] = self.totalFileCount?.toMap()
                }
                if self.totalFileCountDayGrowthRatio != nil {
                    map["TotalFileCountDayGrowthRatio"] = self.totalFileCountDayGrowthRatio?.toMap()
                }
                if self.totalFileDayGrowthCount != nil {
                    map["TotalFileDayGrowthCount"] = self.totalFileDayGrowthCount?.toMap()
                }
                if self.warmDataDayGrowthSize != nil {
                    map["WarmDataDayGrowthSize"] = self.warmDataDayGrowthSize?.toMap()
                }
                if self.warmDataRatio != nil {
                    map["WarmDataRatio"] = self.warmDataRatio?.toMap()
                }
                if self.warmDataSize != nil {
                    map["WarmDataSize"] = self.warmDataSize?.toMap()
                }
                if self.warmDataSizeDayGrowthRatio != nil {
                    map["WarmDataSizeDayGrowthRatio"] = self.warmDataSizeDayGrowthRatio?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ColdDataDayGrowthSize") {
                    var model = ListDoctorHiveDatabasesResponseBody.Data.Metrics.ColdDataDayGrowthSize()
                    model.fromMap(dict["ColdDataDayGrowthSize"] as! [String: Any])
                    self.coldDataDayGrowthSize = model
                }
                if dict.keys.contains("ColdDataRatio") {
                    var model = ListDoctorHiveDatabasesResponseBody.Data.Metrics.ColdDataRatio()
                    model.fromMap(dict["ColdDataRatio"] as! [String: Any])
                    self.coldDataRatio = model
                }
                if dict.keys.contains("ColdDataSize") {
                    var model = ListDoctorHiveDatabasesResponseBody.Data.Metrics.ColdDataSize()
                    model.fromMap(dict["ColdDataSize"] as! [String: Any])
                    self.coldDataSize = model
                }
                if dict.keys.contains("ColdDataSizeDayGrowthRatio") {
                    var model = ListDoctorHiveDatabasesResponseBody.Data.Metrics.ColdDataSizeDayGrowthRatio()
                    model.fromMap(dict["ColdDataSizeDayGrowthRatio"] as! [String: Any])
                    self.coldDataSizeDayGrowthRatio = model
                }
                if dict.keys.contains("EmptyFileCount") {
                    var model = ListDoctorHiveDatabasesResponseBody.Data.Metrics.EmptyFileCount()
                    model.fromMap(dict["EmptyFileCount"] as! [String: Any])
                    self.emptyFileCount = model
                }
                if dict.keys.contains("EmptyFileCountDayGrowthRatio") {
                    var model = ListDoctorHiveDatabasesResponseBody.Data.Metrics.EmptyFileCountDayGrowthRatio()
                    model.fromMap(dict["EmptyFileCountDayGrowthRatio"] as! [String: Any])
                    self.emptyFileCountDayGrowthRatio = model
                }
                if dict.keys.contains("EmptyFileDayGrowthCount") {
                    var model = ListDoctorHiveDatabasesResponseBody.Data.Metrics.EmptyFileDayGrowthCount()
                    model.fromMap(dict["EmptyFileDayGrowthCount"] as! [String: Any])
                    self.emptyFileDayGrowthCount = model
                }
                if dict.keys.contains("EmptyFileRatio") {
                    var model = ListDoctorHiveDatabasesResponseBody.Data.Metrics.EmptyFileRatio()
                    model.fromMap(dict["EmptyFileRatio"] as! [String: Any])
                    self.emptyFileRatio = model
                }
                if dict.keys.contains("FreezeDataDayGrowthSize") {
                    var model = ListDoctorHiveDatabasesResponseBody.Data.Metrics.FreezeDataDayGrowthSize()
                    model.fromMap(dict["FreezeDataDayGrowthSize"] as! [String: Any])
                    self.freezeDataDayGrowthSize = model
                }
                if dict.keys.contains("FreezeDataRatio") {
                    var model = ListDoctorHiveDatabasesResponseBody.Data.Metrics.FreezeDataRatio()
                    model.fromMap(dict["FreezeDataRatio"] as! [String: Any])
                    self.freezeDataRatio = model
                }
                if dict.keys.contains("FreezeDataSize") {
                    var model = ListDoctorHiveDatabasesResponseBody.Data.Metrics.FreezeDataSize()
                    model.fromMap(dict["FreezeDataSize"] as! [String: Any])
                    self.freezeDataSize = model
                }
                if dict.keys.contains("FreezeDataSizeDayGrowthRatio") {
                    var model = ListDoctorHiveDatabasesResponseBody.Data.Metrics.FreezeDataSizeDayGrowthRatio()
                    model.fromMap(dict["FreezeDataSizeDayGrowthRatio"] as! [String: Any])
                    self.freezeDataSizeDayGrowthRatio = model
                }
                if dict.keys.contains("HotDataDayGrowthSize") {
                    var model = ListDoctorHiveDatabasesResponseBody.Data.Metrics.HotDataDayGrowthSize()
                    model.fromMap(dict["HotDataDayGrowthSize"] as! [String: Any])
                    self.hotDataDayGrowthSize = model
                }
                if dict.keys.contains("HotDataRatio") {
                    var model = ListDoctorHiveDatabasesResponseBody.Data.Metrics.HotDataRatio()
                    model.fromMap(dict["HotDataRatio"] as! [String: Any])
                    self.hotDataRatio = model
                }
                if dict.keys.contains("HotDataSize") {
                    var model = ListDoctorHiveDatabasesResponseBody.Data.Metrics.HotDataSize()
                    model.fromMap(dict["HotDataSize"] as! [String: Any])
                    self.hotDataSize = model
                }
                if dict.keys.contains("HotDataSizeDayGrowthRatio") {
                    var model = ListDoctorHiveDatabasesResponseBody.Data.Metrics.HotDataSizeDayGrowthRatio()
                    model.fromMap(dict["HotDataSizeDayGrowthRatio"] as! [String: Any])
                    self.hotDataSizeDayGrowthRatio = model
                }
                if dict.keys.contains("LargeFileCount") {
                    var model = ListDoctorHiveDatabasesResponseBody.Data.Metrics.LargeFileCount()
                    model.fromMap(dict["LargeFileCount"] as! [String: Any])
                    self.largeFileCount = model
                }
                if dict.keys.contains("LargeFileCountDayGrowthRatio") {
                    var model = ListDoctorHiveDatabasesResponseBody.Data.Metrics.LargeFileCountDayGrowthRatio()
                    model.fromMap(dict["LargeFileCountDayGrowthRatio"] as! [String: Any])
                    self.largeFileCountDayGrowthRatio = model
                }
                if dict.keys.contains("LargeFileDayGrowthCount") {
                    var model = ListDoctorHiveDatabasesResponseBody.Data.Metrics.LargeFileDayGrowthCount()
                    model.fromMap(dict["LargeFileDayGrowthCount"] as! [String: Any])
                    self.largeFileDayGrowthCount = model
                }
                if dict.keys.contains("LargeFileRatio") {
                    var model = ListDoctorHiveDatabasesResponseBody.Data.Metrics.LargeFileRatio()
                    model.fromMap(dict["LargeFileRatio"] as! [String: Any])
                    self.largeFileRatio = model
                }
                if dict.keys.contains("MediumFileCount") {
                    var model = ListDoctorHiveDatabasesResponseBody.Data.Metrics.MediumFileCount()
                    model.fromMap(dict["MediumFileCount"] as! [String: Any])
                    self.mediumFileCount = model
                }
                if dict.keys.contains("MediumFileCountDayGrowthRatio") {
                    var model = ListDoctorHiveDatabasesResponseBody.Data.Metrics.MediumFileCountDayGrowthRatio()
                    model.fromMap(dict["MediumFileCountDayGrowthRatio"] as! [String: Any])
                    self.mediumFileCountDayGrowthRatio = model
                }
                if dict.keys.contains("MediumFileDayGrowthCount") {
                    var model = ListDoctorHiveDatabasesResponseBody.Data.Metrics.MediumFileDayGrowthCount()
                    model.fromMap(dict["MediumFileDayGrowthCount"] as! [String: Any])
                    self.mediumFileDayGrowthCount = model
                }
                if dict.keys.contains("MediumFileRatio") {
                    var model = ListDoctorHiveDatabasesResponseBody.Data.Metrics.MediumFileRatio()
                    model.fromMap(dict["MediumFileRatio"] as! [String: Any])
                    self.mediumFileRatio = model
                }
                if dict.keys.contains("PartitionNum") {
                    var model = ListDoctorHiveDatabasesResponseBody.Data.Metrics.PartitionNum()
                    model.fromMap(dict["PartitionNum"] as! [String: Any])
                    self.partitionNum = model
                }
                if dict.keys.contains("SmallFileCount") {
                    var model = ListDoctorHiveDatabasesResponseBody.Data.Metrics.SmallFileCount()
                    model.fromMap(dict["SmallFileCount"] as! [String: Any])
                    self.smallFileCount = model
                }
                if dict.keys.contains("SmallFileCountDayGrowthRatio") {
                    var model = ListDoctorHiveDatabasesResponseBody.Data.Metrics.SmallFileCountDayGrowthRatio()
                    model.fromMap(dict["SmallFileCountDayGrowthRatio"] as! [String: Any])
                    self.smallFileCountDayGrowthRatio = model
                }
                if dict.keys.contains("SmallFileDayGrowthCount") {
                    var model = ListDoctorHiveDatabasesResponseBody.Data.Metrics.SmallFileDayGrowthCount()
                    model.fromMap(dict["SmallFileDayGrowthCount"] as! [String: Any])
                    self.smallFileDayGrowthCount = model
                }
                if dict.keys.contains("SmallFileRatio") {
                    var model = ListDoctorHiveDatabasesResponseBody.Data.Metrics.SmallFileRatio()
                    model.fromMap(dict["SmallFileRatio"] as! [String: Any])
                    self.smallFileRatio = model
                }
                if dict.keys.contains("TableCount") {
                    var model = ListDoctorHiveDatabasesResponseBody.Data.Metrics.TableCount()
                    model.fromMap(dict["TableCount"] as! [String: Any])
                    self.tableCount = model
                }
                if dict.keys.contains("TinyFileCount") {
                    var model = ListDoctorHiveDatabasesResponseBody.Data.Metrics.TinyFileCount()
                    model.fromMap(dict["TinyFileCount"] as! [String: Any])
                    self.tinyFileCount = model
                }
                if dict.keys.contains("TinyFileCountDayGrowthRatio") {
                    var model = ListDoctorHiveDatabasesResponseBody.Data.Metrics.TinyFileCountDayGrowthRatio()
                    model.fromMap(dict["TinyFileCountDayGrowthRatio"] as! [String: Any])
                    self.tinyFileCountDayGrowthRatio = model
                }
                if dict.keys.contains("TinyFileDayGrowthCount") {
                    var model = ListDoctorHiveDatabasesResponseBody.Data.Metrics.TinyFileDayGrowthCount()
                    model.fromMap(dict["TinyFileDayGrowthCount"] as! [String: Any])
                    self.tinyFileDayGrowthCount = model
                }
                if dict.keys.contains("TinyFileRatio") {
                    var model = ListDoctorHiveDatabasesResponseBody.Data.Metrics.TinyFileRatio()
                    model.fromMap(dict["TinyFileRatio"] as! [String: Any])
                    self.tinyFileRatio = model
                }
                if dict.keys.contains("TotalDataDayGrowthSize") {
                    var model = ListDoctorHiveDatabasesResponseBody.Data.Metrics.TotalDataDayGrowthSize()
                    model.fromMap(dict["TotalDataDayGrowthSize"] as! [String: Any])
                    self.totalDataDayGrowthSize = model
                }
                if dict.keys.contains("TotalDataSize") {
                    var model = ListDoctorHiveDatabasesResponseBody.Data.Metrics.TotalDataSize()
                    model.fromMap(dict["TotalDataSize"] as! [String: Any])
                    self.totalDataSize = model
                }
                if dict.keys.contains("TotalDataSizeDayGrowthRatio") {
                    var model = ListDoctorHiveDatabasesResponseBody.Data.Metrics.TotalDataSizeDayGrowthRatio()
                    model.fromMap(dict["TotalDataSizeDayGrowthRatio"] as! [String: Any])
                    self.totalDataSizeDayGrowthRatio = model
                }
                if dict.keys.contains("TotalFileCount") {
                    var model = ListDoctorHiveDatabasesResponseBody.Data.Metrics.TotalFileCount()
                    model.fromMap(dict["TotalFileCount"] as! [String: Any])
                    self.totalFileCount = model
                }
                if dict.keys.contains("TotalFileCountDayGrowthRatio") {
                    var model = ListDoctorHiveDatabasesResponseBody.Data.Metrics.TotalFileCountDayGrowthRatio()
                    model.fromMap(dict["TotalFileCountDayGrowthRatio"] as! [String: Any])
                    self.totalFileCountDayGrowthRatio = model
                }
                if dict.keys.contains("TotalFileDayGrowthCount") {
                    var model = ListDoctorHiveDatabasesResponseBody.Data.Metrics.TotalFileDayGrowthCount()
                    model.fromMap(dict["TotalFileDayGrowthCount"] as! [String: Any])
                    self.totalFileDayGrowthCount = model
                }
                if dict.keys.contains("WarmDataDayGrowthSize") {
                    var model = ListDoctorHiveDatabasesResponseBody.Data.Metrics.WarmDataDayGrowthSize()
                    model.fromMap(dict["WarmDataDayGrowthSize"] as! [String: Any])
                    self.warmDataDayGrowthSize = model
                }
                if dict.keys.contains("WarmDataRatio") {
                    var model = ListDoctorHiveDatabasesResponseBody.Data.Metrics.WarmDataRatio()
                    model.fromMap(dict["WarmDataRatio"] as! [String: Any])
                    self.warmDataRatio = model
                }
                if dict.keys.contains("WarmDataSize") {
                    var model = ListDoctorHiveDatabasesResponseBody.Data.Metrics.WarmDataSize()
                    model.fromMap(dict["WarmDataSize"] as! [String: Any])
                    self.warmDataSize = model
                }
                if dict.keys.contains("WarmDataSizeDayGrowthRatio") {
                    var model = ListDoctorHiveDatabasesResponseBody.Data.Metrics.WarmDataSizeDayGrowthRatio()
                    model.fromMap(dict["WarmDataSizeDayGrowthRatio"] as! [String: Any])
                    self.warmDataSizeDayGrowthRatio = model
                }
            }
        }
        public var analysis: ListDoctorHiveDatabasesResponseBody.Data.Analysis?

        public var databaseName: String?

        public var formats: [ListDoctorHiveDatabasesResponseBody.Data.Formats]?

        public var metrics: ListDoctorHiveDatabasesResponseBody.Data.Metrics?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.analysis?.validate()
            try self.metrics?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.analysis != nil {
                map["Analysis"] = self.analysis?.toMap()
            }
            if self.databaseName != nil {
                map["DatabaseName"] = self.databaseName!
            }
            if self.formats != nil {
                var tmp : [Any] = []
                for k in self.formats! {
                    tmp.append(k.toMap())
                }
                map["Formats"] = tmp
            }
            if self.metrics != nil {
                map["Metrics"] = self.metrics?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Analysis") {
                var model = ListDoctorHiveDatabasesResponseBody.Data.Analysis()
                model.fromMap(dict["Analysis"] as! [String: Any])
                self.analysis = model
            }
            if dict.keys.contains("DatabaseName") {
                self.databaseName = dict["DatabaseName"] as! String
            }
            if dict.keys.contains("Formats") {
                var tmp : [ListDoctorHiveDatabasesResponseBody.Data.Formats] = []
                for v in dict["Formats"] as! [Any] {
                    var model = ListDoctorHiveDatabasesResponseBody.Data.Formats()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.formats = tmp
            }
            if dict.keys.contains("Metrics") {
                var model = ListDoctorHiveDatabasesResponseBody.Data.Metrics()
                model.fromMap(dict["Metrics"] as! [String: Any])
                self.metrics = model
            }
        }
    }
    public var data: [ListDoctorHiveDatabasesResponseBody.Data]?

    public var maxResults: Int32?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var tmp : [ListDoctorHiveDatabasesResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListDoctorHiveDatabasesResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListDoctorHiveDatabasesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDoctorHiveDatabasesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDoctorHiveDatabasesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDoctorHiveTablesRequest : Tea.TeaModel {
    public var clusterId: String?

    public var dateTime: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var orderBy: String?

    public var orderType: String?

    public var regionId: String?

    public var tableNames: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.dateTime != nil {
            map["DateTime"] = self.dateTime!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.orderType != nil {
            map["OrderType"] = self.orderType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.tableNames != nil {
            map["TableNames"] = self.tableNames!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("DateTime") {
            self.dateTime = dict["DateTime"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OrderBy") {
            self.orderBy = dict["OrderBy"] as! String
        }
        if dict.keys.contains("OrderType") {
            self.orderType = dict["OrderType"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("TableNames") {
            self.tableNames = dict["TableNames"] as! [String]
        }
    }
}

public class ListDoctorHiveTablesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Analysis : Tea.TeaModel {
            public var hiveDistributionScore: Int32?

            public var hiveFormatScore: Int32?

            public var hiveFrequencyScore: Int32?

            public var hiveScore: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.hiveDistributionScore != nil {
                    map["HiveDistributionScore"] = self.hiveDistributionScore!
                }
                if self.hiveFormatScore != nil {
                    map["HiveFormatScore"] = self.hiveFormatScore!
                }
                if self.hiveFrequencyScore != nil {
                    map["HiveFrequencyScore"] = self.hiveFrequencyScore!
                }
                if self.hiveScore != nil {
                    map["HiveScore"] = self.hiveScore!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("HiveDistributionScore") {
                    self.hiveDistributionScore = dict["HiveDistributionScore"] as! Int32
                }
                if dict.keys.contains("HiveFormatScore") {
                    self.hiveFormatScore = dict["HiveFormatScore"] as! Int32
                }
                if dict.keys.contains("HiveFrequencyScore") {
                    self.hiveFrequencyScore = dict["HiveFrequencyScore"] as! Int32
                }
                if dict.keys.contains("HiveScore") {
                    self.hiveScore = dict["HiveScore"] as! Int32
                }
            }
        }
        public class Formats : Tea.TeaModel {
            public var formatDayGrowthSize: Int64?

            public var formatName: String?

            public var formatRatio: Double?

            public var formatSize: Int64?

            public var formatSizeDayGrowthRatio: Double?

            public var formatSizeUnit: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.formatDayGrowthSize != nil {
                    map["FormatDayGrowthSize"] = self.formatDayGrowthSize!
                }
                if self.formatName != nil {
                    map["FormatName"] = self.formatName!
                }
                if self.formatRatio != nil {
                    map["FormatRatio"] = self.formatRatio!
                }
                if self.formatSize != nil {
                    map["FormatSize"] = self.formatSize!
                }
                if self.formatSizeDayGrowthRatio != nil {
                    map["FormatSizeDayGrowthRatio"] = self.formatSizeDayGrowthRatio!
                }
                if self.formatSizeUnit != nil {
                    map["FormatSizeUnit"] = self.formatSizeUnit!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FormatDayGrowthSize") {
                    self.formatDayGrowthSize = dict["FormatDayGrowthSize"] as! Int64
                }
                if dict.keys.contains("FormatName") {
                    self.formatName = dict["FormatName"] as! String
                }
                if dict.keys.contains("FormatRatio") {
                    self.formatRatio = dict["FormatRatio"] as! Double
                }
                if dict.keys.contains("FormatSize") {
                    self.formatSize = dict["FormatSize"] as! Int64
                }
                if dict.keys.contains("FormatSizeDayGrowthRatio") {
                    self.formatSizeDayGrowthRatio = dict["FormatSizeDayGrowthRatio"] as! Double
                }
                if dict.keys.contains("FormatSizeUnit") {
                    self.formatSizeUnit = dict["FormatSizeUnit"] as! String
                }
            }
        }
        public class Metrics : Tea.TeaModel {
            public class ColdDataDayGrowthSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class ColdDataRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class ColdDataSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class ColdDataSizeDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class EmptyFileCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class EmptyFileCountDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class EmptyFileDayGrowthCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class EmptyFileRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class FreezeDataDayGrowthSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class FreezeDataRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class FreezeDataSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class FreezeDataSizeDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class HotDataDayGrowthSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class HotDataRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class HotDataSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class HotDataSizeDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class LargeFileCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class LargeFileCountDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class LargeFileDayGrowthCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class LargeFileRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class MediumFileCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class MediumFileCountDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class MediumFileDayGrowthCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class MediumFileRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class PartitionNum : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class SmallFileCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class SmallFileCountDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class SmallFileDayGrowthCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class SmallFileRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class TinyFileCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class TinyFileCountDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class TinyFileDayGrowthCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class TinyFileRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class TotalDataDayGrowthSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class TotalDataSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class TotalDataSizeDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class TotalFileCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class TotalFileCountDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class TotalFileDayGrowthCount : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class WarmDataDayGrowthSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class WarmDataRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class WarmDataSize : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class WarmDataSizeDayGrowthRatio : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public var coldDataDayGrowthSize: ListDoctorHiveTablesResponseBody.Data.Metrics.ColdDataDayGrowthSize?

            public var coldDataRatio: ListDoctorHiveTablesResponseBody.Data.Metrics.ColdDataRatio?

            public var coldDataSize: ListDoctorHiveTablesResponseBody.Data.Metrics.ColdDataSize?

            public var coldDataSizeDayGrowthRatio: ListDoctorHiveTablesResponseBody.Data.Metrics.ColdDataSizeDayGrowthRatio?

            public var emptyFileCount: ListDoctorHiveTablesResponseBody.Data.Metrics.EmptyFileCount?

            public var emptyFileCountDayGrowthRatio: ListDoctorHiveTablesResponseBody.Data.Metrics.EmptyFileCountDayGrowthRatio?

            public var emptyFileDayGrowthCount: ListDoctorHiveTablesResponseBody.Data.Metrics.EmptyFileDayGrowthCount?

            public var emptyFileRatio: ListDoctorHiveTablesResponseBody.Data.Metrics.EmptyFileRatio?

            public var freezeDataDayGrowthSize: ListDoctorHiveTablesResponseBody.Data.Metrics.FreezeDataDayGrowthSize?

            public var freezeDataRatio: ListDoctorHiveTablesResponseBody.Data.Metrics.FreezeDataRatio?

            public var freezeDataSize: ListDoctorHiveTablesResponseBody.Data.Metrics.FreezeDataSize?

            public var freezeDataSizeDayGrowthRatio: ListDoctorHiveTablesResponseBody.Data.Metrics.FreezeDataSizeDayGrowthRatio?

            public var hotDataDayGrowthSize: ListDoctorHiveTablesResponseBody.Data.Metrics.HotDataDayGrowthSize?

            public var hotDataRatio: ListDoctorHiveTablesResponseBody.Data.Metrics.HotDataRatio?

            public var hotDataSize: ListDoctorHiveTablesResponseBody.Data.Metrics.HotDataSize?

            public var hotDataSizeDayGrowthRatio: ListDoctorHiveTablesResponseBody.Data.Metrics.HotDataSizeDayGrowthRatio?

            public var largeFileCount: ListDoctorHiveTablesResponseBody.Data.Metrics.LargeFileCount?

            public var largeFileCountDayGrowthRatio: ListDoctorHiveTablesResponseBody.Data.Metrics.LargeFileCountDayGrowthRatio?

            public var largeFileDayGrowthCount: ListDoctorHiveTablesResponseBody.Data.Metrics.LargeFileDayGrowthCount?

            public var largeFileRatio: ListDoctorHiveTablesResponseBody.Data.Metrics.LargeFileRatio?

            public var mediumFileCount: ListDoctorHiveTablesResponseBody.Data.Metrics.MediumFileCount?

            public var mediumFileCountDayGrowthRatio: ListDoctorHiveTablesResponseBody.Data.Metrics.MediumFileCountDayGrowthRatio?

            public var mediumFileDayGrowthCount: ListDoctorHiveTablesResponseBody.Data.Metrics.MediumFileDayGrowthCount?

            public var mediumFileRatio: ListDoctorHiveTablesResponseBody.Data.Metrics.MediumFileRatio?

            public var partitionNum: ListDoctorHiveTablesResponseBody.Data.Metrics.PartitionNum?

            public var smallFileCount: ListDoctorHiveTablesResponseBody.Data.Metrics.SmallFileCount?

            public var smallFileCountDayGrowthRatio: ListDoctorHiveTablesResponseBody.Data.Metrics.SmallFileCountDayGrowthRatio?

            public var smallFileDayGrowthCount: ListDoctorHiveTablesResponseBody.Data.Metrics.SmallFileDayGrowthCount?

            public var smallFileRatio: ListDoctorHiveTablesResponseBody.Data.Metrics.SmallFileRatio?

            public var tinyFileCount: ListDoctorHiveTablesResponseBody.Data.Metrics.TinyFileCount?

            public var tinyFileCountDayGrowthRatio: ListDoctorHiveTablesResponseBody.Data.Metrics.TinyFileCountDayGrowthRatio?

            public var tinyFileDayGrowthCount: ListDoctorHiveTablesResponseBody.Data.Metrics.TinyFileDayGrowthCount?

            public var tinyFileRatio: ListDoctorHiveTablesResponseBody.Data.Metrics.TinyFileRatio?

            public var totalDataDayGrowthSize: ListDoctorHiveTablesResponseBody.Data.Metrics.TotalDataDayGrowthSize?

            public var totalDataSize: ListDoctorHiveTablesResponseBody.Data.Metrics.TotalDataSize?

            public var totalDataSizeDayGrowthRatio: ListDoctorHiveTablesResponseBody.Data.Metrics.TotalDataSizeDayGrowthRatio?

            public var totalFileCount: ListDoctorHiveTablesResponseBody.Data.Metrics.TotalFileCount?

            public var totalFileCountDayGrowthRatio: ListDoctorHiveTablesResponseBody.Data.Metrics.TotalFileCountDayGrowthRatio?

            public var totalFileDayGrowthCount: ListDoctorHiveTablesResponseBody.Data.Metrics.TotalFileDayGrowthCount?

            public var warmDataDayGrowthSize: ListDoctorHiveTablesResponseBody.Data.Metrics.WarmDataDayGrowthSize?

            public var warmDataRatio: ListDoctorHiveTablesResponseBody.Data.Metrics.WarmDataRatio?

            public var warmDataSize: ListDoctorHiveTablesResponseBody.Data.Metrics.WarmDataSize?

            public var warmDataSizeDayGrowthRatio: ListDoctorHiveTablesResponseBody.Data.Metrics.WarmDataSizeDayGrowthRatio?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.coldDataDayGrowthSize?.validate()
                try self.coldDataRatio?.validate()
                try self.coldDataSize?.validate()
                try self.coldDataSizeDayGrowthRatio?.validate()
                try self.emptyFileCount?.validate()
                try self.emptyFileCountDayGrowthRatio?.validate()
                try self.emptyFileDayGrowthCount?.validate()
                try self.emptyFileRatio?.validate()
                try self.freezeDataDayGrowthSize?.validate()
                try self.freezeDataRatio?.validate()
                try self.freezeDataSize?.validate()
                try self.freezeDataSizeDayGrowthRatio?.validate()
                try self.hotDataDayGrowthSize?.validate()
                try self.hotDataRatio?.validate()
                try self.hotDataSize?.validate()
                try self.hotDataSizeDayGrowthRatio?.validate()
                try self.largeFileCount?.validate()
                try self.largeFileCountDayGrowthRatio?.validate()
                try self.largeFileDayGrowthCount?.validate()
                try self.largeFileRatio?.validate()
                try self.mediumFileCount?.validate()
                try self.mediumFileCountDayGrowthRatio?.validate()
                try self.mediumFileDayGrowthCount?.validate()
                try self.mediumFileRatio?.validate()
                try self.partitionNum?.validate()
                try self.smallFileCount?.validate()
                try self.smallFileCountDayGrowthRatio?.validate()
                try self.smallFileDayGrowthCount?.validate()
                try self.smallFileRatio?.validate()
                try self.tinyFileCount?.validate()
                try self.tinyFileCountDayGrowthRatio?.validate()
                try self.tinyFileDayGrowthCount?.validate()
                try self.tinyFileRatio?.validate()
                try self.totalDataDayGrowthSize?.validate()
                try self.totalDataSize?.validate()
                try self.totalDataSizeDayGrowthRatio?.validate()
                try self.totalFileCount?.validate()
                try self.totalFileCountDayGrowthRatio?.validate()
                try self.totalFileDayGrowthCount?.validate()
                try self.warmDataDayGrowthSize?.validate()
                try self.warmDataRatio?.validate()
                try self.warmDataSize?.validate()
                try self.warmDataSizeDayGrowthRatio?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.coldDataDayGrowthSize != nil {
                    map["ColdDataDayGrowthSize"] = self.coldDataDayGrowthSize?.toMap()
                }
                if self.coldDataRatio != nil {
                    map["ColdDataRatio"] = self.coldDataRatio?.toMap()
                }
                if self.coldDataSize != nil {
                    map["ColdDataSize"] = self.coldDataSize?.toMap()
                }
                if self.coldDataSizeDayGrowthRatio != nil {
                    map["ColdDataSizeDayGrowthRatio"] = self.coldDataSizeDayGrowthRatio?.toMap()
                }
                if self.emptyFileCount != nil {
                    map["EmptyFileCount"] = self.emptyFileCount?.toMap()
                }
                if self.emptyFileCountDayGrowthRatio != nil {
                    map["EmptyFileCountDayGrowthRatio"] = self.emptyFileCountDayGrowthRatio?.toMap()
                }
                if self.emptyFileDayGrowthCount != nil {
                    map["EmptyFileDayGrowthCount"] = self.emptyFileDayGrowthCount?.toMap()
                }
                if self.emptyFileRatio != nil {
                    map["EmptyFileRatio"] = self.emptyFileRatio?.toMap()
                }
                if self.freezeDataDayGrowthSize != nil {
                    map["FreezeDataDayGrowthSize"] = self.freezeDataDayGrowthSize?.toMap()
                }
                if self.freezeDataRatio != nil {
                    map["FreezeDataRatio"] = self.freezeDataRatio?.toMap()
                }
                if self.freezeDataSize != nil {
                    map["FreezeDataSize"] = self.freezeDataSize?.toMap()
                }
                if self.freezeDataSizeDayGrowthRatio != nil {
                    map["FreezeDataSizeDayGrowthRatio"] = self.freezeDataSizeDayGrowthRatio?.toMap()
                }
                if self.hotDataDayGrowthSize != nil {
                    map["HotDataDayGrowthSize"] = self.hotDataDayGrowthSize?.toMap()
                }
                if self.hotDataRatio != nil {
                    map["HotDataRatio"] = self.hotDataRatio?.toMap()
                }
                if self.hotDataSize != nil {
                    map["HotDataSize"] = self.hotDataSize?.toMap()
                }
                if self.hotDataSizeDayGrowthRatio != nil {
                    map["HotDataSizeDayGrowthRatio"] = self.hotDataSizeDayGrowthRatio?.toMap()
                }
                if self.largeFileCount != nil {
                    map["LargeFileCount"] = self.largeFileCount?.toMap()
                }
                if self.largeFileCountDayGrowthRatio != nil {
                    map["LargeFileCountDayGrowthRatio"] = self.largeFileCountDayGrowthRatio?.toMap()
                }
                if self.largeFileDayGrowthCount != nil {
                    map["LargeFileDayGrowthCount"] = self.largeFileDayGrowthCount?.toMap()
                }
                if self.largeFileRatio != nil {
                    map["LargeFileRatio"] = self.largeFileRatio?.toMap()
                }
                if self.mediumFileCount != nil {
                    map["MediumFileCount"] = self.mediumFileCount?.toMap()
                }
                if self.mediumFileCountDayGrowthRatio != nil {
                    map["MediumFileCountDayGrowthRatio"] = self.mediumFileCountDayGrowthRatio?.toMap()
                }
                if self.mediumFileDayGrowthCount != nil {
                    map["MediumFileDayGrowthCount"] = self.mediumFileDayGrowthCount?.toMap()
                }
                if self.mediumFileRatio != nil {
                    map["MediumFileRatio"] = self.mediumFileRatio?.toMap()
                }
                if self.partitionNum != nil {
                    map["PartitionNum"] = self.partitionNum?.toMap()
                }
                if self.smallFileCount != nil {
                    map["SmallFileCount"] = self.smallFileCount?.toMap()
                }
                if self.smallFileCountDayGrowthRatio != nil {
                    map["SmallFileCountDayGrowthRatio"] = self.smallFileCountDayGrowthRatio?.toMap()
                }
                if self.smallFileDayGrowthCount != nil {
                    map["SmallFileDayGrowthCount"] = self.smallFileDayGrowthCount?.toMap()
                }
                if self.smallFileRatio != nil {
                    map["SmallFileRatio"] = self.smallFileRatio?.toMap()
                }
                if self.tinyFileCount != nil {
                    map["TinyFileCount"] = self.tinyFileCount?.toMap()
                }
                if self.tinyFileCountDayGrowthRatio != nil {
                    map["TinyFileCountDayGrowthRatio"] = self.tinyFileCountDayGrowthRatio?.toMap()
                }
                if self.tinyFileDayGrowthCount != nil {
                    map["TinyFileDayGrowthCount"] = self.tinyFileDayGrowthCount?.toMap()
                }
                if self.tinyFileRatio != nil {
                    map["TinyFileRatio"] = self.tinyFileRatio?.toMap()
                }
                if self.totalDataDayGrowthSize != nil {
                    map["TotalDataDayGrowthSize"] = self.totalDataDayGrowthSize?.toMap()
                }
                if self.totalDataSize != nil {
                    map["TotalDataSize"] = self.totalDataSize?.toMap()
                }
                if self.totalDataSizeDayGrowthRatio != nil {
                    map["TotalDataSizeDayGrowthRatio"] = self.totalDataSizeDayGrowthRatio?.toMap()
                }
                if self.totalFileCount != nil {
                    map["TotalFileCount"] = self.totalFileCount?.toMap()
                }
                if self.totalFileCountDayGrowthRatio != nil {
                    map["TotalFileCountDayGrowthRatio"] = self.totalFileCountDayGrowthRatio?.toMap()
                }
                if self.totalFileDayGrowthCount != nil {
                    map["TotalFileDayGrowthCount"] = self.totalFileDayGrowthCount?.toMap()
                }
                if self.warmDataDayGrowthSize != nil {
                    map["WarmDataDayGrowthSize"] = self.warmDataDayGrowthSize?.toMap()
                }
                if self.warmDataRatio != nil {
                    map["WarmDataRatio"] = self.warmDataRatio?.toMap()
                }
                if self.warmDataSize != nil {
                    map["WarmDataSize"] = self.warmDataSize?.toMap()
                }
                if self.warmDataSizeDayGrowthRatio != nil {
                    map["WarmDataSizeDayGrowthRatio"] = self.warmDataSizeDayGrowthRatio?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ColdDataDayGrowthSize") {
                    var model = ListDoctorHiveTablesResponseBody.Data.Metrics.ColdDataDayGrowthSize()
                    model.fromMap(dict["ColdDataDayGrowthSize"] as! [String: Any])
                    self.coldDataDayGrowthSize = model
                }
                if dict.keys.contains("ColdDataRatio") {
                    var model = ListDoctorHiveTablesResponseBody.Data.Metrics.ColdDataRatio()
                    model.fromMap(dict["ColdDataRatio"] as! [String: Any])
                    self.coldDataRatio = model
                }
                if dict.keys.contains("ColdDataSize") {
                    var model = ListDoctorHiveTablesResponseBody.Data.Metrics.ColdDataSize()
                    model.fromMap(dict["ColdDataSize"] as! [String: Any])
                    self.coldDataSize = model
                }
                if dict.keys.contains("ColdDataSizeDayGrowthRatio") {
                    var model = ListDoctorHiveTablesResponseBody.Data.Metrics.ColdDataSizeDayGrowthRatio()
                    model.fromMap(dict["ColdDataSizeDayGrowthRatio"] as! [String: Any])
                    self.coldDataSizeDayGrowthRatio = model
                }
                if dict.keys.contains("EmptyFileCount") {
                    var model = ListDoctorHiveTablesResponseBody.Data.Metrics.EmptyFileCount()
                    model.fromMap(dict["EmptyFileCount"] as! [String: Any])
                    self.emptyFileCount = model
                }
                if dict.keys.contains("EmptyFileCountDayGrowthRatio") {
                    var model = ListDoctorHiveTablesResponseBody.Data.Metrics.EmptyFileCountDayGrowthRatio()
                    model.fromMap(dict["EmptyFileCountDayGrowthRatio"] as! [String: Any])
                    self.emptyFileCountDayGrowthRatio = model
                }
                if dict.keys.contains("EmptyFileDayGrowthCount") {
                    var model = ListDoctorHiveTablesResponseBody.Data.Metrics.EmptyFileDayGrowthCount()
                    model.fromMap(dict["EmptyFileDayGrowthCount"] as! [String: Any])
                    self.emptyFileDayGrowthCount = model
                }
                if dict.keys.contains("EmptyFileRatio") {
                    var model = ListDoctorHiveTablesResponseBody.Data.Metrics.EmptyFileRatio()
                    model.fromMap(dict["EmptyFileRatio"] as! [String: Any])
                    self.emptyFileRatio = model
                }
                if dict.keys.contains("FreezeDataDayGrowthSize") {
                    var model = ListDoctorHiveTablesResponseBody.Data.Metrics.FreezeDataDayGrowthSize()
                    model.fromMap(dict["FreezeDataDayGrowthSize"] as! [String: Any])
                    self.freezeDataDayGrowthSize = model
                }
                if dict.keys.contains("FreezeDataRatio") {
                    var model = ListDoctorHiveTablesResponseBody.Data.Metrics.FreezeDataRatio()
                    model.fromMap(dict["FreezeDataRatio"] as! [String: Any])
                    self.freezeDataRatio = model
                }
                if dict.keys.contains("FreezeDataSize") {
                    var model = ListDoctorHiveTablesResponseBody.Data.Metrics.FreezeDataSize()
                    model.fromMap(dict["FreezeDataSize"] as! [String: Any])
                    self.freezeDataSize = model
                }
                if dict.keys.contains("FreezeDataSizeDayGrowthRatio") {
                    var model = ListDoctorHiveTablesResponseBody.Data.Metrics.FreezeDataSizeDayGrowthRatio()
                    model.fromMap(dict["FreezeDataSizeDayGrowthRatio"] as! [String: Any])
                    self.freezeDataSizeDayGrowthRatio = model
                }
                if dict.keys.contains("HotDataDayGrowthSize") {
                    var model = ListDoctorHiveTablesResponseBody.Data.Metrics.HotDataDayGrowthSize()
                    model.fromMap(dict["HotDataDayGrowthSize"] as! [String: Any])
                    self.hotDataDayGrowthSize = model
                }
                if dict.keys.contains("HotDataRatio") {
                    var model = ListDoctorHiveTablesResponseBody.Data.Metrics.HotDataRatio()
                    model.fromMap(dict["HotDataRatio"] as! [String: Any])
                    self.hotDataRatio = model
                }
                if dict.keys.contains("HotDataSize") {
                    var model = ListDoctorHiveTablesResponseBody.Data.Metrics.HotDataSize()
                    model.fromMap(dict["HotDataSize"] as! [String: Any])
                    self.hotDataSize = model
                }
                if dict.keys.contains("HotDataSizeDayGrowthRatio") {
                    var model = ListDoctorHiveTablesResponseBody.Data.Metrics.HotDataSizeDayGrowthRatio()
                    model.fromMap(dict["HotDataSizeDayGrowthRatio"] as! [String: Any])
                    self.hotDataSizeDayGrowthRatio = model
                }
                if dict.keys.contains("LargeFileCount") {
                    var model = ListDoctorHiveTablesResponseBody.Data.Metrics.LargeFileCount()
                    model.fromMap(dict["LargeFileCount"] as! [String: Any])
                    self.largeFileCount = model
                }
                if dict.keys.contains("LargeFileCountDayGrowthRatio") {
                    var model = ListDoctorHiveTablesResponseBody.Data.Metrics.LargeFileCountDayGrowthRatio()
                    model.fromMap(dict["LargeFileCountDayGrowthRatio"] as! [String: Any])
                    self.largeFileCountDayGrowthRatio = model
                }
                if dict.keys.contains("LargeFileDayGrowthCount") {
                    var model = ListDoctorHiveTablesResponseBody.Data.Metrics.LargeFileDayGrowthCount()
                    model.fromMap(dict["LargeFileDayGrowthCount"] as! [String: Any])
                    self.largeFileDayGrowthCount = model
                }
                if dict.keys.contains("LargeFileRatio") {
                    var model = ListDoctorHiveTablesResponseBody.Data.Metrics.LargeFileRatio()
                    model.fromMap(dict["LargeFileRatio"] as! [String: Any])
                    self.largeFileRatio = model
                }
                if dict.keys.contains("MediumFileCount") {
                    var model = ListDoctorHiveTablesResponseBody.Data.Metrics.MediumFileCount()
                    model.fromMap(dict["MediumFileCount"] as! [String: Any])
                    self.mediumFileCount = model
                }
                if dict.keys.contains("MediumFileCountDayGrowthRatio") {
                    var model = ListDoctorHiveTablesResponseBody.Data.Metrics.MediumFileCountDayGrowthRatio()
                    model.fromMap(dict["MediumFileCountDayGrowthRatio"] as! [String: Any])
                    self.mediumFileCountDayGrowthRatio = model
                }
                if dict.keys.contains("MediumFileDayGrowthCount") {
                    var model = ListDoctorHiveTablesResponseBody.Data.Metrics.MediumFileDayGrowthCount()
                    model.fromMap(dict["MediumFileDayGrowthCount"] as! [String: Any])
                    self.mediumFileDayGrowthCount = model
                }
                if dict.keys.contains("MediumFileRatio") {
                    var model = ListDoctorHiveTablesResponseBody.Data.Metrics.MediumFileRatio()
                    model.fromMap(dict["MediumFileRatio"] as! [String: Any])
                    self.mediumFileRatio = model
                }
                if dict.keys.contains("PartitionNum") {
                    var model = ListDoctorHiveTablesResponseBody.Data.Metrics.PartitionNum()
                    model.fromMap(dict["PartitionNum"] as! [String: Any])
                    self.partitionNum = model
                }
                if dict.keys.contains("SmallFileCount") {
                    var model = ListDoctorHiveTablesResponseBody.Data.Metrics.SmallFileCount()
                    model.fromMap(dict["SmallFileCount"] as! [String: Any])
                    self.smallFileCount = model
                }
                if dict.keys.contains("SmallFileCountDayGrowthRatio") {
                    var model = ListDoctorHiveTablesResponseBody.Data.Metrics.SmallFileCountDayGrowthRatio()
                    model.fromMap(dict["SmallFileCountDayGrowthRatio"] as! [String: Any])
                    self.smallFileCountDayGrowthRatio = model
                }
                if dict.keys.contains("SmallFileDayGrowthCount") {
                    var model = ListDoctorHiveTablesResponseBody.Data.Metrics.SmallFileDayGrowthCount()
                    model.fromMap(dict["SmallFileDayGrowthCount"] as! [String: Any])
                    self.smallFileDayGrowthCount = model
                }
                if dict.keys.contains("SmallFileRatio") {
                    var model = ListDoctorHiveTablesResponseBody.Data.Metrics.SmallFileRatio()
                    model.fromMap(dict["SmallFileRatio"] as! [String: Any])
                    self.smallFileRatio = model
                }
                if dict.keys.contains("TinyFileCount") {
                    var model = ListDoctorHiveTablesResponseBody.Data.Metrics.TinyFileCount()
                    model.fromMap(dict["TinyFileCount"] as! [String: Any])
                    self.tinyFileCount = model
                }
                if dict.keys.contains("TinyFileCountDayGrowthRatio") {
                    var model = ListDoctorHiveTablesResponseBody.Data.Metrics.TinyFileCountDayGrowthRatio()
                    model.fromMap(dict["TinyFileCountDayGrowthRatio"] as! [String: Any])
                    self.tinyFileCountDayGrowthRatio = model
                }
                if dict.keys.contains("TinyFileDayGrowthCount") {
                    var model = ListDoctorHiveTablesResponseBody.Data.Metrics.TinyFileDayGrowthCount()
                    model.fromMap(dict["TinyFileDayGrowthCount"] as! [String: Any])
                    self.tinyFileDayGrowthCount = model
                }
                if dict.keys.contains("TinyFileRatio") {
                    var model = ListDoctorHiveTablesResponseBody.Data.Metrics.TinyFileRatio()
                    model.fromMap(dict["TinyFileRatio"] as! [String: Any])
                    self.tinyFileRatio = model
                }
                if dict.keys.contains("TotalDataDayGrowthSize") {
                    var model = ListDoctorHiveTablesResponseBody.Data.Metrics.TotalDataDayGrowthSize()
                    model.fromMap(dict["TotalDataDayGrowthSize"] as! [String: Any])
                    self.totalDataDayGrowthSize = model
                }
                if dict.keys.contains("TotalDataSize") {
                    var model = ListDoctorHiveTablesResponseBody.Data.Metrics.TotalDataSize()
                    model.fromMap(dict["TotalDataSize"] as! [String: Any])
                    self.totalDataSize = model
                }
                if dict.keys.contains("TotalDataSizeDayGrowthRatio") {
                    var model = ListDoctorHiveTablesResponseBody.Data.Metrics.TotalDataSizeDayGrowthRatio()
                    model.fromMap(dict["TotalDataSizeDayGrowthRatio"] as! [String: Any])
                    self.totalDataSizeDayGrowthRatio = model
                }
                if dict.keys.contains("TotalFileCount") {
                    var model = ListDoctorHiveTablesResponseBody.Data.Metrics.TotalFileCount()
                    model.fromMap(dict["TotalFileCount"] as! [String: Any])
                    self.totalFileCount = model
                }
                if dict.keys.contains("TotalFileCountDayGrowthRatio") {
                    var model = ListDoctorHiveTablesResponseBody.Data.Metrics.TotalFileCountDayGrowthRatio()
                    model.fromMap(dict["TotalFileCountDayGrowthRatio"] as! [String: Any])
                    self.totalFileCountDayGrowthRatio = model
                }
                if dict.keys.contains("TotalFileDayGrowthCount") {
                    var model = ListDoctorHiveTablesResponseBody.Data.Metrics.TotalFileDayGrowthCount()
                    model.fromMap(dict["TotalFileDayGrowthCount"] as! [String: Any])
                    self.totalFileDayGrowthCount = model
                }
                if dict.keys.contains("WarmDataDayGrowthSize") {
                    var model = ListDoctorHiveTablesResponseBody.Data.Metrics.WarmDataDayGrowthSize()
                    model.fromMap(dict["WarmDataDayGrowthSize"] as! [String: Any])
                    self.warmDataDayGrowthSize = model
                }
                if dict.keys.contains("WarmDataRatio") {
                    var model = ListDoctorHiveTablesResponseBody.Data.Metrics.WarmDataRatio()
                    model.fromMap(dict["WarmDataRatio"] as! [String: Any])
                    self.warmDataRatio = model
                }
                if dict.keys.contains("WarmDataSize") {
                    var model = ListDoctorHiveTablesResponseBody.Data.Metrics.WarmDataSize()
                    model.fromMap(dict["WarmDataSize"] as! [String: Any])
                    self.warmDataSize = model
                }
                if dict.keys.contains("WarmDataSizeDayGrowthRatio") {
                    var model = ListDoctorHiveTablesResponseBody.Data.Metrics.WarmDataSizeDayGrowthRatio()
                    model.fromMap(dict["WarmDataSizeDayGrowthRatio"] as! [String: Any])
                    self.warmDataSizeDayGrowthRatio = model
                }
            }
        }
        public var analysis: ListDoctorHiveTablesResponseBody.Data.Analysis?

        public var formats: [ListDoctorHiveTablesResponseBody.Data.Formats]?

        public var metrics: ListDoctorHiveTablesResponseBody.Data.Metrics?

        public var owner: String?

        public var tableName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.analysis?.validate()
            try self.metrics?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.analysis != nil {
                map["Analysis"] = self.analysis?.toMap()
            }
            if self.formats != nil {
                var tmp : [Any] = []
                for k in self.formats! {
                    tmp.append(k.toMap())
                }
                map["Formats"] = tmp
            }
            if self.metrics != nil {
                map["Metrics"] = self.metrics?.toMap()
            }
            if self.owner != nil {
                map["Owner"] = self.owner!
            }
            if self.tableName != nil {
                map["TableName"] = self.tableName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Analysis") {
                var model = ListDoctorHiveTablesResponseBody.Data.Analysis()
                model.fromMap(dict["Analysis"] as! [String: Any])
                self.analysis = model
            }
            if dict.keys.contains("Formats") {
                var tmp : [ListDoctorHiveTablesResponseBody.Data.Formats] = []
                for v in dict["Formats"] as! [Any] {
                    var model = ListDoctorHiveTablesResponseBody.Data.Formats()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.formats = tmp
            }
            if dict.keys.contains("Metrics") {
                var model = ListDoctorHiveTablesResponseBody.Data.Metrics()
                model.fromMap(dict["Metrics"] as! [String: Any])
                self.metrics = model
            }
            if dict.keys.contains("Owner") {
                self.owner = dict["Owner"] as! String
            }
            if dict.keys.contains("TableName") {
                self.tableName = dict["TableName"] as! String
            }
        }
    }
    public var data: [ListDoctorHiveTablesResponseBody.Data]?

    public var maxResults: Int32?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var tmp : [ListDoctorHiveTablesResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListDoctorHiveTablesResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListDoctorHiveTablesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDoctorHiveTablesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDoctorHiveTablesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDoctorJobsRequest : Tea.TeaModel {
    public class EndRange : Tea.TeaModel {
        public var endTime: Int64?

        public var startTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EndTime") {
                self.endTime = dict["EndTime"] as! Int64
            }
            if dict.keys.contains("StartTime") {
                self.startTime = dict["StartTime"] as! Int64
            }
        }
    }
    public class StartRange : Tea.TeaModel {
        public var endTime: Int64?

        public var startTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EndTime") {
                self.endTime = dict["EndTime"] as! Int64
            }
            if dict.keys.contains("StartTime") {
                self.startTime = dict["StartTime"] as! Int64
            }
        }
    }
    public var appIds: [String]?

    public var clusterId: String?

    public var endRange: ListDoctorJobsRequest.EndRange?

    public var maxResults: Int32?

    public var nextToken: String?

    public var orderBy: String?

    public var orderType: String?

    public var queues: [String]?

    public var regionId: String?

    public var startRange: ListDoctorJobsRequest.StartRange?

    public var types: [String]?

    public var users: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.endRange?.validate()
        try self.startRange?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appIds != nil {
            map["AppIds"] = self.appIds!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.endRange != nil {
            map["EndRange"] = self.endRange?.toMap()
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.orderType != nil {
            map["OrderType"] = self.orderType!
        }
        if self.queues != nil {
            map["Queues"] = self.queues!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startRange != nil {
            map["StartRange"] = self.startRange?.toMap()
        }
        if self.types != nil {
            map["Types"] = self.types!
        }
        if self.users != nil {
            map["Users"] = self.users!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppIds") {
            self.appIds = dict["AppIds"] as! [String]
        }
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("EndRange") {
            var model = ListDoctorJobsRequest.EndRange()
            model.fromMap(dict["EndRange"] as! [String: Any])
            self.endRange = model
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OrderBy") {
            self.orderBy = dict["OrderBy"] as! String
        }
        if dict.keys.contains("OrderType") {
            self.orderType = dict["OrderType"] as! String
        }
        if dict.keys.contains("Queues") {
            self.queues = dict["Queues"] as! [String]
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("StartRange") {
            var model = ListDoctorJobsRequest.StartRange()
            model.fromMap(dict["StartRange"] as! [String: Any])
            self.startRange = model
        }
        if dict.keys.contains("Types") {
            self.types = dict["Types"] as! [String]
        }
        if dict.keys.contains("Users") {
            self.users = dict["Users"] as! [String]
        }
    }
}

public class ListDoctorJobsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Metrics : Tea.TeaModel {
            public class MemSeconds : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public class VcoreSeconds : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var unit: String?

                public var value: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Unit") {
                        self.unit = dict["Unit"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Int64
                    }
                }
            }
            public var memSeconds: ListDoctorJobsResponseBody.Data.Metrics.MemSeconds?

            public var vcoreSeconds: ListDoctorJobsResponseBody.Data.Metrics.VcoreSeconds?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.memSeconds?.validate()
                try self.vcoreSeconds?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.memSeconds != nil {
                    map["MemSeconds"] = self.memSeconds?.toMap()
                }
                if self.vcoreSeconds != nil {
                    map["VcoreSeconds"] = self.vcoreSeconds?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("MemSeconds") {
                    var model = ListDoctorJobsResponseBody.Data.Metrics.MemSeconds()
                    model.fromMap(dict["MemSeconds"] as! [String: Any])
                    self.memSeconds = model
                }
                if dict.keys.contains("VcoreSeconds") {
                    var model = ListDoctorJobsResponseBody.Data.Metrics.VcoreSeconds()
                    model.fromMap(dict["VcoreSeconds"] as! [String: Any])
                    self.vcoreSeconds = model
                }
            }
        }
        public var appId: String?

        public var appName: String?

        public var elapsedTime: Int64?

        public var finalStatus: String?

        public var finishTime: Int64?

        public var launchTime: Int64?

        public var metrics: ListDoctorJobsResponseBody.Data.Metrics?

        public var queue: String?

        public var startTime: Int64?

        public var state: String?

        public var type: String?

        public var user: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.metrics?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.elapsedTime != nil {
                map["ElapsedTime"] = self.elapsedTime!
            }
            if self.finalStatus != nil {
                map["FinalStatus"] = self.finalStatus!
            }
            if self.finishTime != nil {
                map["FinishTime"] = self.finishTime!
            }
            if self.launchTime != nil {
                map["LaunchTime"] = self.launchTime!
            }
            if self.metrics != nil {
                map["Metrics"] = self.metrics?.toMap()
            }
            if self.queue != nil {
                map["Queue"] = self.queue!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.user != nil {
                map["User"] = self.user!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("AppName") {
                self.appName = dict["AppName"] as! String
            }
            if dict.keys.contains("ElapsedTime") {
                self.elapsedTime = dict["ElapsedTime"] as! Int64
            }
            if dict.keys.contains("FinalStatus") {
                self.finalStatus = dict["FinalStatus"] as! String
            }
            if dict.keys.contains("FinishTime") {
                self.finishTime = dict["FinishTime"] as! Int64
            }
            if dict.keys.contains("LaunchTime") {
                self.launchTime = dict["LaunchTime"] as! Int64
            }
            if dict.keys.contains("Metrics") {
                var model = ListDoctorJobsResponseBody.Data.Metrics()
                model.fromMap(dict["Metrics"] as! [String: Any])
                self.metrics = model
            }
            if dict.keys.contains("Queue") {
                self.queue = dict["Queue"] as! String
            }
            if dict.keys.contains("StartTime") {
                self.startTime = dict["StartTime"] as! Int64
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("User") {
                self.user = dict["User"] as! String
            }
        }
    }
    public var data: [ListDoctorJobsResponseBody.Data]?

    public var maxResults: Int32?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var tmp : [ListDoctorJobsResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListDoctorJobsResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListDoctorJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDoctorJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDoctorJobsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDoctorJobsStatsRequest : Tea.TeaModel {
    public class EndRange : Tea.TeaModel {
        public var endTime: Int64?

        public var startTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EndTime") {
                self.endTime = dict["EndTime"] as! Int64
            }
            if dict.keys.contains("StartTime") {
                self.startTime = dict["StartTime"] as! Int64
            }
        }
    }
    public class StartRange : Tea.TeaModel {
        public var endTime: Int64?

        public var startTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EndTime") {
                self.endTime = dict["EndTime"] as! Int64
            }
            if dict.keys.contains("StartTime") {
                self.startTime = dict["StartTime"] as! Int64
            }
        }
    }
    public var clusterId: String?

    public var endRange: ListDoctorJobsStatsRequest.EndRange?

    public var groupBy: [String]?

    public var maxResults: Int32?

    public var nextToken: String?

    public var orderBy: String?

    public var orderType: String?

    public var regionId: String?

    public var startRange: ListDoctorJobsStatsRequest.StartRange?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.endRange?.validate()
        try self.startRange?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.endRange != nil {
            map["EndRange"] = self.endRange?.toMap()
        }
        if self.groupBy != nil {
            map["GroupBy"] = self.groupBy!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.orderType != nil {
            map["OrderType"] = self.orderType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startRange != nil {
            map["StartRange"] = self.startRange?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("EndRange") {
            var model = ListDoctorJobsStatsRequest.EndRange()
            model.fromMap(dict["EndRange"] as! [String: Any])
            self.endRange = model
        }
        if dict.keys.contains("GroupBy") {
            self.groupBy = dict["GroupBy"] as! [String]
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OrderBy") {
            self.orderBy = dict["OrderBy"] as! String
        }
        if dict.keys.contains("OrderType") {
            self.orderType = dict["OrderType"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("StartRange") {
            var model = ListDoctorJobsStatsRequest.StartRange()
            model.fromMap(dict["StartRange"] as! [String: Any])
            self.startRange = model
        }
    }
}

public class ListDoctorJobsStatsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class AppsCount : Tea.TeaModel {
            public var description_: String?

            public var name: String?

            public var unit: String?

            public var value: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.unit != nil {
                    map["Unit"] = self.unit!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Unit") {
                    self.unit = dict["Unit"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! Int64
                }
            }
        }
        public class MemSeconds : Tea.TeaModel {
            public var description_: String?

            public var name: String?

            public var unit: String?

            public var value: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.unit != nil {
                    map["Unit"] = self.unit!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Unit") {
                    self.unit = dict["Unit"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! Int64
                }
            }
        }
        public class VcoreSeconds : Tea.TeaModel {
            public var description_: String?

            public var name: String?

            public var unit: String?

            public var value: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.unit != nil {
                    map["Unit"] = self.unit!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Unit") {
                    self.unit = dict["Unit"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! Int64
                }
            }
        }
        public var appsCount: ListDoctorJobsStatsResponseBody.Data.AppsCount?

        public var memSeconds: ListDoctorJobsStatsResponseBody.Data.MemSeconds?

        public var queue: String?

        public var type: String?

        public var user: String?

        public var vcoreSeconds: ListDoctorJobsStatsResponseBody.Data.VcoreSeconds?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.appsCount?.validate()
            try self.memSeconds?.validate()
            try self.vcoreSeconds?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appsCount != nil {
                map["AppsCount"] = self.appsCount?.toMap()
            }
            if self.memSeconds != nil {
                map["MemSeconds"] = self.memSeconds?.toMap()
            }
            if self.queue != nil {
                map["Queue"] = self.queue!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.user != nil {
                map["User"] = self.user!
            }
            if self.vcoreSeconds != nil {
                map["VcoreSeconds"] = self.vcoreSeconds?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppsCount") {
                var model = ListDoctorJobsStatsResponseBody.Data.AppsCount()
                model.fromMap(dict["AppsCount"] as! [String: Any])
                self.appsCount = model
            }
            if dict.keys.contains("MemSeconds") {
                var model = ListDoctorJobsStatsResponseBody.Data.MemSeconds()
                model.fromMap(dict["MemSeconds"] as! [String: Any])
                self.memSeconds = model
            }
            if dict.keys.contains("Queue") {
                self.queue = dict["Queue"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("User") {
                self.user = dict["User"] as! String
            }
            if dict.keys.contains("VcoreSeconds") {
                var model = ListDoctorJobsStatsResponseBody.Data.VcoreSeconds()
                model.fromMap(dict["VcoreSeconds"] as! [String: Any])
                self.vcoreSeconds = model
            }
        }
    }
    public var data: [ListDoctorJobsStatsResponseBody.Data]?

    public var maxResults: Int32?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var tmp : [ListDoctorJobsStatsResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListDoctorJobsStatsResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListDoctorJobsStatsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDoctorJobsStatsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDoctorJobsStatsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDoctorReportsRequest : Tea.TeaModel {
    public var clusterId: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ListDoctorReportsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class SummaryReport : Tea.TeaModel {
            public var score: Int32?

            public var suggestion: String?

            public var summary: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.score != nil {
                    map["Score"] = self.score!
                }
                if self.suggestion != nil {
                    map["Suggestion"] = self.suggestion!
                }
                if self.summary != nil {
                    map["Summary"] = self.summary!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Score") {
                    self.score = dict["Score"] as! Int32
                }
                if dict.keys.contains("Suggestion") {
                    self.suggestion = dict["Suggestion"] as! String
                }
                if dict.keys.contains("Summary") {
                    self.summary = dict["Summary"] as! String
                }
            }
        }
        public var componentTypes: [String]?

        public var dateTime: String?

        public var summaryReport: ListDoctorReportsResponseBody.Data.SummaryReport?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.summaryReport?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.componentTypes != nil {
                map["ComponentTypes"] = self.componentTypes!
            }
            if self.dateTime != nil {
                map["DateTime"] = self.dateTime!
            }
            if self.summaryReport != nil {
                map["SummaryReport"] = self.summaryReport?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ComponentTypes") {
                self.componentTypes = dict["ComponentTypes"] as! [String]
            }
            if dict.keys.contains("DateTime") {
                self.dateTime = dict["DateTime"] as! String
            }
            if dict.keys.contains("SummaryReport") {
                var model = ListDoctorReportsResponseBody.Data.SummaryReport()
                model.fromMap(dict["SummaryReport"] as! [String: Any])
                self.summaryReport = model
            }
        }
    }
    public var data: [ListDoctorReportsResponseBody.Data]?

    public var maxResults: Int32?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var tmp : [ListDoctorReportsResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListDoctorReportsResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListDoctorReportsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDoctorReportsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDoctorReportsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListInspectionHistoryRequest : Tea.TeaModel {
    public var clusterId: String?

    public var component: String?

    public var instanceId: String?

    public var language: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var regionId: String?

    public var service: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.component != nil {
            map["Component"] = self.component!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.service != nil {
            map["Service"] = self.service!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("Component") {
            self.component = dict["Component"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Language") {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Service") {
            self.service = dict["Service"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class ListInspectionHistoryResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var changeMessage: String?

        public var healthStatus: String?

        public var inspectionItems: [[String: String]]?

        public var reportTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.changeMessage != nil {
                map["ChangeMessage"] = self.changeMessage!
            }
            if self.healthStatus != nil {
                map["HealthStatus"] = self.healthStatus!
            }
            if self.inspectionItems != nil {
                map["InspectionItems"] = self.inspectionItems!
            }
            if self.reportTime != nil {
                map["ReportTime"] = self.reportTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ChangeMessage") {
                self.changeMessage = dict["ChangeMessage"] as! String
            }
            if dict.keys.contains("HealthStatus") {
                self.healthStatus = dict["HealthStatus"] as! String
            }
            if dict.keys.contains("InspectionItems") {
                self.inspectionItems = dict["InspectionItems"] as! [[String: String]]
            }
            if dict.keys.contains("ReportTime") {
                self.reportTime = dict["ReportTime"] as! String
            }
        }
    }
    public var data: [ListInspectionHistoryResponseBody.Data]?

    public var maxResults: Int32?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var tmp : [ListInspectionHistoryResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListInspectionHistoryResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListInspectionHistoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListInspectionHistoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListInspectionHistoryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListInstanceTypesRequest : Tea.TeaModel {
    public var clusterId: String?

    public var clusterType: String?

    public var deployMode: String?

    public var instanceType: String?

    public var isModification: Bool?

    public var nodeGroupId: String?

    public var nodeGroupType: String?

    public var paymentType: String?

    public var regionId: String?

    public var releaseVersion: String?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.clusterType != nil {
            map["ClusterType"] = self.clusterType!
        }
        if self.deployMode != nil {
            map["DeployMode"] = self.deployMode!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.isModification != nil {
            map["IsModification"] = self.isModification!
        }
        if self.nodeGroupId != nil {
            map["NodeGroupId"] = self.nodeGroupId!
        }
        if self.nodeGroupType != nil {
            map["NodeGroupType"] = self.nodeGroupType!
        }
        if self.paymentType != nil {
            map["PaymentType"] = self.paymentType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.releaseVersion != nil {
            map["ReleaseVersion"] = self.releaseVersion!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("ClusterType") {
            self.clusterType = dict["ClusterType"] as! String
        }
        if dict.keys.contains("DeployMode") {
            self.deployMode = dict["DeployMode"] as! String
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("IsModification") {
            self.isModification = dict["IsModification"] as! Bool
        }
        if dict.keys.contains("NodeGroupId") {
            self.nodeGroupId = dict["NodeGroupId"] as! String
        }
        if dict.keys.contains("NodeGroupType") {
            self.nodeGroupType = dict["NodeGroupType"] as! String
        }
        if dict.keys.contains("PaymentType") {
            self.paymentType = dict["PaymentType"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ReleaseVersion") {
            self.releaseVersion = dict["ReleaseVersion"] as! String
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! String
        }
    }
}

public class ListInstanceTypesResponseBody : Tea.TeaModel {
    public var instanceTypes: [InstanceType]?

    public var maxResults: Int32?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceTypes != nil {
            var tmp : [Any] = []
            for k in self.instanceTypes! {
                tmp.append(k.toMap())
            }
            map["InstanceTypes"] = tmp
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceTypes") {
            var tmp : [InstanceType] = []
            for v in dict["InstanceTypes"] as! [Any] {
                var model = InstanceType()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.instanceTypes = tmp
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListInstanceTypesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListInstanceTypesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListInstanceTypesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListNodeGroupsRequest : Tea.TeaModel {
    public var clusterId: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var nodeGroupIds: [String]?

    public var nodeGroupNames: [String]?

    public var nodeGroupStates: [String]?

    public var nodeGroupTypes: [String]?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.nodeGroupIds != nil {
            map["NodeGroupIds"] = self.nodeGroupIds!
        }
        if self.nodeGroupNames != nil {
            map["NodeGroupNames"] = self.nodeGroupNames!
        }
        if self.nodeGroupStates != nil {
            map["NodeGroupStates"] = self.nodeGroupStates!
        }
        if self.nodeGroupTypes != nil {
            map["NodeGroupTypes"] = self.nodeGroupTypes!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("NodeGroupIds") {
            self.nodeGroupIds = dict["NodeGroupIds"] as! [String]
        }
        if dict.keys.contains("NodeGroupNames") {
            self.nodeGroupNames = dict["NodeGroupNames"] as! [String]
        }
        if dict.keys.contains("NodeGroupStates") {
            self.nodeGroupStates = dict["NodeGroupStates"] as! [String]
        }
        if dict.keys.contains("NodeGroupTypes") {
            self.nodeGroupTypes = dict["NodeGroupTypes"] as! [String]
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ListNodeGroupsResponseBody : Tea.TeaModel {
    public var maxResults: Int32?

    public var nextToken: String?

    public var nodeGroups: [NodeGroup]?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.nodeGroups != nil {
            var tmp : [Any] = []
            for k in self.nodeGroups! {
                tmp.append(k.toMap())
            }
            map["NodeGroups"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("NodeGroups") {
            var tmp : [NodeGroup] = []
            for v in dict["NodeGroups"] as! [Any] {
                var model = NodeGroup()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.nodeGroups = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListNodeGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListNodeGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListNodeGroupsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListNodesRequest : Tea.TeaModel {
    public var clusterId: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var nodeGroupIds: [String]?

    public var nodeIds: [String]?

    public var nodeNames: [String]?

    public var nodeStates: [String]?

    public var privateIps: [String]?

    public var publicIps: [String]?

    public var regionId: String?

    public var tags: [Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.nodeGroupIds != nil {
            map["NodeGroupIds"] = self.nodeGroupIds!
        }
        if self.nodeIds != nil {
            map["NodeIds"] = self.nodeIds!
        }
        if self.nodeNames != nil {
            map["NodeNames"] = self.nodeNames!
        }
        if self.nodeStates != nil {
            map["NodeStates"] = self.nodeStates!
        }
        if self.privateIps != nil {
            map["PrivateIps"] = self.privateIps!
        }
        if self.publicIps != nil {
            map["PublicIps"] = self.publicIps!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("NodeGroupIds") {
            self.nodeGroupIds = dict["NodeGroupIds"] as! [String]
        }
        if dict.keys.contains("NodeIds") {
            self.nodeIds = dict["NodeIds"] as! [String]
        }
        if dict.keys.contains("NodeNames") {
            self.nodeNames = dict["NodeNames"] as! [String]
        }
        if dict.keys.contains("NodeStates") {
            self.nodeStates = dict["NodeStates"] as! [String]
        }
        if dict.keys.contains("PrivateIps") {
            self.privateIps = dict["PrivateIps"] as! [String]
        }
        if dict.keys.contains("PublicIps") {
            self.publicIps = dict["PublicIps"] as! [String]
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Tags") {
            var tmp : [Tag] = []
            for v in dict["Tags"] as! [Any] {
                var model = Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
    }
}

public class ListNodesResponseBody : Tea.TeaModel {
    public var maxResults: Int32?

    public var nextToken: String?

    public var nodes: [Node]?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.nodes != nil {
            var tmp : [Any] = []
            for k in self.nodes! {
                tmp.append(k.toMap())
            }
            map["Nodes"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("Nodes") {
            var tmp : [Node] = []
            for v in dict["Nodes"] as! [Any] {
                var model = Node()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.nodes = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListNodesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListNodesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListNodesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListReleaseVersionsRequest : Tea.TeaModel {
    public var clusterType: String?

    public var iaasType: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterType != nil {
            map["ClusterType"] = self.clusterType!
        }
        if self.iaasType != nil {
            map["IaasType"] = self.iaasType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterType") {
            self.clusterType = dict["ClusterType"] as! String
        }
        if dict.keys.contains("IaasType") {
            self.iaasType = dict["IaasType"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ListReleaseVersionsResponseBody : Tea.TeaModel {
    public class ReleaseVersions : Tea.TeaModel {
        public var iaasType: String?

        public var releaseVersion: String?

        public var series: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.iaasType != nil {
                map["IaasType"] = self.iaasType!
            }
            if self.releaseVersion != nil {
                map["ReleaseVersion"] = self.releaseVersion!
            }
            if self.series != nil {
                map["Series"] = self.series!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("IaasType") {
                self.iaasType = dict["IaasType"] as! String
            }
            if dict.keys.contains("ReleaseVersion") {
                self.releaseVersion = dict["ReleaseVersion"] as! String
            }
            if dict.keys.contains("Series") {
                self.series = dict["Series"] as! String
            }
        }
    }
    public var maxResults: Int32?

    public var nextToken: String?

    public var releaseVersions: [ListReleaseVersionsResponseBody.ReleaseVersions]?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.releaseVersions != nil {
            var tmp : [Any] = []
            for k in self.releaseVersions! {
                tmp.append(k.toMap())
            }
            map["ReleaseVersions"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("ReleaseVersions") {
            var tmp : [ListReleaseVersionsResponseBody.ReleaseVersions] = []
            for v in dict["ReleaseVersions"] as! [Any] {
                var model = ListReleaseVersionsResponseBody.ReleaseVersions()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.releaseVersions = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListReleaseVersionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListReleaseVersionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListReleaseVersionsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListResourceHealthInspectionsRequest : Tea.TeaModel {
    public var applicationName: String?

    public var clusterId: String?

    public var componentName: String?

    public var healthStatuses: [String]?

    public var language: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var nodeIds: [String]?

    public var nodeNames: [String]?

    public var regionId: String?

    public var resourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationName != nil {
            map["ApplicationName"] = self.applicationName!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.componentName != nil {
            map["ComponentName"] = self.componentName!
        }
        if self.healthStatuses != nil {
            map["HealthStatuses"] = self.healthStatuses!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.nodeIds != nil {
            map["NodeIds"] = self.nodeIds!
        }
        if self.nodeNames != nil {
            map["NodeNames"] = self.nodeNames!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApplicationName") {
            self.applicationName = dict["ApplicationName"] as! String
        }
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("ComponentName") {
            self.componentName = dict["ComponentName"] as! String
        }
        if dict.keys.contains("HealthStatuses") {
            self.healthStatuses = dict["HealthStatuses"] as! [String]
        }
        if dict.keys.contains("Language") {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("NodeIds") {
            self.nodeIds = dict["NodeIds"] as! [String]
        }
        if dict.keys.contains("NodeNames") {
            self.nodeNames = dict["NodeNames"] as! [String]
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
    }
}

public class ListResourceHealthInspectionsResponseBody : Tea.TeaModel {
    public class HealthInspections : Tea.TeaModel {
        public var applicationName: String?

        public var componentName: String?

        public var healthMessage: String?

        public var healthStatus: String?

        public var inspectionName: String?

        public var nodeId: String?

        public var nodeName: String?

        public var reportTime: Int64?

        public var ruleName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.applicationName != nil {
                map["ApplicationName"] = self.applicationName!
            }
            if self.componentName != nil {
                map["ComponentName"] = self.componentName!
            }
            if self.healthMessage != nil {
                map["HealthMessage"] = self.healthMessage!
            }
            if self.healthStatus != nil {
                map["HealthStatus"] = self.healthStatus!
            }
            if self.inspectionName != nil {
                map["InspectionName"] = self.inspectionName!
            }
            if self.nodeId != nil {
                map["NodeId"] = self.nodeId!
            }
            if self.nodeName != nil {
                map["NodeName"] = self.nodeName!
            }
            if self.reportTime != nil {
                map["ReportTime"] = self.reportTime!
            }
            if self.ruleName != nil {
                map["RuleName"] = self.ruleName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApplicationName") {
                self.applicationName = dict["ApplicationName"] as! String
            }
            if dict.keys.contains("ComponentName") {
                self.componentName = dict["ComponentName"] as! String
            }
            if dict.keys.contains("HealthMessage") {
                self.healthMessage = dict["HealthMessage"] as! String
            }
            if dict.keys.contains("HealthStatus") {
                self.healthStatus = dict["HealthStatus"] as! String
            }
            if dict.keys.contains("InspectionName") {
                self.inspectionName = dict["InspectionName"] as! String
            }
            if dict.keys.contains("NodeId") {
                self.nodeId = dict["NodeId"] as! String
            }
            if dict.keys.contains("NodeName") {
                self.nodeName = dict["NodeName"] as! String
            }
            if dict.keys.contains("ReportTime") {
                self.reportTime = dict["ReportTime"] as! Int64
            }
            if dict.keys.contains("RuleName") {
                self.ruleName = dict["RuleName"] as! String
            }
        }
    }
    public var healthInspections: [ListResourceHealthInspectionsResponseBody.HealthInspections]?

    public var maxResults: Int32?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.healthInspections != nil {
            var tmp : [Any] = []
            for k in self.healthInspections! {
                tmp.append(k.toMap())
            }
            map["HealthInspections"] = tmp
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("HealthInspections") {
            var tmp : [ListResourceHealthInspectionsResponseBody.HealthInspections] = []
            for v in dict["HealthInspections"] as! [Any] {
                var model = ListResourceHealthInspectionsResponseBody.HealthInspections()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.healthInspections = tmp
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListResourceHealthInspectionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListResourceHealthInspectionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListResourceHealthInspectionsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListScriptsRequest : Tea.TeaModel {
    public var clusterId: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var regionId: String?

    public var scriptType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.scriptType != nil {
            map["ScriptType"] = self.scriptType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ScriptType") {
            self.scriptType = dict["ScriptType"] as! String
        }
    }
}

public class ListScriptsResponseBody : Tea.TeaModel {
    public class Scripts : Tea.TeaModel {
        public var action: String?

        public var endTime: Int64?

        public var executionFailStrategy: String?

        public var executionMoment: String?

        public var executionState: String?

        public var lastUpdateTime: Int64?

        public var nodeSelector: NodeSelector?

        public var regionId: String?

        public var scriptArgs: String?

        public var scriptId: String?

        public var scriptName: String?

        public var scriptPath: String?

        public var startTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.nodeSelector?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.action != nil {
                map["Action"] = self.action!
            }
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.executionFailStrategy != nil {
                map["ExecutionFailStrategy"] = self.executionFailStrategy!
            }
            if self.executionMoment != nil {
                map["ExecutionMoment"] = self.executionMoment!
            }
            if self.executionState != nil {
                map["ExecutionState"] = self.executionState!
            }
            if self.lastUpdateTime != nil {
                map["LastUpdateTime"] = self.lastUpdateTime!
            }
            if self.nodeSelector != nil {
                map["NodeSelector"] = self.nodeSelector?.toMap()
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.scriptArgs != nil {
                map["ScriptArgs"] = self.scriptArgs!
            }
            if self.scriptId != nil {
                map["ScriptId"] = self.scriptId!
            }
            if self.scriptName != nil {
                map["ScriptName"] = self.scriptName!
            }
            if self.scriptPath != nil {
                map["ScriptPath"] = self.scriptPath!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Action") {
                self.action = dict["Action"] as! String
            }
            if dict.keys.contains("EndTime") {
                self.endTime = dict["EndTime"] as! Int64
            }
            if dict.keys.contains("ExecutionFailStrategy") {
                self.executionFailStrategy = dict["ExecutionFailStrategy"] as! String
            }
            if dict.keys.contains("ExecutionMoment") {
                self.executionMoment = dict["ExecutionMoment"] as! String
            }
            if dict.keys.contains("ExecutionState") {
                self.executionState = dict["ExecutionState"] as! String
            }
            if dict.keys.contains("LastUpdateTime") {
                self.lastUpdateTime = dict["LastUpdateTime"] as! Int64
            }
            if dict.keys.contains("NodeSelector") {
                var model = NodeSelector()
                model.fromMap(dict["NodeSelector"] as! [String: Any])
                self.nodeSelector = model
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("ScriptArgs") {
                self.scriptArgs = dict["ScriptArgs"] as! String
            }
            if dict.keys.contains("ScriptId") {
                self.scriptId = dict["ScriptId"] as! String
            }
            if dict.keys.contains("ScriptName") {
                self.scriptName = dict["ScriptName"] as! String
            }
            if dict.keys.contains("ScriptPath") {
                self.scriptPath = dict["ScriptPath"] as! String
            }
            if dict.keys.contains("StartTime") {
                self.startTime = dict["StartTime"] as! Int64
            }
        }
    }
    public var maxResults: Int32?

    public var nextToken: String?

    public var requestId: String?

    public var scripts: [ListScriptsResponseBody.Scripts]?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scripts != nil {
            var tmp : [Any] = []
            for k in self.scripts! {
                tmp.append(k.toMap())
            }
            map["Scripts"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Scripts") {
            var tmp : [ListScriptsResponseBody.Scripts] = []
            for v in dict["Scripts"] as! [Any] {
                var model = ListScriptsResponseBody.Scripts()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.scripts = tmp
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListScriptsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListScriptsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListScriptsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListTagResourcesRequest : Tea.TeaModel {
    public var maxResults: Int32?

    public var nextToken: String?

    public var regionId: String?

    public var resourceIds: [String]?

    public var resourceType: String?

    public var tags: [Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceIds != nil {
            map["ResourceIds"] = self.resourceIds!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceIds") {
            self.resourceIds = dict["ResourceIds"] as! [String]
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("Tags") {
            var tmp : [Tag] = []
            for v in dict["Tags"] as! [Any] {
                var model = Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
    }
}

public class ListTagResourcesResponseBody : Tea.TeaModel {
    public class TagResources : Tea.TeaModel {
        public var resourceId: String?

        public var resourceType: String?

        public var tagKey: String?

        public var tagValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.resourceId != nil {
                map["ResourceId"] = self.resourceId!
            }
            if self.resourceType != nil {
                map["ResourceType"] = self.resourceType!
            }
            if self.tagKey != nil {
                map["TagKey"] = self.tagKey!
            }
            if self.tagValue != nil {
                map["TagValue"] = self.tagValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ResourceId") {
                self.resourceId = dict["ResourceId"] as! String
            }
            if dict.keys.contains("ResourceType") {
                self.resourceType = dict["ResourceType"] as! String
            }
            if dict.keys.contains("TagKey") {
                self.tagKey = dict["TagKey"] as! String
            }
            if dict.keys.contains("TagValue") {
                self.tagValue = dict["TagValue"] as! String
            }
        }
    }
    public var maxResults: Int32?

    public var nextToken: String?

    public var requestId: String?

    public var tagResources: [ListTagResourcesResponseBody.TagResources]?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.tagResources != nil {
            var tmp : [Any] = []
            for k in self.tagResources! {
                tmp.append(k.toMap())
            }
            map["TagResources"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TagResources") {
            var tmp : [ListTagResourcesResponseBody.TagResources] = []
            for v in dict["TagResources"] as! [Any] {
                var model = ListTagResourcesResponseBody.TagResources()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tagResources = tmp
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListTagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListTagResourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class PutAutoScalingPolicyRequest : Tea.TeaModel {
    public var clusterId: String?

    public var constraints: ScalingConstraints?

    public var nodeGroupId: String?

    public var regionId: String?

    public var scalingRules: [ScalingRule]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.constraints?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.constraints != nil {
            map["Constraints"] = self.constraints?.toMap()
        }
        if self.nodeGroupId != nil {
            map["NodeGroupId"] = self.nodeGroupId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.scalingRules != nil {
            var tmp : [Any] = []
            for k in self.scalingRules! {
                tmp.append(k.toMap())
            }
            map["ScalingRules"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("Constraints") {
            var model = ScalingConstraints()
            model.fromMap(dict["Constraints"] as! [String: Any])
            self.constraints = model
        }
        if dict.keys.contains("NodeGroupId") {
            self.nodeGroupId = dict["NodeGroupId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ScalingRules") {
            var tmp : [ScalingRule] = []
            for v in dict["ScalingRules"] as! [Any] {
                var model = ScalingRule()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.scalingRules = tmp
        }
    }
}

public class PutAutoScalingPolicyResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class PutAutoScalingPolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PutAutoScalingPolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = PutAutoScalingPolicyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemoveAutoScalingPolicyRequest : Tea.TeaModel {
    public var clusterId: String?

    public var nodeGroupId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.nodeGroupId != nil {
            map["NodeGroupId"] = self.nodeGroupId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("NodeGroupId") {
            self.nodeGroupId = dict["NodeGroupId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class RemoveAutoScalingPolicyResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RemoveAutoScalingPolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveAutoScalingPolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RemoveAutoScalingPolicyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RunApiTemplateRequest : Tea.TeaModel {
    public var apiName: String?

    public var clientToken: String?

    public var regionId: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiName != nil {
            map["ApiName"] = self.apiName!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiName") {
            self.apiName = dict["ApiName"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class RunApiTemplateResponseBody : Tea.TeaModel {
    public var data: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RunApiTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RunApiTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RunApiTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RunApplicationActionRequest : Tea.TeaModel {
    public var actionName: String?

    public var batchSize: Int32?

    public var clusterId: String?

    public var componentInstanceSelector: ComponentInstanceSelector?

    public var description_: String?

    public var executeStrategy: String?

    public var interval: Int64?

    public var regionId: String?

    public var rollingExecute: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.componentInstanceSelector?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.actionName != nil {
            map["ActionName"] = self.actionName!
        }
        if self.batchSize != nil {
            map["BatchSize"] = self.batchSize!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.componentInstanceSelector != nil {
            map["ComponentInstanceSelector"] = self.componentInstanceSelector?.toMap()
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.executeStrategy != nil {
            map["ExecuteStrategy"] = self.executeStrategy!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.rollingExecute != nil {
            map["RollingExecute"] = self.rollingExecute!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ActionName") {
            self.actionName = dict["ActionName"] as! String
        }
        if dict.keys.contains("BatchSize") {
            self.batchSize = dict["BatchSize"] as! Int32
        }
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("ComponentInstanceSelector") {
            var model = ComponentInstanceSelector()
            model.fromMap(dict["ComponentInstanceSelector"] as! [String: Any])
            self.componentInstanceSelector = model
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("ExecuteStrategy") {
            self.executeStrategy = dict["ExecuteStrategy"] as! String
        }
        if dict.keys.contains("Interval") {
            self.interval = dict["Interval"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RollingExecute") {
            self.rollingExecute = dict["RollingExecute"] as! Bool
        }
    }
}

public class RunApplicationActionResponseBody : Tea.TeaModel {
    public class AbnInstances : Tea.TeaModel {
        public var nodeId: String?

        public var nodeName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.nodeId != nil {
                map["NodeId"] = self.nodeId!
            }
            if self.nodeName != nil {
                map["NodeName"] = self.nodeName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("NodeId") {
                self.nodeId = dict["NodeId"] as! String
            }
            if dict.keys.contains("NodeName") {
                self.nodeName = dict["NodeName"] as! String
            }
        }
    }
    public var abnInstances: [RunApplicationActionResponseBody.AbnInstances]?

    public var operationId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.abnInstances != nil {
            var tmp : [Any] = []
            for k in self.abnInstances! {
                tmp.append(k.toMap())
            }
            map["AbnInstances"] = tmp
        }
        if self.operationId != nil {
            map["OperationId"] = self.operationId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AbnInstances") {
            var tmp : [RunApplicationActionResponseBody.AbnInstances] = []
            for v in dict["AbnInstances"] as! [Any] {
                var model = RunApplicationActionResponseBody.AbnInstances()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.abnInstances = tmp
        }
        if dict.keys.contains("OperationId") {
            self.operationId = dict["OperationId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RunApplicationActionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RunApplicationActionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RunApplicationActionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class TagResourcesRequest : Tea.TeaModel {
    public var regionId: String?

    public var resourceIds: [String]?

    public var resourceType: String?

    public var tags: [Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceIds != nil {
            map["ResourceIds"] = self.resourceIds!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceIds") {
            self.resourceIds = dict["ResourceIds"] as! [String]
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("Tags") {
            var tmp : [Tag] = []
            for v in dict["Tags"] as! [Any] {
                var model = Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
    }
}

public class TagResourcesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class TagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: TagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = TagResourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UntagResourcesRequest : Tea.TeaModel {
    public var all: Bool?

    public var regionId: String?

    public var resourceIds: [String]?

    public var resourceType: String?

    public var tagKeys: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.all != nil {
            map["All"] = self.all!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceIds != nil {
            map["ResourceIds"] = self.resourceIds!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tagKeys != nil {
            map["TagKeys"] = self.tagKeys!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("All") {
            self.all = dict["All"] as! Bool
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceIds") {
            self.resourceIds = dict["ResourceIds"] as! [String]
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("TagKeys") {
            self.tagKeys = dict["TagKeys"] as! [String]
        }
    }
}

public class UntagResourcesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UntagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UntagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UntagResourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateApiTemplateRequest : Tea.TeaModel {
    public var apiName: String?

    public var content: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var templateId: String?

    public var templateName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiName != nil {
            map["ApiName"] = self.apiName!
        }
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.templateName != nil {
            map["TemplateName"] = self.templateName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiName") {
            self.apiName = dict["ApiName"] as! String
        }
        if dict.keys.contains("Content") {
            self.content = dict["Content"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("TemplateName") {
            self.templateName = dict["TemplateName"] as! String
        }
    }
}

public class UpdateApiTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateApiTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateApiTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateApiTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateApplicationConfigsRequest : Tea.TeaModel {
    public var applicationConfigs: [UpdateApplicationConfig]?

    public var applicationName: String?

    public var clusterId: String?

    public var configAction: String?

    public var configScope: String?

    public var description_: String?

    public var nodeGroupId: String?

    public var nodeId: String?

    public var refreshConfig: Bool?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationConfigs != nil {
            var tmp : [Any] = []
            for k in self.applicationConfigs! {
                tmp.append(k.toMap())
            }
            map["ApplicationConfigs"] = tmp
        }
        if self.applicationName != nil {
            map["ApplicationName"] = self.applicationName!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.configAction != nil {
            map["ConfigAction"] = self.configAction!
        }
        if self.configScope != nil {
            map["ConfigScope"] = self.configScope!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.nodeGroupId != nil {
            map["NodeGroupId"] = self.nodeGroupId!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.refreshConfig != nil {
            map["RefreshConfig"] = self.refreshConfig!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApplicationConfigs") {
            var tmp : [UpdateApplicationConfig] = []
            for v in dict["ApplicationConfigs"] as! [Any] {
                var model = UpdateApplicationConfig()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.applicationConfigs = tmp
        }
        if dict.keys.contains("ApplicationName") {
            self.applicationName = dict["ApplicationName"] as! String
        }
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("ConfigAction") {
            self.configAction = dict["ConfigAction"] as! String
        }
        if dict.keys.contains("ConfigScope") {
            self.configScope = dict["ConfigScope"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("NodeGroupId") {
            self.nodeGroupId = dict["NodeGroupId"] as! String
        }
        if dict.keys.contains("NodeId") {
            self.nodeId = dict["NodeId"] as! String
        }
        if dict.keys.contains("RefreshConfig") {
            self.refreshConfig = dict["RefreshConfig"] as! Bool
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class UpdateApplicationConfigsResponseBody : Tea.TeaModel {
    public var operationId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.operationId != nil {
            map["OperationId"] = self.operationId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OperationId") {
            self.operationId = dict["OperationId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateApplicationConfigsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateApplicationConfigsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateApplicationConfigsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateScriptRequest : Tea.TeaModel {
    public var clusterId: String?

    public var regionId: String?

    public var script: Script?

    public var scriptId: String?

    public var scriptType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.script?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.script != nil {
            map["Script"] = self.script?.toMap()
        }
        if self.scriptId != nil {
            map["ScriptId"] = self.scriptId!
        }
        if self.scriptType != nil {
            map["ScriptType"] = self.scriptType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Script") {
            var model = Script()
            model.fromMap(dict["Script"] as! [String: Any])
            self.script = model
        }
        if dict.keys.contains("ScriptId") {
            self.scriptId = dict["ScriptId"] as! String
        }
        if dict.keys.contains("ScriptType") {
            self.scriptType = dict["ScriptType"] as! String
        }
    }
}

public class UpdateScriptShrinkRequest : Tea.TeaModel {
    public var clusterId: String?

    public var regionId: String?

    public var scriptShrink: String?

    public var scriptId: String?

    public var scriptType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.scriptShrink != nil {
            map["Script"] = self.scriptShrink!
        }
        if self.scriptId != nil {
            map["ScriptId"] = self.scriptId!
        }
        if self.scriptType != nil {
            map["ScriptType"] = self.scriptType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Script") {
            self.scriptShrink = dict["Script"] as! String
        }
        if dict.keys.contains("ScriptId") {
            self.scriptId = dict["ScriptId"] as! String
        }
        if dict.keys.contains("ScriptType") {
            self.scriptType = dict["ScriptType"] as! String
        }
    }
}

public class UpdateScriptResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateScriptResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateScriptResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateScriptResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}
