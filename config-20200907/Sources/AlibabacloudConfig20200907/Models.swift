import Foundation
import Tea
import TeaUtils
import AlibabacloudOpenApi
import AlibabaCloudOpenApiUtil
import AlibabacloudEndpointUtil

public class ResourceDirectoryFolderNode : Tea.TeaModel {
    public var accountId: String?

    public var children: [ResourceDirectoryFolderNode]?

    public var displayName: String?

    public var folderId: String?

    public var folderName: String?

    public var parentFolderId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountId != nil {
            map["AccountId"] = self.accountId!
        }
        if self.children != nil {
            var tmp : [Any] = []
            for k in self.children! {
                tmp.append(k.toMap())
            }
            map["Children"] = tmp
        }
        if self.displayName != nil {
            map["DisplayName"] = self.displayName!
        }
        if self.folderId != nil {
            map["FolderId"] = self.folderId!
        }
        if self.folderName != nil {
            map["FolderName"] = self.folderName!
        }
        if self.parentFolderId != nil {
            map["ParentFolderId"] = self.parentFolderId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AccountId"] as? String {
            self.accountId = value
        }
        if let value = dict["Children"] as? [Any?] {
            var tmp : [ResourceDirectoryFolderNode] = []
            for v in value {
                if v != nil {
                    var model = ResourceDirectoryFolderNode()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.children = tmp
        }
        if let value = dict["DisplayName"] as? String {
            self.displayName = value
        }
        if let value = dict["FolderId"] as? String {
            self.folderId = value
        }
        if let value = dict["FolderName"] as? String {
            self.folderName = value
        }
        if let value = dict["ParentFolderId"] as? String {
            self.parentFolderId = value
        }
    }
}

public class ActiveAggregateConfigRulesRequest : Tea.TeaModel {
    public var aggregatorId: String?

    public var compliancePackId: String?

    public var configRuleIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aggregatorId != nil {
            map["AggregatorId"] = self.aggregatorId!
        }
        if self.compliancePackId != nil {
            map["CompliancePackId"] = self.compliancePackId!
        }
        if self.configRuleIds != nil {
            map["ConfigRuleIds"] = self.configRuleIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AggregatorId"] as? String {
            self.aggregatorId = value
        }
        if let value = dict["CompliancePackId"] as? String {
            self.compliancePackId = value
        }
        if let value = dict["ConfigRuleIds"] as? String {
            self.configRuleIds = value
        }
    }
}

public class ActiveAggregateConfigRulesResponseBody : Tea.TeaModel {
    public class OperateRuleResult : Tea.TeaModel {
        public class OperateRuleItemList : Tea.TeaModel {
            public var configRuleId: String?

            public var errorCode: String?

            public var success: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.configRuleId != nil {
                    map["ConfigRuleId"] = self.configRuleId!
                }
                if self.errorCode != nil {
                    map["ErrorCode"] = self.errorCode!
                }
                if self.success != nil {
                    map["Success"] = self.success!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ConfigRuleId"] as? String {
                    self.configRuleId = value
                }
                if let value = dict["ErrorCode"] as? String {
                    self.errorCode = value
                }
                if let value = dict["Success"] as? Bool {
                    self.success = value
                }
            }
        }
        public var operateRuleItemList: [ActiveAggregateConfigRulesResponseBody.OperateRuleResult.OperateRuleItemList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.operateRuleItemList != nil {
                var tmp : [Any] = []
                for k in self.operateRuleItemList! {
                    tmp.append(k.toMap())
                }
                map["OperateRuleItemList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["OperateRuleItemList"] as? [Any?] {
                var tmp : [ActiveAggregateConfigRulesResponseBody.OperateRuleResult.OperateRuleItemList] = []
                for v in value {
                    if v != nil {
                        var model = ActiveAggregateConfigRulesResponseBody.OperateRuleResult.OperateRuleItemList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.operateRuleItemList = tmp
            }
        }
    }
    public var operateRuleResult: ActiveAggregateConfigRulesResponseBody.OperateRuleResult?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.operateRuleResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.operateRuleResult != nil {
            map["OperateRuleResult"] = self.operateRuleResult?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OperateRuleResult"] as? [String: Any?] {
            var model = ActiveAggregateConfigRulesResponseBody.OperateRuleResult()
            model.fromMap(value)
            self.operateRuleResult = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ActiveAggregateConfigRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ActiveAggregateConfigRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ActiveAggregateConfigRulesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ActiveConfigRulesRequest : Tea.TeaModel {
    public var compliancePackId: String?

    public var configRuleIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.compliancePackId != nil {
            map["CompliancePackId"] = self.compliancePackId!
        }
        if self.configRuleIds != nil {
            map["ConfigRuleIds"] = self.configRuleIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CompliancePackId"] as? String {
            self.compliancePackId = value
        }
        if let value = dict["ConfigRuleIds"] as? String {
            self.configRuleIds = value
        }
    }
}

public class ActiveConfigRulesResponseBody : Tea.TeaModel {
    public class OperateRuleResult : Tea.TeaModel {
        public class OperateRuleItemList : Tea.TeaModel {
            public var configRuleId: String?

            public var errorCode: String?

            public var success: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.configRuleId != nil {
                    map["ConfigRuleId"] = self.configRuleId!
                }
                if self.errorCode != nil {
                    map["ErrorCode"] = self.errorCode!
                }
                if self.success != nil {
                    map["Success"] = self.success!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ConfigRuleId"] as? String {
                    self.configRuleId = value
                }
                if let value = dict["ErrorCode"] as? String {
                    self.errorCode = value
                }
                if let value = dict["Success"] as? Bool {
                    self.success = value
                }
            }
        }
        public var operateRuleItemList: [ActiveConfigRulesResponseBody.OperateRuleResult.OperateRuleItemList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.operateRuleItemList != nil {
                var tmp : [Any] = []
                for k in self.operateRuleItemList! {
                    tmp.append(k.toMap())
                }
                map["OperateRuleItemList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["OperateRuleItemList"] as? [Any?] {
                var tmp : [ActiveConfigRulesResponseBody.OperateRuleResult.OperateRuleItemList] = []
                for v in value {
                    if v != nil {
                        var model = ActiveConfigRulesResponseBody.OperateRuleResult.OperateRuleItemList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.operateRuleItemList = tmp
            }
        }
    }
    public var operateRuleResult: ActiveConfigRulesResponseBody.OperateRuleResult?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.operateRuleResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.operateRuleResult != nil {
            map["OperateRuleResult"] = self.operateRuleResult?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OperateRuleResult"] as? [String: Any?] {
            var model = ActiveConfigRulesResponseBody.OperateRuleResult()
            model.fromMap(value)
            self.operateRuleResult = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ActiveConfigRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ActiveConfigRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ActiveConfigRulesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AttachAggregateConfigRuleToCompliancePackRequest : Tea.TeaModel {
    public var aggregatorId: String?

    public var compliancePackId: String?

    public var configRuleIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aggregatorId != nil {
            map["AggregatorId"] = self.aggregatorId!
        }
        if self.compliancePackId != nil {
            map["CompliancePackId"] = self.compliancePackId!
        }
        if self.configRuleIds != nil {
            map["ConfigRuleIds"] = self.configRuleIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AggregatorId"] as? String {
            self.aggregatorId = value
        }
        if let value = dict["CompliancePackId"] as? String {
            self.compliancePackId = value
        }
        if let value = dict["ConfigRuleIds"] as? String {
            self.configRuleIds = value
        }
    }
}

public class AttachAggregateConfigRuleToCompliancePackResponseBody : Tea.TeaModel {
    public class OperateRuleResult : Tea.TeaModel {
        public class OperateRuleItemList : Tea.TeaModel {
            public var configRuleId: String?

            public var errorCode: String?

            public var success: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.configRuleId != nil {
                    map["ConfigRuleId"] = self.configRuleId!
                }
                if self.errorCode != nil {
                    map["ErrorCode"] = self.errorCode!
                }
                if self.success != nil {
                    map["Success"] = self.success!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ConfigRuleId"] as? String {
                    self.configRuleId = value
                }
                if let value = dict["ErrorCode"] as? String {
                    self.errorCode = value
                }
                if let value = dict["Success"] as? Bool {
                    self.success = value
                }
            }
        }
        public var operateRuleItemList: [AttachAggregateConfigRuleToCompliancePackResponseBody.OperateRuleResult.OperateRuleItemList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.operateRuleItemList != nil {
                var tmp : [Any] = []
                for k in self.operateRuleItemList! {
                    tmp.append(k.toMap())
                }
                map["OperateRuleItemList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["OperateRuleItemList"] as? [Any?] {
                var tmp : [AttachAggregateConfigRuleToCompliancePackResponseBody.OperateRuleResult.OperateRuleItemList] = []
                for v in value {
                    if v != nil {
                        var model = AttachAggregateConfigRuleToCompliancePackResponseBody.OperateRuleResult.OperateRuleItemList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.operateRuleItemList = tmp
            }
        }
    }
    public var operateRuleResult: AttachAggregateConfigRuleToCompliancePackResponseBody.OperateRuleResult?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.operateRuleResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.operateRuleResult != nil {
            map["OperateRuleResult"] = self.operateRuleResult?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OperateRuleResult"] as? [String: Any?] {
            var model = AttachAggregateConfigRuleToCompliancePackResponseBody.OperateRuleResult()
            model.fromMap(value)
            self.operateRuleResult = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AttachAggregateConfigRuleToCompliancePackResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AttachAggregateConfigRuleToCompliancePackResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AttachAggregateConfigRuleToCompliancePackResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AttachConfigRuleToCompliancePackRequest : Tea.TeaModel {
    public var compliancePackId: String?

    public var configRuleIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.compliancePackId != nil {
            map["CompliancePackId"] = self.compliancePackId!
        }
        if self.configRuleIds != nil {
            map["ConfigRuleIds"] = self.configRuleIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CompliancePackId"] as? String {
            self.compliancePackId = value
        }
        if let value = dict["ConfigRuleIds"] as? String {
            self.configRuleIds = value
        }
    }
}

public class AttachConfigRuleToCompliancePackResponseBody : Tea.TeaModel {
    public class OperateRuleResult : Tea.TeaModel {
        public class OperateRuleItemList : Tea.TeaModel {
            public var configRuleId: String?

            public var errorCode: String?

            public var success: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.configRuleId != nil {
                    map["ConfigRuleId"] = self.configRuleId!
                }
                if self.errorCode != nil {
                    map["ErrorCode"] = self.errorCode!
                }
                if self.success != nil {
                    map["Success"] = self.success!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ConfigRuleId"] as? String {
                    self.configRuleId = value
                }
                if let value = dict["ErrorCode"] as? String {
                    self.errorCode = value
                }
                if let value = dict["Success"] as? Bool {
                    self.success = value
                }
            }
        }
        public var operateRuleItemList: [AttachConfigRuleToCompliancePackResponseBody.OperateRuleResult.OperateRuleItemList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.operateRuleItemList != nil {
                var tmp : [Any] = []
                for k in self.operateRuleItemList! {
                    tmp.append(k.toMap())
                }
                map["OperateRuleItemList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["OperateRuleItemList"] as? [Any?] {
                var tmp : [AttachConfigRuleToCompliancePackResponseBody.OperateRuleResult.OperateRuleItemList] = []
                for v in value {
                    if v != nil {
                        var model = AttachConfigRuleToCompliancePackResponseBody.OperateRuleResult.OperateRuleItemList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.operateRuleItemList = tmp
            }
        }
    }
    public var operateRuleResult: AttachConfigRuleToCompliancePackResponseBody.OperateRuleResult?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.operateRuleResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.operateRuleResult != nil {
            map["OperateRuleResult"] = self.operateRuleResult?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OperateRuleResult"] as? [String: Any?] {
            var model = AttachConfigRuleToCompliancePackResponseBody.OperateRuleResult()
            model.fromMap(value)
            self.operateRuleResult = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AttachConfigRuleToCompliancePackResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AttachConfigRuleToCompliancePackResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AttachConfigRuleToCompliancePackResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CopyCompliancePacksRequest : Tea.TeaModel {
    public var desAggregatorIds: String?

    public var srcAggregatorId: String?

    public var srcCompliancePackIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.desAggregatorIds != nil {
            map["DesAggregatorIds"] = self.desAggregatorIds!
        }
        if self.srcAggregatorId != nil {
            map["SrcAggregatorId"] = self.srcAggregatorId!
        }
        if self.srcCompliancePackIds != nil {
            map["SrcCompliancePackIds"] = self.srcCompliancePackIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DesAggregatorIds"] as? String {
            self.desAggregatorIds = value
        }
        if let value = dict["SrcAggregatorId"] as? String {
            self.srcAggregatorId = value
        }
        if let value = dict["SrcCompliancePackIds"] as? String {
            self.srcCompliancePackIds = value
        }
    }
}

public class CopyCompliancePacksResponseBody : Tea.TeaModel {
    public var copyRulesResult: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.copyRulesResult != nil {
            map["CopyRulesResult"] = self.copyRulesResult!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CopyRulesResult"] as? Bool {
            self.copyRulesResult = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CopyCompliancePacksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CopyCompliancePacksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CopyCompliancePacksResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CopyConfigRulesRequest : Tea.TeaModel {
    public var desAggregatorIds: String?

    public var srcAggregatorId: String?

    public var srcConfigRuleIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.desAggregatorIds != nil {
            map["DesAggregatorIds"] = self.desAggregatorIds!
        }
        if self.srcAggregatorId != nil {
            map["SrcAggregatorId"] = self.srcAggregatorId!
        }
        if self.srcConfigRuleIds != nil {
            map["SrcConfigRuleIds"] = self.srcConfigRuleIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DesAggregatorIds"] as? String {
            self.desAggregatorIds = value
        }
        if let value = dict["SrcAggregatorId"] as? String {
            self.srcAggregatorId = value
        }
        if let value = dict["SrcConfigRuleIds"] as? String {
            self.srcConfigRuleIds = value
        }
    }
}

public class CopyConfigRulesResponseBody : Tea.TeaModel {
    public var copyRulesResult: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.copyRulesResult != nil {
            map["CopyRulesResult"] = self.copyRulesResult!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CopyRulesResult"] as? Bool {
            self.copyRulesResult = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CopyConfigRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CopyConfigRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CopyConfigRulesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateAdvancedSearchFileRequest : Tea.TeaModel {
    public var sql: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.sql != nil {
            map["Sql"] = self.sql!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Sql"] as? String {
            self.sql = value
        }
    }
}

public class CreateAdvancedSearchFileResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateAdvancedSearchFileResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateAdvancedSearchFileResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateAdvancedSearchFileResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateAggregateAdvancedSearchFileRequest : Tea.TeaModel {
    public var aggregatorId: String?

    public var sql: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aggregatorId != nil {
            map["AggregatorId"] = self.aggregatorId!
        }
        if self.sql != nil {
            map["Sql"] = self.sql!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AggregatorId"] as? String {
            self.aggregatorId = value
        }
        if let value = dict["Sql"] as? String {
            self.sql = value
        }
    }
}

public class CreateAggregateAdvancedSearchFileResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateAggregateAdvancedSearchFileResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateAggregateAdvancedSearchFileResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateAggregateAdvancedSearchFileResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateAggregateCompliancePackRequest : Tea.TeaModel {
    public class ConfigRules : Tea.TeaModel {
        public class ConfigRuleParameters : Tea.TeaModel {
            public var parameterName: String?

            public var parameterValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.parameterName != nil {
                    map["ParameterName"] = self.parameterName!
                }
                if self.parameterValue != nil {
                    map["ParameterValue"] = self.parameterValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ParameterName"] as? String {
                    self.parameterName = value
                }
                if let value = dict["ParameterValue"] as? String {
                    self.parameterValue = value
                }
            }
        }
        public var configRuleId: String?

        public var configRuleName: String?

        public var configRuleParameters: [CreateAggregateCompliancePackRequest.ConfigRules.ConfigRuleParameters]?

        public var description_: String?

        public var managedRuleIdentifier: String?

        public var riskLevel: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.configRuleId != nil {
                map["ConfigRuleId"] = self.configRuleId!
            }
            if self.configRuleName != nil {
                map["ConfigRuleName"] = self.configRuleName!
            }
            if self.configRuleParameters != nil {
                var tmp : [Any] = []
                for k in self.configRuleParameters! {
                    tmp.append(k.toMap())
                }
                map["ConfigRuleParameters"] = tmp
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.managedRuleIdentifier != nil {
                map["ManagedRuleIdentifier"] = self.managedRuleIdentifier!
            }
            if self.riskLevel != nil {
                map["RiskLevel"] = self.riskLevel!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ConfigRuleId"] as? String {
                self.configRuleId = value
            }
            if let value = dict["ConfigRuleName"] as? String {
                self.configRuleName = value
            }
            if let value = dict["ConfigRuleParameters"] as? [Any?] {
                var tmp : [CreateAggregateCompliancePackRequest.ConfigRules.ConfigRuleParameters] = []
                for v in value {
                    if v != nil {
                        var model = CreateAggregateCompliancePackRequest.ConfigRules.ConfigRuleParameters()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.configRuleParameters = tmp
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["ManagedRuleIdentifier"] as? String {
                self.managedRuleIdentifier = value
            }
            if let value = dict["RiskLevel"] as? Int32 {
                self.riskLevel = value
            }
        }
    }
    public class ExcludeTagsScope : Tea.TeaModel {
        public var tagKey: String?

        public var tagValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tagKey != nil {
                map["TagKey"] = self.tagKey!
            }
            if self.tagValue != nil {
                map["TagValue"] = self.tagValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["TagKey"] as? String {
                self.tagKey = value
            }
            if let value = dict["TagValue"] as? String {
                self.tagValue = value
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public class TagsScope : Tea.TeaModel {
        public var tagKey: String?

        public var tagValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tagKey != nil {
                map["TagKey"] = self.tagKey!
            }
            if self.tagValue != nil {
                map["TagValue"] = self.tagValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["TagKey"] as? String {
                self.tagKey = value
            }
            if let value = dict["TagValue"] as? String {
                self.tagValue = value
            }
        }
    }
    public var aggregatorId: String?

    public var clientToken: String?

    public var compliancePackName: String?

    public var compliancePackTemplateId: String?

    public var configRules: [CreateAggregateCompliancePackRequest.ConfigRules]?

    public var defaultEnable: Bool?

    public var description_: String?

    public var excludeRegionIdsScope: String?

    public var excludeResourceGroupIdsScope: String?

    public var excludeResourceIdsScope: String?

    public var excludeTagsScope: [CreateAggregateCompliancePackRequest.ExcludeTagsScope]?

    public var regionIdsScope: String?

    public var resourceGroupIdsScope: String?

    public var resourceIdsScope: String?

    public var riskLevel: Int32?

    public var tag: [CreateAggregateCompliancePackRequest.Tag]?

    public var tagKeyScope: String?

    public var tagValueScope: String?

    public var tagsScope: [CreateAggregateCompliancePackRequest.TagsScope]?

    public var templateContent: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aggregatorId != nil {
            map["AggregatorId"] = self.aggregatorId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.compliancePackName != nil {
            map["CompliancePackName"] = self.compliancePackName!
        }
        if self.compliancePackTemplateId != nil {
            map["CompliancePackTemplateId"] = self.compliancePackTemplateId!
        }
        if self.configRules != nil {
            var tmp : [Any] = []
            for k in self.configRules! {
                tmp.append(k.toMap())
            }
            map["ConfigRules"] = tmp
        }
        if self.defaultEnable != nil {
            map["DefaultEnable"] = self.defaultEnable!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.excludeRegionIdsScope != nil {
            map["ExcludeRegionIdsScope"] = self.excludeRegionIdsScope!
        }
        if self.excludeResourceGroupIdsScope != nil {
            map["ExcludeResourceGroupIdsScope"] = self.excludeResourceGroupIdsScope!
        }
        if self.excludeResourceIdsScope != nil {
            map["ExcludeResourceIdsScope"] = self.excludeResourceIdsScope!
        }
        if self.excludeTagsScope != nil {
            var tmp : [Any] = []
            for k in self.excludeTagsScope! {
                tmp.append(k.toMap())
            }
            map["ExcludeTagsScope"] = tmp
        }
        if self.regionIdsScope != nil {
            map["RegionIdsScope"] = self.regionIdsScope!
        }
        if self.resourceGroupIdsScope != nil {
            map["ResourceGroupIdsScope"] = self.resourceGroupIdsScope!
        }
        if self.resourceIdsScope != nil {
            map["ResourceIdsScope"] = self.resourceIdsScope!
        }
        if self.riskLevel != nil {
            map["RiskLevel"] = self.riskLevel!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.tagKeyScope != nil {
            map["TagKeyScope"] = self.tagKeyScope!
        }
        if self.tagValueScope != nil {
            map["TagValueScope"] = self.tagValueScope!
        }
        if self.tagsScope != nil {
            var tmp : [Any] = []
            for k in self.tagsScope! {
                tmp.append(k.toMap())
            }
            map["TagsScope"] = tmp
        }
        if self.templateContent != nil {
            map["TemplateContent"] = self.templateContent!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AggregatorId"] as? String {
            self.aggregatorId = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["CompliancePackName"] as? String {
            self.compliancePackName = value
        }
        if let value = dict["CompliancePackTemplateId"] as? String {
            self.compliancePackTemplateId = value
        }
        if let value = dict["ConfigRules"] as? [Any?] {
            var tmp : [CreateAggregateCompliancePackRequest.ConfigRules] = []
            for v in value {
                if v != nil {
                    var model = CreateAggregateCompliancePackRequest.ConfigRules()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.configRules = tmp
        }
        if let value = dict["DefaultEnable"] as? Bool {
            self.defaultEnable = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["ExcludeRegionIdsScope"] as? String {
            self.excludeRegionIdsScope = value
        }
        if let value = dict["ExcludeResourceGroupIdsScope"] as? String {
            self.excludeResourceGroupIdsScope = value
        }
        if let value = dict["ExcludeResourceIdsScope"] as? String {
            self.excludeResourceIdsScope = value
        }
        if let value = dict["ExcludeTagsScope"] as? [Any?] {
            var tmp : [CreateAggregateCompliancePackRequest.ExcludeTagsScope] = []
            for v in value {
                if v != nil {
                    var model = CreateAggregateCompliancePackRequest.ExcludeTagsScope()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.excludeTagsScope = tmp
        }
        if let value = dict["RegionIdsScope"] as? String {
            self.regionIdsScope = value
        }
        if let value = dict["ResourceGroupIdsScope"] as? String {
            self.resourceGroupIdsScope = value
        }
        if let value = dict["ResourceIdsScope"] as? String {
            self.resourceIdsScope = value
        }
        if let value = dict["RiskLevel"] as? Int32 {
            self.riskLevel = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [CreateAggregateCompliancePackRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = CreateAggregateCompliancePackRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
        if let value = dict["TagKeyScope"] as? String {
            self.tagKeyScope = value
        }
        if let value = dict["TagValueScope"] as? String {
            self.tagValueScope = value
        }
        if let value = dict["TagsScope"] as? [Any?] {
            var tmp : [CreateAggregateCompliancePackRequest.TagsScope] = []
            for v in value {
                if v != nil {
                    var model = CreateAggregateCompliancePackRequest.TagsScope()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tagsScope = tmp
        }
        if let value = dict["TemplateContent"] as? String {
            self.templateContent = value
        }
    }
}

public class CreateAggregateCompliancePackShrinkRequest : Tea.TeaModel {
    public class ExcludeTagsScope : Tea.TeaModel {
        public var tagKey: String?

        public var tagValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tagKey != nil {
                map["TagKey"] = self.tagKey!
            }
            if self.tagValue != nil {
                map["TagValue"] = self.tagValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["TagKey"] as? String {
                self.tagKey = value
            }
            if let value = dict["TagValue"] as? String {
                self.tagValue = value
            }
        }
    }
    public class TagsScope : Tea.TeaModel {
        public var tagKey: String?

        public var tagValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tagKey != nil {
                map["TagKey"] = self.tagKey!
            }
            if self.tagValue != nil {
                map["TagValue"] = self.tagValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["TagKey"] as? String {
                self.tagKey = value
            }
            if let value = dict["TagValue"] as? String {
                self.tagValue = value
            }
        }
    }
    public var aggregatorId: String?

    public var clientToken: String?

    public var compliancePackName: String?

    public var compliancePackTemplateId: String?

    public var configRulesShrink: String?

    public var defaultEnable: Bool?

    public var description_: String?

    public var excludeRegionIdsScope: String?

    public var excludeResourceGroupIdsScope: String?

    public var excludeResourceIdsScope: String?

    public var excludeTagsScope: [CreateAggregateCompliancePackShrinkRequest.ExcludeTagsScope]?

    public var regionIdsScope: String?

    public var resourceGroupIdsScope: String?

    public var resourceIdsScope: String?

    public var riskLevel: Int32?

    public var tagShrink: String?

    public var tagKeyScope: String?

    public var tagValueScope: String?

    public var tagsScope: [CreateAggregateCompliancePackShrinkRequest.TagsScope]?

    public var templateContent: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aggregatorId != nil {
            map["AggregatorId"] = self.aggregatorId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.compliancePackName != nil {
            map["CompliancePackName"] = self.compliancePackName!
        }
        if self.compliancePackTemplateId != nil {
            map["CompliancePackTemplateId"] = self.compliancePackTemplateId!
        }
        if self.configRulesShrink != nil {
            map["ConfigRules"] = self.configRulesShrink!
        }
        if self.defaultEnable != nil {
            map["DefaultEnable"] = self.defaultEnable!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.excludeRegionIdsScope != nil {
            map["ExcludeRegionIdsScope"] = self.excludeRegionIdsScope!
        }
        if self.excludeResourceGroupIdsScope != nil {
            map["ExcludeResourceGroupIdsScope"] = self.excludeResourceGroupIdsScope!
        }
        if self.excludeResourceIdsScope != nil {
            map["ExcludeResourceIdsScope"] = self.excludeResourceIdsScope!
        }
        if self.excludeTagsScope != nil {
            var tmp : [Any] = []
            for k in self.excludeTagsScope! {
                tmp.append(k.toMap())
            }
            map["ExcludeTagsScope"] = tmp
        }
        if self.regionIdsScope != nil {
            map["RegionIdsScope"] = self.regionIdsScope!
        }
        if self.resourceGroupIdsScope != nil {
            map["ResourceGroupIdsScope"] = self.resourceGroupIdsScope!
        }
        if self.resourceIdsScope != nil {
            map["ResourceIdsScope"] = self.resourceIdsScope!
        }
        if self.riskLevel != nil {
            map["RiskLevel"] = self.riskLevel!
        }
        if self.tagShrink != nil {
            map["Tag"] = self.tagShrink!
        }
        if self.tagKeyScope != nil {
            map["TagKeyScope"] = self.tagKeyScope!
        }
        if self.tagValueScope != nil {
            map["TagValueScope"] = self.tagValueScope!
        }
        if self.tagsScope != nil {
            var tmp : [Any] = []
            for k in self.tagsScope! {
                tmp.append(k.toMap())
            }
            map["TagsScope"] = tmp
        }
        if self.templateContent != nil {
            map["TemplateContent"] = self.templateContent!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AggregatorId"] as? String {
            self.aggregatorId = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["CompliancePackName"] as? String {
            self.compliancePackName = value
        }
        if let value = dict["CompliancePackTemplateId"] as? String {
            self.compliancePackTemplateId = value
        }
        if let value = dict["ConfigRules"] as? String {
            self.configRulesShrink = value
        }
        if let value = dict["DefaultEnable"] as? Bool {
            self.defaultEnable = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["ExcludeRegionIdsScope"] as? String {
            self.excludeRegionIdsScope = value
        }
        if let value = dict["ExcludeResourceGroupIdsScope"] as? String {
            self.excludeResourceGroupIdsScope = value
        }
        if let value = dict["ExcludeResourceIdsScope"] as? String {
            self.excludeResourceIdsScope = value
        }
        if let value = dict["ExcludeTagsScope"] as? [Any?] {
            var tmp : [CreateAggregateCompliancePackShrinkRequest.ExcludeTagsScope] = []
            for v in value {
                if v != nil {
                    var model = CreateAggregateCompliancePackShrinkRequest.ExcludeTagsScope()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.excludeTagsScope = tmp
        }
        if let value = dict["RegionIdsScope"] as? String {
            self.regionIdsScope = value
        }
        if let value = dict["ResourceGroupIdsScope"] as? String {
            self.resourceGroupIdsScope = value
        }
        if let value = dict["ResourceIdsScope"] as? String {
            self.resourceIdsScope = value
        }
        if let value = dict["RiskLevel"] as? Int32 {
            self.riskLevel = value
        }
        if let value = dict["Tag"] as? String {
            self.tagShrink = value
        }
        if let value = dict["TagKeyScope"] as? String {
            self.tagKeyScope = value
        }
        if let value = dict["TagValueScope"] as? String {
            self.tagValueScope = value
        }
        if let value = dict["TagsScope"] as? [Any?] {
            var tmp : [CreateAggregateCompliancePackShrinkRequest.TagsScope] = []
            for v in value {
                if v != nil {
                    var model = CreateAggregateCompliancePackShrinkRequest.TagsScope()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tagsScope = tmp
        }
        if let value = dict["TemplateContent"] as? String {
            self.templateContent = value
        }
    }
}

public class CreateAggregateCompliancePackResponseBody : Tea.TeaModel {
    public var compliancePackId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.compliancePackId != nil {
            map["CompliancePackId"] = self.compliancePackId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CompliancePackId"] as? String {
            self.compliancePackId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateAggregateCompliancePackResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateAggregateCompliancePackResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateAggregateCompliancePackResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateAggregateConfigDeliveryChannelRequest : Tea.TeaModel {
    public var aggregatorId: String?

    public var clientToken: String?

    public var compliantSnapshot: Bool?

    public var configurationItemChangeNotification: Bool?

    public var configurationSnapshot: Bool?

    public var deliveryChannelCondition: String?

    public var deliveryChannelName: String?

    public var deliveryChannelTargetArn: String?

    public var deliveryChannelType: String?

    public var deliverySnapshotTime: String?

    public var description_: String?

    public var nonCompliantNotification: Bool?

    public var oversizedDataOSSTargetArn: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aggregatorId != nil {
            map["AggregatorId"] = self.aggregatorId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.compliantSnapshot != nil {
            map["CompliantSnapshot"] = self.compliantSnapshot!
        }
        if self.configurationItemChangeNotification != nil {
            map["ConfigurationItemChangeNotification"] = self.configurationItemChangeNotification!
        }
        if self.configurationSnapshot != nil {
            map["ConfigurationSnapshot"] = self.configurationSnapshot!
        }
        if self.deliveryChannelCondition != nil {
            map["DeliveryChannelCondition"] = self.deliveryChannelCondition!
        }
        if self.deliveryChannelName != nil {
            map["DeliveryChannelName"] = self.deliveryChannelName!
        }
        if self.deliveryChannelTargetArn != nil {
            map["DeliveryChannelTargetArn"] = self.deliveryChannelTargetArn!
        }
        if self.deliveryChannelType != nil {
            map["DeliveryChannelType"] = self.deliveryChannelType!
        }
        if self.deliverySnapshotTime != nil {
            map["DeliverySnapshotTime"] = self.deliverySnapshotTime!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.nonCompliantNotification != nil {
            map["NonCompliantNotification"] = self.nonCompliantNotification!
        }
        if self.oversizedDataOSSTargetArn != nil {
            map["OversizedDataOSSTargetArn"] = self.oversizedDataOSSTargetArn!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AggregatorId"] as? String {
            self.aggregatorId = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["CompliantSnapshot"] as? Bool {
            self.compliantSnapshot = value
        }
        if let value = dict["ConfigurationItemChangeNotification"] as? Bool {
            self.configurationItemChangeNotification = value
        }
        if let value = dict["ConfigurationSnapshot"] as? Bool {
            self.configurationSnapshot = value
        }
        if let value = dict["DeliveryChannelCondition"] as? String {
            self.deliveryChannelCondition = value
        }
        if let value = dict["DeliveryChannelName"] as? String {
            self.deliveryChannelName = value
        }
        if let value = dict["DeliveryChannelTargetArn"] as? String {
            self.deliveryChannelTargetArn = value
        }
        if let value = dict["DeliveryChannelType"] as? String {
            self.deliveryChannelType = value
        }
        if let value = dict["DeliverySnapshotTime"] as? String {
            self.deliverySnapshotTime = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["NonCompliantNotification"] as? Bool {
            self.nonCompliantNotification = value
        }
        if let value = dict["OversizedDataOSSTargetArn"] as? String {
            self.oversizedDataOSSTargetArn = value
        }
    }
}

public class CreateAggregateConfigDeliveryChannelResponseBody : Tea.TeaModel {
    public var deliveryChannelId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deliveryChannelId != nil {
            map["DeliveryChannelId"] = self.deliveryChannelId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DeliveryChannelId"] as? String {
            self.deliveryChannelId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateAggregateConfigDeliveryChannelResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateAggregateConfigDeliveryChannelResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateAggregateConfigDeliveryChannelResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateAggregateConfigRuleRequest : Tea.TeaModel {
    public class ExcludeTagsScope : Tea.TeaModel {
        public var tagKey: String?

        public var tagValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tagKey != nil {
                map["TagKey"] = self.tagKey!
            }
            if self.tagValue != nil {
                map["TagValue"] = self.tagValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["TagKey"] as? String {
                self.tagKey = value
            }
            if let value = dict["TagValue"] as? String {
                self.tagValue = value
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public class TagsScope : Tea.TeaModel {
        public var tagKey: String?

        public var tagValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tagKey != nil {
                map["TagKey"] = self.tagKey!
            }
            if self.tagValue != nil {
                map["TagValue"] = self.tagValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["TagKey"] as? String {
                self.tagKey = value
            }
            if let value = dict["TagValue"] as? String {
                self.tagValue = value
            }
        }
    }
    public var accountIdsScope: String?

    public var aggregatorId: String?

    public var clientToken: String?

    public var configRuleName: String?

    public var configRuleTriggerTypes: String?

    public var description_: String?

    public var excludeAccountIdsScope: String?

    public var excludeFolderIdsScope: String?

    public var excludeRegionIdsScope: String?

    public var excludeResourceGroupIdsScope: String?

    public var excludeResourceIdsScope: String?

    public var excludeTagsScope: [CreateAggregateConfigRuleRequest.ExcludeTagsScope]?

    public var extendContent: String?

    public var folderIdsScope: String?

    public var inputParameters: [String: Any]?

    public var maximumExecutionFrequency: String?

    public var regionIdsScope: String?

    public var resourceGroupIdsScope: String?

    public var resourceIdsScope: String?

    public var resourceNameScope: String?

    public var resourceTypesScope: [String]?

    public var riskLevel: Int32?

    public var sourceIdentifier: String?

    public var sourceOwner: String?

    public var tag: [CreateAggregateConfigRuleRequest.Tag]?

    public var tagKeyLogicScope: String?

    public var tagKeyScope: String?

    public var tagValueScope: String?

    public var tagsScope: [CreateAggregateConfigRuleRequest.TagsScope]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountIdsScope != nil {
            map["AccountIdsScope"] = self.accountIdsScope!
        }
        if self.aggregatorId != nil {
            map["AggregatorId"] = self.aggregatorId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.configRuleName != nil {
            map["ConfigRuleName"] = self.configRuleName!
        }
        if self.configRuleTriggerTypes != nil {
            map["ConfigRuleTriggerTypes"] = self.configRuleTriggerTypes!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.excludeAccountIdsScope != nil {
            map["ExcludeAccountIdsScope"] = self.excludeAccountIdsScope!
        }
        if self.excludeFolderIdsScope != nil {
            map["ExcludeFolderIdsScope"] = self.excludeFolderIdsScope!
        }
        if self.excludeRegionIdsScope != nil {
            map["ExcludeRegionIdsScope"] = self.excludeRegionIdsScope!
        }
        if self.excludeResourceGroupIdsScope != nil {
            map["ExcludeResourceGroupIdsScope"] = self.excludeResourceGroupIdsScope!
        }
        if self.excludeResourceIdsScope != nil {
            map["ExcludeResourceIdsScope"] = self.excludeResourceIdsScope!
        }
        if self.excludeTagsScope != nil {
            var tmp : [Any] = []
            for k in self.excludeTagsScope! {
                tmp.append(k.toMap())
            }
            map["ExcludeTagsScope"] = tmp
        }
        if self.extendContent != nil {
            map["ExtendContent"] = self.extendContent!
        }
        if self.folderIdsScope != nil {
            map["FolderIdsScope"] = self.folderIdsScope!
        }
        if self.inputParameters != nil {
            map["InputParameters"] = self.inputParameters!
        }
        if self.maximumExecutionFrequency != nil {
            map["MaximumExecutionFrequency"] = self.maximumExecutionFrequency!
        }
        if self.regionIdsScope != nil {
            map["RegionIdsScope"] = self.regionIdsScope!
        }
        if self.resourceGroupIdsScope != nil {
            map["ResourceGroupIdsScope"] = self.resourceGroupIdsScope!
        }
        if self.resourceIdsScope != nil {
            map["ResourceIdsScope"] = self.resourceIdsScope!
        }
        if self.resourceNameScope != nil {
            map["ResourceNameScope"] = self.resourceNameScope!
        }
        if self.resourceTypesScope != nil {
            map["ResourceTypesScope"] = self.resourceTypesScope!
        }
        if self.riskLevel != nil {
            map["RiskLevel"] = self.riskLevel!
        }
        if self.sourceIdentifier != nil {
            map["SourceIdentifier"] = self.sourceIdentifier!
        }
        if self.sourceOwner != nil {
            map["SourceOwner"] = self.sourceOwner!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.tagKeyLogicScope != nil {
            map["TagKeyLogicScope"] = self.tagKeyLogicScope!
        }
        if self.tagKeyScope != nil {
            map["TagKeyScope"] = self.tagKeyScope!
        }
        if self.tagValueScope != nil {
            map["TagValueScope"] = self.tagValueScope!
        }
        if self.tagsScope != nil {
            var tmp : [Any] = []
            for k in self.tagsScope! {
                tmp.append(k.toMap())
            }
            map["TagsScope"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AccountIdsScope"] as? String {
            self.accountIdsScope = value
        }
        if let value = dict["AggregatorId"] as? String {
            self.aggregatorId = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["ConfigRuleName"] as? String {
            self.configRuleName = value
        }
        if let value = dict["ConfigRuleTriggerTypes"] as? String {
            self.configRuleTriggerTypes = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["ExcludeAccountIdsScope"] as? String {
            self.excludeAccountIdsScope = value
        }
        if let value = dict["ExcludeFolderIdsScope"] as? String {
            self.excludeFolderIdsScope = value
        }
        if let value = dict["ExcludeRegionIdsScope"] as? String {
            self.excludeRegionIdsScope = value
        }
        if let value = dict["ExcludeResourceGroupIdsScope"] as? String {
            self.excludeResourceGroupIdsScope = value
        }
        if let value = dict["ExcludeResourceIdsScope"] as? String {
            self.excludeResourceIdsScope = value
        }
        if let value = dict["ExcludeTagsScope"] as? [Any?] {
            var tmp : [CreateAggregateConfigRuleRequest.ExcludeTagsScope] = []
            for v in value {
                if v != nil {
                    var model = CreateAggregateConfigRuleRequest.ExcludeTagsScope()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.excludeTagsScope = tmp
        }
        if let value = dict["ExtendContent"] as? String {
            self.extendContent = value
        }
        if let value = dict["FolderIdsScope"] as? String {
            self.folderIdsScope = value
        }
        if let value = dict["InputParameters"] as? [String: Any] {
            self.inputParameters = value
        }
        if let value = dict["MaximumExecutionFrequency"] as? String {
            self.maximumExecutionFrequency = value
        }
        if let value = dict["RegionIdsScope"] as? String {
            self.regionIdsScope = value
        }
        if let value = dict["ResourceGroupIdsScope"] as? String {
            self.resourceGroupIdsScope = value
        }
        if let value = dict["ResourceIdsScope"] as? String {
            self.resourceIdsScope = value
        }
        if let value = dict["ResourceNameScope"] as? String {
            self.resourceNameScope = value
        }
        if let value = dict["ResourceTypesScope"] as? [String] {
            self.resourceTypesScope = value
        }
        if let value = dict["RiskLevel"] as? Int32 {
            self.riskLevel = value
        }
        if let value = dict["SourceIdentifier"] as? String {
            self.sourceIdentifier = value
        }
        if let value = dict["SourceOwner"] as? String {
            self.sourceOwner = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [CreateAggregateConfigRuleRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = CreateAggregateConfigRuleRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
        if let value = dict["TagKeyLogicScope"] as? String {
            self.tagKeyLogicScope = value
        }
        if let value = dict["TagKeyScope"] as? String {
            self.tagKeyScope = value
        }
        if let value = dict["TagValueScope"] as? String {
            self.tagValueScope = value
        }
        if let value = dict["TagsScope"] as? [Any?] {
            var tmp : [CreateAggregateConfigRuleRequest.TagsScope] = []
            for v in value {
                if v != nil {
                    var model = CreateAggregateConfigRuleRequest.TagsScope()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tagsScope = tmp
        }
    }
}

public class CreateAggregateConfigRuleShrinkRequest : Tea.TeaModel {
    public class ExcludeTagsScope : Tea.TeaModel {
        public var tagKey: String?

        public var tagValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tagKey != nil {
                map["TagKey"] = self.tagKey!
            }
            if self.tagValue != nil {
                map["TagValue"] = self.tagValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["TagKey"] as? String {
                self.tagKey = value
            }
            if let value = dict["TagValue"] as? String {
                self.tagValue = value
            }
        }
    }
    public class TagsScope : Tea.TeaModel {
        public var tagKey: String?

        public var tagValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tagKey != nil {
                map["TagKey"] = self.tagKey!
            }
            if self.tagValue != nil {
                map["TagValue"] = self.tagValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["TagKey"] as? String {
                self.tagKey = value
            }
            if let value = dict["TagValue"] as? String {
                self.tagValue = value
            }
        }
    }
    public var accountIdsScope: String?

    public var aggregatorId: String?

    public var clientToken: String?

    public var configRuleName: String?

    public var configRuleTriggerTypes: String?

    public var description_: String?

    public var excludeAccountIdsScope: String?

    public var excludeFolderIdsScope: String?

    public var excludeRegionIdsScope: String?

    public var excludeResourceGroupIdsScope: String?

    public var excludeResourceIdsScope: String?

    public var excludeTagsScope: [CreateAggregateConfigRuleShrinkRequest.ExcludeTagsScope]?

    public var extendContent: String?

    public var folderIdsScope: String?

    public var inputParametersShrink: String?

    public var maximumExecutionFrequency: String?

    public var regionIdsScope: String?

    public var resourceGroupIdsScope: String?

    public var resourceIdsScope: String?

    public var resourceNameScope: String?

    public var resourceTypesScopeShrink: String?

    public var riskLevel: Int32?

    public var sourceIdentifier: String?

    public var sourceOwner: String?

    public var tagShrink: String?

    public var tagKeyLogicScope: String?

    public var tagKeyScope: String?

    public var tagValueScope: String?

    public var tagsScope: [CreateAggregateConfigRuleShrinkRequest.TagsScope]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountIdsScope != nil {
            map["AccountIdsScope"] = self.accountIdsScope!
        }
        if self.aggregatorId != nil {
            map["AggregatorId"] = self.aggregatorId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.configRuleName != nil {
            map["ConfigRuleName"] = self.configRuleName!
        }
        if self.configRuleTriggerTypes != nil {
            map["ConfigRuleTriggerTypes"] = self.configRuleTriggerTypes!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.excludeAccountIdsScope != nil {
            map["ExcludeAccountIdsScope"] = self.excludeAccountIdsScope!
        }
        if self.excludeFolderIdsScope != nil {
            map["ExcludeFolderIdsScope"] = self.excludeFolderIdsScope!
        }
        if self.excludeRegionIdsScope != nil {
            map["ExcludeRegionIdsScope"] = self.excludeRegionIdsScope!
        }
        if self.excludeResourceGroupIdsScope != nil {
            map["ExcludeResourceGroupIdsScope"] = self.excludeResourceGroupIdsScope!
        }
        if self.excludeResourceIdsScope != nil {
            map["ExcludeResourceIdsScope"] = self.excludeResourceIdsScope!
        }
        if self.excludeTagsScope != nil {
            var tmp : [Any] = []
            for k in self.excludeTagsScope! {
                tmp.append(k.toMap())
            }
            map["ExcludeTagsScope"] = tmp
        }
        if self.extendContent != nil {
            map["ExtendContent"] = self.extendContent!
        }
        if self.folderIdsScope != nil {
            map["FolderIdsScope"] = self.folderIdsScope!
        }
        if self.inputParametersShrink != nil {
            map["InputParameters"] = self.inputParametersShrink!
        }
        if self.maximumExecutionFrequency != nil {
            map["MaximumExecutionFrequency"] = self.maximumExecutionFrequency!
        }
        if self.regionIdsScope != nil {
            map["RegionIdsScope"] = self.regionIdsScope!
        }
        if self.resourceGroupIdsScope != nil {
            map["ResourceGroupIdsScope"] = self.resourceGroupIdsScope!
        }
        if self.resourceIdsScope != nil {
            map["ResourceIdsScope"] = self.resourceIdsScope!
        }
        if self.resourceNameScope != nil {
            map["ResourceNameScope"] = self.resourceNameScope!
        }
        if self.resourceTypesScopeShrink != nil {
            map["ResourceTypesScope"] = self.resourceTypesScopeShrink!
        }
        if self.riskLevel != nil {
            map["RiskLevel"] = self.riskLevel!
        }
        if self.sourceIdentifier != nil {
            map["SourceIdentifier"] = self.sourceIdentifier!
        }
        if self.sourceOwner != nil {
            map["SourceOwner"] = self.sourceOwner!
        }
        if self.tagShrink != nil {
            map["Tag"] = self.tagShrink!
        }
        if self.tagKeyLogicScope != nil {
            map["TagKeyLogicScope"] = self.tagKeyLogicScope!
        }
        if self.tagKeyScope != nil {
            map["TagKeyScope"] = self.tagKeyScope!
        }
        if self.tagValueScope != nil {
            map["TagValueScope"] = self.tagValueScope!
        }
        if self.tagsScope != nil {
            var tmp : [Any] = []
            for k in self.tagsScope! {
                tmp.append(k.toMap())
            }
            map["TagsScope"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AccountIdsScope"] as? String {
            self.accountIdsScope = value
        }
        if let value = dict["AggregatorId"] as? String {
            self.aggregatorId = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["ConfigRuleName"] as? String {
            self.configRuleName = value
        }
        if let value = dict["ConfigRuleTriggerTypes"] as? String {
            self.configRuleTriggerTypes = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["ExcludeAccountIdsScope"] as? String {
            self.excludeAccountIdsScope = value
        }
        if let value = dict["ExcludeFolderIdsScope"] as? String {
            self.excludeFolderIdsScope = value
        }
        if let value = dict["ExcludeRegionIdsScope"] as? String {
            self.excludeRegionIdsScope = value
        }
        if let value = dict["ExcludeResourceGroupIdsScope"] as? String {
            self.excludeResourceGroupIdsScope = value
        }
        if let value = dict["ExcludeResourceIdsScope"] as? String {
            self.excludeResourceIdsScope = value
        }
        if let value = dict["ExcludeTagsScope"] as? [Any?] {
            var tmp : [CreateAggregateConfigRuleShrinkRequest.ExcludeTagsScope] = []
            for v in value {
                if v != nil {
                    var model = CreateAggregateConfigRuleShrinkRequest.ExcludeTagsScope()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.excludeTagsScope = tmp
        }
        if let value = dict["ExtendContent"] as? String {
            self.extendContent = value
        }
        if let value = dict["FolderIdsScope"] as? String {
            self.folderIdsScope = value
        }
        if let value = dict["InputParameters"] as? String {
            self.inputParametersShrink = value
        }
        if let value = dict["MaximumExecutionFrequency"] as? String {
            self.maximumExecutionFrequency = value
        }
        if let value = dict["RegionIdsScope"] as? String {
            self.regionIdsScope = value
        }
        if let value = dict["ResourceGroupIdsScope"] as? String {
            self.resourceGroupIdsScope = value
        }
        if let value = dict["ResourceIdsScope"] as? String {
            self.resourceIdsScope = value
        }
        if let value = dict["ResourceNameScope"] as? String {
            self.resourceNameScope = value
        }
        if let value = dict["ResourceTypesScope"] as? String {
            self.resourceTypesScopeShrink = value
        }
        if let value = dict["RiskLevel"] as? Int32 {
            self.riskLevel = value
        }
        if let value = dict["SourceIdentifier"] as? String {
            self.sourceIdentifier = value
        }
        if let value = dict["SourceOwner"] as? String {
            self.sourceOwner = value
        }
        if let value = dict["Tag"] as? String {
            self.tagShrink = value
        }
        if let value = dict["TagKeyLogicScope"] as? String {
            self.tagKeyLogicScope = value
        }
        if let value = dict["TagKeyScope"] as? String {
            self.tagKeyScope = value
        }
        if let value = dict["TagValueScope"] as? String {
            self.tagValueScope = value
        }
        if let value = dict["TagsScope"] as? [Any?] {
            var tmp : [CreateAggregateConfigRuleShrinkRequest.TagsScope] = []
            for v in value {
                if v != nil {
                    var model = CreateAggregateConfigRuleShrinkRequest.TagsScope()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tagsScope = tmp
        }
    }
}

public class CreateAggregateConfigRuleResponseBody : Tea.TeaModel {
    public var configRuleId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configRuleId != nil {
            map["ConfigRuleId"] = self.configRuleId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ConfigRuleId"] as? String {
            self.configRuleId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateAggregateConfigRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateAggregateConfigRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateAggregateConfigRuleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateAggregateRemediationRequest : Tea.TeaModel {
    public var aggregatorId: String?

    public var clientToken: String?

    public var configRuleId: String?

    public var invokeType: String?

    public var params: String?

    public var remediationTemplateId: String?

    public var remediationType: String?

    public var sourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aggregatorId != nil {
            map["AggregatorId"] = self.aggregatorId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.configRuleId != nil {
            map["ConfigRuleId"] = self.configRuleId!
        }
        if self.invokeType != nil {
            map["InvokeType"] = self.invokeType!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.remediationTemplateId != nil {
            map["RemediationTemplateId"] = self.remediationTemplateId!
        }
        if self.remediationType != nil {
            map["RemediationType"] = self.remediationType!
        }
        if self.sourceType != nil {
            map["SourceType"] = self.sourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AggregatorId"] as? String {
            self.aggregatorId = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["ConfigRuleId"] as? String {
            self.configRuleId = value
        }
        if let value = dict["InvokeType"] as? String {
            self.invokeType = value
        }
        if let value = dict["Params"] as? String {
            self.params = value
        }
        if let value = dict["RemediationTemplateId"] as? String {
            self.remediationTemplateId = value
        }
        if let value = dict["RemediationType"] as? String {
            self.remediationType = value
        }
        if let value = dict["SourceType"] as? String {
            self.sourceType = value
        }
    }
}

public class CreateAggregateRemediationResponseBody : Tea.TeaModel {
    public var remediationId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.remediationId != nil {
            map["RemediationId"] = self.remediationId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RemediationId"] as? String {
            self.remediationId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateAggregateRemediationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateAggregateRemediationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateAggregateRemediationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateAggregatorRequest : Tea.TeaModel {
    public class AggregatorAccounts : Tea.TeaModel {
        public var accountId: Int64?

        public var accountName: String?

        public var accountType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["AccountId"] = self.accountId!
            }
            if self.accountName != nil {
                map["AccountName"] = self.accountName!
            }
            if self.accountType != nil {
                map["AccountType"] = self.accountType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AccountId"] as? Int64 {
                self.accountId = value
            }
            if let value = dict["AccountName"] as? String {
                self.accountName = value
            }
            if let value = dict["AccountType"] as? String {
                self.accountType = value
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var aggregatorAccounts: [CreateAggregatorRequest.AggregatorAccounts]?

    public var aggregatorName: String?

    public var aggregatorType: String?

    public var clientToken: String?

    public var description_: String?

    public var folderId: String?

    public var tag: [CreateAggregatorRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aggregatorAccounts != nil {
            var tmp : [Any] = []
            for k in self.aggregatorAccounts! {
                tmp.append(k.toMap())
            }
            map["AggregatorAccounts"] = tmp
        }
        if self.aggregatorName != nil {
            map["AggregatorName"] = self.aggregatorName!
        }
        if self.aggregatorType != nil {
            map["AggregatorType"] = self.aggregatorType!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.folderId != nil {
            map["FolderId"] = self.folderId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AggregatorAccounts"] as? [Any?] {
            var tmp : [CreateAggregatorRequest.AggregatorAccounts] = []
            for v in value {
                if v != nil {
                    var model = CreateAggregatorRequest.AggregatorAccounts()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.aggregatorAccounts = tmp
        }
        if let value = dict["AggregatorName"] as? String {
            self.aggregatorName = value
        }
        if let value = dict["AggregatorType"] as? String {
            self.aggregatorType = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["FolderId"] as? String {
            self.folderId = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [CreateAggregatorRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = CreateAggregatorRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
    }
}

public class CreateAggregatorShrinkRequest : Tea.TeaModel {
    public var aggregatorAccountsShrink: String?

    public var aggregatorName: String?

    public var aggregatorType: String?

    public var clientToken: String?

    public var description_: String?

    public var folderId: String?

    public var tagShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aggregatorAccountsShrink != nil {
            map["AggregatorAccounts"] = self.aggregatorAccountsShrink!
        }
        if self.aggregatorName != nil {
            map["AggregatorName"] = self.aggregatorName!
        }
        if self.aggregatorType != nil {
            map["AggregatorType"] = self.aggregatorType!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.folderId != nil {
            map["FolderId"] = self.folderId!
        }
        if self.tagShrink != nil {
            map["Tag"] = self.tagShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AggregatorAccounts"] as? String {
            self.aggregatorAccountsShrink = value
        }
        if let value = dict["AggregatorName"] as? String {
            self.aggregatorName = value
        }
        if let value = dict["AggregatorType"] as? String {
            self.aggregatorType = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["FolderId"] as? String {
            self.folderId = value
        }
        if let value = dict["Tag"] as? String {
            self.tagShrink = value
        }
    }
}

public class CreateAggregatorResponseBody : Tea.TeaModel {
    public var aggregatorId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aggregatorId != nil {
            map["AggregatorId"] = self.aggregatorId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AggregatorId"] as? String {
            self.aggregatorId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateAggregatorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateAggregatorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateAggregatorResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateCompliancePackRequest : Tea.TeaModel {
    public class ConfigRules : Tea.TeaModel {
        public class ConfigRuleParameters : Tea.TeaModel {
            public var parameterName: String?

            public var parameterValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.parameterName != nil {
                    map["ParameterName"] = self.parameterName!
                }
                if self.parameterValue != nil {
                    map["ParameterValue"] = self.parameterValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ParameterName"] as? String {
                    self.parameterName = value
                }
                if let value = dict["ParameterValue"] as? String {
                    self.parameterValue = value
                }
            }
        }
        public var configRuleId: String?

        public var configRuleName: String?

        public var configRuleParameters: [CreateCompliancePackRequest.ConfigRules.ConfigRuleParameters]?

        public var description_: String?

        public var managedRuleIdentifier: String?

        public var riskLevel: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.configRuleId != nil {
                map["ConfigRuleId"] = self.configRuleId!
            }
            if self.configRuleName != nil {
                map["ConfigRuleName"] = self.configRuleName!
            }
            if self.configRuleParameters != nil {
                var tmp : [Any] = []
                for k in self.configRuleParameters! {
                    tmp.append(k.toMap())
                }
                map["ConfigRuleParameters"] = tmp
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.managedRuleIdentifier != nil {
                map["ManagedRuleIdentifier"] = self.managedRuleIdentifier!
            }
            if self.riskLevel != nil {
                map["RiskLevel"] = self.riskLevel!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ConfigRuleId"] as? String {
                self.configRuleId = value
            }
            if let value = dict["ConfigRuleName"] as? String {
                self.configRuleName = value
            }
            if let value = dict["ConfigRuleParameters"] as? [Any?] {
                var tmp : [CreateCompliancePackRequest.ConfigRules.ConfigRuleParameters] = []
                for v in value {
                    if v != nil {
                        var model = CreateCompliancePackRequest.ConfigRules.ConfigRuleParameters()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.configRuleParameters = tmp
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["ManagedRuleIdentifier"] as? String {
                self.managedRuleIdentifier = value
            }
            if let value = dict["RiskLevel"] as? Int32 {
                self.riskLevel = value
            }
        }
    }
    public class ExcludeTagsScope : Tea.TeaModel {
        public var tagKey: String?

        public var tagValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tagKey != nil {
                map["TagKey"] = self.tagKey!
            }
            if self.tagValue != nil {
                map["TagValue"] = self.tagValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["TagKey"] as? String {
                self.tagKey = value
            }
            if let value = dict["TagValue"] as? String {
                self.tagValue = value
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public class TagsScope : Tea.TeaModel {
        public var tagKey: String?

        public var tagValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tagKey != nil {
                map["TagKey"] = self.tagKey!
            }
            if self.tagValue != nil {
                map["TagValue"] = self.tagValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["TagKey"] as? String {
                self.tagKey = value
            }
            if let value = dict["TagValue"] as? String {
                self.tagValue = value
            }
        }
    }
    public var clientToken: String?

    public var compliancePackName: String?

    public var compliancePackTemplateId: String?

    public var configRules: [CreateCompliancePackRequest.ConfigRules]?

    public var defaultEnable: Bool?

    public var description_: String?

    public var excludeRegionIdsScope: String?

    public var excludeResourceGroupIdsScope: String?

    public var excludeResourceIdsScope: String?

    public var excludeTagsScope: [CreateCompliancePackRequest.ExcludeTagsScope]?

    public var regionIdsScope: String?

    public var resourceGroupIdsScope: String?

    public var resourceIdsScope: String?

    public var riskLevel: Int32?

    public var tag: [CreateCompliancePackRequest.Tag]?

    public var tagKeyScope: String?

    public var tagValueScope: String?

    public var tagsScope: [CreateCompliancePackRequest.TagsScope]?

    public var templateContent: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.compliancePackName != nil {
            map["CompliancePackName"] = self.compliancePackName!
        }
        if self.compliancePackTemplateId != nil {
            map["CompliancePackTemplateId"] = self.compliancePackTemplateId!
        }
        if self.configRules != nil {
            var tmp : [Any] = []
            for k in self.configRules! {
                tmp.append(k.toMap())
            }
            map["ConfigRules"] = tmp
        }
        if self.defaultEnable != nil {
            map["DefaultEnable"] = self.defaultEnable!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.excludeRegionIdsScope != nil {
            map["ExcludeRegionIdsScope"] = self.excludeRegionIdsScope!
        }
        if self.excludeResourceGroupIdsScope != nil {
            map["ExcludeResourceGroupIdsScope"] = self.excludeResourceGroupIdsScope!
        }
        if self.excludeResourceIdsScope != nil {
            map["ExcludeResourceIdsScope"] = self.excludeResourceIdsScope!
        }
        if self.excludeTagsScope != nil {
            var tmp : [Any] = []
            for k in self.excludeTagsScope! {
                tmp.append(k.toMap())
            }
            map["ExcludeTagsScope"] = tmp
        }
        if self.regionIdsScope != nil {
            map["RegionIdsScope"] = self.regionIdsScope!
        }
        if self.resourceGroupIdsScope != nil {
            map["ResourceGroupIdsScope"] = self.resourceGroupIdsScope!
        }
        if self.resourceIdsScope != nil {
            map["ResourceIdsScope"] = self.resourceIdsScope!
        }
        if self.riskLevel != nil {
            map["RiskLevel"] = self.riskLevel!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.tagKeyScope != nil {
            map["TagKeyScope"] = self.tagKeyScope!
        }
        if self.tagValueScope != nil {
            map["TagValueScope"] = self.tagValueScope!
        }
        if self.tagsScope != nil {
            var tmp : [Any] = []
            for k in self.tagsScope! {
                tmp.append(k.toMap())
            }
            map["TagsScope"] = tmp
        }
        if self.templateContent != nil {
            map["TemplateContent"] = self.templateContent!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["CompliancePackName"] as? String {
            self.compliancePackName = value
        }
        if let value = dict["CompliancePackTemplateId"] as? String {
            self.compliancePackTemplateId = value
        }
        if let value = dict["ConfigRules"] as? [Any?] {
            var tmp : [CreateCompliancePackRequest.ConfigRules] = []
            for v in value {
                if v != nil {
                    var model = CreateCompliancePackRequest.ConfigRules()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.configRules = tmp
        }
        if let value = dict["DefaultEnable"] as? Bool {
            self.defaultEnable = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["ExcludeRegionIdsScope"] as? String {
            self.excludeRegionIdsScope = value
        }
        if let value = dict["ExcludeResourceGroupIdsScope"] as? String {
            self.excludeResourceGroupIdsScope = value
        }
        if let value = dict["ExcludeResourceIdsScope"] as? String {
            self.excludeResourceIdsScope = value
        }
        if let value = dict["ExcludeTagsScope"] as? [Any?] {
            var tmp : [CreateCompliancePackRequest.ExcludeTagsScope] = []
            for v in value {
                if v != nil {
                    var model = CreateCompliancePackRequest.ExcludeTagsScope()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.excludeTagsScope = tmp
        }
        if let value = dict["RegionIdsScope"] as? String {
            self.regionIdsScope = value
        }
        if let value = dict["ResourceGroupIdsScope"] as? String {
            self.resourceGroupIdsScope = value
        }
        if let value = dict["ResourceIdsScope"] as? String {
            self.resourceIdsScope = value
        }
        if let value = dict["RiskLevel"] as? Int32 {
            self.riskLevel = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [CreateCompliancePackRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = CreateCompliancePackRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
        if let value = dict["TagKeyScope"] as? String {
            self.tagKeyScope = value
        }
        if let value = dict["TagValueScope"] as? String {
            self.tagValueScope = value
        }
        if let value = dict["TagsScope"] as? [Any?] {
            var tmp : [CreateCompliancePackRequest.TagsScope] = []
            for v in value {
                if v != nil {
                    var model = CreateCompliancePackRequest.TagsScope()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tagsScope = tmp
        }
        if let value = dict["TemplateContent"] as? String {
            self.templateContent = value
        }
    }
}

public class CreateCompliancePackShrinkRequest : Tea.TeaModel {
    public class ExcludeTagsScope : Tea.TeaModel {
        public var tagKey: String?

        public var tagValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tagKey != nil {
                map["TagKey"] = self.tagKey!
            }
            if self.tagValue != nil {
                map["TagValue"] = self.tagValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["TagKey"] as? String {
                self.tagKey = value
            }
            if let value = dict["TagValue"] as? String {
                self.tagValue = value
            }
        }
    }
    public class TagsScope : Tea.TeaModel {
        public var tagKey: String?

        public var tagValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tagKey != nil {
                map["TagKey"] = self.tagKey!
            }
            if self.tagValue != nil {
                map["TagValue"] = self.tagValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["TagKey"] as? String {
                self.tagKey = value
            }
            if let value = dict["TagValue"] as? String {
                self.tagValue = value
            }
        }
    }
    public var clientToken: String?

    public var compliancePackName: String?

    public var compliancePackTemplateId: String?

    public var configRulesShrink: String?

    public var defaultEnable: Bool?

    public var description_: String?

    public var excludeRegionIdsScope: String?

    public var excludeResourceGroupIdsScope: String?

    public var excludeResourceIdsScope: String?

    public var excludeTagsScope: [CreateCompliancePackShrinkRequest.ExcludeTagsScope]?

    public var regionIdsScope: String?

    public var resourceGroupIdsScope: String?

    public var resourceIdsScope: String?

    public var riskLevel: Int32?

    public var tagShrink: String?

    public var tagKeyScope: String?

    public var tagValueScope: String?

    public var tagsScope: [CreateCompliancePackShrinkRequest.TagsScope]?

    public var templateContent: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.compliancePackName != nil {
            map["CompliancePackName"] = self.compliancePackName!
        }
        if self.compliancePackTemplateId != nil {
            map["CompliancePackTemplateId"] = self.compliancePackTemplateId!
        }
        if self.configRulesShrink != nil {
            map["ConfigRules"] = self.configRulesShrink!
        }
        if self.defaultEnable != nil {
            map["DefaultEnable"] = self.defaultEnable!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.excludeRegionIdsScope != nil {
            map["ExcludeRegionIdsScope"] = self.excludeRegionIdsScope!
        }
        if self.excludeResourceGroupIdsScope != nil {
            map["ExcludeResourceGroupIdsScope"] = self.excludeResourceGroupIdsScope!
        }
        if self.excludeResourceIdsScope != nil {
            map["ExcludeResourceIdsScope"] = self.excludeResourceIdsScope!
        }
        if self.excludeTagsScope != nil {
            var tmp : [Any] = []
            for k in self.excludeTagsScope! {
                tmp.append(k.toMap())
            }
            map["ExcludeTagsScope"] = tmp
        }
        if self.regionIdsScope != nil {
            map["RegionIdsScope"] = self.regionIdsScope!
        }
        if self.resourceGroupIdsScope != nil {
            map["ResourceGroupIdsScope"] = self.resourceGroupIdsScope!
        }
        if self.resourceIdsScope != nil {
            map["ResourceIdsScope"] = self.resourceIdsScope!
        }
        if self.riskLevel != nil {
            map["RiskLevel"] = self.riskLevel!
        }
        if self.tagShrink != nil {
            map["Tag"] = self.tagShrink!
        }
        if self.tagKeyScope != nil {
            map["TagKeyScope"] = self.tagKeyScope!
        }
        if self.tagValueScope != nil {
            map["TagValueScope"] = self.tagValueScope!
        }
        if self.tagsScope != nil {
            var tmp : [Any] = []
            for k in self.tagsScope! {
                tmp.append(k.toMap())
            }
            map["TagsScope"] = tmp
        }
        if self.templateContent != nil {
            map["TemplateContent"] = self.templateContent!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["CompliancePackName"] as? String {
            self.compliancePackName = value
        }
        if let value = dict["CompliancePackTemplateId"] as? String {
            self.compliancePackTemplateId = value
        }
        if let value = dict["ConfigRules"] as? String {
            self.configRulesShrink = value
        }
        if let value = dict["DefaultEnable"] as? Bool {
            self.defaultEnable = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["ExcludeRegionIdsScope"] as? String {
            self.excludeRegionIdsScope = value
        }
        if let value = dict["ExcludeResourceGroupIdsScope"] as? String {
            self.excludeResourceGroupIdsScope = value
        }
        if let value = dict["ExcludeResourceIdsScope"] as? String {
            self.excludeResourceIdsScope = value
        }
        if let value = dict["ExcludeTagsScope"] as? [Any?] {
            var tmp : [CreateCompliancePackShrinkRequest.ExcludeTagsScope] = []
            for v in value {
                if v != nil {
                    var model = CreateCompliancePackShrinkRequest.ExcludeTagsScope()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.excludeTagsScope = tmp
        }
        if let value = dict["RegionIdsScope"] as? String {
            self.regionIdsScope = value
        }
        if let value = dict["ResourceGroupIdsScope"] as? String {
            self.resourceGroupIdsScope = value
        }
        if let value = dict["ResourceIdsScope"] as? String {
            self.resourceIdsScope = value
        }
        if let value = dict["RiskLevel"] as? Int32 {
            self.riskLevel = value
        }
        if let value = dict["Tag"] as? String {
            self.tagShrink = value
        }
        if let value = dict["TagKeyScope"] as? String {
            self.tagKeyScope = value
        }
        if let value = dict["TagValueScope"] as? String {
            self.tagValueScope = value
        }
        if let value = dict["TagsScope"] as? [Any?] {
            var tmp : [CreateCompliancePackShrinkRequest.TagsScope] = []
            for v in value {
                if v != nil {
                    var model = CreateCompliancePackShrinkRequest.TagsScope()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tagsScope = tmp
        }
        if let value = dict["TemplateContent"] as? String {
            self.templateContent = value
        }
    }
}

public class CreateCompliancePackResponseBody : Tea.TeaModel {
    public var compliancePackId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.compliancePackId != nil {
            map["CompliancePackId"] = self.compliancePackId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CompliancePackId"] as? String {
            self.compliancePackId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateCompliancePackResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateCompliancePackResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateCompliancePackResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateConfigDeliveryChannelRequest : Tea.TeaModel {
    public var clientToken: String?

    public var compliantSnapshot: Bool?

    public var configurationItemChangeNotification: Bool?

    public var configurationSnapshot: Bool?

    public var deliveryChannelCondition: String?

    public var deliveryChannelName: String?

    public var deliveryChannelTargetArn: String?

    public var deliveryChannelType: String?

    public var deliverySnapshotTime: String?

    public var description_: String?

    public var nonCompliantNotification: Bool?

    public var oversizedDataOSSTargetArn: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.compliantSnapshot != nil {
            map["CompliantSnapshot"] = self.compliantSnapshot!
        }
        if self.configurationItemChangeNotification != nil {
            map["ConfigurationItemChangeNotification"] = self.configurationItemChangeNotification!
        }
        if self.configurationSnapshot != nil {
            map["ConfigurationSnapshot"] = self.configurationSnapshot!
        }
        if self.deliveryChannelCondition != nil {
            map["DeliveryChannelCondition"] = self.deliveryChannelCondition!
        }
        if self.deliveryChannelName != nil {
            map["DeliveryChannelName"] = self.deliveryChannelName!
        }
        if self.deliveryChannelTargetArn != nil {
            map["DeliveryChannelTargetArn"] = self.deliveryChannelTargetArn!
        }
        if self.deliveryChannelType != nil {
            map["DeliveryChannelType"] = self.deliveryChannelType!
        }
        if self.deliverySnapshotTime != nil {
            map["DeliverySnapshotTime"] = self.deliverySnapshotTime!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.nonCompliantNotification != nil {
            map["NonCompliantNotification"] = self.nonCompliantNotification!
        }
        if self.oversizedDataOSSTargetArn != nil {
            map["OversizedDataOSSTargetArn"] = self.oversizedDataOSSTargetArn!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["CompliantSnapshot"] as? Bool {
            self.compliantSnapshot = value
        }
        if let value = dict["ConfigurationItemChangeNotification"] as? Bool {
            self.configurationItemChangeNotification = value
        }
        if let value = dict["ConfigurationSnapshot"] as? Bool {
            self.configurationSnapshot = value
        }
        if let value = dict["DeliveryChannelCondition"] as? String {
            self.deliveryChannelCondition = value
        }
        if let value = dict["DeliveryChannelName"] as? String {
            self.deliveryChannelName = value
        }
        if let value = dict["DeliveryChannelTargetArn"] as? String {
            self.deliveryChannelTargetArn = value
        }
        if let value = dict["DeliveryChannelType"] as? String {
            self.deliveryChannelType = value
        }
        if let value = dict["DeliverySnapshotTime"] as? String {
            self.deliverySnapshotTime = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["NonCompliantNotification"] as? Bool {
            self.nonCompliantNotification = value
        }
        if let value = dict["OversizedDataOSSTargetArn"] as? String {
            self.oversizedDataOSSTargetArn = value
        }
    }
}

public class CreateConfigDeliveryChannelResponseBody : Tea.TeaModel {
    public var deliveryChannelId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deliveryChannelId != nil {
            map["DeliveryChannelId"] = self.deliveryChannelId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DeliveryChannelId"] as? String {
            self.deliveryChannelId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateConfigDeliveryChannelResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateConfigDeliveryChannelResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateConfigDeliveryChannelResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateConfigRuleRequest : Tea.TeaModel {
    public class ExcludeTagsScope : Tea.TeaModel {
        public var tagKey: String?

        public var tagValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tagKey != nil {
                map["TagKey"] = self.tagKey!
            }
            if self.tagValue != nil {
                map["TagValue"] = self.tagValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["TagKey"] as? String {
                self.tagKey = value
            }
            if let value = dict["TagValue"] as? String {
                self.tagValue = value
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public class TagsScope : Tea.TeaModel {
        public var tagKey: String?

        public var tagValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tagKey != nil {
                map["TagKey"] = self.tagKey!
            }
            if self.tagValue != nil {
                map["TagValue"] = self.tagValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["TagKey"] as? String {
                self.tagKey = value
            }
            if let value = dict["TagValue"] as? String {
                self.tagValue = value
            }
        }
    }
    public var clientToken: String?

    public var configRuleName: String?

    public var configRuleTriggerTypes: String?

    public var description_: String?

    public var excludeRegionIdsScope: String?

    public var excludeResourceGroupIdsScope: String?

    public var excludeResourceIdsScope: String?

    public var excludeTagsScope: [CreateConfigRuleRequest.ExcludeTagsScope]?

    public var extendContent: String?

    public var inputParameters: [String: Any]?

    public var maximumExecutionFrequency: String?

    public var regionIdsScope: String?

    public var resourceGroupIdsScope: String?

    public var resourceIdsScope: String?

    public var resourceNameScope: String?

    public var resourceTypesScope: [String]?

    public var riskLevel: Int32?

    public var sourceIdentifier: String?

    public var sourceOwner: String?

    public var tag: [CreateConfigRuleRequest.Tag]?

    public var tagKeyLogicScope: String?

    public var tagKeyScope: String?

    public var tagValueScope: String?

    public var tagsScope: [CreateConfigRuleRequest.TagsScope]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.configRuleName != nil {
            map["ConfigRuleName"] = self.configRuleName!
        }
        if self.configRuleTriggerTypes != nil {
            map["ConfigRuleTriggerTypes"] = self.configRuleTriggerTypes!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.excludeRegionIdsScope != nil {
            map["ExcludeRegionIdsScope"] = self.excludeRegionIdsScope!
        }
        if self.excludeResourceGroupIdsScope != nil {
            map["ExcludeResourceGroupIdsScope"] = self.excludeResourceGroupIdsScope!
        }
        if self.excludeResourceIdsScope != nil {
            map["ExcludeResourceIdsScope"] = self.excludeResourceIdsScope!
        }
        if self.excludeTagsScope != nil {
            var tmp : [Any] = []
            for k in self.excludeTagsScope! {
                tmp.append(k.toMap())
            }
            map["ExcludeTagsScope"] = tmp
        }
        if self.extendContent != nil {
            map["ExtendContent"] = self.extendContent!
        }
        if self.inputParameters != nil {
            map["InputParameters"] = self.inputParameters!
        }
        if self.maximumExecutionFrequency != nil {
            map["MaximumExecutionFrequency"] = self.maximumExecutionFrequency!
        }
        if self.regionIdsScope != nil {
            map["RegionIdsScope"] = self.regionIdsScope!
        }
        if self.resourceGroupIdsScope != nil {
            map["ResourceGroupIdsScope"] = self.resourceGroupIdsScope!
        }
        if self.resourceIdsScope != nil {
            map["ResourceIdsScope"] = self.resourceIdsScope!
        }
        if self.resourceNameScope != nil {
            map["ResourceNameScope"] = self.resourceNameScope!
        }
        if self.resourceTypesScope != nil {
            map["ResourceTypesScope"] = self.resourceTypesScope!
        }
        if self.riskLevel != nil {
            map["RiskLevel"] = self.riskLevel!
        }
        if self.sourceIdentifier != nil {
            map["SourceIdentifier"] = self.sourceIdentifier!
        }
        if self.sourceOwner != nil {
            map["SourceOwner"] = self.sourceOwner!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.tagKeyLogicScope != nil {
            map["TagKeyLogicScope"] = self.tagKeyLogicScope!
        }
        if self.tagKeyScope != nil {
            map["TagKeyScope"] = self.tagKeyScope!
        }
        if self.tagValueScope != nil {
            map["TagValueScope"] = self.tagValueScope!
        }
        if self.tagsScope != nil {
            var tmp : [Any] = []
            for k in self.tagsScope! {
                tmp.append(k.toMap())
            }
            map["TagsScope"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["ConfigRuleName"] as? String {
            self.configRuleName = value
        }
        if let value = dict["ConfigRuleTriggerTypes"] as? String {
            self.configRuleTriggerTypes = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["ExcludeRegionIdsScope"] as? String {
            self.excludeRegionIdsScope = value
        }
        if let value = dict["ExcludeResourceGroupIdsScope"] as? String {
            self.excludeResourceGroupIdsScope = value
        }
        if let value = dict["ExcludeResourceIdsScope"] as? String {
            self.excludeResourceIdsScope = value
        }
        if let value = dict["ExcludeTagsScope"] as? [Any?] {
            var tmp : [CreateConfigRuleRequest.ExcludeTagsScope] = []
            for v in value {
                if v != nil {
                    var model = CreateConfigRuleRequest.ExcludeTagsScope()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.excludeTagsScope = tmp
        }
        if let value = dict["ExtendContent"] as? String {
            self.extendContent = value
        }
        if let value = dict["InputParameters"] as? [String: Any] {
            self.inputParameters = value
        }
        if let value = dict["MaximumExecutionFrequency"] as? String {
            self.maximumExecutionFrequency = value
        }
        if let value = dict["RegionIdsScope"] as? String {
            self.regionIdsScope = value
        }
        if let value = dict["ResourceGroupIdsScope"] as? String {
            self.resourceGroupIdsScope = value
        }
        if let value = dict["ResourceIdsScope"] as? String {
            self.resourceIdsScope = value
        }
        if let value = dict["ResourceNameScope"] as? String {
            self.resourceNameScope = value
        }
        if let value = dict["ResourceTypesScope"] as? [String] {
            self.resourceTypesScope = value
        }
        if let value = dict["RiskLevel"] as? Int32 {
            self.riskLevel = value
        }
        if let value = dict["SourceIdentifier"] as? String {
            self.sourceIdentifier = value
        }
        if let value = dict["SourceOwner"] as? String {
            self.sourceOwner = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [CreateConfigRuleRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = CreateConfigRuleRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
        if let value = dict["TagKeyLogicScope"] as? String {
            self.tagKeyLogicScope = value
        }
        if let value = dict["TagKeyScope"] as? String {
            self.tagKeyScope = value
        }
        if let value = dict["TagValueScope"] as? String {
            self.tagValueScope = value
        }
        if let value = dict["TagsScope"] as? [Any?] {
            var tmp : [CreateConfigRuleRequest.TagsScope] = []
            for v in value {
                if v != nil {
                    var model = CreateConfigRuleRequest.TagsScope()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tagsScope = tmp
        }
    }
}

public class CreateConfigRuleShrinkRequest : Tea.TeaModel {
    public class ExcludeTagsScope : Tea.TeaModel {
        public var tagKey: String?

        public var tagValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tagKey != nil {
                map["TagKey"] = self.tagKey!
            }
            if self.tagValue != nil {
                map["TagValue"] = self.tagValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["TagKey"] as? String {
                self.tagKey = value
            }
            if let value = dict["TagValue"] as? String {
                self.tagValue = value
            }
        }
    }
    public class TagsScope : Tea.TeaModel {
        public var tagKey: String?

        public var tagValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tagKey != nil {
                map["TagKey"] = self.tagKey!
            }
            if self.tagValue != nil {
                map["TagValue"] = self.tagValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["TagKey"] as? String {
                self.tagKey = value
            }
            if let value = dict["TagValue"] as? String {
                self.tagValue = value
            }
        }
    }
    public var clientToken: String?

    public var configRuleName: String?

    public var configRuleTriggerTypes: String?

    public var description_: String?

    public var excludeRegionIdsScope: String?

    public var excludeResourceGroupIdsScope: String?

    public var excludeResourceIdsScope: String?

    public var excludeTagsScope: [CreateConfigRuleShrinkRequest.ExcludeTagsScope]?

    public var extendContent: String?

    public var inputParametersShrink: String?

    public var maximumExecutionFrequency: String?

    public var regionIdsScope: String?

    public var resourceGroupIdsScope: String?

    public var resourceIdsScope: String?

    public var resourceNameScope: String?

    public var resourceTypesScopeShrink: String?

    public var riskLevel: Int32?

    public var sourceIdentifier: String?

    public var sourceOwner: String?

    public var tagShrink: String?

    public var tagKeyLogicScope: String?

    public var tagKeyScope: String?

    public var tagValueScope: String?

    public var tagsScope: [CreateConfigRuleShrinkRequest.TagsScope]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.configRuleName != nil {
            map["ConfigRuleName"] = self.configRuleName!
        }
        if self.configRuleTriggerTypes != nil {
            map["ConfigRuleTriggerTypes"] = self.configRuleTriggerTypes!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.excludeRegionIdsScope != nil {
            map["ExcludeRegionIdsScope"] = self.excludeRegionIdsScope!
        }
        if self.excludeResourceGroupIdsScope != nil {
            map["ExcludeResourceGroupIdsScope"] = self.excludeResourceGroupIdsScope!
        }
        if self.excludeResourceIdsScope != nil {
            map["ExcludeResourceIdsScope"] = self.excludeResourceIdsScope!
        }
        if self.excludeTagsScope != nil {
            var tmp : [Any] = []
            for k in self.excludeTagsScope! {
                tmp.append(k.toMap())
            }
            map["ExcludeTagsScope"] = tmp
        }
        if self.extendContent != nil {
            map["ExtendContent"] = self.extendContent!
        }
        if self.inputParametersShrink != nil {
            map["InputParameters"] = self.inputParametersShrink!
        }
        if self.maximumExecutionFrequency != nil {
            map["MaximumExecutionFrequency"] = self.maximumExecutionFrequency!
        }
        if self.regionIdsScope != nil {
            map["RegionIdsScope"] = self.regionIdsScope!
        }
        if self.resourceGroupIdsScope != nil {
            map["ResourceGroupIdsScope"] = self.resourceGroupIdsScope!
        }
        if self.resourceIdsScope != nil {
            map["ResourceIdsScope"] = self.resourceIdsScope!
        }
        if self.resourceNameScope != nil {
            map["ResourceNameScope"] = self.resourceNameScope!
        }
        if self.resourceTypesScopeShrink != nil {
            map["ResourceTypesScope"] = self.resourceTypesScopeShrink!
        }
        if self.riskLevel != nil {
            map["RiskLevel"] = self.riskLevel!
        }
        if self.sourceIdentifier != nil {
            map["SourceIdentifier"] = self.sourceIdentifier!
        }
        if self.sourceOwner != nil {
            map["SourceOwner"] = self.sourceOwner!
        }
        if self.tagShrink != nil {
            map["Tag"] = self.tagShrink!
        }
        if self.tagKeyLogicScope != nil {
            map["TagKeyLogicScope"] = self.tagKeyLogicScope!
        }
        if self.tagKeyScope != nil {
            map["TagKeyScope"] = self.tagKeyScope!
        }
        if self.tagValueScope != nil {
            map["TagValueScope"] = self.tagValueScope!
        }
        if self.tagsScope != nil {
            var tmp : [Any] = []
            for k in self.tagsScope! {
                tmp.append(k.toMap())
            }
            map["TagsScope"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["ConfigRuleName"] as? String {
            self.configRuleName = value
        }
        if let value = dict["ConfigRuleTriggerTypes"] as? String {
            self.configRuleTriggerTypes = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["ExcludeRegionIdsScope"] as? String {
            self.excludeRegionIdsScope = value
        }
        if let value = dict["ExcludeResourceGroupIdsScope"] as? String {
            self.excludeResourceGroupIdsScope = value
        }
        if let value = dict["ExcludeResourceIdsScope"] as? String {
            self.excludeResourceIdsScope = value
        }
        if let value = dict["ExcludeTagsScope"] as? [Any?] {
            var tmp : [CreateConfigRuleShrinkRequest.ExcludeTagsScope] = []
            for v in value {
                if v != nil {
                    var model = CreateConfigRuleShrinkRequest.ExcludeTagsScope()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.excludeTagsScope = tmp
        }
        if let value = dict["ExtendContent"] as? String {
            self.extendContent = value
        }
        if let value = dict["InputParameters"] as? String {
            self.inputParametersShrink = value
        }
        if let value = dict["MaximumExecutionFrequency"] as? String {
            self.maximumExecutionFrequency = value
        }
        if let value = dict["RegionIdsScope"] as? String {
            self.regionIdsScope = value
        }
        if let value = dict["ResourceGroupIdsScope"] as? String {
            self.resourceGroupIdsScope = value
        }
        if let value = dict["ResourceIdsScope"] as? String {
            self.resourceIdsScope = value
        }
        if let value = dict["ResourceNameScope"] as? String {
            self.resourceNameScope = value
        }
        if let value = dict["ResourceTypesScope"] as? String {
            self.resourceTypesScopeShrink = value
        }
        if let value = dict["RiskLevel"] as? Int32 {
            self.riskLevel = value
        }
        if let value = dict["SourceIdentifier"] as? String {
            self.sourceIdentifier = value
        }
        if let value = dict["SourceOwner"] as? String {
            self.sourceOwner = value
        }
        if let value = dict["Tag"] as? String {
            self.tagShrink = value
        }
        if let value = dict["TagKeyLogicScope"] as? String {
            self.tagKeyLogicScope = value
        }
        if let value = dict["TagKeyScope"] as? String {
            self.tagKeyScope = value
        }
        if let value = dict["TagValueScope"] as? String {
            self.tagValueScope = value
        }
        if let value = dict["TagsScope"] as? [Any?] {
            var tmp : [CreateConfigRuleShrinkRequest.TagsScope] = []
            for v in value {
                if v != nil {
                    var model = CreateConfigRuleShrinkRequest.TagsScope()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tagsScope = tmp
        }
    }
}

public class CreateConfigRuleResponseBody : Tea.TeaModel {
    public var configRuleId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configRuleId != nil {
            map["ConfigRuleId"] = self.configRuleId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ConfigRuleId"] as? String {
            self.configRuleId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateConfigRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateConfigRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateConfigRuleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateDeliveryChannelRequest : Tea.TeaModel {
    public var clientToken: String?

    public var configurationItemChangeNotification: Bool?

    public var configurationSnapshot: Bool?

    public var deliveryChannelAssumeRoleArn: String?

    public var deliveryChannelCondition: String?

    public var deliveryChannelName: String?

    public var deliveryChannelTargetArn: String?

    public var deliveryChannelType: String?

    public var description_: String?

    public var nonCompliantNotification: Bool?

    public var oversizedDataOSSTargetArn: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.configurationItemChangeNotification != nil {
            map["ConfigurationItemChangeNotification"] = self.configurationItemChangeNotification!
        }
        if self.configurationSnapshot != nil {
            map["ConfigurationSnapshot"] = self.configurationSnapshot!
        }
        if self.deliveryChannelAssumeRoleArn != nil {
            map["DeliveryChannelAssumeRoleArn"] = self.deliveryChannelAssumeRoleArn!
        }
        if self.deliveryChannelCondition != nil {
            map["DeliveryChannelCondition"] = self.deliveryChannelCondition!
        }
        if self.deliveryChannelName != nil {
            map["DeliveryChannelName"] = self.deliveryChannelName!
        }
        if self.deliveryChannelTargetArn != nil {
            map["DeliveryChannelTargetArn"] = self.deliveryChannelTargetArn!
        }
        if self.deliveryChannelType != nil {
            map["DeliveryChannelType"] = self.deliveryChannelType!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.nonCompliantNotification != nil {
            map["NonCompliantNotification"] = self.nonCompliantNotification!
        }
        if self.oversizedDataOSSTargetArn != nil {
            map["OversizedDataOSSTargetArn"] = self.oversizedDataOSSTargetArn!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["ConfigurationItemChangeNotification"] as? Bool {
            self.configurationItemChangeNotification = value
        }
        if let value = dict["ConfigurationSnapshot"] as? Bool {
            self.configurationSnapshot = value
        }
        if let value = dict["DeliveryChannelAssumeRoleArn"] as? String {
            self.deliveryChannelAssumeRoleArn = value
        }
        if let value = dict["DeliveryChannelCondition"] as? String {
            self.deliveryChannelCondition = value
        }
        if let value = dict["DeliveryChannelName"] as? String {
            self.deliveryChannelName = value
        }
        if let value = dict["DeliveryChannelTargetArn"] as? String {
            self.deliveryChannelTargetArn = value
        }
        if let value = dict["DeliveryChannelType"] as? String {
            self.deliveryChannelType = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["NonCompliantNotification"] as? Bool {
            self.nonCompliantNotification = value
        }
        if let value = dict["OversizedDataOSSTargetArn"] as? String {
            self.oversizedDataOSSTargetArn = value
        }
    }
}

public class CreateDeliveryChannelResponseBody : Tea.TeaModel {
    public var deliveryChannelId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deliveryChannelId != nil {
            map["DeliveryChannelId"] = self.deliveryChannelId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DeliveryChannelId"] as? String {
            self.deliveryChannelId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateDeliveryChannelResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDeliveryChannelResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateDeliveryChannelResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateRemediationRequest : Tea.TeaModel {
    public var clientToken: String?

    public var configRuleId: String?

    public var invokeType: String?

    public var params: String?

    public var remediationTemplateId: String?

    public var remediationType: String?

    public var sourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.configRuleId != nil {
            map["ConfigRuleId"] = self.configRuleId!
        }
        if self.invokeType != nil {
            map["InvokeType"] = self.invokeType!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.remediationTemplateId != nil {
            map["RemediationTemplateId"] = self.remediationTemplateId!
        }
        if self.remediationType != nil {
            map["RemediationType"] = self.remediationType!
        }
        if self.sourceType != nil {
            map["SourceType"] = self.sourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["ConfigRuleId"] as? String {
            self.configRuleId = value
        }
        if let value = dict["InvokeType"] as? String {
            self.invokeType = value
        }
        if let value = dict["Params"] as? String {
            self.params = value
        }
        if let value = dict["RemediationTemplateId"] as? String {
            self.remediationTemplateId = value
        }
        if let value = dict["RemediationType"] as? String {
            self.remediationType = value
        }
        if let value = dict["SourceType"] as? String {
            self.sourceType = value
        }
    }
}

public class CreateRemediationResponseBody : Tea.TeaModel {
    public var remediationId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.remediationId != nil {
            map["RemediationId"] = self.remediationId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RemediationId"] as? String {
            self.remediationId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateRemediationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateRemediationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateRemediationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeactiveAggregateConfigRulesRequest : Tea.TeaModel {
    public var aggregatorId: String?

    public var compliancePackId: String?

    public var configRuleIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aggregatorId != nil {
            map["AggregatorId"] = self.aggregatorId!
        }
        if self.compliancePackId != nil {
            map["CompliancePackId"] = self.compliancePackId!
        }
        if self.configRuleIds != nil {
            map["ConfigRuleIds"] = self.configRuleIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AggregatorId"] as? String {
            self.aggregatorId = value
        }
        if let value = dict["CompliancePackId"] as? String {
            self.compliancePackId = value
        }
        if let value = dict["ConfigRuleIds"] as? String {
            self.configRuleIds = value
        }
    }
}

public class DeactiveAggregateConfigRulesResponseBody : Tea.TeaModel {
    public class OperateRuleResult : Tea.TeaModel {
        public class OperateRuleItemList : Tea.TeaModel {
            public var configRuleId: String?

            public var errorCode: String?

            public var success: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.configRuleId != nil {
                    map["ConfigRuleId"] = self.configRuleId!
                }
                if self.errorCode != nil {
                    map["ErrorCode"] = self.errorCode!
                }
                if self.success != nil {
                    map["Success"] = self.success!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ConfigRuleId"] as? String {
                    self.configRuleId = value
                }
                if let value = dict["ErrorCode"] as? String {
                    self.errorCode = value
                }
                if let value = dict["Success"] as? Bool {
                    self.success = value
                }
            }
        }
        public var operateRuleItemList: [DeactiveAggregateConfigRulesResponseBody.OperateRuleResult.OperateRuleItemList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.operateRuleItemList != nil {
                var tmp : [Any] = []
                for k in self.operateRuleItemList! {
                    tmp.append(k.toMap())
                }
                map["OperateRuleItemList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["OperateRuleItemList"] as? [Any?] {
                var tmp : [DeactiveAggregateConfigRulesResponseBody.OperateRuleResult.OperateRuleItemList] = []
                for v in value {
                    if v != nil {
                        var model = DeactiveAggregateConfigRulesResponseBody.OperateRuleResult.OperateRuleItemList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.operateRuleItemList = tmp
            }
        }
    }
    public var operateRuleResult: DeactiveAggregateConfigRulesResponseBody.OperateRuleResult?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.operateRuleResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.operateRuleResult != nil {
            map["OperateRuleResult"] = self.operateRuleResult?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OperateRuleResult"] as? [String: Any?] {
            var model = DeactiveAggregateConfigRulesResponseBody.OperateRuleResult()
            model.fromMap(value)
            self.operateRuleResult = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeactiveAggregateConfigRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeactiveAggregateConfigRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeactiveAggregateConfigRulesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeactiveConfigRulesRequest : Tea.TeaModel {
    public var compliancePackId: String?

    public var configRuleIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.compliancePackId != nil {
            map["CompliancePackId"] = self.compliancePackId!
        }
        if self.configRuleIds != nil {
            map["ConfigRuleIds"] = self.configRuleIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CompliancePackId"] as? String {
            self.compliancePackId = value
        }
        if let value = dict["ConfigRuleIds"] as? String {
            self.configRuleIds = value
        }
    }
}

public class DeactiveConfigRulesResponseBody : Tea.TeaModel {
    public class OperateRuleResult : Tea.TeaModel {
        public class OperateRuleItemList : Tea.TeaModel {
            public var configRuleId: String?

            public var errorCode: String?

            public var success: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.configRuleId != nil {
                    map["ConfigRuleId"] = self.configRuleId!
                }
                if self.errorCode != nil {
                    map["ErrorCode"] = self.errorCode!
                }
                if self.success != nil {
                    map["Success"] = self.success!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ConfigRuleId"] as? String {
                    self.configRuleId = value
                }
                if let value = dict["ErrorCode"] as? String {
                    self.errorCode = value
                }
                if let value = dict["Success"] as? Bool {
                    self.success = value
                }
            }
        }
        public var operateRuleItemList: [DeactiveConfigRulesResponseBody.OperateRuleResult.OperateRuleItemList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.operateRuleItemList != nil {
                var tmp : [Any] = []
                for k in self.operateRuleItemList! {
                    tmp.append(k.toMap())
                }
                map["OperateRuleItemList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["OperateRuleItemList"] as? [Any?] {
                var tmp : [DeactiveConfigRulesResponseBody.OperateRuleResult.OperateRuleItemList] = []
                for v in value {
                    if v != nil {
                        var model = DeactiveConfigRulesResponseBody.OperateRuleResult.OperateRuleItemList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.operateRuleItemList = tmp
            }
        }
    }
    public var operateRuleResult: DeactiveConfigRulesResponseBody.OperateRuleResult?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.operateRuleResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.operateRuleResult != nil {
            map["OperateRuleResult"] = self.operateRuleResult?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OperateRuleResult"] as? [String: Any?] {
            var model = DeactiveConfigRulesResponseBody.OperateRuleResult()
            model.fromMap(value)
            self.operateRuleResult = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeactiveConfigRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeactiveConfigRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeactiveConfigRulesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteAggregateCompliancePacksRequest : Tea.TeaModel {
    public var aggregatorId: String?

    public var clientToken: String?

    public var compliancePackIds: String?

    public var deleteRule: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aggregatorId != nil {
            map["AggregatorId"] = self.aggregatorId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.compliancePackIds != nil {
            map["CompliancePackIds"] = self.compliancePackIds!
        }
        if self.deleteRule != nil {
            map["DeleteRule"] = self.deleteRule!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AggregatorId"] as? String {
            self.aggregatorId = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["CompliancePackIds"] as? String {
            self.compliancePackIds = value
        }
        if let value = dict["DeleteRule"] as? Bool {
            self.deleteRule = value
        }
    }
}

public class DeleteAggregateCompliancePacksResponseBody : Tea.TeaModel {
    public class OperateCompliancePacksResult : Tea.TeaModel {
        public class OperateCompliancePacks : Tea.TeaModel {
            public var compliancePackId: String?

            public var errorCode: String?

            public var success: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.compliancePackId != nil {
                    map["CompliancePackId"] = self.compliancePackId!
                }
                if self.errorCode != nil {
                    map["ErrorCode"] = self.errorCode!
                }
                if self.success != nil {
                    map["Success"] = self.success!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CompliancePackId"] as? String {
                    self.compliancePackId = value
                }
                if let value = dict["ErrorCode"] as? String {
                    self.errorCode = value
                }
                if let value = dict["Success"] as? Bool {
                    self.success = value
                }
            }
        }
        public var operateCompliancePacks: [DeleteAggregateCompliancePacksResponseBody.OperateCompliancePacksResult.OperateCompliancePacks]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.operateCompliancePacks != nil {
                var tmp : [Any] = []
                for k in self.operateCompliancePacks! {
                    tmp.append(k.toMap())
                }
                map["OperateCompliancePacks"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["OperateCompliancePacks"] as? [Any?] {
                var tmp : [DeleteAggregateCompliancePacksResponseBody.OperateCompliancePacksResult.OperateCompliancePacks] = []
                for v in value {
                    if v != nil {
                        var model = DeleteAggregateCompliancePacksResponseBody.OperateCompliancePacksResult.OperateCompliancePacks()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.operateCompliancePacks = tmp
            }
        }
    }
    public var operateCompliancePacksResult: DeleteAggregateCompliancePacksResponseBody.OperateCompliancePacksResult?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.operateCompliancePacksResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.operateCompliancePacksResult != nil {
            map["OperateCompliancePacksResult"] = self.operateCompliancePacksResult?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OperateCompliancePacksResult"] as? [String: Any?] {
            var model = DeleteAggregateCompliancePacksResponseBody.OperateCompliancePacksResult()
            model.fromMap(value)
            self.operateCompliancePacksResult = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteAggregateCompliancePacksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteAggregateCompliancePacksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteAggregateCompliancePacksResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteAggregateConfigDeliveryChannelRequest : Tea.TeaModel {
    public var aggregatorId: String?

    public var deliveryChannelId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aggregatorId != nil {
            map["AggregatorId"] = self.aggregatorId!
        }
        if self.deliveryChannelId != nil {
            map["DeliveryChannelId"] = self.deliveryChannelId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AggregatorId"] as? String {
            self.aggregatorId = value
        }
        if let value = dict["DeliveryChannelId"] as? String {
            self.deliveryChannelId = value
        }
    }
}

public class DeleteAggregateConfigDeliveryChannelResponseBody : Tea.TeaModel {
    public var deliveryChannelId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deliveryChannelId != nil {
            map["DeliveryChannelId"] = self.deliveryChannelId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DeliveryChannelId"] as? String {
            self.deliveryChannelId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteAggregateConfigDeliveryChannelResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteAggregateConfigDeliveryChannelResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteAggregateConfigDeliveryChannelResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteAggregateConfigRulesRequest : Tea.TeaModel {
    public var aggregatorId: String?

    public var configRuleIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aggregatorId != nil {
            map["AggregatorId"] = self.aggregatorId!
        }
        if self.configRuleIds != nil {
            map["ConfigRuleIds"] = self.configRuleIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AggregatorId"] as? String {
            self.aggregatorId = value
        }
        if let value = dict["ConfigRuleIds"] as? String {
            self.configRuleIds = value
        }
    }
}

public class DeleteAggregateConfigRulesResponseBody : Tea.TeaModel {
    public class OperateRuleResult : Tea.TeaModel {
        public class OperateRuleItemList : Tea.TeaModel {
            public var configRuleId: String?

            public var errorCode: String?

            public var success: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.configRuleId != nil {
                    map["ConfigRuleId"] = self.configRuleId!
                }
                if self.errorCode != nil {
                    map["ErrorCode"] = self.errorCode!
                }
                if self.success != nil {
                    map["Success"] = self.success!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ConfigRuleId"] as? String {
                    self.configRuleId = value
                }
                if let value = dict["ErrorCode"] as? String {
                    self.errorCode = value
                }
                if let value = dict["Success"] as? Bool {
                    self.success = value
                }
            }
        }
        public var operateRuleItemList: [DeleteAggregateConfigRulesResponseBody.OperateRuleResult.OperateRuleItemList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.operateRuleItemList != nil {
                var tmp : [Any] = []
                for k in self.operateRuleItemList! {
                    tmp.append(k.toMap())
                }
                map["OperateRuleItemList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["OperateRuleItemList"] as? [Any?] {
                var tmp : [DeleteAggregateConfigRulesResponseBody.OperateRuleResult.OperateRuleItemList] = []
                for v in value {
                    if v != nil {
                        var model = DeleteAggregateConfigRulesResponseBody.OperateRuleResult.OperateRuleItemList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.operateRuleItemList = tmp
            }
        }
    }
    public var operateRuleResult: DeleteAggregateConfigRulesResponseBody.OperateRuleResult?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.operateRuleResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.operateRuleResult != nil {
            map["OperateRuleResult"] = self.operateRuleResult?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OperateRuleResult"] as? [String: Any?] {
            var model = DeleteAggregateConfigRulesResponseBody.OperateRuleResult()
            model.fromMap(value)
            self.operateRuleResult = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteAggregateConfigRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteAggregateConfigRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteAggregateConfigRulesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteAggregateRemediationsRequest : Tea.TeaModel {
    public var aggregatorId: String?

    public var remediationIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aggregatorId != nil {
            map["AggregatorId"] = self.aggregatorId!
        }
        if self.remediationIds != nil {
            map["RemediationIds"] = self.remediationIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AggregatorId"] as? String {
            self.aggregatorId = value
        }
        if let value = dict["RemediationIds"] as? String {
            self.remediationIds = value
        }
    }
}

public class DeleteAggregateRemediationsResponseBody : Tea.TeaModel {
    public class RemediationDeleteResults : Tea.TeaModel {
        public var errorMessage: String?

        public var remediationId: String?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.errorMessage != nil {
                map["ErrorMessage"] = self.errorMessage!
            }
            if self.remediationId != nil {
                map["RemediationId"] = self.remediationId!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ErrorMessage"] as? String {
                self.errorMessage = value
            }
            if let value = dict["RemediationId"] as? String {
                self.remediationId = value
            }
            if let value = dict["Success"] as? Bool {
                self.success = value
            }
        }
    }
    public var remediationDeleteResults: [DeleteAggregateRemediationsResponseBody.RemediationDeleteResults]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.remediationDeleteResults != nil {
            var tmp : [Any] = []
            for k in self.remediationDeleteResults! {
                tmp.append(k.toMap())
            }
            map["RemediationDeleteResults"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RemediationDeleteResults"] as? [Any?] {
            var tmp : [DeleteAggregateRemediationsResponseBody.RemediationDeleteResults] = []
            for v in value {
                if v != nil {
                    var model = DeleteAggregateRemediationsResponseBody.RemediationDeleteResults()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.remediationDeleteResults = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteAggregateRemediationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteAggregateRemediationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteAggregateRemediationsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteAggregatorsRequest : Tea.TeaModel {
    public var aggregatorIds: String?

    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aggregatorIds != nil {
            map["AggregatorIds"] = self.aggregatorIds!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AggregatorIds"] as? String {
            self.aggregatorIds = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
    }
}

public class DeleteAggregatorsResponseBody : Tea.TeaModel {
    public class OperateAggregatorsResult : Tea.TeaModel {
        public class OperateAggregators : Tea.TeaModel {
            public var aggregatorId: String?

            public var errorCode: String?

            public var success: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.aggregatorId != nil {
                    map["AggregatorId"] = self.aggregatorId!
                }
                if self.errorCode != nil {
                    map["ErrorCode"] = self.errorCode!
                }
                if self.success != nil {
                    map["Success"] = self.success!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AggregatorId"] as? String {
                    self.aggregatorId = value
                }
                if let value = dict["ErrorCode"] as? String {
                    self.errorCode = value
                }
                if let value = dict["Success"] as? Bool {
                    self.success = value
                }
            }
        }
        public var operateAggregators: [DeleteAggregatorsResponseBody.OperateAggregatorsResult.OperateAggregators]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.operateAggregators != nil {
                var tmp : [Any] = []
                for k in self.operateAggregators! {
                    tmp.append(k.toMap())
                }
                map["OperateAggregators"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["OperateAggregators"] as? [Any?] {
                var tmp : [DeleteAggregatorsResponseBody.OperateAggregatorsResult.OperateAggregators] = []
                for v in value {
                    if v != nil {
                        var model = DeleteAggregatorsResponseBody.OperateAggregatorsResult.OperateAggregators()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.operateAggregators = tmp
            }
        }
    }
    public var operateAggregatorsResult: DeleteAggregatorsResponseBody.OperateAggregatorsResult?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.operateAggregatorsResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.operateAggregatorsResult != nil {
            map["OperateAggregatorsResult"] = self.operateAggregatorsResult?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OperateAggregatorsResult"] as? [String: Any?] {
            var model = DeleteAggregatorsResponseBody.OperateAggregatorsResult()
            model.fromMap(value)
            self.operateAggregatorsResult = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteAggregatorsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteAggregatorsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteAggregatorsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteCompliancePacksRequest : Tea.TeaModel {
    public var clientToken: String?

    public var compliancePackIds: String?

    public var deleteRule: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.compliancePackIds != nil {
            map["CompliancePackIds"] = self.compliancePackIds!
        }
        if self.deleteRule != nil {
            map["DeleteRule"] = self.deleteRule!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["CompliancePackIds"] as? String {
            self.compliancePackIds = value
        }
        if let value = dict["DeleteRule"] as? Bool {
            self.deleteRule = value
        }
    }
}

public class DeleteCompliancePacksResponseBody : Tea.TeaModel {
    public class OperateCompliancePacksResult : Tea.TeaModel {
        public class OperateCompliancePacks : Tea.TeaModel {
            public var compliancePackId: String?

            public var errorCode: String?

            public var success: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.compliancePackId != nil {
                    map["CompliancePackId"] = self.compliancePackId!
                }
                if self.errorCode != nil {
                    map["ErrorCode"] = self.errorCode!
                }
                if self.success != nil {
                    map["Success"] = self.success!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CompliancePackId"] as? String {
                    self.compliancePackId = value
                }
                if let value = dict["ErrorCode"] as? String {
                    self.errorCode = value
                }
                if let value = dict["Success"] as? Bool {
                    self.success = value
                }
            }
        }
        public var operateCompliancePacks: [DeleteCompliancePacksResponseBody.OperateCompliancePacksResult.OperateCompliancePacks]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.operateCompliancePacks != nil {
                var tmp : [Any] = []
                for k in self.operateCompliancePacks! {
                    tmp.append(k.toMap())
                }
                map["OperateCompliancePacks"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["OperateCompliancePacks"] as? [Any?] {
                var tmp : [DeleteCompliancePacksResponseBody.OperateCompliancePacksResult.OperateCompliancePacks] = []
                for v in value {
                    if v != nil {
                        var model = DeleteCompliancePacksResponseBody.OperateCompliancePacksResult.OperateCompliancePacks()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.operateCompliancePacks = tmp
            }
        }
    }
    public var operateCompliancePacksResult: DeleteCompliancePacksResponseBody.OperateCompliancePacksResult?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.operateCompliancePacksResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.operateCompliancePacksResult != nil {
            map["OperateCompliancePacksResult"] = self.operateCompliancePacksResult?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OperateCompliancePacksResult"] as? [String: Any?] {
            var model = DeleteCompliancePacksResponseBody.OperateCompliancePacksResult()
            model.fromMap(value)
            self.operateCompliancePacksResult = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteCompliancePacksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteCompliancePacksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteCompliancePacksResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteConfigDeliveryChannelRequest : Tea.TeaModel {
    public var deliveryChannelId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deliveryChannelId != nil {
            map["DeliveryChannelId"] = self.deliveryChannelId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DeliveryChannelId"] as? String {
            self.deliveryChannelId = value
        }
    }
}

public class DeleteConfigDeliveryChannelResponseBody : Tea.TeaModel {
    public var deliveryChannelId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deliveryChannelId != nil {
            map["DeliveryChannelId"] = self.deliveryChannelId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DeliveryChannelId"] as? String {
            self.deliveryChannelId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteConfigDeliveryChannelResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteConfigDeliveryChannelResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteConfigDeliveryChannelResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteConfigRulesRequest : Tea.TeaModel {
    public var configRuleIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configRuleIds != nil {
            map["ConfigRuleIds"] = self.configRuleIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ConfigRuleIds"] as? String {
            self.configRuleIds = value
        }
    }
}

public class DeleteConfigRulesResponseBody : Tea.TeaModel {
    public class OperateRuleResult : Tea.TeaModel {
        public class OperateRuleItemList : Tea.TeaModel {
            public var configRuleId: String?

            public var errorCode: String?

            public var success: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.configRuleId != nil {
                    map["ConfigRuleId"] = self.configRuleId!
                }
                if self.errorCode != nil {
                    map["ErrorCode"] = self.errorCode!
                }
                if self.success != nil {
                    map["Success"] = self.success!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ConfigRuleId"] as? String {
                    self.configRuleId = value
                }
                if let value = dict["ErrorCode"] as? String {
                    self.errorCode = value
                }
                if let value = dict["Success"] as? Bool {
                    self.success = value
                }
            }
        }
        public var operateRuleItemList: [DeleteConfigRulesResponseBody.OperateRuleResult.OperateRuleItemList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.operateRuleItemList != nil {
                var tmp : [Any] = []
                for k in self.operateRuleItemList! {
                    tmp.append(k.toMap())
                }
                map["OperateRuleItemList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["OperateRuleItemList"] as? [Any?] {
                var tmp : [DeleteConfigRulesResponseBody.OperateRuleResult.OperateRuleItemList] = []
                for v in value {
                    if v != nil {
                        var model = DeleteConfigRulesResponseBody.OperateRuleResult.OperateRuleItemList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.operateRuleItemList = tmp
            }
        }
    }
    public var operateRuleResult: DeleteConfigRulesResponseBody.OperateRuleResult?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.operateRuleResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.operateRuleResult != nil {
            map["OperateRuleResult"] = self.operateRuleResult?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OperateRuleResult"] as? [String: Any?] {
            var model = DeleteConfigRulesResponseBody.OperateRuleResult()
            model.fromMap(value)
            self.operateRuleResult = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteConfigRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteConfigRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteConfigRulesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteRemediationsRequest : Tea.TeaModel {
    public var remediationIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.remediationIds != nil {
            map["RemediationIds"] = self.remediationIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RemediationIds"] as? String {
            self.remediationIds = value
        }
    }
}

public class DeleteRemediationsResponseBody : Tea.TeaModel {
    public class RemediationDeleteResults : Tea.TeaModel {
        public var errorMessage: String?

        public var remediationId: String?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.errorMessage != nil {
                map["ErrorMessage"] = self.errorMessage!
            }
            if self.remediationId != nil {
                map["RemediationId"] = self.remediationId!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ErrorMessage"] as? String {
                self.errorMessage = value
            }
            if let value = dict["RemediationId"] as? String {
                self.remediationId = value
            }
            if let value = dict["Success"] as? Bool {
                self.success = value
            }
        }
    }
    public var remediationDeleteResults: [DeleteRemediationsResponseBody.RemediationDeleteResults]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.remediationDeleteResults != nil {
            var tmp : [Any] = []
            for k in self.remediationDeleteResults! {
                tmp.append(k.toMap())
            }
            map["RemediationDeleteResults"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RemediationDeleteResults"] as? [Any?] {
            var tmp : [DeleteRemediationsResponseBody.RemediationDeleteResults] = []
            for v in value {
                if v != nil {
                    var model = DeleteRemediationsResponseBody.RemediationDeleteResults()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.remediationDeleteResults = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteRemediationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteRemediationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteRemediationsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeRemediationRequest : Tea.TeaModel {
    public var configRuleId: String?

    public var remediationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configRuleId != nil {
            map["ConfigRuleId"] = self.configRuleId!
        }
        if self.remediationId != nil {
            map["RemediationId"] = self.remediationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ConfigRuleId"] as? String {
            self.configRuleId = value
        }
        if let value = dict["RemediationId"] as? String {
            self.remediationId = value
        }
    }
}

public class DescribeRemediationResponseBody : Tea.TeaModel {
    public class Remediation : Tea.TeaModel {
        public var accountId: Int64?

        public var configRuleId: String?

        public var invokeType: String?

        public var lastSuccessfulInvocationId: String?

        public var lastSuccessfulInvocationTime: Int64?

        public var lastSuccessfulInvocationType: String?

        public var remediationId: String?

        public var remediationOriginParams: String?

        public var remediationSourceType: String?

        public var remediationTemplateId: String?

        public var remediationType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["AccountId"] = self.accountId!
            }
            if self.configRuleId != nil {
                map["ConfigRuleId"] = self.configRuleId!
            }
            if self.invokeType != nil {
                map["InvokeType"] = self.invokeType!
            }
            if self.lastSuccessfulInvocationId != nil {
                map["LastSuccessfulInvocationId"] = self.lastSuccessfulInvocationId!
            }
            if self.lastSuccessfulInvocationTime != nil {
                map["LastSuccessfulInvocationTime"] = self.lastSuccessfulInvocationTime!
            }
            if self.lastSuccessfulInvocationType != nil {
                map["LastSuccessfulInvocationType"] = self.lastSuccessfulInvocationType!
            }
            if self.remediationId != nil {
                map["RemediationId"] = self.remediationId!
            }
            if self.remediationOriginParams != nil {
                map["RemediationOriginParams"] = self.remediationOriginParams!
            }
            if self.remediationSourceType != nil {
                map["RemediationSourceType"] = self.remediationSourceType!
            }
            if self.remediationTemplateId != nil {
                map["RemediationTemplateId"] = self.remediationTemplateId!
            }
            if self.remediationType != nil {
                map["RemediationType"] = self.remediationType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AccountId"] as? Int64 {
                self.accountId = value
            }
            if let value = dict["ConfigRuleId"] as? String {
                self.configRuleId = value
            }
            if let value = dict["InvokeType"] as? String {
                self.invokeType = value
            }
            if let value = dict["LastSuccessfulInvocationId"] as? String {
                self.lastSuccessfulInvocationId = value
            }
            if let value = dict["LastSuccessfulInvocationTime"] as? Int64 {
                self.lastSuccessfulInvocationTime = value
            }
            if let value = dict["LastSuccessfulInvocationType"] as? String {
                self.lastSuccessfulInvocationType = value
            }
            if let value = dict["RemediationId"] as? String {
                self.remediationId = value
            }
            if let value = dict["RemediationOriginParams"] as? String {
                self.remediationOriginParams = value
            }
            if let value = dict["RemediationSourceType"] as? String {
                self.remediationSourceType = value
            }
            if let value = dict["RemediationTemplateId"] as? String {
                self.remediationTemplateId = value
            }
            if let value = dict["RemediationType"] as? String {
                self.remediationType = value
            }
        }
    }
    public var remediation: DescribeRemediationResponseBody.Remediation?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.remediation?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.remediation != nil {
            map["Remediation"] = self.remediation?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Remediation"] as? [String: Any?] {
            var model = DescribeRemediationResponseBody.Remediation()
            model.fromMap(value)
            self.remediation = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeRemediationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRemediationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeRemediationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DetachAggregateConfigRuleToCompliancePackRequest : Tea.TeaModel {
    public var aggregatorId: String?

    public var compliancePackId: String?

    public var configRuleIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aggregatorId != nil {
            map["AggregatorId"] = self.aggregatorId!
        }
        if self.compliancePackId != nil {
            map["CompliancePackId"] = self.compliancePackId!
        }
        if self.configRuleIds != nil {
            map["ConfigRuleIds"] = self.configRuleIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AggregatorId"] as? String {
            self.aggregatorId = value
        }
        if let value = dict["CompliancePackId"] as? String {
            self.compliancePackId = value
        }
        if let value = dict["ConfigRuleIds"] as? String {
            self.configRuleIds = value
        }
    }
}

public class DetachAggregateConfigRuleToCompliancePackResponseBody : Tea.TeaModel {
    public class OperateRuleResult : Tea.TeaModel {
        public class OperateRuleItemList : Tea.TeaModel {
            public var configRuleId: String?

            public var errorCode: String?

            public var success: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.configRuleId != nil {
                    map["ConfigRuleId"] = self.configRuleId!
                }
                if self.errorCode != nil {
                    map["ErrorCode"] = self.errorCode!
                }
                if self.success != nil {
                    map["Success"] = self.success!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ConfigRuleId"] as? String {
                    self.configRuleId = value
                }
                if let value = dict["ErrorCode"] as? String {
                    self.errorCode = value
                }
                if let value = dict["Success"] as? Bool {
                    self.success = value
                }
            }
        }
        public var operateRuleItemList: [DetachAggregateConfigRuleToCompliancePackResponseBody.OperateRuleResult.OperateRuleItemList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.operateRuleItemList != nil {
                var tmp : [Any] = []
                for k in self.operateRuleItemList! {
                    tmp.append(k.toMap())
                }
                map["OperateRuleItemList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["OperateRuleItemList"] as? [Any?] {
                var tmp : [DetachAggregateConfigRuleToCompliancePackResponseBody.OperateRuleResult.OperateRuleItemList] = []
                for v in value {
                    if v != nil {
                        var model = DetachAggregateConfigRuleToCompliancePackResponseBody.OperateRuleResult.OperateRuleItemList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.operateRuleItemList = tmp
            }
        }
    }
    public var operateRuleResult: DetachAggregateConfigRuleToCompliancePackResponseBody.OperateRuleResult?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.operateRuleResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.operateRuleResult != nil {
            map["OperateRuleResult"] = self.operateRuleResult?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OperateRuleResult"] as? [String: Any?] {
            var model = DetachAggregateConfigRuleToCompliancePackResponseBody.OperateRuleResult()
            model.fromMap(value)
            self.operateRuleResult = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DetachAggregateConfigRuleToCompliancePackResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DetachAggregateConfigRuleToCompliancePackResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DetachAggregateConfigRuleToCompliancePackResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DetachConfigRuleToCompliancePackRequest : Tea.TeaModel {
    public var compliancePackId: String?

    public var configRuleIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.compliancePackId != nil {
            map["CompliancePackId"] = self.compliancePackId!
        }
        if self.configRuleIds != nil {
            map["ConfigRuleIds"] = self.configRuleIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CompliancePackId"] as? String {
            self.compliancePackId = value
        }
        if let value = dict["ConfigRuleIds"] as? String {
            self.configRuleIds = value
        }
    }
}

public class DetachConfigRuleToCompliancePackResponseBody : Tea.TeaModel {
    public class OperateRuleResult : Tea.TeaModel {
        public class OperateRuleItemList : Tea.TeaModel {
            public var configRuleId: String?

            public var errorCode: String?

            public var success: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.configRuleId != nil {
                    map["ConfigRuleId"] = self.configRuleId!
                }
                if self.errorCode != nil {
                    map["ErrorCode"] = self.errorCode!
                }
                if self.success != nil {
                    map["Success"] = self.success!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ConfigRuleId"] as? String {
                    self.configRuleId = value
                }
                if let value = dict["ErrorCode"] as? String {
                    self.errorCode = value
                }
                if let value = dict["Success"] as? Bool {
                    self.success = value
                }
            }
        }
        public var operateRuleItemList: [DetachConfigRuleToCompliancePackResponseBody.OperateRuleResult.OperateRuleItemList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.operateRuleItemList != nil {
                var tmp : [Any] = []
                for k in self.operateRuleItemList! {
                    tmp.append(k.toMap())
                }
                map["OperateRuleItemList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["OperateRuleItemList"] as? [Any?] {
                var tmp : [DetachConfigRuleToCompliancePackResponseBody.OperateRuleResult.OperateRuleItemList] = []
                for v in value {
                    if v != nil {
                        var model = DetachConfigRuleToCompliancePackResponseBody.OperateRuleResult.OperateRuleItemList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.operateRuleItemList = tmp
            }
        }
    }
    public var operateRuleResult: DetachConfigRuleToCompliancePackResponseBody.OperateRuleResult?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.operateRuleResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.operateRuleResult != nil {
            map["OperateRuleResult"] = self.operateRuleResult?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OperateRuleResult"] as? [String: Any?] {
            var model = DetachConfigRuleToCompliancePackResponseBody.OperateRuleResult()
            model.fromMap(value)
            self.operateRuleResult = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DetachConfigRuleToCompliancePackResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DetachConfigRuleToCompliancePackResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DetachConfigRuleToCompliancePackResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class EvaluatePreConfigRulesRequest : Tea.TeaModel {
    public class ResourceEvaluateItems : Tea.TeaModel {
        public class Rules : Tea.TeaModel {
            public var identifier: String?

            public var inputParameters: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.identifier != nil {
                    map["Identifier"] = self.identifier!
                }
                if self.inputParameters != nil {
                    map["InputParameters"] = self.inputParameters!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Identifier"] as? String {
                    self.identifier = value
                }
                if let value = dict["InputParameters"] as? String {
                    self.inputParameters = value
                }
            }
        }
        public var resourceLogicalId: String?

        public var resourceProperties: String?

        public var resourceType: String?

        public var rules: [EvaluatePreConfigRulesRequest.ResourceEvaluateItems.Rules]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.resourceLogicalId != nil {
                map["ResourceLogicalId"] = self.resourceLogicalId!
            }
            if self.resourceProperties != nil {
                map["ResourceProperties"] = self.resourceProperties!
            }
            if self.resourceType != nil {
                map["ResourceType"] = self.resourceType!
            }
            if self.rules != nil {
                var tmp : [Any] = []
                for k in self.rules! {
                    tmp.append(k.toMap())
                }
                map["Rules"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ResourceLogicalId"] as? String {
                self.resourceLogicalId = value
            }
            if let value = dict["ResourceProperties"] as? String {
                self.resourceProperties = value
            }
            if let value = dict["ResourceType"] as? String {
                self.resourceType = value
            }
            if let value = dict["Rules"] as? [Any?] {
                var tmp : [EvaluatePreConfigRulesRequest.ResourceEvaluateItems.Rules] = []
                for v in value {
                    if v != nil {
                        var model = EvaluatePreConfigRulesRequest.ResourceEvaluateItems.Rules()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.rules = tmp
            }
        }
    }
    public var enableManagedRules: Bool?

    public var resourceEvaluateItems: [EvaluatePreConfigRulesRequest.ResourceEvaluateItems]?

    public var resourceTypeFormat: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.enableManagedRules != nil {
            map["EnableManagedRules"] = self.enableManagedRules!
        }
        if self.resourceEvaluateItems != nil {
            var tmp : [Any] = []
            for k in self.resourceEvaluateItems! {
                tmp.append(k.toMap())
            }
            map["ResourceEvaluateItems"] = tmp
        }
        if self.resourceTypeFormat != nil {
            map["ResourceTypeFormat"] = self.resourceTypeFormat!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EnableManagedRules"] as? Bool {
            self.enableManagedRules = value
        }
        if let value = dict["ResourceEvaluateItems"] as? [Any?] {
            var tmp : [EvaluatePreConfigRulesRequest.ResourceEvaluateItems] = []
            for v in value {
                if v != nil {
                    var model = EvaluatePreConfigRulesRequest.ResourceEvaluateItems()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.resourceEvaluateItems = tmp
        }
        if let value = dict["ResourceTypeFormat"] as? String {
            self.resourceTypeFormat = value
        }
    }
}

public class EvaluatePreConfigRulesShrinkRequest : Tea.TeaModel {
    public var enableManagedRules: Bool?

    public var resourceEvaluateItemsShrink: String?

    public var resourceTypeFormat: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.enableManagedRules != nil {
            map["EnableManagedRules"] = self.enableManagedRules!
        }
        if self.resourceEvaluateItemsShrink != nil {
            map["ResourceEvaluateItems"] = self.resourceEvaluateItemsShrink!
        }
        if self.resourceTypeFormat != nil {
            map["ResourceTypeFormat"] = self.resourceTypeFormat!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EnableManagedRules"] as? Bool {
            self.enableManagedRules = value
        }
        if let value = dict["ResourceEvaluateItems"] as? String {
            self.resourceEvaluateItemsShrink = value
        }
        if let value = dict["ResourceTypeFormat"] as? String {
            self.resourceTypeFormat = value
        }
    }
}

public class EvaluatePreConfigRulesResponseBody : Tea.TeaModel {
    public class ResourceEvaluations : Tea.TeaModel {
        public class Rules : Tea.TeaModel {
            public var annotation: String?

            public var complianceType: String?

            public var helpUrl: String?

            public var identifier: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.annotation != nil {
                    map["Annotation"] = self.annotation!
                }
                if self.complianceType != nil {
                    map["ComplianceType"] = self.complianceType!
                }
                if self.helpUrl != nil {
                    map["HelpUrl"] = self.helpUrl!
                }
                if self.identifier != nil {
                    map["Identifier"] = self.identifier!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Annotation"] as? String {
                    self.annotation = value
                }
                if let value = dict["ComplianceType"] as? String {
                    self.complianceType = value
                }
                if let value = dict["HelpUrl"] as? String {
                    self.helpUrl = value
                }
                if let value = dict["Identifier"] as? String {
                    self.identifier = value
                }
            }
        }
        public var resourceLogicalId: String?

        public var resourceType: String?

        public var rules: [EvaluatePreConfigRulesResponseBody.ResourceEvaluations.Rules]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.resourceLogicalId != nil {
                map["ResourceLogicalId"] = self.resourceLogicalId!
            }
            if self.resourceType != nil {
                map["ResourceType"] = self.resourceType!
            }
            if self.rules != nil {
                var tmp : [Any] = []
                for k in self.rules! {
                    tmp.append(k.toMap())
                }
                map["Rules"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ResourceLogicalId"] as? String {
                self.resourceLogicalId = value
            }
            if let value = dict["ResourceType"] as? String {
                self.resourceType = value
            }
            if let value = dict["Rules"] as? [Any?] {
                var tmp : [EvaluatePreConfigRulesResponseBody.ResourceEvaluations.Rules] = []
                for v in value {
                    if v != nil {
                        var model = EvaluatePreConfigRulesResponseBody.ResourceEvaluations.Rules()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.rules = tmp
            }
        }
    }
    public var requestId: String?

    public var resourceEvaluations: [EvaluatePreConfigRulesResponseBody.ResourceEvaluations]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceEvaluations != nil {
            var tmp : [Any] = []
            for k in self.resourceEvaluations! {
                tmp.append(k.toMap())
            }
            map["ResourceEvaluations"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ResourceEvaluations"] as? [Any?] {
            var tmp : [EvaluatePreConfigRulesResponseBody.ResourceEvaluations] = []
            for v in value {
                if v != nil {
                    var model = EvaluatePreConfigRulesResponseBody.ResourceEvaluations()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.resourceEvaluations = tmp
        }
    }
}

public class EvaluatePreConfigRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EvaluatePreConfigRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = EvaluatePreConfigRulesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GenerateAggregateCompliancePackReportRequest : Tea.TeaModel {
    public var aggregatorId: String?

    public var clientToken: String?

    public var compliancePackId: String?

    public var multiFiles: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aggregatorId != nil {
            map["AggregatorId"] = self.aggregatorId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.compliancePackId != nil {
            map["CompliancePackId"] = self.compliancePackId!
        }
        if self.multiFiles != nil {
            map["MultiFiles"] = self.multiFiles!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AggregatorId"] as? String {
            self.aggregatorId = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["CompliancePackId"] as? String {
            self.compliancePackId = value
        }
        if let value = dict["MultiFiles"] as? Bool {
            self.multiFiles = value
        }
    }
}

public class GenerateAggregateCompliancePackReportResponseBody : Tea.TeaModel {
    public var compliancePackId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.compliancePackId != nil {
            map["CompliancePackId"] = self.compliancePackId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CompliancePackId"] as? String {
            self.compliancePackId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GenerateAggregateCompliancePackReportResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GenerateAggregateCompliancePackReportResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GenerateAggregateCompliancePackReportResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GenerateAggregateConfigRulesReportRequest : Tea.TeaModel {
    public var aggregatorId: String?

    public var clientToken: String?

    public var configRuleIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aggregatorId != nil {
            map["AggregatorId"] = self.aggregatorId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.configRuleIds != nil {
            map["ConfigRuleIds"] = self.configRuleIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AggregatorId"] as? String {
            self.aggregatorId = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["ConfigRuleIds"] as? String {
            self.configRuleIds = value
        }
    }
}

public class GenerateAggregateConfigRulesReportResponseBody : Tea.TeaModel {
    public var aggregatorId: String?

    public var reportId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aggregatorId != nil {
            map["AggregatorId"] = self.aggregatorId!
        }
        if self.reportId != nil {
            map["ReportId"] = self.reportId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AggregatorId"] as? String {
            self.aggregatorId = value
        }
        if let value = dict["ReportId"] as? String {
            self.reportId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GenerateAggregateConfigRulesReportResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GenerateAggregateConfigRulesReportResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GenerateAggregateConfigRulesReportResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GenerateAggregateResourceInventoryRequest : Tea.TeaModel {
    public var accountIds: String?

    public var aggregatorId: String?

    public var regions: String?

    public var resourceDeleted: Int32?

    public var resourceTypes: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountIds != nil {
            map["AccountIds"] = self.accountIds!
        }
        if self.aggregatorId != nil {
            map["AggregatorId"] = self.aggregatorId!
        }
        if self.regions != nil {
            map["Regions"] = self.regions!
        }
        if self.resourceDeleted != nil {
            map["ResourceDeleted"] = self.resourceDeleted!
        }
        if self.resourceTypes != nil {
            map["ResourceTypes"] = self.resourceTypes!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AccountIds"] as? String {
            self.accountIds = value
        }
        if let value = dict["AggregatorId"] as? String {
            self.aggregatorId = value
        }
        if let value = dict["Regions"] as? String {
            self.regions = value
        }
        if let value = dict["ResourceDeleted"] as? Int32 {
            self.resourceDeleted = value
        }
        if let value = dict["ResourceTypes"] as? String {
            self.resourceTypes = value
        }
    }
}

public class GenerateAggregateResourceInventoryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GenerateAggregateResourceInventoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GenerateAggregateResourceInventoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GenerateAggregateResourceInventoryResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GenerateCompliancePackReportRequest : Tea.TeaModel {
    public var clientToken: String?

    public var compliancePackId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.compliancePackId != nil {
            map["CompliancePackId"] = self.compliancePackId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["CompliancePackId"] as? String {
            self.compliancePackId = value
        }
    }
}

public class GenerateCompliancePackReportResponseBody : Tea.TeaModel {
    public var compliancePackId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.compliancePackId != nil {
            map["CompliancePackId"] = self.compliancePackId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CompliancePackId"] as? String {
            self.compliancePackId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GenerateCompliancePackReportResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GenerateCompliancePackReportResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GenerateCompliancePackReportResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GenerateConfigRulesReportRequest : Tea.TeaModel {
    public var clientToken: String?

    public var configRuleIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.configRuleIds != nil {
            map["ConfigRuleIds"] = self.configRuleIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["ConfigRuleIds"] as? String {
            self.configRuleIds = value
        }
    }
}

public class GenerateConfigRulesReportResponseBody : Tea.TeaModel {
    public var reportId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.reportId != nil {
            map["ReportId"] = self.reportId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ReportId"] as? String {
            self.reportId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GenerateConfigRulesReportResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GenerateConfigRulesReportResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GenerateConfigRulesReportResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GenerateResourceInventoryRequest : Tea.TeaModel {
    public var regions: String?

    public var resourceDeleted: Int32?

    public var resourceTypes: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regions != nil {
            map["Regions"] = self.regions!
        }
        if self.resourceDeleted != nil {
            map["ResourceDeleted"] = self.resourceDeleted!
        }
        if self.resourceTypes != nil {
            map["ResourceTypes"] = self.resourceTypes!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Regions"] as? String {
            self.regions = value
        }
        if let value = dict["ResourceDeleted"] as? Int32 {
            self.resourceDeleted = value
        }
        if let value = dict["ResourceTypes"] as? String {
            self.resourceTypes = value
        }
    }
}

public class GenerateResourceInventoryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GenerateResourceInventoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GenerateResourceInventoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GenerateResourceInventoryResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetAdvancedSearchFileResponseBody : Tea.TeaModel {
    public class ResourceSearch : Tea.TeaModel {
        public var downloadUrl: String?

        public var resourceInventoryGenerateTime: Int64?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.downloadUrl != nil {
                map["DownloadUrl"] = self.downloadUrl!
            }
            if self.resourceInventoryGenerateTime != nil {
                map["ResourceInventoryGenerateTime"] = self.resourceInventoryGenerateTime!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DownloadUrl"] as? String {
                self.downloadUrl = value
            }
            if let value = dict["ResourceInventoryGenerateTime"] as? Int64 {
                self.resourceInventoryGenerateTime = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
        }
    }
    public var requestId: String?

    public var resourceSearch: GetAdvancedSearchFileResponseBody.ResourceSearch?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resourceSearch?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceSearch != nil {
            map["ResourceSearch"] = self.resourceSearch?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ResourceSearch"] as? [String: Any?] {
            var model = GetAdvancedSearchFileResponseBody.ResourceSearch()
            model.fromMap(value)
            self.resourceSearch = model
        }
    }
}

public class GetAdvancedSearchFileResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAdvancedSearchFileResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetAdvancedSearchFileResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetAggregateAccountComplianceByPackRequest : Tea.TeaModel {
    public var aggregatorId: String?

    public var compliancePackId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aggregatorId != nil {
            map["AggregatorId"] = self.aggregatorId!
        }
        if self.compliancePackId != nil {
            map["CompliancePackId"] = self.compliancePackId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AggregatorId"] as? String {
            self.aggregatorId = value
        }
        if let value = dict["CompliancePackId"] as? String {
            self.compliancePackId = value
        }
    }
}

public class GetAggregateAccountComplianceByPackResponseBody : Tea.TeaModel {
    public class AccountComplianceResult : Tea.TeaModel {
        public class AccountCompliances : Tea.TeaModel {
            public var accountId: Int64?

            public var accountName: String?

            public var complianceType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.accountId != nil {
                    map["AccountId"] = self.accountId!
                }
                if self.accountName != nil {
                    map["AccountName"] = self.accountName!
                }
                if self.complianceType != nil {
                    map["ComplianceType"] = self.complianceType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AccountId"] as? Int64 {
                    self.accountId = value
                }
                if let value = dict["AccountName"] as? String {
                    self.accountName = value
                }
                if let value = dict["ComplianceType"] as? String {
                    self.complianceType = value
                }
            }
        }
        public var accountCompliances: [GetAggregateAccountComplianceByPackResponseBody.AccountComplianceResult.AccountCompliances]?

        public var compliancePackId: String?

        public var nonCompliantCount: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountCompliances != nil {
                var tmp : [Any] = []
                for k in self.accountCompliances! {
                    tmp.append(k.toMap())
                }
                map["AccountCompliances"] = tmp
            }
            if self.compliancePackId != nil {
                map["CompliancePackId"] = self.compliancePackId!
            }
            if self.nonCompliantCount != nil {
                map["NonCompliantCount"] = self.nonCompliantCount!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AccountCompliances"] as? [Any?] {
                var tmp : [GetAggregateAccountComplianceByPackResponseBody.AccountComplianceResult.AccountCompliances] = []
                for v in value {
                    if v != nil {
                        var model = GetAggregateAccountComplianceByPackResponseBody.AccountComplianceResult.AccountCompliances()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.accountCompliances = tmp
            }
            if let value = dict["CompliancePackId"] as? String {
                self.compliancePackId = value
            }
            if let value = dict["NonCompliantCount"] as? Int32 {
                self.nonCompliantCount = value
            }
            if let value = dict["TotalCount"] as? Int32 {
                self.totalCount = value
            }
        }
    }
    public var accountComplianceResult: GetAggregateAccountComplianceByPackResponseBody.AccountComplianceResult?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountComplianceResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountComplianceResult != nil {
            map["AccountComplianceResult"] = self.accountComplianceResult?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AccountComplianceResult"] as? [String: Any?] {
            var model = GetAggregateAccountComplianceByPackResponseBody.AccountComplianceResult()
            model.fromMap(value)
            self.accountComplianceResult = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetAggregateAccountComplianceByPackResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAggregateAccountComplianceByPackResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetAggregateAccountComplianceByPackResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetAggregateAdvancedSearchFileRequest : Tea.TeaModel {
    public var aggregatorId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aggregatorId != nil {
            map["AggregatorId"] = self.aggregatorId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AggregatorId"] as? String {
            self.aggregatorId = value
        }
    }
}

public class GetAggregateAdvancedSearchFileResponseBody : Tea.TeaModel {
    public class ResourceSearch : Tea.TeaModel {
        public var downloadUrl: String?

        public var resourceInventoryGenerateTime: Int64?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.downloadUrl != nil {
                map["DownloadUrl"] = self.downloadUrl!
            }
            if self.resourceInventoryGenerateTime != nil {
                map["ResourceInventoryGenerateTime"] = self.resourceInventoryGenerateTime!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DownloadUrl"] as? String {
                self.downloadUrl = value
            }
            if let value = dict["ResourceInventoryGenerateTime"] as? Int64 {
                self.resourceInventoryGenerateTime = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
        }
    }
    public var requestId: String?

    public var resourceSearch: GetAggregateAdvancedSearchFileResponseBody.ResourceSearch?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resourceSearch?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceSearch != nil {
            map["ResourceSearch"] = self.resourceSearch?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ResourceSearch"] as? [String: Any?] {
            var model = GetAggregateAdvancedSearchFileResponseBody.ResourceSearch()
            model.fromMap(value)
            self.resourceSearch = model
        }
    }
}

public class GetAggregateAdvancedSearchFileResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAggregateAdvancedSearchFileResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetAggregateAdvancedSearchFileResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetAggregateCompliancePackRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var aggregatorId: String?

    public var compliancePackId: String?

    public var tag: [GetAggregateCompliancePackRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aggregatorId != nil {
            map["AggregatorId"] = self.aggregatorId!
        }
        if self.compliancePackId != nil {
            map["CompliancePackId"] = self.compliancePackId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AggregatorId"] as? String {
            self.aggregatorId = value
        }
        if let value = dict["CompliancePackId"] as? String {
            self.compliancePackId = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [GetAggregateCompliancePackRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = GetAggregateCompliancePackRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
    }
}

public class GetAggregateCompliancePackShrinkRequest : Tea.TeaModel {
    public var aggregatorId: String?

    public var compliancePackId: String?

    public var tagShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aggregatorId != nil {
            map["AggregatorId"] = self.aggregatorId!
        }
        if self.compliancePackId != nil {
            map["CompliancePackId"] = self.compliancePackId!
        }
        if self.tagShrink != nil {
            map["Tag"] = self.tagShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AggregatorId"] as? String {
            self.aggregatorId = value
        }
        if let value = dict["CompliancePackId"] as? String {
            self.compliancePackId = value
        }
        if let value = dict["Tag"] as? String {
            self.tagShrink = value
        }
    }
}

public class GetAggregateCompliancePackResponseBody : Tea.TeaModel {
    public class CompliancePack : Tea.TeaModel {
        public class ConfigRules : Tea.TeaModel {
            public class ConfigRuleParameters : Tea.TeaModel {
                public var parameterName: String?

                public var parameterValue: String?

                public var required_: Bool?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.parameterName != nil {
                        map["ParameterName"] = self.parameterName!
                    }
                    if self.parameterValue != nil {
                        map["ParameterValue"] = self.parameterValue!
                    }
                    if self.required_ != nil {
                        map["Required"] = self.required_!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ParameterName"] as? String {
                        self.parameterName = value
                    }
                    if let value = dict["ParameterValue"] as? String {
                        self.parameterValue = value
                    }
                    if let value = dict["Required"] as? Bool {
                        self.required_ = value
                    }
                }
            }
            public var configRuleId: String?

            public var configRuleName: String?

            public var configRuleParameters: [GetAggregateCompliancePackResponseBody.CompliancePack.ConfigRules.ConfigRuleParameters]?

            public var description_: String?

            public var managedRuleIdentifier: String?

            public var resourceTypesScope: String?

            public var riskLevel: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.configRuleId != nil {
                    map["ConfigRuleId"] = self.configRuleId!
                }
                if self.configRuleName != nil {
                    map["ConfigRuleName"] = self.configRuleName!
                }
                if self.configRuleParameters != nil {
                    var tmp : [Any] = []
                    for k in self.configRuleParameters! {
                        tmp.append(k.toMap())
                    }
                    map["ConfigRuleParameters"] = tmp
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.managedRuleIdentifier != nil {
                    map["ManagedRuleIdentifier"] = self.managedRuleIdentifier!
                }
                if self.resourceTypesScope != nil {
                    map["ResourceTypesScope"] = self.resourceTypesScope!
                }
                if self.riskLevel != nil {
                    map["RiskLevel"] = self.riskLevel!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ConfigRuleId"] as? String {
                    self.configRuleId = value
                }
                if let value = dict["ConfigRuleName"] as? String {
                    self.configRuleName = value
                }
                if let value = dict["ConfigRuleParameters"] as? [Any?] {
                    var tmp : [GetAggregateCompliancePackResponseBody.CompliancePack.ConfigRules.ConfigRuleParameters] = []
                    for v in value {
                        if v != nil {
                            var model = GetAggregateCompliancePackResponseBody.CompliancePack.ConfigRules.ConfigRuleParameters()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.configRuleParameters = tmp
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["ManagedRuleIdentifier"] as? String {
                    self.managedRuleIdentifier = value
                }
                if let value = dict["ResourceTypesScope"] as? String {
                    self.resourceTypesScope = value
                }
                if let value = dict["RiskLevel"] as? Int32 {
                    self.riskLevel = value
                }
            }
        }
        public class Scope : Tea.TeaModel {
            public class ExcludeTagsScope : Tea.TeaModel {
                public var tagKey: String?

                public var tagValue: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tagKey != nil {
                        map["TagKey"] = self.tagKey!
                    }
                    if self.tagValue != nil {
                        map["TagValue"] = self.tagValue!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["TagKey"] as? String {
                        self.tagKey = value
                    }
                    if let value = dict["TagValue"] as? String {
                        self.tagValue = value
                    }
                }
            }
            public class TagsScope : Tea.TeaModel {
                public var tagKey: String?

                public var tagValue: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tagKey != nil {
                        map["TagKey"] = self.tagKey!
                    }
                    if self.tagValue != nil {
                        map["TagValue"] = self.tagValue!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["TagKey"] as? String {
                        self.tagKey = value
                    }
                    if let value = dict["TagValue"] as? String {
                        self.tagValue = value
                    }
                }
            }
            public var excludeRegionIdsScope: String?

            public var excludeResourceGroupIdsScope: String?

            public var excludeResourceIdsScope: String?

            public var excludeTagsScope: [GetAggregateCompliancePackResponseBody.CompliancePack.Scope.ExcludeTagsScope]?

            public var regionIdsScope: String?

            public var resourceGroupIdsScope: String?

            public var resourceIdsScope: String?

            public var tagKeyScope: String?

            public var tagValueScope: String?

            public var tagsScope: [GetAggregateCompliancePackResponseBody.CompliancePack.Scope.TagsScope]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.excludeRegionIdsScope != nil {
                    map["ExcludeRegionIdsScope"] = self.excludeRegionIdsScope!
                }
                if self.excludeResourceGroupIdsScope != nil {
                    map["ExcludeResourceGroupIdsScope"] = self.excludeResourceGroupIdsScope!
                }
                if self.excludeResourceIdsScope != nil {
                    map["ExcludeResourceIdsScope"] = self.excludeResourceIdsScope!
                }
                if self.excludeTagsScope != nil {
                    var tmp : [Any] = []
                    for k in self.excludeTagsScope! {
                        tmp.append(k.toMap())
                    }
                    map["ExcludeTagsScope"] = tmp
                }
                if self.regionIdsScope != nil {
                    map["RegionIdsScope"] = self.regionIdsScope!
                }
                if self.resourceGroupIdsScope != nil {
                    map["ResourceGroupIdsScope"] = self.resourceGroupIdsScope!
                }
                if self.resourceIdsScope != nil {
                    map["ResourceIdsScope"] = self.resourceIdsScope!
                }
                if self.tagKeyScope != nil {
                    map["TagKeyScope"] = self.tagKeyScope!
                }
                if self.tagValueScope != nil {
                    map["TagValueScope"] = self.tagValueScope!
                }
                if self.tagsScope != nil {
                    var tmp : [Any] = []
                    for k in self.tagsScope! {
                        tmp.append(k.toMap())
                    }
                    map["TagsScope"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ExcludeRegionIdsScope"] as? String {
                    self.excludeRegionIdsScope = value
                }
                if let value = dict["ExcludeResourceGroupIdsScope"] as? String {
                    self.excludeResourceGroupIdsScope = value
                }
                if let value = dict["ExcludeResourceIdsScope"] as? String {
                    self.excludeResourceIdsScope = value
                }
                if let value = dict["ExcludeTagsScope"] as? [Any?] {
                    var tmp : [GetAggregateCompliancePackResponseBody.CompliancePack.Scope.ExcludeTagsScope] = []
                    for v in value {
                        if v != nil {
                            var model = GetAggregateCompliancePackResponseBody.CompliancePack.Scope.ExcludeTagsScope()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.excludeTagsScope = tmp
                }
                if let value = dict["RegionIdsScope"] as? String {
                    self.regionIdsScope = value
                }
                if let value = dict["ResourceGroupIdsScope"] as? String {
                    self.resourceGroupIdsScope = value
                }
                if let value = dict["ResourceIdsScope"] as? String {
                    self.resourceIdsScope = value
                }
                if let value = dict["TagKeyScope"] as? String {
                    self.tagKeyScope = value
                }
                if let value = dict["TagValueScope"] as? String {
                    self.tagValueScope = value
                }
                if let value = dict["TagsScope"] as? [Any?] {
                    var tmp : [GetAggregateCompliancePackResponseBody.CompliancePack.Scope.TagsScope] = []
                    for v in value {
                        if v != nil {
                            var model = GetAggregateCompliancePackResponseBody.CompliancePack.Scope.TagsScope()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.tagsScope = tmp
                }
            }
        }
        public class Tags : Tea.TeaModel {
            public var tagKey: String?

            public var tagValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.tagKey != nil {
                    map["TagKey"] = self.tagKey!
                }
                if self.tagValue != nil {
                    map["TagValue"] = self.tagValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["TagKey"] as? String {
                    self.tagKey = value
                }
                if let value = dict["TagValue"] as? String {
                    self.tagValue = value
                }
            }
        }
        public var accountId: Int64?

        public var aggregatorId: String?

        public var compliancePackId: String?

        public var compliancePackName: String?

        public var compliancePackTemplateId: String?

        public var configRules: [GetAggregateCompliancePackResponseBody.CompliancePack.ConfigRules]?

        public var createTimestamp: Int64?

        public var description_: String?

        public var riskLevel: Int32?

        public var scope: GetAggregateCompliancePackResponseBody.CompliancePack.Scope?

        public var status: String?

        public var tags: [GetAggregateCompliancePackResponseBody.CompliancePack.Tags]?

        public var templateContent: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.scope?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["AccountId"] = self.accountId!
            }
            if self.aggregatorId != nil {
                map["AggregatorId"] = self.aggregatorId!
            }
            if self.compliancePackId != nil {
                map["CompliancePackId"] = self.compliancePackId!
            }
            if self.compliancePackName != nil {
                map["CompliancePackName"] = self.compliancePackName!
            }
            if self.compliancePackTemplateId != nil {
                map["CompliancePackTemplateId"] = self.compliancePackTemplateId!
            }
            if self.configRules != nil {
                var tmp : [Any] = []
                for k in self.configRules! {
                    tmp.append(k.toMap())
                }
                map["ConfigRules"] = tmp
            }
            if self.createTimestamp != nil {
                map["CreateTimestamp"] = self.createTimestamp!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.riskLevel != nil {
                map["RiskLevel"] = self.riskLevel!
            }
            if self.scope != nil {
                map["Scope"] = self.scope?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            if self.templateContent != nil {
                map["TemplateContent"] = self.templateContent!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AccountId"] as? Int64 {
                self.accountId = value
            }
            if let value = dict["AggregatorId"] as? String {
                self.aggregatorId = value
            }
            if let value = dict["CompliancePackId"] as? String {
                self.compliancePackId = value
            }
            if let value = dict["CompliancePackName"] as? String {
                self.compliancePackName = value
            }
            if let value = dict["CompliancePackTemplateId"] as? String {
                self.compliancePackTemplateId = value
            }
            if let value = dict["ConfigRules"] as? [Any?] {
                var tmp : [GetAggregateCompliancePackResponseBody.CompliancePack.ConfigRules] = []
                for v in value {
                    if v != nil {
                        var model = GetAggregateCompliancePackResponseBody.CompliancePack.ConfigRules()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.configRules = tmp
            }
            if let value = dict["CreateTimestamp"] as? Int64 {
                self.createTimestamp = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["RiskLevel"] as? Int32 {
                self.riskLevel = value
            }
            if let value = dict["Scope"] as? [String: Any?] {
                var model = GetAggregateCompliancePackResponseBody.CompliancePack.Scope()
                model.fromMap(value)
                self.scope = model
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
            if let value = dict["Tags"] as? [Any?] {
                var tmp : [GetAggregateCompliancePackResponseBody.CompliancePack.Tags] = []
                for v in value {
                    if v != nil {
                        var model = GetAggregateCompliancePackResponseBody.CompliancePack.Tags()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tags = tmp
            }
            if let value = dict["TemplateContent"] as? String {
                self.templateContent = value
            }
        }
    }
    public var compliancePack: GetAggregateCompliancePackResponseBody.CompliancePack?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.compliancePack?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.compliancePack != nil {
            map["CompliancePack"] = self.compliancePack?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CompliancePack"] as? [String: Any?] {
            var model = GetAggregateCompliancePackResponseBody.CompliancePack()
            model.fromMap(value)
            self.compliancePack = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetAggregateCompliancePackResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAggregateCompliancePackResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetAggregateCompliancePackResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetAggregateCompliancePackReportRequest : Tea.TeaModel {
    public var aggregatorId: String?

    public var compliancePackId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aggregatorId != nil {
            map["AggregatorId"] = self.aggregatorId!
        }
        if self.compliancePackId != nil {
            map["CompliancePackId"] = self.compliancePackId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AggregatorId"] as? String {
            self.aggregatorId = value
        }
        if let value = dict["CompliancePackId"] as? String {
            self.compliancePackId = value
        }
    }
}

public class GetAggregateCompliancePackReportResponseBody : Tea.TeaModel {
    public class CompliancePackReport : Tea.TeaModel {
        public var accountId: Int64?

        public var compliancePackId: String?

        public var reportCreateTimestamp: Int64?

        public var reportStatus: String?

        public var reportUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["AccountId"] = self.accountId!
            }
            if self.compliancePackId != nil {
                map["CompliancePackId"] = self.compliancePackId!
            }
            if self.reportCreateTimestamp != nil {
                map["ReportCreateTimestamp"] = self.reportCreateTimestamp!
            }
            if self.reportStatus != nil {
                map["ReportStatus"] = self.reportStatus!
            }
            if self.reportUrl != nil {
                map["ReportUrl"] = self.reportUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AccountId"] as? Int64 {
                self.accountId = value
            }
            if let value = dict["CompliancePackId"] as? String {
                self.compliancePackId = value
            }
            if let value = dict["ReportCreateTimestamp"] as? Int64 {
                self.reportCreateTimestamp = value
            }
            if let value = dict["ReportStatus"] as? String {
                self.reportStatus = value
            }
            if let value = dict["ReportUrl"] as? String {
                self.reportUrl = value
            }
        }
    }
    public var compliancePackReport: GetAggregateCompliancePackReportResponseBody.CompliancePackReport?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.compliancePackReport?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.compliancePackReport != nil {
            map["CompliancePackReport"] = self.compliancePackReport?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CompliancePackReport"] as? [String: Any?] {
            var model = GetAggregateCompliancePackReportResponseBody.CompliancePackReport()
            model.fromMap(value)
            self.compliancePackReport = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetAggregateCompliancePackReportResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAggregateCompliancePackReportResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetAggregateCompliancePackReportResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetAggregateComplianceSummaryRequest : Tea.TeaModel {
    public var aggregatorId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aggregatorId != nil {
            map["AggregatorId"] = self.aggregatorId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AggregatorId"] as? String {
            self.aggregatorId = value
        }
    }
}

public class GetAggregateComplianceSummaryResponseBody : Tea.TeaModel {
    public class ComplianceSummary : Tea.TeaModel {
        public class ComplianceSummaryByConfigRule : Tea.TeaModel {
            public var complianceSummaryTimestamp: Int64?

            public var compliantCount: Int32?

            public var nonCompliantCount: Int32?

            public var totalCount: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.complianceSummaryTimestamp != nil {
                    map["ComplianceSummaryTimestamp"] = self.complianceSummaryTimestamp!
                }
                if self.compliantCount != nil {
                    map["CompliantCount"] = self.compliantCount!
                }
                if self.nonCompliantCount != nil {
                    map["NonCompliantCount"] = self.nonCompliantCount!
                }
                if self.totalCount != nil {
                    map["TotalCount"] = self.totalCount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ComplianceSummaryTimestamp"] as? Int64 {
                    self.complianceSummaryTimestamp = value
                }
                if let value = dict["CompliantCount"] as? Int32 {
                    self.compliantCount = value
                }
                if let value = dict["NonCompliantCount"] as? Int32 {
                    self.nonCompliantCount = value
                }
                if let value = dict["TotalCount"] as? Int64 {
                    self.totalCount = value
                }
            }
        }
        public class ComplianceSummaryByResource : Tea.TeaModel {
            public var complianceSummaryTimestamp: Int64?

            public var compliantCount: Int32?

            public var nonCompliantCount: Int32?

            public var totalCount: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.complianceSummaryTimestamp != nil {
                    map["ComplianceSummaryTimestamp"] = self.complianceSummaryTimestamp!
                }
                if self.compliantCount != nil {
                    map["CompliantCount"] = self.compliantCount!
                }
                if self.nonCompliantCount != nil {
                    map["NonCompliantCount"] = self.nonCompliantCount!
                }
                if self.totalCount != nil {
                    map["TotalCount"] = self.totalCount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ComplianceSummaryTimestamp"] as? Int64 {
                    self.complianceSummaryTimestamp = value
                }
                if let value = dict["CompliantCount"] as? Int32 {
                    self.compliantCount = value
                }
                if let value = dict["NonCompliantCount"] as? Int32 {
                    self.nonCompliantCount = value
                }
                if let value = dict["TotalCount"] as? Int64 {
                    self.totalCount = value
                }
            }
        }
        public var complianceSummaryByConfigRule: GetAggregateComplianceSummaryResponseBody.ComplianceSummary.ComplianceSummaryByConfigRule?

        public var complianceSummaryByResource: GetAggregateComplianceSummaryResponseBody.ComplianceSummary.ComplianceSummaryByResource?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.complianceSummaryByConfigRule?.validate()
            try self.complianceSummaryByResource?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.complianceSummaryByConfigRule != nil {
                map["ComplianceSummaryByConfigRule"] = self.complianceSummaryByConfigRule?.toMap()
            }
            if self.complianceSummaryByResource != nil {
                map["ComplianceSummaryByResource"] = self.complianceSummaryByResource?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ComplianceSummaryByConfigRule"] as? [String: Any?] {
                var model = GetAggregateComplianceSummaryResponseBody.ComplianceSummary.ComplianceSummaryByConfigRule()
                model.fromMap(value)
                self.complianceSummaryByConfigRule = model
            }
            if let value = dict["ComplianceSummaryByResource"] as? [String: Any?] {
                var model = GetAggregateComplianceSummaryResponseBody.ComplianceSummary.ComplianceSummaryByResource()
                model.fromMap(value)
                self.complianceSummaryByResource = model
            }
        }
    }
    public var complianceSummary: GetAggregateComplianceSummaryResponseBody.ComplianceSummary?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.complianceSummary?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.complianceSummary != nil {
            map["ComplianceSummary"] = self.complianceSummary?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ComplianceSummary"] as? [String: Any?] {
            var model = GetAggregateComplianceSummaryResponseBody.ComplianceSummary()
            model.fromMap(value)
            self.complianceSummary = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetAggregateComplianceSummaryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAggregateComplianceSummaryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetAggregateComplianceSummaryResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetAggregateConfigDeliveryChannelRequest : Tea.TeaModel {
    public var aggregatorId: String?

    public var deliveryChannelId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aggregatorId != nil {
            map["AggregatorId"] = self.aggregatorId!
        }
        if self.deliveryChannelId != nil {
            map["DeliveryChannelId"] = self.deliveryChannelId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AggregatorId"] as? String {
            self.aggregatorId = value
        }
        if let value = dict["DeliveryChannelId"] as? String {
            self.deliveryChannelId = value
        }
    }
}

public class GetAggregateConfigDeliveryChannelResponseBody : Tea.TeaModel {
    public class DeliveryChannel : Tea.TeaModel {
        public var accountId: String?

        public var aggregatorId: String?

        public var compliantSnapshot: Bool?

        public var configurationItemChangeNotification: Bool?

        public var configurationSnapshot: Bool?

        public var deliveryChannelAssumeRoleArn: String?

        public var deliveryChannelCondition: String?

        public var deliveryChannelId: String?

        public var deliveryChannelName: String?

        public var deliveryChannelTargetArn: String?

        public var deliveryChannelType: String?

        public var deliverySnapshotTime: String?

        public var description_: String?

        public var nonCompliantNotification: Bool?

        public var oversizedDataOSSTargetArn: String?

        public var status: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["AccountId"] = self.accountId!
            }
            if self.aggregatorId != nil {
                map["AggregatorId"] = self.aggregatorId!
            }
            if self.compliantSnapshot != nil {
                map["CompliantSnapshot"] = self.compliantSnapshot!
            }
            if self.configurationItemChangeNotification != nil {
                map["ConfigurationItemChangeNotification"] = self.configurationItemChangeNotification!
            }
            if self.configurationSnapshot != nil {
                map["ConfigurationSnapshot"] = self.configurationSnapshot!
            }
            if self.deliveryChannelAssumeRoleArn != nil {
                map["DeliveryChannelAssumeRoleArn"] = self.deliveryChannelAssumeRoleArn!
            }
            if self.deliveryChannelCondition != nil {
                map["DeliveryChannelCondition"] = self.deliveryChannelCondition!
            }
            if self.deliveryChannelId != nil {
                map["DeliveryChannelId"] = self.deliveryChannelId!
            }
            if self.deliveryChannelName != nil {
                map["DeliveryChannelName"] = self.deliveryChannelName!
            }
            if self.deliveryChannelTargetArn != nil {
                map["DeliveryChannelTargetArn"] = self.deliveryChannelTargetArn!
            }
            if self.deliveryChannelType != nil {
                map["DeliveryChannelType"] = self.deliveryChannelType!
            }
            if self.deliverySnapshotTime != nil {
                map["DeliverySnapshotTime"] = self.deliverySnapshotTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.nonCompliantNotification != nil {
                map["NonCompliantNotification"] = self.nonCompliantNotification!
            }
            if self.oversizedDataOSSTargetArn != nil {
                map["OversizedDataOSSTargetArn"] = self.oversizedDataOSSTargetArn!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AccountId"] as? String {
                self.accountId = value
            }
            if let value = dict["AggregatorId"] as? String {
                self.aggregatorId = value
            }
            if let value = dict["CompliantSnapshot"] as? Bool {
                self.compliantSnapshot = value
            }
            if let value = dict["ConfigurationItemChangeNotification"] as? Bool {
                self.configurationItemChangeNotification = value
            }
            if let value = dict["ConfigurationSnapshot"] as? Bool {
                self.configurationSnapshot = value
            }
            if let value = dict["DeliveryChannelAssumeRoleArn"] as? String {
                self.deliveryChannelAssumeRoleArn = value
            }
            if let value = dict["DeliveryChannelCondition"] as? String {
                self.deliveryChannelCondition = value
            }
            if let value = dict["DeliveryChannelId"] as? String {
                self.deliveryChannelId = value
            }
            if let value = dict["DeliveryChannelName"] as? String {
                self.deliveryChannelName = value
            }
            if let value = dict["DeliveryChannelTargetArn"] as? String {
                self.deliveryChannelTargetArn = value
            }
            if let value = dict["DeliveryChannelType"] as? String {
                self.deliveryChannelType = value
            }
            if let value = dict["DeliverySnapshotTime"] as? String {
                self.deliverySnapshotTime = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["NonCompliantNotification"] as? Bool {
                self.nonCompliantNotification = value
            }
            if let value = dict["OversizedDataOSSTargetArn"] as? String {
                self.oversizedDataOSSTargetArn = value
            }
            if let value = dict["Status"] as? Int32 {
                self.status = value
            }
        }
    }
    public var deliveryChannel: GetAggregateConfigDeliveryChannelResponseBody.DeliveryChannel?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.deliveryChannel?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deliveryChannel != nil {
            map["DeliveryChannel"] = self.deliveryChannel?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DeliveryChannel"] as? [String: Any?] {
            var model = GetAggregateConfigDeliveryChannelResponseBody.DeliveryChannel()
            model.fromMap(value)
            self.deliveryChannel = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetAggregateConfigDeliveryChannelResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAggregateConfigDeliveryChannelResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetAggregateConfigDeliveryChannelResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetAggregateConfigRuleRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var aggregatorId: String?

    public var configRuleId: String?

    public var tag: [GetAggregateConfigRuleRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aggregatorId != nil {
            map["AggregatorId"] = self.aggregatorId!
        }
        if self.configRuleId != nil {
            map["ConfigRuleId"] = self.configRuleId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AggregatorId"] as? String {
            self.aggregatorId = value
        }
        if let value = dict["ConfigRuleId"] as? String {
            self.configRuleId = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [GetAggregateConfigRuleRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = GetAggregateConfigRuleRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
    }
}

public class GetAggregateConfigRuleShrinkRequest : Tea.TeaModel {
    public var aggregatorId: String?

    public var configRuleId: String?

    public var tagShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aggregatorId != nil {
            map["AggregatorId"] = self.aggregatorId!
        }
        if self.configRuleId != nil {
            map["ConfigRuleId"] = self.configRuleId!
        }
        if self.tagShrink != nil {
            map["Tag"] = self.tagShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AggregatorId"] as? String {
            self.aggregatorId = value
        }
        if let value = dict["ConfigRuleId"] as? String {
            self.configRuleId = value
        }
        if let value = dict["Tag"] as? String {
            self.tagShrink = value
        }
    }
}

public class GetAggregateConfigRuleResponseBody : Tea.TeaModel {
    public class ConfigRule : Tea.TeaModel {
        public class Compliance : Tea.TeaModel {
            public var complianceType: String?

            public var count: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.complianceType != nil {
                    map["ComplianceType"] = self.complianceType!
                }
                if self.count != nil {
                    map["Count"] = self.count!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ComplianceType"] as? String {
                    self.complianceType = value
                }
                if let value = dict["Count"] as? Int32 {
                    self.count = value
                }
            }
        }
        public class ConfigRuleEvaluationStatus : Tea.TeaModel {
            public var firstActivatedTimestamp: Int64?

            public var firstEvaluationStarted: Bool?

            public var lastErrorCode: String?

            public var lastErrorMessage: String?

            public var lastFailedEvaluationTimestamp: Int64?

            public var lastFailedInvocationTimestamp: Int64?

            public var lastSuccessfulEvaluationTimestamp: Int64?

            public var lastSuccessfulInvocationTimestamp: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.firstActivatedTimestamp != nil {
                    map["FirstActivatedTimestamp"] = self.firstActivatedTimestamp!
                }
                if self.firstEvaluationStarted != nil {
                    map["FirstEvaluationStarted"] = self.firstEvaluationStarted!
                }
                if self.lastErrorCode != nil {
                    map["LastErrorCode"] = self.lastErrorCode!
                }
                if self.lastErrorMessage != nil {
                    map["LastErrorMessage"] = self.lastErrorMessage!
                }
                if self.lastFailedEvaluationTimestamp != nil {
                    map["LastFailedEvaluationTimestamp"] = self.lastFailedEvaluationTimestamp!
                }
                if self.lastFailedInvocationTimestamp != nil {
                    map["LastFailedInvocationTimestamp"] = self.lastFailedInvocationTimestamp!
                }
                if self.lastSuccessfulEvaluationTimestamp != nil {
                    map["LastSuccessfulEvaluationTimestamp"] = self.lastSuccessfulEvaluationTimestamp!
                }
                if self.lastSuccessfulInvocationTimestamp != nil {
                    map["LastSuccessfulInvocationTimestamp"] = self.lastSuccessfulInvocationTimestamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["FirstActivatedTimestamp"] as? Int64 {
                    self.firstActivatedTimestamp = value
                }
                if let value = dict["FirstEvaluationStarted"] as? Bool {
                    self.firstEvaluationStarted = value
                }
                if let value = dict["LastErrorCode"] as? String {
                    self.lastErrorCode = value
                }
                if let value = dict["LastErrorMessage"] as? String {
                    self.lastErrorMessage = value
                }
                if let value = dict["LastFailedEvaluationTimestamp"] as? Int64 {
                    self.lastFailedEvaluationTimestamp = value
                }
                if let value = dict["LastFailedInvocationTimestamp"] as? Int64 {
                    self.lastFailedInvocationTimestamp = value
                }
                if let value = dict["LastSuccessfulEvaluationTimestamp"] as? Int64 {
                    self.lastSuccessfulEvaluationTimestamp = value
                }
                if let value = dict["LastSuccessfulInvocationTimestamp"] as? Int64 {
                    self.lastSuccessfulInvocationTimestamp = value
                }
            }
        }
        public class CreateBy : Tea.TeaModel {
            public var aggregatorId: String?

            public var aggregatorName: String?

            public var compliancePackId: String?

            public var compliancePackName: String?

            public var creatorId: String?

            public var creatorName: String?

            public var creatorType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.aggregatorId != nil {
                    map["AggregatorId"] = self.aggregatorId!
                }
                if self.aggregatorName != nil {
                    map["AggregatorName"] = self.aggregatorName!
                }
                if self.compliancePackId != nil {
                    map["CompliancePackId"] = self.compliancePackId!
                }
                if self.compliancePackName != nil {
                    map["CompliancePackName"] = self.compliancePackName!
                }
                if self.creatorId != nil {
                    map["CreatorId"] = self.creatorId!
                }
                if self.creatorName != nil {
                    map["CreatorName"] = self.creatorName!
                }
                if self.creatorType != nil {
                    map["CreatorType"] = self.creatorType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AggregatorId"] as? String {
                    self.aggregatorId = value
                }
                if let value = dict["AggregatorName"] as? String {
                    self.aggregatorName = value
                }
                if let value = dict["CompliancePackId"] as? String {
                    self.compliancePackId = value
                }
                if let value = dict["CompliancePackName"] as? String {
                    self.compliancePackName = value
                }
                if let value = dict["CreatorId"] as? String {
                    self.creatorId = value
                }
                if let value = dict["CreatorName"] as? String {
                    self.creatorName = value
                }
                if let value = dict["CreatorType"] as? String {
                    self.creatorType = value
                }
            }
        }
        public class ExcludeTagsScope : Tea.TeaModel {
            public var tagKey: String?

            public var tagValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.tagKey != nil {
                    map["TagKey"] = self.tagKey!
                }
                if self.tagValue != nil {
                    map["TagValue"] = self.tagValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["TagKey"] as? String {
                    self.tagKey = value
                }
                if let value = dict["TagValue"] as? String {
                    self.tagValue = value
                }
            }
        }
        public class ManagedRule : Tea.TeaModel {
            public class SourceDetails : Tea.TeaModel {
                public var eventSource: String?

                public var maximumExecutionFrequency: String?

                public var messageType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.eventSource != nil {
                        map["EventSource"] = self.eventSource!
                    }
                    if self.maximumExecutionFrequency != nil {
                        map["MaximumExecutionFrequency"] = self.maximumExecutionFrequency!
                    }
                    if self.messageType != nil {
                        map["MessageType"] = self.messageType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["EventSource"] as? String {
                        self.eventSource = value
                    }
                    if let value = dict["MaximumExecutionFrequency"] as? String {
                        self.maximumExecutionFrequency = value
                    }
                    if let value = dict["MessageType"] as? String {
                        self.messageType = value
                    }
                }
            }
            public var compulsoryInputParameterDetails: [String: Any]?

            public var description_: String?

            public var identifier: String?

            public var labels: [String]?

            public var managedRuleName: String?

            public var optionalInputParameterDetails: [String: Any]?

            public var sourceDetails: [GetAggregateConfigRuleResponseBody.ConfigRule.ManagedRule.SourceDetails]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.compulsoryInputParameterDetails != nil {
                    map["CompulsoryInputParameterDetails"] = self.compulsoryInputParameterDetails!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.identifier != nil {
                    map["Identifier"] = self.identifier!
                }
                if self.labels != nil {
                    map["Labels"] = self.labels!
                }
                if self.managedRuleName != nil {
                    map["ManagedRuleName"] = self.managedRuleName!
                }
                if self.optionalInputParameterDetails != nil {
                    map["OptionalInputParameterDetails"] = self.optionalInputParameterDetails!
                }
                if self.sourceDetails != nil {
                    var tmp : [Any] = []
                    for k in self.sourceDetails! {
                        tmp.append(k.toMap())
                    }
                    map["SourceDetails"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CompulsoryInputParameterDetails"] as? [String: Any] {
                    self.compulsoryInputParameterDetails = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["Identifier"] as? String {
                    self.identifier = value
                }
                if let value = dict["Labels"] as? [String] {
                    self.labels = value
                }
                if let value = dict["ManagedRuleName"] as? String {
                    self.managedRuleName = value
                }
                if let value = dict["OptionalInputParameterDetails"] as? [String: Any] {
                    self.optionalInputParameterDetails = value
                }
                if let value = dict["SourceDetails"] as? [Any?] {
                    var tmp : [GetAggregateConfigRuleResponseBody.ConfigRule.ManagedRule.SourceDetails] = []
                    for v in value {
                        if v != nil {
                            var model = GetAggregateConfigRuleResponseBody.ConfigRule.ManagedRule.SourceDetails()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.sourceDetails = tmp
                }
            }
        }
        public class Source : Tea.TeaModel {
            public class SourceDetails : Tea.TeaModel {
                public var eventSource: String?

                public var maximumExecutionFrequency: String?

                public var messageType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.eventSource != nil {
                        map["EventSource"] = self.eventSource!
                    }
                    if self.maximumExecutionFrequency != nil {
                        map["MaximumExecutionFrequency"] = self.maximumExecutionFrequency!
                    }
                    if self.messageType != nil {
                        map["MessageType"] = self.messageType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["EventSource"] as? String {
                        self.eventSource = value
                    }
                    if let value = dict["MaximumExecutionFrequency"] as? String {
                        self.maximumExecutionFrequency = value
                    }
                    if let value = dict["MessageType"] as? String {
                        self.messageType = value
                    }
                }
            }
            public var identifier: String?

            public var owner: String?

            public var sourceDetails: [GetAggregateConfigRuleResponseBody.ConfigRule.Source.SourceDetails]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.identifier != nil {
                    map["Identifier"] = self.identifier!
                }
                if self.owner != nil {
                    map["Owner"] = self.owner!
                }
                if self.sourceDetails != nil {
                    var tmp : [Any] = []
                    for k in self.sourceDetails! {
                        tmp.append(k.toMap())
                    }
                    map["SourceDetails"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Identifier"] as? String {
                    self.identifier = value
                }
                if let value = dict["Owner"] as? String {
                    self.owner = value
                }
                if let value = dict["SourceDetails"] as? [Any?] {
                    var tmp : [GetAggregateConfigRuleResponseBody.ConfigRule.Source.SourceDetails] = []
                    for v in value {
                        if v != nil {
                            var model = GetAggregateConfigRuleResponseBody.ConfigRule.Source.SourceDetails()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.sourceDetails = tmp
                }
            }
        }
        public class Tags : Tea.TeaModel {
            public var tagKey: String?

            public var tagValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.tagKey != nil {
                    map["TagKey"] = self.tagKey!
                }
                if self.tagValue != nil {
                    map["TagValue"] = self.tagValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["TagKey"] as? String {
                    self.tagKey = value
                }
                if let value = dict["TagValue"] as? String {
                    self.tagValue = value
                }
            }
        }
        public class TagsScope : Tea.TeaModel {
            public var tagKey: String?

            public var tagValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.tagKey != nil {
                    map["TagKey"] = self.tagKey!
                }
                if self.tagValue != nil {
                    map["TagValue"] = self.tagValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["TagKey"] as? String {
                    self.tagKey = value
                }
                if let value = dict["TagValue"] as? String {
                    self.tagValue = value
                }
            }
        }
        public var accountId: Int64?

        public var accountIdsScope: String?

        public var compliance: GetAggregateConfigRuleResponseBody.ConfigRule.Compliance?

        public var configRuleArn: String?

        public var configRuleEvaluationStatus: GetAggregateConfigRuleResponseBody.ConfigRule.ConfigRuleEvaluationStatus?

        public var configRuleId: String?

        public var configRuleName: String?

        public var configRuleState: String?

        public var configRuleTriggerTypes: String?

        public var createBy: GetAggregateConfigRuleResponseBody.ConfigRule.CreateBy?

        public var createTimestamp: Int64?

        public var description_: String?

        public var excludeAccountIdsScope: String?

        public var excludeFolderIdsScope: String?

        public var excludeRegionIdsScope: String?

        public var excludeResourceGroupIdsScope: String?

        public var excludeResourceIdsScope: String?

        public var excludeTagsScope: [GetAggregateConfigRuleResponseBody.ConfigRule.ExcludeTagsScope]?

        public var extendContent: String?

        public var folderIdsScope: String?

        public var inputParameters: [String: Any]?

        public var managedRule: GetAggregateConfigRuleResponseBody.ConfigRule.ManagedRule?

        public var maximumExecutionFrequency: String?

        public var modifiedTimestamp: Int64?

        public var regionIdsScope: String?

        public var resourceGroupIdsScope: String?

        public var resourceIdsScope: String?

        public var resourceNameScope: String?

        public var resourceTypesScope: String?

        public var riskLevel: Int32?

        public var source: GetAggregateConfigRuleResponseBody.ConfigRule.Source?

        public var tagKeyLogicScope: String?

        public var tagKeyScope: String?

        public var tagValueScope: String?

        public var tags: [GetAggregateConfigRuleResponseBody.ConfigRule.Tags]?

        public var tagsScope: [GetAggregateConfigRuleResponseBody.ConfigRule.TagsScope]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.compliance?.validate()
            try self.configRuleEvaluationStatus?.validate()
            try self.createBy?.validate()
            try self.managedRule?.validate()
            try self.source?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["AccountId"] = self.accountId!
            }
            if self.accountIdsScope != nil {
                map["AccountIdsScope"] = self.accountIdsScope!
            }
            if self.compliance != nil {
                map["Compliance"] = self.compliance?.toMap()
            }
            if self.configRuleArn != nil {
                map["ConfigRuleArn"] = self.configRuleArn!
            }
            if self.configRuleEvaluationStatus != nil {
                map["ConfigRuleEvaluationStatus"] = self.configRuleEvaluationStatus?.toMap()
            }
            if self.configRuleId != nil {
                map["ConfigRuleId"] = self.configRuleId!
            }
            if self.configRuleName != nil {
                map["ConfigRuleName"] = self.configRuleName!
            }
            if self.configRuleState != nil {
                map["ConfigRuleState"] = self.configRuleState!
            }
            if self.configRuleTriggerTypes != nil {
                map["ConfigRuleTriggerTypes"] = self.configRuleTriggerTypes!
            }
            if self.createBy != nil {
                map["CreateBy"] = self.createBy?.toMap()
            }
            if self.createTimestamp != nil {
                map["CreateTimestamp"] = self.createTimestamp!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.excludeAccountIdsScope != nil {
                map["ExcludeAccountIdsScope"] = self.excludeAccountIdsScope!
            }
            if self.excludeFolderIdsScope != nil {
                map["ExcludeFolderIdsScope"] = self.excludeFolderIdsScope!
            }
            if self.excludeRegionIdsScope != nil {
                map["ExcludeRegionIdsScope"] = self.excludeRegionIdsScope!
            }
            if self.excludeResourceGroupIdsScope != nil {
                map["ExcludeResourceGroupIdsScope"] = self.excludeResourceGroupIdsScope!
            }
            if self.excludeResourceIdsScope != nil {
                map["ExcludeResourceIdsScope"] = self.excludeResourceIdsScope!
            }
            if self.excludeTagsScope != nil {
                var tmp : [Any] = []
                for k in self.excludeTagsScope! {
                    tmp.append(k.toMap())
                }
                map["ExcludeTagsScope"] = tmp
            }
            if self.extendContent != nil {
                map["ExtendContent"] = self.extendContent!
            }
            if self.folderIdsScope != nil {
                map["FolderIdsScope"] = self.folderIdsScope!
            }
            if self.inputParameters != nil {
                map["InputParameters"] = self.inputParameters!
            }
            if self.managedRule != nil {
                map["ManagedRule"] = self.managedRule?.toMap()
            }
            if self.maximumExecutionFrequency != nil {
                map["MaximumExecutionFrequency"] = self.maximumExecutionFrequency!
            }
            if self.modifiedTimestamp != nil {
                map["ModifiedTimestamp"] = self.modifiedTimestamp!
            }
            if self.regionIdsScope != nil {
                map["RegionIdsScope"] = self.regionIdsScope!
            }
            if self.resourceGroupIdsScope != nil {
                map["ResourceGroupIdsScope"] = self.resourceGroupIdsScope!
            }
            if self.resourceIdsScope != nil {
                map["ResourceIdsScope"] = self.resourceIdsScope!
            }
            if self.resourceNameScope != nil {
                map["ResourceNameScope"] = self.resourceNameScope!
            }
            if self.resourceTypesScope != nil {
                map["ResourceTypesScope"] = self.resourceTypesScope!
            }
            if self.riskLevel != nil {
                map["RiskLevel"] = self.riskLevel!
            }
            if self.source != nil {
                map["Source"] = self.source?.toMap()
            }
            if self.tagKeyLogicScope != nil {
                map["TagKeyLogicScope"] = self.tagKeyLogicScope!
            }
            if self.tagKeyScope != nil {
                map["TagKeyScope"] = self.tagKeyScope!
            }
            if self.tagValueScope != nil {
                map["TagValueScope"] = self.tagValueScope!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            if self.tagsScope != nil {
                var tmp : [Any] = []
                for k in self.tagsScope! {
                    tmp.append(k.toMap())
                }
                map["TagsScope"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AccountId"] as? Int64 {
                self.accountId = value
            }
            if let value = dict["AccountIdsScope"] as? String {
                self.accountIdsScope = value
            }
            if let value = dict["Compliance"] as? [String: Any?] {
                var model = GetAggregateConfigRuleResponseBody.ConfigRule.Compliance()
                model.fromMap(value)
                self.compliance = model
            }
            if let value = dict["ConfigRuleArn"] as? String {
                self.configRuleArn = value
            }
            if let value = dict["ConfigRuleEvaluationStatus"] as? [String: Any?] {
                var model = GetAggregateConfigRuleResponseBody.ConfigRule.ConfigRuleEvaluationStatus()
                model.fromMap(value)
                self.configRuleEvaluationStatus = model
            }
            if let value = dict["ConfigRuleId"] as? String {
                self.configRuleId = value
            }
            if let value = dict["ConfigRuleName"] as? String {
                self.configRuleName = value
            }
            if let value = dict["ConfigRuleState"] as? String {
                self.configRuleState = value
            }
            if let value = dict["ConfigRuleTriggerTypes"] as? String {
                self.configRuleTriggerTypes = value
            }
            if let value = dict["CreateBy"] as? [String: Any?] {
                var model = GetAggregateConfigRuleResponseBody.ConfigRule.CreateBy()
                model.fromMap(value)
                self.createBy = model
            }
            if let value = dict["CreateTimestamp"] as? Int64 {
                self.createTimestamp = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["ExcludeAccountIdsScope"] as? String {
                self.excludeAccountIdsScope = value
            }
            if let value = dict["ExcludeFolderIdsScope"] as? String {
                self.excludeFolderIdsScope = value
            }
            if let value = dict["ExcludeRegionIdsScope"] as? String {
                self.excludeRegionIdsScope = value
            }
            if let value = dict["ExcludeResourceGroupIdsScope"] as? String {
                self.excludeResourceGroupIdsScope = value
            }
            if let value = dict["ExcludeResourceIdsScope"] as? String {
                self.excludeResourceIdsScope = value
            }
            if let value = dict["ExcludeTagsScope"] as? [Any?] {
                var tmp : [GetAggregateConfigRuleResponseBody.ConfigRule.ExcludeTagsScope] = []
                for v in value {
                    if v != nil {
                        var model = GetAggregateConfigRuleResponseBody.ConfigRule.ExcludeTagsScope()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.excludeTagsScope = tmp
            }
            if let value = dict["ExtendContent"] as? String {
                self.extendContent = value
            }
            if let value = dict["FolderIdsScope"] as? String {
                self.folderIdsScope = value
            }
            if let value = dict["InputParameters"] as? [String: Any] {
                self.inputParameters = value
            }
            if let value = dict["ManagedRule"] as? [String: Any?] {
                var model = GetAggregateConfigRuleResponseBody.ConfigRule.ManagedRule()
                model.fromMap(value)
                self.managedRule = model
            }
            if let value = dict["MaximumExecutionFrequency"] as? String {
                self.maximumExecutionFrequency = value
            }
            if let value = dict["ModifiedTimestamp"] as? Int64 {
                self.modifiedTimestamp = value
            }
            if let value = dict["RegionIdsScope"] as? String {
                self.regionIdsScope = value
            }
            if let value = dict["ResourceGroupIdsScope"] as? String {
                self.resourceGroupIdsScope = value
            }
            if let value = dict["ResourceIdsScope"] as? String {
                self.resourceIdsScope = value
            }
            if let value = dict["ResourceNameScope"] as? String {
                self.resourceNameScope = value
            }
            if let value = dict["ResourceTypesScope"] as? String {
                self.resourceTypesScope = value
            }
            if let value = dict["RiskLevel"] as? Int32 {
                self.riskLevel = value
            }
            if let value = dict["Source"] as? [String: Any?] {
                var model = GetAggregateConfigRuleResponseBody.ConfigRule.Source()
                model.fromMap(value)
                self.source = model
            }
            if let value = dict["TagKeyLogicScope"] as? String {
                self.tagKeyLogicScope = value
            }
            if let value = dict["TagKeyScope"] as? String {
                self.tagKeyScope = value
            }
            if let value = dict["TagValueScope"] as? String {
                self.tagValueScope = value
            }
            if let value = dict["Tags"] as? [Any?] {
                var tmp : [GetAggregateConfigRuleResponseBody.ConfigRule.Tags] = []
                for v in value {
                    if v != nil {
                        var model = GetAggregateConfigRuleResponseBody.ConfigRule.Tags()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tags = tmp
            }
            if let value = dict["TagsScope"] as? [Any?] {
                var tmp : [GetAggregateConfigRuleResponseBody.ConfigRule.TagsScope] = []
                for v in value {
                    if v != nil {
                        var model = GetAggregateConfigRuleResponseBody.ConfigRule.TagsScope()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tagsScope = tmp
            }
        }
    }
    public var configRule: GetAggregateConfigRuleResponseBody.ConfigRule?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.configRule?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configRule != nil {
            map["ConfigRule"] = self.configRule?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ConfigRule"] as? [String: Any?] {
            var model = GetAggregateConfigRuleResponseBody.ConfigRule()
            model.fromMap(value)
            self.configRule = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetAggregateConfigRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAggregateConfigRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetAggregateConfigRuleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetAggregateConfigRuleComplianceByPackRequest : Tea.TeaModel {
    public var aggregatorId: String?

    public var compliancePackId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aggregatorId != nil {
            map["AggregatorId"] = self.aggregatorId!
        }
        if self.compliancePackId != nil {
            map["CompliancePackId"] = self.compliancePackId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AggregatorId"] as? String {
            self.aggregatorId = value
        }
        if let value = dict["CompliancePackId"] as? String {
            self.compliancePackId = value
        }
    }
}

public class GetAggregateConfigRuleComplianceByPackResponseBody : Tea.TeaModel {
    public class ConfigRuleComplianceResult : Tea.TeaModel {
        public class ConfigRuleCompliances : Tea.TeaModel {
            public var complianceType: String?

            public var configRuleId: String?

            public var configRuleName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.complianceType != nil {
                    map["ComplianceType"] = self.complianceType!
                }
                if self.configRuleId != nil {
                    map["ConfigRuleId"] = self.configRuleId!
                }
                if self.configRuleName != nil {
                    map["ConfigRuleName"] = self.configRuleName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ComplianceType"] as? String {
                    self.complianceType = value
                }
                if let value = dict["ConfigRuleId"] as? String {
                    self.configRuleId = value
                }
                if let value = dict["ConfigRuleName"] as? String {
                    self.configRuleName = value
                }
            }
        }
        public var compliancePackId: String?

        public var configRuleCompliances: [GetAggregateConfigRuleComplianceByPackResponseBody.ConfigRuleComplianceResult.ConfigRuleCompliances]?

        public var nonCompliantCount: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.compliancePackId != nil {
                map["CompliancePackId"] = self.compliancePackId!
            }
            if self.configRuleCompliances != nil {
                var tmp : [Any] = []
                for k in self.configRuleCompliances! {
                    tmp.append(k.toMap())
                }
                map["ConfigRuleCompliances"] = tmp
            }
            if self.nonCompliantCount != nil {
                map["NonCompliantCount"] = self.nonCompliantCount!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CompliancePackId"] as? String {
                self.compliancePackId = value
            }
            if let value = dict["ConfigRuleCompliances"] as? [Any?] {
                var tmp : [GetAggregateConfigRuleComplianceByPackResponseBody.ConfigRuleComplianceResult.ConfigRuleCompliances] = []
                for v in value {
                    if v != nil {
                        var model = GetAggregateConfigRuleComplianceByPackResponseBody.ConfigRuleComplianceResult.ConfigRuleCompliances()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.configRuleCompliances = tmp
            }
            if let value = dict["NonCompliantCount"] as? Int32 {
                self.nonCompliantCount = value
            }
            if let value = dict["TotalCount"] as? Int32 {
                self.totalCount = value
            }
        }
    }
    public var configRuleComplianceResult: GetAggregateConfigRuleComplianceByPackResponseBody.ConfigRuleComplianceResult?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.configRuleComplianceResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configRuleComplianceResult != nil {
            map["ConfigRuleComplianceResult"] = self.configRuleComplianceResult?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ConfigRuleComplianceResult"] as? [String: Any?] {
            var model = GetAggregateConfigRuleComplianceByPackResponseBody.ConfigRuleComplianceResult()
            model.fromMap(value)
            self.configRuleComplianceResult = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetAggregateConfigRuleComplianceByPackResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAggregateConfigRuleComplianceByPackResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetAggregateConfigRuleComplianceByPackResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetAggregateConfigRuleSummaryByRiskLevelRequest : Tea.TeaModel {
    public var aggregatorId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aggregatorId != nil {
            map["AggregatorId"] = self.aggregatorId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AggregatorId"] as? String {
            self.aggregatorId = value
        }
    }
}

public class GetAggregateConfigRuleSummaryByRiskLevelResponseBody : Tea.TeaModel {
    public class ConfigRuleSummaries : Tea.TeaModel {
        public var compliantCount: Int32?

        public var nonCompliantCount: Int32?

        public var riskLevel: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.compliantCount != nil {
                map["CompliantCount"] = self.compliantCount!
            }
            if self.nonCompliantCount != nil {
                map["NonCompliantCount"] = self.nonCompliantCount!
            }
            if self.riskLevel != nil {
                map["RiskLevel"] = self.riskLevel!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CompliantCount"] as? Int32 {
                self.compliantCount = value
            }
            if let value = dict["NonCompliantCount"] as? Int32 {
                self.nonCompliantCount = value
            }
            if let value = dict["RiskLevel"] as? Int32 {
                self.riskLevel = value
            }
        }
    }
    public var configRuleSummaries: [GetAggregateConfigRuleSummaryByRiskLevelResponseBody.ConfigRuleSummaries]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configRuleSummaries != nil {
            var tmp : [Any] = []
            for k in self.configRuleSummaries! {
                tmp.append(k.toMap())
            }
            map["ConfigRuleSummaries"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ConfigRuleSummaries"] as? [Any?] {
            var tmp : [GetAggregateConfigRuleSummaryByRiskLevelResponseBody.ConfigRuleSummaries] = []
            for v in value {
                if v != nil {
                    var model = GetAggregateConfigRuleSummaryByRiskLevelResponseBody.ConfigRuleSummaries()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.configRuleSummaries = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetAggregateConfigRuleSummaryByRiskLevelResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAggregateConfigRuleSummaryByRiskLevelResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetAggregateConfigRuleSummaryByRiskLevelResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetAggregateConfigRulesReportRequest : Tea.TeaModel {
    public var aggregatorId: String?

    public var reportId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aggregatorId != nil {
            map["AggregatorId"] = self.aggregatorId!
        }
        if self.reportId != nil {
            map["ReportId"] = self.reportId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AggregatorId"] as? String {
            self.aggregatorId = value
        }
        if let value = dict["ReportId"] as? String {
            self.reportId = value
        }
    }
}

public class GetAggregateConfigRulesReportResponseBody : Tea.TeaModel {
    public class ConfigRulesReport : Tea.TeaModel {
        public var accountId: Int64?

        public var aggregatorId: String?

        public var reportCreateTimestamp: Int64?

        public var reportId: String?

        public var reportStatus: String?

        public var reportUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["AccountId"] = self.accountId!
            }
            if self.aggregatorId != nil {
                map["AggregatorId"] = self.aggregatorId!
            }
            if self.reportCreateTimestamp != nil {
                map["ReportCreateTimestamp"] = self.reportCreateTimestamp!
            }
            if self.reportId != nil {
                map["ReportId"] = self.reportId!
            }
            if self.reportStatus != nil {
                map["ReportStatus"] = self.reportStatus!
            }
            if self.reportUrl != nil {
                map["ReportUrl"] = self.reportUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AccountId"] as? Int64 {
                self.accountId = value
            }
            if let value = dict["AggregatorId"] as? String {
                self.aggregatorId = value
            }
            if let value = dict["ReportCreateTimestamp"] as? Int64 {
                self.reportCreateTimestamp = value
            }
            if let value = dict["ReportId"] as? String {
                self.reportId = value
            }
            if let value = dict["ReportStatus"] as? String {
                self.reportStatus = value
            }
            if let value = dict["ReportUrl"] as? String {
                self.reportUrl = value
            }
        }
    }
    public var configRulesReport: GetAggregateConfigRulesReportResponseBody.ConfigRulesReport?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.configRulesReport?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configRulesReport != nil {
            map["ConfigRulesReport"] = self.configRulesReport?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ConfigRulesReport"] as? [String: Any?] {
            var model = GetAggregateConfigRulesReportResponseBody.ConfigRulesReport()
            model.fromMap(value)
            self.configRulesReport = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetAggregateConfigRulesReportResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAggregateConfigRulesReportResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetAggregateConfigRulesReportResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetAggregateDiscoveredResourceRequest : Tea.TeaModel {
    public var aggregatorId: String?

    public var complianceOption: Int32?

    public var region: String?

    public var resourceAccountId: Int64?

    public var resourceId: String?

    public var resourceOwnerId: Int64?

    public var resourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aggregatorId != nil {
            map["AggregatorId"] = self.aggregatorId!
        }
        if self.complianceOption != nil {
            map["ComplianceOption"] = self.complianceOption!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.resourceAccountId != nil {
            map["ResourceAccountId"] = self.resourceAccountId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AggregatorId"] as? String {
            self.aggregatorId = value
        }
        if let value = dict["ComplianceOption"] as? Int32 {
            self.complianceOption = value
        }
        if let value = dict["Region"] as? String {
            self.region = value
        }
        if let value = dict["ResourceAccountId"] as? Int64 {
            self.resourceAccountId = value
        }
        if let value = dict["ResourceId"] as? String {
            self.resourceId = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
    }
}

public class GetAggregateDiscoveredResourceResponseBody : Tea.TeaModel {
    public class DiscoveredResourceDetail : Tea.TeaModel {
        public var accountId: Int64?

        public var availabilityZone: String?

        public var complianceType: String?

        public var configuration: String?

        public var region: String?

        public var resourceCreationTime: Int64?

        public var resourceDeleted: Int32?

        public var resourceId: String?

        public var resourceName: String?

        public var resourceStatus: String?

        public var resourceType: String?

        public var tags: String?

        public var vSwitchId: String?

        public var vpcId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["AccountId"] = self.accountId!
            }
            if self.availabilityZone != nil {
                map["AvailabilityZone"] = self.availabilityZone!
            }
            if self.complianceType != nil {
                map["ComplianceType"] = self.complianceType!
            }
            if self.configuration != nil {
                map["Configuration"] = self.configuration!
            }
            if self.region != nil {
                map["Region"] = self.region!
            }
            if self.resourceCreationTime != nil {
                map["ResourceCreationTime"] = self.resourceCreationTime!
            }
            if self.resourceDeleted != nil {
                map["ResourceDeleted"] = self.resourceDeleted!
            }
            if self.resourceId != nil {
                map["ResourceId"] = self.resourceId!
            }
            if self.resourceName != nil {
                map["ResourceName"] = self.resourceName!
            }
            if self.resourceStatus != nil {
                map["ResourceStatus"] = self.resourceStatus!
            }
            if self.resourceType != nil {
                map["ResourceType"] = self.resourceType!
            }
            if self.tags != nil {
                map["Tags"] = self.tags!
            }
            if self.vSwitchId != nil {
                map["VSwitchId"] = self.vSwitchId!
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AccountId"] as? Int64 {
                self.accountId = value
            }
            if let value = dict["AvailabilityZone"] as? String {
                self.availabilityZone = value
            }
            if let value = dict["ComplianceType"] as? String {
                self.complianceType = value
            }
            if let value = dict["Configuration"] as? String {
                self.configuration = value
            }
            if let value = dict["Region"] as? String {
                self.region = value
            }
            if let value = dict["ResourceCreationTime"] as? Int64 {
                self.resourceCreationTime = value
            }
            if let value = dict["ResourceDeleted"] as? Int32 {
                self.resourceDeleted = value
            }
            if let value = dict["ResourceId"] as? String {
                self.resourceId = value
            }
            if let value = dict["ResourceName"] as? String {
                self.resourceName = value
            }
            if let value = dict["ResourceStatus"] as? String {
                self.resourceStatus = value
            }
            if let value = dict["ResourceType"] as? String {
                self.resourceType = value
            }
            if let value = dict["Tags"] as? String {
                self.tags = value
            }
            if let value = dict["VSwitchId"] as? String {
                self.vSwitchId = value
            }
            if let value = dict["VpcId"] as? String {
                self.vpcId = value
            }
        }
    }
    public var discoveredResourceDetail: GetAggregateDiscoveredResourceResponseBody.DiscoveredResourceDetail?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.discoveredResourceDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.discoveredResourceDetail != nil {
            map["DiscoveredResourceDetail"] = self.discoveredResourceDetail?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DiscoveredResourceDetail"] as? [String: Any?] {
            var model = GetAggregateDiscoveredResourceResponseBody.DiscoveredResourceDetail()
            model.fromMap(value)
            self.discoveredResourceDetail = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetAggregateDiscoveredResourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAggregateDiscoveredResourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetAggregateDiscoveredResourceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetAggregateResourceComplianceByConfigRuleRequest : Tea.TeaModel {
    public var aggregatorId: String?

    public var complianceType: String?

    public var configRuleId: String?

    public var resourceAccountId: Int64?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aggregatorId != nil {
            map["AggregatorId"] = self.aggregatorId!
        }
        if self.complianceType != nil {
            map["ComplianceType"] = self.complianceType!
        }
        if self.configRuleId != nil {
            map["ConfigRuleId"] = self.configRuleId!
        }
        if self.resourceAccountId != nil {
            map["ResourceAccountId"] = self.resourceAccountId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AggregatorId"] as? String {
            self.aggregatorId = value
        }
        if let value = dict["ComplianceType"] as? String {
            self.complianceType = value
        }
        if let value = dict["ConfigRuleId"] as? String {
            self.configRuleId = value
        }
        if let value = dict["ResourceAccountId"] as? Int64 {
            self.resourceAccountId = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class GetAggregateResourceComplianceByConfigRuleResponseBody : Tea.TeaModel {
    public class ComplianceResult : Tea.TeaModel {
        public class Compliances : Tea.TeaModel {
            public var complianceType: String?

            public var count: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.complianceType != nil {
                    map["ComplianceType"] = self.complianceType!
                }
                if self.count != nil {
                    map["Count"] = self.count!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ComplianceType"] as? String {
                    self.complianceType = value
                }
                if let value = dict["Count"] as? Int32 {
                    self.count = value
                }
            }
        }
        public var compliances: [GetAggregateResourceComplianceByConfigRuleResponseBody.ComplianceResult.Compliances]?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.compliances != nil {
                var tmp : [Any] = []
                for k in self.compliances! {
                    tmp.append(k.toMap())
                }
                map["Compliances"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Compliances"] as? [Any?] {
                var tmp : [GetAggregateResourceComplianceByConfigRuleResponseBody.ComplianceResult.Compliances] = []
                for v in value {
                    if v != nil {
                        var model = GetAggregateResourceComplianceByConfigRuleResponseBody.ComplianceResult.Compliances()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.compliances = tmp
            }
            if let value = dict["TotalCount"] as? Int64 {
                self.totalCount = value
            }
        }
    }
    public var complianceResult: GetAggregateResourceComplianceByConfigRuleResponseBody.ComplianceResult?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.complianceResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.complianceResult != nil {
            map["ComplianceResult"] = self.complianceResult?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ComplianceResult"] as? [String: Any?] {
            var model = GetAggregateResourceComplianceByConfigRuleResponseBody.ComplianceResult()
            model.fromMap(value)
            self.complianceResult = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetAggregateResourceComplianceByConfigRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAggregateResourceComplianceByConfigRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetAggregateResourceComplianceByConfigRuleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetAggregateResourceComplianceByPackRequest : Tea.TeaModel {
    public var aggregatorId: String?

    public var compliancePackId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aggregatorId != nil {
            map["AggregatorId"] = self.aggregatorId!
        }
        if self.compliancePackId != nil {
            map["CompliancePackId"] = self.compliancePackId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AggregatorId"] as? String {
            self.aggregatorId = value
        }
        if let value = dict["CompliancePackId"] as? String {
            self.compliancePackId = value
        }
    }
}

public class GetAggregateResourceComplianceByPackResponseBody : Tea.TeaModel {
    public class ResourceComplianceResult : Tea.TeaModel {
        public var compliancePackId: String?

        public var nonCompliantCount: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.compliancePackId != nil {
                map["CompliancePackId"] = self.compliancePackId!
            }
            if self.nonCompliantCount != nil {
                map["NonCompliantCount"] = self.nonCompliantCount!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CompliancePackId"] as? String {
                self.compliancePackId = value
            }
            if let value = dict["NonCompliantCount"] as? Int32 {
                self.nonCompliantCount = value
            }
            if let value = dict["TotalCount"] as? Int32 {
                self.totalCount = value
            }
        }
    }
    public var requestId: String?

    public var resourceComplianceResult: GetAggregateResourceComplianceByPackResponseBody.ResourceComplianceResult?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resourceComplianceResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceComplianceResult != nil {
            map["ResourceComplianceResult"] = self.resourceComplianceResult?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ResourceComplianceResult"] as? [String: Any?] {
            var model = GetAggregateResourceComplianceByPackResponseBody.ResourceComplianceResult()
            model.fromMap(value)
            self.resourceComplianceResult = model
        }
    }
}

public class GetAggregateResourceComplianceByPackResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAggregateResourceComplianceByPackResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetAggregateResourceComplianceByPackResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetAggregateResourceComplianceGroupByRegionRequest : Tea.TeaModel {
    public var aggregatorId: String?

    public var configRuleIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aggregatorId != nil {
            map["AggregatorId"] = self.aggregatorId!
        }
        if self.configRuleIds != nil {
            map["ConfigRuleIds"] = self.configRuleIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AggregatorId"] as? String {
            self.aggregatorId = value
        }
        if let value = dict["ConfigRuleIds"] as? String {
            self.configRuleIds = value
        }
    }
}

public class GetAggregateResourceComplianceGroupByRegionResponseBody : Tea.TeaModel {
    public class ComplianceResult : Tea.TeaModel {
        public class ComplianceResultList : Tea.TeaModel {
            public class Compliances : Tea.TeaModel {
                public var complianceType: String?

                public var count: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.complianceType != nil {
                        map["ComplianceType"] = self.complianceType!
                    }
                    if self.count != nil {
                        map["Count"] = self.count!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ComplianceType"] as? String {
                        self.complianceType = value
                    }
                    if let value = dict["Count"] as? Int64 {
                        self.count = value
                    }
                }
            }
            public var compliances: [GetAggregateResourceComplianceGroupByRegionResponseBody.ComplianceResult.ComplianceResultList.Compliances]?

            public var regionId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.compliances != nil {
                    var tmp : [Any] = []
                    for k in self.compliances! {
                        tmp.append(k.toMap())
                    }
                    map["Compliances"] = tmp
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Compliances"] as? [Any?] {
                    var tmp : [GetAggregateResourceComplianceGroupByRegionResponseBody.ComplianceResult.ComplianceResultList.Compliances] = []
                    for v in value {
                        if v != nil {
                            var model = GetAggregateResourceComplianceGroupByRegionResponseBody.ComplianceResult.ComplianceResultList.Compliances()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.compliances = tmp
                }
                if let value = dict["RegionId"] as? String {
                    self.regionId = value
                }
            }
        }
        public var complianceResultList: [GetAggregateResourceComplianceGroupByRegionResponseBody.ComplianceResult.ComplianceResultList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.complianceResultList != nil {
                var tmp : [Any] = []
                for k in self.complianceResultList! {
                    tmp.append(k.toMap())
                }
                map["ComplianceResultList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ComplianceResultList"] as? [Any?] {
                var tmp : [GetAggregateResourceComplianceGroupByRegionResponseBody.ComplianceResult.ComplianceResultList] = []
                for v in value {
                    if v != nil {
                        var model = GetAggregateResourceComplianceGroupByRegionResponseBody.ComplianceResult.ComplianceResultList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.complianceResultList = tmp
            }
        }
    }
    public var complianceResult: GetAggregateResourceComplianceGroupByRegionResponseBody.ComplianceResult?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.complianceResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.complianceResult != nil {
            map["ComplianceResult"] = self.complianceResult?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ComplianceResult"] as? [String: Any?] {
            var model = GetAggregateResourceComplianceGroupByRegionResponseBody.ComplianceResult()
            model.fromMap(value)
            self.complianceResult = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetAggregateResourceComplianceGroupByRegionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAggregateResourceComplianceGroupByRegionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetAggregateResourceComplianceGroupByRegionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetAggregateResourceComplianceGroupByResourceTypeRequest : Tea.TeaModel {
    public var aggregatorId: String?

    public var configRuleIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aggregatorId != nil {
            map["AggregatorId"] = self.aggregatorId!
        }
        if self.configRuleIds != nil {
            map["ConfigRuleIds"] = self.configRuleIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AggregatorId"] as? String {
            self.aggregatorId = value
        }
        if let value = dict["ConfigRuleIds"] as? String {
            self.configRuleIds = value
        }
    }
}

public class GetAggregateResourceComplianceGroupByResourceTypeResponseBody : Tea.TeaModel {
    public class ComplianceResult : Tea.TeaModel {
        public class ComplianceResultList : Tea.TeaModel {
            public class Compliances : Tea.TeaModel {
                public var complianceType: String?

                public var count: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.complianceType != nil {
                        map["ComplianceType"] = self.complianceType!
                    }
                    if self.count != nil {
                        map["Count"] = self.count!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ComplianceType"] as? String {
                        self.complianceType = value
                    }
                    if let value = dict["Count"] as? Int64 {
                        self.count = value
                    }
                }
            }
            public var compliances: [GetAggregateResourceComplianceGroupByResourceTypeResponseBody.ComplianceResult.ComplianceResultList.Compliances]?

            public var resourceType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.compliances != nil {
                    var tmp : [Any] = []
                    for k in self.compliances! {
                        tmp.append(k.toMap())
                    }
                    map["Compliances"] = tmp
                }
                if self.resourceType != nil {
                    map["ResourceType"] = self.resourceType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Compliances"] as? [Any?] {
                    var tmp : [GetAggregateResourceComplianceGroupByResourceTypeResponseBody.ComplianceResult.ComplianceResultList.Compliances] = []
                    for v in value {
                        if v != nil {
                            var model = GetAggregateResourceComplianceGroupByResourceTypeResponseBody.ComplianceResult.ComplianceResultList.Compliances()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.compliances = tmp
                }
                if let value = dict["ResourceType"] as? String {
                    self.resourceType = value
                }
            }
        }
        public var complianceResultList: [GetAggregateResourceComplianceGroupByResourceTypeResponseBody.ComplianceResult.ComplianceResultList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.complianceResultList != nil {
                var tmp : [Any] = []
                for k in self.complianceResultList! {
                    tmp.append(k.toMap())
                }
                map["ComplianceResultList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ComplianceResultList"] as? [Any?] {
                var tmp : [GetAggregateResourceComplianceGroupByResourceTypeResponseBody.ComplianceResult.ComplianceResultList] = []
                for v in value {
                    if v != nil {
                        var model = GetAggregateResourceComplianceGroupByResourceTypeResponseBody.ComplianceResult.ComplianceResultList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.complianceResultList = tmp
            }
        }
    }
    public var complianceResult: GetAggregateResourceComplianceGroupByResourceTypeResponseBody.ComplianceResult?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.complianceResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.complianceResult != nil {
            map["ComplianceResult"] = self.complianceResult?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ComplianceResult"] as? [String: Any?] {
            var model = GetAggregateResourceComplianceGroupByResourceTypeResponseBody.ComplianceResult()
            model.fromMap(value)
            self.complianceResult = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetAggregateResourceComplianceGroupByResourceTypeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAggregateResourceComplianceGroupByResourceTypeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetAggregateResourceComplianceGroupByResourceTypeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetAggregateResourceComplianceTimelineRequest : Tea.TeaModel {
    public var aggregatorId: String?

    public var endTime: Int64?

    public var maxResults: Int32?

    public var nextToken: String?

    public var region: String?

    public var resourceAccountId: Int64?

    public var resourceId: String?

    public var resourceOwnerId: Int64?

    public var resourceType: String?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aggregatorId != nil {
            map["AggregatorId"] = self.aggregatorId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.resourceAccountId != nil {
            map["ResourceAccountId"] = self.resourceAccountId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AggregatorId"] as? String {
            self.aggregatorId = value
        }
        if let value = dict["EndTime"] as? Int64 {
            self.endTime = value
        }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["Region"] as? String {
            self.region = value
        }
        if let value = dict["ResourceAccountId"] as? Int64 {
            self.resourceAccountId = value
        }
        if let value = dict["ResourceId"] as? String {
            self.resourceId = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
        if let value = dict["StartTime"] as? Int64 {
            self.startTime = value
        }
    }
}

public class GetAggregateResourceComplianceTimelineResponseBody : Tea.TeaModel {
    public class ResourceComplianceTimeline : Tea.TeaModel {
        public class ComplianceList : Tea.TeaModel {
            public var accountId: String?

            public var availabilityZone: String?

            public var captureTime: Int64?

            public var configuration: String?

            public var configurationDiff: String?

            public var region: String?

            public var resourceCreateTime: Int64?

            public var resourceId: String?

            public var resourceName: String?

            public var resourceStatus: String?

            public var resourceType: String?

            public var tags: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.accountId != nil {
                    map["AccountId"] = self.accountId!
                }
                if self.availabilityZone != nil {
                    map["AvailabilityZone"] = self.availabilityZone!
                }
                if self.captureTime != nil {
                    map["CaptureTime"] = self.captureTime!
                }
                if self.configuration != nil {
                    map["Configuration"] = self.configuration!
                }
                if self.configurationDiff != nil {
                    map["ConfigurationDiff"] = self.configurationDiff!
                }
                if self.region != nil {
                    map["Region"] = self.region!
                }
                if self.resourceCreateTime != nil {
                    map["ResourceCreateTime"] = self.resourceCreateTime!
                }
                if self.resourceId != nil {
                    map["ResourceId"] = self.resourceId!
                }
                if self.resourceName != nil {
                    map["ResourceName"] = self.resourceName!
                }
                if self.resourceStatus != nil {
                    map["ResourceStatus"] = self.resourceStatus!
                }
                if self.resourceType != nil {
                    map["ResourceType"] = self.resourceType!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AccountId"] as? String {
                    self.accountId = value
                }
                if let value = dict["AvailabilityZone"] as? String {
                    self.availabilityZone = value
                }
                if let value = dict["CaptureTime"] as? Int64 {
                    self.captureTime = value
                }
                if let value = dict["Configuration"] as? String {
                    self.configuration = value
                }
                if let value = dict["ConfigurationDiff"] as? String {
                    self.configurationDiff = value
                }
                if let value = dict["Region"] as? String {
                    self.region = value
                }
                if let value = dict["ResourceCreateTime"] as? Int64 {
                    self.resourceCreateTime = value
                }
                if let value = dict["ResourceId"] as? String {
                    self.resourceId = value
                }
                if let value = dict["ResourceName"] as? String {
                    self.resourceName = value
                }
                if let value = dict["ResourceStatus"] as? String {
                    self.resourceStatus = value
                }
                if let value = dict["ResourceType"] as? String {
                    self.resourceType = value
                }
                if let value = dict["Tags"] as? String {
                    self.tags = value
                }
            }
        }
        public var complianceList: [GetAggregateResourceComplianceTimelineResponseBody.ResourceComplianceTimeline.ComplianceList]?

        public var maxResults: Int32?

        public var nextToken: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.complianceList != nil {
                var tmp : [Any] = []
                for k in self.complianceList! {
                    tmp.append(k.toMap())
                }
                map["ComplianceList"] = tmp
            }
            if self.maxResults != nil {
                map["MaxResults"] = self.maxResults!
            }
            if self.nextToken != nil {
                map["NextToken"] = self.nextToken!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ComplianceList"] as? [Any?] {
                var tmp : [GetAggregateResourceComplianceTimelineResponseBody.ResourceComplianceTimeline.ComplianceList] = []
                for v in value {
                    if v != nil {
                        var model = GetAggregateResourceComplianceTimelineResponseBody.ResourceComplianceTimeline.ComplianceList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.complianceList = tmp
            }
            if let value = dict["MaxResults"] as? Int32 {
                self.maxResults = value
            }
            if let value = dict["NextToken"] as? String {
                self.nextToken = value
            }
        }
    }
    public var requestId: String?

    public var resourceComplianceTimeline: GetAggregateResourceComplianceTimelineResponseBody.ResourceComplianceTimeline?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resourceComplianceTimeline?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceComplianceTimeline != nil {
            map["ResourceComplianceTimeline"] = self.resourceComplianceTimeline?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ResourceComplianceTimeline"] as? [String: Any?] {
            var model = GetAggregateResourceComplianceTimelineResponseBody.ResourceComplianceTimeline()
            model.fromMap(value)
            self.resourceComplianceTimeline = model
        }
    }
}

public class GetAggregateResourceComplianceTimelineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAggregateResourceComplianceTimelineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetAggregateResourceComplianceTimelineResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetAggregateResourceConfigurationTimelineRequest : Tea.TeaModel {
    public var aggregatorId: String?

    public var endTime: Int64?

    public var maxResults: Int32?

    public var nextToken: String?

    public var region: String?

    public var resourceAccountId: Int64?

    public var resourceId: String?

    public var resourceOwnerId: Int64?

    public var resourceType: String?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aggregatorId != nil {
            map["AggregatorId"] = self.aggregatorId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.resourceAccountId != nil {
            map["ResourceAccountId"] = self.resourceAccountId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AggregatorId"] as? String {
            self.aggregatorId = value
        }
        if let value = dict["EndTime"] as? Int64 {
            self.endTime = value
        }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["Region"] as? String {
            self.region = value
        }
        if let value = dict["ResourceAccountId"] as? Int64 {
            self.resourceAccountId = value
        }
        if let value = dict["ResourceId"] as? String {
            self.resourceId = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
        if let value = dict["StartTime"] as? Int64 {
            self.startTime = value
        }
    }
}

public class GetAggregateResourceConfigurationTimelineResponseBody : Tea.TeaModel {
    public class ResourceConfigurationTimeline : Tea.TeaModel {
        public class ConfigurationList : Tea.TeaModel {
            public var accountId: Int64?

            public var availabilityZone: String?

            public var captureTime: String?

            public var configurationDiff: String?

            public var region: String?

            public var resourceCreateTime: String?

            public var resourceEventType: String?

            public var resourceId: String?

            public var resourceName: String?

            public var resourceType: String?

            public var tags: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.accountId != nil {
                    map["AccountId"] = self.accountId!
                }
                if self.availabilityZone != nil {
                    map["AvailabilityZone"] = self.availabilityZone!
                }
                if self.captureTime != nil {
                    map["CaptureTime"] = self.captureTime!
                }
                if self.configurationDiff != nil {
                    map["ConfigurationDiff"] = self.configurationDiff!
                }
                if self.region != nil {
                    map["Region"] = self.region!
                }
                if self.resourceCreateTime != nil {
                    map["ResourceCreateTime"] = self.resourceCreateTime!
                }
                if self.resourceEventType != nil {
                    map["ResourceEventType"] = self.resourceEventType!
                }
                if self.resourceId != nil {
                    map["ResourceId"] = self.resourceId!
                }
                if self.resourceName != nil {
                    map["ResourceName"] = self.resourceName!
                }
                if self.resourceType != nil {
                    map["ResourceType"] = self.resourceType!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AccountId"] as? Int64 {
                    self.accountId = value
                }
                if let value = dict["AvailabilityZone"] as? String {
                    self.availabilityZone = value
                }
                if let value = dict["CaptureTime"] as? String {
                    self.captureTime = value
                }
                if let value = dict["ConfigurationDiff"] as? String {
                    self.configurationDiff = value
                }
                if let value = dict["Region"] as? String {
                    self.region = value
                }
                if let value = dict["ResourceCreateTime"] as? String {
                    self.resourceCreateTime = value
                }
                if let value = dict["ResourceEventType"] as? String {
                    self.resourceEventType = value
                }
                if let value = dict["ResourceId"] as? String {
                    self.resourceId = value
                }
                if let value = dict["ResourceName"] as? String {
                    self.resourceName = value
                }
                if let value = dict["ResourceType"] as? String {
                    self.resourceType = value
                }
                if let value = dict["Tags"] as? String {
                    self.tags = value
                }
            }
        }
        public var configurationList: [GetAggregateResourceConfigurationTimelineResponseBody.ResourceConfigurationTimeline.ConfigurationList]?

        public var maxResults: Int32?

        public var nextToken: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.configurationList != nil {
                var tmp : [Any] = []
                for k in self.configurationList! {
                    tmp.append(k.toMap())
                }
                map["ConfigurationList"] = tmp
            }
            if self.maxResults != nil {
                map["MaxResults"] = self.maxResults!
            }
            if self.nextToken != nil {
                map["NextToken"] = self.nextToken!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ConfigurationList"] as? [Any?] {
                var tmp : [GetAggregateResourceConfigurationTimelineResponseBody.ResourceConfigurationTimeline.ConfigurationList] = []
                for v in value {
                    if v != nil {
                        var model = GetAggregateResourceConfigurationTimelineResponseBody.ResourceConfigurationTimeline.ConfigurationList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.configurationList = tmp
            }
            if let value = dict["MaxResults"] as? Int32 {
                self.maxResults = value
            }
            if let value = dict["NextToken"] as? String {
                self.nextToken = value
            }
        }
    }
    public var requestId: String?

    public var resourceConfigurationTimeline: GetAggregateResourceConfigurationTimelineResponseBody.ResourceConfigurationTimeline?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resourceConfigurationTimeline?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceConfigurationTimeline != nil {
            map["ResourceConfigurationTimeline"] = self.resourceConfigurationTimeline?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ResourceConfigurationTimeline"] as? [String: Any?] {
            var model = GetAggregateResourceConfigurationTimelineResponseBody.ResourceConfigurationTimeline()
            model.fromMap(value)
            self.resourceConfigurationTimeline = model
        }
    }
}

public class GetAggregateResourceConfigurationTimelineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAggregateResourceConfigurationTimelineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetAggregateResourceConfigurationTimelineResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetAggregateResourceCountsGroupByRegionRequest : Tea.TeaModel {
    public var aggregatorId: String?

    public var folderId: String?

    public var resourceAccountId: Int64?

    public var resourceOwnerId: Int64?

    public var resourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aggregatorId != nil {
            map["AggregatorId"] = self.aggregatorId!
        }
        if self.folderId != nil {
            map["FolderId"] = self.folderId!
        }
        if self.resourceAccountId != nil {
            map["ResourceAccountId"] = self.resourceAccountId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AggregatorId"] as? String {
            self.aggregatorId = value
        }
        if let value = dict["FolderId"] as? String {
            self.folderId = value
        }
        if let value = dict["ResourceAccountId"] as? Int64 {
            self.resourceAccountId = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
    }
}

public class GetAggregateResourceCountsGroupByRegionResponseBody : Tea.TeaModel {
    public class DiscoveredResourceCountsSummary : Tea.TeaModel {
        public var groupName: String?

        public var region: String?

        public var resourceCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.groupName != nil {
                map["GroupName"] = self.groupName!
            }
            if self.region != nil {
                map["Region"] = self.region!
            }
            if self.resourceCount != nil {
                map["ResourceCount"] = self.resourceCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["GroupName"] as? String {
                self.groupName = value
            }
            if let value = dict["Region"] as? String {
                self.region = value
            }
            if let value = dict["ResourceCount"] as? Int64 {
                self.resourceCount = value
            }
        }
    }
    public var discoveredResourceCountsSummary: [GetAggregateResourceCountsGroupByRegionResponseBody.DiscoveredResourceCountsSummary]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.discoveredResourceCountsSummary != nil {
            var tmp : [Any] = []
            for k in self.discoveredResourceCountsSummary! {
                tmp.append(k.toMap())
            }
            map["DiscoveredResourceCountsSummary"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DiscoveredResourceCountsSummary"] as? [Any?] {
            var tmp : [GetAggregateResourceCountsGroupByRegionResponseBody.DiscoveredResourceCountsSummary] = []
            for v in value {
                if v != nil {
                    var model = GetAggregateResourceCountsGroupByRegionResponseBody.DiscoveredResourceCountsSummary()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.discoveredResourceCountsSummary = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetAggregateResourceCountsGroupByRegionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAggregateResourceCountsGroupByRegionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetAggregateResourceCountsGroupByRegionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetAggregateResourceCountsGroupByResourceTypeRequest : Tea.TeaModel {
    public var aggregatorId: String?

    public var folderId: String?

    public var region: String?

    public var resourceAccountId: Int64?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aggregatorId != nil {
            map["AggregatorId"] = self.aggregatorId!
        }
        if self.folderId != nil {
            map["FolderId"] = self.folderId!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.resourceAccountId != nil {
            map["ResourceAccountId"] = self.resourceAccountId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AggregatorId"] as? String {
            self.aggregatorId = value
        }
        if let value = dict["FolderId"] as? String {
            self.folderId = value
        }
        if let value = dict["Region"] as? String {
            self.region = value
        }
        if let value = dict["ResourceAccountId"] as? Int64 {
            self.resourceAccountId = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class GetAggregateResourceCountsGroupByResourceTypeResponseBody : Tea.TeaModel {
    public class DiscoveredResourceCountsSummary : Tea.TeaModel {
        public var groupName: String?

        public var resourceCount: Int64?

        public var resourceType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.groupName != nil {
                map["GroupName"] = self.groupName!
            }
            if self.resourceCount != nil {
                map["ResourceCount"] = self.resourceCount!
            }
            if self.resourceType != nil {
                map["ResourceType"] = self.resourceType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["GroupName"] as? String {
                self.groupName = value
            }
            if let value = dict["ResourceCount"] as? Int64 {
                self.resourceCount = value
            }
            if let value = dict["ResourceType"] as? String {
                self.resourceType = value
            }
        }
    }
    public var discoveredResourceCountsSummary: [GetAggregateResourceCountsGroupByResourceTypeResponseBody.DiscoveredResourceCountsSummary]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.discoveredResourceCountsSummary != nil {
            var tmp : [Any] = []
            for k in self.discoveredResourceCountsSummary! {
                tmp.append(k.toMap())
            }
            map["DiscoveredResourceCountsSummary"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DiscoveredResourceCountsSummary"] as? [Any?] {
            var tmp : [GetAggregateResourceCountsGroupByResourceTypeResponseBody.DiscoveredResourceCountsSummary] = []
            for v in value {
                if v != nil {
                    var model = GetAggregateResourceCountsGroupByResourceTypeResponseBody.DiscoveredResourceCountsSummary()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.discoveredResourceCountsSummary = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetAggregateResourceCountsGroupByResourceTypeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAggregateResourceCountsGroupByResourceTypeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetAggregateResourceCountsGroupByResourceTypeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetAggregateResourceInventoryRequest : Tea.TeaModel {
    public var aggregatorId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aggregatorId != nil {
            map["AggregatorId"] = self.aggregatorId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AggregatorId"] as? String {
            self.aggregatorId = value
        }
    }
}

public class GetAggregateResourceInventoryResponseBody : Tea.TeaModel {
    public class ResourceInventory : Tea.TeaModel {
        public var downloadUrl: String?

        public var resourceInventoryGenerateTime: Int64?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.downloadUrl != nil {
                map["DownloadUrl"] = self.downloadUrl!
            }
            if self.resourceInventoryGenerateTime != nil {
                map["ResourceInventoryGenerateTime"] = self.resourceInventoryGenerateTime!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DownloadUrl"] as? String {
                self.downloadUrl = value
            }
            if let value = dict["ResourceInventoryGenerateTime"] as? Int64 {
                self.resourceInventoryGenerateTime = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
        }
    }
    public var requestId: String?

    public var resourceInventory: GetAggregateResourceInventoryResponseBody.ResourceInventory?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resourceInventory?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceInventory != nil {
            map["ResourceInventory"] = self.resourceInventory?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ResourceInventory"] as? [String: Any?] {
            var model = GetAggregateResourceInventoryResponseBody.ResourceInventory()
            model.fromMap(value)
            self.resourceInventory = model
        }
    }
}

public class GetAggregateResourceInventoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAggregateResourceInventoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetAggregateResourceInventoryResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetAggregatorRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var aggregatorId: String?

    public var tag: [GetAggregatorRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aggregatorId != nil {
            map["AggregatorId"] = self.aggregatorId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AggregatorId"] as? String {
            self.aggregatorId = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [GetAggregatorRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = GetAggregatorRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
    }
}

public class GetAggregatorShrinkRequest : Tea.TeaModel {
    public var aggregatorId: String?

    public var tagShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aggregatorId != nil {
            map["AggregatorId"] = self.aggregatorId!
        }
        if self.tagShrink != nil {
            map["Tag"] = self.tagShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AggregatorId"] as? String {
            self.aggregatorId = value
        }
        if let value = dict["Tag"] as? String {
            self.tagShrink = value
        }
    }
}

public class GetAggregatorResponseBody : Tea.TeaModel {
    public class Aggregator : Tea.TeaModel {
        public class AggregatorAccounts : Tea.TeaModel {
            public var accountId: Int64?

            public var accountName: String?

            public var accountType: String?

            public var recorderStatus: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.accountId != nil {
                    map["AccountId"] = self.accountId!
                }
                if self.accountName != nil {
                    map["AccountName"] = self.accountName!
                }
                if self.accountType != nil {
                    map["AccountType"] = self.accountType!
                }
                if self.recorderStatus != nil {
                    map["RecorderStatus"] = self.recorderStatus!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AccountId"] as? Int64 {
                    self.accountId = value
                }
                if let value = dict["AccountName"] as? String {
                    self.accountName = value
                }
                if let value = dict["AccountType"] as? String {
                    self.accountType = value
                }
                if let value = dict["RecorderStatus"] as? String {
                    self.recorderStatus = value
                }
            }
        }
        public class Tags : Tea.TeaModel {
            public var tagKey: String?

            public var tagValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.tagKey != nil {
                    map["TagKey"] = self.tagKey!
                }
                if self.tagValue != nil {
                    map["TagValue"] = self.tagValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["TagKey"] as? String {
                    self.tagKey = value
                }
                if let value = dict["TagValue"] as? String {
                    self.tagValue = value
                }
            }
        }
        public var accountId: Int64?

        public var aggregatorAccountCount: Int64?

        public var aggregatorAccounts: [GetAggregatorResponseBody.Aggregator.AggregatorAccounts]?

        public var aggregatorCreateTimestamp: String?

        public var aggregatorId: String?

        public var aggregatorName: String?

        public var aggregatorStatus: Int32?

        public var aggregatorType: String?

        public var description_: String?

        public var folderId: String?

        public var tags: [GetAggregatorResponseBody.Aggregator.Tags]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["AccountId"] = self.accountId!
            }
            if self.aggregatorAccountCount != nil {
                map["AggregatorAccountCount"] = self.aggregatorAccountCount!
            }
            if self.aggregatorAccounts != nil {
                var tmp : [Any] = []
                for k in self.aggregatorAccounts! {
                    tmp.append(k.toMap())
                }
                map["AggregatorAccounts"] = tmp
            }
            if self.aggregatorCreateTimestamp != nil {
                map["AggregatorCreateTimestamp"] = self.aggregatorCreateTimestamp!
            }
            if self.aggregatorId != nil {
                map["AggregatorId"] = self.aggregatorId!
            }
            if self.aggregatorName != nil {
                map["AggregatorName"] = self.aggregatorName!
            }
            if self.aggregatorStatus != nil {
                map["AggregatorStatus"] = self.aggregatorStatus!
            }
            if self.aggregatorType != nil {
                map["AggregatorType"] = self.aggregatorType!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.folderId != nil {
                map["FolderId"] = self.folderId!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AccountId"] as? Int64 {
                self.accountId = value
            }
            if let value = dict["AggregatorAccountCount"] as? Int64 {
                self.aggregatorAccountCount = value
            }
            if let value = dict["AggregatorAccounts"] as? [Any?] {
                var tmp : [GetAggregatorResponseBody.Aggregator.AggregatorAccounts] = []
                for v in value {
                    if v != nil {
                        var model = GetAggregatorResponseBody.Aggregator.AggregatorAccounts()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.aggregatorAccounts = tmp
            }
            if let value = dict["AggregatorCreateTimestamp"] as? String {
                self.aggregatorCreateTimestamp = value
            }
            if let value = dict["AggregatorId"] as? String {
                self.aggregatorId = value
            }
            if let value = dict["AggregatorName"] as? String {
                self.aggregatorName = value
            }
            if let value = dict["AggregatorStatus"] as? Int32 {
                self.aggregatorStatus = value
            }
            if let value = dict["AggregatorType"] as? String {
                self.aggregatorType = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["FolderId"] as? String {
                self.folderId = value
            }
            if let value = dict["Tags"] as? [Any?] {
                var tmp : [GetAggregatorResponseBody.Aggregator.Tags] = []
                for v in value {
                    if v != nil {
                        var model = GetAggregatorResponseBody.Aggregator.Tags()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tags = tmp
            }
        }
    }
    public var aggregator: GetAggregatorResponseBody.Aggregator?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.aggregator?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aggregator != nil {
            map["Aggregator"] = self.aggregator?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Aggregator"] as? [String: Any?] {
            var model = GetAggregatorResponseBody.Aggregator()
            model.fromMap(value)
            self.aggregator = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetAggregatorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAggregatorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetAggregatorResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetCompliancePackRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var compliancePackId: String?

    public var tag: [GetCompliancePackRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.compliancePackId != nil {
            map["CompliancePackId"] = self.compliancePackId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CompliancePackId"] as? String {
            self.compliancePackId = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [GetCompliancePackRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = GetCompliancePackRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
    }
}

public class GetCompliancePackShrinkRequest : Tea.TeaModel {
    public var compliancePackId: String?

    public var tagShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.compliancePackId != nil {
            map["CompliancePackId"] = self.compliancePackId!
        }
        if self.tagShrink != nil {
            map["Tag"] = self.tagShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CompliancePackId"] as? String {
            self.compliancePackId = value
        }
        if let value = dict["Tag"] as? String {
            self.tagShrink = value
        }
    }
}

public class GetCompliancePackResponseBody : Tea.TeaModel {
    public class CompliancePack : Tea.TeaModel {
        public class ConfigRules : Tea.TeaModel {
            public class ConfigRuleParameters : Tea.TeaModel {
                public var parameterName: String?

                public var parameterValue: String?

                public var required_: Bool?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.parameterName != nil {
                        map["ParameterName"] = self.parameterName!
                    }
                    if self.parameterValue != nil {
                        map["ParameterValue"] = self.parameterValue!
                    }
                    if self.required_ != nil {
                        map["Required"] = self.required_!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ParameterName"] as? String {
                        self.parameterName = value
                    }
                    if let value = dict["ParameterValue"] as? String {
                        self.parameterValue = value
                    }
                    if let value = dict["Required"] as? Bool {
                        self.required_ = value
                    }
                }
            }
            public var configRuleId: String?

            public var configRuleName: String?

            public var configRuleParameters: [GetCompliancePackResponseBody.CompliancePack.ConfigRules.ConfigRuleParameters]?

            public var description_: String?

            public var managedRuleIdentifier: String?

            public var resourceTypesScope: String?

            public var riskLevel: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.configRuleId != nil {
                    map["ConfigRuleId"] = self.configRuleId!
                }
                if self.configRuleName != nil {
                    map["ConfigRuleName"] = self.configRuleName!
                }
                if self.configRuleParameters != nil {
                    var tmp : [Any] = []
                    for k in self.configRuleParameters! {
                        tmp.append(k.toMap())
                    }
                    map["ConfigRuleParameters"] = tmp
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.managedRuleIdentifier != nil {
                    map["ManagedRuleIdentifier"] = self.managedRuleIdentifier!
                }
                if self.resourceTypesScope != nil {
                    map["ResourceTypesScope"] = self.resourceTypesScope!
                }
                if self.riskLevel != nil {
                    map["RiskLevel"] = self.riskLevel!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ConfigRuleId"] as? String {
                    self.configRuleId = value
                }
                if let value = dict["ConfigRuleName"] as? String {
                    self.configRuleName = value
                }
                if let value = dict["ConfigRuleParameters"] as? [Any?] {
                    var tmp : [GetCompliancePackResponseBody.CompliancePack.ConfigRules.ConfigRuleParameters] = []
                    for v in value {
                        if v != nil {
                            var model = GetCompliancePackResponseBody.CompliancePack.ConfigRules.ConfigRuleParameters()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.configRuleParameters = tmp
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["ManagedRuleIdentifier"] as? String {
                    self.managedRuleIdentifier = value
                }
                if let value = dict["ResourceTypesScope"] as? String {
                    self.resourceTypesScope = value
                }
                if let value = dict["RiskLevel"] as? Int32 {
                    self.riskLevel = value
                }
            }
        }
        public class Scope : Tea.TeaModel {
            public class ExcludeTagsScope : Tea.TeaModel {
                public var tagKey: String?

                public var tagValue: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tagKey != nil {
                        map["TagKey"] = self.tagKey!
                    }
                    if self.tagValue != nil {
                        map["TagValue"] = self.tagValue!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["TagKey"] as? String {
                        self.tagKey = value
                    }
                    if let value = dict["TagValue"] as? String {
                        self.tagValue = value
                    }
                }
            }
            public class TagsScope : Tea.TeaModel {
                public var tagKey: String?

                public var tagValue: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tagKey != nil {
                        map["TagKey"] = self.tagKey!
                    }
                    if self.tagValue != nil {
                        map["TagValue"] = self.tagValue!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["TagKey"] as? String {
                        self.tagKey = value
                    }
                    if let value = dict["TagValue"] as? String {
                        self.tagValue = value
                    }
                }
            }
            public var excludeRegionIdsScope: String?

            public var excludeResourceGroupIdsScope: String?

            public var excludeResourceIdsScope: String?

            public var excludeTagsScope: [GetCompliancePackResponseBody.CompliancePack.Scope.ExcludeTagsScope]?

            public var regionIdsScope: String?

            public var resourceGroupIdsScope: String?

            public var resourceIdsScope: String?

            public var tagKeyScope: String?

            public var tagValueScope: String?

            public var tagsScope: [GetCompliancePackResponseBody.CompliancePack.Scope.TagsScope]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.excludeRegionIdsScope != nil {
                    map["ExcludeRegionIdsScope"] = self.excludeRegionIdsScope!
                }
                if self.excludeResourceGroupIdsScope != nil {
                    map["ExcludeResourceGroupIdsScope"] = self.excludeResourceGroupIdsScope!
                }
                if self.excludeResourceIdsScope != nil {
                    map["ExcludeResourceIdsScope"] = self.excludeResourceIdsScope!
                }
                if self.excludeTagsScope != nil {
                    var tmp : [Any] = []
                    for k in self.excludeTagsScope! {
                        tmp.append(k.toMap())
                    }
                    map["ExcludeTagsScope"] = tmp
                }
                if self.regionIdsScope != nil {
                    map["RegionIdsScope"] = self.regionIdsScope!
                }
                if self.resourceGroupIdsScope != nil {
                    map["ResourceGroupIdsScope"] = self.resourceGroupIdsScope!
                }
                if self.resourceIdsScope != nil {
                    map["ResourceIdsScope"] = self.resourceIdsScope!
                }
                if self.tagKeyScope != nil {
                    map["TagKeyScope"] = self.tagKeyScope!
                }
                if self.tagValueScope != nil {
                    map["TagValueScope"] = self.tagValueScope!
                }
                if self.tagsScope != nil {
                    var tmp : [Any] = []
                    for k in self.tagsScope! {
                        tmp.append(k.toMap())
                    }
                    map["TagsScope"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ExcludeRegionIdsScope"] as? String {
                    self.excludeRegionIdsScope = value
                }
                if let value = dict["ExcludeResourceGroupIdsScope"] as? String {
                    self.excludeResourceGroupIdsScope = value
                }
                if let value = dict["ExcludeResourceIdsScope"] as? String {
                    self.excludeResourceIdsScope = value
                }
                if let value = dict["ExcludeTagsScope"] as? [Any?] {
                    var tmp : [GetCompliancePackResponseBody.CompliancePack.Scope.ExcludeTagsScope] = []
                    for v in value {
                        if v != nil {
                            var model = GetCompliancePackResponseBody.CompliancePack.Scope.ExcludeTagsScope()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.excludeTagsScope = tmp
                }
                if let value = dict["RegionIdsScope"] as? String {
                    self.regionIdsScope = value
                }
                if let value = dict["ResourceGroupIdsScope"] as? String {
                    self.resourceGroupIdsScope = value
                }
                if let value = dict["ResourceIdsScope"] as? String {
                    self.resourceIdsScope = value
                }
                if let value = dict["TagKeyScope"] as? String {
                    self.tagKeyScope = value
                }
                if let value = dict["TagValueScope"] as? String {
                    self.tagValueScope = value
                }
                if let value = dict["TagsScope"] as? [Any?] {
                    var tmp : [GetCompliancePackResponseBody.CompliancePack.Scope.TagsScope] = []
                    for v in value {
                        if v != nil {
                            var model = GetCompliancePackResponseBody.CompliancePack.Scope.TagsScope()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.tagsScope = tmp
                }
            }
        }
        public class Tags : Tea.TeaModel {
            public var tagKey: String?

            public var tagValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.tagKey != nil {
                    map["TagKey"] = self.tagKey!
                }
                if self.tagValue != nil {
                    map["TagValue"] = self.tagValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["TagKey"] as? String {
                    self.tagKey = value
                }
                if let value = dict["TagValue"] as? String {
                    self.tagValue = value
                }
            }
        }
        public var accountId: Int64?

        public var compliancePackId: String?

        public var compliancePackName: String?

        public var compliancePackTemplateId: String?

        public var configRules: [GetCompliancePackResponseBody.CompliancePack.ConfigRules]?

        public var createTimestamp: Int64?

        public var description_: String?

        public var riskLevel: Int32?

        public var scope: GetCompliancePackResponseBody.CompliancePack.Scope?

        public var status: String?

        public var tags: [GetCompliancePackResponseBody.CompliancePack.Tags]?

        public var templateContent: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.scope?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["AccountId"] = self.accountId!
            }
            if self.compliancePackId != nil {
                map["CompliancePackId"] = self.compliancePackId!
            }
            if self.compliancePackName != nil {
                map["CompliancePackName"] = self.compliancePackName!
            }
            if self.compliancePackTemplateId != nil {
                map["CompliancePackTemplateId"] = self.compliancePackTemplateId!
            }
            if self.configRules != nil {
                var tmp : [Any] = []
                for k in self.configRules! {
                    tmp.append(k.toMap())
                }
                map["ConfigRules"] = tmp
            }
            if self.createTimestamp != nil {
                map["CreateTimestamp"] = self.createTimestamp!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.riskLevel != nil {
                map["RiskLevel"] = self.riskLevel!
            }
            if self.scope != nil {
                map["Scope"] = self.scope?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            if self.templateContent != nil {
                map["TemplateContent"] = self.templateContent!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AccountId"] as? Int64 {
                self.accountId = value
            }
            if let value = dict["CompliancePackId"] as? String {
                self.compliancePackId = value
            }
            if let value = dict["CompliancePackName"] as? String {
                self.compliancePackName = value
            }
            if let value = dict["CompliancePackTemplateId"] as? String {
                self.compliancePackTemplateId = value
            }
            if let value = dict["ConfigRules"] as? [Any?] {
                var tmp : [GetCompliancePackResponseBody.CompliancePack.ConfigRules] = []
                for v in value {
                    if v != nil {
                        var model = GetCompliancePackResponseBody.CompliancePack.ConfigRules()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.configRules = tmp
            }
            if let value = dict["CreateTimestamp"] as? Int64 {
                self.createTimestamp = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["RiskLevel"] as? Int32 {
                self.riskLevel = value
            }
            if let value = dict["Scope"] as? [String: Any?] {
                var model = GetCompliancePackResponseBody.CompliancePack.Scope()
                model.fromMap(value)
                self.scope = model
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
            if let value = dict["Tags"] as? [Any?] {
                var tmp : [GetCompliancePackResponseBody.CompliancePack.Tags] = []
                for v in value {
                    if v != nil {
                        var model = GetCompliancePackResponseBody.CompliancePack.Tags()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tags = tmp
            }
            if let value = dict["TemplateContent"] as? String {
                self.templateContent = value
            }
        }
    }
    public var compliancePack: GetCompliancePackResponseBody.CompliancePack?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.compliancePack?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.compliancePack != nil {
            map["CompliancePack"] = self.compliancePack?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CompliancePack"] as? [String: Any?] {
            var model = GetCompliancePackResponseBody.CompliancePack()
            model.fromMap(value)
            self.compliancePack = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetCompliancePackResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetCompliancePackResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetCompliancePackResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetCompliancePackReportRequest : Tea.TeaModel {
    public var compliancePackId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.compliancePackId != nil {
            map["CompliancePackId"] = self.compliancePackId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CompliancePackId"] as? String {
            self.compliancePackId = value
        }
    }
}

public class GetCompliancePackReportResponseBody : Tea.TeaModel {
    public class CompliancePackReport : Tea.TeaModel {
        public var accountId: Int64?

        public var compliancePackId: String?

        public var reportCreateTimestamp: Int64?

        public var reportStatus: String?

        public var reportUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["AccountId"] = self.accountId!
            }
            if self.compliancePackId != nil {
                map["CompliancePackId"] = self.compliancePackId!
            }
            if self.reportCreateTimestamp != nil {
                map["ReportCreateTimestamp"] = self.reportCreateTimestamp!
            }
            if self.reportStatus != nil {
                map["ReportStatus"] = self.reportStatus!
            }
            if self.reportUrl != nil {
                map["ReportUrl"] = self.reportUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AccountId"] as? Int64 {
                self.accountId = value
            }
            if let value = dict["CompliancePackId"] as? String {
                self.compliancePackId = value
            }
            if let value = dict["ReportCreateTimestamp"] as? Int64 {
                self.reportCreateTimestamp = value
            }
            if let value = dict["ReportStatus"] as? String {
                self.reportStatus = value
            }
            if let value = dict["ReportUrl"] as? String {
                self.reportUrl = value
            }
        }
    }
    public var compliancePackReport: GetCompliancePackReportResponseBody.CompliancePackReport?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.compliancePackReport?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.compliancePackReport != nil {
            map["CompliancePackReport"] = self.compliancePackReport?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CompliancePackReport"] as? [String: Any?] {
            var model = GetCompliancePackReportResponseBody.CompliancePackReport()
            model.fromMap(value)
            self.compliancePackReport = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetCompliancePackReportResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetCompliancePackReportResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetCompliancePackReportResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetComplianceSummaryResponseBody : Tea.TeaModel {
    public class ComplianceSummary : Tea.TeaModel {
        public class ComplianceSummaryByConfigRule : Tea.TeaModel {
            public var complianceSummaryTimestamp: Int64?

            public var compliantCount: Int32?

            public var nonCompliantCount: Int32?

            public var totalCount: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.complianceSummaryTimestamp != nil {
                    map["ComplianceSummaryTimestamp"] = self.complianceSummaryTimestamp!
                }
                if self.compliantCount != nil {
                    map["CompliantCount"] = self.compliantCount!
                }
                if self.nonCompliantCount != nil {
                    map["NonCompliantCount"] = self.nonCompliantCount!
                }
                if self.totalCount != nil {
                    map["TotalCount"] = self.totalCount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ComplianceSummaryTimestamp"] as? Int64 {
                    self.complianceSummaryTimestamp = value
                }
                if let value = dict["CompliantCount"] as? Int32 {
                    self.compliantCount = value
                }
                if let value = dict["NonCompliantCount"] as? Int32 {
                    self.nonCompliantCount = value
                }
                if let value = dict["TotalCount"] as? Int64 {
                    self.totalCount = value
                }
            }
        }
        public class ComplianceSummaryByResource : Tea.TeaModel {
            public var complianceSummaryTimestamp: Int64?

            public var compliantCount: Int32?

            public var nonCompliantCount: Int32?

            public var totalCount: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.complianceSummaryTimestamp != nil {
                    map["ComplianceSummaryTimestamp"] = self.complianceSummaryTimestamp!
                }
                if self.compliantCount != nil {
                    map["CompliantCount"] = self.compliantCount!
                }
                if self.nonCompliantCount != nil {
                    map["NonCompliantCount"] = self.nonCompliantCount!
                }
                if self.totalCount != nil {
                    map["TotalCount"] = self.totalCount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ComplianceSummaryTimestamp"] as? Int64 {
                    self.complianceSummaryTimestamp = value
                }
                if let value = dict["CompliantCount"] as? Int32 {
                    self.compliantCount = value
                }
                if let value = dict["NonCompliantCount"] as? Int32 {
                    self.nonCompliantCount = value
                }
                if let value = dict["TotalCount"] as? Int64 {
                    self.totalCount = value
                }
            }
        }
        public var complianceSummaryByConfigRule: GetComplianceSummaryResponseBody.ComplianceSummary.ComplianceSummaryByConfigRule?

        public var complianceSummaryByResource: GetComplianceSummaryResponseBody.ComplianceSummary.ComplianceSummaryByResource?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.complianceSummaryByConfigRule?.validate()
            try self.complianceSummaryByResource?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.complianceSummaryByConfigRule != nil {
                map["ComplianceSummaryByConfigRule"] = self.complianceSummaryByConfigRule?.toMap()
            }
            if self.complianceSummaryByResource != nil {
                map["ComplianceSummaryByResource"] = self.complianceSummaryByResource?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ComplianceSummaryByConfigRule"] as? [String: Any?] {
                var model = GetComplianceSummaryResponseBody.ComplianceSummary.ComplianceSummaryByConfigRule()
                model.fromMap(value)
                self.complianceSummaryByConfigRule = model
            }
            if let value = dict["ComplianceSummaryByResource"] as? [String: Any?] {
                var model = GetComplianceSummaryResponseBody.ComplianceSummary.ComplianceSummaryByResource()
                model.fromMap(value)
                self.complianceSummaryByResource = model
            }
        }
    }
    public var complianceSummary: GetComplianceSummaryResponseBody.ComplianceSummary?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.complianceSummary?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.complianceSummary != nil {
            map["ComplianceSummary"] = self.complianceSummary?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ComplianceSummary"] as? [String: Any?] {
            var model = GetComplianceSummaryResponseBody.ComplianceSummary()
            model.fromMap(value)
            self.complianceSummary = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetComplianceSummaryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetComplianceSummaryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetComplianceSummaryResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetConfigDeliveryChannelRequest : Tea.TeaModel {
    public var deliveryChannelId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deliveryChannelId != nil {
            map["DeliveryChannelId"] = self.deliveryChannelId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DeliveryChannelId"] as? String {
            self.deliveryChannelId = value
        }
    }
}

public class GetConfigDeliveryChannelResponseBody : Tea.TeaModel {
    public class DeliveryChannel : Tea.TeaModel {
        public var accountId: Int64?

        public var compliantSnapshot: Bool?

        public var configurationItemChangeNotification: Bool?

        public var configurationSnapshot: Bool?

        public var deliveryChannelAssumeRoleArn: String?

        public var deliveryChannelCondition: String?

        public var deliveryChannelId: String?

        public var deliveryChannelName: String?

        public var deliveryChannelTargetArn: String?

        public var deliveryChannelType: String?

        public var deliverySnapshotTime: String?

        public var description_: String?

        public var nonCompliantNotification: Bool?

        public var oversizedDataOSSTargetArn: String?

        public var status: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["AccountId"] = self.accountId!
            }
            if self.compliantSnapshot != nil {
                map["CompliantSnapshot"] = self.compliantSnapshot!
            }
            if self.configurationItemChangeNotification != nil {
                map["ConfigurationItemChangeNotification"] = self.configurationItemChangeNotification!
            }
            if self.configurationSnapshot != nil {
                map["ConfigurationSnapshot"] = self.configurationSnapshot!
            }
            if self.deliveryChannelAssumeRoleArn != nil {
                map["DeliveryChannelAssumeRoleArn"] = self.deliveryChannelAssumeRoleArn!
            }
            if self.deliveryChannelCondition != nil {
                map["DeliveryChannelCondition"] = self.deliveryChannelCondition!
            }
            if self.deliveryChannelId != nil {
                map["DeliveryChannelId"] = self.deliveryChannelId!
            }
            if self.deliveryChannelName != nil {
                map["DeliveryChannelName"] = self.deliveryChannelName!
            }
            if self.deliveryChannelTargetArn != nil {
                map["DeliveryChannelTargetArn"] = self.deliveryChannelTargetArn!
            }
            if self.deliveryChannelType != nil {
                map["DeliveryChannelType"] = self.deliveryChannelType!
            }
            if self.deliverySnapshotTime != nil {
                map["DeliverySnapshotTime"] = self.deliverySnapshotTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.nonCompliantNotification != nil {
                map["NonCompliantNotification"] = self.nonCompliantNotification!
            }
            if self.oversizedDataOSSTargetArn != nil {
                map["OversizedDataOSSTargetArn"] = self.oversizedDataOSSTargetArn!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AccountId"] as? Int64 {
                self.accountId = value
            }
            if let value = dict["CompliantSnapshot"] as? Bool {
                self.compliantSnapshot = value
            }
            if let value = dict["ConfigurationItemChangeNotification"] as? Bool {
                self.configurationItemChangeNotification = value
            }
            if let value = dict["ConfigurationSnapshot"] as? Bool {
                self.configurationSnapshot = value
            }
            if let value = dict["DeliveryChannelAssumeRoleArn"] as? String {
                self.deliveryChannelAssumeRoleArn = value
            }
            if let value = dict["DeliveryChannelCondition"] as? String {
                self.deliveryChannelCondition = value
            }
            if let value = dict["DeliveryChannelId"] as? String {
                self.deliveryChannelId = value
            }
            if let value = dict["DeliveryChannelName"] as? String {
                self.deliveryChannelName = value
            }
            if let value = dict["DeliveryChannelTargetArn"] as? String {
                self.deliveryChannelTargetArn = value
            }
            if let value = dict["DeliveryChannelType"] as? String {
                self.deliveryChannelType = value
            }
            if let value = dict["DeliverySnapshotTime"] as? String {
                self.deliverySnapshotTime = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["NonCompliantNotification"] as? Bool {
                self.nonCompliantNotification = value
            }
            if let value = dict["OversizedDataOSSTargetArn"] as? String {
                self.oversizedDataOSSTargetArn = value
            }
            if let value = dict["Status"] as? Int32 {
                self.status = value
            }
        }
    }
    public var deliveryChannel: GetConfigDeliveryChannelResponseBody.DeliveryChannel?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.deliveryChannel?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deliveryChannel != nil {
            map["DeliveryChannel"] = self.deliveryChannel?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DeliveryChannel"] as? [String: Any?] {
            var model = GetConfigDeliveryChannelResponseBody.DeliveryChannel()
            model.fromMap(value)
            self.deliveryChannel = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetConfigDeliveryChannelResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetConfigDeliveryChannelResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetConfigDeliveryChannelResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetConfigRuleRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var configRuleId: String?

    public var tag: [GetConfigRuleRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configRuleId != nil {
            map["ConfigRuleId"] = self.configRuleId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ConfigRuleId"] as? String {
            self.configRuleId = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [GetConfigRuleRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = GetConfigRuleRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
    }
}

public class GetConfigRuleShrinkRequest : Tea.TeaModel {
    public var configRuleId: String?

    public var tagShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configRuleId != nil {
            map["ConfigRuleId"] = self.configRuleId!
        }
        if self.tagShrink != nil {
            map["Tag"] = self.tagShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ConfigRuleId"] as? String {
            self.configRuleId = value
        }
        if let value = dict["Tag"] as? String {
            self.tagShrink = value
        }
    }
}

public class GetConfigRuleResponseBody : Tea.TeaModel {
    public class ConfigRule : Tea.TeaModel {
        public class Compliance : Tea.TeaModel {
            public var complianceType: String?

            public var count: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.complianceType != nil {
                    map["ComplianceType"] = self.complianceType!
                }
                if self.count != nil {
                    map["Count"] = self.count!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ComplianceType"] as? String {
                    self.complianceType = value
                }
                if let value = dict["Count"] as? Int32 {
                    self.count = value
                }
            }
        }
        public class ConfigRuleEvaluationStatus : Tea.TeaModel {
            public var firstActivatedTimestamp: Int64?

            public var firstEvaluationStarted: Bool?

            public var lastErrorCode: String?

            public var lastErrorMessage: String?

            public var lastFailedEvaluationTimestamp: Int64?

            public var lastFailedInvocationTimestamp: Int64?

            public var lastSuccessfulEvaluationTimestamp: Int64?

            public var lastSuccessfulInvocationTimestamp: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.firstActivatedTimestamp != nil {
                    map["FirstActivatedTimestamp"] = self.firstActivatedTimestamp!
                }
                if self.firstEvaluationStarted != nil {
                    map["FirstEvaluationStarted"] = self.firstEvaluationStarted!
                }
                if self.lastErrorCode != nil {
                    map["LastErrorCode"] = self.lastErrorCode!
                }
                if self.lastErrorMessage != nil {
                    map["LastErrorMessage"] = self.lastErrorMessage!
                }
                if self.lastFailedEvaluationTimestamp != nil {
                    map["LastFailedEvaluationTimestamp"] = self.lastFailedEvaluationTimestamp!
                }
                if self.lastFailedInvocationTimestamp != nil {
                    map["LastFailedInvocationTimestamp"] = self.lastFailedInvocationTimestamp!
                }
                if self.lastSuccessfulEvaluationTimestamp != nil {
                    map["LastSuccessfulEvaluationTimestamp"] = self.lastSuccessfulEvaluationTimestamp!
                }
                if self.lastSuccessfulInvocationTimestamp != nil {
                    map["LastSuccessfulInvocationTimestamp"] = self.lastSuccessfulInvocationTimestamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["FirstActivatedTimestamp"] as? Int64 {
                    self.firstActivatedTimestamp = value
                }
                if let value = dict["FirstEvaluationStarted"] as? Bool {
                    self.firstEvaluationStarted = value
                }
                if let value = dict["LastErrorCode"] as? String {
                    self.lastErrorCode = value
                }
                if let value = dict["LastErrorMessage"] as? String {
                    self.lastErrorMessage = value
                }
                if let value = dict["LastFailedEvaluationTimestamp"] as? Int64 {
                    self.lastFailedEvaluationTimestamp = value
                }
                if let value = dict["LastFailedInvocationTimestamp"] as? Int64 {
                    self.lastFailedInvocationTimestamp = value
                }
                if let value = dict["LastSuccessfulEvaluationTimestamp"] as? Int64 {
                    self.lastSuccessfulEvaluationTimestamp = value
                }
                if let value = dict["LastSuccessfulInvocationTimestamp"] as? Int64 {
                    self.lastSuccessfulInvocationTimestamp = value
                }
            }
        }
        public class CreateBy : Tea.TeaModel {
            public var compliancePackId: String?

            public var compliancePackName: String?

            public var creatorId: String?

            public var creatorName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.compliancePackId != nil {
                    map["CompliancePackId"] = self.compliancePackId!
                }
                if self.compliancePackName != nil {
                    map["CompliancePackName"] = self.compliancePackName!
                }
                if self.creatorId != nil {
                    map["CreatorId"] = self.creatorId!
                }
                if self.creatorName != nil {
                    map["CreatorName"] = self.creatorName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CompliancePackId"] as? String {
                    self.compliancePackId = value
                }
                if let value = dict["CompliancePackName"] as? String {
                    self.compliancePackName = value
                }
                if let value = dict["CreatorId"] as? String {
                    self.creatorId = value
                }
                if let value = dict["CreatorName"] as? String {
                    self.creatorName = value
                }
            }
        }
        public class ExcludeTagsScope : Tea.TeaModel {
            public var tagKey: String?

            public var tagValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.tagKey != nil {
                    map["TagKey"] = self.tagKey!
                }
                if self.tagValue != nil {
                    map["TagValue"] = self.tagValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["TagKey"] as? String {
                    self.tagKey = value
                }
                if let value = dict["TagValue"] as? String {
                    self.tagValue = value
                }
            }
        }
        public class ManagedRule : Tea.TeaModel {
            public class SourceDetails : Tea.TeaModel {
                public var eventSource: String?

                public var maximumExecutionFrequency: String?

                public var messageType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.eventSource != nil {
                        map["EventSource"] = self.eventSource!
                    }
                    if self.maximumExecutionFrequency != nil {
                        map["MaximumExecutionFrequency"] = self.maximumExecutionFrequency!
                    }
                    if self.messageType != nil {
                        map["MessageType"] = self.messageType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["EventSource"] as? String {
                        self.eventSource = value
                    }
                    if let value = dict["MaximumExecutionFrequency"] as? String {
                        self.maximumExecutionFrequency = value
                    }
                    if let value = dict["MessageType"] as? String {
                        self.messageType = value
                    }
                }
            }
            public var compulsoryInputParameterDetails: [String: Any]?

            public var description_: String?

            public var identifier: String?

            public var labels: [String]?

            public var managedRuleName: String?

            public var optionalInputParameterDetails: [String: Any]?

            public var sourceDetails: [GetConfigRuleResponseBody.ConfigRule.ManagedRule.SourceDetails]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.compulsoryInputParameterDetails != nil {
                    map["CompulsoryInputParameterDetails"] = self.compulsoryInputParameterDetails!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.identifier != nil {
                    map["Identifier"] = self.identifier!
                }
                if self.labels != nil {
                    map["Labels"] = self.labels!
                }
                if self.managedRuleName != nil {
                    map["ManagedRuleName"] = self.managedRuleName!
                }
                if self.optionalInputParameterDetails != nil {
                    map["OptionalInputParameterDetails"] = self.optionalInputParameterDetails!
                }
                if self.sourceDetails != nil {
                    var tmp : [Any] = []
                    for k in self.sourceDetails! {
                        tmp.append(k.toMap())
                    }
                    map["SourceDetails"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CompulsoryInputParameterDetails"] as? [String: Any] {
                    self.compulsoryInputParameterDetails = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["Identifier"] as? String {
                    self.identifier = value
                }
                if let value = dict["Labels"] as? [String] {
                    self.labels = value
                }
                if let value = dict["ManagedRuleName"] as? String {
                    self.managedRuleName = value
                }
                if let value = dict["OptionalInputParameterDetails"] as? [String: Any] {
                    self.optionalInputParameterDetails = value
                }
                if let value = dict["SourceDetails"] as? [Any?] {
                    var tmp : [GetConfigRuleResponseBody.ConfigRule.ManagedRule.SourceDetails] = []
                    for v in value {
                        if v != nil {
                            var model = GetConfigRuleResponseBody.ConfigRule.ManagedRule.SourceDetails()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.sourceDetails = tmp
                }
            }
        }
        public class Scope : Tea.TeaModel {
            public var complianceResourceTypes: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.complianceResourceTypes != nil {
                    map["ComplianceResourceTypes"] = self.complianceResourceTypes!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ComplianceResourceTypes"] as? [String] {
                    self.complianceResourceTypes = value
                }
            }
        }
        public class Source : Tea.TeaModel {
            public class SourceDetails : Tea.TeaModel {
                public var eventSource: String?

                public var maximumExecutionFrequency: String?

                public var messageType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.eventSource != nil {
                        map["EventSource"] = self.eventSource!
                    }
                    if self.maximumExecutionFrequency != nil {
                        map["MaximumExecutionFrequency"] = self.maximumExecutionFrequency!
                    }
                    if self.messageType != nil {
                        map["MessageType"] = self.messageType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["EventSource"] as? String {
                        self.eventSource = value
                    }
                    if let value = dict["MaximumExecutionFrequency"] as? String {
                        self.maximumExecutionFrequency = value
                    }
                    if let value = dict["MessageType"] as? String {
                        self.messageType = value
                    }
                }
            }
            public var identifier: String?

            public var owner: String?

            public var sourceDetails: [GetConfigRuleResponseBody.ConfigRule.Source.SourceDetails]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.identifier != nil {
                    map["Identifier"] = self.identifier!
                }
                if self.owner != nil {
                    map["Owner"] = self.owner!
                }
                if self.sourceDetails != nil {
                    var tmp : [Any] = []
                    for k in self.sourceDetails! {
                        tmp.append(k.toMap())
                    }
                    map["SourceDetails"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Identifier"] as? String {
                    self.identifier = value
                }
                if let value = dict["Owner"] as? String {
                    self.owner = value
                }
                if let value = dict["SourceDetails"] as? [Any?] {
                    var tmp : [GetConfigRuleResponseBody.ConfigRule.Source.SourceDetails] = []
                    for v in value {
                        if v != nil {
                            var model = GetConfigRuleResponseBody.ConfigRule.Source.SourceDetails()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.sourceDetails = tmp
                }
            }
        }
        public class Tags : Tea.TeaModel {
            public var tagKey: String?

            public var tagValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.tagKey != nil {
                    map["TagKey"] = self.tagKey!
                }
                if self.tagValue != nil {
                    map["TagValue"] = self.tagValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["TagKey"] as? String {
                    self.tagKey = value
                }
                if let value = dict["TagValue"] as? String {
                    self.tagValue = value
                }
            }
        }
        public class TagsScope : Tea.TeaModel {
            public var tagKey: String?

            public var tagValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.tagKey != nil {
                    map["TagKey"] = self.tagKey!
                }
                if self.tagValue != nil {
                    map["TagValue"] = self.tagValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["TagKey"] as? String {
                    self.tagKey = value
                }
                if let value = dict["TagValue"] as? String {
                    self.tagValue = value
                }
            }
        }
        public var accountId: Int64?

        public var compliance: GetConfigRuleResponseBody.ConfigRule.Compliance?

        public var configRuleArn: String?

        public var configRuleEvaluationStatus: GetConfigRuleResponseBody.ConfigRule.ConfigRuleEvaluationStatus?

        public var configRuleId: String?

        public var configRuleName: String?

        public var configRuleState: String?

        public var configRuleTriggerTypes: String?

        public var createBy: GetConfigRuleResponseBody.ConfigRule.CreateBy?

        public var createTimestamp: Int64?

        public var description_: String?

        public var excludeRegionIdsScope: String?

        public var excludeResourceGroupIdsScope: String?

        public var excludeResourceIdsScope: String?

        public var excludeTagsScope: [GetConfigRuleResponseBody.ConfigRule.ExcludeTagsScope]?

        public var extendContent: String?

        public var inputParameters: [String: Any]?

        public var managedRule: GetConfigRuleResponseBody.ConfigRule.ManagedRule?

        public var maximumExecutionFrequency: String?

        public var modifiedTimestamp: Int64?

        public var regionIdsScope: String?

        public var resourceGroupIdsScope: String?

        public var resourceIdsScope: String?

        public var resourceNameScope: String?

        public var resourceTypesScope: String?

        public var riskLevel: Int32?

        public var scope: GetConfigRuleResponseBody.ConfigRule.Scope?

        public var source: GetConfigRuleResponseBody.ConfigRule.Source?

        public var tagKeyLogicScope: String?

        public var tagKeyScope: String?

        public var tagValueScope: String?

        public var tags: [GetConfigRuleResponseBody.ConfigRule.Tags]?

        public var tagsScope: [GetConfigRuleResponseBody.ConfigRule.TagsScope]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.compliance?.validate()
            try self.configRuleEvaluationStatus?.validate()
            try self.createBy?.validate()
            try self.managedRule?.validate()
            try self.scope?.validate()
            try self.source?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["AccountId"] = self.accountId!
            }
            if self.compliance != nil {
                map["Compliance"] = self.compliance?.toMap()
            }
            if self.configRuleArn != nil {
                map["ConfigRuleArn"] = self.configRuleArn!
            }
            if self.configRuleEvaluationStatus != nil {
                map["ConfigRuleEvaluationStatus"] = self.configRuleEvaluationStatus?.toMap()
            }
            if self.configRuleId != nil {
                map["ConfigRuleId"] = self.configRuleId!
            }
            if self.configRuleName != nil {
                map["ConfigRuleName"] = self.configRuleName!
            }
            if self.configRuleState != nil {
                map["ConfigRuleState"] = self.configRuleState!
            }
            if self.configRuleTriggerTypes != nil {
                map["ConfigRuleTriggerTypes"] = self.configRuleTriggerTypes!
            }
            if self.createBy != nil {
                map["CreateBy"] = self.createBy?.toMap()
            }
            if self.createTimestamp != nil {
                map["CreateTimestamp"] = self.createTimestamp!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.excludeRegionIdsScope != nil {
                map["ExcludeRegionIdsScope"] = self.excludeRegionIdsScope!
            }
            if self.excludeResourceGroupIdsScope != nil {
                map["ExcludeResourceGroupIdsScope"] = self.excludeResourceGroupIdsScope!
            }
            if self.excludeResourceIdsScope != nil {
                map["ExcludeResourceIdsScope"] = self.excludeResourceIdsScope!
            }
            if self.excludeTagsScope != nil {
                var tmp : [Any] = []
                for k in self.excludeTagsScope! {
                    tmp.append(k.toMap())
                }
                map["ExcludeTagsScope"] = tmp
            }
            if self.extendContent != nil {
                map["ExtendContent"] = self.extendContent!
            }
            if self.inputParameters != nil {
                map["InputParameters"] = self.inputParameters!
            }
            if self.managedRule != nil {
                map["ManagedRule"] = self.managedRule?.toMap()
            }
            if self.maximumExecutionFrequency != nil {
                map["MaximumExecutionFrequency"] = self.maximumExecutionFrequency!
            }
            if self.modifiedTimestamp != nil {
                map["ModifiedTimestamp"] = self.modifiedTimestamp!
            }
            if self.regionIdsScope != nil {
                map["RegionIdsScope"] = self.regionIdsScope!
            }
            if self.resourceGroupIdsScope != nil {
                map["ResourceGroupIdsScope"] = self.resourceGroupIdsScope!
            }
            if self.resourceIdsScope != nil {
                map["ResourceIdsScope"] = self.resourceIdsScope!
            }
            if self.resourceNameScope != nil {
                map["ResourceNameScope"] = self.resourceNameScope!
            }
            if self.resourceTypesScope != nil {
                map["ResourceTypesScope"] = self.resourceTypesScope!
            }
            if self.riskLevel != nil {
                map["RiskLevel"] = self.riskLevel!
            }
            if self.scope != nil {
                map["Scope"] = self.scope?.toMap()
            }
            if self.source != nil {
                map["Source"] = self.source?.toMap()
            }
            if self.tagKeyLogicScope != nil {
                map["TagKeyLogicScope"] = self.tagKeyLogicScope!
            }
            if self.tagKeyScope != nil {
                map["TagKeyScope"] = self.tagKeyScope!
            }
            if self.tagValueScope != nil {
                map["TagValueScope"] = self.tagValueScope!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            if self.tagsScope != nil {
                var tmp : [Any] = []
                for k in self.tagsScope! {
                    tmp.append(k.toMap())
                }
                map["TagsScope"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AccountId"] as? Int64 {
                self.accountId = value
            }
            if let value = dict["Compliance"] as? [String: Any?] {
                var model = GetConfigRuleResponseBody.ConfigRule.Compliance()
                model.fromMap(value)
                self.compliance = model
            }
            if let value = dict["ConfigRuleArn"] as? String {
                self.configRuleArn = value
            }
            if let value = dict["ConfigRuleEvaluationStatus"] as? [String: Any?] {
                var model = GetConfigRuleResponseBody.ConfigRule.ConfigRuleEvaluationStatus()
                model.fromMap(value)
                self.configRuleEvaluationStatus = model
            }
            if let value = dict["ConfigRuleId"] as? String {
                self.configRuleId = value
            }
            if let value = dict["ConfigRuleName"] as? String {
                self.configRuleName = value
            }
            if let value = dict["ConfigRuleState"] as? String {
                self.configRuleState = value
            }
            if let value = dict["ConfigRuleTriggerTypes"] as? String {
                self.configRuleTriggerTypes = value
            }
            if let value = dict["CreateBy"] as? [String: Any?] {
                var model = GetConfigRuleResponseBody.ConfigRule.CreateBy()
                model.fromMap(value)
                self.createBy = model
            }
            if let value = dict["CreateTimestamp"] as? Int64 {
                self.createTimestamp = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["ExcludeRegionIdsScope"] as? String {
                self.excludeRegionIdsScope = value
            }
            if let value = dict["ExcludeResourceGroupIdsScope"] as? String {
                self.excludeResourceGroupIdsScope = value
            }
            if let value = dict["ExcludeResourceIdsScope"] as? String {
                self.excludeResourceIdsScope = value
            }
            if let value = dict["ExcludeTagsScope"] as? [Any?] {
                var tmp : [GetConfigRuleResponseBody.ConfigRule.ExcludeTagsScope] = []
                for v in value {
                    if v != nil {
                        var model = GetConfigRuleResponseBody.ConfigRule.ExcludeTagsScope()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.excludeTagsScope = tmp
            }
            if let value = dict["ExtendContent"] as? String {
                self.extendContent = value
            }
            if let value = dict["InputParameters"] as? [String: Any] {
                self.inputParameters = value
            }
            if let value = dict["ManagedRule"] as? [String: Any?] {
                var model = GetConfigRuleResponseBody.ConfigRule.ManagedRule()
                model.fromMap(value)
                self.managedRule = model
            }
            if let value = dict["MaximumExecutionFrequency"] as? String {
                self.maximumExecutionFrequency = value
            }
            if let value = dict["ModifiedTimestamp"] as? Int64 {
                self.modifiedTimestamp = value
            }
            if let value = dict["RegionIdsScope"] as? String {
                self.regionIdsScope = value
            }
            if let value = dict["ResourceGroupIdsScope"] as? String {
                self.resourceGroupIdsScope = value
            }
            if let value = dict["ResourceIdsScope"] as? String {
                self.resourceIdsScope = value
            }
            if let value = dict["ResourceNameScope"] as? String {
                self.resourceNameScope = value
            }
            if let value = dict["ResourceTypesScope"] as? String {
                self.resourceTypesScope = value
            }
            if let value = dict["RiskLevel"] as? Int32 {
                self.riskLevel = value
            }
            if let value = dict["Scope"] as? [String: Any?] {
                var model = GetConfigRuleResponseBody.ConfigRule.Scope()
                model.fromMap(value)
                self.scope = model
            }
            if let value = dict["Source"] as? [String: Any?] {
                var model = GetConfigRuleResponseBody.ConfigRule.Source()
                model.fromMap(value)
                self.source = model
            }
            if let value = dict["TagKeyLogicScope"] as? String {
                self.tagKeyLogicScope = value
            }
            if let value = dict["TagKeyScope"] as? String {
                self.tagKeyScope = value
            }
            if let value = dict["TagValueScope"] as? String {
                self.tagValueScope = value
            }
            if let value = dict["Tags"] as? [Any?] {
                var tmp : [GetConfigRuleResponseBody.ConfigRule.Tags] = []
                for v in value {
                    if v != nil {
                        var model = GetConfigRuleResponseBody.ConfigRule.Tags()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tags = tmp
            }
            if let value = dict["TagsScope"] as? [Any?] {
                var tmp : [GetConfigRuleResponseBody.ConfigRule.TagsScope] = []
                for v in value {
                    if v != nil {
                        var model = GetConfigRuleResponseBody.ConfigRule.TagsScope()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tagsScope = tmp
            }
        }
    }
    public var configRule: GetConfigRuleResponseBody.ConfigRule?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.configRule?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configRule != nil {
            map["ConfigRule"] = self.configRule?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ConfigRule"] as? [String: Any?] {
            var model = GetConfigRuleResponseBody.ConfigRule()
            model.fromMap(value)
            self.configRule = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetConfigRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetConfigRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetConfigRuleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetConfigRuleComplianceByPackRequest : Tea.TeaModel {
    public var compliancePackId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.compliancePackId != nil {
            map["CompliancePackId"] = self.compliancePackId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CompliancePackId"] as? String {
            self.compliancePackId = value
        }
    }
}

public class GetConfigRuleComplianceByPackResponseBody : Tea.TeaModel {
    public class ConfigRuleComplianceResult : Tea.TeaModel {
        public class ConfigRuleCompliances : Tea.TeaModel {
            public var complianceType: String?

            public var configRuleId: String?

            public var configRuleName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.complianceType != nil {
                    map["ComplianceType"] = self.complianceType!
                }
                if self.configRuleId != nil {
                    map["ConfigRuleId"] = self.configRuleId!
                }
                if self.configRuleName != nil {
                    map["ConfigRuleName"] = self.configRuleName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ComplianceType"] as? String {
                    self.complianceType = value
                }
                if let value = dict["ConfigRuleId"] as? String {
                    self.configRuleId = value
                }
                if let value = dict["ConfigRuleName"] as? String {
                    self.configRuleName = value
                }
            }
        }
        public var compliancePackId: String?

        public var configRuleCompliances: [GetConfigRuleComplianceByPackResponseBody.ConfigRuleComplianceResult.ConfigRuleCompliances]?

        public var nonCompliantCount: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.compliancePackId != nil {
                map["CompliancePackId"] = self.compliancePackId!
            }
            if self.configRuleCompliances != nil {
                var tmp : [Any] = []
                for k in self.configRuleCompliances! {
                    tmp.append(k.toMap())
                }
                map["ConfigRuleCompliances"] = tmp
            }
            if self.nonCompliantCount != nil {
                map["NonCompliantCount"] = self.nonCompliantCount!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CompliancePackId"] as? String {
                self.compliancePackId = value
            }
            if let value = dict["ConfigRuleCompliances"] as? [Any?] {
                var tmp : [GetConfigRuleComplianceByPackResponseBody.ConfigRuleComplianceResult.ConfigRuleCompliances] = []
                for v in value {
                    if v != nil {
                        var model = GetConfigRuleComplianceByPackResponseBody.ConfigRuleComplianceResult.ConfigRuleCompliances()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.configRuleCompliances = tmp
            }
            if let value = dict["NonCompliantCount"] as? Int32 {
                self.nonCompliantCount = value
            }
            if let value = dict["TotalCount"] as? Int32 {
                self.totalCount = value
            }
        }
    }
    public var configRuleComplianceResult: GetConfigRuleComplianceByPackResponseBody.ConfigRuleComplianceResult?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.configRuleComplianceResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configRuleComplianceResult != nil {
            map["ConfigRuleComplianceResult"] = self.configRuleComplianceResult?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ConfigRuleComplianceResult"] as? [String: Any?] {
            var model = GetConfigRuleComplianceByPackResponseBody.ConfigRuleComplianceResult()
            model.fromMap(value)
            self.configRuleComplianceResult = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetConfigRuleComplianceByPackResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetConfigRuleComplianceByPackResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetConfigRuleComplianceByPackResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetConfigRuleSummaryByRiskLevelResponseBody : Tea.TeaModel {
    public class ConfigRuleSummaries : Tea.TeaModel {
        public var compliantCount: Int32?

        public var nonCompliantCount: Int32?

        public var riskLevel: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.compliantCount != nil {
                map["CompliantCount"] = self.compliantCount!
            }
            if self.nonCompliantCount != nil {
                map["NonCompliantCount"] = self.nonCompliantCount!
            }
            if self.riskLevel != nil {
                map["RiskLevel"] = self.riskLevel!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CompliantCount"] as? Int32 {
                self.compliantCount = value
            }
            if let value = dict["NonCompliantCount"] as? Int32 {
                self.nonCompliantCount = value
            }
            if let value = dict["RiskLevel"] as? Int32 {
                self.riskLevel = value
            }
        }
    }
    public var configRuleSummaries: [GetConfigRuleSummaryByRiskLevelResponseBody.ConfigRuleSummaries]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configRuleSummaries != nil {
            var tmp : [Any] = []
            for k in self.configRuleSummaries! {
                tmp.append(k.toMap())
            }
            map["ConfigRuleSummaries"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ConfigRuleSummaries"] as? [Any?] {
            var tmp : [GetConfigRuleSummaryByRiskLevelResponseBody.ConfigRuleSummaries] = []
            for v in value {
                if v != nil {
                    var model = GetConfigRuleSummaryByRiskLevelResponseBody.ConfigRuleSummaries()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.configRuleSummaries = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetConfigRuleSummaryByRiskLevelResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetConfigRuleSummaryByRiskLevelResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetConfigRuleSummaryByRiskLevelResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetConfigRulesReportRequest : Tea.TeaModel {
    public var reportId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.reportId != nil {
            map["ReportId"] = self.reportId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ReportId"] as? String {
            self.reportId = value
        }
    }
}

public class GetConfigRulesReportResponseBody : Tea.TeaModel {
    public class ConfigRulesReport : Tea.TeaModel {
        public var accountId: Int64?

        public var reportCreateTimestamp: Int64?

        public var reportId: String?

        public var reportStatus: String?

        public var reportUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["AccountId"] = self.accountId!
            }
            if self.reportCreateTimestamp != nil {
                map["ReportCreateTimestamp"] = self.reportCreateTimestamp!
            }
            if self.reportId != nil {
                map["ReportId"] = self.reportId!
            }
            if self.reportStatus != nil {
                map["ReportStatus"] = self.reportStatus!
            }
            if self.reportUrl != nil {
                map["ReportUrl"] = self.reportUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AccountId"] as? Int64 {
                self.accountId = value
            }
            if let value = dict["ReportCreateTimestamp"] as? Int64 {
                self.reportCreateTimestamp = value
            }
            if let value = dict["ReportId"] as? String {
                self.reportId = value
            }
            if let value = dict["ReportStatus"] as? String {
                self.reportStatus = value
            }
            if let value = dict["ReportUrl"] as? String {
                self.reportUrl = value
            }
        }
    }
    public var configRulesReport: GetConfigRulesReportResponseBody.ConfigRulesReport?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.configRulesReport?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configRulesReport != nil {
            map["ConfigRulesReport"] = self.configRulesReport?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ConfigRulesReport"] as? [String: Any?] {
            var model = GetConfigRulesReportResponseBody.ConfigRulesReport()
            model.fromMap(value)
            self.configRulesReport = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetConfigRulesReportResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetConfigRulesReportResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetConfigRulesReportResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetConfigurationRecorderResponseBody : Tea.TeaModel {
    public class ConfigurationRecorder : Tea.TeaModel {
        public var configurationRecorderStatus: String?

        public var resourceTypes: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.configurationRecorderStatus != nil {
                map["ConfigurationRecorderStatus"] = self.configurationRecorderStatus!
            }
            if self.resourceTypes != nil {
                map["ResourceTypes"] = self.resourceTypes!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ConfigurationRecorderStatus"] as? String {
                self.configurationRecorderStatus = value
            }
            if let value = dict["ResourceTypes"] as? [String] {
                self.resourceTypes = value
            }
        }
    }
    public var configurationRecorder: GetConfigurationRecorderResponseBody.ConfigurationRecorder?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.configurationRecorder?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configurationRecorder != nil {
            map["ConfigurationRecorder"] = self.configurationRecorder?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ConfigurationRecorder"] as? [String: Any?] {
            var model = GetConfigurationRecorderResponseBody.ConfigurationRecorder()
            model.fromMap(value)
            self.configurationRecorder = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetConfigurationRecorderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetConfigurationRecorderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetConfigurationRecorderResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetDiscoveredResourceRequest : Tea.TeaModel {
    public var complianceOption: Int32?

    public var region: String?

    public var resourceId: String?

    public var resourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.complianceOption != nil {
            map["ComplianceOption"] = self.complianceOption!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ComplianceOption"] as? Int32 {
            self.complianceOption = value
        }
        if let value = dict["Region"] as? String {
            self.region = value
        }
        if let value = dict["ResourceId"] as? String {
            self.resourceId = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
    }
}

public class GetDiscoveredResourceResponseBody : Tea.TeaModel {
    public class DiscoveredResourceDetail : Tea.TeaModel {
        public var accountId: Int64?

        public var availabilityZone: String?

        public var complianceType: String?

        public var configuration: String?

        public var region: String?

        public var resourceCreationTime: Int64?

        public var resourceDeleted: Int32?

        public var resourceId: String?

        public var resourceName: String?

        public var resourceStatus: String?

        public var resourceType: String?

        public var tags: String?

        public var vSwitchId: String?

        public var vpcId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["AccountId"] = self.accountId!
            }
            if self.availabilityZone != nil {
                map["AvailabilityZone"] = self.availabilityZone!
            }
            if self.complianceType != nil {
                map["ComplianceType"] = self.complianceType!
            }
            if self.configuration != nil {
                map["Configuration"] = self.configuration!
            }
            if self.region != nil {
                map["Region"] = self.region!
            }
            if self.resourceCreationTime != nil {
                map["ResourceCreationTime"] = self.resourceCreationTime!
            }
            if self.resourceDeleted != nil {
                map["ResourceDeleted"] = self.resourceDeleted!
            }
            if self.resourceId != nil {
                map["ResourceId"] = self.resourceId!
            }
            if self.resourceName != nil {
                map["ResourceName"] = self.resourceName!
            }
            if self.resourceStatus != nil {
                map["ResourceStatus"] = self.resourceStatus!
            }
            if self.resourceType != nil {
                map["ResourceType"] = self.resourceType!
            }
            if self.tags != nil {
                map["Tags"] = self.tags!
            }
            if self.vSwitchId != nil {
                map["VSwitchId"] = self.vSwitchId!
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AccountId"] as? Int64 {
                self.accountId = value
            }
            if let value = dict["AvailabilityZone"] as? String {
                self.availabilityZone = value
            }
            if let value = dict["ComplianceType"] as? String {
                self.complianceType = value
            }
            if let value = dict["Configuration"] as? String {
                self.configuration = value
            }
            if let value = dict["Region"] as? String {
                self.region = value
            }
            if let value = dict["ResourceCreationTime"] as? Int64 {
                self.resourceCreationTime = value
            }
            if let value = dict["ResourceDeleted"] as? Int32 {
                self.resourceDeleted = value
            }
            if let value = dict["ResourceId"] as? String {
                self.resourceId = value
            }
            if let value = dict["ResourceName"] as? String {
                self.resourceName = value
            }
            if let value = dict["ResourceStatus"] as? String {
                self.resourceStatus = value
            }
            if let value = dict["ResourceType"] as? String {
                self.resourceType = value
            }
            if let value = dict["Tags"] as? String {
                self.tags = value
            }
            if let value = dict["VSwitchId"] as? String {
                self.vSwitchId = value
            }
            if let value = dict["VpcId"] as? String {
                self.vpcId = value
            }
        }
    }
    public var discoveredResourceDetail: GetDiscoveredResourceResponseBody.DiscoveredResourceDetail?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.discoveredResourceDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.discoveredResourceDetail != nil {
            map["DiscoveredResourceDetail"] = self.discoveredResourceDetail?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DiscoveredResourceDetail"] as? [String: Any?] {
            var model = GetDiscoveredResourceResponseBody.DiscoveredResourceDetail()
            model.fromMap(value)
            self.discoveredResourceDetail = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetDiscoveredResourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDiscoveredResourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetDiscoveredResourceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetDiscoveredResourceCountsGroupByRegionRequest : Tea.TeaModel {
    public var resourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
    }
}

public class GetDiscoveredResourceCountsGroupByRegionResponseBody : Tea.TeaModel {
    public class DiscoveredResourceCountsSummary : Tea.TeaModel {
        public var groupName: String?

        public var region: String?

        public var resourceCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.groupName != nil {
                map["GroupName"] = self.groupName!
            }
            if self.region != nil {
                map["Region"] = self.region!
            }
            if self.resourceCount != nil {
                map["ResourceCount"] = self.resourceCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["GroupName"] as? String {
                self.groupName = value
            }
            if let value = dict["Region"] as? String {
                self.region = value
            }
            if let value = dict["ResourceCount"] as? Int64 {
                self.resourceCount = value
            }
        }
    }
    public var discoveredResourceCountsSummary: [GetDiscoveredResourceCountsGroupByRegionResponseBody.DiscoveredResourceCountsSummary]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.discoveredResourceCountsSummary != nil {
            var tmp : [Any] = []
            for k in self.discoveredResourceCountsSummary! {
                tmp.append(k.toMap())
            }
            map["DiscoveredResourceCountsSummary"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DiscoveredResourceCountsSummary"] as? [Any?] {
            var tmp : [GetDiscoveredResourceCountsGroupByRegionResponseBody.DiscoveredResourceCountsSummary] = []
            for v in value {
                if v != nil {
                    var model = GetDiscoveredResourceCountsGroupByRegionResponseBody.DiscoveredResourceCountsSummary()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.discoveredResourceCountsSummary = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetDiscoveredResourceCountsGroupByRegionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDiscoveredResourceCountsGroupByRegionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetDiscoveredResourceCountsGroupByRegionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetDiscoveredResourceCountsGroupByResourceTypeRequest : Tea.TeaModel {
    public var region: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.region != nil {
            map["Region"] = self.region!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Region"] as? String {
            self.region = value
        }
    }
}

public class GetDiscoveredResourceCountsGroupByResourceTypeResponseBody : Tea.TeaModel {
    public class DiscoveredResourceCountsSummary : Tea.TeaModel {
        public var groupName: String?

        public var resourceCount: Int64?

        public var resourceType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.groupName != nil {
                map["GroupName"] = self.groupName!
            }
            if self.resourceCount != nil {
                map["ResourceCount"] = self.resourceCount!
            }
            if self.resourceType != nil {
                map["ResourceType"] = self.resourceType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["GroupName"] as? String {
                self.groupName = value
            }
            if let value = dict["ResourceCount"] as? Int64 {
                self.resourceCount = value
            }
            if let value = dict["ResourceType"] as? String {
                self.resourceType = value
            }
        }
    }
    public var discoveredResourceCountsSummary: [GetDiscoveredResourceCountsGroupByResourceTypeResponseBody.DiscoveredResourceCountsSummary]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.discoveredResourceCountsSummary != nil {
            var tmp : [Any] = []
            for k in self.discoveredResourceCountsSummary! {
                tmp.append(k.toMap())
            }
            map["DiscoveredResourceCountsSummary"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DiscoveredResourceCountsSummary"] as? [Any?] {
            var tmp : [GetDiscoveredResourceCountsGroupByResourceTypeResponseBody.DiscoveredResourceCountsSummary] = []
            for v in value {
                if v != nil {
                    var model = GetDiscoveredResourceCountsGroupByResourceTypeResponseBody.DiscoveredResourceCountsSummary()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.discoveredResourceCountsSummary = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetDiscoveredResourceCountsGroupByResourceTypeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDiscoveredResourceCountsGroupByResourceTypeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetDiscoveredResourceCountsGroupByResourceTypeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetIntegratedServiceStatusRequest : Tea.TeaModel {
    public var serviceCode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.serviceCode != nil {
            map["ServiceCode"] = self.serviceCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ServiceCode"] as? String {
            self.serviceCode = value
        }
    }
}

public class GetIntegratedServiceStatusResponseBody : Tea.TeaModel {
    public var aggregatorDeliveryDataType: String?

    public var data: Bool?

    public var integratedTypes: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aggregatorDeliveryDataType != nil {
            map["AggregatorDeliveryDataType"] = self.aggregatorDeliveryDataType!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.integratedTypes != nil {
            map["IntegratedTypes"] = self.integratedTypes!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AggregatorDeliveryDataType"] as? String {
            self.aggregatorDeliveryDataType = value
        }
        if let value = dict["Data"] as? Bool {
            self.data = value
        }
        if let value = dict["IntegratedTypes"] as? String {
            self.integratedTypes = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetIntegratedServiceStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetIntegratedServiceStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetIntegratedServiceStatusResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetManagedRuleRequest : Tea.TeaModel {
    public var identifier: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.identifier != nil {
            map["Identifier"] = self.identifier!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Identifier"] as? String {
            self.identifier = value
        }
    }
}

public class GetManagedRuleResponseBody : Tea.TeaModel {
    public class ManagedRule : Tea.TeaModel {
        public class Scope : Tea.TeaModel {
            public var complianceResourceTypes: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.complianceResourceTypes != nil {
                    map["ComplianceResourceTypes"] = self.complianceResourceTypes!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ComplianceResourceTypes"] as? [String] {
                    self.complianceResourceTypes = value
                }
            }
        }
        public class SourceDetails : Tea.TeaModel {
            public var maximumExecutionFrequency: String?

            public var messageType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.maximumExecutionFrequency != nil {
                    map["MaximumExecutionFrequency"] = self.maximumExecutionFrequency!
                }
                if self.messageType != nil {
                    map["MessageType"] = self.messageType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["MaximumExecutionFrequency"] as? String {
                    self.maximumExecutionFrequency = value
                }
                if let value = dict["MessageType"] as? String {
                    self.messageType = value
                }
            }
        }
        public var compulsoryInputParameterDetails: [String: Any]?

        public var configRuleName: String?

        public var description_: String?

        public var helpUrls: String?

        public var identifier: String?

        public var labels: [String]?

        public var optionalInputParameterDetails: [String: Any]?

        public var riskLevel: Int32?

        public var scope: GetManagedRuleResponseBody.ManagedRule.Scope?

        public var sourceDetails: [GetManagedRuleResponseBody.ManagedRule.SourceDetails]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.scope?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.compulsoryInputParameterDetails != nil {
                map["CompulsoryInputParameterDetails"] = self.compulsoryInputParameterDetails!
            }
            if self.configRuleName != nil {
                map["ConfigRuleName"] = self.configRuleName!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.helpUrls != nil {
                map["HelpUrls"] = self.helpUrls!
            }
            if self.identifier != nil {
                map["Identifier"] = self.identifier!
            }
            if self.labels != nil {
                map["Labels"] = self.labels!
            }
            if self.optionalInputParameterDetails != nil {
                map["OptionalInputParameterDetails"] = self.optionalInputParameterDetails!
            }
            if self.riskLevel != nil {
                map["RiskLevel"] = self.riskLevel!
            }
            if self.scope != nil {
                map["Scope"] = self.scope?.toMap()
            }
            if self.sourceDetails != nil {
                var tmp : [Any] = []
                for k in self.sourceDetails! {
                    tmp.append(k.toMap())
                }
                map["SourceDetails"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CompulsoryInputParameterDetails"] as? [String: Any] {
                self.compulsoryInputParameterDetails = value
            }
            if let value = dict["ConfigRuleName"] as? String {
                self.configRuleName = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["HelpUrls"] as? String {
                self.helpUrls = value
            }
            if let value = dict["Identifier"] as? String {
                self.identifier = value
            }
            if let value = dict["Labels"] as? [String] {
                self.labels = value
            }
            if let value = dict["OptionalInputParameterDetails"] as? [String: Any] {
                self.optionalInputParameterDetails = value
            }
            if let value = dict["RiskLevel"] as? Int32 {
                self.riskLevel = value
            }
            if let value = dict["Scope"] as? [String: Any?] {
                var model = GetManagedRuleResponseBody.ManagedRule.Scope()
                model.fromMap(value)
                self.scope = model
            }
            if let value = dict["SourceDetails"] as? [Any?] {
                var tmp : [GetManagedRuleResponseBody.ManagedRule.SourceDetails] = []
                for v in value {
                    if v != nil {
                        var model = GetManagedRuleResponseBody.ManagedRule.SourceDetails()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.sourceDetails = tmp
            }
        }
    }
    public var managedRule: GetManagedRuleResponseBody.ManagedRule?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.managedRule?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.managedRule != nil {
            map["ManagedRule"] = self.managedRule?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ManagedRule"] as? [String: Any?] {
            var model = GetManagedRuleResponseBody.ManagedRule()
            model.fromMap(value)
            self.managedRule = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetManagedRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetManagedRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetManagedRuleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetRemediationTemplateRequest : Tea.TeaModel {
    public var templateIdentifier: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.templateIdentifier != nil {
            map["TemplateIdentifier"] = self.templateIdentifier!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["TemplateIdentifier"] as? String {
            self.templateIdentifier = value
        }
    }
}

public class GetRemediationTemplateResponseBody : Tea.TeaModel {
    public class RemediationTemplates : Tea.TeaModel {
        public var managedRuleIdentifier: String?

        public var remediationType: String?

        public var templateDefinition: String?

        public var templateDescription: String?

        public var templateIdentifier: String?

        public var templateName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.managedRuleIdentifier != nil {
                map["ManagedRuleIdentifier"] = self.managedRuleIdentifier!
            }
            if self.remediationType != nil {
                map["RemediationType"] = self.remediationType!
            }
            if self.templateDefinition != nil {
                map["TemplateDefinition"] = self.templateDefinition!
            }
            if self.templateDescription != nil {
                map["TemplateDescription"] = self.templateDescription!
            }
            if self.templateIdentifier != nil {
                map["TemplateIdentifier"] = self.templateIdentifier!
            }
            if self.templateName != nil {
                map["TemplateName"] = self.templateName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ManagedRuleIdentifier"] as? String {
                self.managedRuleIdentifier = value
            }
            if let value = dict["RemediationType"] as? String {
                self.remediationType = value
            }
            if let value = dict["TemplateDefinition"] as? String {
                self.templateDefinition = value
            }
            if let value = dict["TemplateDescription"] as? String {
                self.templateDescription = value
            }
            if let value = dict["TemplateIdentifier"] as? String {
                self.templateIdentifier = value
            }
            if let value = dict["TemplateName"] as? String {
                self.templateName = value
            }
        }
    }
    public var remediationTemplates: [GetRemediationTemplateResponseBody.RemediationTemplates]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.remediationTemplates != nil {
            var tmp : [Any] = []
            for k in self.remediationTemplates! {
                tmp.append(k.toMap())
            }
            map["RemediationTemplates"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RemediationTemplates"] as? [Any?] {
            var tmp : [GetRemediationTemplateResponseBody.RemediationTemplates] = []
            for v in value {
                if v != nil {
                    var model = GetRemediationTemplateResponseBody.RemediationTemplates()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.remediationTemplates = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetRemediationTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetRemediationTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetRemediationTemplateResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetResourceComplianceByConfigRuleRequest : Tea.TeaModel {
    public var complianceType: String?

    public var configRuleId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.complianceType != nil {
            map["ComplianceType"] = self.complianceType!
        }
        if self.configRuleId != nil {
            map["ConfigRuleId"] = self.configRuleId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ComplianceType"] as? String {
            self.complianceType = value
        }
        if let value = dict["ConfigRuleId"] as? String {
            self.configRuleId = value
        }
    }
}

public class GetResourceComplianceByConfigRuleResponseBody : Tea.TeaModel {
    public class ComplianceResult : Tea.TeaModel {
        public class Compliances : Tea.TeaModel {
            public var complianceType: String?

            public var count: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.complianceType != nil {
                    map["ComplianceType"] = self.complianceType!
                }
                if self.count != nil {
                    map["Count"] = self.count!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ComplianceType"] as? String {
                    self.complianceType = value
                }
                if let value = dict["Count"] as? Int32 {
                    self.count = value
                }
            }
        }
        public var compliances: [GetResourceComplianceByConfigRuleResponseBody.ComplianceResult.Compliances]?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.compliances != nil {
                var tmp : [Any] = []
                for k in self.compliances! {
                    tmp.append(k.toMap())
                }
                map["Compliances"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Compliances"] as? [Any?] {
                var tmp : [GetResourceComplianceByConfigRuleResponseBody.ComplianceResult.Compliances] = []
                for v in value {
                    if v != nil {
                        var model = GetResourceComplianceByConfigRuleResponseBody.ComplianceResult.Compliances()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.compliances = tmp
            }
            if let value = dict["TotalCount"] as? Int64 {
                self.totalCount = value
            }
        }
    }
    public var complianceResult: GetResourceComplianceByConfigRuleResponseBody.ComplianceResult?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.complianceResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.complianceResult != nil {
            map["ComplianceResult"] = self.complianceResult?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ComplianceResult"] as? [String: Any?] {
            var model = GetResourceComplianceByConfigRuleResponseBody.ComplianceResult()
            model.fromMap(value)
            self.complianceResult = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetResourceComplianceByConfigRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetResourceComplianceByConfigRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetResourceComplianceByConfigRuleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetResourceComplianceByPackRequest : Tea.TeaModel {
    public var compliancePackId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.compliancePackId != nil {
            map["CompliancePackId"] = self.compliancePackId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CompliancePackId"] as? String {
            self.compliancePackId = value
        }
    }
}

public class GetResourceComplianceByPackResponseBody : Tea.TeaModel {
    public class ResourceComplianceResult : Tea.TeaModel {
        public var compliancePackId: String?

        public var nonCompliantCount: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.compliancePackId != nil {
                map["CompliancePackId"] = self.compliancePackId!
            }
            if self.nonCompliantCount != nil {
                map["NonCompliantCount"] = self.nonCompliantCount!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CompliancePackId"] as? String {
                self.compliancePackId = value
            }
            if let value = dict["NonCompliantCount"] as? Int32 {
                self.nonCompliantCount = value
            }
            if let value = dict["TotalCount"] as? Int32 {
                self.totalCount = value
            }
        }
    }
    public var requestId: String?

    public var resourceComplianceResult: GetResourceComplianceByPackResponseBody.ResourceComplianceResult?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resourceComplianceResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceComplianceResult != nil {
            map["ResourceComplianceResult"] = self.resourceComplianceResult?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ResourceComplianceResult"] as? [String: Any?] {
            var model = GetResourceComplianceByPackResponseBody.ResourceComplianceResult()
            model.fromMap(value)
            self.resourceComplianceResult = model
        }
    }
}

public class GetResourceComplianceByPackResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetResourceComplianceByPackResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetResourceComplianceByPackResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetResourceComplianceGroupByRegionRequest : Tea.TeaModel {
    public var configRuleIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configRuleIds != nil {
            map["ConfigRuleIds"] = self.configRuleIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ConfigRuleIds"] as? String {
            self.configRuleIds = value
        }
    }
}

public class GetResourceComplianceGroupByRegionResponseBody : Tea.TeaModel {
    public class ComplianceResult : Tea.TeaModel {
        public class ComplianceResultList : Tea.TeaModel {
            public class Compliances : Tea.TeaModel {
                public var complianceType: String?

                public var count: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.complianceType != nil {
                        map["ComplianceType"] = self.complianceType!
                    }
                    if self.count != nil {
                        map["Count"] = self.count!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ComplianceType"] as? String {
                        self.complianceType = value
                    }
                    if let value = dict["Count"] as? Int64 {
                        self.count = value
                    }
                }
            }
            public var compliances: [GetResourceComplianceGroupByRegionResponseBody.ComplianceResult.ComplianceResultList.Compliances]?

            public var regionId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.compliances != nil {
                    var tmp : [Any] = []
                    for k in self.compliances! {
                        tmp.append(k.toMap())
                    }
                    map["Compliances"] = tmp
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Compliances"] as? [Any?] {
                    var tmp : [GetResourceComplianceGroupByRegionResponseBody.ComplianceResult.ComplianceResultList.Compliances] = []
                    for v in value {
                        if v != nil {
                            var model = GetResourceComplianceGroupByRegionResponseBody.ComplianceResult.ComplianceResultList.Compliances()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.compliances = tmp
                }
                if let value = dict["RegionId"] as? String {
                    self.regionId = value
                }
            }
        }
        public var complianceResultList: [GetResourceComplianceGroupByRegionResponseBody.ComplianceResult.ComplianceResultList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.complianceResultList != nil {
                var tmp : [Any] = []
                for k in self.complianceResultList! {
                    tmp.append(k.toMap())
                }
                map["ComplianceResultList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ComplianceResultList"] as? [Any?] {
                var tmp : [GetResourceComplianceGroupByRegionResponseBody.ComplianceResult.ComplianceResultList] = []
                for v in value {
                    if v != nil {
                        var model = GetResourceComplianceGroupByRegionResponseBody.ComplianceResult.ComplianceResultList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.complianceResultList = tmp
            }
        }
    }
    public var complianceResult: GetResourceComplianceGroupByRegionResponseBody.ComplianceResult?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.complianceResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.complianceResult != nil {
            map["ComplianceResult"] = self.complianceResult?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ComplianceResult"] as? [String: Any?] {
            var model = GetResourceComplianceGroupByRegionResponseBody.ComplianceResult()
            model.fromMap(value)
            self.complianceResult = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetResourceComplianceGroupByRegionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetResourceComplianceGroupByRegionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetResourceComplianceGroupByRegionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetResourceComplianceGroupByResourceTypeRequest : Tea.TeaModel {
    public var configRuleIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configRuleIds != nil {
            map["ConfigRuleIds"] = self.configRuleIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ConfigRuleIds"] as? String {
            self.configRuleIds = value
        }
    }
}

public class GetResourceComplianceGroupByResourceTypeResponseBody : Tea.TeaModel {
    public class ComplianceResult : Tea.TeaModel {
        public class ComplianceResultList : Tea.TeaModel {
            public class Compliances : Tea.TeaModel {
                public var complianceType: String?

                public var count: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.complianceType != nil {
                        map["ComplianceType"] = self.complianceType!
                    }
                    if self.count != nil {
                        map["Count"] = self.count!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ComplianceType"] as? String {
                        self.complianceType = value
                    }
                    if let value = dict["Count"] as? Int64 {
                        self.count = value
                    }
                }
            }
            public var compliances: [GetResourceComplianceGroupByResourceTypeResponseBody.ComplianceResult.ComplianceResultList.Compliances]?

            public var resourceType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.compliances != nil {
                    var tmp : [Any] = []
                    for k in self.compliances! {
                        tmp.append(k.toMap())
                    }
                    map["Compliances"] = tmp
                }
                if self.resourceType != nil {
                    map["ResourceType"] = self.resourceType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Compliances"] as? [Any?] {
                    var tmp : [GetResourceComplianceGroupByResourceTypeResponseBody.ComplianceResult.ComplianceResultList.Compliances] = []
                    for v in value {
                        if v != nil {
                            var model = GetResourceComplianceGroupByResourceTypeResponseBody.ComplianceResult.ComplianceResultList.Compliances()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.compliances = tmp
                }
                if let value = dict["ResourceType"] as? String {
                    self.resourceType = value
                }
            }
        }
        public var complianceResultList: [GetResourceComplianceGroupByResourceTypeResponseBody.ComplianceResult.ComplianceResultList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.complianceResultList != nil {
                var tmp : [Any] = []
                for k in self.complianceResultList! {
                    tmp.append(k.toMap())
                }
                map["ComplianceResultList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ComplianceResultList"] as? [Any?] {
                var tmp : [GetResourceComplianceGroupByResourceTypeResponseBody.ComplianceResult.ComplianceResultList] = []
                for v in value {
                    if v != nil {
                        var model = GetResourceComplianceGroupByResourceTypeResponseBody.ComplianceResult.ComplianceResultList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.complianceResultList = tmp
            }
        }
    }
    public var complianceResult: GetResourceComplianceGroupByResourceTypeResponseBody.ComplianceResult?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.complianceResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.complianceResult != nil {
            map["ComplianceResult"] = self.complianceResult?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ComplianceResult"] as? [String: Any?] {
            var model = GetResourceComplianceGroupByResourceTypeResponseBody.ComplianceResult()
            model.fromMap(value)
            self.complianceResult = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetResourceComplianceGroupByResourceTypeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetResourceComplianceGroupByResourceTypeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetResourceComplianceGroupByResourceTypeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetResourceComplianceTimelineRequest : Tea.TeaModel {
    public var endTime: Int64?

    public var maxResults: Int32?

    public var nextToken: String?

    public var region: String?

    public var resourceId: String?

    public var resourceType: String?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EndTime"] as? Int64 {
            self.endTime = value
        }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["Region"] as? String {
            self.region = value
        }
        if let value = dict["ResourceId"] as? String {
            self.resourceId = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
        if let value = dict["StartTime"] as? Int64 {
            self.startTime = value
        }
    }
}

public class GetResourceComplianceTimelineResponseBody : Tea.TeaModel {
    public class ResourceComplianceTimeline : Tea.TeaModel {
        public class ComplianceList : Tea.TeaModel {
            public var accountId: String?

            public var availabilityZone: String?

            public var captureTime: Int64?

            public var configuration: String?

            public var configurationDiff: String?

            public var region: String?

            public var resourceCreateTime: Int64?

            public var resourceId: String?

            public var resourceName: String?

            public var resourceStatus: String?

            public var resourceType: String?

            public var tags: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.accountId != nil {
                    map["AccountId"] = self.accountId!
                }
                if self.availabilityZone != nil {
                    map["AvailabilityZone"] = self.availabilityZone!
                }
                if self.captureTime != nil {
                    map["CaptureTime"] = self.captureTime!
                }
                if self.configuration != nil {
                    map["Configuration"] = self.configuration!
                }
                if self.configurationDiff != nil {
                    map["ConfigurationDiff"] = self.configurationDiff!
                }
                if self.region != nil {
                    map["Region"] = self.region!
                }
                if self.resourceCreateTime != nil {
                    map["ResourceCreateTime"] = self.resourceCreateTime!
                }
                if self.resourceId != nil {
                    map["ResourceId"] = self.resourceId!
                }
                if self.resourceName != nil {
                    map["ResourceName"] = self.resourceName!
                }
                if self.resourceStatus != nil {
                    map["ResourceStatus"] = self.resourceStatus!
                }
                if self.resourceType != nil {
                    map["ResourceType"] = self.resourceType!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AccountId"] as? String {
                    self.accountId = value
                }
                if let value = dict["AvailabilityZone"] as? String {
                    self.availabilityZone = value
                }
                if let value = dict["CaptureTime"] as? Int64 {
                    self.captureTime = value
                }
                if let value = dict["Configuration"] as? String {
                    self.configuration = value
                }
                if let value = dict["ConfigurationDiff"] as? String {
                    self.configurationDiff = value
                }
                if let value = dict["Region"] as? String {
                    self.region = value
                }
                if let value = dict["ResourceCreateTime"] as? Int64 {
                    self.resourceCreateTime = value
                }
                if let value = dict["ResourceId"] as? String {
                    self.resourceId = value
                }
                if let value = dict["ResourceName"] as? String {
                    self.resourceName = value
                }
                if let value = dict["ResourceStatus"] as? String {
                    self.resourceStatus = value
                }
                if let value = dict["ResourceType"] as? String {
                    self.resourceType = value
                }
                if let value = dict["Tags"] as? String {
                    self.tags = value
                }
            }
        }
        public var complianceList: [GetResourceComplianceTimelineResponseBody.ResourceComplianceTimeline.ComplianceList]?

        public var maxResults: Int32?

        public var nextToken: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.complianceList != nil {
                var tmp : [Any] = []
                for k in self.complianceList! {
                    tmp.append(k.toMap())
                }
                map["ComplianceList"] = tmp
            }
            if self.maxResults != nil {
                map["MaxResults"] = self.maxResults!
            }
            if self.nextToken != nil {
                map["NextToken"] = self.nextToken!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ComplianceList"] as? [Any?] {
                var tmp : [GetResourceComplianceTimelineResponseBody.ResourceComplianceTimeline.ComplianceList] = []
                for v in value {
                    if v != nil {
                        var model = GetResourceComplianceTimelineResponseBody.ResourceComplianceTimeline.ComplianceList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.complianceList = tmp
            }
            if let value = dict["MaxResults"] as? Int32 {
                self.maxResults = value
            }
            if let value = dict["NextToken"] as? String {
                self.nextToken = value
            }
        }
    }
    public var requestId: String?

    public var resourceComplianceTimeline: GetResourceComplianceTimelineResponseBody.ResourceComplianceTimeline?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resourceComplianceTimeline?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceComplianceTimeline != nil {
            map["ResourceComplianceTimeline"] = self.resourceComplianceTimeline?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ResourceComplianceTimeline"] as? [String: Any?] {
            var model = GetResourceComplianceTimelineResponseBody.ResourceComplianceTimeline()
            model.fromMap(value)
            self.resourceComplianceTimeline = model
        }
    }
}

public class GetResourceComplianceTimelineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetResourceComplianceTimelineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetResourceComplianceTimelineResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetResourceConfigurationTimelineRequest : Tea.TeaModel {
    public var endTime: Int64?

    public var maxResults: Int32?

    public var nextToken: String?

    public var region: String?

    public var resourceId: String?

    public var resourceType: String?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EndTime"] as? Int64 {
            self.endTime = value
        }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["Region"] as? String {
            self.region = value
        }
        if let value = dict["ResourceId"] as? String {
            self.resourceId = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
        if let value = dict["StartTime"] as? Int64 {
            self.startTime = value
        }
    }
}

public class GetResourceConfigurationTimelineResponseBody : Tea.TeaModel {
    public class ResourceConfigurationTimeline : Tea.TeaModel {
        public class ConfigurationList : Tea.TeaModel {
            public var accountId: Int64?

            public var availabilityZone: String?

            public var captureTime: String?

            public var configurationDiff: String?

            public var region: String?

            public var relationship: String?

            public var relationshipDiff: String?

            public var resourceCreateTime: String?

            public var resourceEventType: String?

            public var resourceId: String?

            public var resourceName: String?

            public var resourceType: String?

            public var tags: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.accountId != nil {
                    map["AccountId"] = self.accountId!
                }
                if self.availabilityZone != nil {
                    map["AvailabilityZone"] = self.availabilityZone!
                }
                if self.captureTime != nil {
                    map["CaptureTime"] = self.captureTime!
                }
                if self.configurationDiff != nil {
                    map["ConfigurationDiff"] = self.configurationDiff!
                }
                if self.region != nil {
                    map["Region"] = self.region!
                }
                if self.relationship != nil {
                    map["Relationship"] = self.relationship!
                }
                if self.relationshipDiff != nil {
                    map["RelationshipDiff"] = self.relationshipDiff!
                }
                if self.resourceCreateTime != nil {
                    map["ResourceCreateTime"] = self.resourceCreateTime!
                }
                if self.resourceEventType != nil {
                    map["ResourceEventType"] = self.resourceEventType!
                }
                if self.resourceId != nil {
                    map["ResourceId"] = self.resourceId!
                }
                if self.resourceName != nil {
                    map["ResourceName"] = self.resourceName!
                }
                if self.resourceType != nil {
                    map["ResourceType"] = self.resourceType!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AccountId"] as? Int64 {
                    self.accountId = value
                }
                if let value = dict["AvailabilityZone"] as? String {
                    self.availabilityZone = value
                }
                if let value = dict["CaptureTime"] as? String {
                    self.captureTime = value
                }
                if let value = dict["ConfigurationDiff"] as? String {
                    self.configurationDiff = value
                }
                if let value = dict["Region"] as? String {
                    self.region = value
                }
                if let value = dict["Relationship"] as? String {
                    self.relationship = value
                }
                if let value = dict["RelationshipDiff"] as? String {
                    self.relationshipDiff = value
                }
                if let value = dict["ResourceCreateTime"] as? String {
                    self.resourceCreateTime = value
                }
                if let value = dict["ResourceEventType"] as? String {
                    self.resourceEventType = value
                }
                if let value = dict["ResourceId"] as? String {
                    self.resourceId = value
                }
                if let value = dict["ResourceName"] as? String {
                    self.resourceName = value
                }
                if let value = dict["ResourceType"] as? String {
                    self.resourceType = value
                }
                if let value = dict["Tags"] as? String {
                    self.tags = value
                }
            }
        }
        public var configurationList: [GetResourceConfigurationTimelineResponseBody.ResourceConfigurationTimeline.ConfigurationList]?

        public var maxResults: Int32?

        public var nextToken: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.configurationList != nil {
                var tmp : [Any] = []
                for k in self.configurationList! {
                    tmp.append(k.toMap())
                }
                map["ConfigurationList"] = tmp
            }
            if self.maxResults != nil {
                map["MaxResults"] = self.maxResults!
            }
            if self.nextToken != nil {
                map["NextToken"] = self.nextToken!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ConfigurationList"] as? [Any?] {
                var tmp : [GetResourceConfigurationTimelineResponseBody.ResourceConfigurationTimeline.ConfigurationList] = []
                for v in value {
                    if v != nil {
                        var model = GetResourceConfigurationTimelineResponseBody.ResourceConfigurationTimeline.ConfigurationList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.configurationList = tmp
            }
            if let value = dict["MaxResults"] as? Int32 {
                self.maxResults = value
            }
            if let value = dict["NextToken"] as? String {
                self.nextToken = value
            }
        }
    }
    public var requestId: String?

    public var resourceConfigurationTimeline: GetResourceConfigurationTimelineResponseBody.ResourceConfigurationTimeline?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resourceConfigurationTimeline?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceConfigurationTimeline != nil {
            map["ResourceConfigurationTimeline"] = self.resourceConfigurationTimeline?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ResourceConfigurationTimeline"] as? [String: Any?] {
            var model = GetResourceConfigurationTimelineResponseBody.ResourceConfigurationTimeline()
            model.fromMap(value)
            self.resourceConfigurationTimeline = model
        }
    }
}

public class GetResourceConfigurationTimelineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetResourceConfigurationTimelineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetResourceConfigurationTimelineResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetResourceInventoryResponseBody : Tea.TeaModel {
    public class ResourceInventory : Tea.TeaModel {
        public var downloadUrl: String?

        public var resourceInventoryGenerateTime: Int64?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.downloadUrl != nil {
                map["DownloadUrl"] = self.downloadUrl!
            }
            if self.resourceInventoryGenerateTime != nil {
                map["ResourceInventoryGenerateTime"] = self.resourceInventoryGenerateTime!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DownloadUrl"] as? String {
                self.downloadUrl = value
            }
            if let value = dict["ResourceInventoryGenerateTime"] as? Int64 {
                self.resourceInventoryGenerateTime = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
        }
    }
    public var requestId: String?

    public var resourceInventory: GetResourceInventoryResponseBody.ResourceInventory?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resourceInventory?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceInventory != nil {
            map["ResourceInventory"] = self.resourceInventory?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ResourceInventory"] as? [String: Any?] {
            var model = GetResourceInventoryResponseBody.ResourceInventory()
            model.fromMap(value)
            self.resourceInventory = model
        }
    }
}

public class GetResourceInventoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetResourceInventoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetResourceInventoryResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetSupportedResourceRelationConfigRequest : Tea.TeaModel {
    public var resourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
    }
}

public class GetSupportedResourceRelationConfigResponseBody : Tea.TeaModel {
    public class ResourceRelationConfigList : Tea.TeaModel {
        public var relationType: String?

        public var targetResourceType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.relationType != nil {
                map["RelationType"] = self.relationType!
            }
            if self.targetResourceType != nil {
                map["TargetResourceType"] = self.targetResourceType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["RelationType"] as? String {
                self.relationType = value
            }
            if let value = dict["TargetResourceType"] as? String {
                self.targetResourceType = value
            }
        }
    }
    public var requestId: String?

    public var resourceRelationConfigList: [GetSupportedResourceRelationConfigResponseBody.ResourceRelationConfigList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceRelationConfigList != nil {
            var tmp : [Any] = []
            for k in self.resourceRelationConfigList! {
                tmp.append(k.toMap())
            }
            map["ResourceRelationConfigList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ResourceRelationConfigList"] as? [Any?] {
            var tmp : [GetSupportedResourceRelationConfigResponseBody.ResourceRelationConfigList] = []
            for v in value {
                if v != nil {
                    var model = GetSupportedResourceRelationConfigResponseBody.ResourceRelationConfigList()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.resourceRelationConfigList = tmp
        }
    }
}

public class GetSupportedResourceRelationConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetSupportedResourceRelationConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetSupportedResourceRelationConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class IgnoreAggregateEvaluationResultsRequest : Tea.TeaModel {
    public class Resources : Tea.TeaModel {
        public var region: String?

        public var resourceAccountId: Int64?

        public var resourceId: String?

        public var resourceType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.region != nil {
                map["Region"] = self.region!
            }
            if self.resourceAccountId != nil {
                map["ResourceAccountId"] = self.resourceAccountId!
            }
            if self.resourceId != nil {
                map["ResourceId"] = self.resourceId!
            }
            if self.resourceType != nil {
                map["ResourceType"] = self.resourceType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Region"] as? String {
                self.region = value
            }
            if let value = dict["ResourceAccountId"] as? Int64 {
                self.resourceAccountId = value
            }
            if let value = dict["ResourceId"] as? String {
                self.resourceId = value
            }
            if let value = dict["ResourceType"] as? String {
                self.resourceType = value
            }
        }
    }
    public var aggregatorId: String?

    public var configRuleId: String?

    public var ignoreDate: String?

    public var reason: String?

    public var resources: [IgnoreAggregateEvaluationResultsRequest.Resources]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aggregatorId != nil {
            map["AggregatorId"] = self.aggregatorId!
        }
        if self.configRuleId != nil {
            map["ConfigRuleId"] = self.configRuleId!
        }
        if self.ignoreDate != nil {
            map["IgnoreDate"] = self.ignoreDate!
        }
        if self.reason != nil {
            map["Reason"] = self.reason!
        }
        if self.resources != nil {
            var tmp : [Any] = []
            for k in self.resources! {
                tmp.append(k.toMap())
            }
            map["Resources"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AggregatorId"] as? String {
            self.aggregatorId = value
        }
        if let value = dict["ConfigRuleId"] as? String {
            self.configRuleId = value
        }
        if let value = dict["IgnoreDate"] as? String {
            self.ignoreDate = value
        }
        if let value = dict["Reason"] as? String {
            self.reason = value
        }
        if let value = dict["Resources"] as? [Any?] {
            var tmp : [IgnoreAggregateEvaluationResultsRequest.Resources] = []
            for v in value {
                if v != nil {
                    var model = IgnoreAggregateEvaluationResultsRequest.Resources()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.resources = tmp
        }
    }
}

public class IgnoreAggregateEvaluationResultsShrinkRequest : Tea.TeaModel {
    public var aggregatorId: String?

    public var configRuleId: String?

    public var ignoreDate: String?

    public var reason: String?

    public var resourcesShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aggregatorId != nil {
            map["AggregatorId"] = self.aggregatorId!
        }
        if self.configRuleId != nil {
            map["ConfigRuleId"] = self.configRuleId!
        }
        if self.ignoreDate != nil {
            map["IgnoreDate"] = self.ignoreDate!
        }
        if self.reason != nil {
            map["Reason"] = self.reason!
        }
        if self.resourcesShrink != nil {
            map["Resources"] = self.resourcesShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AggregatorId"] as? String {
            self.aggregatorId = value
        }
        if let value = dict["ConfigRuleId"] as? String {
            self.configRuleId = value
        }
        if let value = dict["IgnoreDate"] as? String {
            self.ignoreDate = value
        }
        if let value = dict["Reason"] as? String {
            self.reason = value
        }
        if let value = dict["Resources"] as? String {
            self.resourcesShrink = value
        }
    }
}

public class IgnoreAggregateEvaluationResultsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class IgnoreAggregateEvaluationResultsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: IgnoreAggregateEvaluationResultsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = IgnoreAggregateEvaluationResultsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class IgnoreEvaluationResultsRequest : Tea.TeaModel {
    public class Resources : Tea.TeaModel {
        public var region: String?

        public var resourceAccountId: Int64?

        public var resourceId: String?

        public var resourceType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.region != nil {
                map["Region"] = self.region!
            }
            if self.resourceAccountId != nil {
                map["ResourceAccountId"] = self.resourceAccountId!
            }
            if self.resourceId != nil {
                map["ResourceId"] = self.resourceId!
            }
            if self.resourceType != nil {
                map["ResourceType"] = self.resourceType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Region"] as? String {
                self.region = value
            }
            if let value = dict["ResourceAccountId"] as? Int64 {
                self.resourceAccountId = value
            }
            if let value = dict["ResourceId"] as? String {
                self.resourceId = value
            }
            if let value = dict["ResourceType"] as? String {
                self.resourceType = value
            }
        }
    }
    public var configRuleId: String?

    public var ignoreDate: String?

    public var reason: String?

    public var resources: [IgnoreEvaluationResultsRequest.Resources]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configRuleId != nil {
            map["ConfigRuleId"] = self.configRuleId!
        }
        if self.ignoreDate != nil {
            map["IgnoreDate"] = self.ignoreDate!
        }
        if self.reason != nil {
            map["Reason"] = self.reason!
        }
        if self.resources != nil {
            var tmp : [Any] = []
            for k in self.resources! {
                tmp.append(k.toMap())
            }
            map["Resources"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ConfigRuleId"] as? String {
            self.configRuleId = value
        }
        if let value = dict["IgnoreDate"] as? String {
            self.ignoreDate = value
        }
        if let value = dict["Reason"] as? String {
            self.reason = value
        }
        if let value = dict["Resources"] as? [Any?] {
            var tmp : [IgnoreEvaluationResultsRequest.Resources] = []
            for v in value {
                if v != nil {
                    var model = IgnoreEvaluationResultsRequest.Resources()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.resources = tmp
        }
    }
}

public class IgnoreEvaluationResultsShrinkRequest : Tea.TeaModel {
    public var configRuleId: String?

    public var ignoreDate: String?

    public var reason: String?

    public var resourcesShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configRuleId != nil {
            map["ConfigRuleId"] = self.configRuleId!
        }
        if self.ignoreDate != nil {
            map["IgnoreDate"] = self.ignoreDate!
        }
        if self.reason != nil {
            map["Reason"] = self.reason!
        }
        if self.resourcesShrink != nil {
            map["Resources"] = self.resourcesShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ConfigRuleId"] as? String {
            self.configRuleId = value
        }
        if let value = dict["IgnoreDate"] as? String {
            self.ignoreDate = value
        }
        if let value = dict["Reason"] as? String {
            self.reason = value
        }
        if let value = dict["Resources"] as? String {
            self.resourcesShrink = value
        }
    }
}

public class IgnoreEvaluationResultsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class IgnoreEvaluationResultsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: IgnoreEvaluationResultsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = IgnoreEvaluationResultsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListAggregateCompliancePacksRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var aggregatorId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var status: String?

    public var tag: [ListAggregateCompliancePacksRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aggregatorId != nil {
            map["AggregatorId"] = self.aggregatorId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AggregatorId"] as? String {
            self.aggregatorId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [ListAggregateCompliancePacksRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = ListAggregateCompliancePacksRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
    }
}

public class ListAggregateCompliancePacksShrinkRequest : Tea.TeaModel {
    public var aggregatorId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var status: String?

    public var tagShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aggregatorId != nil {
            map["AggregatorId"] = self.aggregatorId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.tagShrink != nil {
            map["Tag"] = self.tagShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AggregatorId"] as? String {
            self.aggregatorId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
        if let value = dict["Tag"] as? String {
            self.tagShrink = value
        }
    }
}

public class ListAggregateCompliancePacksResponseBody : Tea.TeaModel {
    public class CompliancePacksResult : Tea.TeaModel {
        public class CompliancePacks : Tea.TeaModel {
            public class Tags : Tea.TeaModel {
                public var tagKey: String?

                public var tagValue: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tagKey != nil {
                        map["TagKey"] = self.tagKey!
                    }
                    if self.tagValue != nil {
                        map["TagValue"] = self.tagValue!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["TagKey"] as? String {
                        self.tagKey = value
                    }
                    if let value = dict["TagValue"] as? String {
                        self.tagValue = value
                    }
                }
            }
            public var accountId: Int64?

            public var aggregatorId: String?

            public var compliancePackId: String?

            public var compliancePackName: String?

            public var compliancePackTemplateId: String?

            public var createTimestamp: Int64?

            public var description_: String?

            public var riskLevel: Int32?

            public var status: String?

            public var tags: [ListAggregateCompliancePacksResponseBody.CompliancePacksResult.CompliancePacks.Tags]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.accountId != nil {
                    map["AccountId"] = self.accountId!
                }
                if self.aggregatorId != nil {
                    map["AggregatorId"] = self.aggregatorId!
                }
                if self.compliancePackId != nil {
                    map["CompliancePackId"] = self.compliancePackId!
                }
                if self.compliancePackName != nil {
                    map["CompliancePackName"] = self.compliancePackName!
                }
                if self.compliancePackTemplateId != nil {
                    map["CompliancePackTemplateId"] = self.compliancePackTemplateId!
                }
                if self.createTimestamp != nil {
                    map["CreateTimestamp"] = self.createTimestamp!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.riskLevel != nil {
                    map["RiskLevel"] = self.riskLevel!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.tags != nil {
                    var tmp : [Any] = []
                    for k in self.tags! {
                        tmp.append(k.toMap())
                    }
                    map["Tags"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AccountId"] as? Int64 {
                    self.accountId = value
                }
                if let value = dict["AggregatorId"] as? String {
                    self.aggregatorId = value
                }
                if let value = dict["CompliancePackId"] as? String {
                    self.compliancePackId = value
                }
                if let value = dict["CompliancePackName"] as? String {
                    self.compliancePackName = value
                }
                if let value = dict["CompliancePackTemplateId"] as? String {
                    self.compliancePackTemplateId = value
                }
                if let value = dict["CreateTimestamp"] as? Int64 {
                    self.createTimestamp = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["RiskLevel"] as? Int32 {
                    self.riskLevel = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
                if let value = dict["Tags"] as? [Any?] {
                    var tmp : [ListAggregateCompliancePacksResponseBody.CompliancePacksResult.CompliancePacks.Tags] = []
                    for v in value {
                        if v != nil {
                            var model = ListAggregateCompliancePacksResponseBody.CompliancePacksResult.CompliancePacks.Tags()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.tags = tmp
                }
            }
        }
        public var compliancePacks: [ListAggregateCompliancePacksResponseBody.CompliancePacksResult.CompliancePacks]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.compliancePacks != nil {
                var tmp : [Any] = []
                for k in self.compliancePacks! {
                    tmp.append(k.toMap())
                }
                map["CompliancePacks"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CompliancePacks"] as? [Any?] {
                var tmp : [ListAggregateCompliancePacksResponseBody.CompliancePacksResult.CompliancePacks] = []
                for v in value {
                    if v != nil {
                        var model = ListAggregateCompliancePacksResponseBody.CompliancePacksResult.CompliancePacks()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.compliancePacks = tmp
            }
            if let value = dict["PageNumber"] as? Int32 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["TotalCount"] as? Int64 {
                self.totalCount = value
            }
        }
    }
    public var compliancePacksResult: ListAggregateCompliancePacksResponseBody.CompliancePacksResult?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.compliancePacksResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.compliancePacksResult != nil {
            map["CompliancePacksResult"] = self.compliancePacksResult?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CompliancePacksResult"] as? [String: Any?] {
            var model = ListAggregateCompliancePacksResponseBody.CompliancePacksResult()
            model.fromMap(value)
            self.compliancePacksResult = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListAggregateCompliancePacksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAggregateCompliancePacksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListAggregateCompliancePacksResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListAggregateConfigDeliveryChannelsRequest : Tea.TeaModel {
    public var aggregatorId: String?

    public var deliveryChannelIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aggregatorId != nil {
            map["AggregatorId"] = self.aggregatorId!
        }
        if self.deliveryChannelIds != nil {
            map["DeliveryChannelIds"] = self.deliveryChannelIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AggregatorId"] as? String {
            self.aggregatorId = value
        }
        if let value = dict["DeliveryChannelIds"] as? String {
            self.deliveryChannelIds = value
        }
    }
}

public class ListAggregateConfigDeliveryChannelsResponseBody : Tea.TeaModel {
    public class DeliveryChannels : Tea.TeaModel {
        public var accountId: Int64?

        public var aggregatorId: String?

        public var compliantSnapshot: Bool?

        public var configurationItemChangeNotification: Bool?

        public var configurationSnapshot: Bool?

        public var deliveryChannelAssumeRoleArn: String?

        public var deliveryChannelCondition: String?

        public var deliveryChannelId: String?

        public var deliveryChannelName: String?

        public var deliveryChannelTargetArn: String?

        public var deliveryChannelType: String?

        public var deliverySnapshotTime: String?

        public var description_: String?

        public var nonCompliantNotification: Bool?

        public var oversizedDataOSSTargetArn: String?

        public var status: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["AccountId"] = self.accountId!
            }
            if self.aggregatorId != nil {
                map["AggregatorId"] = self.aggregatorId!
            }
            if self.compliantSnapshot != nil {
                map["CompliantSnapshot"] = self.compliantSnapshot!
            }
            if self.configurationItemChangeNotification != nil {
                map["ConfigurationItemChangeNotification"] = self.configurationItemChangeNotification!
            }
            if self.configurationSnapshot != nil {
                map["ConfigurationSnapshot"] = self.configurationSnapshot!
            }
            if self.deliveryChannelAssumeRoleArn != nil {
                map["DeliveryChannelAssumeRoleArn"] = self.deliveryChannelAssumeRoleArn!
            }
            if self.deliveryChannelCondition != nil {
                map["DeliveryChannelCondition"] = self.deliveryChannelCondition!
            }
            if self.deliveryChannelId != nil {
                map["DeliveryChannelId"] = self.deliveryChannelId!
            }
            if self.deliveryChannelName != nil {
                map["DeliveryChannelName"] = self.deliveryChannelName!
            }
            if self.deliveryChannelTargetArn != nil {
                map["DeliveryChannelTargetArn"] = self.deliveryChannelTargetArn!
            }
            if self.deliveryChannelType != nil {
                map["DeliveryChannelType"] = self.deliveryChannelType!
            }
            if self.deliverySnapshotTime != nil {
                map["DeliverySnapshotTime"] = self.deliverySnapshotTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.nonCompliantNotification != nil {
                map["NonCompliantNotification"] = self.nonCompliantNotification!
            }
            if self.oversizedDataOSSTargetArn != nil {
                map["OversizedDataOSSTargetArn"] = self.oversizedDataOSSTargetArn!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AccountId"] as? Int64 {
                self.accountId = value
            }
            if let value = dict["AggregatorId"] as? String {
                self.aggregatorId = value
            }
            if let value = dict["CompliantSnapshot"] as? Bool {
                self.compliantSnapshot = value
            }
            if let value = dict["ConfigurationItemChangeNotification"] as? Bool {
                self.configurationItemChangeNotification = value
            }
            if let value = dict["ConfigurationSnapshot"] as? Bool {
                self.configurationSnapshot = value
            }
            if let value = dict["DeliveryChannelAssumeRoleArn"] as? String {
                self.deliveryChannelAssumeRoleArn = value
            }
            if let value = dict["DeliveryChannelCondition"] as? String {
                self.deliveryChannelCondition = value
            }
            if let value = dict["DeliveryChannelId"] as? String {
                self.deliveryChannelId = value
            }
            if let value = dict["DeliveryChannelName"] as? String {
                self.deliveryChannelName = value
            }
            if let value = dict["DeliveryChannelTargetArn"] as? String {
                self.deliveryChannelTargetArn = value
            }
            if let value = dict["DeliveryChannelType"] as? String {
                self.deliveryChannelType = value
            }
            if let value = dict["DeliverySnapshotTime"] as? String {
                self.deliverySnapshotTime = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["NonCompliantNotification"] as? Bool {
                self.nonCompliantNotification = value
            }
            if let value = dict["OversizedDataOSSTargetArn"] as? String {
                self.oversizedDataOSSTargetArn = value
            }
            if let value = dict["Status"] as? Int32 {
                self.status = value
            }
        }
    }
    public var deliveryChannels: [ListAggregateConfigDeliveryChannelsResponseBody.DeliveryChannels]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deliveryChannels != nil {
            var tmp : [Any] = []
            for k in self.deliveryChannels! {
                tmp.append(k.toMap())
            }
            map["DeliveryChannels"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DeliveryChannels"] as? [Any?] {
            var tmp : [ListAggregateConfigDeliveryChannelsResponseBody.DeliveryChannels] = []
            for v in value {
                if v != nil {
                    var model = ListAggregateConfigDeliveryChannelsResponseBody.DeliveryChannels()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.deliveryChannels = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListAggregateConfigDeliveryChannelsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAggregateConfigDeliveryChannelsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListAggregateConfigDeliveryChannelsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListAggregateConfigRuleEvaluationResultsRequest : Tea.TeaModel {
    public var aggregatorId: String?

    public var compliancePackId: String?

    public var complianceType: String?

    public var configRuleId: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var regions: String?

    public var resourceAccountId: Int64?

    public var resourceGroupIds: String?

    public var resourceOwnerId: Int64?

    public var resourceTypes: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aggregatorId != nil {
            map["AggregatorId"] = self.aggregatorId!
        }
        if self.compliancePackId != nil {
            map["CompliancePackId"] = self.compliancePackId!
        }
        if self.complianceType != nil {
            map["ComplianceType"] = self.complianceType!
        }
        if self.configRuleId != nil {
            map["ConfigRuleId"] = self.configRuleId!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.regions != nil {
            map["Regions"] = self.regions!
        }
        if self.resourceAccountId != nil {
            map["ResourceAccountId"] = self.resourceAccountId!
        }
        if self.resourceGroupIds != nil {
            map["ResourceGroupIds"] = self.resourceGroupIds!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceTypes != nil {
            map["ResourceTypes"] = self.resourceTypes!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AggregatorId"] as? String {
            self.aggregatorId = value
        }
        if let value = dict["CompliancePackId"] as? String {
            self.compliancePackId = value
        }
        if let value = dict["ComplianceType"] as? String {
            self.complianceType = value
        }
        if let value = dict["ConfigRuleId"] as? String {
            self.configRuleId = value
        }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["Regions"] as? String {
            self.regions = value
        }
        if let value = dict["ResourceAccountId"] as? Int64 {
            self.resourceAccountId = value
        }
        if let value = dict["ResourceGroupIds"] as? String {
            self.resourceGroupIds = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ResourceTypes"] as? String {
            self.resourceTypes = value
        }
    }
}

public class ListAggregateConfigRuleEvaluationResultsResponseBody : Tea.TeaModel {
    public class EvaluationResults : Tea.TeaModel {
        public class EvaluationResultList : Tea.TeaModel {
            public class EvaluationResultIdentifier : Tea.TeaModel {
                public class EvaluationResultQualifier : Tea.TeaModel {
                    public var compliancePackId: String?

                    public var configRuleArn: String?

                    public var configRuleId: String?

                    public var configRuleName: String?

                    public var ignoreDate: String?

                    public var regionId: String?

                    public var resourceGroupId: String?

                    public var resourceId: String?

                    public var resourceName: String?

                    public var resourceOwnerId: Int64?

                    public var resourceType: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.compliancePackId != nil {
                            map["CompliancePackId"] = self.compliancePackId!
                        }
                        if self.configRuleArn != nil {
                            map["ConfigRuleArn"] = self.configRuleArn!
                        }
                        if self.configRuleId != nil {
                            map["ConfigRuleId"] = self.configRuleId!
                        }
                        if self.configRuleName != nil {
                            map["ConfigRuleName"] = self.configRuleName!
                        }
                        if self.ignoreDate != nil {
                            map["IgnoreDate"] = self.ignoreDate!
                        }
                        if self.regionId != nil {
                            map["RegionId"] = self.regionId!
                        }
                        if self.resourceGroupId != nil {
                            map["ResourceGroupId"] = self.resourceGroupId!
                        }
                        if self.resourceId != nil {
                            map["ResourceId"] = self.resourceId!
                        }
                        if self.resourceName != nil {
                            map["ResourceName"] = self.resourceName!
                        }
                        if self.resourceOwnerId != nil {
                            map["ResourceOwnerId"] = self.resourceOwnerId!
                        }
                        if self.resourceType != nil {
                            map["ResourceType"] = self.resourceType!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["CompliancePackId"] as? String {
                            self.compliancePackId = value
                        }
                        if let value = dict["ConfigRuleArn"] as? String {
                            self.configRuleArn = value
                        }
                        if let value = dict["ConfigRuleId"] as? String {
                            self.configRuleId = value
                        }
                        if let value = dict["ConfigRuleName"] as? String {
                            self.configRuleName = value
                        }
                        if let value = dict["IgnoreDate"] as? String {
                            self.ignoreDate = value
                        }
                        if let value = dict["RegionId"] as? String {
                            self.regionId = value
                        }
                        if let value = dict["ResourceGroupId"] as? String {
                            self.resourceGroupId = value
                        }
                        if let value = dict["ResourceId"] as? String {
                            self.resourceId = value
                        }
                        if let value = dict["ResourceName"] as? String {
                            self.resourceName = value
                        }
                        if let value = dict["ResourceOwnerId"] as? Int64 {
                            self.resourceOwnerId = value
                        }
                        if let value = dict["ResourceType"] as? String {
                            self.resourceType = value
                        }
                    }
                }
                public var evaluationResultQualifier: ListAggregateConfigRuleEvaluationResultsResponseBody.EvaluationResults.EvaluationResultList.EvaluationResultIdentifier.EvaluationResultQualifier?

                public var orderingTimestamp: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.evaluationResultQualifier?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.evaluationResultQualifier != nil {
                        map["EvaluationResultQualifier"] = self.evaluationResultQualifier?.toMap()
                    }
                    if self.orderingTimestamp != nil {
                        map["OrderingTimestamp"] = self.orderingTimestamp!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["EvaluationResultQualifier"] as? [String: Any?] {
                        var model = ListAggregateConfigRuleEvaluationResultsResponseBody.EvaluationResults.EvaluationResultList.EvaluationResultIdentifier.EvaluationResultQualifier()
                        model.fromMap(value)
                        self.evaluationResultQualifier = model
                    }
                    if let value = dict["OrderingTimestamp"] as? Int64 {
                        self.orderingTimestamp = value
                    }
                }
            }
            public var annotation: String?

            public var complianceType: String?

            public var configRuleInvokedTimestamp: Int64?

            public var evaluationId: String?

            public var evaluationResultIdentifier: ListAggregateConfigRuleEvaluationResultsResponseBody.EvaluationResults.EvaluationResultList.EvaluationResultIdentifier?

            public var invokingEventMessageType: String?

            public var lastNonCompliantRecordTimestamp: Int64?

            public var remediationEnabled: Bool?

            public var resultRecordedTimestamp: Int64?

            public var riskLevel: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.evaluationResultIdentifier?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.annotation != nil {
                    map["Annotation"] = self.annotation!
                }
                if self.complianceType != nil {
                    map["ComplianceType"] = self.complianceType!
                }
                if self.configRuleInvokedTimestamp != nil {
                    map["ConfigRuleInvokedTimestamp"] = self.configRuleInvokedTimestamp!
                }
                if self.evaluationId != nil {
                    map["EvaluationId"] = self.evaluationId!
                }
                if self.evaluationResultIdentifier != nil {
                    map["EvaluationResultIdentifier"] = self.evaluationResultIdentifier?.toMap()
                }
                if self.invokingEventMessageType != nil {
                    map["InvokingEventMessageType"] = self.invokingEventMessageType!
                }
                if self.lastNonCompliantRecordTimestamp != nil {
                    map["LastNonCompliantRecordTimestamp"] = self.lastNonCompliantRecordTimestamp!
                }
                if self.remediationEnabled != nil {
                    map["RemediationEnabled"] = self.remediationEnabled!
                }
                if self.resultRecordedTimestamp != nil {
                    map["ResultRecordedTimestamp"] = self.resultRecordedTimestamp!
                }
                if self.riskLevel != nil {
                    map["RiskLevel"] = self.riskLevel!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Annotation"] as? String {
                    self.annotation = value
                }
                if let value = dict["ComplianceType"] as? String {
                    self.complianceType = value
                }
                if let value = dict["ConfigRuleInvokedTimestamp"] as? Int64 {
                    self.configRuleInvokedTimestamp = value
                }
                if let value = dict["EvaluationId"] as? String {
                    self.evaluationId = value
                }
                if let value = dict["EvaluationResultIdentifier"] as? [String: Any?] {
                    var model = ListAggregateConfigRuleEvaluationResultsResponseBody.EvaluationResults.EvaluationResultList.EvaluationResultIdentifier()
                    model.fromMap(value)
                    self.evaluationResultIdentifier = model
                }
                if let value = dict["InvokingEventMessageType"] as? String {
                    self.invokingEventMessageType = value
                }
                if let value = dict["LastNonCompliantRecordTimestamp"] as? Int64 {
                    self.lastNonCompliantRecordTimestamp = value
                }
                if let value = dict["RemediationEnabled"] as? Bool {
                    self.remediationEnabled = value
                }
                if let value = dict["ResultRecordedTimestamp"] as? Int64 {
                    self.resultRecordedTimestamp = value
                }
                if let value = dict["RiskLevel"] as? Int32 {
                    self.riskLevel = value
                }
            }
        }
        public var evaluationResultList: [ListAggregateConfigRuleEvaluationResultsResponseBody.EvaluationResults.EvaluationResultList]?

        public var maxResults: Int32?

        public var nextToken: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.evaluationResultList != nil {
                var tmp : [Any] = []
                for k in self.evaluationResultList! {
                    tmp.append(k.toMap())
                }
                map["EvaluationResultList"] = tmp
            }
            if self.maxResults != nil {
                map["MaxResults"] = self.maxResults!
            }
            if self.nextToken != nil {
                map["NextToken"] = self.nextToken!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["EvaluationResultList"] as? [Any?] {
                var tmp : [ListAggregateConfigRuleEvaluationResultsResponseBody.EvaluationResults.EvaluationResultList] = []
                for v in value {
                    if v != nil {
                        var model = ListAggregateConfigRuleEvaluationResultsResponseBody.EvaluationResults.EvaluationResultList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.evaluationResultList = tmp
            }
            if let value = dict["MaxResults"] as? Int32 {
                self.maxResults = value
            }
            if let value = dict["NextToken"] as? String {
                self.nextToken = value
            }
        }
    }
    public var evaluationResults: ListAggregateConfigRuleEvaluationResultsResponseBody.EvaluationResults?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.evaluationResults?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.evaluationResults != nil {
            map["EvaluationResults"] = self.evaluationResults?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EvaluationResults"] as? [String: Any?] {
            var model = ListAggregateConfigRuleEvaluationResultsResponseBody.EvaluationResults()
            model.fromMap(value)
            self.evaluationResults = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListAggregateConfigRuleEvaluationResultsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAggregateConfigRuleEvaluationResultsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListAggregateConfigRuleEvaluationResultsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListAggregateConfigRuleEvaluationStatisticsRequest : Tea.TeaModel {
    public var aggregatorId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aggregatorId != nil {
            map["AggregatorId"] = self.aggregatorId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AggregatorId"] as? String {
            self.aggregatorId = value
        }
    }
}

public class ListAggregateConfigRuleEvaluationStatisticsResponseBody : Tea.TeaModel {
    public class EvaluationResults : Tea.TeaModel {
        public var aggregatorId: String?

        public var nonCompliantResourceCnt: Int32?

        public var nonCompliantRuleCnt: Int32?

        public var statisticDate: String?

        public var totalResourceCnt: Int32?

        public var totalRuleCnt: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aggregatorId != nil {
                map["AggregatorId"] = self.aggregatorId!
            }
            if self.nonCompliantResourceCnt != nil {
                map["NonCompliantResourceCnt"] = self.nonCompliantResourceCnt!
            }
            if self.nonCompliantRuleCnt != nil {
                map["NonCompliantRuleCnt"] = self.nonCompliantRuleCnt!
            }
            if self.statisticDate != nil {
                map["StatisticDate"] = self.statisticDate!
            }
            if self.totalResourceCnt != nil {
                map["TotalResourceCnt"] = self.totalResourceCnt!
            }
            if self.totalRuleCnt != nil {
                map["TotalRuleCnt"] = self.totalRuleCnt!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AggregatorId"] as? String {
                self.aggregatorId = value
            }
            if let value = dict["NonCompliantResourceCnt"] as? Int32 {
                self.nonCompliantResourceCnt = value
            }
            if let value = dict["NonCompliantRuleCnt"] as? Int32 {
                self.nonCompliantRuleCnt = value
            }
            if let value = dict["StatisticDate"] as? String {
                self.statisticDate = value
            }
            if let value = dict["TotalResourceCnt"] as? Int32 {
                self.totalResourceCnt = value
            }
            if let value = dict["TotalRuleCnt"] as? Int32 {
                self.totalRuleCnt = value
            }
        }
    }
    public var evaluationResults: [ListAggregateConfigRuleEvaluationStatisticsResponseBody.EvaluationResults]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.evaluationResults != nil {
            var tmp : [Any] = []
            for k in self.evaluationResults! {
                tmp.append(k.toMap())
            }
            map["EvaluationResults"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EvaluationResults"] as? [Any?] {
            var tmp : [ListAggregateConfigRuleEvaluationStatisticsResponseBody.EvaluationResults] = []
            for v in value {
                if v != nil {
                    var model = ListAggregateConfigRuleEvaluationStatisticsResponseBody.EvaluationResults()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.evaluationResults = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListAggregateConfigRuleEvaluationStatisticsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAggregateConfigRuleEvaluationStatisticsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListAggregateConfigRuleEvaluationStatisticsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListAggregateConfigRulesRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var aggregatorId: String?

    public var compliancePackId: String?

    public var complianceType: String?

    public var configRuleName: String?

    public var configRuleState: String?

    public var keyword: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var resourceTypes: String?

    public var riskLevel: Int32?

    public var tag: [ListAggregateConfigRulesRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aggregatorId != nil {
            map["AggregatorId"] = self.aggregatorId!
        }
        if self.compliancePackId != nil {
            map["CompliancePackId"] = self.compliancePackId!
        }
        if self.complianceType != nil {
            map["ComplianceType"] = self.complianceType!
        }
        if self.configRuleName != nil {
            map["ConfigRuleName"] = self.configRuleName!
        }
        if self.configRuleState != nil {
            map["ConfigRuleState"] = self.configRuleState!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceTypes != nil {
            map["ResourceTypes"] = self.resourceTypes!
        }
        if self.riskLevel != nil {
            map["RiskLevel"] = self.riskLevel!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AggregatorId"] as? String {
            self.aggregatorId = value
        }
        if let value = dict["CompliancePackId"] as? String {
            self.compliancePackId = value
        }
        if let value = dict["ComplianceType"] as? String {
            self.complianceType = value
        }
        if let value = dict["ConfigRuleName"] as? String {
            self.configRuleName = value
        }
        if let value = dict["ConfigRuleState"] as? String {
            self.configRuleState = value
        }
        if let value = dict["Keyword"] as? String {
            self.keyword = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ResourceTypes"] as? String {
            self.resourceTypes = value
        }
        if let value = dict["RiskLevel"] as? Int32 {
            self.riskLevel = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [ListAggregateConfigRulesRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = ListAggregateConfigRulesRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
    }
}

public class ListAggregateConfigRulesShrinkRequest : Tea.TeaModel {
    public var aggregatorId: String?

    public var compliancePackId: String?

    public var complianceType: String?

    public var configRuleName: String?

    public var configRuleState: String?

    public var keyword: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var resourceTypes: String?

    public var riskLevel: Int32?

    public var tagShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aggregatorId != nil {
            map["AggregatorId"] = self.aggregatorId!
        }
        if self.compliancePackId != nil {
            map["CompliancePackId"] = self.compliancePackId!
        }
        if self.complianceType != nil {
            map["ComplianceType"] = self.complianceType!
        }
        if self.configRuleName != nil {
            map["ConfigRuleName"] = self.configRuleName!
        }
        if self.configRuleState != nil {
            map["ConfigRuleState"] = self.configRuleState!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceTypes != nil {
            map["ResourceTypes"] = self.resourceTypes!
        }
        if self.riskLevel != nil {
            map["RiskLevel"] = self.riskLevel!
        }
        if self.tagShrink != nil {
            map["Tag"] = self.tagShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AggregatorId"] as? String {
            self.aggregatorId = value
        }
        if let value = dict["CompliancePackId"] as? String {
            self.compliancePackId = value
        }
        if let value = dict["ComplianceType"] as? String {
            self.complianceType = value
        }
        if let value = dict["ConfigRuleName"] as? String {
            self.configRuleName = value
        }
        if let value = dict["ConfigRuleState"] as? String {
            self.configRuleState = value
        }
        if let value = dict["Keyword"] as? String {
            self.keyword = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ResourceTypes"] as? String {
            self.resourceTypes = value
        }
        if let value = dict["RiskLevel"] as? Int32 {
            self.riskLevel = value
        }
        if let value = dict["Tag"] as? String {
            self.tagShrink = value
        }
    }
}

public class ListAggregateConfigRulesResponseBody : Tea.TeaModel {
    public class ConfigRules : Tea.TeaModel {
        public class ConfigRuleList : Tea.TeaModel {
            public class Compliance : Tea.TeaModel {
                public var complianceType: String?

                public var count: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.complianceType != nil {
                        map["ComplianceType"] = self.complianceType!
                    }
                    if self.count != nil {
                        map["Count"] = self.count!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ComplianceType"] as? String {
                        self.complianceType = value
                    }
                    if let value = dict["Count"] as? Int32 {
                        self.count = value
                    }
                }
            }
            public class CreateBy : Tea.TeaModel {
                public var aggregatorId: String?

                public var aggregatorName: String?

                public var compliancePackId: String?

                public var compliancePackName: String?

                public var creatorId: String?

                public var creatorName: String?

                public var creatorType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.aggregatorId != nil {
                        map["AggregatorId"] = self.aggregatorId!
                    }
                    if self.aggregatorName != nil {
                        map["AggregatorName"] = self.aggregatorName!
                    }
                    if self.compliancePackId != nil {
                        map["CompliancePackId"] = self.compliancePackId!
                    }
                    if self.compliancePackName != nil {
                        map["CompliancePackName"] = self.compliancePackName!
                    }
                    if self.creatorId != nil {
                        map["CreatorId"] = self.creatorId!
                    }
                    if self.creatorName != nil {
                        map["CreatorName"] = self.creatorName!
                    }
                    if self.creatorType != nil {
                        map["CreatorType"] = self.creatorType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["AggregatorId"] as? String {
                        self.aggregatorId = value
                    }
                    if let value = dict["AggregatorName"] as? String {
                        self.aggregatorName = value
                    }
                    if let value = dict["CompliancePackId"] as? String {
                        self.compliancePackId = value
                    }
                    if let value = dict["CompliancePackName"] as? String {
                        self.compliancePackName = value
                    }
                    if let value = dict["CreatorId"] as? String {
                        self.creatorId = value
                    }
                    if let value = dict["CreatorName"] as? String {
                        self.creatorName = value
                    }
                    if let value = dict["CreatorType"] as? String {
                        self.creatorType = value
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public var key: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Key"] as? String {
                        self.key = value
                    }
                    if let value = dict["Value"] as? String {
                        self.value = value
                    }
                }
            }
            public var accountId: Int64?

            public var automationType: String?

            public var compliance: ListAggregateConfigRulesResponseBody.ConfigRules.ConfigRuleList.Compliance?

            public var configRuleArn: String?

            public var configRuleId: String?

            public var configRuleName: String?

            public var configRuleState: String?

            public var createBy: ListAggregateConfigRulesResponseBody.ConfigRules.ConfigRuleList.CreateBy?

            public var description_: String?

            public var resourceTypesScope: String?

            public var riskLevel: Int32?

            public var sourceIdentifier: String?

            public var sourceOwner: String?

            public var tags: [ListAggregateConfigRulesResponseBody.ConfigRules.ConfigRuleList.Tags]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.compliance?.validate()
                try self.createBy?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.accountId != nil {
                    map["AccountId"] = self.accountId!
                }
                if self.automationType != nil {
                    map["AutomationType"] = self.automationType!
                }
                if self.compliance != nil {
                    map["Compliance"] = self.compliance?.toMap()
                }
                if self.configRuleArn != nil {
                    map["ConfigRuleArn"] = self.configRuleArn!
                }
                if self.configRuleId != nil {
                    map["ConfigRuleId"] = self.configRuleId!
                }
                if self.configRuleName != nil {
                    map["ConfigRuleName"] = self.configRuleName!
                }
                if self.configRuleState != nil {
                    map["ConfigRuleState"] = self.configRuleState!
                }
                if self.createBy != nil {
                    map["CreateBy"] = self.createBy?.toMap()
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.resourceTypesScope != nil {
                    map["ResourceTypesScope"] = self.resourceTypesScope!
                }
                if self.riskLevel != nil {
                    map["RiskLevel"] = self.riskLevel!
                }
                if self.sourceIdentifier != nil {
                    map["SourceIdentifier"] = self.sourceIdentifier!
                }
                if self.sourceOwner != nil {
                    map["SourceOwner"] = self.sourceOwner!
                }
                if self.tags != nil {
                    var tmp : [Any] = []
                    for k in self.tags! {
                        tmp.append(k.toMap())
                    }
                    map["Tags"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AccountId"] as? Int64 {
                    self.accountId = value
                }
                if let value = dict["AutomationType"] as? String {
                    self.automationType = value
                }
                if let value = dict["Compliance"] as? [String: Any?] {
                    var model = ListAggregateConfigRulesResponseBody.ConfigRules.ConfigRuleList.Compliance()
                    model.fromMap(value)
                    self.compliance = model
                }
                if let value = dict["ConfigRuleArn"] as? String {
                    self.configRuleArn = value
                }
                if let value = dict["ConfigRuleId"] as? String {
                    self.configRuleId = value
                }
                if let value = dict["ConfigRuleName"] as? String {
                    self.configRuleName = value
                }
                if let value = dict["ConfigRuleState"] as? String {
                    self.configRuleState = value
                }
                if let value = dict["CreateBy"] as? [String: Any?] {
                    var model = ListAggregateConfigRulesResponseBody.ConfigRules.ConfigRuleList.CreateBy()
                    model.fromMap(value)
                    self.createBy = model
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["ResourceTypesScope"] as? String {
                    self.resourceTypesScope = value
                }
                if let value = dict["RiskLevel"] as? Int32 {
                    self.riskLevel = value
                }
                if let value = dict["SourceIdentifier"] as? String {
                    self.sourceIdentifier = value
                }
                if let value = dict["SourceOwner"] as? String {
                    self.sourceOwner = value
                }
                if let value = dict["Tags"] as? [Any?] {
                    var tmp : [ListAggregateConfigRulesResponseBody.ConfigRules.ConfigRuleList.Tags] = []
                    for v in value {
                        if v != nil {
                            var model = ListAggregateConfigRulesResponseBody.ConfigRules.ConfigRuleList.Tags()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.tags = tmp
                }
            }
        }
        public var configRuleList: [ListAggregateConfigRulesResponseBody.ConfigRules.ConfigRuleList]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.configRuleList != nil {
                var tmp : [Any] = []
                for k in self.configRuleList! {
                    tmp.append(k.toMap())
                }
                map["ConfigRuleList"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ConfigRuleList"] as? [Any?] {
                var tmp : [ListAggregateConfigRulesResponseBody.ConfigRules.ConfigRuleList] = []
                for v in value {
                    if v != nil {
                        var model = ListAggregateConfigRulesResponseBody.ConfigRules.ConfigRuleList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.configRuleList = tmp
            }
            if let value = dict["PageNumber"] as? Int32 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["TotalCount"] as? Int64 {
                self.totalCount = value
            }
        }
    }
    public var configRules: ListAggregateConfigRulesResponseBody.ConfigRules?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.configRules?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configRules != nil {
            map["ConfigRules"] = self.configRules?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ConfigRules"] as? [String: Any?] {
            var model = ListAggregateConfigRulesResponseBody.ConfigRules()
            model.fromMap(value)
            self.configRules = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListAggregateConfigRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAggregateConfigRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListAggregateConfigRulesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListAggregateDiscoveredResourcesRequest : Tea.TeaModel {
    public var aggregatorId: String?

    public var endUpdateTimestamp: Int64?

    public var excludeResourceTypes: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var regions: String?

    public var resourceAccountId: Int64?

    public var resourceDeleted: Int32?

    public var resourceId: String?

    public var resourceOwnerId: Int64?

    public var resourceTypes: String?

    public var startUpdateTimestamp: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aggregatorId != nil {
            map["AggregatorId"] = self.aggregatorId!
        }
        if self.endUpdateTimestamp != nil {
            map["EndUpdateTimestamp"] = self.endUpdateTimestamp!
        }
        if self.excludeResourceTypes != nil {
            map["ExcludeResourceTypes"] = self.excludeResourceTypes!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.regions != nil {
            map["Regions"] = self.regions!
        }
        if self.resourceAccountId != nil {
            map["ResourceAccountId"] = self.resourceAccountId!
        }
        if self.resourceDeleted != nil {
            map["ResourceDeleted"] = self.resourceDeleted!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceTypes != nil {
            map["ResourceTypes"] = self.resourceTypes!
        }
        if self.startUpdateTimestamp != nil {
            map["StartUpdateTimestamp"] = self.startUpdateTimestamp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AggregatorId"] as? String {
            self.aggregatorId = value
        }
        if let value = dict["EndUpdateTimestamp"] as? Int64 {
            self.endUpdateTimestamp = value
        }
        if let value = dict["ExcludeResourceTypes"] as? String {
            self.excludeResourceTypes = value
        }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["Regions"] as? String {
            self.regions = value
        }
        if let value = dict["ResourceAccountId"] as? Int64 {
            self.resourceAccountId = value
        }
        if let value = dict["ResourceDeleted"] as? Int32 {
            self.resourceDeleted = value
        }
        if let value = dict["ResourceId"] as? String {
            self.resourceId = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ResourceTypes"] as? String {
            self.resourceTypes = value
        }
        if let value = dict["StartUpdateTimestamp"] as? Int64 {
            self.startUpdateTimestamp = value
        }
    }
}

public class ListAggregateDiscoveredResourcesResponseBody : Tea.TeaModel {
    public class DiscoveredResourceProfiles : Tea.TeaModel {
        public class DiscoveredResourceProfileList : Tea.TeaModel {
            public var accountId: Int64?

            public var availabilityZone: String?

            public var region: String?

            public var resourceCreationTime: Int64?

            public var resourceDeleted: Int32?

            public var resourceId: String?

            public var resourceName: String?

            public var resourceOwnerId: Int64?

            public var resourceStatus: String?

            public var resourceType: String?

            public var tags: String?

            public var updateTime: Int64?

            public var vSwitchId: String?

            public var version: Int64?

            public var vpcId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.accountId != nil {
                    map["AccountId"] = self.accountId!
                }
                if self.availabilityZone != nil {
                    map["AvailabilityZone"] = self.availabilityZone!
                }
                if self.region != nil {
                    map["Region"] = self.region!
                }
                if self.resourceCreationTime != nil {
                    map["ResourceCreationTime"] = self.resourceCreationTime!
                }
                if self.resourceDeleted != nil {
                    map["ResourceDeleted"] = self.resourceDeleted!
                }
                if self.resourceId != nil {
                    map["ResourceId"] = self.resourceId!
                }
                if self.resourceName != nil {
                    map["ResourceName"] = self.resourceName!
                }
                if self.resourceOwnerId != nil {
                    map["ResourceOwnerId"] = self.resourceOwnerId!
                }
                if self.resourceStatus != nil {
                    map["ResourceStatus"] = self.resourceStatus!
                }
                if self.resourceType != nil {
                    map["ResourceType"] = self.resourceType!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.vSwitchId != nil {
                    map["VSwitchId"] = self.vSwitchId!
                }
                if self.version != nil {
                    map["Version"] = self.version!
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AccountId"] as? Int64 {
                    self.accountId = value
                }
                if let value = dict["AvailabilityZone"] as? String {
                    self.availabilityZone = value
                }
                if let value = dict["Region"] as? String {
                    self.region = value
                }
                if let value = dict["ResourceCreationTime"] as? Int64 {
                    self.resourceCreationTime = value
                }
                if let value = dict["ResourceDeleted"] as? Int32 {
                    self.resourceDeleted = value
                }
                if let value = dict["ResourceId"] as? String {
                    self.resourceId = value
                }
                if let value = dict["ResourceName"] as? String {
                    self.resourceName = value
                }
                if let value = dict["ResourceOwnerId"] as? Int64 {
                    self.resourceOwnerId = value
                }
                if let value = dict["ResourceStatus"] as? String {
                    self.resourceStatus = value
                }
                if let value = dict["ResourceType"] as? String {
                    self.resourceType = value
                }
                if let value = dict["Tags"] as? String {
                    self.tags = value
                }
                if let value = dict["UpdateTime"] as? Int64 {
                    self.updateTime = value
                }
                if let value = dict["VSwitchId"] as? String {
                    self.vSwitchId = value
                }
                if let value = dict["Version"] as? Int64 {
                    self.version = value
                }
                if let value = dict["VpcId"] as? String {
                    self.vpcId = value
                }
            }
        }
        public var discoveredResourceProfileList: [ListAggregateDiscoveredResourcesResponseBody.DiscoveredResourceProfiles.DiscoveredResourceProfileList]?

        public var maxResults: Int32?

        public var nextToken: String?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.discoveredResourceProfileList != nil {
                var tmp : [Any] = []
                for k in self.discoveredResourceProfileList! {
                    tmp.append(k.toMap())
                }
                map["DiscoveredResourceProfileList"] = tmp
            }
            if self.maxResults != nil {
                map["MaxResults"] = self.maxResults!
            }
            if self.nextToken != nil {
                map["NextToken"] = self.nextToken!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DiscoveredResourceProfileList"] as? [Any?] {
                var tmp : [ListAggregateDiscoveredResourcesResponseBody.DiscoveredResourceProfiles.DiscoveredResourceProfileList] = []
                for v in value {
                    if v != nil {
                        var model = ListAggregateDiscoveredResourcesResponseBody.DiscoveredResourceProfiles.DiscoveredResourceProfileList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.discoveredResourceProfileList = tmp
            }
            if let value = dict["MaxResults"] as? Int32 {
                self.maxResults = value
            }
            if let value = dict["NextToken"] as? String {
                self.nextToken = value
            }
            if let value = dict["TotalCount"] as? Int32 {
                self.totalCount = value
            }
        }
    }
    public var discoveredResourceProfiles: ListAggregateDiscoveredResourcesResponseBody.DiscoveredResourceProfiles?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.discoveredResourceProfiles?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.discoveredResourceProfiles != nil {
            map["DiscoveredResourceProfiles"] = self.discoveredResourceProfiles?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DiscoveredResourceProfiles"] as? [String: Any?] {
            var model = ListAggregateDiscoveredResourcesResponseBody.DiscoveredResourceProfiles()
            model.fromMap(value)
            self.discoveredResourceProfiles = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListAggregateDiscoveredResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAggregateDiscoveredResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListAggregateDiscoveredResourcesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListAggregateRemediationExecutionsRequest : Tea.TeaModel {
    public var aggregatorId: String?

    public var configRuleId: String?

    public var executionStatus: String?

    public var maxResults: Int64?

    public var nextToken: String?

    public var resourceAccountId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aggregatorId != nil {
            map["AggregatorId"] = self.aggregatorId!
        }
        if self.configRuleId != nil {
            map["ConfigRuleId"] = self.configRuleId!
        }
        if self.executionStatus != nil {
            map["ExecutionStatus"] = self.executionStatus!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.resourceAccountId != nil {
            map["ResourceAccountId"] = self.resourceAccountId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AggregatorId"] as? String {
            self.aggregatorId = value
        }
        if let value = dict["ConfigRuleId"] as? String {
            self.configRuleId = value
        }
        if let value = dict["ExecutionStatus"] as? String {
            self.executionStatus = value
        }
        if let value = dict["MaxResults"] as? Int64 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["ResourceAccountId"] as? Int64 {
            self.resourceAccountId = value
        }
    }
}

public class ListAggregateRemediationExecutionsResponseBody : Tea.TeaModel {
    public class RemediationExecutionData : Tea.TeaModel {
        public class RemediationExecutions : Tea.TeaModel {
            public var executionCreateDate: String?

            public var executionInvocationId: String?

            public var executionResourceIds: String?

            public var executionResourceType: String?

            public var executionStatus: String?

            public var executionStatusMessage: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.executionCreateDate != nil {
                    map["ExecutionCreateDate"] = self.executionCreateDate!
                }
                if self.executionInvocationId != nil {
                    map["ExecutionInvocationId"] = self.executionInvocationId!
                }
                if self.executionResourceIds != nil {
                    map["ExecutionResourceIds"] = self.executionResourceIds!
                }
                if self.executionResourceType != nil {
                    map["ExecutionResourceType"] = self.executionResourceType!
                }
                if self.executionStatus != nil {
                    map["ExecutionStatus"] = self.executionStatus!
                }
                if self.executionStatusMessage != nil {
                    map["ExecutionStatusMessage"] = self.executionStatusMessage!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ExecutionCreateDate"] as? String {
                    self.executionCreateDate = value
                }
                if let value = dict["ExecutionInvocationId"] as? String {
                    self.executionInvocationId = value
                }
                if let value = dict["ExecutionResourceIds"] as? String {
                    self.executionResourceIds = value
                }
                if let value = dict["ExecutionResourceType"] as? String {
                    self.executionResourceType = value
                }
                if let value = dict["ExecutionStatus"] as? String {
                    self.executionStatus = value
                }
                if let value = dict["ExecutionStatusMessage"] as? String {
                    self.executionStatusMessage = value
                }
            }
        }
        public var maxResults: Int64?

        public var nextToken: String?

        public var remediationExecutions: [ListAggregateRemediationExecutionsResponseBody.RemediationExecutionData.RemediationExecutions]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.maxResults != nil {
                map["MaxResults"] = self.maxResults!
            }
            if self.nextToken != nil {
                map["NextToken"] = self.nextToken!
            }
            if self.remediationExecutions != nil {
                var tmp : [Any] = []
                for k in self.remediationExecutions! {
                    tmp.append(k.toMap())
                }
                map["RemediationExecutions"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["MaxResults"] as? Int64 {
                self.maxResults = value
            }
            if let value = dict["NextToken"] as? String {
                self.nextToken = value
            }
            if let value = dict["RemediationExecutions"] as? [Any?] {
                var tmp : [ListAggregateRemediationExecutionsResponseBody.RemediationExecutionData.RemediationExecutions] = []
                for v in value {
                    if v != nil {
                        var model = ListAggregateRemediationExecutionsResponseBody.RemediationExecutionData.RemediationExecutions()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.remediationExecutions = tmp
            }
        }
    }
    public var remediationExecutionData: ListAggregateRemediationExecutionsResponseBody.RemediationExecutionData?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.remediationExecutionData?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.remediationExecutionData != nil {
            map["RemediationExecutionData"] = self.remediationExecutionData?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RemediationExecutionData"] as? [String: Any?] {
            var model = ListAggregateRemediationExecutionsResponseBody.RemediationExecutionData()
            model.fromMap(value)
            self.remediationExecutionData = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListAggregateRemediationExecutionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAggregateRemediationExecutionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListAggregateRemediationExecutionsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListAggregateRemediationsRequest : Tea.TeaModel {
    public var aggregatorId: String?

    public var configRuleIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aggregatorId != nil {
            map["AggregatorId"] = self.aggregatorId!
        }
        if self.configRuleIds != nil {
            map["ConfigRuleIds"] = self.configRuleIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AggregatorId"] as? String {
            self.aggregatorId = value
        }
        if let value = dict["ConfigRuleIds"] as? String {
            self.configRuleIds = value
        }
    }
}

public class ListAggregateRemediationsResponseBody : Tea.TeaModel {
    public class Remediations : Tea.TeaModel {
        public var accountId: Int64?

        public var aggregatorId: String?

        public var configRuleId: String?

        public var invokeType: String?

        public var lastSuccessfulInvocationId: String?

        public var lastSuccessfulInvocationTime: Int64?

        public var lastSuccessfulInvocationType: String?

        public var remediaitonOriginParams: String?

        public var remediationId: String?

        public var remediationSourceType: String?

        public var remediationTemplateId: String?

        public var remediationType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["AccountId"] = self.accountId!
            }
            if self.aggregatorId != nil {
                map["AggregatorId"] = self.aggregatorId!
            }
            if self.configRuleId != nil {
                map["ConfigRuleId"] = self.configRuleId!
            }
            if self.invokeType != nil {
                map["InvokeType"] = self.invokeType!
            }
            if self.lastSuccessfulInvocationId != nil {
                map["LastSuccessfulInvocationId"] = self.lastSuccessfulInvocationId!
            }
            if self.lastSuccessfulInvocationTime != nil {
                map["LastSuccessfulInvocationTime"] = self.lastSuccessfulInvocationTime!
            }
            if self.lastSuccessfulInvocationType != nil {
                map["LastSuccessfulInvocationType"] = self.lastSuccessfulInvocationType!
            }
            if self.remediaitonOriginParams != nil {
                map["RemediaitonOriginParams"] = self.remediaitonOriginParams!
            }
            if self.remediationId != nil {
                map["RemediationId"] = self.remediationId!
            }
            if self.remediationSourceType != nil {
                map["RemediationSourceType"] = self.remediationSourceType!
            }
            if self.remediationTemplateId != nil {
                map["RemediationTemplateId"] = self.remediationTemplateId!
            }
            if self.remediationType != nil {
                map["RemediationType"] = self.remediationType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AccountId"] as? Int64 {
                self.accountId = value
            }
            if let value = dict["AggregatorId"] as? String {
                self.aggregatorId = value
            }
            if let value = dict["ConfigRuleId"] as? String {
                self.configRuleId = value
            }
            if let value = dict["InvokeType"] as? String {
                self.invokeType = value
            }
            if let value = dict["LastSuccessfulInvocationId"] as? String {
                self.lastSuccessfulInvocationId = value
            }
            if let value = dict["LastSuccessfulInvocationTime"] as? Int64 {
                self.lastSuccessfulInvocationTime = value
            }
            if let value = dict["LastSuccessfulInvocationType"] as? String {
                self.lastSuccessfulInvocationType = value
            }
            if let value = dict["RemediaitonOriginParams"] as? String {
                self.remediaitonOriginParams = value
            }
            if let value = dict["RemediationId"] as? String {
                self.remediationId = value
            }
            if let value = dict["RemediationSourceType"] as? String {
                self.remediationSourceType = value
            }
            if let value = dict["RemediationTemplateId"] as? String {
                self.remediationTemplateId = value
            }
            if let value = dict["RemediationType"] as? String {
                self.remediationType = value
            }
        }
    }
    public var remediations: [ListAggregateRemediationsResponseBody.Remediations]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.remediations != nil {
            var tmp : [Any] = []
            for k in self.remediations! {
                tmp.append(k.toMap())
            }
            map["Remediations"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Remediations"] as? [Any?] {
            var tmp : [ListAggregateRemediationsResponseBody.Remediations] = []
            for v in value {
                if v != nil {
                    var model = ListAggregateRemediationsResponseBody.Remediations()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.remediations = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListAggregateRemediationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAggregateRemediationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListAggregateRemediationsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListAggregateResourceEvaluationResultsRequest : Tea.TeaModel {
    public var aggregatorId: String?

    public var complianceType: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var region: String?

    public var resourceId: String?

    public var resourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aggregatorId != nil {
            map["AggregatorId"] = self.aggregatorId!
        }
        if self.complianceType != nil {
            map["ComplianceType"] = self.complianceType!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AggregatorId"] as? String {
            self.aggregatorId = value
        }
        if let value = dict["ComplianceType"] as? String {
            self.complianceType = value
        }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["Region"] as? String {
            self.region = value
        }
        if let value = dict["ResourceId"] as? String {
            self.resourceId = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
    }
}

public class ListAggregateResourceEvaluationResultsResponseBody : Tea.TeaModel {
    public class EvaluationResults : Tea.TeaModel {
        public class EvaluationResultList : Tea.TeaModel {
            public class EvaluationResultIdentifier : Tea.TeaModel {
                public class EvaluationResultQualifier : Tea.TeaModel {
                    public var configRuleArn: String?

                    public var configRuleId: String?

                    public var configRuleName: String?

                    public var ignoreDate: String?

                    public var regionId: String?

                    public var resourceId: String?

                    public var resourceName: String?

                    public var resourceType: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.configRuleArn != nil {
                            map["ConfigRuleArn"] = self.configRuleArn!
                        }
                        if self.configRuleId != nil {
                            map["ConfigRuleId"] = self.configRuleId!
                        }
                        if self.configRuleName != nil {
                            map["ConfigRuleName"] = self.configRuleName!
                        }
                        if self.ignoreDate != nil {
                            map["IgnoreDate"] = self.ignoreDate!
                        }
                        if self.regionId != nil {
                            map["RegionId"] = self.regionId!
                        }
                        if self.resourceId != nil {
                            map["ResourceId"] = self.resourceId!
                        }
                        if self.resourceName != nil {
                            map["ResourceName"] = self.resourceName!
                        }
                        if self.resourceType != nil {
                            map["ResourceType"] = self.resourceType!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["ConfigRuleArn"] as? String {
                            self.configRuleArn = value
                        }
                        if let value = dict["ConfigRuleId"] as? String {
                            self.configRuleId = value
                        }
                        if let value = dict["ConfigRuleName"] as? String {
                            self.configRuleName = value
                        }
                        if let value = dict["IgnoreDate"] as? String {
                            self.ignoreDate = value
                        }
                        if let value = dict["RegionId"] as? String {
                            self.regionId = value
                        }
                        if let value = dict["ResourceId"] as? String {
                            self.resourceId = value
                        }
                        if let value = dict["ResourceName"] as? String {
                            self.resourceName = value
                        }
                        if let value = dict["ResourceType"] as? String {
                            self.resourceType = value
                        }
                    }
                }
                public var evaluationResultQualifier: ListAggregateResourceEvaluationResultsResponseBody.EvaluationResults.EvaluationResultList.EvaluationResultIdentifier.EvaluationResultQualifier?

                public var orderingTimestamp: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.evaluationResultQualifier?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.evaluationResultQualifier != nil {
                        map["EvaluationResultQualifier"] = self.evaluationResultQualifier?.toMap()
                    }
                    if self.orderingTimestamp != nil {
                        map["OrderingTimestamp"] = self.orderingTimestamp!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["EvaluationResultQualifier"] as? [String: Any?] {
                        var model = ListAggregateResourceEvaluationResultsResponseBody.EvaluationResults.EvaluationResultList.EvaluationResultIdentifier.EvaluationResultQualifier()
                        model.fromMap(value)
                        self.evaluationResultQualifier = model
                    }
                    if let value = dict["OrderingTimestamp"] as? Int64 {
                        self.orderingTimestamp = value
                    }
                }
            }
            public var annotation: String?

            public var complianceType: String?

            public var configRuleInvokedTimestamp: Int64?

            public var evaluationId: String?

            public var evaluationResultIdentifier: ListAggregateResourceEvaluationResultsResponseBody.EvaluationResults.EvaluationResultList.EvaluationResultIdentifier?

            public var invokingEventMessageType: String?

            public var lastNonCompliantRecordTimestamp: Int64?

            public var remediationEnabled: Bool?

            public var resultRecordedTimestamp: Int64?

            public var riskLevel: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.evaluationResultIdentifier?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.annotation != nil {
                    map["Annotation"] = self.annotation!
                }
                if self.complianceType != nil {
                    map["ComplianceType"] = self.complianceType!
                }
                if self.configRuleInvokedTimestamp != nil {
                    map["ConfigRuleInvokedTimestamp"] = self.configRuleInvokedTimestamp!
                }
                if self.evaluationId != nil {
                    map["EvaluationId"] = self.evaluationId!
                }
                if self.evaluationResultIdentifier != nil {
                    map["EvaluationResultIdentifier"] = self.evaluationResultIdentifier?.toMap()
                }
                if self.invokingEventMessageType != nil {
                    map["InvokingEventMessageType"] = self.invokingEventMessageType!
                }
                if self.lastNonCompliantRecordTimestamp != nil {
                    map["LastNonCompliantRecordTimestamp"] = self.lastNonCompliantRecordTimestamp!
                }
                if self.remediationEnabled != nil {
                    map["RemediationEnabled"] = self.remediationEnabled!
                }
                if self.resultRecordedTimestamp != nil {
                    map["ResultRecordedTimestamp"] = self.resultRecordedTimestamp!
                }
                if self.riskLevel != nil {
                    map["RiskLevel"] = self.riskLevel!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Annotation"] as? String {
                    self.annotation = value
                }
                if let value = dict["ComplianceType"] as? String {
                    self.complianceType = value
                }
                if let value = dict["ConfigRuleInvokedTimestamp"] as? Int64 {
                    self.configRuleInvokedTimestamp = value
                }
                if let value = dict["EvaluationId"] as? String {
                    self.evaluationId = value
                }
                if let value = dict["EvaluationResultIdentifier"] as? [String: Any?] {
                    var model = ListAggregateResourceEvaluationResultsResponseBody.EvaluationResults.EvaluationResultList.EvaluationResultIdentifier()
                    model.fromMap(value)
                    self.evaluationResultIdentifier = model
                }
                if let value = dict["InvokingEventMessageType"] as? String {
                    self.invokingEventMessageType = value
                }
                if let value = dict["LastNonCompliantRecordTimestamp"] as? Int64 {
                    self.lastNonCompliantRecordTimestamp = value
                }
                if let value = dict["RemediationEnabled"] as? Bool {
                    self.remediationEnabled = value
                }
                if let value = dict["ResultRecordedTimestamp"] as? Int64 {
                    self.resultRecordedTimestamp = value
                }
                if let value = dict["RiskLevel"] as? Int32 {
                    self.riskLevel = value
                }
            }
        }
        public var evaluationResultList: [ListAggregateResourceEvaluationResultsResponseBody.EvaluationResults.EvaluationResultList]?

        public var maxResults: Int32?

        public var nextToken: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.evaluationResultList != nil {
                var tmp : [Any] = []
                for k in self.evaluationResultList! {
                    tmp.append(k.toMap())
                }
                map["EvaluationResultList"] = tmp
            }
            if self.maxResults != nil {
                map["MaxResults"] = self.maxResults!
            }
            if self.nextToken != nil {
                map["NextToken"] = self.nextToken!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["EvaluationResultList"] as? [Any?] {
                var tmp : [ListAggregateResourceEvaluationResultsResponseBody.EvaluationResults.EvaluationResultList] = []
                for v in value {
                    if v != nil {
                        var model = ListAggregateResourceEvaluationResultsResponseBody.EvaluationResults.EvaluationResultList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.evaluationResultList = tmp
            }
            if let value = dict["MaxResults"] as? Int32 {
                self.maxResults = value
            }
            if let value = dict["NextToken"] as? String {
                self.nextToken = value
            }
        }
    }
    public var evaluationResults: ListAggregateResourceEvaluationResultsResponseBody.EvaluationResults?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.evaluationResults?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.evaluationResults != nil {
            map["EvaluationResults"] = self.evaluationResults?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EvaluationResults"] as? [String: Any?] {
            var model = ListAggregateResourceEvaluationResultsResponseBody.EvaluationResults()
            model.fromMap(value)
            self.evaluationResults = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListAggregateResourceEvaluationResultsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAggregateResourceEvaluationResultsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListAggregateResourceEvaluationResultsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListAggregateResourceRelationsRequest : Tea.TeaModel {
    public var aggregatorId: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var region: String?

    public var relationType: String?

    public var resourceAccountId: Int64?

    public var resourceId: String?

    public var resourceType: String?

    public var targetResourceId: String?

    public var targetResourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aggregatorId != nil {
            map["AggregatorId"] = self.aggregatorId!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.relationType != nil {
            map["RelationType"] = self.relationType!
        }
        if self.resourceAccountId != nil {
            map["ResourceAccountId"] = self.resourceAccountId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.targetResourceId != nil {
            map["TargetResourceId"] = self.targetResourceId!
        }
        if self.targetResourceType != nil {
            map["TargetResourceType"] = self.targetResourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AggregatorId"] as? String {
            self.aggregatorId = value
        }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["Region"] as? String {
            self.region = value
        }
        if let value = dict["RelationType"] as? String {
            self.relationType = value
        }
        if let value = dict["ResourceAccountId"] as? Int64 {
            self.resourceAccountId = value
        }
        if let value = dict["ResourceId"] as? String {
            self.resourceId = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
        if let value = dict["TargetResourceId"] as? String {
            self.targetResourceId = value
        }
        if let value = dict["TargetResourceType"] as? String {
            self.targetResourceType = value
        }
    }
}

public class ListAggregateResourceRelationsResponseBody : Tea.TeaModel {
    public class ResourceRelations : Tea.TeaModel {
        public class ResourceRelationList : Tea.TeaModel {
            public var accountId: Int64?

            public var relationType: String?

            public var sourceResourceId: String?

            public var sourceResourceRegionId: String?

            public var sourceResourceType: String?

            public var targetResourceId: String?

            public var targetResourceType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.accountId != nil {
                    map["AccountId"] = self.accountId!
                }
                if self.relationType != nil {
                    map["RelationType"] = self.relationType!
                }
                if self.sourceResourceId != nil {
                    map["SourceResourceId"] = self.sourceResourceId!
                }
                if self.sourceResourceRegionId != nil {
                    map["SourceResourceRegionId"] = self.sourceResourceRegionId!
                }
                if self.sourceResourceType != nil {
                    map["SourceResourceType"] = self.sourceResourceType!
                }
                if self.targetResourceId != nil {
                    map["TargetResourceId"] = self.targetResourceId!
                }
                if self.targetResourceType != nil {
                    map["TargetResourceType"] = self.targetResourceType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AccountId"] as? Int64 {
                    self.accountId = value
                }
                if let value = dict["RelationType"] as? String {
                    self.relationType = value
                }
                if let value = dict["SourceResourceId"] as? String {
                    self.sourceResourceId = value
                }
                if let value = dict["SourceResourceRegionId"] as? String {
                    self.sourceResourceRegionId = value
                }
                if let value = dict["SourceResourceType"] as? String {
                    self.sourceResourceType = value
                }
                if let value = dict["TargetResourceId"] as? String {
                    self.targetResourceId = value
                }
                if let value = dict["TargetResourceType"] as? String {
                    self.targetResourceType = value
                }
            }
        }
        public var maxResults: Int32?

        public var nextToken: String?

        public var resourceRelationList: [ListAggregateResourceRelationsResponseBody.ResourceRelations.ResourceRelationList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.maxResults != nil {
                map["MaxResults"] = self.maxResults!
            }
            if self.nextToken != nil {
                map["NextToken"] = self.nextToken!
            }
            if self.resourceRelationList != nil {
                var tmp : [Any] = []
                for k in self.resourceRelationList! {
                    tmp.append(k.toMap())
                }
                map["ResourceRelationList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["MaxResults"] as? Int32 {
                self.maxResults = value
            }
            if let value = dict["NextToken"] as? String {
                self.nextToken = value
            }
            if let value = dict["ResourceRelationList"] as? [Any?] {
                var tmp : [ListAggregateResourceRelationsResponseBody.ResourceRelations.ResourceRelationList] = []
                for v in value {
                    if v != nil {
                        var model = ListAggregateResourceRelationsResponseBody.ResourceRelations.ResourceRelationList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.resourceRelationList = tmp
            }
        }
    }
    public var requestId: String?

    public var resourceRelations: ListAggregateResourceRelationsResponseBody.ResourceRelations?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resourceRelations?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceRelations != nil {
            map["ResourceRelations"] = self.resourceRelations?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ResourceRelations"] as? [String: Any?] {
            var model = ListAggregateResourceRelationsResponseBody.ResourceRelations()
            model.fromMap(value)
            self.resourceRelations = model
        }
    }
}

public class ListAggregateResourceRelationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAggregateResourceRelationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListAggregateResourceRelationsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListAggregateResourcesByAdvancedSearchRequest : Tea.TeaModel {
    public var aggregatorId: String?

    public var sql: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aggregatorId != nil {
            map["AggregatorId"] = self.aggregatorId!
        }
        if self.sql != nil {
            map["Sql"] = self.sql!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AggregatorId"] as? String {
            self.aggregatorId = value
        }
        if let value = dict["Sql"] as? String {
            self.sql = value
        }
    }
}

public class ListAggregateResourcesByAdvancedSearchResponseBody : Tea.TeaModel {
    public class QueryResults : Tea.TeaModel {
        public class QueryResultList : Tea.TeaModel {
            public var columns: [String]?

            public var values: [Any]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.columns != nil {
                    map["Columns"] = self.columns!
                }
                if self.values != nil {
                    map["Values"] = self.values!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Columns"] as? [String] {
                    self.columns = value
                }
                if let value = dict["Values"] as? [Any] {
                    self.values = value
                }
            }
        }
        public var queryResultList: ListAggregateResourcesByAdvancedSearchResponseBody.QueryResults.QueryResultList?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.queryResultList?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.queryResultList != nil {
                map["QueryResultList"] = self.queryResultList?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["QueryResultList"] as? [String: Any?] {
                var model = ListAggregateResourcesByAdvancedSearchResponseBody.QueryResults.QueryResultList()
                model.fromMap(value)
                self.queryResultList = model
            }
        }
    }
    public var queryResults: ListAggregateResourcesByAdvancedSearchResponseBody.QueryResults?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.queryResults?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.queryResults != nil {
            map["QueryResults"] = self.queryResults?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["QueryResults"] as? [String: Any?] {
            var model = ListAggregateResourcesByAdvancedSearchResponseBody.QueryResults()
            model.fromMap(value)
            self.queryResults = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListAggregateResourcesByAdvancedSearchResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAggregateResourcesByAdvancedSearchResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListAggregateResourcesByAdvancedSearchResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListAggregatorsRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var maxResults: Int32?

    public var nextToken: String?

    public var tag: [ListAggregatorsRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [ListAggregatorsRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = ListAggregatorsRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
    }
}

public class ListAggregatorsShrinkRequest : Tea.TeaModel {
    public var maxResults: Int32?

    public var nextToken: String?

    public var tagShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.tagShrink != nil {
            map["Tag"] = self.tagShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["Tag"] as? String {
            self.tagShrink = value
        }
    }
}

public class ListAggregatorsResponseBody : Tea.TeaModel {
    public class AggregatorsResult : Tea.TeaModel {
        public class Aggregators : Tea.TeaModel {
            public class Tags : Tea.TeaModel {
                public var tagKey: String?

                public var tagValue: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tagKey != nil {
                        map["TagKey"] = self.tagKey!
                    }
                    if self.tagValue != nil {
                        map["TagValue"] = self.tagValue!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["TagKey"] as? String {
                        self.tagKey = value
                    }
                    if let value = dict["TagValue"] as? String {
                        self.tagValue = value
                    }
                }
            }
            public var accountId: Int64?

            public var aggregatorAccountCount: Int64?

            public var aggregatorCreateTimestamp: Int64?

            public var aggregatorId: String?

            public var aggregatorName: String?

            public var aggregatorStatus: Int32?

            public var aggregatorType: String?

            public var description_: String?

            public var folderId: String?

            public var tags: [ListAggregatorsResponseBody.AggregatorsResult.Aggregators.Tags]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.accountId != nil {
                    map["AccountId"] = self.accountId!
                }
                if self.aggregatorAccountCount != nil {
                    map["AggregatorAccountCount"] = self.aggregatorAccountCount!
                }
                if self.aggregatorCreateTimestamp != nil {
                    map["AggregatorCreateTimestamp"] = self.aggregatorCreateTimestamp!
                }
                if self.aggregatorId != nil {
                    map["AggregatorId"] = self.aggregatorId!
                }
                if self.aggregatorName != nil {
                    map["AggregatorName"] = self.aggregatorName!
                }
                if self.aggregatorStatus != nil {
                    map["AggregatorStatus"] = self.aggregatorStatus!
                }
                if self.aggregatorType != nil {
                    map["AggregatorType"] = self.aggregatorType!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.folderId != nil {
                    map["FolderId"] = self.folderId!
                }
                if self.tags != nil {
                    var tmp : [Any] = []
                    for k in self.tags! {
                        tmp.append(k.toMap())
                    }
                    map["Tags"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AccountId"] as? Int64 {
                    self.accountId = value
                }
                if let value = dict["AggregatorAccountCount"] as? Int64 {
                    self.aggregatorAccountCount = value
                }
                if let value = dict["AggregatorCreateTimestamp"] as? Int64 {
                    self.aggregatorCreateTimestamp = value
                }
                if let value = dict["AggregatorId"] as? String {
                    self.aggregatorId = value
                }
                if let value = dict["AggregatorName"] as? String {
                    self.aggregatorName = value
                }
                if let value = dict["AggregatorStatus"] as? Int32 {
                    self.aggregatorStatus = value
                }
                if let value = dict["AggregatorType"] as? String {
                    self.aggregatorType = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["FolderId"] as? String {
                    self.folderId = value
                }
                if let value = dict["Tags"] as? [Any?] {
                    var tmp : [ListAggregatorsResponseBody.AggregatorsResult.Aggregators.Tags] = []
                    for v in value {
                        if v != nil {
                            var model = ListAggregatorsResponseBody.AggregatorsResult.Aggregators.Tags()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.tags = tmp
                }
            }
        }
        public var aggregators: [ListAggregatorsResponseBody.AggregatorsResult.Aggregators]?

        public var nextToken: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aggregators != nil {
                var tmp : [Any] = []
                for k in self.aggregators! {
                    tmp.append(k.toMap())
                }
                map["Aggregators"] = tmp
            }
            if self.nextToken != nil {
                map["NextToken"] = self.nextToken!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Aggregators"] as? [Any?] {
                var tmp : [ListAggregatorsResponseBody.AggregatorsResult.Aggregators] = []
                for v in value {
                    if v != nil {
                        var model = ListAggregatorsResponseBody.AggregatorsResult.Aggregators()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.aggregators = tmp
            }
            if let value = dict["NextToken"] as? String {
                self.nextToken = value
            }
        }
    }
    public var aggregatorsResult: ListAggregatorsResponseBody.AggregatorsResult?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.aggregatorsResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aggregatorsResult != nil {
            map["AggregatorsResult"] = self.aggregatorsResult?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AggregatorsResult"] as? [String: Any?] {
            var model = ListAggregatorsResponseBody.AggregatorsResult()
            model.fromMap(value)
            self.aggregatorsResult = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListAggregatorsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAggregatorsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListAggregatorsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListCompliancePackTemplatesRequest : Tea.TeaModel {
    public var compliancePackTemplateId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var resourceTypes: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.compliancePackTemplateId != nil {
            map["CompliancePackTemplateId"] = self.compliancePackTemplateId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceTypes != nil {
            map["ResourceTypes"] = self.resourceTypes!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CompliancePackTemplateId"] as? String {
            self.compliancePackTemplateId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ResourceTypes"] as? String {
            self.resourceTypes = value
        }
    }
}

public class ListCompliancePackTemplatesResponseBody : Tea.TeaModel {
    public class CompliancePackTemplatesResult : Tea.TeaModel {
        public class CompliancePackTemplates : Tea.TeaModel {
            public class ConfigRules : Tea.TeaModel {
                public class ConfigRuleParameters : Tea.TeaModel {
                    public var parameterName: String?

                    public var parameterValue: String?

                    public var required_: Bool?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.parameterName != nil {
                            map["ParameterName"] = self.parameterName!
                        }
                        if self.parameterValue != nil {
                            map["ParameterValue"] = self.parameterValue!
                        }
                        if self.required_ != nil {
                            map["Required"] = self.required_!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["ParameterName"] as? String {
                            self.parameterName = value
                        }
                        if let value = dict["ParameterValue"] as? String {
                            self.parameterValue = value
                        }
                        if let value = dict["Required"] as? Bool {
                            self.required_ = value
                        }
                    }
                }
                public var configRuleParameters: [ListCompliancePackTemplatesResponseBody.CompliancePackTemplatesResult.CompliancePackTemplates.ConfigRules.ConfigRuleParameters]?

                public var controlDescription: String?

                public var controlId: String?

                public var defaultEnable: Bool?

                public var description_: String?

                public var managedRuleIdentifier: String?

                public var managedRuleName: String?

                public var resourceTypesScope: String?

                public var riskLevel: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.configRuleParameters != nil {
                        var tmp : [Any] = []
                        for k in self.configRuleParameters! {
                            tmp.append(k.toMap())
                        }
                        map["ConfigRuleParameters"] = tmp
                    }
                    if self.controlDescription != nil {
                        map["ControlDescription"] = self.controlDescription!
                    }
                    if self.controlId != nil {
                        map["ControlId"] = self.controlId!
                    }
                    if self.defaultEnable != nil {
                        map["DefaultEnable"] = self.defaultEnable!
                    }
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.managedRuleIdentifier != nil {
                        map["ManagedRuleIdentifier"] = self.managedRuleIdentifier!
                    }
                    if self.managedRuleName != nil {
                        map["ManagedRuleName"] = self.managedRuleName!
                    }
                    if self.resourceTypesScope != nil {
                        map["ResourceTypesScope"] = self.resourceTypesScope!
                    }
                    if self.riskLevel != nil {
                        map["RiskLevel"] = self.riskLevel!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ConfigRuleParameters"] as? [Any?] {
                        var tmp : [ListCompliancePackTemplatesResponseBody.CompliancePackTemplatesResult.CompliancePackTemplates.ConfigRules.ConfigRuleParameters] = []
                        for v in value {
                            if v != nil {
                                var model = ListCompliancePackTemplatesResponseBody.CompliancePackTemplatesResult.CompliancePackTemplates.ConfigRules.ConfigRuleParameters()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.configRuleParameters = tmp
                    }
                    if let value = dict["ControlDescription"] as? String {
                        self.controlDescription = value
                    }
                    if let value = dict["ControlId"] as? String {
                        self.controlId = value
                    }
                    if let value = dict["DefaultEnable"] as? Bool {
                        self.defaultEnable = value
                    }
                    if let value = dict["Description"] as? String {
                        self.description_ = value
                    }
                    if let value = dict["ManagedRuleIdentifier"] as? String {
                        self.managedRuleIdentifier = value
                    }
                    if let value = dict["ManagedRuleName"] as? String {
                        self.managedRuleName = value
                    }
                    if let value = dict["ResourceTypesScope"] as? String {
                        self.resourceTypesScope = value
                    }
                    if let value = dict["RiskLevel"] as? Int32 {
                        self.riskLevel = value
                    }
                }
            }
            public var compliancePackTemplateId: String?

            public var compliancePackTemplateName: String?

            public var configRules: [ListCompliancePackTemplatesResponseBody.CompliancePackTemplatesResult.CompliancePackTemplates.ConfigRules]?

            public var description_: String?

            public var labels: String?

            public var lastUpdate: Int32?

            public var riskLevel: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.compliancePackTemplateId != nil {
                    map["CompliancePackTemplateId"] = self.compliancePackTemplateId!
                }
                if self.compliancePackTemplateName != nil {
                    map["CompliancePackTemplateName"] = self.compliancePackTemplateName!
                }
                if self.configRules != nil {
                    var tmp : [Any] = []
                    for k in self.configRules! {
                        tmp.append(k.toMap())
                    }
                    map["ConfigRules"] = tmp
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.labels != nil {
                    map["Labels"] = self.labels!
                }
                if self.lastUpdate != nil {
                    map["LastUpdate"] = self.lastUpdate!
                }
                if self.riskLevel != nil {
                    map["RiskLevel"] = self.riskLevel!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CompliancePackTemplateId"] as? String {
                    self.compliancePackTemplateId = value
                }
                if let value = dict["CompliancePackTemplateName"] as? String {
                    self.compliancePackTemplateName = value
                }
                if let value = dict["ConfigRules"] as? [Any?] {
                    var tmp : [ListCompliancePackTemplatesResponseBody.CompliancePackTemplatesResult.CompliancePackTemplates.ConfigRules] = []
                    for v in value {
                        if v != nil {
                            var model = ListCompliancePackTemplatesResponseBody.CompliancePackTemplatesResult.CompliancePackTemplates.ConfigRules()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.configRules = tmp
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["Labels"] as? String {
                    self.labels = value
                }
                if let value = dict["LastUpdate"] as? Int32 {
                    self.lastUpdate = value
                }
                if let value = dict["RiskLevel"] as? Int32 {
                    self.riskLevel = value
                }
            }
        }
        public var compliancePackTemplates: [ListCompliancePackTemplatesResponseBody.CompliancePackTemplatesResult.CompliancePackTemplates]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.compliancePackTemplates != nil {
                var tmp : [Any] = []
                for k in self.compliancePackTemplates! {
                    tmp.append(k.toMap())
                }
                map["CompliancePackTemplates"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CompliancePackTemplates"] as? [Any?] {
                var tmp : [ListCompliancePackTemplatesResponseBody.CompliancePackTemplatesResult.CompliancePackTemplates] = []
                for v in value {
                    if v != nil {
                        var model = ListCompliancePackTemplatesResponseBody.CompliancePackTemplatesResult.CompliancePackTemplates()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.compliancePackTemplates = tmp
            }
            if let value = dict["PageNumber"] as? Int32 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["TotalCount"] as? Int64 {
                self.totalCount = value
            }
        }
    }
    public var compliancePackTemplatesResult: ListCompliancePackTemplatesResponseBody.CompliancePackTemplatesResult?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.compliancePackTemplatesResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.compliancePackTemplatesResult != nil {
            map["CompliancePackTemplatesResult"] = self.compliancePackTemplatesResult?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CompliancePackTemplatesResult"] as? [String: Any?] {
            var model = ListCompliancePackTemplatesResponseBody.CompliancePackTemplatesResult()
            model.fromMap(value)
            self.compliancePackTemplatesResult = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListCompliancePackTemplatesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListCompliancePackTemplatesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListCompliancePackTemplatesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListCompliancePacksRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var status: String?

    public var tag: [ListCompliancePacksRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [ListCompliancePacksRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = ListCompliancePacksRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
    }
}

public class ListCompliancePacksShrinkRequest : Tea.TeaModel {
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var status: String?

    public var tagShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.tagShrink != nil {
            map["Tag"] = self.tagShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
        if let value = dict["Tag"] as? String {
            self.tagShrink = value
        }
    }
}

public class ListCompliancePacksResponseBody : Tea.TeaModel {
    public class CompliancePacksResult : Tea.TeaModel {
        public class CompliancePacks : Tea.TeaModel {
            public class Tags : Tea.TeaModel {
                public var tagKey: String?

                public var tagValue: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tagKey != nil {
                        map["TagKey"] = self.tagKey!
                    }
                    if self.tagValue != nil {
                        map["TagValue"] = self.tagValue!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["TagKey"] as? String {
                        self.tagKey = value
                    }
                    if let value = dict["TagValue"] as? String {
                        self.tagValue = value
                    }
                }
            }
            public var accountId: Int64?

            public var compliancePackId: String?

            public var compliancePackName: String?

            public var compliancePackTemplateId: String?

            public var createTimestamp: Int64?

            public var description_: String?

            public var riskLevel: Int32?

            public var status: String?

            public var tags: [ListCompliancePacksResponseBody.CompliancePacksResult.CompliancePacks.Tags]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.accountId != nil {
                    map["AccountId"] = self.accountId!
                }
                if self.compliancePackId != nil {
                    map["CompliancePackId"] = self.compliancePackId!
                }
                if self.compliancePackName != nil {
                    map["CompliancePackName"] = self.compliancePackName!
                }
                if self.compliancePackTemplateId != nil {
                    map["CompliancePackTemplateId"] = self.compliancePackTemplateId!
                }
                if self.createTimestamp != nil {
                    map["CreateTimestamp"] = self.createTimestamp!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.riskLevel != nil {
                    map["RiskLevel"] = self.riskLevel!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.tags != nil {
                    var tmp : [Any] = []
                    for k in self.tags! {
                        tmp.append(k.toMap())
                    }
                    map["Tags"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AccountId"] as? Int64 {
                    self.accountId = value
                }
                if let value = dict["CompliancePackId"] as? String {
                    self.compliancePackId = value
                }
                if let value = dict["CompliancePackName"] as? String {
                    self.compliancePackName = value
                }
                if let value = dict["CompliancePackTemplateId"] as? String {
                    self.compliancePackTemplateId = value
                }
                if let value = dict["CreateTimestamp"] as? Int64 {
                    self.createTimestamp = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["RiskLevel"] as? Int32 {
                    self.riskLevel = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
                if let value = dict["Tags"] as? [Any?] {
                    var tmp : [ListCompliancePacksResponseBody.CompliancePacksResult.CompliancePacks.Tags] = []
                    for v in value {
                        if v != nil {
                            var model = ListCompliancePacksResponseBody.CompliancePacksResult.CompliancePacks.Tags()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.tags = tmp
                }
            }
        }
        public var compliancePacks: [ListCompliancePacksResponseBody.CompliancePacksResult.CompliancePacks]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.compliancePacks != nil {
                var tmp : [Any] = []
                for k in self.compliancePacks! {
                    tmp.append(k.toMap())
                }
                map["CompliancePacks"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CompliancePacks"] as? [Any?] {
                var tmp : [ListCompliancePacksResponseBody.CompliancePacksResult.CompliancePacks] = []
                for v in value {
                    if v != nil {
                        var model = ListCompliancePacksResponseBody.CompliancePacksResult.CompliancePacks()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.compliancePacks = tmp
            }
            if let value = dict["PageNumber"] as? Int32 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["TotalCount"] as? Int64 {
                self.totalCount = value
            }
        }
    }
    public var compliancePacksResult: ListCompliancePacksResponseBody.CompliancePacksResult?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.compliancePacksResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.compliancePacksResult != nil {
            map["CompliancePacksResult"] = self.compliancePacksResult?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CompliancePacksResult"] as? [String: Any?] {
            var model = ListCompliancePacksResponseBody.CompliancePacksResult()
            model.fromMap(value)
            self.compliancePacksResult = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListCompliancePacksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListCompliancePacksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListCompliancePacksResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListConfigDeliveryChannelsRequest : Tea.TeaModel {
    public var deliveryChannelIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deliveryChannelIds != nil {
            map["DeliveryChannelIds"] = self.deliveryChannelIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DeliveryChannelIds"] as? String {
            self.deliveryChannelIds = value
        }
    }
}

public class ListConfigDeliveryChannelsResponseBody : Tea.TeaModel {
    public class DeliveryChannels : Tea.TeaModel {
        public var accountId: Int64?

        public var compliantSnapshot: Bool?

        public var configurationItemChangeNotification: Bool?

        public var configurationSnapshot: Bool?

        public var deliveryChannelAssumeRoleArn: String?

        public var deliveryChannelCondition: String?

        public var deliveryChannelId: String?

        public var deliveryChannelName: String?

        public var deliveryChannelTargetArn: String?

        public var deliveryChannelType: String?

        public var deliverySnapshotTime: String?

        public var description_: String?

        public var nonCompliantNotification: Bool?

        public var oversizedDataOSSTargetArn: String?

        public var status: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["AccountId"] = self.accountId!
            }
            if self.compliantSnapshot != nil {
                map["CompliantSnapshot"] = self.compliantSnapshot!
            }
            if self.configurationItemChangeNotification != nil {
                map["ConfigurationItemChangeNotification"] = self.configurationItemChangeNotification!
            }
            if self.configurationSnapshot != nil {
                map["ConfigurationSnapshot"] = self.configurationSnapshot!
            }
            if self.deliveryChannelAssumeRoleArn != nil {
                map["DeliveryChannelAssumeRoleArn"] = self.deliveryChannelAssumeRoleArn!
            }
            if self.deliveryChannelCondition != nil {
                map["DeliveryChannelCondition"] = self.deliveryChannelCondition!
            }
            if self.deliveryChannelId != nil {
                map["DeliveryChannelId"] = self.deliveryChannelId!
            }
            if self.deliveryChannelName != nil {
                map["DeliveryChannelName"] = self.deliveryChannelName!
            }
            if self.deliveryChannelTargetArn != nil {
                map["DeliveryChannelTargetArn"] = self.deliveryChannelTargetArn!
            }
            if self.deliveryChannelType != nil {
                map["DeliveryChannelType"] = self.deliveryChannelType!
            }
            if self.deliverySnapshotTime != nil {
                map["DeliverySnapshotTime"] = self.deliverySnapshotTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.nonCompliantNotification != nil {
                map["NonCompliantNotification"] = self.nonCompliantNotification!
            }
            if self.oversizedDataOSSTargetArn != nil {
                map["OversizedDataOSSTargetArn"] = self.oversizedDataOSSTargetArn!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AccountId"] as? Int64 {
                self.accountId = value
            }
            if let value = dict["CompliantSnapshot"] as? Bool {
                self.compliantSnapshot = value
            }
            if let value = dict["ConfigurationItemChangeNotification"] as? Bool {
                self.configurationItemChangeNotification = value
            }
            if let value = dict["ConfigurationSnapshot"] as? Bool {
                self.configurationSnapshot = value
            }
            if let value = dict["DeliveryChannelAssumeRoleArn"] as? String {
                self.deliveryChannelAssumeRoleArn = value
            }
            if let value = dict["DeliveryChannelCondition"] as? String {
                self.deliveryChannelCondition = value
            }
            if let value = dict["DeliveryChannelId"] as? String {
                self.deliveryChannelId = value
            }
            if let value = dict["DeliveryChannelName"] as? String {
                self.deliveryChannelName = value
            }
            if let value = dict["DeliveryChannelTargetArn"] as? String {
                self.deliveryChannelTargetArn = value
            }
            if let value = dict["DeliveryChannelType"] as? String {
                self.deliveryChannelType = value
            }
            if let value = dict["DeliverySnapshotTime"] as? String {
                self.deliverySnapshotTime = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["NonCompliantNotification"] as? Bool {
                self.nonCompliantNotification = value
            }
            if let value = dict["OversizedDataOSSTargetArn"] as? String {
                self.oversizedDataOSSTargetArn = value
            }
            if let value = dict["Status"] as? Int32 {
                self.status = value
            }
        }
    }
    public var deliveryChannels: [ListConfigDeliveryChannelsResponseBody.DeliveryChannels]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deliveryChannels != nil {
            var tmp : [Any] = []
            for k in self.deliveryChannels! {
                tmp.append(k.toMap())
            }
            map["DeliveryChannels"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DeliveryChannels"] as? [Any?] {
            var tmp : [ListConfigDeliveryChannelsResponseBody.DeliveryChannels] = []
            for v in value {
                if v != nil {
                    var model = ListConfigDeliveryChannelsResponseBody.DeliveryChannels()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.deliveryChannels = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListConfigDeliveryChannelsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListConfigDeliveryChannelsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListConfigDeliveryChannelsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListConfigRuleEvaluationResultsRequest : Tea.TeaModel {
    public var compliancePackId: String?

    public var complianceType: String?

    public var configRuleId: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var regions: String?

    public var resourceGroupIds: String?

    public var resourceTypes: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.compliancePackId != nil {
            map["CompliancePackId"] = self.compliancePackId!
        }
        if self.complianceType != nil {
            map["ComplianceType"] = self.complianceType!
        }
        if self.configRuleId != nil {
            map["ConfigRuleId"] = self.configRuleId!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.regions != nil {
            map["Regions"] = self.regions!
        }
        if self.resourceGroupIds != nil {
            map["ResourceGroupIds"] = self.resourceGroupIds!
        }
        if self.resourceTypes != nil {
            map["ResourceTypes"] = self.resourceTypes!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CompliancePackId"] as? String {
            self.compliancePackId = value
        }
        if let value = dict["ComplianceType"] as? String {
            self.complianceType = value
        }
        if let value = dict["ConfigRuleId"] as? String {
            self.configRuleId = value
        }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["Regions"] as? String {
            self.regions = value
        }
        if let value = dict["ResourceGroupIds"] as? String {
            self.resourceGroupIds = value
        }
        if let value = dict["ResourceTypes"] as? String {
            self.resourceTypes = value
        }
    }
}

public class ListConfigRuleEvaluationResultsResponseBody : Tea.TeaModel {
    public class EvaluationResults : Tea.TeaModel {
        public class EvaluationResultList : Tea.TeaModel {
            public class EvaluationResultIdentifier : Tea.TeaModel {
                public class EvaluationResultQualifier : Tea.TeaModel {
                    public var compliancePackId: String?

                    public var configRuleArn: String?

                    public var configRuleId: String?

                    public var configRuleName: String?

                    public var ignoreDate: String?

                    public var regionId: String?

                    public var resourceGroupId: String?

                    public var resourceId: String?

                    public var resourceName: String?

                    public var resourceOwnerId: Int64?

                    public var resourceType: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.compliancePackId != nil {
                            map["CompliancePackId"] = self.compliancePackId!
                        }
                        if self.configRuleArn != nil {
                            map["ConfigRuleArn"] = self.configRuleArn!
                        }
                        if self.configRuleId != nil {
                            map["ConfigRuleId"] = self.configRuleId!
                        }
                        if self.configRuleName != nil {
                            map["ConfigRuleName"] = self.configRuleName!
                        }
                        if self.ignoreDate != nil {
                            map["IgnoreDate"] = self.ignoreDate!
                        }
                        if self.regionId != nil {
                            map["RegionId"] = self.regionId!
                        }
                        if self.resourceGroupId != nil {
                            map["ResourceGroupId"] = self.resourceGroupId!
                        }
                        if self.resourceId != nil {
                            map["ResourceId"] = self.resourceId!
                        }
                        if self.resourceName != nil {
                            map["ResourceName"] = self.resourceName!
                        }
                        if self.resourceOwnerId != nil {
                            map["ResourceOwnerId"] = self.resourceOwnerId!
                        }
                        if self.resourceType != nil {
                            map["ResourceType"] = self.resourceType!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["CompliancePackId"] as? String {
                            self.compliancePackId = value
                        }
                        if let value = dict["ConfigRuleArn"] as? String {
                            self.configRuleArn = value
                        }
                        if let value = dict["ConfigRuleId"] as? String {
                            self.configRuleId = value
                        }
                        if let value = dict["ConfigRuleName"] as? String {
                            self.configRuleName = value
                        }
                        if let value = dict["IgnoreDate"] as? String {
                            self.ignoreDate = value
                        }
                        if let value = dict["RegionId"] as? String {
                            self.regionId = value
                        }
                        if let value = dict["ResourceGroupId"] as? String {
                            self.resourceGroupId = value
                        }
                        if let value = dict["ResourceId"] as? String {
                            self.resourceId = value
                        }
                        if let value = dict["ResourceName"] as? String {
                            self.resourceName = value
                        }
                        if let value = dict["ResourceOwnerId"] as? Int64 {
                            self.resourceOwnerId = value
                        }
                        if let value = dict["ResourceType"] as? String {
                            self.resourceType = value
                        }
                    }
                }
                public var evaluationResultQualifier: ListConfigRuleEvaluationResultsResponseBody.EvaluationResults.EvaluationResultList.EvaluationResultIdentifier.EvaluationResultQualifier?

                public var orderingTimestamp: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.evaluationResultQualifier?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.evaluationResultQualifier != nil {
                        map["EvaluationResultQualifier"] = self.evaluationResultQualifier?.toMap()
                    }
                    if self.orderingTimestamp != nil {
                        map["OrderingTimestamp"] = self.orderingTimestamp!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["EvaluationResultQualifier"] as? [String: Any?] {
                        var model = ListConfigRuleEvaluationResultsResponseBody.EvaluationResults.EvaluationResultList.EvaluationResultIdentifier.EvaluationResultQualifier()
                        model.fromMap(value)
                        self.evaluationResultQualifier = model
                    }
                    if let value = dict["OrderingTimestamp"] as? Int64 {
                        self.orderingTimestamp = value
                    }
                }
            }
            public var annotation: String?

            public var complianceType: String?

            public var configRuleInvokedTimestamp: Int64?

            public var evaluationId: String?

            public var evaluationResultIdentifier: ListConfigRuleEvaluationResultsResponseBody.EvaluationResults.EvaluationResultList.EvaluationResultIdentifier?

            public var invokingEventMessageType: String?

            public var lastNonCompliantRecordTimestamp: Int64?

            public var remediationEnabled: Bool?

            public var resultRecordedTimestamp: Int64?

            public var riskLevel: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.evaluationResultIdentifier?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.annotation != nil {
                    map["Annotation"] = self.annotation!
                }
                if self.complianceType != nil {
                    map["ComplianceType"] = self.complianceType!
                }
                if self.configRuleInvokedTimestamp != nil {
                    map["ConfigRuleInvokedTimestamp"] = self.configRuleInvokedTimestamp!
                }
                if self.evaluationId != nil {
                    map["EvaluationId"] = self.evaluationId!
                }
                if self.evaluationResultIdentifier != nil {
                    map["EvaluationResultIdentifier"] = self.evaluationResultIdentifier?.toMap()
                }
                if self.invokingEventMessageType != nil {
                    map["InvokingEventMessageType"] = self.invokingEventMessageType!
                }
                if self.lastNonCompliantRecordTimestamp != nil {
                    map["LastNonCompliantRecordTimestamp"] = self.lastNonCompliantRecordTimestamp!
                }
                if self.remediationEnabled != nil {
                    map["RemediationEnabled"] = self.remediationEnabled!
                }
                if self.resultRecordedTimestamp != nil {
                    map["ResultRecordedTimestamp"] = self.resultRecordedTimestamp!
                }
                if self.riskLevel != nil {
                    map["RiskLevel"] = self.riskLevel!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Annotation"] as? String {
                    self.annotation = value
                }
                if let value = dict["ComplianceType"] as? String {
                    self.complianceType = value
                }
                if let value = dict["ConfigRuleInvokedTimestamp"] as? Int64 {
                    self.configRuleInvokedTimestamp = value
                }
                if let value = dict["EvaluationId"] as? String {
                    self.evaluationId = value
                }
                if let value = dict["EvaluationResultIdentifier"] as? [String: Any?] {
                    var model = ListConfigRuleEvaluationResultsResponseBody.EvaluationResults.EvaluationResultList.EvaluationResultIdentifier()
                    model.fromMap(value)
                    self.evaluationResultIdentifier = model
                }
                if let value = dict["InvokingEventMessageType"] as? String {
                    self.invokingEventMessageType = value
                }
                if let value = dict["LastNonCompliantRecordTimestamp"] as? Int64 {
                    self.lastNonCompliantRecordTimestamp = value
                }
                if let value = dict["RemediationEnabled"] as? Bool {
                    self.remediationEnabled = value
                }
                if let value = dict["ResultRecordedTimestamp"] as? Int64 {
                    self.resultRecordedTimestamp = value
                }
                if let value = dict["RiskLevel"] as? Int32 {
                    self.riskLevel = value
                }
            }
        }
        public var evaluationResultList: [ListConfigRuleEvaluationResultsResponseBody.EvaluationResults.EvaluationResultList]?

        public var maxResults: Int32?

        public var nextToken: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.evaluationResultList != nil {
                var tmp : [Any] = []
                for k in self.evaluationResultList! {
                    tmp.append(k.toMap())
                }
                map["EvaluationResultList"] = tmp
            }
            if self.maxResults != nil {
                map["MaxResults"] = self.maxResults!
            }
            if self.nextToken != nil {
                map["NextToken"] = self.nextToken!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["EvaluationResultList"] as? [Any?] {
                var tmp : [ListConfigRuleEvaluationResultsResponseBody.EvaluationResults.EvaluationResultList] = []
                for v in value {
                    if v != nil {
                        var model = ListConfigRuleEvaluationResultsResponseBody.EvaluationResults.EvaluationResultList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.evaluationResultList = tmp
            }
            if let value = dict["MaxResults"] as? Int32 {
                self.maxResults = value
            }
            if let value = dict["NextToken"] as? String {
                self.nextToken = value
            }
        }
    }
    public var evaluationResults: ListConfigRuleEvaluationResultsResponseBody.EvaluationResults?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.evaluationResults?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.evaluationResults != nil {
            map["EvaluationResults"] = self.evaluationResults?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EvaluationResults"] as? [String: Any?] {
            var model = ListConfigRuleEvaluationResultsResponseBody.EvaluationResults()
            model.fromMap(value)
            self.evaluationResults = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListConfigRuleEvaluationResultsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListConfigRuleEvaluationResultsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListConfigRuleEvaluationResultsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListConfigRuleEvaluationStatisticsResponseBody : Tea.TeaModel {
    public class EvaluationResults : Tea.TeaModel {
        public var nonCompliantResourceCnt: Int32?

        public var nonCompliantRuleCnt: Int32?

        public var statisticDate: String?

        public var totalResourceCnt: Int32?

        public var totalRuleCnt: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.nonCompliantResourceCnt != nil {
                map["NonCompliantResourceCnt"] = self.nonCompliantResourceCnt!
            }
            if self.nonCompliantRuleCnt != nil {
                map["NonCompliantRuleCnt"] = self.nonCompliantRuleCnt!
            }
            if self.statisticDate != nil {
                map["StatisticDate"] = self.statisticDate!
            }
            if self.totalResourceCnt != nil {
                map["TotalResourceCnt"] = self.totalResourceCnt!
            }
            if self.totalRuleCnt != nil {
                map["TotalRuleCnt"] = self.totalRuleCnt!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["NonCompliantResourceCnt"] as? Int32 {
                self.nonCompliantResourceCnt = value
            }
            if let value = dict["NonCompliantRuleCnt"] as? Int32 {
                self.nonCompliantRuleCnt = value
            }
            if let value = dict["StatisticDate"] as? String {
                self.statisticDate = value
            }
            if let value = dict["TotalResourceCnt"] as? Int32 {
                self.totalResourceCnt = value
            }
            if let value = dict["TotalRuleCnt"] as? Int32 {
                self.totalRuleCnt = value
            }
        }
    }
    public var evaluationResults: [ListConfigRuleEvaluationStatisticsResponseBody.EvaluationResults]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.evaluationResults != nil {
            var tmp : [Any] = []
            for k in self.evaluationResults! {
                tmp.append(k.toMap())
            }
            map["EvaluationResults"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EvaluationResults"] as? [Any?] {
            var tmp : [ListConfigRuleEvaluationStatisticsResponseBody.EvaluationResults] = []
            for v in value {
                if v != nil {
                    var model = ListConfigRuleEvaluationStatisticsResponseBody.EvaluationResults()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.evaluationResults = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListConfigRuleEvaluationStatisticsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListConfigRuleEvaluationStatisticsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListConfigRuleEvaluationStatisticsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListConfigRulesRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var compliancePackId: String?

    public var complianceType: String?

    public var configRuleName: String?

    public var configRuleState: String?

    public var keyword: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var resourceTypes: String?

    public var riskLevel: Int32?

    public var tag: [ListConfigRulesRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.compliancePackId != nil {
            map["CompliancePackId"] = self.compliancePackId!
        }
        if self.complianceType != nil {
            map["ComplianceType"] = self.complianceType!
        }
        if self.configRuleName != nil {
            map["ConfigRuleName"] = self.configRuleName!
        }
        if self.configRuleState != nil {
            map["ConfigRuleState"] = self.configRuleState!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceTypes != nil {
            map["ResourceTypes"] = self.resourceTypes!
        }
        if self.riskLevel != nil {
            map["RiskLevel"] = self.riskLevel!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CompliancePackId"] as? String {
            self.compliancePackId = value
        }
        if let value = dict["ComplianceType"] as? String {
            self.complianceType = value
        }
        if let value = dict["ConfigRuleName"] as? String {
            self.configRuleName = value
        }
        if let value = dict["ConfigRuleState"] as? String {
            self.configRuleState = value
        }
        if let value = dict["Keyword"] as? String {
            self.keyword = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ResourceTypes"] as? String {
            self.resourceTypes = value
        }
        if let value = dict["RiskLevel"] as? Int32 {
            self.riskLevel = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [ListConfigRulesRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = ListConfigRulesRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
    }
}

public class ListConfigRulesShrinkRequest : Tea.TeaModel {
    public var compliancePackId: String?

    public var complianceType: String?

    public var configRuleName: String?

    public var configRuleState: String?

    public var keyword: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var resourceTypes: String?

    public var riskLevel: Int32?

    public var tagShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.compliancePackId != nil {
            map["CompliancePackId"] = self.compliancePackId!
        }
        if self.complianceType != nil {
            map["ComplianceType"] = self.complianceType!
        }
        if self.configRuleName != nil {
            map["ConfigRuleName"] = self.configRuleName!
        }
        if self.configRuleState != nil {
            map["ConfigRuleState"] = self.configRuleState!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceTypes != nil {
            map["ResourceTypes"] = self.resourceTypes!
        }
        if self.riskLevel != nil {
            map["RiskLevel"] = self.riskLevel!
        }
        if self.tagShrink != nil {
            map["Tag"] = self.tagShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CompliancePackId"] as? String {
            self.compliancePackId = value
        }
        if let value = dict["ComplianceType"] as? String {
            self.complianceType = value
        }
        if let value = dict["ConfigRuleName"] as? String {
            self.configRuleName = value
        }
        if let value = dict["ConfigRuleState"] as? String {
            self.configRuleState = value
        }
        if let value = dict["Keyword"] as? String {
            self.keyword = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ResourceTypes"] as? String {
            self.resourceTypes = value
        }
        if let value = dict["RiskLevel"] as? Int32 {
            self.riskLevel = value
        }
        if let value = dict["Tag"] as? String {
            self.tagShrink = value
        }
    }
}

public class ListConfigRulesResponseBody : Tea.TeaModel {
    public class ConfigRules : Tea.TeaModel {
        public class ConfigRuleList : Tea.TeaModel {
            public class Compliance : Tea.TeaModel {
                public var complianceType: String?

                public var count: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.complianceType != nil {
                        map["ComplianceType"] = self.complianceType!
                    }
                    if self.count != nil {
                        map["Count"] = self.count!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ComplianceType"] as? String {
                        self.complianceType = value
                    }
                    if let value = dict["Count"] as? Int32 {
                        self.count = value
                    }
                }
            }
            public class CreateBy : Tea.TeaModel {
                public var compliancePackId: String?

                public var compliancePackName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.compliancePackId != nil {
                        map["CompliancePackId"] = self.compliancePackId!
                    }
                    if self.compliancePackName != nil {
                        map["CompliancePackName"] = self.compliancePackName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["CompliancePackId"] as? String {
                        self.compliancePackId = value
                    }
                    if let value = dict["CompliancePackName"] as? String {
                        self.compliancePackName = value
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public var key: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Key"] as? String {
                        self.key = value
                    }
                    if let value = dict["Value"] as? String {
                        self.value = value
                    }
                }
            }
            public var accountId: Int64?

            public var automationType: String?

            public var compliance: ListConfigRulesResponseBody.ConfigRules.ConfigRuleList.Compliance?

            public var configRuleArn: String?

            public var configRuleId: String?

            public var configRuleName: String?

            public var configRuleState: String?

            public var createBy: ListConfigRulesResponseBody.ConfigRules.ConfigRuleList.CreateBy?

            public var description_: String?

            public var resourceTypesScope: String?

            public var riskLevel: Int32?

            public var sourceIdentifier: String?

            public var sourceOwner: String?

            public var tags: [ListConfigRulesResponseBody.ConfigRules.ConfigRuleList.Tags]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.compliance?.validate()
                try self.createBy?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.accountId != nil {
                    map["AccountId"] = self.accountId!
                }
                if self.automationType != nil {
                    map["AutomationType"] = self.automationType!
                }
                if self.compliance != nil {
                    map["Compliance"] = self.compliance?.toMap()
                }
                if self.configRuleArn != nil {
                    map["ConfigRuleArn"] = self.configRuleArn!
                }
                if self.configRuleId != nil {
                    map["ConfigRuleId"] = self.configRuleId!
                }
                if self.configRuleName != nil {
                    map["ConfigRuleName"] = self.configRuleName!
                }
                if self.configRuleState != nil {
                    map["ConfigRuleState"] = self.configRuleState!
                }
                if self.createBy != nil {
                    map["CreateBy"] = self.createBy?.toMap()
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.resourceTypesScope != nil {
                    map["ResourceTypesScope"] = self.resourceTypesScope!
                }
                if self.riskLevel != nil {
                    map["RiskLevel"] = self.riskLevel!
                }
                if self.sourceIdentifier != nil {
                    map["SourceIdentifier"] = self.sourceIdentifier!
                }
                if self.sourceOwner != nil {
                    map["SourceOwner"] = self.sourceOwner!
                }
                if self.tags != nil {
                    var tmp : [Any] = []
                    for k in self.tags! {
                        tmp.append(k.toMap())
                    }
                    map["Tags"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AccountId"] as? Int64 {
                    self.accountId = value
                }
                if let value = dict["AutomationType"] as? String {
                    self.automationType = value
                }
                if let value = dict["Compliance"] as? [String: Any?] {
                    var model = ListConfigRulesResponseBody.ConfigRules.ConfigRuleList.Compliance()
                    model.fromMap(value)
                    self.compliance = model
                }
                if let value = dict["ConfigRuleArn"] as? String {
                    self.configRuleArn = value
                }
                if let value = dict["ConfigRuleId"] as? String {
                    self.configRuleId = value
                }
                if let value = dict["ConfigRuleName"] as? String {
                    self.configRuleName = value
                }
                if let value = dict["ConfigRuleState"] as? String {
                    self.configRuleState = value
                }
                if let value = dict["CreateBy"] as? [String: Any?] {
                    var model = ListConfigRulesResponseBody.ConfigRules.ConfigRuleList.CreateBy()
                    model.fromMap(value)
                    self.createBy = model
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["ResourceTypesScope"] as? String {
                    self.resourceTypesScope = value
                }
                if let value = dict["RiskLevel"] as? Int32 {
                    self.riskLevel = value
                }
                if let value = dict["SourceIdentifier"] as? String {
                    self.sourceIdentifier = value
                }
                if let value = dict["SourceOwner"] as? String {
                    self.sourceOwner = value
                }
                if let value = dict["Tags"] as? [Any?] {
                    var tmp : [ListConfigRulesResponseBody.ConfigRules.ConfigRuleList.Tags] = []
                    for v in value {
                        if v != nil {
                            var model = ListConfigRulesResponseBody.ConfigRules.ConfigRuleList.Tags()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.tags = tmp
                }
            }
        }
        public var configRuleList: [ListConfigRulesResponseBody.ConfigRules.ConfigRuleList]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.configRuleList != nil {
                var tmp : [Any] = []
                for k in self.configRuleList! {
                    tmp.append(k.toMap())
                }
                map["ConfigRuleList"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ConfigRuleList"] as? [Any?] {
                var tmp : [ListConfigRulesResponseBody.ConfigRules.ConfigRuleList] = []
                for v in value {
                    if v != nil {
                        var model = ListConfigRulesResponseBody.ConfigRules.ConfigRuleList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.configRuleList = tmp
            }
            if let value = dict["PageNumber"] as? Int32 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["TotalCount"] as? Int64 {
                self.totalCount = value
            }
        }
    }
    public var configRules: ListConfigRulesResponseBody.ConfigRules?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.configRules?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configRules != nil {
            map["ConfigRules"] = self.configRules?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ConfigRules"] as? [String: Any?] {
            var model = ListConfigRulesResponseBody.ConfigRules()
            model.fromMap(value)
            self.configRules = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListConfigRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListConfigRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListConfigRulesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListDiscoveredResourcesRequest : Tea.TeaModel {
    public var endUpdateTimestamp: Int64?

    public var excludeResourceTypes: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var regions: String?

    public var resourceDeleted: Int32?

    public var resourceId: String?

    public var resourceTypes: String?

    public var startUpdateTimestamp: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endUpdateTimestamp != nil {
            map["EndUpdateTimestamp"] = self.endUpdateTimestamp!
        }
        if self.excludeResourceTypes != nil {
            map["ExcludeResourceTypes"] = self.excludeResourceTypes!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.regions != nil {
            map["Regions"] = self.regions!
        }
        if self.resourceDeleted != nil {
            map["ResourceDeleted"] = self.resourceDeleted!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceTypes != nil {
            map["ResourceTypes"] = self.resourceTypes!
        }
        if self.startUpdateTimestamp != nil {
            map["StartUpdateTimestamp"] = self.startUpdateTimestamp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EndUpdateTimestamp"] as? Int64 {
            self.endUpdateTimestamp = value
        }
        if let value = dict["ExcludeResourceTypes"] as? String {
            self.excludeResourceTypes = value
        }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["Regions"] as? String {
            self.regions = value
        }
        if let value = dict["ResourceDeleted"] as? Int32 {
            self.resourceDeleted = value
        }
        if let value = dict["ResourceId"] as? String {
            self.resourceId = value
        }
        if let value = dict["ResourceTypes"] as? String {
            self.resourceTypes = value
        }
        if let value = dict["StartUpdateTimestamp"] as? Int64 {
            self.startUpdateTimestamp = value
        }
    }
}

public class ListDiscoveredResourcesResponseBody : Tea.TeaModel {
    public class DiscoveredResourceProfiles : Tea.TeaModel {
        public class DiscoveredResourceProfileList : Tea.TeaModel {
            public var accountId: Int64?

            public var availabilityZone: String?

            public var region: String?

            public var resourceCreationTime: Int64?

            public var resourceDeleted: Int32?

            public var resourceId: String?

            public var resourceName: String?

            public var resourceStatus: String?

            public var resourceType: String?

            public var tags: String?

            public var updateTime: Int64?

            public var vSwitchId: String?

            public var version: Int64?

            public var vpcId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.accountId != nil {
                    map["AccountId"] = self.accountId!
                }
                if self.availabilityZone != nil {
                    map["AvailabilityZone"] = self.availabilityZone!
                }
                if self.region != nil {
                    map["Region"] = self.region!
                }
                if self.resourceCreationTime != nil {
                    map["ResourceCreationTime"] = self.resourceCreationTime!
                }
                if self.resourceDeleted != nil {
                    map["ResourceDeleted"] = self.resourceDeleted!
                }
                if self.resourceId != nil {
                    map["ResourceId"] = self.resourceId!
                }
                if self.resourceName != nil {
                    map["ResourceName"] = self.resourceName!
                }
                if self.resourceStatus != nil {
                    map["ResourceStatus"] = self.resourceStatus!
                }
                if self.resourceType != nil {
                    map["ResourceType"] = self.resourceType!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.vSwitchId != nil {
                    map["VSwitchId"] = self.vSwitchId!
                }
                if self.version != nil {
                    map["Version"] = self.version!
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AccountId"] as? Int64 {
                    self.accountId = value
                }
                if let value = dict["AvailabilityZone"] as? String {
                    self.availabilityZone = value
                }
                if let value = dict["Region"] as? String {
                    self.region = value
                }
                if let value = dict["ResourceCreationTime"] as? Int64 {
                    self.resourceCreationTime = value
                }
                if let value = dict["ResourceDeleted"] as? Int32 {
                    self.resourceDeleted = value
                }
                if let value = dict["ResourceId"] as? String {
                    self.resourceId = value
                }
                if let value = dict["ResourceName"] as? String {
                    self.resourceName = value
                }
                if let value = dict["ResourceStatus"] as? String {
                    self.resourceStatus = value
                }
                if let value = dict["ResourceType"] as? String {
                    self.resourceType = value
                }
                if let value = dict["Tags"] as? String {
                    self.tags = value
                }
                if let value = dict["UpdateTime"] as? Int64 {
                    self.updateTime = value
                }
                if let value = dict["VSwitchId"] as? String {
                    self.vSwitchId = value
                }
                if let value = dict["Version"] as? Int64 {
                    self.version = value
                }
                if let value = dict["VpcId"] as? String {
                    self.vpcId = value
                }
            }
        }
        public var discoveredResourceProfileList: [ListDiscoveredResourcesResponseBody.DiscoveredResourceProfiles.DiscoveredResourceProfileList]?

        public var maxResults: Int32?

        public var nextToken: String?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.discoveredResourceProfileList != nil {
                var tmp : [Any] = []
                for k in self.discoveredResourceProfileList! {
                    tmp.append(k.toMap())
                }
                map["DiscoveredResourceProfileList"] = tmp
            }
            if self.maxResults != nil {
                map["MaxResults"] = self.maxResults!
            }
            if self.nextToken != nil {
                map["NextToken"] = self.nextToken!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DiscoveredResourceProfileList"] as? [Any?] {
                var tmp : [ListDiscoveredResourcesResponseBody.DiscoveredResourceProfiles.DiscoveredResourceProfileList] = []
                for v in value {
                    if v != nil {
                        var model = ListDiscoveredResourcesResponseBody.DiscoveredResourceProfiles.DiscoveredResourceProfileList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.discoveredResourceProfileList = tmp
            }
            if let value = dict["MaxResults"] as? Int32 {
                self.maxResults = value
            }
            if let value = dict["NextToken"] as? String {
                self.nextToken = value
            }
            if let value = dict["TotalCount"] as? Int32 {
                self.totalCount = value
            }
        }
    }
    public var discoveredResourceProfiles: ListDiscoveredResourcesResponseBody.DiscoveredResourceProfiles?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.discoveredResourceProfiles?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.discoveredResourceProfiles != nil {
            map["DiscoveredResourceProfiles"] = self.discoveredResourceProfiles?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DiscoveredResourceProfiles"] as? [String: Any?] {
            var model = ListDiscoveredResourcesResponseBody.DiscoveredResourceProfiles()
            model.fromMap(value)
            self.discoveredResourceProfiles = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListDiscoveredResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDiscoveredResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListDiscoveredResourcesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListIntegratedServiceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var aggregatorDeliveryDataType: String?

        public var integratedTypes: String?

        public var serviceCode: String?

        public var serviceName: String?

        public var status: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aggregatorDeliveryDataType != nil {
                map["AggregatorDeliveryDataType"] = self.aggregatorDeliveryDataType!
            }
            if self.integratedTypes != nil {
                map["IntegratedTypes"] = self.integratedTypes!
            }
            if self.serviceCode != nil {
                map["ServiceCode"] = self.serviceCode!
            }
            if self.serviceName != nil {
                map["ServiceName"] = self.serviceName!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AggregatorDeliveryDataType"] as? String {
                self.aggregatorDeliveryDataType = value
            }
            if let value = dict["IntegratedTypes"] as? String {
                self.integratedTypes = value
            }
            if let value = dict["ServiceCode"] as? String {
                self.serviceCode = value
            }
            if let value = dict["ServiceName"] as? String {
                self.serviceName = value
            }
            if let value = dict["Status"] as? Bool {
                self.status = value
            }
        }
    }
    public var data: [ListIntegratedServiceResponseBody.Data]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [Any?] {
            var tmp : [ListIntegratedServiceResponseBody.Data] = []
            for v in value {
                if v != nil {
                    var model = ListIntegratedServiceResponseBody.Data()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.data = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListIntegratedServiceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListIntegratedServiceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListIntegratedServiceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListManagedRulesRequest : Tea.TeaModel {
    public var filterType: String?

    public var keyword: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var resourceTypes: String?

    public var riskLevel: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.filterType != nil {
            map["FilterType"] = self.filterType!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceTypes != nil {
            map["ResourceTypes"] = self.resourceTypes!
        }
        if self.riskLevel != nil {
            map["RiskLevel"] = self.riskLevel!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["FilterType"] as? String {
            self.filterType = value
        }
        if let value = dict["Keyword"] as? String {
            self.keyword = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ResourceTypes"] as? String {
            self.resourceTypes = value
        }
        if let value = dict["RiskLevel"] as? Int32 {
            self.riskLevel = value
        }
    }
}

public class ListManagedRulesResponseBody : Tea.TeaModel {
    public class ManagedRules : Tea.TeaModel {
        public class ManagedRuleList : Tea.TeaModel {
            public class Scope : Tea.TeaModel {
                public var complianceResourceTypes: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.complianceResourceTypes != nil {
                        map["ComplianceResourceTypes"] = self.complianceResourceTypes!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ComplianceResourceTypes"] as? [String] {
                        self.complianceResourceTypes = value
                    }
                }
            }
            public var configRuleName: String?

            public var description_: String?

            public var helpUrls: String?

            public var identifier: String?

            public var labels: [String]?

            public var remediationTemplateIdentifier: String?

            public var remediationTemplateName: String?

            public var riskLevel: Int32?

            public var scope: ListManagedRulesResponseBody.ManagedRules.ManagedRuleList.Scope?

            public var supportPreviewManagedRule: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.scope?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.configRuleName != nil {
                    map["ConfigRuleName"] = self.configRuleName!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.helpUrls != nil {
                    map["HelpUrls"] = self.helpUrls!
                }
                if self.identifier != nil {
                    map["Identifier"] = self.identifier!
                }
                if self.labels != nil {
                    map["Labels"] = self.labels!
                }
                if self.remediationTemplateIdentifier != nil {
                    map["RemediationTemplateIdentifier"] = self.remediationTemplateIdentifier!
                }
                if self.remediationTemplateName != nil {
                    map["RemediationTemplateName"] = self.remediationTemplateName!
                }
                if self.riskLevel != nil {
                    map["RiskLevel"] = self.riskLevel!
                }
                if self.scope != nil {
                    map["Scope"] = self.scope?.toMap()
                }
                if self.supportPreviewManagedRule != nil {
                    map["SupportPreviewManagedRule"] = self.supportPreviewManagedRule!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ConfigRuleName"] as? String {
                    self.configRuleName = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["HelpUrls"] as? String {
                    self.helpUrls = value
                }
                if let value = dict["Identifier"] as? String {
                    self.identifier = value
                }
                if let value = dict["Labels"] as? [String] {
                    self.labels = value
                }
                if let value = dict["RemediationTemplateIdentifier"] as? String {
                    self.remediationTemplateIdentifier = value
                }
                if let value = dict["RemediationTemplateName"] as? String {
                    self.remediationTemplateName = value
                }
                if let value = dict["RiskLevel"] as? Int32 {
                    self.riskLevel = value
                }
                if let value = dict["Scope"] as? [String: Any?] {
                    var model = ListManagedRulesResponseBody.ManagedRules.ManagedRuleList.Scope()
                    model.fromMap(value)
                    self.scope = model
                }
                if let value = dict["SupportPreviewManagedRule"] as? Bool {
                    self.supportPreviewManagedRule = value
                }
            }
        }
        public var managedRuleList: [ListManagedRulesResponseBody.ManagedRules.ManagedRuleList]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.managedRuleList != nil {
                var tmp : [Any] = []
                for k in self.managedRuleList! {
                    tmp.append(k.toMap())
                }
                map["ManagedRuleList"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ManagedRuleList"] as? [Any?] {
                var tmp : [ListManagedRulesResponseBody.ManagedRules.ManagedRuleList] = []
                for v in value {
                    if v != nil {
                        var model = ListManagedRulesResponseBody.ManagedRules.ManagedRuleList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.managedRuleList = tmp
            }
            if let value = dict["PageNumber"] as? Int32 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["TotalCount"] as? Int64 {
                self.totalCount = value
            }
        }
    }
    public var managedRules: ListManagedRulesResponseBody.ManagedRules?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.managedRules?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.managedRules != nil {
            map["ManagedRules"] = self.managedRules?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ManagedRules"] as? [String: Any?] {
            var model = ListManagedRulesResponseBody.ManagedRules()
            model.fromMap(value)
            self.managedRules = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListManagedRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListManagedRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListManagedRulesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListPreManagedRulesRequest : Tea.TeaModel {
    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var resourceTypes: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceTypes != nil {
            map["ResourceTypes"] = self.resourceTypes!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["ResourceTypes"] as? [String] {
            self.resourceTypes = value
        }
    }
}

public class ListPreManagedRulesShrinkRequest : Tea.TeaModel {
    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var resourceTypesShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceTypesShrink != nil {
            map["ResourceTypes"] = self.resourceTypesShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["ResourceTypes"] as? String {
            self.resourceTypesShrink = value
        }
    }
}

public class ListPreManagedRulesResponseBody : Tea.TeaModel {
    public class ManagedRules : Tea.TeaModel {
        public var compulsoryInputParameterDetails: [String: Any]?

        public var configRuleName: String?

        public var description_: String?

        public var helpUrls: String?

        public var identifier: String?

        public var optionalInputParameterDetails: [String: Any]?

        public var resourceType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.compulsoryInputParameterDetails != nil {
                map["CompulsoryInputParameterDetails"] = self.compulsoryInputParameterDetails!
            }
            if self.configRuleName != nil {
                map["ConfigRuleName"] = self.configRuleName!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.helpUrls != nil {
                map["HelpUrls"] = self.helpUrls!
            }
            if self.identifier != nil {
                map["Identifier"] = self.identifier!
            }
            if self.optionalInputParameterDetails != nil {
                map["OptionalInputParameterDetails"] = self.optionalInputParameterDetails!
            }
            if self.resourceType != nil {
                map["ResourceType"] = self.resourceType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CompulsoryInputParameterDetails"] as? [String: Any] {
                self.compulsoryInputParameterDetails = value
            }
            if let value = dict["ConfigRuleName"] as? String {
                self.configRuleName = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["HelpUrls"] as? String {
                self.helpUrls = value
            }
            if let value = dict["Identifier"] as? String {
                self.identifier = value
            }
            if let value = dict["OptionalInputParameterDetails"] as? [String: Any] {
                self.optionalInputParameterDetails = value
            }
            if let value = dict["ResourceType"] as? String {
                self.resourceType = value
            }
        }
    }
    public var managedRules: [ListPreManagedRulesResponseBody.ManagedRules]?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.managedRules != nil {
            var tmp : [Any] = []
            for k in self.managedRules! {
                tmp.append(k.toMap())
            }
            map["ManagedRules"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ManagedRules"] as? [Any?] {
            var tmp : [ListPreManagedRulesResponseBody.ManagedRules] = []
            for v in value {
                if v != nil {
                    var model = ListPreManagedRulesResponseBody.ManagedRules()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.managedRules = tmp
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListPreManagedRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListPreManagedRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListPreManagedRulesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListRemediationExecutionsRequest : Tea.TeaModel {
    public var configRuleId: String?

    public var executionStatus: String?

    public var maxResults: Int64?

    public var nextToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configRuleId != nil {
            map["ConfigRuleId"] = self.configRuleId!
        }
        if self.executionStatus != nil {
            map["ExecutionStatus"] = self.executionStatus!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ConfigRuleId"] as? String {
            self.configRuleId = value
        }
        if let value = dict["ExecutionStatus"] as? String {
            self.executionStatus = value
        }
        if let value = dict["MaxResults"] as? Int64 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
    }
}

public class ListRemediationExecutionsResponseBody : Tea.TeaModel {
    public class RemediationExecutionData : Tea.TeaModel {
        public class RemediationExecutions : Tea.TeaModel {
            public var executionCreateDate: String?

            public var executionInvocationId: String?

            public var executionResourceIds: String?

            public var executionResourceType: String?

            public var executionStatus: String?

            public var executionStatusMessage: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.executionCreateDate != nil {
                    map["ExecutionCreateDate"] = self.executionCreateDate!
                }
                if self.executionInvocationId != nil {
                    map["ExecutionInvocationId"] = self.executionInvocationId!
                }
                if self.executionResourceIds != nil {
                    map["ExecutionResourceIds"] = self.executionResourceIds!
                }
                if self.executionResourceType != nil {
                    map["ExecutionResourceType"] = self.executionResourceType!
                }
                if self.executionStatus != nil {
                    map["ExecutionStatus"] = self.executionStatus!
                }
                if self.executionStatusMessage != nil {
                    map["ExecutionStatusMessage"] = self.executionStatusMessage!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ExecutionCreateDate"] as? String {
                    self.executionCreateDate = value
                }
                if let value = dict["ExecutionInvocationId"] as? String {
                    self.executionInvocationId = value
                }
                if let value = dict["ExecutionResourceIds"] as? String {
                    self.executionResourceIds = value
                }
                if let value = dict["ExecutionResourceType"] as? String {
                    self.executionResourceType = value
                }
                if let value = dict["ExecutionStatus"] as? String {
                    self.executionStatus = value
                }
                if let value = dict["ExecutionStatusMessage"] as? String {
                    self.executionStatusMessage = value
                }
            }
        }
        public var maxResults: Int64?

        public var nextToken: String?

        public var remediationExecutions: [ListRemediationExecutionsResponseBody.RemediationExecutionData.RemediationExecutions]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.maxResults != nil {
                map["MaxResults"] = self.maxResults!
            }
            if self.nextToken != nil {
                map["NextToken"] = self.nextToken!
            }
            if self.remediationExecutions != nil {
                var tmp : [Any] = []
                for k in self.remediationExecutions! {
                    tmp.append(k.toMap())
                }
                map["RemediationExecutions"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["MaxResults"] as? Int64 {
                self.maxResults = value
            }
            if let value = dict["NextToken"] as? String {
                self.nextToken = value
            }
            if let value = dict["RemediationExecutions"] as? [Any?] {
                var tmp : [ListRemediationExecutionsResponseBody.RemediationExecutionData.RemediationExecutions] = []
                for v in value {
                    if v != nil {
                        var model = ListRemediationExecutionsResponseBody.RemediationExecutionData.RemediationExecutions()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.remediationExecutions = tmp
            }
        }
    }
    public var remediationExecutionData: ListRemediationExecutionsResponseBody.RemediationExecutionData?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.remediationExecutionData?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.remediationExecutionData != nil {
            map["RemediationExecutionData"] = self.remediationExecutionData?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RemediationExecutionData"] as? [String: Any?] {
            var model = ListRemediationExecutionsResponseBody.RemediationExecutionData()
            model.fromMap(value)
            self.remediationExecutionData = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListRemediationExecutionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListRemediationExecutionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListRemediationExecutionsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListRemediationTemplatesRequest : Tea.TeaModel {
    public var managedRuleIdentifier: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var remediationType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.managedRuleIdentifier != nil {
            map["ManagedRuleIdentifier"] = self.managedRuleIdentifier!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.remediationType != nil {
            map["RemediationType"] = self.remediationType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ManagedRuleIdentifier"] as? String {
            self.managedRuleIdentifier = value
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["RemediationType"] as? String {
            self.remediationType = value
        }
    }
}

public class ListRemediationTemplatesResponseBody : Tea.TeaModel {
    public class RemediationTemplates : Tea.TeaModel {
        public var remediationType: String?

        public var templateDefinition: String?

        public var templateDescription: String?

        public var templateIdentifier: String?

        public var templateName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.remediationType != nil {
                map["RemediationType"] = self.remediationType!
            }
            if self.templateDefinition != nil {
                map["TemplateDefinition"] = self.templateDefinition!
            }
            if self.templateDescription != nil {
                map["TemplateDescription"] = self.templateDescription!
            }
            if self.templateIdentifier != nil {
                map["TemplateIdentifier"] = self.templateIdentifier!
            }
            if self.templateName != nil {
                map["TemplateName"] = self.templateName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["RemediationType"] as? String {
                self.remediationType = value
            }
            if let value = dict["TemplateDefinition"] as? String {
                self.templateDefinition = value
            }
            if let value = dict["TemplateDescription"] as? String {
                self.templateDescription = value
            }
            if let value = dict["TemplateIdentifier"] as? String {
                self.templateIdentifier = value
            }
            if let value = dict["TemplateName"] as? String {
                self.templateName = value
            }
        }
    }
    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var remediationTemplates: [ListRemediationTemplatesResponseBody.RemediationTemplates]?

    public var requestId: String?

    public var totalCount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.remediationTemplates != nil {
            var tmp : [Any] = []
            for k in self.remediationTemplates! {
                tmp.append(k.toMap())
            }
            map["RemediationTemplates"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["RemediationTemplates"] as? [Any?] {
            var tmp : [ListRemediationTemplatesResponseBody.RemediationTemplates] = []
            for v in value {
                if v != nil {
                    var model = ListRemediationTemplatesResponseBody.RemediationTemplates()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.remediationTemplates = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? String {
            self.totalCount = value
        }
    }
}

public class ListRemediationTemplatesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListRemediationTemplatesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListRemediationTemplatesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListRemediationsRequest : Tea.TeaModel {
    public var configRuleIds: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configRuleIds != nil {
            map["ConfigRuleIds"] = self.configRuleIds!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ConfigRuleIds"] as? String {
            self.configRuleIds = value
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
    }
}

public class ListRemediationsResponseBody : Tea.TeaModel {
    public class Remediations : Tea.TeaModel {
        public var accountId: Int64?

        public var configRuleId: String?

        public var invokeType: String?

        public var lastSuccessfulInvocationId: String?

        public var lastSuccessfulInvocationTime: Int64?

        public var lastSuccessfulInvocationType: String?

        public var remediationId: String?

        public var remediationOriginParams: String?

        public var remediationSourceType: String?

        public var remediationTemplateId: String?

        public var remediationType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["AccountId"] = self.accountId!
            }
            if self.configRuleId != nil {
                map["ConfigRuleId"] = self.configRuleId!
            }
            if self.invokeType != nil {
                map["InvokeType"] = self.invokeType!
            }
            if self.lastSuccessfulInvocationId != nil {
                map["LastSuccessfulInvocationId"] = self.lastSuccessfulInvocationId!
            }
            if self.lastSuccessfulInvocationTime != nil {
                map["LastSuccessfulInvocationTime"] = self.lastSuccessfulInvocationTime!
            }
            if self.lastSuccessfulInvocationType != nil {
                map["LastSuccessfulInvocationType"] = self.lastSuccessfulInvocationType!
            }
            if self.remediationId != nil {
                map["RemediationId"] = self.remediationId!
            }
            if self.remediationOriginParams != nil {
                map["RemediationOriginParams"] = self.remediationOriginParams!
            }
            if self.remediationSourceType != nil {
                map["RemediationSourceType"] = self.remediationSourceType!
            }
            if self.remediationTemplateId != nil {
                map["RemediationTemplateId"] = self.remediationTemplateId!
            }
            if self.remediationType != nil {
                map["RemediationType"] = self.remediationType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AccountId"] as? Int64 {
                self.accountId = value
            }
            if let value = dict["ConfigRuleId"] as? String {
                self.configRuleId = value
            }
            if let value = dict["InvokeType"] as? String {
                self.invokeType = value
            }
            if let value = dict["LastSuccessfulInvocationId"] as? String {
                self.lastSuccessfulInvocationId = value
            }
            if let value = dict["LastSuccessfulInvocationTime"] as? Int64 {
                self.lastSuccessfulInvocationTime = value
            }
            if let value = dict["LastSuccessfulInvocationType"] as? String {
                self.lastSuccessfulInvocationType = value
            }
            if let value = dict["RemediationId"] as? String {
                self.remediationId = value
            }
            if let value = dict["RemediationOriginParams"] as? String {
                self.remediationOriginParams = value
            }
            if let value = dict["RemediationSourceType"] as? String {
                self.remediationSourceType = value
            }
            if let value = dict["RemediationTemplateId"] as? String {
                self.remediationTemplateId = value
            }
            if let value = dict["RemediationType"] as? String {
                self.remediationType = value
            }
        }
    }
    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var remediations: [ListRemediationsResponseBody.Remediations]?

    public var requestId: String?

    public var totalCount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.remediations != nil {
            var tmp : [Any] = []
            for k in self.remediations! {
                tmp.append(k.toMap())
            }
            map["Remediations"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["Remediations"] as? [Any?] {
            var tmp : [ListRemediationsResponseBody.Remediations] = []
            for v in value {
                if v != nil {
                    var model = ListRemediationsResponseBody.Remediations()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.remediations = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? String {
            self.totalCount = value
        }
    }
}

public class ListRemediationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListRemediationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListRemediationsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListResourceEvaluationResultsRequest : Tea.TeaModel {
    public var complianceType: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var region: String?

    public var resourceId: String?

    public var resourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.complianceType != nil {
            map["ComplianceType"] = self.complianceType!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ComplianceType"] as? String {
            self.complianceType = value
        }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["Region"] as? String {
            self.region = value
        }
        if let value = dict["ResourceId"] as? String {
            self.resourceId = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
    }
}

public class ListResourceEvaluationResultsResponseBody : Tea.TeaModel {
    public class EvaluationResults : Tea.TeaModel {
        public class EvaluationResultList : Tea.TeaModel {
            public class EvaluationResultIdentifier : Tea.TeaModel {
                public class EvaluationResultQualifier : Tea.TeaModel {
                    public var configRuleArn: String?

                    public var configRuleId: String?

                    public var configRuleName: String?

                    public var ignoreDate: String?

                    public var regionId: String?

                    public var resourceId: String?

                    public var resourceName: String?

                    public var resourceType: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.configRuleArn != nil {
                            map["ConfigRuleArn"] = self.configRuleArn!
                        }
                        if self.configRuleId != nil {
                            map["ConfigRuleId"] = self.configRuleId!
                        }
                        if self.configRuleName != nil {
                            map["ConfigRuleName"] = self.configRuleName!
                        }
                        if self.ignoreDate != nil {
                            map["IgnoreDate"] = self.ignoreDate!
                        }
                        if self.regionId != nil {
                            map["RegionId"] = self.regionId!
                        }
                        if self.resourceId != nil {
                            map["ResourceId"] = self.resourceId!
                        }
                        if self.resourceName != nil {
                            map["ResourceName"] = self.resourceName!
                        }
                        if self.resourceType != nil {
                            map["ResourceType"] = self.resourceType!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["ConfigRuleArn"] as? String {
                            self.configRuleArn = value
                        }
                        if let value = dict["ConfigRuleId"] as? String {
                            self.configRuleId = value
                        }
                        if let value = dict["ConfigRuleName"] as? String {
                            self.configRuleName = value
                        }
                        if let value = dict["IgnoreDate"] as? String {
                            self.ignoreDate = value
                        }
                        if let value = dict["RegionId"] as? String {
                            self.regionId = value
                        }
                        if let value = dict["ResourceId"] as? String {
                            self.resourceId = value
                        }
                        if let value = dict["ResourceName"] as? String {
                            self.resourceName = value
                        }
                        if let value = dict["ResourceType"] as? String {
                            self.resourceType = value
                        }
                    }
                }
                public var evaluationResultQualifier: ListResourceEvaluationResultsResponseBody.EvaluationResults.EvaluationResultList.EvaluationResultIdentifier.EvaluationResultQualifier?

                public var orderingTimestamp: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.evaluationResultQualifier?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.evaluationResultQualifier != nil {
                        map["EvaluationResultQualifier"] = self.evaluationResultQualifier?.toMap()
                    }
                    if self.orderingTimestamp != nil {
                        map["OrderingTimestamp"] = self.orderingTimestamp!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["EvaluationResultQualifier"] as? [String: Any?] {
                        var model = ListResourceEvaluationResultsResponseBody.EvaluationResults.EvaluationResultList.EvaluationResultIdentifier.EvaluationResultQualifier()
                        model.fromMap(value)
                        self.evaluationResultQualifier = model
                    }
                    if let value = dict["OrderingTimestamp"] as? Int64 {
                        self.orderingTimestamp = value
                    }
                }
            }
            public var annotation: String?

            public var complianceType: String?

            public var configRuleInvokedTimestamp: Int64?

            public var evaluationId: String?

            public var evaluationResultIdentifier: ListResourceEvaluationResultsResponseBody.EvaluationResults.EvaluationResultList.EvaluationResultIdentifier?

            public var invokingEventMessageType: String?

            public var lastNonCompliantRecordTimestamp: Int64?

            public var remediationEnabled: Bool?

            public var resultRecordedTimestamp: Int64?

            public var riskLevel: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.evaluationResultIdentifier?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.annotation != nil {
                    map["Annotation"] = self.annotation!
                }
                if self.complianceType != nil {
                    map["ComplianceType"] = self.complianceType!
                }
                if self.configRuleInvokedTimestamp != nil {
                    map["ConfigRuleInvokedTimestamp"] = self.configRuleInvokedTimestamp!
                }
                if self.evaluationId != nil {
                    map["EvaluationId"] = self.evaluationId!
                }
                if self.evaluationResultIdentifier != nil {
                    map["EvaluationResultIdentifier"] = self.evaluationResultIdentifier?.toMap()
                }
                if self.invokingEventMessageType != nil {
                    map["InvokingEventMessageType"] = self.invokingEventMessageType!
                }
                if self.lastNonCompliantRecordTimestamp != nil {
                    map["LastNonCompliantRecordTimestamp"] = self.lastNonCompliantRecordTimestamp!
                }
                if self.remediationEnabled != nil {
                    map["RemediationEnabled"] = self.remediationEnabled!
                }
                if self.resultRecordedTimestamp != nil {
                    map["ResultRecordedTimestamp"] = self.resultRecordedTimestamp!
                }
                if self.riskLevel != nil {
                    map["RiskLevel"] = self.riskLevel!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Annotation"] as? String {
                    self.annotation = value
                }
                if let value = dict["ComplianceType"] as? String {
                    self.complianceType = value
                }
                if let value = dict["ConfigRuleInvokedTimestamp"] as? Int64 {
                    self.configRuleInvokedTimestamp = value
                }
                if let value = dict["EvaluationId"] as? String {
                    self.evaluationId = value
                }
                if let value = dict["EvaluationResultIdentifier"] as? [String: Any?] {
                    var model = ListResourceEvaluationResultsResponseBody.EvaluationResults.EvaluationResultList.EvaluationResultIdentifier()
                    model.fromMap(value)
                    self.evaluationResultIdentifier = model
                }
                if let value = dict["InvokingEventMessageType"] as? String {
                    self.invokingEventMessageType = value
                }
                if let value = dict["LastNonCompliantRecordTimestamp"] as? Int64 {
                    self.lastNonCompliantRecordTimestamp = value
                }
                if let value = dict["RemediationEnabled"] as? Bool {
                    self.remediationEnabled = value
                }
                if let value = dict["ResultRecordedTimestamp"] as? Int64 {
                    self.resultRecordedTimestamp = value
                }
                if let value = dict["RiskLevel"] as? Int32 {
                    self.riskLevel = value
                }
            }
        }
        public var evaluationResultList: [ListResourceEvaluationResultsResponseBody.EvaluationResults.EvaluationResultList]?

        public var maxResults: Int32?

        public var nextToken: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.evaluationResultList != nil {
                var tmp : [Any] = []
                for k in self.evaluationResultList! {
                    tmp.append(k.toMap())
                }
                map["EvaluationResultList"] = tmp
            }
            if self.maxResults != nil {
                map["MaxResults"] = self.maxResults!
            }
            if self.nextToken != nil {
                map["NextToken"] = self.nextToken!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["EvaluationResultList"] as? [Any?] {
                var tmp : [ListResourceEvaluationResultsResponseBody.EvaluationResults.EvaluationResultList] = []
                for v in value {
                    if v != nil {
                        var model = ListResourceEvaluationResultsResponseBody.EvaluationResults.EvaluationResultList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.evaluationResultList = tmp
            }
            if let value = dict["MaxResults"] as? Int32 {
                self.maxResults = value
            }
            if let value = dict["NextToken"] as? String {
                self.nextToken = value
            }
        }
    }
    public var evaluationResults: ListResourceEvaluationResultsResponseBody.EvaluationResults?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.evaluationResults?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.evaluationResults != nil {
            map["EvaluationResults"] = self.evaluationResults?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EvaluationResults"] as? [String: Any?] {
            var model = ListResourceEvaluationResultsResponseBody.EvaluationResults()
            model.fromMap(value)
            self.evaluationResults = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListResourceEvaluationResultsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListResourceEvaluationResultsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListResourceEvaluationResultsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListResourceRelationsRequest : Tea.TeaModel {
    public var maxResults: Int32?

    public var nextToken: String?

    public var region: String?

    public var relationType: String?

    public var resourceId: String?

    public var resourceType: String?

    public var targetResourceId: String?

    public var targetResourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.relationType != nil {
            map["RelationType"] = self.relationType!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.targetResourceId != nil {
            map["TargetResourceId"] = self.targetResourceId!
        }
        if self.targetResourceType != nil {
            map["TargetResourceType"] = self.targetResourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["Region"] as? String {
            self.region = value
        }
        if let value = dict["RelationType"] as? String {
            self.relationType = value
        }
        if let value = dict["ResourceId"] as? String {
            self.resourceId = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
        if let value = dict["TargetResourceId"] as? String {
            self.targetResourceId = value
        }
        if let value = dict["TargetResourceType"] as? String {
            self.targetResourceType = value
        }
    }
}

public class ListResourceRelationsResponseBody : Tea.TeaModel {
    public class ResourceRelations : Tea.TeaModel {
        public class ResourceRelationList : Tea.TeaModel {
            public var accountId: Int64?

            public var relationType: String?

            public var sourceResourceId: String?

            public var sourceResourceRegionId: String?

            public var sourceResourceType: String?

            public var targetResourceId: String?

            public var targetResourceType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.accountId != nil {
                    map["AccountId"] = self.accountId!
                }
                if self.relationType != nil {
                    map["RelationType"] = self.relationType!
                }
                if self.sourceResourceId != nil {
                    map["SourceResourceId"] = self.sourceResourceId!
                }
                if self.sourceResourceRegionId != nil {
                    map["SourceResourceRegionId"] = self.sourceResourceRegionId!
                }
                if self.sourceResourceType != nil {
                    map["SourceResourceType"] = self.sourceResourceType!
                }
                if self.targetResourceId != nil {
                    map["TargetResourceId"] = self.targetResourceId!
                }
                if self.targetResourceType != nil {
                    map["TargetResourceType"] = self.targetResourceType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AccountId"] as? Int64 {
                    self.accountId = value
                }
                if let value = dict["RelationType"] as? String {
                    self.relationType = value
                }
                if let value = dict["SourceResourceId"] as? String {
                    self.sourceResourceId = value
                }
                if let value = dict["SourceResourceRegionId"] as? String {
                    self.sourceResourceRegionId = value
                }
                if let value = dict["SourceResourceType"] as? String {
                    self.sourceResourceType = value
                }
                if let value = dict["TargetResourceId"] as? String {
                    self.targetResourceId = value
                }
                if let value = dict["TargetResourceType"] as? String {
                    self.targetResourceType = value
                }
            }
        }
        public var maxResults: Int32?

        public var nextToken: String?

        public var resourceRelationList: [ListResourceRelationsResponseBody.ResourceRelations.ResourceRelationList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.maxResults != nil {
                map["MaxResults"] = self.maxResults!
            }
            if self.nextToken != nil {
                map["NextToken"] = self.nextToken!
            }
            if self.resourceRelationList != nil {
                var tmp : [Any] = []
                for k in self.resourceRelationList! {
                    tmp.append(k.toMap())
                }
                map["ResourceRelationList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["MaxResults"] as? Int32 {
                self.maxResults = value
            }
            if let value = dict["NextToken"] as? String {
                self.nextToken = value
            }
            if let value = dict["ResourceRelationList"] as? [Any?] {
                var tmp : [ListResourceRelationsResponseBody.ResourceRelations.ResourceRelationList] = []
                for v in value {
                    if v != nil {
                        var model = ListResourceRelationsResponseBody.ResourceRelations.ResourceRelationList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.resourceRelationList = tmp
            }
        }
    }
    public var requestId: String?

    public var resourceRelations: ListResourceRelationsResponseBody.ResourceRelations?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resourceRelations?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceRelations != nil {
            map["ResourceRelations"] = self.resourceRelations?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ResourceRelations"] as? [String: Any?] {
            var model = ListResourceRelationsResponseBody.ResourceRelations()
            model.fromMap(value)
            self.resourceRelations = model
        }
    }
}

public class ListResourceRelationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListResourceRelationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListResourceRelationsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListResourcesByAdvancedSearchRequest : Tea.TeaModel {
    public var sql: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.sql != nil {
            map["Sql"] = self.sql!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Sql"] as? String {
            self.sql = value
        }
    }
}

public class ListResourcesByAdvancedSearchResponseBody : Tea.TeaModel {
    public class QueryResults : Tea.TeaModel {
        public class QueryResultList : Tea.TeaModel {
            public var columns: [String]?

            public var values: [Any]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.columns != nil {
                    map["Columns"] = self.columns!
                }
                if self.values != nil {
                    map["Values"] = self.values!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Columns"] as? [String] {
                    self.columns = value
                }
                if let value = dict["Values"] as? [Any] {
                    self.values = value
                }
            }
        }
        public var queryResultList: ListResourcesByAdvancedSearchResponseBody.QueryResults.QueryResultList?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.queryResultList?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.queryResultList != nil {
                map["QueryResultList"] = self.queryResultList?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["QueryResultList"] as? [String: Any?] {
                var model = ListResourcesByAdvancedSearchResponseBody.QueryResults.QueryResultList()
                model.fromMap(value)
                self.queryResultList = model
            }
        }
    }
    public var queryResults: ListResourcesByAdvancedSearchResponseBody.QueryResults?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.queryResults?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.queryResults != nil {
            map["QueryResults"] = self.queryResults?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["QueryResults"] as? [String: Any?] {
            var model = ListResourcesByAdvancedSearchResponseBody.QueryResults()
            model.fromMap(value)
            self.queryResults = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListResourcesByAdvancedSearchResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListResourcesByAdvancedSearchResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListResourcesByAdvancedSearchResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListSupportedProductsRequest : Tea.TeaModel {
    public var maxResults: Int32?

    public var nextToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
    }
}

public class ListSupportedProductsResponseBody : Tea.TeaModel {
    public class Products : Tea.TeaModel {
        public class ResourceTypeList : Tea.TeaModel {
            public var resourceType: String?

            public var typeNameEn: String?

            public var typeNameZh: String?

            public var typePageLink: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.resourceType != nil {
                    map["ResourceType"] = self.resourceType!
                }
                if self.typeNameEn != nil {
                    map["TypeNameEn"] = self.typeNameEn!
                }
                if self.typeNameZh != nil {
                    map["TypeNameZh"] = self.typeNameZh!
                }
                if self.typePageLink != nil {
                    map["TypePageLink"] = self.typePageLink!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ResourceType"] as? String {
                    self.resourceType = value
                }
                if let value = dict["TypeNameEn"] as? String {
                    self.typeNameEn = value
                }
                if let value = dict["TypeNameZh"] as? String {
                    self.typeNameZh = value
                }
                if let value = dict["TypePageLink"] as? String {
                    self.typePageLink = value
                }
            }
        }
        public var productNameEn: String?

        public var productNameZh: String?

        public var resourceTypeList: [ListSupportedProductsResponseBody.Products.ResourceTypeList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.productNameEn != nil {
                map["ProductNameEn"] = self.productNameEn!
            }
            if self.productNameZh != nil {
                map["ProductNameZh"] = self.productNameZh!
            }
            if self.resourceTypeList != nil {
                var tmp : [Any] = []
                for k in self.resourceTypeList! {
                    tmp.append(k.toMap())
                }
                map["ResourceTypeList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ProductNameEn"] as? String {
                self.productNameEn = value
            }
            if let value = dict["ProductNameZh"] as? String {
                self.productNameZh = value
            }
            if let value = dict["ResourceTypeList"] as? [Any?] {
                var tmp : [ListSupportedProductsResponseBody.Products.ResourceTypeList] = []
                for v in value {
                    if v != nil {
                        var model = ListSupportedProductsResponseBody.Products.ResourceTypeList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.resourceTypeList = tmp
            }
        }
    }
    public var maxResults: String?

    public var nextToken: String?

    public var products: [ListSupportedProductsResponseBody.Products]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.products != nil {
            var tmp : [Any] = []
            for k in self.products! {
                tmp.append(k.toMap())
            }
            map["Products"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["MaxResults"] as? String {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["Products"] as? [Any?] {
            var tmp : [ListSupportedProductsResponseBody.Products] = []
            for v in value {
                if v != nil {
                    var model = ListSupportedProductsResponseBody.Products()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.products = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListSupportedProductsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSupportedProductsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListSupportedProductsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListTagResourcesRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var nextToken: String?

    public var regionId: String?

    public var resourceId: [String]?

    public var resourceType: String?

    public var tag: [ListTagResourcesRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceId"] as? [String] {
            self.resourceId = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [ListTagResourcesRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = ListTagResourcesRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
    }
}

public class ListTagResourcesShrinkRequest : Tea.TeaModel {
    public var nextToken: String?

    public var regionId: String?

    public var resourceId: [String]?

    public var resourceType: String?

    public var tagShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tagShrink != nil {
            map["Tag"] = self.tagShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceId"] as? [String] {
            self.resourceId = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
        if let value = dict["Tag"] as? String {
            self.tagShrink = value
        }
    }
}

public class ListTagResourcesResponseBody : Tea.TeaModel {
    public class TagResources : Tea.TeaModel {
        public class TagResource : Tea.TeaModel {
            public var resourceId: String?

            public var resourceType: String?

            public var tagKey: String?

            public var tagValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.resourceId != nil {
                    map["ResourceId"] = self.resourceId!
                }
                if self.resourceType != nil {
                    map["ResourceType"] = self.resourceType!
                }
                if self.tagKey != nil {
                    map["TagKey"] = self.tagKey!
                }
                if self.tagValue != nil {
                    map["TagValue"] = self.tagValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ResourceId"] as? String {
                    self.resourceId = value
                }
                if let value = dict["ResourceType"] as? String {
                    self.resourceType = value
                }
                if let value = dict["TagKey"] as? String {
                    self.tagKey = value
                }
                if let value = dict["TagValue"] as? String {
                    self.tagValue = value
                }
            }
        }
        public var tagResource: [ListTagResourcesResponseBody.TagResources.TagResource]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tagResource != nil {
                var tmp : [Any] = []
                for k in self.tagResource! {
                    tmp.append(k.toMap())
                }
                map["TagResource"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["TagResource"] as? [Any?] {
                var tmp : [ListTagResourcesResponseBody.TagResources.TagResource] = []
                for v in value {
                    if v != nil {
                        var model = ListTagResourcesResponseBody.TagResources.TagResource()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tagResource = tmp
            }
        }
    }
    public var nextToken: String?

    public var requestId: String?

    public var tagResources: ListTagResourcesResponseBody.TagResources?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tagResources?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.tagResources != nil {
            map["TagResources"] = self.tagResources?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TagResources"] as? [String: Any?] {
            var model = ListTagResourcesResponseBody.TagResources()
            model.fromMap(value)
            self.tagResources = model
        }
    }
}

public class ListTagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListTagResourcesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class PutEvaluationsRequest : Tea.TeaModel {
    public var deleteMode: Bool?

    public var evaluations: String?

    public var resultToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deleteMode != nil {
            map["DeleteMode"] = self.deleteMode!
        }
        if self.evaluations != nil {
            map["Evaluations"] = self.evaluations!
        }
        if self.resultToken != nil {
            map["ResultToken"] = self.resultToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DeleteMode"] as? Bool {
            self.deleteMode = value
        }
        if let value = dict["Evaluations"] as? String {
            self.evaluations = value
        }
        if let value = dict["ResultToken"] as? String {
            self.resultToken = value
        }
    }
}

public class PutEvaluationsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? Bool {
            self.result = value
        }
    }
}

public class PutEvaluationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PutEvaluationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = PutEvaluationsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RevertAggregateEvaluationResultsRequest : Tea.TeaModel {
    public class Resources : Tea.TeaModel {
        public var region: String?

        public var resourceAccountId: Int64?

        public var resourceId: String?

        public var resourceType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.region != nil {
                map["Region"] = self.region!
            }
            if self.resourceAccountId != nil {
                map["ResourceAccountId"] = self.resourceAccountId!
            }
            if self.resourceId != nil {
                map["ResourceId"] = self.resourceId!
            }
            if self.resourceType != nil {
                map["ResourceType"] = self.resourceType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Region"] as? String {
                self.region = value
            }
            if let value = dict["ResourceAccountId"] as? Int64 {
                self.resourceAccountId = value
            }
            if let value = dict["ResourceId"] as? String {
                self.resourceId = value
            }
            if let value = dict["ResourceType"] as? String {
                self.resourceType = value
            }
        }
    }
    public var aggregatorId: String?

    public var configRuleId: String?

    public var resources: [RevertAggregateEvaluationResultsRequest.Resources]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aggregatorId != nil {
            map["AggregatorId"] = self.aggregatorId!
        }
        if self.configRuleId != nil {
            map["ConfigRuleId"] = self.configRuleId!
        }
        if self.resources != nil {
            var tmp : [Any] = []
            for k in self.resources! {
                tmp.append(k.toMap())
            }
            map["Resources"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AggregatorId"] as? String {
            self.aggregatorId = value
        }
        if let value = dict["ConfigRuleId"] as? String {
            self.configRuleId = value
        }
        if let value = dict["Resources"] as? [Any?] {
            var tmp : [RevertAggregateEvaluationResultsRequest.Resources] = []
            for v in value {
                if v != nil {
                    var model = RevertAggregateEvaluationResultsRequest.Resources()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.resources = tmp
        }
    }
}

public class RevertAggregateEvaluationResultsShrinkRequest : Tea.TeaModel {
    public var aggregatorId: String?

    public var configRuleId: String?

    public var resourcesShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aggregatorId != nil {
            map["AggregatorId"] = self.aggregatorId!
        }
        if self.configRuleId != nil {
            map["ConfigRuleId"] = self.configRuleId!
        }
        if self.resourcesShrink != nil {
            map["Resources"] = self.resourcesShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AggregatorId"] as? String {
            self.aggregatorId = value
        }
        if let value = dict["ConfigRuleId"] as? String {
            self.configRuleId = value
        }
        if let value = dict["Resources"] as? String {
            self.resourcesShrink = value
        }
    }
}

public class RevertAggregateEvaluationResultsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class RevertAggregateEvaluationResultsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RevertAggregateEvaluationResultsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RevertAggregateEvaluationResultsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RevertEvaluationResultsRequest : Tea.TeaModel {
    public class Resources : Tea.TeaModel {
        public var region: String?

        public var resourceAccountId: Int64?

        public var resourceId: String?

        public var resourceType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.region != nil {
                map["Region"] = self.region!
            }
            if self.resourceAccountId != nil {
                map["ResourceAccountId"] = self.resourceAccountId!
            }
            if self.resourceId != nil {
                map["ResourceId"] = self.resourceId!
            }
            if self.resourceType != nil {
                map["ResourceType"] = self.resourceType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Region"] as? String {
                self.region = value
            }
            if let value = dict["ResourceAccountId"] as? Int64 {
                self.resourceAccountId = value
            }
            if let value = dict["ResourceId"] as? String {
                self.resourceId = value
            }
            if let value = dict["ResourceType"] as? String {
                self.resourceType = value
            }
        }
    }
    public var configRuleId: String?

    public var resources: [RevertEvaluationResultsRequest.Resources]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configRuleId != nil {
            map["ConfigRuleId"] = self.configRuleId!
        }
        if self.resources != nil {
            var tmp : [Any] = []
            for k in self.resources! {
                tmp.append(k.toMap())
            }
            map["Resources"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ConfigRuleId"] as? String {
            self.configRuleId = value
        }
        if let value = dict["Resources"] as? [Any?] {
            var tmp : [RevertEvaluationResultsRequest.Resources] = []
            for v in value {
                if v != nil {
                    var model = RevertEvaluationResultsRequest.Resources()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.resources = tmp
        }
    }
}

public class RevertEvaluationResultsShrinkRequest : Tea.TeaModel {
    public var configRuleId: String?

    public var resourcesShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configRuleId != nil {
            map["ConfigRuleId"] = self.configRuleId!
        }
        if self.resourcesShrink != nil {
            map["Resources"] = self.resourcesShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ConfigRuleId"] as? String {
            self.configRuleId = value
        }
        if let value = dict["Resources"] as? String {
            self.resourcesShrink = value
        }
    }
}

public class RevertEvaluationResultsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class RevertEvaluationResultsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RevertEvaluationResultsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RevertEvaluationResultsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class StartAggregateConfigRuleEvaluationRequest : Tea.TeaModel {
    public var aggregatorId: String?

    public var compliancePackId: String?

    public var configRuleId: String?

    public var revertEvaluation: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aggregatorId != nil {
            map["AggregatorId"] = self.aggregatorId!
        }
        if self.compliancePackId != nil {
            map["CompliancePackId"] = self.compliancePackId!
        }
        if self.configRuleId != nil {
            map["ConfigRuleId"] = self.configRuleId!
        }
        if self.revertEvaluation != nil {
            map["RevertEvaluation"] = self.revertEvaluation!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AggregatorId"] as? String {
            self.aggregatorId = value
        }
        if let value = dict["CompliancePackId"] as? String {
            self.compliancePackId = value
        }
        if let value = dict["ConfigRuleId"] as? String {
            self.configRuleId = value
        }
        if let value = dict["RevertEvaluation"] as? Bool {
            self.revertEvaluation = value
        }
    }
}

public class StartAggregateConfigRuleEvaluationResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? Bool {
            self.result = value
        }
    }
}

public class StartAggregateConfigRuleEvaluationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartAggregateConfigRuleEvaluationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = StartAggregateConfigRuleEvaluationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class StartAggregateRemediationRequest : Tea.TeaModel {
    public var aggregatorId: String?

    public var configRuleId: String?

    public var resourceAccountId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aggregatorId != nil {
            map["AggregatorId"] = self.aggregatorId!
        }
        if self.configRuleId != nil {
            map["ConfigRuleId"] = self.configRuleId!
        }
        if self.resourceAccountId != nil {
            map["ResourceAccountId"] = self.resourceAccountId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AggregatorId"] as? String {
            self.aggregatorId = value
        }
        if let value = dict["ConfigRuleId"] as? String {
            self.configRuleId = value
        }
        if let value = dict["ResourceAccountId"] as? Int64 {
            self.resourceAccountId = value
        }
    }
}

public class StartAggregateRemediationResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? Bool {
            self.data = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class StartAggregateRemediationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartAggregateRemediationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = StartAggregateRemediationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class StartConfigRuleEvaluationRequest : Tea.TeaModel {
    public var compliancePackId: String?

    public var configRuleId: String?

    public var revertEvaluation: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.compliancePackId != nil {
            map["CompliancePackId"] = self.compliancePackId!
        }
        if self.configRuleId != nil {
            map["ConfigRuleId"] = self.configRuleId!
        }
        if self.revertEvaluation != nil {
            map["RevertEvaluation"] = self.revertEvaluation!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CompliancePackId"] as? String {
            self.compliancePackId = value
        }
        if let value = dict["ConfigRuleId"] as? String {
            self.configRuleId = value
        }
        if let value = dict["RevertEvaluation"] as? Bool {
            self.revertEvaluation = value
        }
    }
}

public class StartConfigRuleEvaluationResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? Bool {
            self.result = value
        }
    }
}

public class StartConfigRuleEvaluationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartConfigRuleEvaluationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = StartConfigRuleEvaluationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class StartConfigurationRecorderResponseBody : Tea.TeaModel {
    public class ConfigurationRecorder : Tea.TeaModel {
        public var configurationRecorderStatus: String?

        public var resourceTypes: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.configurationRecorderStatus != nil {
                map["ConfigurationRecorderStatus"] = self.configurationRecorderStatus!
            }
            if self.resourceTypes != nil {
                map["ResourceTypes"] = self.resourceTypes!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ConfigurationRecorderStatus"] as? String {
                self.configurationRecorderStatus = value
            }
            if let value = dict["ResourceTypes"] as? [String] {
                self.resourceTypes = value
            }
        }
    }
    public var configurationRecorder: StartConfigurationRecorderResponseBody.ConfigurationRecorder?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.configurationRecorder?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configurationRecorder != nil {
            map["ConfigurationRecorder"] = self.configurationRecorder?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ConfigurationRecorder"] as? [String: Any?] {
            var model = StartConfigurationRecorderResponseBody.ConfigurationRecorder()
            model.fromMap(value)
            self.configurationRecorder = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class StartConfigurationRecorderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartConfigurationRecorderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = StartConfigurationRecorderResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class StartRemediationRequest : Tea.TeaModel {
    public var configRuleId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configRuleId != nil {
            map["ConfigRuleId"] = self.configRuleId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ConfigRuleId"] as? String {
            self.configRuleId = value
        }
    }
}

public class StartRemediationResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? Bool {
            self.data = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class StartRemediationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartRemediationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = StartRemediationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class StopConfigurationRecorderResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var stopConfigurationRecorderResult: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.stopConfigurationRecorderResult != nil {
            map["StopConfigurationRecorderResult"] = self.stopConfigurationRecorderResult!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["StopConfigurationRecorderResult"] as? Bool {
            self.stopConfigurationRecorderResult = value
        }
    }
}

public class StopConfigurationRecorderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopConfigurationRecorderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = StopConfigurationRecorderResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class TagResourcesRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var regionId: String?

    public var resourceId: [String]?

    public var resourceType: String?

    public var tag: [TagResourcesRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceId"] as? [String] {
            self.resourceId = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [TagResourcesRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = TagResourcesRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
    }
}

public class TagResourcesShrinkRequest : Tea.TeaModel {
    public var regionId: String?

    public var resourceId: [String]?

    public var resourceType: String?

    public var tagShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tagShrink != nil {
            map["Tag"] = self.tagShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceId"] as? [String] {
            self.resourceId = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
        if let value = dict["Tag"] as? String {
            self.tagShrink = value
        }
    }
}

public class TagResourcesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class TagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: TagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = TagResourcesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UntagResourcesRequest : Tea.TeaModel {
    public var all: Bool?

    public var regionId: String?

    public var resourceId: [String]?

    public var resourceType: String?

    public var tagKey: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.all != nil {
            map["All"] = self.all!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tagKey != nil {
            map["TagKey"] = self.tagKey!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["All"] as? Bool {
            self.all = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceId"] as? [String] {
            self.resourceId = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
        if let value = dict["TagKey"] as? [String] {
            self.tagKey = value
        }
    }
}

public class UntagResourcesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UntagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UntagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UntagResourcesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateAggregateCompliancePackRequest : Tea.TeaModel {
    public class ConfigRules : Tea.TeaModel {
        public class ConfigRuleParameters : Tea.TeaModel {
            public var parameterName: String?

            public var parameterValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.parameterName != nil {
                    map["ParameterName"] = self.parameterName!
                }
                if self.parameterValue != nil {
                    map["ParameterValue"] = self.parameterValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ParameterName"] as? String {
                    self.parameterName = value
                }
                if let value = dict["ParameterValue"] as? String {
                    self.parameterValue = value
                }
            }
        }
        public var configRuleId: String?

        public var configRuleName: String?

        public var configRuleParameters: [UpdateAggregateCompliancePackRequest.ConfigRules.ConfigRuleParameters]?

        public var description_: String?

        public var managedRuleIdentifier: String?

        public var riskLevel: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.configRuleId != nil {
                map["ConfigRuleId"] = self.configRuleId!
            }
            if self.configRuleName != nil {
                map["ConfigRuleName"] = self.configRuleName!
            }
            if self.configRuleParameters != nil {
                var tmp : [Any] = []
                for k in self.configRuleParameters! {
                    tmp.append(k.toMap())
                }
                map["ConfigRuleParameters"] = tmp
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.managedRuleIdentifier != nil {
                map["ManagedRuleIdentifier"] = self.managedRuleIdentifier!
            }
            if self.riskLevel != nil {
                map["RiskLevel"] = self.riskLevel!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ConfigRuleId"] as? String {
                self.configRuleId = value
            }
            if let value = dict["ConfigRuleName"] as? String {
                self.configRuleName = value
            }
            if let value = dict["ConfigRuleParameters"] as? [Any?] {
                var tmp : [UpdateAggregateCompliancePackRequest.ConfigRules.ConfigRuleParameters] = []
                for v in value {
                    if v != nil {
                        var model = UpdateAggregateCompliancePackRequest.ConfigRules.ConfigRuleParameters()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.configRuleParameters = tmp
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["ManagedRuleIdentifier"] as? String {
                self.managedRuleIdentifier = value
            }
            if let value = dict["RiskLevel"] as? Int32 {
                self.riskLevel = value
            }
        }
    }
    public class ExcludeTagsScope : Tea.TeaModel {
        public var tagKey: String?

        public var tagValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tagKey != nil {
                map["TagKey"] = self.tagKey!
            }
            if self.tagValue != nil {
                map["TagValue"] = self.tagValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["TagKey"] as? String {
                self.tagKey = value
            }
            if let value = dict["TagValue"] as? String {
                self.tagValue = value
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public class TagsScope : Tea.TeaModel {
        public var tagKey: String?

        public var tagValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tagKey != nil {
                map["TagKey"] = self.tagKey!
            }
            if self.tagValue != nil {
                map["TagValue"] = self.tagValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["TagKey"] as? String {
                self.tagKey = value
            }
            if let value = dict["TagValue"] as? String {
                self.tagValue = value
            }
        }
    }
    public var aggregatorId: String?

    public var clientToken: String?

    public var compliancePackId: String?

    public var compliancePackName: String?

    public var configRules: [UpdateAggregateCompliancePackRequest.ConfigRules]?

    public var description_: String?

    public var excludeRegionIdsScope: String?

    public var excludeResourceGroupIdsScope: String?

    public var excludeResourceIdsScope: String?

    public var excludeTagsScope: [UpdateAggregateCompliancePackRequest.ExcludeTagsScope]?

    public var regionIdsScope: String?

    public var resourceGroupIdsScope: String?

    public var resourceIdsScope: String?

    public var riskLevel: Int32?

    public var tag: [UpdateAggregateCompliancePackRequest.Tag]?

    public var tagKeyScope: String?

    public var tagValueScope: String?

    public var tagsScope: [UpdateAggregateCompliancePackRequest.TagsScope]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aggregatorId != nil {
            map["AggregatorId"] = self.aggregatorId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.compliancePackId != nil {
            map["CompliancePackId"] = self.compliancePackId!
        }
        if self.compliancePackName != nil {
            map["CompliancePackName"] = self.compliancePackName!
        }
        if self.configRules != nil {
            var tmp : [Any] = []
            for k in self.configRules! {
                tmp.append(k.toMap())
            }
            map["ConfigRules"] = tmp
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.excludeRegionIdsScope != nil {
            map["ExcludeRegionIdsScope"] = self.excludeRegionIdsScope!
        }
        if self.excludeResourceGroupIdsScope != nil {
            map["ExcludeResourceGroupIdsScope"] = self.excludeResourceGroupIdsScope!
        }
        if self.excludeResourceIdsScope != nil {
            map["ExcludeResourceIdsScope"] = self.excludeResourceIdsScope!
        }
        if self.excludeTagsScope != nil {
            var tmp : [Any] = []
            for k in self.excludeTagsScope! {
                tmp.append(k.toMap())
            }
            map["ExcludeTagsScope"] = tmp
        }
        if self.regionIdsScope != nil {
            map["RegionIdsScope"] = self.regionIdsScope!
        }
        if self.resourceGroupIdsScope != nil {
            map["ResourceGroupIdsScope"] = self.resourceGroupIdsScope!
        }
        if self.resourceIdsScope != nil {
            map["ResourceIdsScope"] = self.resourceIdsScope!
        }
        if self.riskLevel != nil {
            map["RiskLevel"] = self.riskLevel!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.tagKeyScope != nil {
            map["TagKeyScope"] = self.tagKeyScope!
        }
        if self.tagValueScope != nil {
            map["TagValueScope"] = self.tagValueScope!
        }
        if self.tagsScope != nil {
            var tmp : [Any] = []
            for k in self.tagsScope! {
                tmp.append(k.toMap())
            }
            map["TagsScope"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AggregatorId"] as? String {
            self.aggregatorId = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["CompliancePackId"] as? String {
            self.compliancePackId = value
        }
        if let value = dict["CompliancePackName"] as? String {
            self.compliancePackName = value
        }
        if let value = dict["ConfigRules"] as? [Any?] {
            var tmp : [UpdateAggregateCompliancePackRequest.ConfigRules] = []
            for v in value {
                if v != nil {
                    var model = UpdateAggregateCompliancePackRequest.ConfigRules()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.configRules = tmp
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["ExcludeRegionIdsScope"] as? String {
            self.excludeRegionIdsScope = value
        }
        if let value = dict["ExcludeResourceGroupIdsScope"] as? String {
            self.excludeResourceGroupIdsScope = value
        }
        if let value = dict["ExcludeResourceIdsScope"] as? String {
            self.excludeResourceIdsScope = value
        }
        if let value = dict["ExcludeTagsScope"] as? [Any?] {
            var tmp : [UpdateAggregateCompliancePackRequest.ExcludeTagsScope] = []
            for v in value {
                if v != nil {
                    var model = UpdateAggregateCompliancePackRequest.ExcludeTagsScope()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.excludeTagsScope = tmp
        }
        if let value = dict["RegionIdsScope"] as? String {
            self.regionIdsScope = value
        }
        if let value = dict["ResourceGroupIdsScope"] as? String {
            self.resourceGroupIdsScope = value
        }
        if let value = dict["ResourceIdsScope"] as? String {
            self.resourceIdsScope = value
        }
        if let value = dict["RiskLevel"] as? Int32 {
            self.riskLevel = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [UpdateAggregateCompliancePackRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = UpdateAggregateCompliancePackRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
        if let value = dict["TagKeyScope"] as? String {
            self.tagKeyScope = value
        }
        if let value = dict["TagValueScope"] as? String {
            self.tagValueScope = value
        }
        if let value = dict["TagsScope"] as? [Any?] {
            var tmp : [UpdateAggregateCompliancePackRequest.TagsScope] = []
            for v in value {
                if v != nil {
                    var model = UpdateAggregateCompliancePackRequest.TagsScope()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tagsScope = tmp
        }
    }
}

public class UpdateAggregateCompliancePackShrinkRequest : Tea.TeaModel {
    public class ExcludeTagsScope : Tea.TeaModel {
        public var tagKey: String?

        public var tagValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tagKey != nil {
                map["TagKey"] = self.tagKey!
            }
            if self.tagValue != nil {
                map["TagValue"] = self.tagValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["TagKey"] as? String {
                self.tagKey = value
            }
            if let value = dict["TagValue"] as? String {
                self.tagValue = value
            }
        }
    }
    public class TagsScope : Tea.TeaModel {
        public var tagKey: String?

        public var tagValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tagKey != nil {
                map["TagKey"] = self.tagKey!
            }
            if self.tagValue != nil {
                map["TagValue"] = self.tagValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["TagKey"] as? String {
                self.tagKey = value
            }
            if let value = dict["TagValue"] as? String {
                self.tagValue = value
            }
        }
    }
    public var aggregatorId: String?

    public var clientToken: String?

    public var compliancePackId: String?

    public var compliancePackName: String?

    public var configRulesShrink: String?

    public var description_: String?

    public var excludeRegionIdsScope: String?

    public var excludeResourceGroupIdsScope: String?

    public var excludeResourceIdsScope: String?

    public var excludeTagsScope: [UpdateAggregateCompliancePackShrinkRequest.ExcludeTagsScope]?

    public var regionIdsScope: String?

    public var resourceGroupIdsScope: String?

    public var resourceIdsScope: String?

    public var riskLevel: Int32?

    public var tagShrink: String?

    public var tagKeyScope: String?

    public var tagValueScope: String?

    public var tagsScope: [UpdateAggregateCompliancePackShrinkRequest.TagsScope]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aggregatorId != nil {
            map["AggregatorId"] = self.aggregatorId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.compliancePackId != nil {
            map["CompliancePackId"] = self.compliancePackId!
        }
        if self.compliancePackName != nil {
            map["CompliancePackName"] = self.compliancePackName!
        }
        if self.configRulesShrink != nil {
            map["ConfigRules"] = self.configRulesShrink!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.excludeRegionIdsScope != nil {
            map["ExcludeRegionIdsScope"] = self.excludeRegionIdsScope!
        }
        if self.excludeResourceGroupIdsScope != nil {
            map["ExcludeResourceGroupIdsScope"] = self.excludeResourceGroupIdsScope!
        }
        if self.excludeResourceIdsScope != nil {
            map["ExcludeResourceIdsScope"] = self.excludeResourceIdsScope!
        }
        if self.excludeTagsScope != nil {
            var tmp : [Any] = []
            for k in self.excludeTagsScope! {
                tmp.append(k.toMap())
            }
            map["ExcludeTagsScope"] = tmp
        }
        if self.regionIdsScope != nil {
            map["RegionIdsScope"] = self.regionIdsScope!
        }
        if self.resourceGroupIdsScope != nil {
            map["ResourceGroupIdsScope"] = self.resourceGroupIdsScope!
        }
        if self.resourceIdsScope != nil {
            map["ResourceIdsScope"] = self.resourceIdsScope!
        }
        if self.riskLevel != nil {
            map["RiskLevel"] = self.riskLevel!
        }
        if self.tagShrink != nil {
            map["Tag"] = self.tagShrink!
        }
        if self.tagKeyScope != nil {
            map["TagKeyScope"] = self.tagKeyScope!
        }
        if self.tagValueScope != nil {
            map["TagValueScope"] = self.tagValueScope!
        }
        if self.tagsScope != nil {
            var tmp : [Any] = []
            for k in self.tagsScope! {
                tmp.append(k.toMap())
            }
            map["TagsScope"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AggregatorId"] as? String {
            self.aggregatorId = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["CompliancePackId"] as? String {
            self.compliancePackId = value
        }
        if let value = dict["CompliancePackName"] as? String {
            self.compliancePackName = value
        }
        if let value = dict["ConfigRules"] as? String {
            self.configRulesShrink = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["ExcludeRegionIdsScope"] as? String {
            self.excludeRegionIdsScope = value
        }
        if let value = dict["ExcludeResourceGroupIdsScope"] as? String {
            self.excludeResourceGroupIdsScope = value
        }
        if let value = dict["ExcludeResourceIdsScope"] as? String {
            self.excludeResourceIdsScope = value
        }
        if let value = dict["ExcludeTagsScope"] as? [Any?] {
            var tmp : [UpdateAggregateCompliancePackShrinkRequest.ExcludeTagsScope] = []
            for v in value {
                if v != nil {
                    var model = UpdateAggregateCompliancePackShrinkRequest.ExcludeTagsScope()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.excludeTagsScope = tmp
        }
        if let value = dict["RegionIdsScope"] as? String {
            self.regionIdsScope = value
        }
        if let value = dict["ResourceGroupIdsScope"] as? String {
            self.resourceGroupIdsScope = value
        }
        if let value = dict["ResourceIdsScope"] as? String {
            self.resourceIdsScope = value
        }
        if let value = dict["RiskLevel"] as? Int32 {
            self.riskLevel = value
        }
        if let value = dict["Tag"] as? String {
            self.tagShrink = value
        }
        if let value = dict["TagKeyScope"] as? String {
            self.tagKeyScope = value
        }
        if let value = dict["TagValueScope"] as? String {
            self.tagValueScope = value
        }
        if let value = dict["TagsScope"] as? [Any?] {
            var tmp : [UpdateAggregateCompliancePackShrinkRequest.TagsScope] = []
            for v in value {
                if v != nil {
                    var model = UpdateAggregateCompliancePackShrinkRequest.TagsScope()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tagsScope = tmp
        }
    }
}

public class UpdateAggregateCompliancePackResponseBody : Tea.TeaModel {
    public var compliancePackId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.compliancePackId != nil {
            map["CompliancePackId"] = self.compliancePackId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CompliancePackId"] as? String {
            self.compliancePackId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateAggregateCompliancePackResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateAggregateCompliancePackResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateAggregateCompliancePackResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateAggregateConfigDeliveryChannelRequest : Tea.TeaModel {
    public var aggregatorId: String?

    public var clientToken: String?

    public var compliantSnapshot: Bool?

    public var configurationItemChangeNotification: Bool?

    public var configurationSnapshot: Bool?

    public var deliveryChannelCondition: String?

    public var deliveryChannelId: String?

    public var deliveryChannelName: String?

    public var deliveryChannelTargetArn: String?

    public var deliverySnapshotTime: String?

    public var description_: String?

    public var nonCompliantNotification: Bool?

    public var oversizedDataOSSTargetArn: String?

    public var status: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aggregatorId != nil {
            map["AggregatorId"] = self.aggregatorId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.compliantSnapshot != nil {
            map["CompliantSnapshot"] = self.compliantSnapshot!
        }
        if self.configurationItemChangeNotification != nil {
            map["ConfigurationItemChangeNotification"] = self.configurationItemChangeNotification!
        }
        if self.configurationSnapshot != nil {
            map["ConfigurationSnapshot"] = self.configurationSnapshot!
        }
        if self.deliveryChannelCondition != nil {
            map["DeliveryChannelCondition"] = self.deliveryChannelCondition!
        }
        if self.deliveryChannelId != nil {
            map["DeliveryChannelId"] = self.deliveryChannelId!
        }
        if self.deliveryChannelName != nil {
            map["DeliveryChannelName"] = self.deliveryChannelName!
        }
        if self.deliveryChannelTargetArn != nil {
            map["DeliveryChannelTargetArn"] = self.deliveryChannelTargetArn!
        }
        if self.deliverySnapshotTime != nil {
            map["DeliverySnapshotTime"] = self.deliverySnapshotTime!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.nonCompliantNotification != nil {
            map["NonCompliantNotification"] = self.nonCompliantNotification!
        }
        if self.oversizedDataOSSTargetArn != nil {
            map["OversizedDataOSSTargetArn"] = self.oversizedDataOSSTargetArn!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AggregatorId"] as? String {
            self.aggregatorId = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["CompliantSnapshot"] as? Bool {
            self.compliantSnapshot = value
        }
        if let value = dict["ConfigurationItemChangeNotification"] as? Bool {
            self.configurationItemChangeNotification = value
        }
        if let value = dict["ConfigurationSnapshot"] as? Bool {
            self.configurationSnapshot = value
        }
        if let value = dict["DeliveryChannelCondition"] as? String {
            self.deliveryChannelCondition = value
        }
        if let value = dict["DeliveryChannelId"] as? String {
            self.deliveryChannelId = value
        }
        if let value = dict["DeliveryChannelName"] as? String {
            self.deliveryChannelName = value
        }
        if let value = dict["DeliveryChannelTargetArn"] as? String {
            self.deliveryChannelTargetArn = value
        }
        if let value = dict["DeliverySnapshotTime"] as? String {
            self.deliverySnapshotTime = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["NonCompliantNotification"] as? Bool {
            self.nonCompliantNotification = value
        }
        if let value = dict["OversizedDataOSSTargetArn"] as? String {
            self.oversizedDataOSSTargetArn = value
        }
        if let value = dict["Status"] as? Int64 {
            self.status = value
        }
    }
}

public class UpdateAggregateConfigDeliveryChannelResponseBody : Tea.TeaModel {
    public var deliveryChannelId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deliveryChannelId != nil {
            map["DeliveryChannelId"] = self.deliveryChannelId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DeliveryChannelId"] as? String {
            self.deliveryChannelId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateAggregateConfigDeliveryChannelResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateAggregateConfigDeliveryChannelResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateAggregateConfigDeliveryChannelResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateAggregateConfigRuleRequest : Tea.TeaModel {
    public class ExcludeTagsScope : Tea.TeaModel {
        public var tagKey: String?

        public var tagValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tagKey != nil {
                map["TagKey"] = self.tagKey!
            }
            if self.tagValue != nil {
                map["TagValue"] = self.tagValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["TagKey"] as? String {
                self.tagKey = value
            }
            if let value = dict["TagValue"] as? String {
                self.tagValue = value
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public class TagsScope : Tea.TeaModel {
        public var tagKey: String?

        public var tagValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tagKey != nil {
                map["TagKey"] = self.tagKey!
            }
            if self.tagValue != nil {
                map["TagValue"] = self.tagValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["TagKey"] as? String {
                self.tagKey = value
            }
            if let value = dict["TagValue"] as? String {
                self.tagValue = value
            }
        }
    }
    public var accountIdsScope: String?

    public var aggregatorId: String?

    public var clientToken: String?

    public var configRuleId: String?

    public var configRuleName: String?

    public var configRuleTriggerTypes: String?

    public var description_: String?

    public var excludeAccountIdsScope: String?

    public var excludeFolderIdsScope: String?

    public var excludeRegionIdsScope: String?

    public var excludeResourceGroupIdsScope: String?

    public var excludeResourceIdsScope: String?

    public var excludeTagsScope: [UpdateAggregateConfigRuleRequest.ExcludeTagsScope]?

    public var folderIdsScope: String?

    public var inputParameters: [String: Any]?

    public var maximumExecutionFrequency: String?

    public var regionIdsScope: String?

    public var resourceGroupIdsScope: String?

    public var resourceIdsScope: String?

    public var resourceNameScope: String?

    public var resourceTypesScope: [String]?

    public var riskLevel: Int32?

    public var tag: [UpdateAggregateConfigRuleRequest.Tag]?

    public var tagKeyLogicScope: String?

    public var tagKeyScope: String?

    public var tagValueScope: String?

    public var tagsScope: [UpdateAggregateConfigRuleRequest.TagsScope]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountIdsScope != nil {
            map["AccountIdsScope"] = self.accountIdsScope!
        }
        if self.aggregatorId != nil {
            map["AggregatorId"] = self.aggregatorId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.configRuleId != nil {
            map["ConfigRuleId"] = self.configRuleId!
        }
        if self.configRuleName != nil {
            map["ConfigRuleName"] = self.configRuleName!
        }
        if self.configRuleTriggerTypes != nil {
            map["ConfigRuleTriggerTypes"] = self.configRuleTriggerTypes!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.excludeAccountIdsScope != nil {
            map["ExcludeAccountIdsScope"] = self.excludeAccountIdsScope!
        }
        if self.excludeFolderIdsScope != nil {
            map["ExcludeFolderIdsScope"] = self.excludeFolderIdsScope!
        }
        if self.excludeRegionIdsScope != nil {
            map["ExcludeRegionIdsScope"] = self.excludeRegionIdsScope!
        }
        if self.excludeResourceGroupIdsScope != nil {
            map["ExcludeResourceGroupIdsScope"] = self.excludeResourceGroupIdsScope!
        }
        if self.excludeResourceIdsScope != nil {
            map["ExcludeResourceIdsScope"] = self.excludeResourceIdsScope!
        }
        if self.excludeTagsScope != nil {
            var tmp : [Any] = []
            for k in self.excludeTagsScope! {
                tmp.append(k.toMap())
            }
            map["ExcludeTagsScope"] = tmp
        }
        if self.folderIdsScope != nil {
            map["FolderIdsScope"] = self.folderIdsScope!
        }
        if self.inputParameters != nil {
            map["InputParameters"] = self.inputParameters!
        }
        if self.maximumExecutionFrequency != nil {
            map["MaximumExecutionFrequency"] = self.maximumExecutionFrequency!
        }
        if self.regionIdsScope != nil {
            map["RegionIdsScope"] = self.regionIdsScope!
        }
        if self.resourceGroupIdsScope != nil {
            map["ResourceGroupIdsScope"] = self.resourceGroupIdsScope!
        }
        if self.resourceIdsScope != nil {
            map["ResourceIdsScope"] = self.resourceIdsScope!
        }
        if self.resourceNameScope != nil {
            map["ResourceNameScope"] = self.resourceNameScope!
        }
        if self.resourceTypesScope != nil {
            map["ResourceTypesScope"] = self.resourceTypesScope!
        }
        if self.riskLevel != nil {
            map["RiskLevel"] = self.riskLevel!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.tagKeyLogicScope != nil {
            map["TagKeyLogicScope"] = self.tagKeyLogicScope!
        }
        if self.tagKeyScope != nil {
            map["TagKeyScope"] = self.tagKeyScope!
        }
        if self.tagValueScope != nil {
            map["TagValueScope"] = self.tagValueScope!
        }
        if self.tagsScope != nil {
            var tmp : [Any] = []
            for k in self.tagsScope! {
                tmp.append(k.toMap())
            }
            map["TagsScope"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AccountIdsScope"] as? String {
            self.accountIdsScope = value
        }
        if let value = dict["AggregatorId"] as? String {
            self.aggregatorId = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["ConfigRuleId"] as? String {
            self.configRuleId = value
        }
        if let value = dict["ConfigRuleName"] as? String {
            self.configRuleName = value
        }
        if let value = dict["ConfigRuleTriggerTypes"] as? String {
            self.configRuleTriggerTypes = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["ExcludeAccountIdsScope"] as? String {
            self.excludeAccountIdsScope = value
        }
        if let value = dict["ExcludeFolderIdsScope"] as? String {
            self.excludeFolderIdsScope = value
        }
        if let value = dict["ExcludeRegionIdsScope"] as? String {
            self.excludeRegionIdsScope = value
        }
        if let value = dict["ExcludeResourceGroupIdsScope"] as? String {
            self.excludeResourceGroupIdsScope = value
        }
        if let value = dict["ExcludeResourceIdsScope"] as? String {
            self.excludeResourceIdsScope = value
        }
        if let value = dict["ExcludeTagsScope"] as? [Any?] {
            var tmp : [UpdateAggregateConfigRuleRequest.ExcludeTagsScope] = []
            for v in value {
                if v != nil {
                    var model = UpdateAggregateConfigRuleRequest.ExcludeTagsScope()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.excludeTagsScope = tmp
        }
        if let value = dict["FolderIdsScope"] as? String {
            self.folderIdsScope = value
        }
        if let value = dict["InputParameters"] as? [String: Any] {
            self.inputParameters = value
        }
        if let value = dict["MaximumExecutionFrequency"] as? String {
            self.maximumExecutionFrequency = value
        }
        if let value = dict["RegionIdsScope"] as? String {
            self.regionIdsScope = value
        }
        if let value = dict["ResourceGroupIdsScope"] as? String {
            self.resourceGroupIdsScope = value
        }
        if let value = dict["ResourceIdsScope"] as? String {
            self.resourceIdsScope = value
        }
        if let value = dict["ResourceNameScope"] as? String {
            self.resourceNameScope = value
        }
        if let value = dict["ResourceTypesScope"] as? [String] {
            self.resourceTypesScope = value
        }
        if let value = dict["RiskLevel"] as? Int32 {
            self.riskLevel = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [UpdateAggregateConfigRuleRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = UpdateAggregateConfigRuleRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
        if let value = dict["TagKeyLogicScope"] as? String {
            self.tagKeyLogicScope = value
        }
        if let value = dict["TagKeyScope"] as? String {
            self.tagKeyScope = value
        }
        if let value = dict["TagValueScope"] as? String {
            self.tagValueScope = value
        }
        if let value = dict["TagsScope"] as? [Any?] {
            var tmp : [UpdateAggregateConfigRuleRequest.TagsScope] = []
            for v in value {
                if v != nil {
                    var model = UpdateAggregateConfigRuleRequest.TagsScope()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tagsScope = tmp
        }
    }
}

public class UpdateAggregateConfigRuleShrinkRequest : Tea.TeaModel {
    public class ExcludeTagsScope : Tea.TeaModel {
        public var tagKey: String?

        public var tagValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tagKey != nil {
                map["TagKey"] = self.tagKey!
            }
            if self.tagValue != nil {
                map["TagValue"] = self.tagValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["TagKey"] as? String {
                self.tagKey = value
            }
            if let value = dict["TagValue"] as? String {
                self.tagValue = value
            }
        }
    }
    public class TagsScope : Tea.TeaModel {
        public var tagKey: String?

        public var tagValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tagKey != nil {
                map["TagKey"] = self.tagKey!
            }
            if self.tagValue != nil {
                map["TagValue"] = self.tagValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["TagKey"] as? String {
                self.tagKey = value
            }
            if let value = dict["TagValue"] as? String {
                self.tagValue = value
            }
        }
    }
    public var accountIdsScope: String?

    public var aggregatorId: String?

    public var clientToken: String?

    public var configRuleId: String?

    public var configRuleName: String?

    public var configRuleTriggerTypes: String?

    public var description_: String?

    public var excludeAccountIdsScope: String?

    public var excludeFolderIdsScope: String?

    public var excludeRegionIdsScope: String?

    public var excludeResourceGroupIdsScope: String?

    public var excludeResourceIdsScope: String?

    public var excludeTagsScope: [UpdateAggregateConfigRuleShrinkRequest.ExcludeTagsScope]?

    public var folderIdsScope: String?

    public var inputParametersShrink: String?

    public var maximumExecutionFrequency: String?

    public var regionIdsScope: String?

    public var resourceGroupIdsScope: String?

    public var resourceIdsScope: String?

    public var resourceNameScope: String?

    public var resourceTypesScopeShrink: String?

    public var riskLevel: Int32?

    public var tagShrink: String?

    public var tagKeyLogicScope: String?

    public var tagKeyScope: String?

    public var tagValueScope: String?

    public var tagsScope: [UpdateAggregateConfigRuleShrinkRequest.TagsScope]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountIdsScope != nil {
            map["AccountIdsScope"] = self.accountIdsScope!
        }
        if self.aggregatorId != nil {
            map["AggregatorId"] = self.aggregatorId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.configRuleId != nil {
            map["ConfigRuleId"] = self.configRuleId!
        }
        if self.configRuleName != nil {
            map["ConfigRuleName"] = self.configRuleName!
        }
        if self.configRuleTriggerTypes != nil {
            map["ConfigRuleTriggerTypes"] = self.configRuleTriggerTypes!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.excludeAccountIdsScope != nil {
            map["ExcludeAccountIdsScope"] = self.excludeAccountIdsScope!
        }
        if self.excludeFolderIdsScope != nil {
            map["ExcludeFolderIdsScope"] = self.excludeFolderIdsScope!
        }
        if self.excludeRegionIdsScope != nil {
            map["ExcludeRegionIdsScope"] = self.excludeRegionIdsScope!
        }
        if self.excludeResourceGroupIdsScope != nil {
            map["ExcludeResourceGroupIdsScope"] = self.excludeResourceGroupIdsScope!
        }
        if self.excludeResourceIdsScope != nil {
            map["ExcludeResourceIdsScope"] = self.excludeResourceIdsScope!
        }
        if self.excludeTagsScope != nil {
            var tmp : [Any] = []
            for k in self.excludeTagsScope! {
                tmp.append(k.toMap())
            }
            map["ExcludeTagsScope"] = tmp
        }
        if self.folderIdsScope != nil {
            map["FolderIdsScope"] = self.folderIdsScope!
        }
        if self.inputParametersShrink != nil {
            map["InputParameters"] = self.inputParametersShrink!
        }
        if self.maximumExecutionFrequency != nil {
            map["MaximumExecutionFrequency"] = self.maximumExecutionFrequency!
        }
        if self.regionIdsScope != nil {
            map["RegionIdsScope"] = self.regionIdsScope!
        }
        if self.resourceGroupIdsScope != nil {
            map["ResourceGroupIdsScope"] = self.resourceGroupIdsScope!
        }
        if self.resourceIdsScope != nil {
            map["ResourceIdsScope"] = self.resourceIdsScope!
        }
        if self.resourceNameScope != nil {
            map["ResourceNameScope"] = self.resourceNameScope!
        }
        if self.resourceTypesScopeShrink != nil {
            map["ResourceTypesScope"] = self.resourceTypesScopeShrink!
        }
        if self.riskLevel != nil {
            map["RiskLevel"] = self.riskLevel!
        }
        if self.tagShrink != nil {
            map["Tag"] = self.tagShrink!
        }
        if self.tagKeyLogicScope != nil {
            map["TagKeyLogicScope"] = self.tagKeyLogicScope!
        }
        if self.tagKeyScope != nil {
            map["TagKeyScope"] = self.tagKeyScope!
        }
        if self.tagValueScope != nil {
            map["TagValueScope"] = self.tagValueScope!
        }
        if self.tagsScope != nil {
            var tmp : [Any] = []
            for k in self.tagsScope! {
                tmp.append(k.toMap())
            }
            map["TagsScope"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AccountIdsScope"] as? String {
            self.accountIdsScope = value
        }
        if let value = dict["AggregatorId"] as? String {
            self.aggregatorId = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["ConfigRuleId"] as? String {
            self.configRuleId = value
        }
        if let value = dict["ConfigRuleName"] as? String {
            self.configRuleName = value
        }
        if let value = dict["ConfigRuleTriggerTypes"] as? String {
            self.configRuleTriggerTypes = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["ExcludeAccountIdsScope"] as? String {
            self.excludeAccountIdsScope = value
        }
        if let value = dict["ExcludeFolderIdsScope"] as? String {
            self.excludeFolderIdsScope = value
        }
        if let value = dict["ExcludeRegionIdsScope"] as? String {
            self.excludeRegionIdsScope = value
        }
        if let value = dict["ExcludeResourceGroupIdsScope"] as? String {
            self.excludeResourceGroupIdsScope = value
        }
        if let value = dict["ExcludeResourceIdsScope"] as? String {
            self.excludeResourceIdsScope = value
        }
        if let value = dict["ExcludeTagsScope"] as? [Any?] {
            var tmp : [UpdateAggregateConfigRuleShrinkRequest.ExcludeTagsScope] = []
            for v in value {
                if v != nil {
                    var model = UpdateAggregateConfigRuleShrinkRequest.ExcludeTagsScope()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.excludeTagsScope = tmp
        }
        if let value = dict["FolderIdsScope"] as? String {
            self.folderIdsScope = value
        }
        if let value = dict["InputParameters"] as? String {
            self.inputParametersShrink = value
        }
        if let value = dict["MaximumExecutionFrequency"] as? String {
            self.maximumExecutionFrequency = value
        }
        if let value = dict["RegionIdsScope"] as? String {
            self.regionIdsScope = value
        }
        if let value = dict["ResourceGroupIdsScope"] as? String {
            self.resourceGroupIdsScope = value
        }
        if let value = dict["ResourceIdsScope"] as? String {
            self.resourceIdsScope = value
        }
        if let value = dict["ResourceNameScope"] as? String {
            self.resourceNameScope = value
        }
        if let value = dict["ResourceTypesScope"] as? String {
            self.resourceTypesScopeShrink = value
        }
        if let value = dict["RiskLevel"] as? Int32 {
            self.riskLevel = value
        }
        if let value = dict["Tag"] as? String {
            self.tagShrink = value
        }
        if let value = dict["TagKeyLogicScope"] as? String {
            self.tagKeyLogicScope = value
        }
        if let value = dict["TagKeyScope"] as? String {
            self.tagKeyScope = value
        }
        if let value = dict["TagValueScope"] as? String {
            self.tagValueScope = value
        }
        if let value = dict["TagsScope"] as? [Any?] {
            var tmp : [UpdateAggregateConfigRuleShrinkRequest.TagsScope] = []
            for v in value {
                if v != nil {
                    var model = UpdateAggregateConfigRuleShrinkRequest.TagsScope()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tagsScope = tmp
        }
    }
}

public class UpdateAggregateConfigRuleResponseBody : Tea.TeaModel {
    public var configRuleId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configRuleId != nil {
            map["ConfigRuleId"] = self.configRuleId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ConfigRuleId"] as? String {
            self.configRuleId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateAggregateConfigRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateAggregateConfigRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateAggregateConfigRuleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateAggregateRemediationRequest : Tea.TeaModel {
    public var aggregatorId: String?

    public var invokeType: String?

    public var params: String?

    public var remediationId: String?

    public var remediationTemplateId: String?

    public var remediationType: String?

    public var sourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aggregatorId != nil {
            map["AggregatorId"] = self.aggregatorId!
        }
        if self.invokeType != nil {
            map["InvokeType"] = self.invokeType!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.remediationId != nil {
            map["RemediationId"] = self.remediationId!
        }
        if self.remediationTemplateId != nil {
            map["RemediationTemplateId"] = self.remediationTemplateId!
        }
        if self.remediationType != nil {
            map["RemediationType"] = self.remediationType!
        }
        if self.sourceType != nil {
            map["SourceType"] = self.sourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AggregatorId"] as? String {
            self.aggregatorId = value
        }
        if let value = dict["InvokeType"] as? String {
            self.invokeType = value
        }
        if let value = dict["Params"] as? String {
            self.params = value
        }
        if let value = dict["RemediationId"] as? String {
            self.remediationId = value
        }
        if let value = dict["RemediationTemplateId"] as? String {
            self.remediationTemplateId = value
        }
        if let value = dict["RemediationType"] as? String {
            self.remediationType = value
        }
        if let value = dict["SourceType"] as? String {
            self.sourceType = value
        }
    }
}

public class UpdateAggregateRemediationResponseBody : Tea.TeaModel {
    public var remediationId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.remediationId != nil {
            map["RemediationId"] = self.remediationId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RemediationId"] as? String {
            self.remediationId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateAggregateRemediationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateAggregateRemediationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateAggregateRemediationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateAggregatorRequest : Tea.TeaModel {
    public class AggregatorAccounts : Tea.TeaModel {
        public var accountId: Int64?

        public var accountName: String?

        public var accountType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["AccountId"] = self.accountId!
            }
            if self.accountName != nil {
                map["AccountName"] = self.accountName!
            }
            if self.accountType != nil {
                map["AccountType"] = self.accountType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AccountId"] as? Int64 {
                self.accountId = value
            }
            if let value = dict["AccountName"] as? String {
                self.accountName = value
            }
            if let value = dict["AccountType"] as? String {
                self.accountType = value
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var aggregatorAccounts: [UpdateAggregatorRequest.AggregatorAccounts]?

    public var aggregatorId: String?

    public var aggregatorName: String?

    public var clientToken: String?

    public var description_: String?

    public var folderId: String?

    public var tag: [UpdateAggregatorRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aggregatorAccounts != nil {
            var tmp : [Any] = []
            for k in self.aggregatorAccounts! {
                tmp.append(k.toMap())
            }
            map["AggregatorAccounts"] = tmp
        }
        if self.aggregatorId != nil {
            map["AggregatorId"] = self.aggregatorId!
        }
        if self.aggregatorName != nil {
            map["AggregatorName"] = self.aggregatorName!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.folderId != nil {
            map["FolderId"] = self.folderId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AggregatorAccounts"] as? [Any?] {
            var tmp : [UpdateAggregatorRequest.AggregatorAccounts] = []
            for v in value {
                if v != nil {
                    var model = UpdateAggregatorRequest.AggregatorAccounts()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.aggregatorAccounts = tmp
        }
        if let value = dict["AggregatorId"] as? String {
            self.aggregatorId = value
        }
        if let value = dict["AggregatorName"] as? String {
            self.aggregatorName = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["FolderId"] as? String {
            self.folderId = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [UpdateAggregatorRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = UpdateAggregatorRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
    }
}

public class UpdateAggregatorShrinkRequest : Tea.TeaModel {
    public var aggregatorAccountsShrink: String?

    public var aggregatorId: String?

    public var aggregatorName: String?

    public var clientToken: String?

    public var description_: String?

    public var folderId: String?

    public var tagShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aggregatorAccountsShrink != nil {
            map["AggregatorAccounts"] = self.aggregatorAccountsShrink!
        }
        if self.aggregatorId != nil {
            map["AggregatorId"] = self.aggregatorId!
        }
        if self.aggregatorName != nil {
            map["AggregatorName"] = self.aggregatorName!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.folderId != nil {
            map["FolderId"] = self.folderId!
        }
        if self.tagShrink != nil {
            map["Tag"] = self.tagShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AggregatorAccounts"] as? String {
            self.aggregatorAccountsShrink = value
        }
        if let value = dict["AggregatorId"] as? String {
            self.aggregatorId = value
        }
        if let value = dict["AggregatorName"] as? String {
            self.aggregatorName = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["FolderId"] as? String {
            self.folderId = value
        }
        if let value = dict["Tag"] as? String {
            self.tagShrink = value
        }
    }
}

public class UpdateAggregatorResponseBody : Tea.TeaModel {
    public var aggregatorId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aggregatorId != nil {
            map["AggregatorId"] = self.aggregatorId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AggregatorId"] as? String {
            self.aggregatorId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateAggregatorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateAggregatorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateAggregatorResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateCompliancePackRequest : Tea.TeaModel {
    public class ConfigRules : Tea.TeaModel {
        public class ConfigRuleParameters : Tea.TeaModel {
            public var parameterName: String?

            public var parameterValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.parameterName != nil {
                    map["ParameterName"] = self.parameterName!
                }
                if self.parameterValue != nil {
                    map["ParameterValue"] = self.parameterValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ParameterName"] as? String {
                    self.parameterName = value
                }
                if let value = dict["ParameterValue"] as? String {
                    self.parameterValue = value
                }
            }
        }
        public var configRuleId: String?

        public var configRuleName: String?

        public var configRuleParameters: [UpdateCompliancePackRequest.ConfigRules.ConfigRuleParameters]?

        public var description_: String?

        public var managedRuleIdentifier: String?

        public var riskLevel: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.configRuleId != nil {
                map["ConfigRuleId"] = self.configRuleId!
            }
            if self.configRuleName != nil {
                map["ConfigRuleName"] = self.configRuleName!
            }
            if self.configRuleParameters != nil {
                var tmp : [Any] = []
                for k in self.configRuleParameters! {
                    tmp.append(k.toMap())
                }
                map["ConfigRuleParameters"] = tmp
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.managedRuleIdentifier != nil {
                map["ManagedRuleIdentifier"] = self.managedRuleIdentifier!
            }
            if self.riskLevel != nil {
                map["RiskLevel"] = self.riskLevel!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ConfigRuleId"] as? String {
                self.configRuleId = value
            }
            if let value = dict["ConfigRuleName"] as? String {
                self.configRuleName = value
            }
            if let value = dict["ConfigRuleParameters"] as? [Any?] {
                var tmp : [UpdateCompliancePackRequest.ConfigRules.ConfigRuleParameters] = []
                for v in value {
                    if v != nil {
                        var model = UpdateCompliancePackRequest.ConfigRules.ConfigRuleParameters()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.configRuleParameters = tmp
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["ManagedRuleIdentifier"] as? String {
                self.managedRuleIdentifier = value
            }
            if let value = dict["RiskLevel"] as? Int32 {
                self.riskLevel = value
            }
        }
    }
    public class ExcludeTagsScope : Tea.TeaModel {
        public var tagKey: String?

        public var tagValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tagKey != nil {
                map["TagKey"] = self.tagKey!
            }
            if self.tagValue != nil {
                map["TagValue"] = self.tagValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["TagKey"] as? String {
                self.tagKey = value
            }
            if let value = dict["TagValue"] as? String {
                self.tagValue = value
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public class TagsScope : Tea.TeaModel {
        public var tagKey: String?

        public var tagValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tagKey != nil {
                map["TagKey"] = self.tagKey!
            }
            if self.tagValue != nil {
                map["TagValue"] = self.tagValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["TagKey"] as? String {
                self.tagKey = value
            }
            if let value = dict["TagValue"] as? String {
                self.tagValue = value
            }
        }
    }
    public var clientToken: String?

    public var compliancePackId: String?

    public var compliancePackName: String?

    public var configRules: [UpdateCompliancePackRequest.ConfigRules]?

    public var description_: String?

    public var excludeRegionIdsScope: String?

    public var excludeResourceGroupIdsScope: String?

    public var excludeResourceIdsScope: String?

    public var excludeTagsScope: [UpdateCompliancePackRequest.ExcludeTagsScope]?

    public var regionIdsScope: String?

    public var resourceGroupIdsScope: String?

    public var resourceIdsScope: String?

    public var riskLevel: Int32?

    public var tag: [UpdateCompliancePackRequest.Tag]?

    public var tagKeyScope: String?

    public var tagValueScope: String?

    public var tagsScope: [UpdateCompliancePackRequest.TagsScope]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.compliancePackId != nil {
            map["CompliancePackId"] = self.compliancePackId!
        }
        if self.compliancePackName != nil {
            map["CompliancePackName"] = self.compliancePackName!
        }
        if self.configRules != nil {
            var tmp : [Any] = []
            for k in self.configRules! {
                tmp.append(k.toMap())
            }
            map["ConfigRules"] = tmp
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.excludeRegionIdsScope != nil {
            map["ExcludeRegionIdsScope"] = self.excludeRegionIdsScope!
        }
        if self.excludeResourceGroupIdsScope != nil {
            map["ExcludeResourceGroupIdsScope"] = self.excludeResourceGroupIdsScope!
        }
        if self.excludeResourceIdsScope != nil {
            map["ExcludeResourceIdsScope"] = self.excludeResourceIdsScope!
        }
        if self.excludeTagsScope != nil {
            var tmp : [Any] = []
            for k in self.excludeTagsScope! {
                tmp.append(k.toMap())
            }
            map["ExcludeTagsScope"] = tmp
        }
        if self.regionIdsScope != nil {
            map["RegionIdsScope"] = self.regionIdsScope!
        }
        if self.resourceGroupIdsScope != nil {
            map["ResourceGroupIdsScope"] = self.resourceGroupIdsScope!
        }
        if self.resourceIdsScope != nil {
            map["ResourceIdsScope"] = self.resourceIdsScope!
        }
        if self.riskLevel != nil {
            map["RiskLevel"] = self.riskLevel!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.tagKeyScope != nil {
            map["TagKeyScope"] = self.tagKeyScope!
        }
        if self.tagValueScope != nil {
            map["TagValueScope"] = self.tagValueScope!
        }
        if self.tagsScope != nil {
            var tmp : [Any] = []
            for k in self.tagsScope! {
                tmp.append(k.toMap())
            }
            map["TagsScope"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["CompliancePackId"] as? String {
            self.compliancePackId = value
        }
        if let value = dict["CompliancePackName"] as? String {
            self.compliancePackName = value
        }
        if let value = dict["ConfigRules"] as? [Any?] {
            var tmp : [UpdateCompliancePackRequest.ConfigRules] = []
            for v in value {
                if v != nil {
                    var model = UpdateCompliancePackRequest.ConfigRules()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.configRules = tmp
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["ExcludeRegionIdsScope"] as? String {
            self.excludeRegionIdsScope = value
        }
        if let value = dict["ExcludeResourceGroupIdsScope"] as? String {
            self.excludeResourceGroupIdsScope = value
        }
        if let value = dict["ExcludeResourceIdsScope"] as? String {
            self.excludeResourceIdsScope = value
        }
        if let value = dict["ExcludeTagsScope"] as? [Any?] {
            var tmp : [UpdateCompliancePackRequest.ExcludeTagsScope] = []
            for v in value {
                if v != nil {
                    var model = UpdateCompliancePackRequest.ExcludeTagsScope()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.excludeTagsScope = tmp
        }
        if let value = dict["RegionIdsScope"] as? String {
            self.regionIdsScope = value
        }
        if let value = dict["ResourceGroupIdsScope"] as? String {
            self.resourceGroupIdsScope = value
        }
        if let value = dict["ResourceIdsScope"] as? String {
            self.resourceIdsScope = value
        }
        if let value = dict["RiskLevel"] as? Int32 {
            self.riskLevel = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [UpdateCompliancePackRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = UpdateCompliancePackRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
        if let value = dict["TagKeyScope"] as? String {
            self.tagKeyScope = value
        }
        if let value = dict["TagValueScope"] as? String {
            self.tagValueScope = value
        }
        if let value = dict["TagsScope"] as? [Any?] {
            var tmp : [UpdateCompliancePackRequest.TagsScope] = []
            for v in value {
                if v != nil {
                    var model = UpdateCompliancePackRequest.TagsScope()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tagsScope = tmp
        }
    }
}

public class UpdateCompliancePackShrinkRequest : Tea.TeaModel {
    public class ExcludeTagsScope : Tea.TeaModel {
        public var tagKey: String?

        public var tagValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tagKey != nil {
                map["TagKey"] = self.tagKey!
            }
            if self.tagValue != nil {
                map["TagValue"] = self.tagValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["TagKey"] as? String {
                self.tagKey = value
            }
            if let value = dict["TagValue"] as? String {
                self.tagValue = value
            }
        }
    }
    public class TagsScope : Tea.TeaModel {
        public var tagKey: String?

        public var tagValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tagKey != nil {
                map["TagKey"] = self.tagKey!
            }
            if self.tagValue != nil {
                map["TagValue"] = self.tagValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["TagKey"] as? String {
                self.tagKey = value
            }
            if let value = dict["TagValue"] as? String {
                self.tagValue = value
            }
        }
    }
    public var clientToken: String?

    public var compliancePackId: String?

    public var compliancePackName: String?

    public var configRulesShrink: String?

    public var description_: String?

    public var excludeRegionIdsScope: String?

    public var excludeResourceGroupIdsScope: String?

    public var excludeResourceIdsScope: String?

    public var excludeTagsScope: [UpdateCompliancePackShrinkRequest.ExcludeTagsScope]?

    public var regionIdsScope: String?

    public var resourceGroupIdsScope: String?

    public var resourceIdsScope: String?

    public var riskLevel: Int32?

    public var tagShrink: String?

    public var tagKeyScope: String?

    public var tagValueScope: String?

    public var tagsScope: [UpdateCompliancePackShrinkRequest.TagsScope]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.compliancePackId != nil {
            map["CompliancePackId"] = self.compliancePackId!
        }
        if self.compliancePackName != nil {
            map["CompliancePackName"] = self.compliancePackName!
        }
        if self.configRulesShrink != nil {
            map["ConfigRules"] = self.configRulesShrink!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.excludeRegionIdsScope != nil {
            map["ExcludeRegionIdsScope"] = self.excludeRegionIdsScope!
        }
        if self.excludeResourceGroupIdsScope != nil {
            map["ExcludeResourceGroupIdsScope"] = self.excludeResourceGroupIdsScope!
        }
        if self.excludeResourceIdsScope != nil {
            map["ExcludeResourceIdsScope"] = self.excludeResourceIdsScope!
        }
        if self.excludeTagsScope != nil {
            var tmp : [Any] = []
            for k in self.excludeTagsScope! {
                tmp.append(k.toMap())
            }
            map["ExcludeTagsScope"] = tmp
        }
        if self.regionIdsScope != nil {
            map["RegionIdsScope"] = self.regionIdsScope!
        }
        if self.resourceGroupIdsScope != nil {
            map["ResourceGroupIdsScope"] = self.resourceGroupIdsScope!
        }
        if self.resourceIdsScope != nil {
            map["ResourceIdsScope"] = self.resourceIdsScope!
        }
        if self.riskLevel != nil {
            map["RiskLevel"] = self.riskLevel!
        }
        if self.tagShrink != nil {
            map["Tag"] = self.tagShrink!
        }
        if self.tagKeyScope != nil {
            map["TagKeyScope"] = self.tagKeyScope!
        }
        if self.tagValueScope != nil {
            map["TagValueScope"] = self.tagValueScope!
        }
        if self.tagsScope != nil {
            var tmp : [Any] = []
            for k in self.tagsScope! {
                tmp.append(k.toMap())
            }
            map["TagsScope"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["CompliancePackId"] as? String {
            self.compliancePackId = value
        }
        if let value = dict["CompliancePackName"] as? String {
            self.compliancePackName = value
        }
        if let value = dict["ConfigRules"] as? String {
            self.configRulesShrink = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["ExcludeRegionIdsScope"] as? String {
            self.excludeRegionIdsScope = value
        }
        if let value = dict["ExcludeResourceGroupIdsScope"] as? String {
            self.excludeResourceGroupIdsScope = value
        }
        if let value = dict["ExcludeResourceIdsScope"] as? String {
            self.excludeResourceIdsScope = value
        }
        if let value = dict["ExcludeTagsScope"] as? [Any?] {
            var tmp : [UpdateCompliancePackShrinkRequest.ExcludeTagsScope] = []
            for v in value {
                if v != nil {
                    var model = UpdateCompliancePackShrinkRequest.ExcludeTagsScope()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.excludeTagsScope = tmp
        }
        if let value = dict["RegionIdsScope"] as? String {
            self.regionIdsScope = value
        }
        if let value = dict["ResourceGroupIdsScope"] as? String {
            self.resourceGroupIdsScope = value
        }
        if let value = dict["ResourceIdsScope"] as? String {
            self.resourceIdsScope = value
        }
        if let value = dict["RiskLevel"] as? Int32 {
            self.riskLevel = value
        }
        if let value = dict["Tag"] as? String {
            self.tagShrink = value
        }
        if let value = dict["TagKeyScope"] as? String {
            self.tagKeyScope = value
        }
        if let value = dict["TagValueScope"] as? String {
            self.tagValueScope = value
        }
        if let value = dict["TagsScope"] as? [Any?] {
            var tmp : [UpdateCompliancePackShrinkRequest.TagsScope] = []
            for v in value {
                if v != nil {
                    var model = UpdateCompliancePackShrinkRequest.TagsScope()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tagsScope = tmp
        }
    }
}

public class UpdateCompliancePackResponseBody : Tea.TeaModel {
    public var compliancePackId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.compliancePackId != nil {
            map["CompliancePackId"] = self.compliancePackId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CompliancePackId"] as? String {
            self.compliancePackId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateCompliancePackResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateCompliancePackResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateCompliancePackResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateConfigDeliveryChannelRequest : Tea.TeaModel {
    public var clientToken: String?

    public var compliantSnapshot: Bool?

    public var configurationItemChangeNotification: Bool?

    public var configurationSnapshot: Bool?

    public var deliveryChannelCondition: String?

    public var deliveryChannelId: String?

    public var deliveryChannelName: String?

    public var deliveryChannelTargetArn: String?

    public var deliverySnapshotTime: String?

    public var description_: String?

    public var nonCompliantNotification: Bool?

    public var oversizedDataOSSTargetArn: String?

    public var status: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.compliantSnapshot != nil {
            map["CompliantSnapshot"] = self.compliantSnapshot!
        }
        if self.configurationItemChangeNotification != nil {
            map["ConfigurationItemChangeNotification"] = self.configurationItemChangeNotification!
        }
        if self.configurationSnapshot != nil {
            map["ConfigurationSnapshot"] = self.configurationSnapshot!
        }
        if self.deliveryChannelCondition != nil {
            map["DeliveryChannelCondition"] = self.deliveryChannelCondition!
        }
        if self.deliveryChannelId != nil {
            map["DeliveryChannelId"] = self.deliveryChannelId!
        }
        if self.deliveryChannelName != nil {
            map["DeliveryChannelName"] = self.deliveryChannelName!
        }
        if self.deliveryChannelTargetArn != nil {
            map["DeliveryChannelTargetArn"] = self.deliveryChannelTargetArn!
        }
        if self.deliverySnapshotTime != nil {
            map["DeliverySnapshotTime"] = self.deliverySnapshotTime!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.nonCompliantNotification != nil {
            map["NonCompliantNotification"] = self.nonCompliantNotification!
        }
        if self.oversizedDataOSSTargetArn != nil {
            map["OversizedDataOSSTargetArn"] = self.oversizedDataOSSTargetArn!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["CompliantSnapshot"] as? Bool {
            self.compliantSnapshot = value
        }
        if let value = dict["ConfigurationItemChangeNotification"] as? Bool {
            self.configurationItemChangeNotification = value
        }
        if let value = dict["ConfigurationSnapshot"] as? Bool {
            self.configurationSnapshot = value
        }
        if let value = dict["DeliveryChannelCondition"] as? String {
            self.deliveryChannelCondition = value
        }
        if let value = dict["DeliveryChannelId"] as? String {
            self.deliveryChannelId = value
        }
        if let value = dict["DeliveryChannelName"] as? String {
            self.deliveryChannelName = value
        }
        if let value = dict["DeliveryChannelTargetArn"] as? String {
            self.deliveryChannelTargetArn = value
        }
        if let value = dict["DeliverySnapshotTime"] as? String {
            self.deliverySnapshotTime = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["NonCompliantNotification"] as? Bool {
            self.nonCompliantNotification = value
        }
        if let value = dict["OversizedDataOSSTargetArn"] as? String {
            self.oversizedDataOSSTargetArn = value
        }
        if let value = dict["Status"] as? Int64 {
            self.status = value
        }
    }
}

public class UpdateConfigDeliveryChannelResponseBody : Tea.TeaModel {
    public var deliveryChannelId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deliveryChannelId != nil {
            map["DeliveryChannelId"] = self.deliveryChannelId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DeliveryChannelId"] as? String {
            self.deliveryChannelId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateConfigDeliveryChannelResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateConfigDeliveryChannelResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateConfigDeliveryChannelResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateConfigRuleRequest : Tea.TeaModel {
    public class ExcludeTagsScope : Tea.TeaModel {
        public var tagKey: String?

        public var tagValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tagKey != nil {
                map["TagKey"] = self.tagKey!
            }
            if self.tagValue != nil {
                map["TagValue"] = self.tagValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["TagKey"] as? String {
                self.tagKey = value
            }
            if let value = dict["TagValue"] as? String {
                self.tagValue = value
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public class TagsScope : Tea.TeaModel {
        public var tagKey: String?

        public var tagValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tagKey != nil {
                map["TagKey"] = self.tagKey!
            }
            if self.tagValue != nil {
                map["TagValue"] = self.tagValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["TagKey"] as? String {
                self.tagKey = value
            }
            if let value = dict["TagValue"] as? String {
                self.tagValue = value
            }
        }
    }
    public var clientToken: String?

    public var configRuleId: String?

    public var configRuleName: String?

    public var configRuleTriggerTypes: String?

    public var description_: String?

    public var excludeRegionIdsScope: String?

    public var excludeResourceGroupIdsScope: String?

    public var excludeResourceIdsScope: String?

    public var excludeTagsScope: [UpdateConfigRuleRequest.ExcludeTagsScope]?

    public var extendContent: String?

    public var inputParameters: [String: Any]?

    public var maximumExecutionFrequency: String?

    public var regionIdsScope: String?

    public var resourceGroupIdsScope: String?

    public var resourceIdsScope: String?

    public var resourceNameScope: String?

    public var resourceTypesScope: [String]?

    public var riskLevel: Int32?

    public var tag: [UpdateConfigRuleRequest.Tag]?

    public var tagKeyLogicScope: String?

    public var tagKeyScope: String?

    public var tagValueScope: String?

    public var tagsScope: [UpdateConfigRuleRequest.TagsScope]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.configRuleId != nil {
            map["ConfigRuleId"] = self.configRuleId!
        }
        if self.configRuleName != nil {
            map["ConfigRuleName"] = self.configRuleName!
        }
        if self.configRuleTriggerTypes != nil {
            map["ConfigRuleTriggerTypes"] = self.configRuleTriggerTypes!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.excludeRegionIdsScope != nil {
            map["ExcludeRegionIdsScope"] = self.excludeRegionIdsScope!
        }
        if self.excludeResourceGroupIdsScope != nil {
            map["ExcludeResourceGroupIdsScope"] = self.excludeResourceGroupIdsScope!
        }
        if self.excludeResourceIdsScope != nil {
            map["ExcludeResourceIdsScope"] = self.excludeResourceIdsScope!
        }
        if self.excludeTagsScope != nil {
            var tmp : [Any] = []
            for k in self.excludeTagsScope! {
                tmp.append(k.toMap())
            }
            map["ExcludeTagsScope"] = tmp
        }
        if self.extendContent != nil {
            map["ExtendContent"] = self.extendContent!
        }
        if self.inputParameters != nil {
            map["InputParameters"] = self.inputParameters!
        }
        if self.maximumExecutionFrequency != nil {
            map["MaximumExecutionFrequency"] = self.maximumExecutionFrequency!
        }
        if self.regionIdsScope != nil {
            map["RegionIdsScope"] = self.regionIdsScope!
        }
        if self.resourceGroupIdsScope != nil {
            map["ResourceGroupIdsScope"] = self.resourceGroupIdsScope!
        }
        if self.resourceIdsScope != nil {
            map["ResourceIdsScope"] = self.resourceIdsScope!
        }
        if self.resourceNameScope != nil {
            map["ResourceNameScope"] = self.resourceNameScope!
        }
        if self.resourceTypesScope != nil {
            map["ResourceTypesScope"] = self.resourceTypesScope!
        }
        if self.riskLevel != nil {
            map["RiskLevel"] = self.riskLevel!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.tagKeyLogicScope != nil {
            map["TagKeyLogicScope"] = self.tagKeyLogicScope!
        }
        if self.tagKeyScope != nil {
            map["TagKeyScope"] = self.tagKeyScope!
        }
        if self.tagValueScope != nil {
            map["TagValueScope"] = self.tagValueScope!
        }
        if self.tagsScope != nil {
            var tmp : [Any] = []
            for k in self.tagsScope! {
                tmp.append(k.toMap())
            }
            map["TagsScope"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["ConfigRuleId"] as? String {
            self.configRuleId = value
        }
        if let value = dict["ConfigRuleName"] as? String {
            self.configRuleName = value
        }
        if let value = dict["ConfigRuleTriggerTypes"] as? String {
            self.configRuleTriggerTypes = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["ExcludeRegionIdsScope"] as? String {
            self.excludeRegionIdsScope = value
        }
        if let value = dict["ExcludeResourceGroupIdsScope"] as? String {
            self.excludeResourceGroupIdsScope = value
        }
        if let value = dict["ExcludeResourceIdsScope"] as? String {
            self.excludeResourceIdsScope = value
        }
        if let value = dict["ExcludeTagsScope"] as? [Any?] {
            var tmp : [UpdateConfigRuleRequest.ExcludeTagsScope] = []
            for v in value {
                if v != nil {
                    var model = UpdateConfigRuleRequest.ExcludeTagsScope()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.excludeTagsScope = tmp
        }
        if let value = dict["ExtendContent"] as? String {
            self.extendContent = value
        }
        if let value = dict["InputParameters"] as? [String: Any] {
            self.inputParameters = value
        }
        if let value = dict["MaximumExecutionFrequency"] as? String {
            self.maximumExecutionFrequency = value
        }
        if let value = dict["RegionIdsScope"] as? String {
            self.regionIdsScope = value
        }
        if let value = dict["ResourceGroupIdsScope"] as? String {
            self.resourceGroupIdsScope = value
        }
        if let value = dict["ResourceIdsScope"] as? String {
            self.resourceIdsScope = value
        }
        if let value = dict["ResourceNameScope"] as? String {
            self.resourceNameScope = value
        }
        if let value = dict["ResourceTypesScope"] as? [String] {
            self.resourceTypesScope = value
        }
        if let value = dict["RiskLevel"] as? Int32 {
            self.riskLevel = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [UpdateConfigRuleRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = UpdateConfigRuleRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
        if let value = dict["TagKeyLogicScope"] as? String {
            self.tagKeyLogicScope = value
        }
        if let value = dict["TagKeyScope"] as? String {
            self.tagKeyScope = value
        }
        if let value = dict["TagValueScope"] as? String {
            self.tagValueScope = value
        }
        if let value = dict["TagsScope"] as? [Any?] {
            var tmp : [UpdateConfigRuleRequest.TagsScope] = []
            for v in value {
                if v != nil {
                    var model = UpdateConfigRuleRequest.TagsScope()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tagsScope = tmp
        }
    }
}

public class UpdateConfigRuleShrinkRequest : Tea.TeaModel {
    public class ExcludeTagsScope : Tea.TeaModel {
        public var tagKey: String?

        public var tagValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tagKey != nil {
                map["TagKey"] = self.tagKey!
            }
            if self.tagValue != nil {
                map["TagValue"] = self.tagValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["TagKey"] as? String {
                self.tagKey = value
            }
            if let value = dict["TagValue"] as? String {
                self.tagValue = value
            }
        }
    }
    public class TagsScope : Tea.TeaModel {
        public var tagKey: String?

        public var tagValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tagKey != nil {
                map["TagKey"] = self.tagKey!
            }
            if self.tagValue != nil {
                map["TagValue"] = self.tagValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["TagKey"] as? String {
                self.tagKey = value
            }
            if let value = dict["TagValue"] as? String {
                self.tagValue = value
            }
        }
    }
    public var clientToken: String?

    public var configRuleId: String?

    public var configRuleName: String?

    public var configRuleTriggerTypes: String?

    public var description_: String?

    public var excludeRegionIdsScope: String?

    public var excludeResourceGroupIdsScope: String?

    public var excludeResourceIdsScope: String?

    public var excludeTagsScope: [UpdateConfigRuleShrinkRequest.ExcludeTagsScope]?

    public var extendContent: String?

    public var inputParametersShrink: String?

    public var maximumExecutionFrequency: String?

    public var regionIdsScope: String?

    public var resourceGroupIdsScope: String?

    public var resourceIdsScope: String?

    public var resourceNameScope: String?

    public var resourceTypesScopeShrink: String?

    public var riskLevel: Int32?

    public var tagShrink: String?

    public var tagKeyLogicScope: String?

    public var tagKeyScope: String?

    public var tagValueScope: String?

    public var tagsScope: [UpdateConfigRuleShrinkRequest.TagsScope]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.configRuleId != nil {
            map["ConfigRuleId"] = self.configRuleId!
        }
        if self.configRuleName != nil {
            map["ConfigRuleName"] = self.configRuleName!
        }
        if self.configRuleTriggerTypes != nil {
            map["ConfigRuleTriggerTypes"] = self.configRuleTriggerTypes!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.excludeRegionIdsScope != nil {
            map["ExcludeRegionIdsScope"] = self.excludeRegionIdsScope!
        }
        if self.excludeResourceGroupIdsScope != nil {
            map["ExcludeResourceGroupIdsScope"] = self.excludeResourceGroupIdsScope!
        }
        if self.excludeResourceIdsScope != nil {
            map["ExcludeResourceIdsScope"] = self.excludeResourceIdsScope!
        }
        if self.excludeTagsScope != nil {
            var tmp : [Any] = []
            for k in self.excludeTagsScope! {
                tmp.append(k.toMap())
            }
            map["ExcludeTagsScope"] = tmp
        }
        if self.extendContent != nil {
            map["ExtendContent"] = self.extendContent!
        }
        if self.inputParametersShrink != nil {
            map["InputParameters"] = self.inputParametersShrink!
        }
        if self.maximumExecutionFrequency != nil {
            map["MaximumExecutionFrequency"] = self.maximumExecutionFrequency!
        }
        if self.regionIdsScope != nil {
            map["RegionIdsScope"] = self.regionIdsScope!
        }
        if self.resourceGroupIdsScope != nil {
            map["ResourceGroupIdsScope"] = self.resourceGroupIdsScope!
        }
        if self.resourceIdsScope != nil {
            map["ResourceIdsScope"] = self.resourceIdsScope!
        }
        if self.resourceNameScope != nil {
            map["ResourceNameScope"] = self.resourceNameScope!
        }
        if self.resourceTypesScopeShrink != nil {
            map["ResourceTypesScope"] = self.resourceTypesScopeShrink!
        }
        if self.riskLevel != nil {
            map["RiskLevel"] = self.riskLevel!
        }
        if self.tagShrink != nil {
            map["Tag"] = self.tagShrink!
        }
        if self.tagKeyLogicScope != nil {
            map["TagKeyLogicScope"] = self.tagKeyLogicScope!
        }
        if self.tagKeyScope != nil {
            map["TagKeyScope"] = self.tagKeyScope!
        }
        if self.tagValueScope != nil {
            map["TagValueScope"] = self.tagValueScope!
        }
        if self.tagsScope != nil {
            var tmp : [Any] = []
            for k in self.tagsScope! {
                tmp.append(k.toMap())
            }
            map["TagsScope"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["ConfigRuleId"] as? String {
            self.configRuleId = value
        }
        if let value = dict["ConfigRuleName"] as? String {
            self.configRuleName = value
        }
        if let value = dict["ConfigRuleTriggerTypes"] as? String {
            self.configRuleTriggerTypes = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["ExcludeRegionIdsScope"] as? String {
            self.excludeRegionIdsScope = value
        }
        if let value = dict["ExcludeResourceGroupIdsScope"] as? String {
            self.excludeResourceGroupIdsScope = value
        }
        if let value = dict["ExcludeResourceIdsScope"] as? String {
            self.excludeResourceIdsScope = value
        }
        if let value = dict["ExcludeTagsScope"] as? [Any?] {
            var tmp : [UpdateConfigRuleShrinkRequest.ExcludeTagsScope] = []
            for v in value {
                if v != nil {
                    var model = UpdateConfigRuleShrinkRequest.ExcludeTagsScope()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.excludeTagsScope = tmp
        }
        if let value = dict["ExtendContent"] as? String {
            self.extendContent = value
        }
        if let value = dict["InputParameters"] as? String {
            self.inputParametersShrink = value
        }
        if let value = dict["MaximumExecutionFrequency"] as? String {
            self.maximumExecutionFrequency = value
        }
        if let value = dict["RegionIdsScope"] as? String {
            self.regionIdsScope = value
        }
        if let value = dict["ResourceGroupIdsScope"] as? String {
            self.resourceGroupIdsScope = value
        }
        if let value = dict["ResourceIdsScope"] as? String {
            self.resourceIdsScope = value
        }
        if let value = dict["ResourceNameScope"] as? String {
            self.resourceNameScope = value
        }
        if let value = dict["ResourceTypesScope"] as? String {
            self.resourceTypesScopeShrink = value
        }
        if let value = dict["RiskLevel"] as? Int32 {
            self.riskLevel = value
        }
        if let value = dict["Tag"] as? String {
            self.tagShrink = value
        }
        if let value = dict["TagKeyLogicScope"] as? String {
            self.tagKeyLogicScope = value
        }
        if let value = dict["TagKeyScope"] as? String {
            self.tagKeyScope = value
        }
        if let value = dict["TagValueScope"] as? String {
            self.tagValueScope = value
        }
        if let value = dict["TagsScope"] as? [Any?] {
            var tmp : [UpdateConfigRuleShrinkRequest.TagsScope] = []
            for v in value {
                if v != nil {
                    var model = UpdateConfigRuleShrinkRequest.TagsScope()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tagsScope = tmp
        }
    }
}

public class UpdateConfigRuleResponseBody : Tea.TeaModel {
    public var configRuleId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configRuleId != nil {
            map["ConfigRuleId"] = self.configRuleId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ConfigRuleId"] as? String {
            self.configRuleId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateConfigRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateConfigRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateConfigRuleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateConfigurationRecorderRequest : Tea.TeaModel {
    public var resourceTypes: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.resourceTypes != nil {
            map["ResourceTypes"] = self.resourceTypes!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ResourceTypes"] as? String {
            self.resourceTypes = value
        }
    }
}

public class UpdateConfigurationRecorderResponseBody : Tea.TeaModel {
    public class ConfigurationRecorder : Tea.TeaModel {
        public var configurationRecorderStatus: String?

        public var resourceTypes: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.configurationRecorderStatus != nil {
                map["ConfigurationRecorderStatus"] = self.configurationRecorderStatus!
            }
            if self.resourceTypes != nil {
                map["ResourceTypes"] = self.resourceTypes!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ConfigurationRecorderStatus"] as? String {
                self.configurationRecorderStatus = value
            }
            if let value = dict["ResourceTypes"] as? [String] {
                self.resourceTypes = value
            }
        }
    }
    public var configurationRecorder: UpdateConfigurationRecorderResponseBody.ConfigurationRecorder?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.configurationRecorder?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configurationRecorder != nil {
            map["ConfigurationRecorder"] = self.configurationRecorder?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ConfigurationRecorder"] as? [String: Any?] {
            var model = UpdateConfigurationRecorderResponseBody.ConfigurationRecorder()
            model.fromMap(value)
            self.configurationRecorder = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateConfigurationRecorderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateConfigurationRecorderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateConfigurationRecorderResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateDeliveryChannelRequest : Tea.TeaModel {
    public var clientToken: String?

    public var configurationItemChangeNotification: Bool?

    public var configurationSnapshot: Bool?

    public var deliveryChannelAssumeRoleArn: String?

    public var deliveryChannelCondition: String?

    public var deliveryChannelId: String?

    public var deliveryChannelName: String?

    public var deliveryChannelTargetArn: String?

    public var description_: String?

    public var nonCompliantNotification: Bool?

    public var oversizedDataOSSTargetArn: String?

    public var status: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.configurationItemChangeNotification != nil {
            map["ConfigurationItemChangeNotification"] = self.configurationItemChangeNotification!
        }
        if self.configurationSnapshot != nil {
            map["ConfigurationSnapshot"] = self.configurationSnapshot!
        }
        if self.deliveryChannelAssumeRoleArn != nil {
            map["DeliveryChannelAssumeRoleArn"] = self.deliveryChannelAssumeRoleArn!
        }
        if self.deliveryChannelCondition != nil {
            map["DeliveryChannelCondition"] = self.deliveryChannelCondition!
        }
        if self.deliveryChannelId != nil {
            map["DeliveryChannelId"] = self.deliveryChannelId!
        }
        if self.deliveryChannelName != nil {
            map["DeliveryChannelName"] = self.deliveryChannelName!
        }
        if self.deliveryChannelTargetArn != nil {
            map["DeliveryChannelTargetArn"] = self.deliveryChannelTargetArn!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.nonCompliantNotification != nil {
            map["NonCompliantNotification"] = self.nonCompliantNotification!
        }
        if self.oversizedDataOSSTargetArn != nil {
            map["OversizedDataOSSTargetArn"] = self.oversizedDataOSSTargetArn!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["ConfigurationItemChangeNotification"] as? Bool {
            self.configurationItemChangeNotification = value
        }
        if let value = dict["ConfigurationSnapshot"] as? Bool {
            self.configurationSnapshot = value
        }
        if let value = dict["DeliveryChannelAssumeRoleArn"] as? String {
            self.deliveryChannelAssumeRoleArn = value
        }
        if let value = dict["DeliveryChannelCondition"] as? String {
            self.deliveryChannelCondition = value
        }
        if let value = dict["DeliveryChannelId"] as? String {
            self.deliveryChannelId = value
        }
        if let value = dict["DeliveryChannelName"] as? String {
            self.deliveryChannelName = value
        }
        if let value = dict["DeliveryChannelTargetArn"] as? String {
            self.deliveryChannelTargetArn = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["NonCompliantNotification"] as? Bool {
            self.nonCompliantNotification = value
        }
        if let value = dict["OversizedDataOSSTargetArn"] as? String {
            self.oversizedDataOSSTargetArn = value
        }
        if let value = dict["Status"] as? Int64 {
            self.status = value
        }
    }
}

public class UpdateDeliveryChannelResponseBody : Tea.TeaModel {
    public var deliveryChannelId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deliveryChannelId != nil {
            map["DeliveryChannelId"] = self.deliveryChannelId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DeliveryChannelId"] as? String {
            self.deliveryChannelId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateDeliveryChannelResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateDeliveryChannelResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateDeliveryChannelResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateIntegratedServiceStatusRequest : Tea.TeaModel {
    public var aggregatorDeliveryDataType: String?

    public var integratedTypes: String?

    public var serviceCode: String?

    public var status: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aggregatorDeliveryDataType != nil {
            map["AggregatorDeliveryDataType"] = self.aggregatorDeliveryDataType!
        }
        if self.integratedTypes != nil {
            map["IntegratedTypes"] = self.integratedTypes!
        }
        if self.serviceCode != nil {
            map["ServiceCode"] = self.serviceCode!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AggregatorDeliveryDataType"] as? String {
            self.aggregatorDeliveryDataType = value
        }
        if let value = dict["IntegratedTypes"] as? String {
            self.integratedTypes = value
        }
        if let value = dict["ServiceCode"] as? String {
            self.serviceCode = value
        }
        if let value = dict["Status"] as? Bool {
            self.status = value
        }
    }
}

public class UpdateIntegratedServiceStatusResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateIntegratedServiceStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateIntegratedServiceStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateIntegratedServiceStatusResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateRemediationRequest : Tea.TeaModel {
    public var clientToken: String?

    public var invokeType: String?

    public var params: String?

    public var remediationId: String?

    public var remediationTemplateId: String?

    public var remediationType: String?

    public var sourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.invokeType != nil {
            map["InvokeType"] = self.invokeType!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.remediationId != nil {
            map["RemediationId"] = self.remediationId!
        }
        if self.remediationTemplateId != nil {
            map["RemediationTemplateId"] = self.remediationTemplateId!
        }
        if self.remediationType != nil {
            map["RemediationType"] = self.remediationType!
        }
        if self.sourceType != nil {
            map["SourceType"] = self.sourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["InvokeType"] as? String {
            self.invokeType = value
        }
        if let value = dict["Params"] as? String {
            self.params = value
        }
        if let value = dict["RemediationId"] as? String {
            self.remediationId = value
        }
        if let value = dict["RemediationTemplateId"] as? String {
            self.remediationTemplateId = value
        }
        if let value = dict["RemediationType"] as? String {
            self.remediationType = value
        }
        if let value = dict["SourceType"] as? String {
            self.sourceType = value
        }
    }
}

public class UpdateRemediationResponseBody : Tea.TeaModel {
    public var remediationId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.remediationId != nil {
            map["RemediationId"] = self.remediationId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RemediationId"] as? String {
            self.remediationId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateRemediationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateRemediationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateRemediationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}
