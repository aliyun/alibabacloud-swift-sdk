import Foundation
import Tea
import TeaUtils
import AlibabacloudOpenApi
import AlibabaCloudOpenApiUtil
import AlibabacloudEndpointUtil

public class AcceptPartnerNotificationRequest : Tea.TeaModel {
    public var bizId: String?

    public var material: String?

    public var operation: String?

    public var remark: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.material != nil {
            map["Material"] = self.material!
        }
        if self.operation != nil {
            map["Operation"] = self.operation!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("Material") && dict["Material"] != nil {
            self.material = dict["Material"] as! String
        }
        if dict.keys.contains("Operation") && dict["Operation"] != nil {
            self.operation = dict["Operation"] as! String
        }
        if dict.keys.contains("Remark") && dict["Remark"] != nil {
            self.remark = dict["Remark"] as! String
        }
    }
}

public class AcceptPartnerNotificationResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMsg: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["ErrorMsg"] = self.errorMsg!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMsg") && dict["ErrorMsg"] != nil {
            self.errorMsg = dict["ErrorMsg"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class AcceptPartnerNotificationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AcceptPartnerNotificationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AcceptPartnerNotificationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ApplyNotaryPostRequest : Tea.TeaModel {
    public var notaryOrderId: Int64?

    public var receiverAddress: String?

    public var receiverName: String?

    public var receiverPhone: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.notaryOrderId != nil {
            map["NotaryOrderId"] = self.notaryOrderId!
        }
        if self.receiverAddress != nil {
            map["ReceiverAddress"] = self.receiverAddress!
        }
        if self.receiverName != nil {
            map["ReceiverName"] = self.receiverName!
        }
        if self.receiverPhone != nil {
            map["ReceiverPhone"] = self.receiverPhone!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NotaryOrderId") && dict["NotaryOrderId"] != nil {
            self.notaryOrderId = dict["NotaryOrderId"] as! Int64
        }
        if dict.keys.contains("ReceiverAddress") && dict["ReceiverAddress"] != nil {
            self.receiverAddress = dict["ReceiverAddress"] as! String
        }
        if dict.keys.contains("ReceiverName") && dict["ReceiverName"] != nil {
            self.receiverName = dict["ReceiverName"] as! String
        }
        if dict.keys.contains("ReceiverPhone") && dict["ReceiverPhone"] != nil {
            self.receiverPhone = dict["ReceiverPhone"] as! String
        }
    }
}

public class ApplyNotaryPostResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMsg: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["ErrorMsg"] = self.errorMsg!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMsg") && dict["ErrorMsg"] != nil {
            self.errorMsg = dict["ErrorMsg"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ApplyNotaryPostResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ApplyNotaryPostResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ApplyNotaryPostResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AskAdjudicationFileRequest : Tea.TeaModel {
    public var bizId: String?

    public var contactAddress: String?

    public var contactCity: String?

    public var contactCounty: String?

    public var contactDistrict: String?

    public var contactName: String?

    public var contactNumber: String?

    public var contactProvince: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.contactAddress != nil {
            map["ContactAddress"] = self.contactAddress!
        }
        if self.contactCity != nil {
            map["ContactCity"] = self.contactCity!
        }
        if self.contactCounty != nil {
            map["ContactCounty"] = self.contactCounty!
        }
        if self.contactDistrict != nil {
            map["ContactDistrict"] = self.contactDistrict!
        }
        if self.contactName != nil {
            map["ContactName"] = self.contactName!
        }
        if self.contactNumber != nil {
            map["ContactNumber"] = self.contactNumber!
        }
        if self.contactProvince != nil {
            map["ContactProvince"] = self.contactProvince!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("ContactAddress") && dict["ContactAddress"] != nil {
            self.contactAddress = dict["ContactAddress"] as! String
        }
        if dict.keys.contains("ContactCity") && dict["ContactCity"] != nil {
            self.contactCity = dict["ContactCity"] as! String
        }
        if dict.keys.contains("ContactCounty") && dict["ContactCounty"] != nil {
            self.contactCounty = dict["ContactCounty"] as! String
        }
        if dict.keys.contains("ContactDistrict") && dict["ContactDistrict"] != nil {
            self.contactDistrict = dict["ContactDistrict"] as! String
        }
        if dict.keys.contains("ContactName") && dict["ContactName"] != nil {
            self.contactName = dict["ContactName"] as! String
        }
        if dict.keys.contains("ContactNumber") && dict["ContactNumber"] != nil {
            self.contactNumber = dict["ContactNumber"] as! String
        }
        if dict.keys.contains("ContactProvince") && dict["ContactProvince"] != nil {
            self.contactProvince = dict["ContactProvince"] as! String
        }
    }
}

public class AskAdjudicationFileResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AskAdjudicationFileResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AskAdjudicationFileResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AskAdjudicationFileResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class BindMaterialRequest : Tea.TeaModel {
    public var bizId: String?

    public var legalNoticeKey: String?

    public var loaOssKey: String?

    public var materialId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.legalNoticeKey != nil {
            map["LegalNoticeKey"] = self.legalNoticeKey!
        }
        if self.loaOssKey != nil {
            map["LoaOssKey"] = self.loaOssKey!
        }
        if self.materialId != nil {
            map["MaterialId"] = self.materialId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("LegalNoticeKey") && dict["LegalNoticeKey"] != nil {
            self.legalNoticeKey = dict["LegalNoticeKey"] as! String
        }
        if dict.keys.contains("LoaOssKey") && dict["LoaOssKey"] != nil {
            self.loaOssKey = dict["LoaOssKey"] as! String
        }
        if dict.keys.contains("MaterialId") && dict["MaterialId"] != nil {
            self.materialId = dict["MaterialId"] as! String
        }
    }
}

public class BindMaterialResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class BindMaterialResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BindMaterialResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = BindMaterialResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CancelTradeOrderRequest : Tea.TeaModel {
    public var bizId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
    }
}

public class CancelTradeOrderResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMsg: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["ErrorMsg"] = self.errorMsg!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMsg") && dict["ErrorMsg"] != nil {
            self.errorMsg = dict["ErrorMsg"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CancelTradeOrderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CancelTradeOrderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CancelTradeOrderResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CheckFlsmFillRequest : Tea.TeaModel {
    public var applicantType: String?

    public var ossKey: String?

    public var personalType: String?

    public var wtrName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicantType != nil {
            map["ApplicantType"] = self.applicantType!
        }
        if self.ossKey != nil {
            map["OssKey"] = self.ossKey!
        }
        if self.personalType != nil {
            map["PersonalType"] = self.personalType!
        }
        if self.wtrName != nil {
            map["WtrName"] = self.wtrName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApplicantType") && dict["ApplicantType"] != nil {
            self.applicantType = dict["ApplicantType"] as! String
        }
        if dict.keys.contains("OssKey") && dict["OssKey"] != nil {
            self.ossKey = dict["OssKey"] as! String
        }
        if dict.keys.contains("PersonalType") && dict["PersonalType"] != nil {
            self.personalType = dict["PersonalType"] as! String
        }
        if dict.keys.contains("WtrName") && dict["WtrName"] != nil {
            self.wtrName = dict["WtrName"] as! String
        }
    }
}

public class CheckFlsmFillResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var tips: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.tips != nil {
            map["Tips"] = self.tips!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Tips") && dict["Tips"] != nil {
            self.tips = dict["Tips"] as! String
        }
    }
}

public class CheckFlsmFillResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CheckFlsmFillResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CheckFlsmFillResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CheckIfCollectedRequest : Tea.TeaModel {
    public var itemIdList: String?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var type: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.itemIdList != nil {
            map["ItemIdList"] = self.itemIdList!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ItemIdList") && dict["ItemIdList"] != nil {
            self.itemIdList = dict["ItemIdList"] as! String
        }
        if dict.keys.contains("PageNum") && dict["PageNum"] != nil {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! Int32
        }
    }
}

public class CheckIfCollectedResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Trademark : Tea.TeaModel {
            public var id: Int64?

            public var itemIdList: String?

            public var name: String?

            public var type: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.itemIdList != nil {
                    map["ItemIdList"] = self.itemIdList!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("ItemIdList") && dict["ItemIdList"] != nil {
                    self.itemIdList = dict["ItemIdList"] as! String
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! Int32
                }
            }
        }
        public var trademark: [CheckIfCollectedResponseBody.Data.Trademark]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.trademark != nil {
                var tmp : [Any] = []
                for k in self.trademark! {
                    tmp.append(k.toMap())
                }
                map["Trademark"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Trademark") && dict["Trademark"] != nil {
                var tmp : [CheckIfCollectedResponseBody.Data.Trademark] = []
                for v in dict["Trademark"] as! [Any] {
                    var model = CheckIfCollectedResponseBody.Data.Trademark()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.trademark = tmp
            }
        }
    }
    public var currentPageNum: Int32?

    public var data: CheckIfCollectedResponseBody.Data?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalItemNum: Int32?

    public var totalPageNum: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPageNum != nil {
            map["CurrentPageNum"] = self.currentPageNum!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalItemNum != nil {
            map["TotalItemNum"] = self.totalItemNum!
        }
        if self.totalPageNum != nil {
            map["TotalPageNum"] = self.totalPageNum!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPageNum") && dict["CurrentPageNum"] != nil {
            self.currentPageNum = dict["CurrentPageNum"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = CheckIfCollectedResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalItemNum") && dict["TotalItemNum"] != nil {
            self.totalItemNum = dict["TotalItemNum"] as! Int32
        }
        if dict.keys.contains("TotalPageNum") && dict["TotalPageNum"] != nil {
            self.totalPageNum = dict["TotalPageNum"] as! Int32
        }
    }
}

public class CheckIfCollectedResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CheckIfCollectedResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CheckIfCollectedResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CheckLoaFillRequest : Tea.TeaModel {
    public var applicantType: String?

    public var bizType: String?

    public var contactName: String?

    public var contactNumber: String?

    public var contactZipcode: String?

    public var ossKey: String?

    public var personalType: String?

    public var principalName: String?

    public var type: String?

    public var wtrName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicantType != nil {
            map["ApplicantType"] = self.applicantType!
        }
        if self.bizType != nil {
            map["BizType"] = self.bizType!
        }
        if self.contactName != nil {
            map["ContactName"] = self.contactName!
        }
        if self.contactNumber != nil {
            map["ContactNumber"] = self.contactNumber!
        }
        if self.contactZipcode != nil {
            map["ContactZipcode"] = self.contactZipcode!
        }
        if self.ossKey != nil {
            map["OssKey"] = self.ossKey!
        }
        if self.personalType != nil {
            map["PersonalType"] = self.personalType!
        }
        if self.principalName != nil {
            map["PrincipalName"] = self.principalName!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.wtrName != nil {
            map["WtrName"] = self.wtrName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApplicantType") && dict["ApplicantType"] != nil {
            self.applicantType = dict["ApplicantType"] as! String
        }
        if dict.keys.contains("BizType") && dict["BizType"] != nil {
            self.bizType = dict["BizType"] as! String
        }
        if dict.keys.contains("ContactName") && dict["ContactName"] != nil {
            self.contactName = dict["ContactName"] as! String
        }
        if dict.keys.contains("ContactNumber") && dict["ContactNumber"] != nil {
            self.contactNumber = dict["ContactNumber"] as! String
        }
        if dict.keys.contains("ContactZipcode") && dict["ContactZipcode"] != nil {
            self.contactZipcode = dict["ContactZipcode"] as! String
        }
        if dict.keys.contains("OssKey") && dict["OssKey"] != nil {
            self.ossKey = dict["OssKey"] as! String
        }
        if dict.keys.contains("PersonalType") && dict["PersonalType"] != nil {
            self.personalType = dict["PersonalType"] as! String
        }
        if dict.keys.contains("PrincipalName") && dict["PrincipalName"] != nil {
            self.principalName = dict["PrincipalName"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("WtrName") && dict["WtrName"] != nil {
            self.wtrName = dict["WtrName"] as! String
        }
    }
}

public class CheckLoaFillResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class ErrorMsgs : Tea.TeaModel {
            public var errorMsg: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.errorMsg != nil {
                    map["ErrorMsg"] = self.errorMsg!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ErrorMsg") && dict["ErrorMsg"] != nil {
                    self.errorMsg = dict["ErrorMsg"] as! [String]
                }
            }
        }
        public var addressFill: Bool?

        public var countryFill: Bool?

        public var errorMsgs: CheckLoaFillResponseBody.Data.ErrorMsgs?

        public var materialNameFill: Bool?

        public var nationalityFill: Bool?

        public var stampFill: Bool?

        public var templateUrl: String?

        public var tips: String?

        public var tradeMarkNameFill: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.errorMsgs?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.addressFill != nil {
                map["AddressFill"] = self.addressFill!
            }
            if self.countryFill != nil {
                map["CountryFill"] = self.countryFill!
            }
            if self.errorMsgs != nil {
                map["ErrorMsgs"] = self.errorMsgs?.toMap()
            }
            if self.materialNameFill != nil {
                map["MaterialNameFill"] = self.materialNameFill!
            }
            if self.nationalityFill != nil {
                map["NationalityFill"] = self.nationalityFill!
            }
            if self.stampFill != nil {
                map["StampFill"] = self.stampFill!
            }
            if self.templateUrl != nil {
                map["TemplateUrl"] = self.templateUrl!
            }
            if self.tips != nil {
                map["Tips"] = self.tips!
            }
            if self.tradeMarkNameFill != nil {
                map["TradeMarkNameFill"] = self.tradeMarkNameFill!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AddressFill") && dict["AddressFill"] != nil {
                self.addressFill = dict["AddressFill"] as! Bool
            }
            if dict.keys.contains("CountryFill") && dict["CountryFill"] != nil {
                self.countryFill = dict["CountryFill"] as! Bool
            }
            if dict.keys.contains("ErrorMsgs") && dict["ErrorMsgs"] != nil {
                var model = CheckLoaFillResponseBody.Data.ErrorMsgs()
                model.fromMap(dict["ErrorMsgs"] as! [String: Any])
                self.errorMsgs = model
            }
            if dict.keys.contains("MaterialNameFill") && dict["MaterialNameFill"] != nil {
                self.materialNameFill = dict["MaterialNameFill"] as! Bool
            }
            if dict.keys.contains("NationalityFill") && dict["NationalityFill"] != nil {
                self.nationalityFill = dict["NationalityFill"] as! Bool
            }
            if dict.keys.contains("StampFill") && dict["StampFill"] != nil {
                self.stampFill = dict["StampFill"] as! Bool
            }
            if dict.keys.contains("TemplateUrl") && dict["TemplateUrl"] != nil {
                self.templateUrl = dict["TemplateUrl"] as! String
            }
            if dict.keys.contains("Tips") && dict["Tips"] != nil {
                self.tips = dict["Tips"] as! String
            }
            if dict.keys.contains("TradeMarkNameFill") && dict["TradeMarkNameFill"] != nil {
                self.tradeMarkNameFill = dict["TradeMarkNameFill"] as! Bool
            }
        }
    }
    public var data: CheckLoaFillResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = CheckLoaFillResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CheckLoaFillResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CheckLoaFillResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CheckLoaFillResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CheckTrademarkIconRequest : Tea.TeaModel {
    public var eventSceneType: Int32?

    public var trademarkIconOssKey: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.eventSceneType != nil {
            map["EventSceneType"] = self.eventSceneType!
        }
        if self.trademarkIconOssKey != nil {
            map["TrademarkIconOssKey"] = self.trademarkIconOssKey!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EventSceneType") && dict["EventSceneType"] != nil {
            self.eventSceneType = dict["EventSceneType"] as! Int32
        }
        if dict.keys.contains("TrademarkIconOssKey") && dict["TrademarkIconOssKey"] != nil {
            self.trademarkIconOssKey = dict["TrademarkIconOssKey"] as! String
        }
    }
}

public class CheckTrademarkIconResponseBody : Tea.TeaModel {
    public var message: String?

    public var requestId: String?

    public var result: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") && dict["Result"] != nil {
            self.result = dict["Result"] as! String
        }
    }
}

public class CheckTrademarkIconResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CheckTrademarkIconResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CheckTrademarkIconResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CheckTrademarkOrderRequest : Tea.TeaModel {
    public var agreementId: String?

    public var bizId: String?

    public var channel: String?

    public var isBlackIcon: Bool?

    public var loaOssKey: String?

    public var logoGoodsId: String?

    public var materialId: String?

    public var orderData: String?

    public var partnerCode: String?

    public var phoneNum: String?

    public var realUserName: String?

    public var registerName: String?

    public var registerNumber: String?

    public var renewInfoId: String?

    public var rootCode: String?

    public var tmComment: String?

    public var tmIcon: String?

    public var tmName: String?

    public var tmNameType: String?

    public var type: Int32?

    public var uid: String?

    public var userId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.agreementId != nil {
            map["AgreementId"] = self.agreementId!
        }
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.channel != nil {
            map["Channel"] = self.channel!
        }
        if self.isBlackIcon != nil {
            map["IsBlackIcon"] = self.isBlackIcon!
        }
        if self.loaOssKey != nil {
            map["LoaOssKey"] = self.loaOssKey!
        }
        if self.logoGoodsId != nil {
            map["LogoGoodsId"] = self.logoGoodsId!
        }
        if self.materialId != nil {
            map["MaterialId"] = self.materialId!
        }
        if self.orderData != nil {
            map["OrderData"] = self.orderData!
        }
        if self.partnerCode != nil {
            map["PartnerCode"] = self.partnerCode!
        }
        if self.phoneNum != nil {
            map["PhoneNum"] = self.phoneNum!
        }
        if self.realUserName != nil {
            map["RealUserName"] = self.realUserName!
        }
        if self.registerName != nil {
            map["RegisterName"] = self.registerName!
        }
        if self.registerNumber != nil {
            map["RegisterNumber"] = self.registerNumber!
        }
        if self.renewInfoId != nil {
            map["RenewInfoId"] = self.renewInfoId!
        }
        if self.rootCode != nil {
            map["RootCode"] = self.rootCode!
        }
        if self.tmComment != nil {
            map["TmComment"] = self.tmComment!
        }
        if self.tmIcon != nil {
            map["TmIcon"] = self.tmIcon!
        }
        if self.tmName != nil {
            map["TmName"] = self.tmName!
        }
        if self.tmNameType != nil {
            map["TmNameType"] = self.tmNameType!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.uid != nil {
            map["Uid"] = self.uid!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AgreementId") && dict["AgreementId"] != nil {
            self.agreementId = dict["AgreementId"] as! String
        }
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("Channel") && dict["Channel"] != nil {
            self.channel = dict["Channel"] as! String
        }
        if dict.keys.contains("IsBlackIcon") && dict["IsBlackIcon"] != nil {
            self.isBlackIcon = dict["IsBlackIcon"] as! Bool
        }
        if dict.keys.contains("LoaOssKey") && dict["LoaOssKey"] != nil {
            self.loaOssKey = dict["LoaOssKey"] as! String
        }
        if dict.keys.contains("LogoGoodsId") && dict["LogoGoodsId"] != nil {
            self.logoGoodsId = dict["LogoGoodsId"] as! String
        }
        if dict.keys.contains("MaterialId") && dict["MaterialId"] != nil {
            self.materialId = dict["MaterialId"] as! String
        }
        if dict.keys.contains("OrderData") && dict["OrderData"] != nil {
            self.orderData = dict["OrderData"] as! String
        }
        if dict.keys.contains("PartnerCode") && dict["PartnerCode"] != nil {
            self.partnerCode = dict["PartnerCode"] as! String
        }
        if dict.keys.contains("PhoneNum") && dict["PhoneNum"] != nil {
            self.phoneNum = dict["PhoneNum"] as! String
        }
        if dict.keys.contains("RealUserName") && dict["RealUserName"] != nil {
            self.realUserName = dict["RealUserName"] as! String
        }
        if dict.keys.contains("RegisterName") && dict["RegisterName"] != nil {
            self.registerName = dict["RegisterName"] as! String
        }
        if dict.keys.contains("RegisterNumber") && dict["RegisterNumber"] != nil {
            self.registerNumber = dict["RegisterNumber"] as! String
        }
        if dict.keys.contains("RenewInfoId") && dict["RenewInfoId"] != nil {
            self.renewInfoId = dict["RenewInfoId"] as! String
        }
        if dict.keys.contains("RootCode") && dict["RootCode"] != nil {
            self.rootCode = dict["RootCode"] as! String
        }
        if dict.keys.contains("TmComment") && dict["TmComment"] != nil {
            self.tmComment = dict["TmComment"] as! String
        }
        if dict.keys.contains("TmIcon") && dict["TmIcon"] != nil {
            self.tmIcon = dict["TmIcon"] as! String
        }
        if dict.keys.contains("TmName") && dict["TmName"] != nil {
            self.tmName = dict["TmName"] as! String
        }
        if dict.keys.contains("TmNameType") && dict["TmNameType"] != nil {
            self.tmNameType = dict["TmNameType"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! Int32
        }
        if dict.keys.contains("Uid") && dict["Uid"] != nil {
            self.uid = dict["Uid"] as! String
        }
        if dict.keys.contains("UserId") && dict["UserId"] != nil {
            self.userId = dict["UserId"] as! Int64
        }
    }
}

public class CheckTrademarkOrderResponseBody : Tea.TeaModel {
    public var data: [String: Any]?

    public var errorMsg: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorMsg != nil {
            map["ErrorMsg"] = self.errorMsg!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! [String: Any]
        }
        if dict.keys.contains("ErrorMsg") && dict["ErrorMsg"] != nil {
            self.errorMsg = dict["ErrorMsg"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CheckTrademarkOrderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CheckTrademarkOrderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CheckTrademarkOrderResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CombineLoaRequest : Tea.TeaModel {
    public var address: String?

    public var applicantType: String?

    public var contactName: String?

    public var contactPhone: String?

    public var contactPostcode: String?

    public var materialId: String?

    public var materialName: String?

    public var nationality: String?

    public var personalType: String?

    public var principalName: Int32?

    public var tmNumber: String?

    public var tmProduceType: String?

    public var trademarkName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.address != nil {
            map["Address"] = self.address!
        }
        if self.applicantType != nil {
            map["ApplicantType"] = self.applicantType!
        }
        if self.contactName != nil {
            map["ContactName"] = self.contactName!
        }
        if self.contactPhone != nil {
            map["ContactPhone"] = self.contactPhone!
        }
        if self.contactPostcode != nil {
            map["ContactPostcode"] = self.contactPostcode!
        }
        if self.materialId != nil {
            map["MaterialId"] = self.materialId!
        }
        if self.materialName != nil {
            map["MaterialName"] = self.materialName!
        }
        if self.nationality != nil {
            map["Nationality"] = self.nationality!
        }
        if self.personalType != nil {
            map["PersonalType"] = self.personalType!
        }
        if self.principalName != nil {
            map["PrincipalName"] = self.principalName!
        }
        if self.tmNumber != nil {
            map["TmNumber"] = self.tmNumber!
        }
        if self.tmProduceType != nil {
            map["TmProduceType"] = self.tmProduceType!
        }
        if self.trademarkName != nil {
            map["TrademarkName"] = self.trademarkName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Address") && dict["Address"] != nil {
            self.address = dict["Address"] as! String
        }
        if dict.keys.contains("ApplicantType") && dict["ApplicantType"] != nil {
            self.applicantType = dict["ApplicantType"] as! String
        }
        if dict.keys.contains("ContactName") && dict["ContactName"] != nil {
            self.contactName = dict["ContactName"] as! String
        }
        if dict.keys.contains("ContactPhone") && dict["ContactPhone"] != nil {
            self.contactPhone = dict["ContactPhone"] as! String
        }
        if dict.keys.contains("ContactPostcode") && dict["ContactPostcode"] != nil {
            self.contactPostcode = dict["ContactPostcode"] as! String
        }
        if dict.keys.contains("MaterialId") && dict["MaterialId"] != nil {
            self.materialId = dict["MaterialId"] as! String
        }
        if dict.keys.contains("MaterialName") && dict["MaterialName"] != nil {
            self.materialName = dict["MaterialName"] as! String
        }
        if dict.keys.contains("Nationality") && dict["Nationality"] != nil {
            self.nationality = dict["Nationality"] as! String
        }
        if dict.keys.contains("PersonalType") && dict["PersonalType"] != nil {
            self.personalType = dict["PersonalType"] as! String
        }
        if dict.keys.contains("PrincipalName") && dict["PrincipalName"] != nil {
            self.principalName = dict["PrincipalName"] as! Int32
        }
        if dict.keys.contains("TmNumber") && dict["TmNumber"] != nil {
            self.tmNumber = dict["TmNumber"] as! String
        }
        if dict.keys.contains("TmProduceType") && dict["TmProduceType"] != nil {
            self.tmProduceType = dict["TmProduceType"] as! String
        }
        if dict.keys.contains("TrademarkName") && dict["TrademarkName"] != nil {
            self.trademarkName = dict["TrademarkName"] as! String
        }
    }
}

public class CombineLoaResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var templateCombineUrl: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.templateCombineUrl != nil {
            map["TemplateCombineUrl"] = self.templateCombineUrl!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TemplateCombineUrl") && dict["TemplateCombineUrl"] != nil {
            self.templateCombineUrl = dict["TemplateCombineUrl"] as! String
        }
    }
}

public class CombineLoaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CombineLoaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CombineLoaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CombineWTSRequest : Tea.TeaModel {
    public var address: String?

    public var contact: String?

    public var contactAddressPost: String?

    public var contactMobile: String?

    public var materialId: String?

    public var materialName: String?

    public var nationality: String?

    public var principalName: String?

    public var tmNum: String?

    public var tmProduceType: String?

    public var trademarkName: String?

    public var wtsType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.address != nil {
            map["Address"] = self.address!
        }
        if self.contact != nil {
            map["Contact"] = self.contact!
        }
        if self.contactAddressPost != nil {
            map["ContactAddressPost"] = self.contactAddressPost!
        }
        if self.contactMobile != nil {
            map["ContactMobile"] = self.contactMobile!
        }
        if self.materialId != nil {
            map["MaterialId"] = self.materialId!
        }
        if self.materialName != nil {
            map["MaterialName"] = self.materialName!
        }
        if self.nationality != nil {
            map["Nationality"] = self.nationality!
        }
        if self.principalName != nil {
            map["PrincipalName"] = self.principalName!
        }
        if self.tmNum != nil {
            map["TmNum"] = self.tmNum!
        }
        if self.tmProduceType != nil {
            map["TmProduceType"] = self.tmProduceType!
        }
        if self.trademarkName != nil {
            map["TrademarkName"] = self.trademarkName!
        }
        if self.wtsType != nil {
            map["WtsType"] = self.wtsType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Address") && dict["Address"] != nil {
            self.address = dict["Address"] as! String
        }
        if dict.keys.contains("Contact") && dict["Contact"] != nil {
            self.contact = dict["Contact"] as! String
        }
        if dict.keys.contains("ContactAddressPost") && dict["ContactAddressPost"] != nil {
            self.contactAddressPost = dict["ContactAddressPost"] as! String
        }
        if dict.keys.contains("ContactMobile") && dict["ContactMobile"] != nil {
            self.contactMobile = dict["ContactMobile"] as! String
        }
        if dict.keys.contains("MaterialId") && dict["MaterialId"] != nil {
            self.materialId = dict["MaterialId"] as! String
        }
        if dict.keys.contains("MaterialName") && dict["MaterialName"] != nil {
            self.materialName = dict["MaterialName"] as! String
        }
        if dict.keys.contains("Nationality") && dict["Nationality"] != nil {
            self.nationality = dict["Nationality"] as! String
        }
        if dict.keys.contains("PrincipalName") && dict["PrincipalName"] != nil {
            self.principalName = dict["PrincipalName"] as! String
        }
        if dict.keys.contains("TmNum") && dict["TmNum"] != nil {
            self.tmNum = dict["TmNum"] as! String
        }
        if dict.keys.contains("TmProduceType") && dict["TmProduceType"] != nil {
            self.tmProduceType = dict["TmProduceType"] as! String
        }
        if dict.keys.contains("TrademarkName") && dict["TrademarkName"] != nil {
            self.trademarkName = dict["TrademarkName"] as! String
        }
        if dict.keys.contains("WtsType") && dict["WtsType"] != nil {
            self.wtsType = dict["WtsType"] as! String
        }
    }
}

public class CombineWTSResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var templateCombineUrl: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.templateCombineUrl != nil {
            map["TemplateCombineUrl"] = self.templateCombineUrl!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TemplateCombineUrl") && dict["TemplateCombineUrl"] != nil {
            self.templateCombineUrl = dict["TemplateCombineUrl"] as! String
        }
    }
}

public class CombineWTSResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CombineWTSResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CombineWTSResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ComplementIntentionUserIdRequest : Tea.TeaModel {
    public var aliyunKp: String?

    public var bid: String?

    public var bizId: String?

    public var callerParentId: Int64?

    public var callerType: String?

    public var complementUserId: String?

    public var type: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliyunKp != nil {
            map["AliyunKp"] = self.aliyunKp!
        }
        if self.bid != nil {
            map["Bid"] = self.bid!
        }
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.callerParentId != nil {
            map["CallerParentId"] = self.callerParentId!
        }
        if self.callerType != nil {
            map["CallerType"] = self.callerType!
        }
        if self.complementUserId != nil {
            map["ComplementUserId"] = self.complementUserId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AliyunKp") && dict["AliyunKp"] != nil {
            self.aliyunKp = dict["AliyunKp"] as! String
        }
        if dict.keys.contains("Bid") && dict["Bid"] != nil {
            self.bid = dict["Bid"] as! String
        }
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("CallerParentId") && dict["CallerParentId"] != nil {
            self.callerParentId = dict["CallerParentId"] as! Int64
        }
        if dict.keys.contains("CallerType") && dict["CallerType"] != nil {
            self.callerType = dict["CallerType"] as! String
        }
        if dict.keys.contains("ComplementUserId") && dict["ComplementUserId"] != nil {
            self.complementUserId = dict["ComplementUserId"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! Int32
        }
    }
}

public class ComplementIntentionUserIdResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ComplementIntentionUserIdResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ComplementIntentionUserIdResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ComplementIntentionUserIdResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ConfirmAdditionalMaterialRequest : Tea.TeaModel {
    public var bizId: String?

    public var note: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.note != nil {
            map["Note"] = self.note!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("Note") && dict["Note"] != nil {
            self.note = dict["Note"] as! String
        }
    }
}

public class ConfirmAdditionalMaterialResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMsg: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["ErrorMsg"] = self.errorMsg!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMsg") && dict["ErrorMsg"] != nil {
            self.errorMsg = dict["ErrorMsg"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ConfirmAdditionalMaterialResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ConfirmAdditionalMaterialResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ConfirmAdditionalMaterialResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ConfirmApplicantRequest : Tea.TeaModel {
    public var bizId: String?

    public var note: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.note != nil {
            map["Note"] = self.note!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("Note") && dict["Note"] != nil {
            self.note = dict["Note"] as! String
        }
    }
}

public class ConfirmApplicantResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMsg: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["ErrorMsg"] = self.errorMsg!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMsg") && dict["ErrorMsg"] != nil {
            self.errorMsg = dict["ErrorMsg"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ConfirmApplicantResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ConfirmApplicantResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ConfirmApplicantResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ConfirmDissentOriginalRequest : Tea.TeaModel {
    public var bizId: String?

    public var contactAddress: String?

    public var contactCity: String?

    public var contactCounty: String?

    public var contactDistrict: String?

    public var contactName: String?

    public var contactNumber: String?

    public var contactProvince: String?

    public var operateType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.contactAddress != nil {
            map["ContactAddress"] = self.contactAddress!
        }
        if self.contactCity != nil {
            map["ContactCity"] = self.contactCity!
        }
        if self.contactCounty != nil {
            map["ContactCounty"] = self.contactCounty!
        }
        if self.contactDistrict != nil {
            map["ContactDistrict"] = self.contactDistrict!
        }
        if self.contactName != nil {
            map["ContactName"] = self.contactName!
        }
        if self.contactNumber != nil {
            map["ContactNumber"] = self.contactNumber!
        }
        if self.contactProvince != nil {
            map["ContactProvince"] = self.contactProvince!
        }
        if self.operateType != nil {
            map["OperateType"] = self.operateType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("ContactAddress") && dict["ContactAddress"] != nil {
            self.contactAddress = dict["ContactAddress"] as! String
        }
        if dict.keys.contains("ContactCity") && dict["ContactCity"] != nil {
            self.contactCity = dict["ContactCity"] as! String
        }
        if dict.keys.contains("ContactCounty") && dict["ContactCounty"] != nil {
            self.contactCounty = dict["ContactCounty"] as! String
        }
        if dict.keys.contains("ContactDistrict") && dict["ContactDistrict"] != nil {
            self.contactDistrict = dict["ContactDistrict"] as! String
        }
        if dict.keys.contains("ContactName") && dict["ContactName"] != nil {
            self.contactName = dict["ContactName"] as! String
        }
        if dict.keys.contains("ContactNumber") && dict["ContactNumber"] != nil {
            self.contactNumber = dict["ContactNumber"] as! String
        }
        if dict.keys.contains("ContactProvince") && dict["ContactProvince"] != nil {
            self.contactProvince = dict["ContactProvince"] as! String
        }
        if dict.keys.contains("OperateType") && dict["OperateType"] != nil {
            self.operateType = dict["OperateType"] as! String
        }
    }
}

public class ConfirmDissentOriginalResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ConfirmDissentOriginalResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ConfirmDissentOriginalResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ConfirmDissentOriginalResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ConvertImageToGrayRequest : Tea.TeaModel {
    public var ossKey: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ossKey != nil {
            map["OssKey"] = self.ossKey!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OssKey") && dict["OssKey"] != nil {
            self.ossKey = dict["OssKey"] as! String
        }
    }
}

public class ConvertImageToGrayResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var signatureUrl: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.signatureUrl != nil {
            map["SignatureUrl"] = self.signatureUrl!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SignatureUrl") && dict["SignatureUrl"] != nil {
            self.signatureUrl = dict["SignatureUrl"] as! String
        }
    }
}

public class ConvertImageToGrayResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ConvertImageToGrayResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ConvertImageToGrayResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CopyApplicantRequest : Tea.TeaModel {
    public var id: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
    }
}

public class CopyApplicantResponseBody : Tea.TeaModel {
    public var id: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CopyApplicantResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CopyApplicantResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CopyApplicantResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateIntentionOrderRequest : Tea.TeaModel {
    public var channel: String?

    public var intentionBizId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.channel != nil {
            map["Channel"] = self.channel!
        }
        if self.intentionBizId != nil {
            map["IntentionBizId"] = self.intentionBizId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Channel") && dict["Channel"] != nil {
            self.channel = dict["Channel"] as! String
        }
        if dict.keys.contains("IntentionBizId") && dict["IntentionBizId"] != nil {
            self.intentionBizId = dict["IntentionBizId"] as! String
        }
    }
}

public class CreateIntentionOrderResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var orderIds: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.orderIds != nil {
                map["OrderIds"] = self.orderIds!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("OrderIds") && dict["OrderIds"] != nil {
                self.orderIds = dict["OrderIds"] as! [String]
            }
        }
    }
    public var data: CreateIntentionOrderResponseBody.Data?

    public var errorMsg: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorMsg != nil {
            map["ErrorMsg"] = self.errorMsg!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = CreateIntentionOrderResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorMsg") && dict["ErrorMsg"] != nil {
            self.errorMsg = dict["ErrorMsg"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateIntentionOrderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateIntentionOrderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateIntentionOrderResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateIntentionOrderGeneratingPayRequest : Tea.TeaModel {
    public var channel: String?

    public var intentionBizId: String?

    public var paymentCallback: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.channel != nil {
            map["Channel"] = self.channel!
        }
        if self.intentionBizId != nil {
            map["IntentionBizId"] = self.intentionBizId!
        }
        if self.paymentCallback != nil {
            map["PaymentCallback"] = self.paymentCallback!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Channel") && dict["Channel"] != nil {
            self.channel = dict["Channel"] as! String
        }
        if dict.keys.contains("IntentionBizId") && dict["IntentionBizId"] != nil {
            self.intentionBizId = dict["IntentionBizId"] as! String
        }
        if dict.keys.contains("PaymentCallback") && dict["PaymentCallback"] != nil {
            self.paymentCallback = dict["PaymentCallback"] as! String
        }
    }
}

public class CreateIntentionOrderGeneratingPayResponseBody : Tea.TeaModel {
    public var errorMsg: String?

    public var orderIds: [Int64]?

    public var payUrl: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorMsg != nil {
            map["ErrorMsg"] = self.errorMsg!
        }
        if self.orderIds != nil {
            map["OrderIds"] = self.orderIds!
        }
        if self.payUrl != nil {
            map["PayUrl"] = self.payUrl!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorMsg") && dict["ErrorMsg"] != nil {
            self.errorMsg = dict["ErrorMsg"] as! String
        }
        if dict.keys.contains("OrderIds") && dict["OrderIds"] != nil {
            self.orderIds = dict["OrderIds"] as! [Int64]
        }
        if dict.keys.contains("PayUrl") && dict["PayUrl"] != nil {
            self.payUrl = dict["PayUrl"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateIntentionOrderGeneratingPayResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateIntentionOrderGeneratingPayResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateIntentionOrderGeneratingPayResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateTrademarkOrderRequest : Tea.TeaModel {
    public var agreementId: String?

    public var bigDipperSource: String?

    public var bizId: String?

    public var channel: String?

    public var isBlackIcon: Bool?

    public var legalNoticeKey: String?

    public var loaOssKey: String?

    public var materialId: String?

    public var orderData: String?

    public var partnerCode: String?

    public var phoneNum: String?

    public var principalName: Int32?

    public var realUserName: String?

    public var registerName: String?

    public var registerNumber: String?

    public var renewInfoId: String?

    public var rootCode: String?

    public var sessionId: String?

    public var tmComment: String?

    public var tmIcon: String?

    public var tmName: String?

    public var tmNameType: String?

    public var type: Int32?

    public var ua: String?

    public var uid: String?

    public var userId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.agreementId != nil {
            map["AgreementId"] = self.agreementId!
        }
        if self.bigDipperSource != nil {
            map["BigDipperSource"] = self.bigDipperSource!
        }
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.channel != nil {
            map["Channel"] = self.channel!
        }
        if self.isBlackIcon != nil {
            map["IsBlackIcon"] = self.isBlackIcon!
        }
        if self.legalNoticeKey != nil {
            map["LegalNoticeKey"] = self.legalNoticeKey!
        }
        if self.loaOssKey != nil {
            map["LoaOssKey"] = self.loaOssKey!
        }
        if self.materialId != nil {
            map["MaterialId"] = self.materialId!
        }
        if self.orderData != nil {
            map["OrderData"] = self.orderData!
        }
        if self.partnerCode != nil {
            map["PartnerCode"] = self.partnerCode!
        }
        if self.phoneNum != nil {
            map["PhoneNum"] = self.phoneNum!
        }
        if self.principalName != nil {
            map["PrincipalName"] = self.principalName!
        }
        if self.realUserName != nil {
            map["RealUserName"] = self.realUserName!
        }
        if self.registerName != nil {
            map["RegisterName"] = self.registerName!
        }
        if self.registerNumber != nil {
            map["RegisterNumber"] = self.registerNumber!
        }
        if self.renewInfoId != nil {
            map["RenewInfoId"] = self.renewInfoId!
        }
        if self.rootCode != nil {
            map["RootCode"] = self.rootCode!
        }
        if self.sessionId != nil {
            map["SessionId"] = self.sessionId!
        }
        if self.tmComment != nil {
            map["TmComment"] = self.tmComment!
        }
        if self.tmIcon != nil {
            map["TmIcon"] = self.tmIcon!
        }
        if self.tmName != nil {
            map["TmName"] = self.tmName!
        }
        if self.tmNameType != nil {
            map["TmNameType"] = self.tmNameType!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.ua != nil {
            map["Ua"] = self.ua!
        }
        if self.uid != nil {
            map["Uid"] = self.uid!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AgreementId") && dict["AgreementId"] != nil {
            self.agreementId = dict["AgreementId"] as! String
        }
        if dict.keys.contains("BigDipperSource") && dict["BigDipperSource"] != nil {
            self.bigDipperSource = dict["BigDipperSource"] as! String
        }
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("Channel") && dict["Channel"] != nil {
            self.channel = dict["Channel"] as! String
        }
        if dict.keys.contains("IsBlackIcon") && dict["IsBlackIcon"] != nil {
            self.isBlackIcon = dict["IsBlackIcon"] as! Bool
        }
        if dict.keys.contains("LegalNoticeKey") && dict["LegalNoticeKey"] != nil {
            self.legalNoticeKey = dict["LegalNoticeKey"] as! String
        }
        if dict.keys.contains("LoaOssKey") && dict["LoaOssKey"] != nil {
            self.loaOssKey = dict["LoaOssKey"] as! String
        }
        if dict.keys.contains("MaterialId") && dict["MaterialId"] != nil {
            self.materialId = dict["MaterialId"] as! String
        }
        if dict.keys.contains("OrderData") && dict["OrderData"] != nil {
            self.orderData = dict["OrderData"] as! String
        }
        if dict.keys.contains("PartnerCode") && dict["PartnerCode"] != nil {
            self.partnerCode = dict["PartnerCode"] as! String
        }
        if dict.keys.contains("PhoneNum") && dict["PhoneNum"] != nil {
            self.phoneNum = dict["PhoneNum"] as! String
        }
        if dict.keys.contains("PrincipalName") && dict["PrincipalName"] != nil {
            self.principalName = dict["PrincipalName"] as! Int32
        }
        if dict.keys.contains("RealUserName") && dict["RealUserName"] != nil {
            self.realUserName = dict["RealUserName"] as! String
        }
        if dict.keys.contains("RegisterName") && dict["RegisterName"] != nil {
            self.registerName = dict["RegisterName"] as! String
        }
        if dict.keys.contains("RegisterNumber") && dict["RegisterNumber"] != nil {
            self.registerNumber = dict["RegisterNumber"] as! String
        }
        if dict.keys.contains("RenewInfoId") && dict["RenewInfoId"] != nil {
            self.renewInfoId = dict["RenewInfoId"] as! String
        }
        if dict.keys.contains("RootCode") && dict["RootCode"] != nil {
            self.rootCode = dict["RootCode"] as! String
        }
        if dict.keys.contains("SessionId") && dict["SessionId"] != nil {
            self.sessionId = dict["SessionId"] as! String
        }
        if dict.keys.contains("TmComment") && dict["TmComment"] != nil {
            self.tmComment = dict["TmComment"] as! String
        }
        if dict.keys.contains("TmIcon") && dict["TmIcon"] != nil {
            self.tmIcon = dict["TmIcon"] as! String
        }
        if dict.keys.contains("TmName") && dict["TmName"] != nil {
            self.tmName = dict["TmName"] as! String
        }
        if dict.keys.contains("TmNameType") && dict["TmNameType"] != nil {
            self.tmNameType = dict["TmNameType"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! Int32
        }
        if dict.keys.contains("Ua") && dict["Ua"] != nil {
            self.ua = dict["Ua"] as! String
        }
        if dict.keys.contains("Uid") && dict["Uid"] != nil {
            self.uid = dict["Uid"] as! String
        }
        if dict.keys.contains("UserId") && dict["UserId"] != nil {
            self.userId = dict["UserId"] as! Int64
        }
    }
}

public class CreateTrademarkOrderResponseBody : Tea.TeaModel {
    public var errorMsg: String?

    public var orderId: Int64?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorMsg != nil {
            map["ErrorMsg"] = self.errorMsg!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorMsg") && dict["ErrorMsg"] != nil {
            self.errorMsg = dict["ErrorMsg"] as! String
        }
        if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateTrademarkOrderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateTrademarkOrderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateTrademarkOrderResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteMaterialRequest : Tea.TeaModel {
    public var id: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
    }
}

public class DeleteMaterialResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMsg: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["ErrorMsg"] = self.errorMsg!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMsg") && dict["ErrorMsg"] != nil {
            self.errorMsg = dict["ErrorMsg"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteMaterialResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteMaterialResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteMaterialResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteTmMonitorRuleRequest : Tea.TeaModel {
    public var id: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
    }
}

public class DeleteTmMonitorRuleResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMsg: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["ErrorMsg"] = self.errorMsg!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMsg") && dict["ErrorMsg"] != nil {
            self.errorMsg = dict["ErrorMsg"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteTmMonitorRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteTmMonitorRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteTmMonitorRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteTrademarkApplicationRequest : Tea.TeaModel {
    public var bizId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
    }
}

public class DeleteTrademarkApplicationResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteTrademarkApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteTrademarkApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteTrademarkApplicationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DenySupplementRequest : Tea.TeaModel {
    public var id: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
    }
}

public class DenySupplementResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMsg: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["ErrorMsg"] = self.errorMsg!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMsg") && dict["ErrorMsg"] != nil {
            self.errorMsg = dict["ErrorMsg"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DenySupplementResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DenySupplementResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DenySupplementResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescirbeCombineTrademarkRequest : Tea.TeaModel {
    public var accurateMatch: Bool?

    public var classification: String?

    public var name: String?

    public var ownerName: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var products: String?

    public var registrationNumber: String?

    public var similarGroups: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accurateMatch != nil {
            map["AccurateMatch"] = self.accurateMatch!
        }
        if self.classification != nil {
            map["Classification"] = self.classification!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerName != nil {
            map["OwnerName"] = self.ownerName!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.products != nil {
            map["Products"] = self.products!
        }
        if self.registrationNumber != nil {
            map["RegistrationNumber"] = self.registrationNumber!
        }
        if self.similarGroups != nil {
            map["SimilarGroups"] = self.similarGroups!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccurateMatch") && dict["AccurateMatch"] != nil {
            self.accurateMatch = dict["AccurateMatch"] as! Bool
        }
        if dict.keys.contains("Classification") && dict["Classification"] != nil {
            self.classification = dict["Classification"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OwnerName") && dict["OwnerName"] != nil {
            self.ownerName = dict["OwnerName"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Products") && dict["Products"] != nil {
            self.products = dict["Products"] as! String
        }
        if dict.keys.contains("RegistrationNumber") && dict["RegistrationNumber"] != nil {
            self.registrationNumber = dict["RegistrationNumber"] as! String
        }
        if dict.keys.contains("SimilarGroups") && dict["SimilarGroups"] != nil {
            self.similarGroups = dict["SimilarGroups"] as! String
        }
    }
}

public class DescirbeCombineTrademarkResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class AnnouncementList : Tea.TeaModel {
            public var annDate: String?

            public var annNumber: String?

            public var annTypeCode: String?

            public var annTypeName: String?

            public var imageUrl: String?

            public var originalImageUrl: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.annDate != nil {
                    map["AnnDate"] = self.annDate!
                }
                if self.annNumber != nil {
                    map["AnnNumber"] = self.annNumber!
                }
                if self.annTypeCode != nil {
                    map["AnnTypeCode"] = self.annTypeCode!
                }
                if self.annTypeName != nil {
                    map["AnnTypeName"] = self.annTypeName!
                }
                if self.imageUrl != nil {
                    map["ImageUrl"] = self.imageUrl!
                }
                if self.originalImageUrl != nil {
                    map["OriginalImageUrl"] = self.originalImageUrl!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AnnDate") && dict["AnnDate"] != nil {
                    self.annDate = dict["AnnDate"] as! String
                }
                if dict.keys.contains("AnnNumber") && dict["AnnNumber"] != nil {
                    self.annNumber = dict["AnnNumber"] as! String
                }
                if dict.keys.contains("AnnTypeCode") && dict["AnnTypeCode"] != nil {
                    self.annTypeCode = dict["AnnTypeCode"] as! String
                }
                if dict.keys.contains("AnnTypeName") && dict["AnnTypeName"] != nil {
                    self.annTypeName = dict["AnnTypeName"] as! String
                }
                if dict.keys.contains("ImageUrl") && dict["ImageUrl"] != nil {
                    self.imageUrl = dict["ImageUrl"] as! String
                }
                if dict.keys.contains("OriginalImageUrl") && dict["OriginalImageUrl"] != nil {
                    self.originalImageUrl = dict["OriginalImageUrl"] as! String
                }
            }
        }
        public class Procedures : Tea.TeaModel {
            public var procedureCode: String?

            public var procedureDate: String?

            public var procedureName: String?

            public var procedureResult: String?

            public var procedureStep: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.procedureCode != nil {
                    map["ProcedureCode"] = self.procedureCode!
                }
                if self.procedureDate != nil {
                    map["ProcedureDate"] = self.procedureDate!
                }
                if self.procedureName != nil {
                    map["ProcedureName"] = self.procedureName!
                }
                if self.procedureResult != nil {
                    map["ProcedureResult"] = self.procedureResult!
                }
                if self.procedureStep != nil {
                    map["ProcedureStep"] = self.procedureStep!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ProcedureCode") && dict["ProcedureCode"] != nil {
                    self.procedureCode = dict["ProcedureCode"] as! String
                }
                if dict.keys.contains("ProcedureDate") && dict["ProcedureDate"] != nil {
                    self.procedureDate = dict["ProcedureDate"] as! String
                }
                if dict.keys.contains("ProcedureName") && dict["ProcedureName"] != nil {
                    self.procedureName = dict["ProcedureName"] as! String
                }
                if dict.keys.contains("ProcedureResult") && dict["ProcedureResult"] != nil {
                    self.procedureResult = dict["ProcedureResult"] as! String
                }
                if dict.keys.contains("ProcedureStep") && dict["ProcedureStep"] != nil {
                    self.procedureStep = dict["ProcedureStep"] as! String
                }
            }
        }
        public var agency: String?

        public var announcementList: [DescirbeCombineTrademarkResponseBody.Data.AnnouncementList]?

        public var applyDate: String?

        public var classification: String?

        public var exclusiveDateLimit: String?

        public var firstAnnoNumber: String?

        public var firstAnnoType: String?

        public var image: String?

        public var indexId: String?

        public var intlRegDate: String?

        public var lastProcedureStatus: String?

        public var lawFinalStatus: String?

        public var name: String?

        public var onSale: Int32?

        public var ownerAddress: String?

        public var ownerEnAddress: String?

        public var ownerEnName: String?

        public var ownerName: String?

        public var preAnnDate: String?

        public var preAnnNumber: String?

        public var priorityDate: String?

        public var procedures: [DescirbeCombineTrademarkResponseBody.Data.Procedures]?

        public var productDescription: String?

        public var regAnnDate: String?

        public var regAnnNumber: String?

        public var registrationNumber: String?

        public var registrationType: String?

        public var secondAnnoNumber: String?

        public var secondAnnoType: String?

        public var share: String?

        public var similarGroup: String?

        public var status: String?

        public var subsequentDesignationDate: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.agency != nil {
                map["Agency"] = self.agency!
            }
            if self.announcementList != nil {
                var tmp : [Any] = []
                for k in self.announcementList! {
                    tmp.append(k.toMap())
                }
                map["AnnouncementList"] = tmp
            }
            if self.applyDate != nil {
                map["ApplyDate"] = self.applyDate!
            }
            if self.classification != nil {
                map["Classification"] = self.classification!
            }
            if self.exclusiveDateLimit != nil {
                map["ExclusiveDateLimit"] = self.exclusiveDateLimit!
            }
            if self.firstAnnoNumber != nil {
                map["FirstAnnoNumber"] = self.firstAnnoNumber!
            }
            if self.firstAnnoType != nil {
                map["FirstAnnoType"] = self.firstAnnoType!
            }
            if self.image != nil {
                map["Image"] = self.image!
            }
            if self.indexId != nil {
                map["IndexId"] = self.indexId!
            }
            if self.intlRegDate != nil {
                map["IntlRegDate"] = self.intlRegDate!
            }
            if self.lastProcedureStatus != nil {
                map["LastProcedureStatus"] = self.lastProcedureStatus!
            }
            if self.lawFinalStatus != nil {
                map["LawFinalStatus"] = self.lawFinalStatus!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.onSale != nil {
                map["OnSale"] = self.onSale!
            }
            if self.ownerAddress != nil {
                map["OwnerAddress"] = self.ownerAddress!
            }
            if self.ownerEnAddress != nil {
                map["OwnerEnAddress"] = self.ownerEnAddress!
            }
            if self.ownerEnName != nil {
                map["OwnerEnName"] = self.ownerEnName!
            }
            if self.ownerName != nil {
                map["OwnerName"] = self.ownerName!
            }
            if self.preAnnDate != nil {
                map["PreAnnDate"] = self.preAnnDate!
            }
            if self.preAnnNumber != nil {
                map["PreAnnNumber"] = self.preAnnNumber!
            }
            if self.priorityDate != nil {
                map["PriorityDate"] = self.priorityDate!
            }
            if self.procedures != nil {
                var tmp : [Any] = []
                for k in self.procedures! {
                    tmp.append(k.toMap())
                }
                map["Procedures"] = tmp
            }
            if self.productDescription != nil {
                map["ProductDescription"] = self.productDescription!
            }
            if self.regAnnDate != nil {
                map["RegAnnDate"] = self.regAnnDate!
            }
            if self.regAnnNumber != nil {
                map["RegAnnNumber"] = self.regAnnNumber!
            }
            if self.registrationNumber != nil {
                map["RegistrationNumber"] = self.registrationNumber!
            }
            if self.registrationType != nil {
                map["RegistrationType"] = self.registrationType!
            }
            if self.secondAnnoNumber != nil {
                map["SecondAnnoNumber"] = self.secondAnnoNumber!
            }
            if self.secondAnnoType != nil {
                map["SecondAnnoType"] = self.secondAnnoType!
            }
            if self.share != nil {
                map["Share"] = self.share!
            }
            if self.similarGroup != nil {
                map["SimilarGroup"] = self.similarGroup!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.subsequentDesignationDate != nil {
                map["SubsequentDesignationDate"] = self.subsequentDesignationDate!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Agency") && dict["Agency"] != nil {
                self.agency = dict["Agency"] as! String
            }
            if dict.keys.contains("AnnouncementList") && dict["AnnouncementList"] != nil {
                var tmp : [DescirbeCombineTrademarkResponseBody.Data.AnnouncementList] = []
                for v in dict["AnnouncementList"] as! [Any] {
                    var model = DescirbeCombineTrademarkResponseBody.Data.AnnouncementList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.announcementList = tmp
            }
            if dict.keys.contains("ApplyDate") && dict["ApplyDate"] != nil {
                self.applyDate = dict["ApplyDate"] as! String
            }
            if dict.keys.contains("Classification") && dict["Classification"] != nil {
                self.classification = dict["Classification"] as! String
            }
            if dict.keys.contains("ExclusiveDateLimit") && dict["ExclusiveDateLimit"] != nil {
                self.exclusiveDateLimit = dict["ExclusiveDateLimit"] as! String
            }
            if dict.keys.contains("FirstAnnoNumber") && dict["FirstAnnoNumber"] != nil {
                self.firstAnnoNumber = dict["FirstAnnoNumber"] as! String
            }
            if dict.keys.contains("FirstAnnoType") && dict["FirstAnnoType"] != nil {
                self.firstAnnoType = dict["FirstAnnoType"] as! String
            }
            if dict.keys.contains("Image") && dict["Image"] != nil {
                self.image = dict["Image"] as! String
            }
            if dict.keys.contains("IndexId") && dict["IndexId"] != nil {
                self.indexId = dict["IndexId"] as! String
            }
            if dict.keys.contains("IntlRegDate") && dict["IntlRegDate"] != nil {
                self.intlRegDate = dict["IntlRegDate"] as! String
            }
            if dict.keys.contains("LastProcedureStatus") && dict["LastProcedureStatus"] != nil {
                self.lastProcedureStatus = dict["LastProcedureStatus"] as! String
            }
            if dict.keys.contains("LawFinalStatus") && dict["LawFinalStatus"] != nil {
                self.lawFinalStatus = dict["LawFinalStatus"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("OnSale") && dict["OnSale"] != nil {
                self.onSale = dict["OnSale"] as! Int32
            }
            if dict.keys.contains("OwnerAddress") && dict["OwnerAddress"] != nil {
                self.ownerAddress = dict["OwnerAddress"] as! String
            }
            if dict.keys.contains("OwnerEnAddress") && dict["OwnerEnAddress"] != nil {
                self.ownerEnAddress = dict["OwnerEnAddress"] as! String
            }
            if dict.keys.contains("OwnerEnName") && dict["OwnerEnName"] != nil {
                self.ownerEnName = dict["OwnerEnName"] as! String
            }
            if dict.keys.contains("OwnerName") && dict["OwnerName"] != nil {
                self.ownerName = dict["OwnerName"] as! String
            }
            if dict.keys.contains("PreAnnDate") && dict["PreAnnDate"] != nil {
                self.preAnnDate = dict["PreAnnDate"] as! String
            }
            if dict.keys.contains("PreAnnNumber") && dict["PreAnnNumber"] != nil {
                self.preAnnNumber = dict["PreAnnNumber"] as! String
            }
            if dict.keys.contains("PriorityDate") && dict["PriorityDate"] != nil {
                self.priorityDate = dict["PriorityDate"] as! String
            }
            if dict.keys.contains("Procedures") && dict["Procedures"] != nil {
                var tmp : [DescirbeCombineTrademarkResponseBody.Data.Procedures] = []
                for v in dict["Procedures"] as! [Any] {
                    var model = DescirbeCombineTrademarkResponseBody.Data.Procedures()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.procedures = tmp
            }
            if dict.keys.contains("ProductDescription") && dict["ProductDescription"] != nil {
                self.productDescription = dict["ProductDescription"] as! String
            }
            if dict.keys.contains("RegAnnDate") && dict["RegAnnDate"] != nil {
                self.regAnnDate = dict["RegAnnDate"] as! String
            }
            if dict.keys.contains("RegAnnNumber") && dict["RegAnnNumber"] != nil {
                self.regAnnNumber = dict["RegAnnNumber"] as! String
            }
            if dict.keys.contains("RegistrationNumber") && dict["RegistrationNumber"] != nil {
                self.registrationNumber = dict["RegistrationNumber"] as! String
            }
            if dict.keys.contains("RegistrationType") && dict["RegistrationType"] != nil {
                self.registrationType = dict["RegistrationType"] as! String
            }
            if dict.keys.contains("SecondAnnoNumber") && dict["SecondAnnoNumber"] != nil {
                self.secondAnnoNumber = dict["SecondAnnoNumber"] as! String
            }
            if dict.keys.contains("SecondAnnoType") && dict["SecondAnnoType"] != nil {
                self.secondAnnoType = dict["SecondAnnoType"] as! String
            }
            if dict.keys.contains("Share") && dict["Share"] != nil {
                self.share = dict["Share"] as! String
            }
            if dict.keys.contains("SimilarGroup") && dict["SimilarGroup"] != nil {
                self.similarGroup = dict["SimilarGroup"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("SubsequentDesignationDate") && dict["SubsequentDesignationDate"] != nil {
                self.subsequentDesignationDate = dict["SubsequentDesignationDate"] as! String
            }
        }
    }
    public var currentPageNumber: Int32?

    public var data: [DescirbeCombineTrademarkResponseBody.Data]?

    public var nextPage: Bool?

    public var pageSize: Int32?

    public var prePage: Bool?

    public var requestId: String?

    public var totalItemNumber: Int32?

    public var totalPageNumber: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPageNumber != nil {
            map["CurrentPageNumber"] = self.currentPageNumber!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.nextPage != nil {
            map["NextPage"] = self.nextPage!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.prePage != nil {
            map["PrePage"] = self.prePage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalItemNumber != nil {
            map["TotalItemNumber"] = self.totalItemNumber!
        }
        if self.totalPageNumber != nil {
            map["TotalPageNumber"] = self.totalPageNumber!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPageNumber") && dict["CurrentPageNumber"] != nil {
            self.currentPageNumber = dict["CurrentPageNumber"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [DescirbeCombineTrademarkResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = DescirbeCombineTrademarkResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("NextPage") && dict["NextPage"] != nil {
            self.nextPage = dict["NextPage"] as! Bool
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("PrePage") && dict["PrePage"] != nil {
            self.prePage = dict["PrePage"] as! Bool
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalItemNumber") && dict["TotalItemNumber"] != nil {
            self.totalItemNumber = dict["TotalItemNumber"] as! Int32
        }
        if dict.keys.contains("TotalPageNumber") && dict["TotalPageNumber"] != nil {
            self.totalPageNumber = dict["TotalPageNumber"] as! Int32
        }
    }
}

public class DescirbeCombineTrademarkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescirbeCombineTrademarkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescirbeCombineTrademarkResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class FillLogisticsRequest : Tea.TeaModel {
    public var bizId: String?

    public var logistics: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.logistics != nil {
            map["Logistics"] = self.logistics!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("Logistics") && dict["Logistics"] != nil {
            self.logistics = dict["Logistics"] as! String
        }
    }
}

public class FillLogisticsResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMsg: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["ErrorMsg"] = self.errorMsg!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMsg") && dict["ErrorMsg"] != nil {
            self.errorMsg = dict["ErrorMsg"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class FillLogisticsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: FillLogisticsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = FillLogisticsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class FilterUnavailableCodesRequest : Tea.TeaModel {
    public var codes: [String: Any]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.codes != nil {
            map["Codes"] = self.codes!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Codes") && dict["Codes"] != nil {
            self.codes = dict["Codes"] as! [String: Any]
        }
    }
}

public class FilterUnavailableCodesShrinkRequest : Tea.TeaModel {
    public var codesShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.codesShrink != nil {
            map["Codes"] = self.codesShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Codes") && dict["Codes"] != nil {
            self.codesShrink = dict["Codes"] as! String
        }
    }
}

public class FilterUnavailableCodesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var codes: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.codes != nil {
                map["Codes"] = self.codes!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Codes") && dict["Codes"] != nil {
                self.codes = dict["Codes"] as! [String]
            }
        }
    }
    public var data: FilterUnavailableCodesResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = FilterUnavailableCodesResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class FilterUnavailableCodesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: FilterUnavailableCodesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = FilterUnavailableCodesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ForceUploadTrademarkOnsaleRequest : Tea.TeaModel {
    public var beginTime: Int64?

    public var classificationCode: String?

    public var description_: String?

    public var endTime: Int64?

    public var label: String?

    public var originalPrice: Double?

    public var ownerEnName: String?

    public var ownerName: String?

    public var reason: String?

    public var regAnnDate: Int64?

    public var secondaryClassification: String?

    public var thirdClassification: String?

    public var tmIcon: String?

    public var tmName: String?

    public var tmNumber: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.beginTime != nil {
            map["BeginTime"] = self.beginTime!
        }
        if self.classificationCode != nil {
            map["ClassificationCode"] = self.classificationCode!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.label != nil {
            map["Label"] = self.label!
        }
        if self.originalPrice != nil {
            map["OriginalPrice"] = self.originalPrice!
        }
        if self.ownerEnName != nil {
            map["OwnerEnName"] = self.ownerEnName!
        }
        if self.ownerName != nil {
            map["OwnerName"] = self.ownerName!
        }
        if self.reason != nil {
            map["Reason"] = self.reason!
        }
        if self.regAnnDate != nil {
            map["RegAnnDate"] = self.regAnnDate!
        }
        if self.secondaryClassification != nil {
            map["SecondaryClassification"] = self.secondaryClassification!
        }
        if self.thirdClassification != nil {
            map["ThirdClassification"] = self.thirdClassification!
        }
        if self.tmIcon != nil {
            map["TmIcon"] = self.tmIcon!
        }
        if self.tmName != nil {
            map["TmName"] = self.tmName!
        }
        if self.tmNumber != nil {
            map["TmNumber"] = self.tmNumber!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BeginTime") && dict["BeginTime"] != nil {
            self.beginTime = dict["BeginTime"] as! Int64
        }
        if dict.keys.contains("ClassificationCode") && dict["ClassificationCode"] != nil {
            self.classificationCode = dict["ClassificationCode"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("Label") && dict["Label"] != nil {
            self.label = dict["Label"] as! String
        }
        if dict.keys.contains("OriginalPrice") && dict["OriginalPrice"] != nil {
            self.originalPrice = dict["OriginalPrice"] as! Double
        }
        if dict.keys.contains("OwnerEnName") && dict["OwnerEnName"] != nil {
            self.ownerEnName = dict["OwnerEnName"] as! String
        }
        if dict.keys.contains("OwnerName") && dict["OwnerName"] != nil {
            self.ownerName = dict["OwnerName"] as! String
        }
        if dict.keys.contains("Reason") && dict["Reason"] != nil {
            self.reason = dict["Reason"] as! String
        }
        if dict.keys.contains("RegAnnDate") && dict["RegAnnDate"] != nil {
            self.regAnnDate = dict["RegAnnDate"] as! Int64
        }
        if dict.keys.contains("SecondaryClassification") && dict["SecondaryClassification"] != nil {
            self.secondaryClassification = dict["SecondaryClassification"] as! String
        }
        if dict.keys.contains("ThirdClassification") && dict["ThirdClassification"] != nil {
            self.thirdClassification = dict["ThirdClassification"] as! String
        }
        if dict.keys.contains("TmIcon") && dict["TmIcon"] != nil {
            self.tmIcon = dict["TmIcon"] as! String
        }
        if dict.keys.contains("TmName") && dict["TmName"] != nil {
            self.tmName = dict["TmName"] as! String
        }
        if dict.keys.contains("TmNumber") && dict["TmNumber"] != nil {
            self.tmNumber = dict["TmNumber"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class ForceUploadTrademarkOnsaleResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ForceUploadTrademarkOnsaleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ForceUploadTrademarkOnsaleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ForceUploadTrademarkOnsaleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GenerateQrCodeRequest : Tea.TeaModel {
    public var fieldKey: String?

    public var ossKey: String?

    public var uuid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fieldKey != nil {
            map["FieldKey"] = self.fieldKey!
        }
        if self.ossKey != nil {
            map["OssKey"] = self.ossKey!
        }
        if self.uuid != nil {
            map["Uuid"] = self.uuid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FieldKey") && dict["FieldKey"] != nil {
            self.fieldKey = dict["FieldKey"] as! String
        }
        if dict.keys.contains("OssKey") && dict["OssKey"] != nil {
            self.ossKey = dict["OssKey"] as! String
        }
        if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
            self.uuid = dict["Uuid"] as! String
        }
    }
}

public class GenerateQrCodeResponseBody : Tea.TeaModel {
    public var expireTime: Int64?

    public var fieldKey: String?

    public var qrcodeUrl: String?

    public var requestId: String?

    public var success: Bool?

    public var uuid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.expireTime != nil {
            map["ExpireTime"] = self.expireTime!
        }
        if self.fieldKey != nil {
            map["FieldKey"] = self.fieldKey!
        }
        if self.qrcodeUrl != nil {
            map["QrcodeUrl"] = self.qrcodeUrl!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.uuid != nil {
            map["Uuid"] = self.uuid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ExpireTime") && dict["ExpireTime"] != nil {
            self.expireTime = dict["ExpireTime"] as! Int64
        }
        if dict.keys.contains("FieldKey") && dict["FieldKey"] != nil {
            self.fieldKey = dict["FieldKey"] as! String
        }
        if dict.keys.contains("QrcodeUrl") && dict["QrcodeUrl"] != nil {
            self.qrcodeUrl = dict["QrcodeUrl"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
            self.uuid = dict["Uuid"] as! String
        }
    }
}

public class GenerateQrCodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GenerateQrCodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GenerateQrCodeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GenerateUploadFilePolicyRequest : Tea.TeaModel {
    public var bizId: String?

    public var fileType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.fileType != nil {
            map["FileType"] = self.fileType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("FileType") && dict["FileType"] != nil {
            self.fileType = dict["FileType"] as! String
        }
    }
}

public class GenerateUploadFilePolicyResponseBody : Tea.TeaModel {
    public var accessId: String?

    public var encodedPolicy: String?

    public var expireTime: Int64?

    public var fileDir: String?

    public var host: String?

    public var requestId: String?

    public var signature: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessId != nil {
            map["AccessId"] = self.accessId!
        }
        if self.encodedPolicy != nil {
            map["EncodedPolicy"] = self.encodedPolicy!
        }
        if self.expireTime != nil {
            map["ExpireTime"] = self.expireTime!
        }
        if self.fileDir != nil {
            map["FileDir"] = self.fileDir!
        }
        if self.host != nil {
            map["Host"] = self.host!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.signature != nil {
            map["Signature"] = self.signature!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccessId") && dict["AccessId"] != nil {
            self.accessId = dict["AccessId"] as! String
        }
        if dict.keys.contains("EncodedPolicy") && dict["EncodedPolicy"] != nil {
            self.encodedPolicy = dict["EncodedPolicy"] as! String
        }
        if dict.keys.contains("ExpireTime") && dict["ExpireTime"] != nil {
            self.expireTime = dict["ExpireTime"] as! Int64
        }
        if dict.keys.contains("FileDir") && dict["FileDir"] != nil {
            self.fileDir = dict["FileDir"] as! String
        }
        if dict.keys.contains("Host") && dict["Host"] != nil {
            self.host = dict["Host"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Signature") && dict["Signature"] != nil {
            self.signature = dict["Signature"] as! String
        }
    }
}

public class GenerateUploadFilePolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GenerateUploadFilePolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GenerateUploadFilePolicyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetAuthorizationLetterVersionRequest : Tea.TeaModel {
    public var ossKey: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ossKey != nil {
            map["OssKey"] = self.ossKey!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OssKey") && dict["OssKey"] != nil {
            self.ossKey = dict["OssKey"] as! String
        }
    }
}

public class GetAuthorizationLetterVersionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var version: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.version != nil {
            map["Version"] = self.version!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Version") && dict["Version"] != nil {
            self.version = dict["Version"] as! String
        }
    }
}

public class GetAuthorizationLetterVersionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAuthorizationLetterVersionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetAuthorizationLetterVersionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDefaultPrincipalResponseBody : Tea.TeaModel {
    public var principalDescription: String?

    public var principalName: String?

    public var principalValue: Int32?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.principalDescription != nil {
            map["PrincipalDescription"] = self.principalDescription!
        }
        if self.principalName != nil {
            map["PrincipalName"] = self.principalName!
        }
        if self.principalValue != nil {
            map["PrincipalValue"] = self.principalValue!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PrincipalDescription") && dict["PrincipalDescription"] != nil {
            self.principalDescription = dict["PrincipalDescription"] as! String
        }
        if dict.keys.contains("PrincipalName") && dict["PrincipalName"] != nil {
            self.principalName = dict["PrincipalName"] as! String
        }
        if dict.keys.contains("PrincipalValue") && dict["PrincipalValue"] != nil {
            self.principalValue = dict["PrincipalValue"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetDefaultPrincipalResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDefaultPrincipalResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetDefaultPrincipalResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDefaultPrincipalNameRequest : Tea.TeaModel {
    public var bizType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizType != nil {
            map["BizType"] = self.bizType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizType") && dict["BizType"] != nil {
            self.bizType = dict["BizType"] as! String
        }
    }
}

public class GetDefaultPrincipalNameResponseBody : Tea.TeaModel {
    public var principalName: Int32?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.principalName != nil {
            map["PrincipalName"] = self.principalName!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PrincipalName") && dict["PrincipalName"] != nil {
            self.principalName = dict["PrincipalName"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetDefaultPrincipalNameResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDefaultPrincipalNameResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetDefaultPrincipalNameResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetNotaryOrderRequest : Tea.TeaModel {
    public var notaryOrderId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.notaryOrderId != nil {
            map["NotaryOrderId"] = self.notaryOrderId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NotaryOrderId") && dict["NotaryOrderId"] != nil {
            self.notaryOrderId = dict["NotaryOrderId"] as! Int64
        }
    }
}

public class GetNotaryOrderResponseBody : Tea.TeaModel {
    public var aliyunOrderId: String?

    public var applyPostStatus: Int32?

    public var bizId: String?

    public var businessLicense: String?

    public var businessLicenseId: String?

    public var companyContactName: String?

    public var companyContactPhone: String?

    public var errorCode: String?

    public var errorMsg: String?

    public var legalPersonIdCard: String?

    public var legalPersonName: String?

    public var legalPersonPhone: String?

    public var name: String?

    public var notaryAcceptDate: Int64?

    public var notaryCertificate: String?

    public var notaryFailedDate: Int64?

    public var notaryFailedReason: String?

    public var notaryOrderId: Int64?

    public var notaryPlatformName: String?

    public var notaryPostReceipt: String?

    public var notaryStatus: Int32?

    public var notarySucceedDate: Int64?

    public var notaryType: Int32?

    public var orderDate: Int64?

    public var orderPrice: Double?

    public var phone: String?

    public var receiverAddress: String?

    public var receiverName: String?

    public var receiverPhone: String?

    public var receiverPostalCode: String?

    public var requestId: String?

    public var sellerBackOfIdCard: String?

    public var sellerCompanyName: String?

    public var sellerFrontOfIdCard: String?

    public var success: Bool?

    public var tmAcceptCertificate: String?

    public var tmClassification: String?

    public var tmImage: String?

    public var tmName: String?

    public var tmRegisterCertificate: String?

    public var tmRegisterChangeCertificate: String?

    public var tmRegisterNo: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliyunOrderId != nil {
            map["AliyunOrderId"] = self.aliyunOrderId!
        }
        if self.applyPostStatus != nil {
            map["ApplyPostStatus"] = self.applyPostStatus!
        }
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.businessLicense != nil {
            map["BusinessLicense"] = self.businessLicense!
        }
        if self.businessLicenseId != nil {
            map["BusinessLicenseId"] = self.businessLicenseId!
        }
        if self.companyContactName != nil {
            map["CompanyContactName"] = self.companyContactName!
        }
        if self.companyContactPhone != nil {
            map["CompanyContactPhone"] = self.companyContactPhone!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["ErrorMsg"] = self.errorMsg!
        }
        if self.legalPersonIdCard != nil {
            map["LegalPersonIdCard"] = self.legalPersonIdCard!
        }
        if self.legalPersonName != nil {
            map["LegalPersonName"] = self.legalPersonName!
        }
        if self.legalPersonPhone != nil {
            map["LegalPersonPhone"] = self.legalPersonPhone!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.notaryAcceptDate != nil {
            map["NotaryAcceptDate"] = self.notaryAcceptDate!
        }
        if self.notaryCertificate != nil {
            map["NotaryCertificate"] = self.notaryCertificate!
        }
        if self.notaryFailedDate != nil {
            map["NotaryFailedDate"] = self.notaryFailedDate!
        }
        if self.notaryFailedReason != nil {
            map["NotaryFailedReason"] = self.notaryFailedReason!
        }
        if self.notaryOrderId != nil {
            map["NotaryOrderId"] = self.notaryOrderId!
        }
        if self.notaryPlatformName != nil {
            map["NotaryPlatformName"] = self.notaryPlatformName!
        }
        if self.notaryPostReceipt != nil {
            map["NotaryPostReceipt"] = self.notaryPostReceipt!
        }
        if self.notaryStatus != nil {
            map["NotaryStatus"] = self.notaryStatus!
        }
        if self.notarySucceedDate != nil {
            map["NotarySucceedDate"] = self.notarySucceedDate!
        }
        if self.notaryType != nil {
            map["NotaryType"] = self.notaryType!
        }
        if self.orderDate != nil {
            map["OrderDate"] = self.orderDate!
        }
        if self.orderPrice != nil {
            map["OrderPrice"] = self.orderPrice!
        }
        if self.phone != nil {
            map["Phone"] = self.phone!
        }
        if self.receiverAddress != nil {
            map["ReceiverAddress"] = self.receiverAddress!
        }
        if self.receiverName != nil {
            map["ReceiverName"] = self.receiverName!
        }
        if self.receiverPhone != nil {
            map["ReceiverPhone"] = self.receiverPhone!
        }
        if self.receiverPostalCode != nil {
            map["ReceiverPostalCode"] = self.receiverPostalCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sellerBackOfIdCard != nil {
            map["SellerBackOfIdCard"] = self.sellerBackOfIdCard!
        }
        if self.sellerCompanyName != nil {
            map["SellerCompanyName"] = self.sellerCompanyName!
        }
        if self.sellerFrontOfIdCard != nil {
            map["SellerFrontOfIdCard"] = self.sellerFrontOfIdCard!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.tmAcceptCertificate != nil {
            map["TmAcceptCertificate"] = self.tmAcceptCertificate!
        }
        if self.tmClassification != nil {
            map["TmClassification"] = self.tmClassification!
        }
        if self.tmImage != nil {
            map["TmImage"] = self.tmImage!
        }
        if self.tmName != nil {
            map["TmName"] = self.tmName!
        }
        if self.tmRegisterCertificate != nil {
            map["TmRegisterCertificate"] = self.tmRegisterCertificate!
        }
        if self.tmRegisterChangeCertificate != nil {
            map["TmRegisterChangeCertificate"] = self.tmRegisterChangeCertificate!
        }
        if self.tmRegisterNo != nil {
            map["TmRegisterNo"] = self.tmRegisterNo!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AliyunOrderId") && dict["AliyunOrderId"] != nil {
            self.aliyunOrderId = dict["AliyunOrderId"] as! String
        }
        if dict.keys.contains("ApplyPostStatus") && dict["ApplyPostStatus"] != nil {
            self.applyPostStatus = dict["ApplyPostStatus"] as! Int32
        }
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("BusinessLicense") && dict["BusinessLicense"] != nil {
            self.businessLicense = dict["BusinessLicense"] as! String
        }
        if dict.keys.contains("BusinessLicenseId") && dict["BusinessLicenseId"] != nil {
            self.businessLicenseId = dict["BusinessLicenseId"] as! String
        }
        if dict.keys.contains("CompanyContactName") && dict["CompanyContactName"] != nil {
            self.companyContactName = dict["CompanyContactName"] as! String
        }
        if dict.keys.contains("CompanyContactPhone") && dict["CompanyContactPhone"] != nil {
            self.companyContactPhone = dict["CompanyContactPhone"] as! String
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMsg") && dict["ErrorMsg"] != nil {
            self.errorMsg = dict["ErrorMsg"] as! String
        }
        if dict.keys.contains("LegalPersonIdCard") && dict["LegalPersonIdCard"] != nil {
            self.legalPersonIdCard = dict["LegalPersonIdCard"] as! String
        }
        if dict.keys.contains("LegalPersonName") && dict["LegalPersonName"] != nil {
            self.legalPersonName = dict["LegalPersonName"] as! String
        }
        if dict.keys.contains("LegalPersonPhone") && dict["LegalPersonPhone"] != nil {
            self.legalPersonPhone = dict["LegalPersonPhone"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("NotaryAcceptDate") && dict["NotaryAcceptDate"] != nil {
            self.notaryAcceptDate = dict["NotaryAcceptDate"] as! Int64
        }
        if dict.keys.contains("NotaryCertificate") && dict["NotaryCertificate"] != nil {
            self.notaryCertificate = dict["NotaryCertificate"] as! String
        }
        if dict.keys.contains("NotaryFailedDate") && dict["NotaryFailedDate"] != nil {
            self.notaryFailedDate = dict["NotaryFailedDate"] as! Int64
        }
        if dict.keys.contains("NotaryFailedReason") && dict["NotaryFailedReason"] != nil {
            self.notaryFailedReason = dict["NotaryFailedReason"] as! String
        }
        if dict.keys.contains("NotaryOrderId") && dict["NotaryOrderId"] != nil {
            self.notaryOrderId = dict["NotaryOrderId"] as! Int64
        }
        if dict.keys.contains("NotaryPlatformName") && dict["NotaryPlatformName"] != nil {
            self.notaryPlatformName = dict["NotaryPlatformName"] as! String
        }
        if dict.keys.contains("NotaryPostReceipt") && dict["NotaryPostReceipt"] != nil {
            self.notaryPostReceipt = dict["NotaryPostReceipt"] as! String
        }
        if dict.keys.contains("NotaryStatus") && dict["NotaryStatus"] != nil {
            self.notaryStatus = dict["NotaryStatus"] as! Int32
        }
        if dict.keys.contains("NotarySucceedDate") && dict["NotarySucceedDate"] != nil {
            self.notarySucceedDate = dict["NotarySucceedDate"] as! Int64
        }
        if dict.keys.contains("NotaryType") && dict["NotaryType"] != nil {
            self.notaryType = dict["NotaryType"] as! Int32
        }
        if dict.keys.contains("OrderDate") && dict["OrderDate"] != nil {
            self.orderDate = dict["OrderDate"] as! Int64
        }
        if dict.keys.contains("OrderPrice") && dict["OrderPrice"] != nil {
            self.orderPrice = dict["OrderPrice"] as! Double
        }
        if dict.keys.contains("Phone") && dict["Phone"] != nil {
            self.phone = dict["Phone"] as! String
        }
        if dict.keys.contains("ReceiverAddress") && dict["ReceiverAddress"] != nil {
            self.receiverAddress = dict["ReceiverAddress"] as! String
        }
        if dict.keys.contains("ReceiverName") && dict["ReceiverName"] != nil {
            self.receiverName = dict["ReceiverName"] as! String
        }
        if dict.keys.contains("ReceiverPhone") && dict["ReceiverPhone"] != nil {
            self.receiverPhone = dict["ReceiverPhone"] as! String
        }
        if dict.keys.contains("ReceiverPostalCode") && dict["ReceiverPostalCode"] != nil {
            self.receiverPostalCode = dict["ReceiverPostalCode"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SellerBackOfIdCard") && dict["SellerBackOfIdCard"] != nil {
            self.sellerBackOfIdCard = dict["SellerBackOfIdCard"] as! String
        }
        if dict.keys.contains("SellerCompanyName") && dict["SellerCompanyName"] != nil {
            self.sellerCompanyName = dict["SellerCompanyName"] as! String
        }
        if dict.keys.contains("SellerFrontOfIdCard") && dict["SellerFrontOfIdCard"] != nil {
            self.sellerFrontOfIdCard = dict["SellerFrontOfIdCard"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TmAcceptCertificate") && dict["TmAcceptCertificate"] != nil {
            self.tmAcceptCertificate = dict["TmAcceptCertificate"] as! String
        }
        if dict.keys.contains("TmClassification") && dict["TmClassification"] != nil {
            self.tmClassification = dict["TmClassification"] as! String
        }
        if dict.keys.contains("TmImage") && dict["TmImage"] != nil {
            self.tmImage = dict["TmImage"] as! String
        }
        if dict.keys.contains("TmName") && dict["TmName"] != nil {
            self.tmName = dict["TmName"] as! String
        }
        if dict.keys.contains("TmRegisterCertificate") && dict["TmRegisterCertificate"] != nil {
            self.tmRegisterCertificate = dict["TmRegisterCertificate"] as! String
        }
        if dict.keys.contains("TmRegisterChangeCertificate") && dict["TmRegisterChangeCertificate"] != nil {
            self.tmRegisterChangeCertificate = dict["TmRegisterChangeCertificate"] as! String
        }
        if dict.keys.contains("TmRegisterNo") && dict["TmRegisterNo"] != nil {
            self.tmRegisterNo = dict["TmRegisterNo"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class GetNotaryOrderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetNotaryOrderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetNotaryOrderResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetSupportPrincipalNameResponseBody : Tea.TeaModel {
    public class Principals : Tea.TeaModel {
        public var defaultPrincipal: Bool?

        public var principalDescription: String?

        public var principalValue: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.defaultPrincipal != nil {
                map["DefaultPrincipal"] = self.defaultPrincipal!
            }
            if self.principalDescription != nil {
                map["PrincipalDescription"] = self.principalDescription!
            }
            if self.principalValue != nil {
                map["PrincipalValue"] = self.principalValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DefaultPrincipal") && dict["DefaultPrincipal"] != nil {
                self.defaultPrincipal = dict["DefaultPrincipal"] as! Bool
            }
            if dict.keys.contains("PrincipalDescription") && dict["PrincipalDescription"] != nil {
                self.principalDescription = dict["PrincipalDescription"] as! String
            }
            if dict.keys.contains("PrincipalValue") && dict["PrincipalValue"] != nil {
                self.principalValue = dict["PrincipalValue"] as! Int32
            }
        }
    }
    public var principals: [GetSupportPrincipalNameResponseBody.Principals]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.principals != nil {
            var tmp : [Any] = []
            for k in self.principals! {
                tmp.append(k.toMap())
            }
            map["Principals"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Principals") && dict["Principals"] != nil {
            var tmp : [GetSupportPrincipalNameResponseBody.Principals] = []
            for v in dict["Principals"] as! [Any] {
                var model = GetSupportPrincipalNameResponseBody.Principals()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.principals = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetSupportPrincipalNameResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetSupportPrincipalNameResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetSupportPrincipalNameResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class InsertMaterialRequest : Tea.TeaModel {
    public var address: String?

    public var businessLicenceOssKey: String?

    public var cardNumber: String?

    public var city: String?

    public var contactAddress: String?

    public var contactCity: String?

    public var contactCounty: String?

    public var contactDistrict: String?

    public var contactEmail: String?

    public var contactName: String?

    public var contactNumber: String?

    public var contactProvince: String?

    public var contactZipcode: String?

    public var country: String?

    public var EAddress: String?

    public var EName: String?

    public var idCardName: String?

    public var idCardNumber: String?

    public var idCardOssKey: String?

    public var legalNoticeOssKey: String?

    public var loaOssKey: String?

    public var name: String?

    public var passportOssKey: String?

    public var personalType: Int64?

    public var principalName: Int32?

    public var province: String?

    public var region: Int32?

    public var town: String?

    public var type: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.address != nil {
            map["Address"] = self.address!
        }
        if self.businessLicenceOssKey != nil {
            map["BusinessLicenceOssKey"] = self.businessLicenceOssKey!
        }
        if self.cardNumber != nil {
            map["CardNumber"] = self.cardNumber!
        }
        if self.city != nil {
            map["City"] = self.city!
        }
        if self.contactAddress != nil {
            map["ContactAddress"] = self.contactAddress!
        }
        if self.contactCity != nil {
            map["ContactCity"] = self.contactCity!
        }
        if self.contactCounty != nil {
            map["ContactCounty"] = self.contactCounty!
        }
        if self.contactDistrict != nil {
            map["ContactDistrict"] = self.contactDistrict!
        }
        if self.contactEmail != nil {
            map["ContactEmail"] = self.contactEmail!
        }
        if self.contactName != nil {
            map["ContactName"] = self.contactName!
        }
        if self.contactNumber != nil {
            map["ContactNumber"] = self.contactNumber!
        }
        if self.contactProvince != nil {
            map["ContactProvince"] = self.contactProvince!
        }
        if self.contactZipcode != nil {
            map["ContactZipcode"] = self.contactZipcode!
        }
        if self.country != nil {
            map["Country"] = self.country!
        }
        if self.EAddress != nil {
            map["EAddress"] = self.EAddress!
        }
        if self.EName != nil {
            map["EName"] = self.EName!
        }
        if self.idCardName != nil {
            map["IdCardName"] = self.idCardName!
        }
        if self.idCardNumber != nil {
            map["IdCardNumber"] = self.idCardNumber!
        }
        if self.idCardOssKey != nil {
            map["IdCardOssKey"] = self.idCardOssKey!
        }
        if self.legalNoticeOssKey != nil {
            map["LegalNoticeOssKey"] = self.legalNoticeOssKey!
        }
        if self.loaOssKey != nil {
            map["LoaOssKey"] = self.loaOssKey!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.passportOssKey != nil {
            map["PassportOssKey"] = self.passportOssKey!
        }
        if self.personalType != nil {
            map["PersonalType"] = self.personalType!
        }
        if self.principalName != nil {
            map["PrincipalName"] = self.principalName!
        }
        if self.province != nil {
            map["Province"] = self.province!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.town != nil {
            map["Town"] = self.town!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Address") && dict["Address"] != nil {
            self.address = dict["Address"] as! String
        }
        if dict.keys.contains("BusinessLicenceOssKey") && dict["BusinessLicenceOssKey"] != nil {
            self.businessLicenceOssKey = dict["BusinessLicenceOssKey"] as! String
        }
        if dict.keys.contains("CardNumber") && dict["CardNumber"] != nil {
            self.cardNumber = dict["CardNumber"] as! String
        }
        if dict.keys.contains("City") && dict["City"] != nil {
            self.city = dict["City"] as! String
        }
        if dict.keys.contains("ContactAddress") && dict["ContactAddress"] != nil {
            self.contactAddress = dict["ContactAddress"] as! String
        }
        if dict.keys.contains("ContactCity") && dict["ContactCity"] != nil {
            self.contactCity = dict["ContactCity"] as! String
        }
        if dict.keys.contains("ContactCounty") && dict["ContactCounty"] != nil {
            self.contactCounty = dict["ContactCounty"] as! String
        }
        if dict.keys.contains("ContactDistrict") && dict["ContactDistrict"] != nil {
            self.contactDistrict = dict["ContactDistrict"] as! String
        }
        if dict.keys.contains("ContactEmail") && dict["ContactEmail"] != nil {
            self.contactEmail = dict["ContactEmail"] as! String
        }
        if dict.keys.contains("ContactName") && dict["ContactName"] != nil {
            self.contactName = dict["ContactName"] as! String
        }
        if dict.keys.contains("ContactNumber") && dict["ContactNumber"] != nil {
            self.contactNumber = dict["ContactNumber"] as! String
        }
        if dict.keys.contains("ContactProvince") && dict["ContactProvince"] != nil {
            self.contactProvince = dict["ContactProvince"] as! String
        }
        if dict.keys.contains("ContactZipcode") && dict["ContactZipcode"] != nil {
            self.contactZipcode = dict["ContactZipcode"] as! String
        }
        if dict.keys.contains("Country") && dict["Country"] != nil {
            self.country = dict["Country"] as! String
        }
        if dict.keys.contains("EAddress") && dict["EAddress"] != nil {
            self.EAddress = dict["EAddress"] as! String
        }
        if dict.keys.contains("EName") && dict["EName"] != nil {
            self.EName = dict["EName"] as! String
        }
        if dict.keys.contains("IdCardName") && dict["IdCardName"] != nil {
            self.idCardName = dict["IdCardName"] as! String
        }
        if dict.keys.contains("IdCardNumber") && dict["IdCardNumber"] != nil {
            self.idCardNumber = dict["IdCardNumber"] as! String
        }
        if dict.keys.contains("IdCardOssKey") && dict["IdCardOssKey"] != nil {
            self.idCardOssKey = dict["IdCardOssKey"] as! String
        }
        if dict.keys.contains("LegalNoticeOssKey") && dict["LegalNoticeOssKey"] != nil {
            self.legalNoticeOssKey = dict["LegalNoticeOssKey"] as! String
        }
        if dict.keys.contains("LoaOssKey") && dict["LoaOssKey"] != nil {
            self.loaOssKey = dict["LoaOssKey"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PassportOssKey") && dict["PassportOssKey"] != nil {
            self.passportOssKey = dict["PassportOssKey"] as! String
        }
        if dict.keys.contains("PersonalType") && dict["PersonalType"] != nil {
            self.personalType = dict["PersonalType"] as! Int64
        }
        if dict.keys.contains("PrincipalName") && dict["PrincipalName"] != nil {
            self.principalName = dict["PrincipalName"] as! Int32
        }
        if dict.keys.contains("Province") && dict["Province"] != nil {
            self.province = dict["Province"] as! String
        }
        if dict.keys.contains("Region") && dict["Region"] != nil {
            self.region = dict["Region"] as! Int32
        }
        if dict.keys.contains("Town") && dict["Town"] != nil {
            self.town = dict["Town"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! Int32
        }
    }
}

public class InsertMaterialResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class InsertMaterialResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InsertMaterialResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = InsertMaterialResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class InsertRenewInfoRequest : Tea.TeaModel {
    public var address: String?

    public var engAddress: String?

    public var engName: String?

    public var name: String?

    public var registerTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.address != nil {
            map["Address"] = self.address!
        }
        if self.engAddress != nil {
            map["EngAddress"] = self.engAddress!
        }
        if self.engName != nil {
            map["EngName"] = self.engName!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.registerTime != nil {
            map["RegisterTime"] = self.registerTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Address") && dict["Address"] != nil {
            self.address = dict["Address"] as! String
        }
        if dict.keys.contains("EngAddress") && dict["EngAddress"] != nil {
            self.engAddress = dict["EngAddress"] as! String
        }
        if dict.keys.contains("EngName") && dict["EngName"] != nil {
            self.engName = dict["EngName"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RegisterTime") && dict["RegisterTime"] != nil {
            self.registerTime = dict["RegisterTime"] as! Int64
        }
    }
}

public class InsertRenewInfoResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMsg: String?

    public var id: Int64?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["ErrorMsg"] = self.errorMsg!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMsg") && dict["ErrorMsg"] != nil {
            self.errorMsg = dict["ErrorMsg"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class InsertRenewInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InsertRenewInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = InsertRenewInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class InsertTmMonitorRuleRequest : Tea.TeaModel {
    public var classification: [String: Any]?

    public var endApplyDate: String?

    public var notifyStatus: [String: Any]?

    public var ruleKeyword: String?

    public var ruleName: String?

    public var ruleSource: String?

    public var ruleType: Int32?

    public var startApplyDate: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.classification != nil {
            map["Classification"] = self.classification!
        }
        if self.endApplyDate != nil {
            map["EndApplyDate"] = self.endApplyDate!
        }
        if self.notifyStatus != nil {
            map["NotifyStatus"] = self.notifyStatus!
        }
        if self.ruleKeyword != nil {
            map["RuleKeyword"] = self.ruleKeyword!
        }
        if self.ruleName != nil {
            map["RuleName"] = self.ruleName!
        }
        if self.ruleSource != nil {
            map["RuleSource"] = self.ruleSource!
        }
        if self.ruleType != nil {
            map["RuleType"] = self.ruleType!
        }
        if self.startApplyDate != nil {
            map["StartApplyDate"] = self.startApplyDate!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Classification") && dict["Classification"] != nil {
            self.classification = dict["Classification"] as! [String: Any]
        }
        if dict.keys.contains("EndApplyDate") && dict["EndApplyDate"] != nil {
            self.endApplyDate = dict["EndApplyDate"] as! String
        }
        if dict.keys.contains("NotifyStatus") && dict["NotifyStatus"] != nil {
            self.notifyStatus = dict["NotifyStatus"] as! [String: Any]
        }
        if dict.keys.contains("RuleKeyword") && dict["RuleKeyword"] != nil {
            self.ruleKeyword = dict["RuleKeyword"] as! String
        }
        if dict.keys.contains("RuleName") && dict["RuleName"] != nil {
            self.ruleName = dict["RuleName"] as! String
        }
        if dict.keys.contains("RuleSource") && dict["RuleSource"] != nil {
            self.ruleSource = dict["RuleSource"] as! String
        }
        if dict.keys.contains("RuleType") && dict["RuleType"] != nil {
            self.ruleType = dict["RuleType"] as! Int32
        }
        if dict.keys.contains("StartApplyDate") && dict["StartApplyDate"] != nil {
            self.startApplyDate = dict["StartApplyDate"] as! String
        }
    }
}

public class InsertTmMonitorRuleShrinkRequest : Tea.TeaModel {
    public var classificationShrink: String?

    public var endApplyDate: String?

    public var notifyStatusShrink: String?

    public var ruleKeyword: String?

    public var ruleName: String?

    public var ruleSource: String?

    public var ruleType: Int32?

    public var startApplyDate: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.classificationShrink != nil {
            map["Classification"] = self.classificationShrink!
        }
        if self.endApplyDate != nil {
            map["EndApplyDate"] = self.endApplyDate!
        }
        if self.notifyStatusShrink != nil {
            map["NotifyStatus"] = self.notifyStatusShrink!
        }
        if self.ruleKeyword != nil {
            map["RuleKeyword"] = self.ruleKeyword!
        }
        if self.ruleName != nil {
            map["RuleName"] = self.ruleName!
        }
        if self.ruleSource != nil {
            map["RuleSource"] = self.ruleSource!
        }
        if self.ruleType != nil {
            map["RuleType"] = self.ruleType!
        }
        if self.startApplyDate != nil {
            map["StartApplyDate"] = self.startApplyDate!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Classification") && dict["Classification"] != nil {
            self.classificationShrink = dict["Classification"] as! String
        }
        if dict.keys.contains("EndApplyDate") && dict["EndApplyDate"] != nil {
            self.endApplyDate = dict["EndApplyDate"] as! String
        }
        if dict.keys.contains("NotifyStatus") && dict["NotifyStatus"] != nil {
            self.notifyStatusShrink = dict["NotifyStatus"] as! String
        }
        if dict.keys.contains("RuleKeyword") && dict["RuleKeyword"] != nil {
            self.ruleKeyword = dict["RuleKeyword"] as! String
        }
        if dict.keys.contains("RuleName") && dict["RuleName"] != nil {
            self.ruleName = dict["RuleName"] as! String
        }
        if dict.keys.contains("RuleSource") && dict["RuleSource"] != nil {
            self.ruleSource = dict["RuleSource"] as! String
        }
        if dict.keys.contains("RuleType") && dict["RuleType"] != nil {
            self.ruleType = dict["RuleType"] as! Int32
        }
        if dict.keys.contains("StartApplyDate") && dict["StartApplyDate"] != nil {
            self.startApplyDate = dict["StartApplyDate"] as! String
        }
    }
}

public class InsertTmMonitorRuleResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMsg: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["ErrorMsg"] = self.errorMsg!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMsg") && dict["ErrorMsg"] != nil {
            self.errorMsg = dict["ErrorMsg"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class InsertTmMonitorRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InsertTmMonitorRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = InsertTmMonitorRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListNotaryInfosRequest : Tea.TeaModel {
    public var bizOrderNo: String?

    public var notaryType: Int32?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var token: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizOrderNo != nil {
            map["BizOrderNo"] = self.bizOrderNo!
        }
        if self.notaryType != nil {
            map["NotaryType"] = self.notaryType!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.token != nil {
            map["Token"] = self.token!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizOrderNo") && dict["BizOrderNo"] != nil {
            self.bizOrderNo = dict["BizOrderNo"] as! String
        }
        if dict.keys.contains("NotaryType") && dict["NotaryType"] != nil {
            self.notaryType = dict["NotaryType"] as! Int32
        }
        if dict.keys.contains("PageNum") && dict["PageNum"] != nil {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Token") && dict["Token"] != nil {
            self.token = dict["Token"] as! String
        }
    }
}

public class ListNotaryInfosResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class NotaryInfo : Tea.TeaModel {
            public var bizOrderNo: String?

            public var gmtModified: Int64?

            public var notaryFailedReason: String?

            public var notaryStatus: Int32?

            public var tmClassification: String?

            public var tmRegisterNo: String?

            public var token: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bizOrderNo != nil {
                    map["BizOrderNo"] = self.bizOrderNo!
                }
                if self.gmtModified != nil {
                    map["GmtModified"] = self.gmtModified!
                }
                if self.notaryFailedReason != nil {
                    map["NotaryFailedReason"] = self.notaryFailedReason!
                }
                if self.notaryStatus != nil {
                    map["NotaryStatus"] = self.notaryStatus!
                }
                if self.tmClassification != nil {
                    map["TmClassification"] = self.tmClassification!
                }
                if self.tmRegisterNo != nil {
                    map["TmRegisterNo"] = self.tmRegisterNo!
                }
                if self.token != nil {
                    map["Token"] = self.token!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BizOrderNo") && dict["BizOrderNo"] != nil {
                    self.bizOrderNo = dict["BizOrderNo"] as! String
                }
                if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
                    self.gmtModified = dict["GmtModified"] as! Int64
                }
                if dict.keys.contains("NotaryFailedReason") && dict["NotaryFailedReason"] != nil {
                    self.notaryFailedReason = dict["NotaryFailedReason"] as! String
                }
                if dict.keys.contains("NotaryStatus") && dict["NotaryStatus"] != nil {
                    self.notaryStatus = dict["NotaryStatus"] as! Int32
                }
                if dict.keys.contains("TmClassification") && dict["TmClassification"] != nil {
                    self.tmClassification = dict["TmClassification"] as! String
                }
                if dict.keys.contains("TmRegisterNo") && dict["TmRegisterNo"] != nil {
                    self.tmRegisterNo = dict["TmRegisterNo"] as! String
                }
                if dict.keys.contains("Token") && dict["Token"] != nil {
                    self.token = dict["Token"] as! String
                }
            }
        }
        public var notaryInfo: [ListNotaryInfosResponseBody.Data.NotaryInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.notaryInfo != nil {
                var tmp : [Any] = []
                for k in self.notaryInfo! {
                    tmp.append(k.toMap())
                }
                map["NotaryInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("NotaryInfo") && dict["NotaryInfo"] != nil {
                var tmp : [ListNotaryInfosResponseBody.Data.NotaryInfo] = []
                for v in dict["NotaryInfo"] as! [Any] {
                    var model = ListNotaryInfosResponseBody.Data.NotaryInfo()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.notaryInfo = tmp
            }
        }
    }
    public var currentPageNum: Int32?

    public var data: ListNotaryInfosResponseBody.Data?

    public var errorCode: String?

    public var errorMsg: String?

    public var nextPage: Bool?

    public var pageSize: Int32?

    public var prePage: Bool?

    public var requestId: String?

    public var success: Bool?

    public var totalItemNum: Int32?

    public var totalPageNum: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPageNum != nil {
            map["CurrentPageNum"] = self.currentPageNum!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["ErrorMsg"] = self.errorMsg!
        }
        if self.nextPage != nil {
            map["NextPage"] = self.nextPage!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.prePage != nil {
            map["PrePage"] = self.prePage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalItemNum != nil {
            map["TotalItemNum"] = self.totalItemNum!
        }
        if self.totalPageNum != nil {
            map["TotalPageNum"] = self.totalPageNum!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPageNum") && dict["CurrentPageNum"] != nil {
            self.currentPageNum = dict["CurrentPageNum"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = ListNotaryInfosResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMsg") && dict["ErrorMsg"] != nil {
            self.errorMsg = dict["ErrorMsg"] as! String
        }
        if dict.keys.contains("NextPage") && dict["NextPage"] != nil {
            self.nextPage = dict["NextPage"] as! Bool
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("PrePage") && dict["PrePage"] != nil {
            self.prePage = dict["PrePage"] as! Bool
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalItemNum") && dict["TotalItemNum"] != nil {
            self.totalItemNum = dict["TotalItemNum"] as! Int32
        }
        if dict.keys.contains("TotalPageNum") && dict["TotalPageNum"] != nil {
            self.totalPageNum = dict["TotalPageNum"] as! Int32
        }
    }
}

public class ListNotaryInfosResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListNotaryInfosResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListNotaryInfosResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListNotaryOrdersRequest : Tea.TeaModel {
    public var aliyunOrderId: String?

    public var bizId: String?

    public var endOrderDate: Int64?

    public var notaryStatus: Int32?

    public var notaryType: Int32?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var sortByType: String?

    public var sortKeyType: Int32?

    public var startOrderDate: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliyunOrderId != nil {
            map["AliyunOrderId"] = self.aliyunOrderId!
        }
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.endOrderDate != nil {
            map["EndOrderDate"] = self.endOrderDate!
        }
        if self.notaryStatus != nil {
            map["NotaryStatus"] = self.notaryStatus!
        }
        if self.notaryType != nil {
            map["NotaryType"] = self.notaryType!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sortByType != nil {
            map["SortByType"] = self.sortByType!
        }
        if self.sortKeyType != nil {
            map["SortKeyType"] = self.sortKeyType!
        }
        if self.startOrderDate != nil {
            map["StartOrderDate"] = self.startOrderDate!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AliyunOrderId") && dict["AliyunOrderId"] != nil {
            self.aliyunOrderId = dict["AliyunOrderId"] as! String
        }
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("EndOrderDate") && dict["EndOrderDate"] != nil {
            self.endOrderDate = dict["EndOrderDate"] as! Int64
        }
        if dict.keys.contains("NotaryStatus") && dict["NotaryStatus"] != nil {
            self.notaryStatus = dict["NotaryStatus"] as! Int32
        }
        if dict.keys.contains("NotaryType") && dict["NotaryType"] != nil {
            self.notaryType = dict["NotaryType"] as! Int32
        }
        if dict.keys.contains("PageNum") && dict["PageNum"] != nil {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SortByType") && dict["SortByType"] != nil {
            self.sortByType = dict["SortByType"] as! String
        }
        if dict.keys.contains("SortKeyType") && dict["SortKeyType"] != nil {
            self.sortKeyType = dict["SortKeyType"] as! Int32
        }
        if dict.keys.contains("StartOrderDate") && dict["StartOrderDate"] != nil {
            self.startOrderDate = dict["StartOrderDate"] as! Int64
        }
    }
}

public class ListNotaryOrdersResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class NotaryOrder : Tea.TeaModel {
            public var aliyunOrderId: String?

            public var applyPostStatus: String?

            public var bizId: String?

            public var gmtModified: Int64?

            public var notaryCertificate: String?

            public var notaryOrderId: Int64?

            public var notaryPlatformName: String?

            public var notaryStatus: Int32?

            public var notaryType: Int32?

            public var orderDate: Int64?

            public var orderPrice: Double?

            public var tmClassification: String?

            public var tmImage: String?

            public var tmName: String?

            public var tmRegisterNo: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.aliyunOrderId != nil {
                    map["AliyunOrderId"] = self.aliyunOrderId!
                }
                if self.applyPostStatus != nil {
                    map["ApplyPostStatus"] = self.applyPostStatus!
                }
                if self.bizId != nil {
                    map["BizId"] = self.bizId!
                }
                if self.gmtModified != nil {
                    map["GmtModified"] = self.gmtModified!
                }
                if self.notaryCertificate != nil {
                    map["NotaryCertificate"] = self.notaryCertificate!
                }
                if self.notaryOrderId != nil {
                    map["NotaryOrderId"] = self.notaryOrderId!
                }
                if self.notaryPlatformName != nil {
                    map["NotaryPlatformName"] = self.notaryPlatformName!
                }
                if self.notaryStatus != nil {
                    map["NotaryStatus"] = self.notaryStatus!
                }
                if self.notaryType != nil {
                    map["NotaryType"] = self.notaryType!
                }
                if self.orderDate != nil {
                    map["OrderDate"] = self.orderDate!
                }
                if self.orderPrice != nil {
                    map["OrderPrice"] = self.orderPrice!
                }
                if self.tmClassification != nil {
                    map["TmClassification"] = self.tmClassification!
                }
                if self.tmImage != nil {
                    map["TmImage"] = self.tmImage!
                }
                if self.tmName != nil {
                    map["TmName"] = self.tmName!
                }
                if self.tmRegisterNo != nil {
                    map["TmRegisterNo"] = self.tmRegisterNo!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AliyunOrderId") && dict["AliyunOrderId"] != nil {
                    self.aliyunOrderId = dict["AliyunOrderId"] as! String
                }
                if dict.keys.contains("ApplyPostStatus") && dict["ApplyPostStatus"] != nil {
                    self.applyPostStatus = dict["ApplyPostStatus"] as! String
                }
                if dict.keys.contains("BizId") && dict["BizId"] != nil {
                    self.bizId = dict["BizId"] as! String
                }
                if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
                    self.gmtModified = dict["GmtModified"] as! Int64
                }
                if dict.keys.contains("NotaryCertificate") && dict["NotaryCertificate"] != nil {
                    self.notaryCertificate = dict["NotaryCertificate"] as! String
                }
                if dict.keys.contains("NotaryOrderId") && dict["NotaryOrderId"] != nil {
                    self.notaryOrderId = dict["NotaryOrderId"] as! Int64
                }
                if dict.keys.contains("NotaryPlatformName") && dict["NotaryPlatformName"] != nil {
                    self.notaryPlatformName = dict["NotaryPlatformName"] as! String
                }
                if dict.keys.contains("NotaryStatus") && dict["NotaryStatus"] != nil {
                    self.notaryStatus = dict["NotaryStatus"] as! Int32
                }
                if dict.keys.contains("NotaryType") && dict["NotaryType"] != nil {
                    self.notaryType = dict["NotaryType"] as! Int32
                }
                if dict.keys.contains("OrderDate") && dict["OrderDate"] != nil {
                    self.orderDate = dict["OrderDate"] as! Int64
                }
                if dict.keys.contains("OrderPrice") && dict["OrderPrice"] != nil {
                    self.orderPrice = dict["OrderPrice"] as! Double
                }
                if dict.keys.contains("TmClassification") && dict["TmClassification"] != nil {
                    self.tmClassification = dict["TmClassification"] as! String
                }
                if dict.keys.contains("TmImage") && dict["TmImage"] != nil {
                    self.tmImage = dict["TmImage"] as! String
                }
                if dict.keys.contains("TmName") && dict["TmName"] != nil {
                    self.tmName = dict["TmName"] as! String
                }
                if dict.keys.contains("TmRegisterNo") && dict["TmRegisterNo"] != nil {
                    self.tmRegisterNo = dict["TmRegisterNo"] as! String
                }
            }
        }
        public var notaryOrder: [ListNotaryOrdersResponseBody.Data.NotaryOrder]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.notaryOrder != nil {
                var tmp : [Any] = []
                for k in self.notaryOrder! {
                    tmp.append(k.toMap())
                }
                map["NotaryOrder"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("NotaryOrder") && dict["NotaryOrder"] != nil {
                var tmp : [ListNotaryOrdersResponseBody.Data.NotaryOrder] = []
                for v in dict["NotaryOrder"] as! [Any] {
                    var model = ListNotaryOrdersResponseBody.Data.NotaryOrder()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.notaryOrder = tmp
            }
        }
    }
    public var currentPageNum: Int32?

    public var data: ListNotaryOrdersResponseBody.Data?

    public var errorCode: String?

    public var errorMsg: String?

    public var nextPage: Bool?

    public var pageSize: Int32?

    public var prePage: Bool?

    public var requestId: String?

    public var success: Bool?

    public var totalItemNum: Int32?

    public var totalPageNum: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPageNum != nil {
            map["CurrentPageNum"] = self.currentPageNum!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["ErrorMsg"] = self.errorMsg!
        }
        if self.nextPage != nil {
            map["NextPage"] = self.nextPage!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.prePage != nil {
            map["PrePage"] = self.prePage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalItemNum != nil {
            map["TotalItemNum"] = self.totalItemNum!
        }
        if self.totalPageNum != nil {
            map["TotalPageNum"] = self.totalPageNum!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPageNum") && dict["CurrentPageNum"] != nil {
            self.currentPageNum = dict["CurrentPageNum"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = ListNotaryOrdersResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMsg") && dict["ErrorMsg"] != nil {
            self.errorMsg = dict["ErrorMsg"] as! String
        }
        if dict.keys.contains("NextPage") && dict["NextPage"] != nil {
            self.nextPage = dict["NextPage"] as! Bool
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("PrePage") && dict["PrePage"] != nil {
            self.prePage = dict["PrePage"] as! Bool
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalItemNum") && dict["TotalItemNum"] != nil {
            self.totalItemNum = dict["TotalItemNum"] as! Int32
        }
        if dict.keys.contains("TotalPageNum") && dict["TotalPageNum"] != nil {
            self.totalPageNum = dict["TotalPageNum"] as! Int32
        }
    }
}

public class ListNotaryOrdersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListNotaryOrdersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListNotaryOrdersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListTrademarkSbjKeyRequest : Tea.TeaModel {
    public var principalKey: String?

    public var principalName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.principalKey != nil {
            map["PrincipalKey"] = self.principalKey!
        }
        if self.principalName != nil {
            map["PrincipalName"] = self.principalName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PrincipalKey") && dict["PrincipalKey"] != nil {
            self.principalKey = dict["PrincipalKey"] as! String
        }
        if dict.keys.contains("PrincipalName") && dict["PrincipalName"] != nil {
            self.principalName = dict["PrincipalName"] as! String
        }
    }
}

public class ListTrademarkSbjKeyResponseBody : Tea.TeaModel {
    public class TmSbjKeyInfo : Tea.TeaModel {
        public var agentId: String?

        public var agreeProt: String?

        public var certInfo: String?

        public var clearData: String?

        public var hashData: String?

        public var keyType: Int32?

        public var name: String?

        public var pin: String?

        public var principalKey: String?

        public var principalName: String?

        public var signCert: String?

        public var signData: String?

        public var startValidDate: String?

        public var submitSignData: String?

        public var typeCert: String?

        public var username: String?

        public var validDate: String?

        public var tmurl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.agentId != nil {
                map["AgentId"] = self.agentId!
            }
            if self.agreeProt != nil {
                map["AgreeProt"] = self.agreeProt!
            }
            if self.certInfo != nil {
                map["CertInfo"] = self.certInfo!
            }
            if self.clearData != nil {
                map["ClearData"] = self.clearData!
            }
            if self.hashData != nil {
                map["HashData"] = self.hashData!
            }
            if self.keyType != nil {
                map["KeyType"] = self.keyType!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.pin != nil {
                map["Pin"] = self.pin!
            }
            if self.principalKey != nil {
                map["PrincipalKey"] = self.principalKey!
            }
            if self.principalName != nil {
                map["PrincipalName"] = self.principalName!
            }
            if self.signCert != nil {
                map["SignCert"] = self.signCert!
            }
            if self.signData != nil {
                map["SignData"] = self.signData!
            }
            if self.startValidDate != nil {
                map["StartValidDate"] = self.startValidDate!
            }
            if self.submitSignData != nil {
                map["SubmitSignData"] = self.submitSignData!
            }
            if self.typeCert != nil {
                map["TypeCert"] = self.typeCert!
            }
            if self.username != nil {
                map["Username"] = self.username!
            }
            if self.validDate != nil {
                map["ValidDate"] = self.validDate!
            }
            if self.tmurl != nil {
                map["tmurl"] = self.tmurl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AgentId") && dict["AgentId"] != nil {
                self.agentId = dict["AgentId"] as! String
            }
            if dict.keys.contains("AgreeProt") && dict["AgreeProt"] != nil {
                self.agreeProt = dict["AgreeProt"] as! String
            }
            if dict.keys.contains("CertInfo") && dict["CertInfo"] != nil {
                self.certInfo = dict["CertInfo"] as! String
            }
            if dict.keys.contains("ClearData") && dict["ClearData"] != nil {
                self.clearData = dict["ClearData"] as! String
            }
            if dict.keys.contains("HashData") && dict["HashData"] != nil {
                self.hashData = dict["HashData"] as! String
            }
            if dict.keys.contains("KeyType") && dict["KeyType"] != nil {
                self.keyType = dict["KeyType"] as! Int32
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Pin") && dict["Pin"] != nil {
                self.pin = dict["Pin"] as! String
            }
            if dict.keys.contains("PrincipalKey") && dict["PrincipalKey"] != nil {
                self.principalKey = dict["PrincipalKey"] as! String
            }
            if dict.keys.contains("PrincipalName") && dict["PrincipalName"] != nil {
                self.principalName = dict["PrincipalName"] as! String
            }
            if dict.keys.contains("SignCert") && dict["SignCert"] != nil {
                self.signCert = dict["SignCert"] as! String
            }
            if dict.keys.contains("SignData") && dict["SignData"] != nil {
                self.signData = dict["SignData"] as! String
            }
            if dict.keys.contains("StartValidDate") && dict["StartValidDate"] != nil {
                self.startValidDate = dict["StartValidDate"] as! String
            }
            if dict.keys.contains("SubmitSignData") && dict["SubmitSignData"] != nil {
                self.submitSignData = dict["SubmitSignData"] as! String
            }
            if dict.keys.contains("TypeCert") && dict["TypeCert"] != nil {
                self.typeCert = dict["TypeCert"] as! String
            }
            if dict.keys.contains("Username") && dict["Username"] != nil {
                self.username = dict["Username"] as! String
            }
            if dict.keys.contains("ValidDate") && dict["ValidDate"] != nil {
                self.validDate = dict["ValidDate"] as! String
            }
            if dict.keys.contains("tmurl") && dict["tmurl"] != nil {
                self.tmurl = dict["tmurl"] as! String
            }
        }
    }
    public var requestId: String?

    public var tmSbjKeyInfo: [ListTrademarkSbjKeyResponseBody.TmSbjKeyInfo]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.tmSbjKeyInfo != nil {
            var tmp : [Any] = []
            for k in self.tmSbjKeyInfo! {
                tmp.append(k.toMap())
            }
            map["TmSbjKeyInfo"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TmSbjKeyInfo") && dict["TmSbjKeyInfo"] != nil {
            var tmp : [ListTrademarkSbjKeyResponseBody.TmSbjKeyInfo] = []
            for v in dict["TmSbjKeyInfo"] as! [Any] {
                var model = ListTrademarkSbjKeyResponseBody.TmSbjKeyInfo()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tmSbjKeyInfo = tmp
        }
    }
}

public class ListTrademarkSbjKeyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTrademarkSbjKeyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListTrademarkSbjKeyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifySubmitTransferMaterailRequest : Tea.TeaModel {
    public var addr: String?

    public var assigneeProxy: String?

    public var bizId: String?

    public var buyerBusinessLicense: String?

    public var buyerBusinessLicenseTranslation: String?

    public var buyerIdCard: String?

    public var cardNo: String?

    public var cardType: String?

    public var complete: Bool?

    public var contactEmail: String?

    public var contactMobile: String?

    public var contactName: String?

    public var name: String?

    public var notarization: String?

    public var note: String?

    public var other: [String: Any]?

    public var registrationCert: String?

    public var sellerApply: String?

    public var sellerBusinessLicense: String?

    public var sellerBusinessLicenseTranslation: String?

    public var sellerIdCard: String?

    public var sellerProxy: String?

    public var tradeMaterialFullUpdate: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addr != nil {
            map["Addr"] = self.addr!
        }
        if self.assigneeProxy != nil {
            map["AssigneeProxy"] = self.assigneeProxy!
        }
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.buyerBusinessLicense != nil {
            map["BuyerBusinessLicense"] = self.buyerBusinessLicense!
        }
        if self.buyerBusinessLicenseTranslation != nil {
            map["BuyerBusinessLicenseTranslation"] = self.buyerBusinessLicenseTranslation!
        }
        if self.buyerIdCard != nil {
            map["BuyerIdCard"] = self.buyerIdCard!
        }
        if self.cardNo != nil {
            map["CardNo"] = self.cardNo!
        }
        if self.cardType != nil {
            map["CardType"] = self.cardType!
        }
        if self.complete != nil {
            map["Complete"] = self.complete!
        }
        if self.contactEmail != nil {
            map["ContactEmail"] = self.contactEmail!
        }
        if self.contactMobile != nil {
            map["ContactMobile"] = self.contactMobile!
        }
        if self.contactName != nil {
            map["ContactName"] = self.contactName!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.notarization != nil {
            map["Notarization"] = self.notarization!
        }
        if self.note != nil {
            map["Note"] = self.note!
        }
        if self.other != nil {
            map["Other"] = self.other!
        }
        if self.registrationCert != nil {
            map["RegistrationCert"] = self.registrationCert!
        }
        if self.sellerApply != nil {
            map["SellerApply"] = self.sellerApply!
        }
        if self.sellerBusinessLicense != nil {
            map["SellerBusinessLicense"] = self.sellerBusinessLicense!
        }
        if self.sellerBusinessLicenseTranslation != nil {
            map["SellerBusinessLicenseTranslation"] = self.sellerBusinessLicenseTranslation!
        }
        if self.sellerIdCard != nil {
            map["SellerIdCard"] = self.sellerIdCard!
        }
        if self.sellerProxy != nil {
            map["SellerProxy"] = self.sellerProxy!
        }
        if self.tradeMaterialFullUpdate != nil {
            map["TradeMaterialFullUpdate"] = self.tradeMaterialFullUpdate!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Addr") && dict["Addr"] != nil {
            self.addr = dict["Addr"] as! String
        }
        if dict.keys.contains("AssigneeProxy") && dict["AssigneeProxy"] != nil {
            self.assigneeProxy = dict["AssigneeProxy"] as! String
        }
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("BuyerBusinessLicense") && dict["BuyerBusinessLicense"] != nil {
            self.buyerBusinessLicense = dict["BuyerBusinessLicense"] as! String
        }
        if dict.keys.contains("BuyerBusinessLicenseTranslation") && dict["BuyerBusinessLicenseTranslation"] != nil {
            self.buyerBusinessLicenseTranslation = dict["BuyerBusinessLicenseTranslation"] as! String
        }
        if dict.keys.contains("BuyerIdCard") && dict["BuyerIdCard"] != nil {
            self.buyerIdCard = dict["BuyerIdCard"] as! String
        }
        if dict.keys.contains("CardNo") && dict["CardNo"] != nil {
            self.cardNo = dict["CardNo"] as! String
        }
        if dict.keys.contains("CardType") && dict["CardType"] != nil {
            self.cardType = dict["CardType"] as! String
        }
        if dict.keys.contains("Complete") && dict["Complete"] != nil {
            self.complete = dict["Complete"] as! Bool
        }
        if dict.keys.contains("ContactEmail") && dict["ContactEmail"] != nil {
            self.contactEmail = dict["ContactEmail"] as! String
        }
        if dict.keys.contains("ContactMobile") && dict["ContactMobile"] != nil {
            self.contactMobile = dict["ContactMobile"] as! String
        }
        if dict.keys.contains("ContactName") && dict["ContactName"] != nil {
            self.contactName = dict["ContactName"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Notarization") && dict["Notarization"] != nil {
            self.notarization = dict["Notarization"] as! String
        }
        if dict.keys.contains("Note") && dict["Note"] != nil {
            self.note = dict["Note"] as! String
        }
        if dict.keys.contains("Other") && dict["Other"] != nil {
            self.other = dict["Other"] as! [String: Any]
        }
        if dict.keys.contains("RegistrationCert") && dict["RegistrationCert"] != nil {
            self.registrationCert = dict["RegistrationCert"] as! String
        }
        if dict.keys.contains("SellerApply") && dict["SellerApply"] != nil {
            self.sellerApply = dict["SellerApply"] as! String
        }
        if dict.keys.contains("SellerBusinessLicense") && dict["SellerBusinessLicense"] != nil {
            self.sellerBusinessLicense = dict["SellerBusinessLicense"] as! String
        }
        if dict.keys.contains("SellerBusinessLicenseTranslation") && dict["SellerBusinessLicenseTranslation"] != nil {
            self.sellerBusinessLicenseTranslation = dict["SellerBusinessLicenseTranslation"] as! String
        }
        if dict.keys.contains("SellerIdCard") && dict["SellerIdCard"] != nil {
            self.sellerIdCard = dict["SellerIdCard"] as! String
        }
        if dict.keys.contains("SellerProxy") && dict["SellerProxy"] != nil {
            self.sellerProxy = dict["SellerProxy"] as! String
        }
        if dict.keys.contains("TradeMaterialFullUpdate") && dict["TradeMaterialFullUpdate"] != nil {
            self.tradeMaterialFullUpdate = dict["TradeMaterialFullUpdate"] as! Bool
        }
    }
}

public class ModifySubmitTransferMaterailShrinkRequest : Tea.TeaModel {
    public var addr: String?

    public var assigneeProxy: String?

    public var bizId: String?

    public var buyerBusinessLicense: String?

    public var buyerBusinessLicenseTranslation: String?

    public var buyerIdCard: String?

    public var cardNo: String?

    public var cardType: String?

    public var complete: Bool?

    public var contactEmail: String?

    public var contactMobile: String?

    public var contactName: String?

    public var name: String?

    public var notarization: String?

    public var note: String?

    public var otherShrink: String?

    public var registrationCert: String?

    public var sellerApply: String?

    public var sellerBusinessLicense: String?

    public var sellerBusinessLicenseTranslation: String?

    public var sellerIdCard: String?

    public var sellerProxy: String?

    public var tradeMaterialFullUpdate: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addr != nil {
            map["Addr"] = self.addr!
        }
        if self.assigneeProxy != nil {
            map["AssigneeProxy"] = self.assigneeProxy!
        }
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.buyerBusinessLicense != nil {
            map["BuyerBusinessLicense"] = self.buyerBusinessLicense!
        }
        if self.buyerBusinessLicenseTranslation != nil {
            map["BuyerBusinessLicenseTranslation"] = self.buyerBusinessLicenseTranslation!
        }
        if self.buyerIdCard != nil {
            map["BuyerIdCard"] = self.buyerIdCard!
        }
        if self.cardNo != nil {
            map["CardNo"] = self.cardNo!
        }
        if self.cardType != nil {
            map["CardType"] = self.cardType!
        }
        if self.complete != nil {
            map["Complete"] = self.complete!
        }
        if self.contactEmail != nil {
            map["ContactEmail"] = self.contactEmail!
        }
        if self.contactMobile != nil {
            map["ContactMobile"] = self.contactMobile!
        }
        if self.contactName != nil {
            map["ContactName"] = self.contactName!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.notarization != nil {
            map["Notarization"] = self.notarization!
        }
        if self.note != nil {
            map["Note"] = self.note!
        }
        if self.otherShrink != nil {
            map["Other"] = self.otherShrink!
        }
        if self.registrationCert != nil {
            map["RegistrationCert"] = self.registrationCert!
        }
        if self.sellerApply != nil {
            map["SellerApply"] = self.sellerApply!
        }
        if self.sellerBusinessLicense != nil {
            map["SellerBusinessLicense"] = self.sellerBusinessLicense!
        }
        if self.sellerBusinessLicenseTranslation != nil {
            map["SellerBusinessLicenseTranslation"] = self.sellerBusinessLicenseTranslation!
        }
        if self.sellerIdCard != nil {
            map["SellerIdCard"] = self.sellerIdCard!
        }
        if self.sellerProxy != nil {
            map["SellerProxy"] = self.sellerProxy!
        }
        if self.tradeMaterialFullUpdate != nil {
            map["TradeMaterialFullUpdate"] = self.tradeMaterialFullUpdate!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Addr") && dict["Addr"] != nil {
            self.addr = dict["Addr"] as! String
        }
        if dict.keys.contains("AssigneeProxy") && dict["AssigneeProxy"] != nil {
            self.assigneeProxy = dict["AssigneeProxy"] as! String
        }
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("BuyerBusinessLicense") && dict["BuyerBusinessLicense"] != nil {
            self.buyerBusinessLicense = dict["BuyerBusinessLicense"] as! String
        }
        if dict.keys.contains("BuyerBusinessLicenseTranslation") && dict["BuyerBusinessLicenseTranslation"] != nil {
            self.buyerBusinessLicenseTranslation = dict["BuyerBusinessLicenseTranslation"] as! String
        }
        if dict.keys.contains("BuyerIdCard") && dict["BuyerIdCard"] != nil {
            self.buyerIdCard = dict["BuyerIdCard"] as! String
        }
        if dict.keys.contains("CardNo") && dict["CardNo"] != nil {
            self.cardNo = dict["CardNo"] as! String
        }
        if dict.keys.contains("CardType") && dict["CardType"] != nil {
            self.cardType = dict["CardType"] as! String
        }
        if dict.keys.contains("Complete") && dict["Complete"] != nil {
            self.complete = dict["Complete"] as! Bool
        }
        if dict.keys.contains("ContactEmail") && dict["ContactEmail"] != nil {
            self.contactEmail = dict["ContactEmail"] as! String
        }
        if dict.keys.contains("ContactMobile") && dict["ContactMobile"] != nil {
            self.contactMobile = dict["ContactMobile"] as! String
        }
        if dict.keys.contains("ContactName") && dict["ContactName"] != nil {
            self.contactName = dict["ContactName"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Notarization") && dict["Notarization"] != nil {
            self.notarization = dict["Notarization"] as! String
        }
        if dict.keys.contains("Note") && dict["Note"] != nil {
            self.note = dict["Note"] as! String
        }
        if dict.keys.contains("Other") && dict["Other"] != nil {
            self.otherShrink = dict["Other"] as! String
        }
        if dict.keys.contains("RegistrationCert") && dict["RegistrationCert"] != nil {
            self.registrationCert = dict["RegistrationCert"] as! String
        }
        if dict.keys.contains("SellerApply") && dict["SellerApply"] != nil {
            self.sellerApply = dict["SellerApply"] as! String
        }
        if dict.keys.contains("SellerBusinessLicense") && dict["SellerBusinessLicense"] != nil {
            self.sellerBusinessLicense = dict["SellerBusinessLicense"] as! String
        }
        if dict.keys.contains("SellerBusinessLicenseTranslation") && dict["SellerBusinessLicenseTranslation"] != nil {
            self.sellerBusinessLicenseTranslation = dict["SellerBusinessLicenseTranslation"] as! String
        }
        if dict.keys.contains("SellerIdCard") && dict["SellerIdCard"] != nil {
            self.sellerIdCard = dict["SellerIdCard"] as! String
        }
        if dict.keys.contains("SellerProxy") && dict["SellerProxy"] != nil {
            self.sellerProxy = dict["SellerProxy"] as! String
        }
        if dict.keys.contains("TradeMaterialFullUpdate") && dict["TradeMaterialFullUpdate"] != nil {
            self.tradeMaterialFullUpdate = dict["TradeMaterialFullUpdate"] as! Bool
        }
    }
}

public class ModifySubmitTransferMaterailResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMsg: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["ErrorMsg"] = self.errorMsg!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMsg") && dict["ErrorMsg"] != nil {
            self.errorMsg = dict["ErrorMsg"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ModifySubmitTransferMaterailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifySubmitTransferMaterailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifySubmitTransferMaterailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class OperateProduceRequest : Tea.TeaModel {
    public var bizId: String?

    public var bizType: String?

    public var extMap: String?

    public var operateType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.bizType != nil {
            map["BizType"] = self.bizType!
        }
        if self.extMap != nil {
            map["ExtMap"] = self.extMap!
        }
        if self.operateType != nil {
            map["OperateType"] = self.operateType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("BizType") && dict["BizType"] != nil {
            self.bizType = dict["BizType"] as! String
        }
        if dict.keys.contains("ExtMap") && dict["ExtMap"] != nil {
            self.extMap = dict["ExtMap"] as! String
        }
        if dict.keys.contains("OperateType") && dict["OperateType"] != nil {
            self.operateType = dict["OperateType"] as! String
        }
    }
}

public class OperateProduceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class OperateProduceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: OperateProduceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = OperateProduceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class PartnerUpdateTrademarkNameRequest : Tea.TeaModel {
    public var aliyunKp: String?

    public var bid: String?

    public var bizId: String?

    public var callerParentId: Int64?

    public var callerType: String?

    public var eventSceneType: Int64?

    public var intentionBizId: String?

    public var tmComment: String?

    public var tmIcon: String?

    public var tmName: String?

    public var type: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliyunKp != nil {
            map["AliyunKp"] = self.aliyunKp!
        }
        if self.bid != nil {
            map["Bid"] = self.bid!
        }
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.callerParentId != nil {
            map["CallerParentId"] = self.callerParentId!
        }
        if self.callerType != nil {
            map["CallerType"] = self.callerType!
        }
        if self.eventSceneType != nil {
            map["EventSceneType"] = self.eventSceneType!
        }
        if self.intentionBizId != nil {
            map["IntentionBizId"] = self.intentionBizId!
        }
        if self.tmComment != nil {
            map["TmComment"] = self.tmComment!
        }
        if self.tmIcon != nil {
            map["TmIcon"] = self.tmIcon!
        }
        if self.tmName != nil {
            map["TmName"] = self.tmName!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AliyunKp") && dict["AliyunKp"] != nil {
            self.aliyunKp = dict["AliyunKp"] as! String
        }
        if dict.keys.contains("Bid") && dict["Bid"] != nil {
            self.bid = dict["Bid"] as! String
        }
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("CallerParentId") && dict["CallerParentId"] != nil {
            self.callerParentId = dict["CallerParentId"] as! Int64
        }
        if dict.keys.contains("CallerType") && dict["CallerType"] != nil {
            self.callerType = dict["CallerType"] as! String
        }
        if dict.keys.contains("EventSceneType") && dict["EventSceneType"] != nil {
            self.eventSceneType = dict["EventSceneType"] as! Int64
        }
        if dict.keys.contains("IntentionBizId") && dict["IntentionBizId"] != nil {
            self.intentionBizId = dict["IntentionBizId"] as! String
        }
        if dict.keys.contains("TmComment") && dict["TmComment"] != nil {
            self.tmComment = dict["TmComment"] as! String
        }
        if dict.keys.contains("TmIcon") && dict["TmIcon"] != nil {
            self.tmIcon = dict["TmIcon"] as! String
        }
        if dict.keys.contains("TmName") && dict["TmName"] != nil {
            self.tmName = dict["TmName"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! Int32
        }
    }
}

public class PartnerUpdateTrademarkNameResponseBody : Tea.TeaModel {
    public var allowRetry: Bool?

    public var appName: String?

    public var dynamicCode: String?

    public var dynamicMessage: String?

    public var errorCode: String?

    public var errorMsg: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.allowRetry != nil {
            map["AllowRetry"] = self.allowRetry!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.dynamicCode != nil {
            map["DynamicCode"] = self.dynamicCode!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["ErrorMsg"] = self.errorMsg!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AllowRetry") && dict["AllowRetry"] != nil {
            self.allowRetry = dict["AllowRetry"] as! Bool
        }
        if dict.keys.contains("AppName") && dict["AppName"] != nil {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("DynamicCode") && dict["DynamicCode"] != nil {
            self.dynamicCode = dict["DynamicCode"] as! String
        }
        if dict.keys.contains("DynamicMessage") && dict["DynamicMessage"] != nil {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMsg") && dict["ErrorMsg"] != nil {
            self.errorMsg = dict["ErrorMsg"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class PartnerUpdateTrademarkNameResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PartnerUpdateTrademarkNameResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = PartnerUpdateTrademarkNameResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryCommunicationLogsRequest : Tea.TeaModel {
    public var bizId: String?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var type: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("PageNum") && dict["PageNum"] != nil {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! Int32
        }
    }
}

public class QueryCommunicationLogsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class TaskList : Tea.TeaModel {
            public var bizId: String?

            public var createTime: Int64?

            public var note: String?

            public var partnerCode: String?

            public var updateTime: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bizId != nil {
                    map["BizId"] = self.bizId!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.note != nil {
                    map["Note"] = self.note!
                }
                if self.partnerCode != nil {
                    map["PartnerCode"] = self.partnerCode!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BizId") && dict["BizId"] != nil {
                    self.bizId = dict["BizId"] as! String
                }
                if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("Note") && dict["Note"] != nil {
                    self.note = dict["Note"] as! String
                }
                if dict.keys.contains("PartnerCode") && dict["PartnerCode"] != nil {
                    self.partnerCode = dict["PartnerCode"] as! String
                }
                if dict.keys.contains("UpdateTime") && dict["UpdateTime"] != nil {
                    self.updateTime = dict["UpdateTime"] as! Int64
                }
            }
        }
        public var taskList: [QueryCommunicationLogsResponseBody.Data.TaskList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.taskList != nil {
                var tmp : [Any] = []
                for k in self.taskList! {
                    tmp.append(k.toMap())
                }
                map["TaskList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TaskList") && dict["TaskList"] != nil {
                var tmp : [QueryCommunicationLogsResponseBody.Data.TaskList] = []
                for v in dict["TaskList"] as! [Any] {
                    var model = QueryCommunicationLogsResponseBody.Data.TaskList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.taskList = tmp
            }
        }
    }
    public var data: QueryCommunicationLogsResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = QueryCommunicationLogsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class QueryCommunicationLogsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryCommunicationLogsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryCommunicationLogsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryCredentialsInfoRequest : Tea.TeaModel {
    public var companyName: String?

    public var materialType: String?

    public var ossKey: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.companyName != nil {
            map["CompanyName"] = self.companyName!
        }
        if self.materialType != nil {
            map["MaterialType"] = self.materialType!
        }
        if self.ossKey != nil {
            map["OssKey"] = self.ossKey!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CompanyName") && dict["CompanyName"] != nil {
            self.companyName = dict["CompanyName"] as! String
        }
        if dict.keys.contains("MaterialType") && dict["MaterialType"] != nil {
            self.materialType = dict["MaterialType"] as! String
        }
        if dict.keys.contains("OssKey") && dict["OssKey"] != nil {
            self.ossKey = dict["OssKey"] as! String
        }
    }
}

public class QueryCredentialsInfoResponseBody : Tea.TeaModel {
    public class CredentialsInfo : Tea.TeaModel {
        public var address: String?

        public var cardNumber: String?

        public var companyName: String?

        public var personName: String?

        public var province: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.address != nil {
                map["Address"] = self.address!
            }
            if self.cardNumber != nil {
                map["CardNumber"] = self.cardNumber!
            }
            if self.companyName != nil {
                map["CompanyName"] = self.companyName!
            }
            if self.personName != nil {
                map["PersonName"] = self.personName!
            }
            if self.province != nil {
                map["Province"] = self.province!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Address") && dict["Address"] != nil {
                self.address = dict["Address"] as! String
            }
            if dict.keys.contains("CardNumber") && dict["CardNumber"] != nil {
                self.cardNumber = dict["CardNumber"] as! String
            }
            if dict.keys.contains("CompanyName") && dict["CompanyName"] != nil {
                self.companyName = dict["CompanyName"] as! String
            }
            if dict.keys.contains("PersonName") && dict["PersonName"] != nil {
                self.personName = dict["PersonName"] as! String
            }
            if dict.keys.contains("Province") && dict["Province"] != nil {
                self.province = dict["Province"] as! String
            }
        }
    }
    public var credentialsInfo: QueryCredentialsInfoResponseBody.CredentialsInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.credentialsInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.credentialsInfo != nil {
            map["CredentialsInfo"] = self.credentialsInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CredentialsInfo") && dict["CredentialsInfo"] != nil {
            var model = QueryCredentialsInfoResponseBody.CredentialsInfo()
            model.fromMap(dict["CredentialsInfo"] as! [String: Any])
            self.credentialsInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class QueryCredentialsInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryCredentialsInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryCredentialsInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryExtensionAttributeRequest : Tea.TeaModel {
    public var attributeKey: String?

    public var bizId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attributeKey != nil {
            map["AttributeKey"] = self.attributeKey!
        }
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AttributeKey") && dict["AttributeKey"] != nil {
            self.attributeKey = dict["AttributeKey"] as! String
        }
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
    }
}

public class QueryExtensionAttributeResponseBody : Tea.TeaModel {
    public var attributeValue: String?

    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attributeValue != nil {
            map["AttributeValue"] = self.attributeValue!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AttributeValue") && dict["AttributeValue"] != nil {
            self.attributeValue = dict["AttributeValue"] as! String
        }
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class QueryExtensionAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryExtensionAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryExtensionAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryIntentionDetailRequest : Tea.TeaModel {
    public var bizId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
    }
}

public class QueryIntentionDetailResponseBody : Tea.TeaModel {
    public var bizId: String?

    public var classification: String?

    public var createTime: Int64?

    public var description_: String?

    public var mobile: String?

    public var partnerMobile: String?

    public var registerNumber: String?

    public var relationBizId: String?

    public var requestId: String?

    public var status: Int32?

    public var type: Int32?

    public var updateTime: Int64?

    public var userId: String?

    public var userName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.classification != nil {
            map["Classification"] = self.classification!
        }
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.mobile != nil {
            map["Mobile"] = self.mobile!
        }
        if self.partnerMobile != nil {
            map["PartnerMobile"] = self.partnerMobile!
        }
        if self.registerNumber != nil {
            map["RegisterNumber"] = self.registerNumber!
        }
        if self.relationBizId != nil {
            map["RelationBizId"] = self.relationBizId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.updateTime != nil {
            map["UpdateTime"] = self.updateTime!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        if self.userName != nil {
            map["UserName"] = self.userName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("Classification") && dict["Classification"] != nil {
            self.classification = dict["Classification"] as! String
        }
        if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
            self.createTime = dict["CreateTime"] as! Int64
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Mobile") && dict["Mobile"] != nil {
            self.mobile = dict["Mobile"] as! String
        }
        if dict.keys.contains("PartnerMobile") && dict["PartnerMobile"] != nil {
            self.partnerMobile = dict["PartnerMobile"] as! String
        }
        if dict.keys.contains("RegisterNumber") && dict["RegisterNumber"] != nil {
            self.registerNumber = dict["RegisterNumber"] as! String
        }
        if dict.keys.contains("RelationBizId") && dict["RelationBizId"] != nil {
            self.relationBizId = dict["RelationBizId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! Int32
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! Int32
        }
        if dict.keys.contains("UpdateTime") && dict["UpdateTime"] != nil {
            self.updateTime = dict["UpdateTime"] as! Int64
        }
        if dict.keys.contains("UserId") && dict["UserId"] != nil {
            self.userId = dict["UserId"] as! String
        }
        if dict.keys.contains("UserName") && dict["UserName"] != nil {
            self.userName = dict["UserName"] as! String
        }
    }
}

public class QueryIntentionDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryIntentionDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryIntentionDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryIntentionListRequest : Tea.TeaModel {
    public var pageNum: Int32?

    public var pageSize: Int32?

    public var sortFiled: String?

    public var sortOrder: String?

    public var status: Int32?

    public var type: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sortFiled != nil {
            map["SortFiled"] = self.sortFiled!
        }
        if self.sortOrder != nil {
            map["SortOrder"] = self.sortOrder!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNum") && dict["PageNum"] != nil {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SortFiled") && dict["SortFiled"] != nil {
            self.sortFiled = dict["SortFiled"] as! String
        }
        if dict.keys.contains("SortOrder") && dict["SortOrder"] != nil {
            self.sortOrder = dict["SortOrder"] as! String
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! Int32
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! Int32
        }
    }
}

public class QueryIntentionListResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Intention : Tea.TeaModel {
            public var bizId: String?

            public var classification: String?

            public var createTime: Int64?

            public var description_: String?

            public var registerNumber: String?

            public var status: Int32?

            public var type: Int32?

            public var updateTime: Int64?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bizId != nil {
                    map["BizId"] = self.bizId!
                }
                if self.classification != nil {
                    map["Classification"] = self.classification!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.registerNumber != nil {
                    map["RegisterNumber"] = self.registerNumber!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BizId") && dict["BizId"] != nil {
                    self.bizId = dict["BizId"] as! String
                }
                if dict.keys.contains("Classification") && dict["Classification"] != nil {
                    self.classification = dict["Classification"] as! String
                }
                if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("RegisterNumber") && dict["RegisterNumber"] != nil {
                    self.registerNumber = dict["RegisterNumber"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! Int32
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! Int32
                }
                if dict.keys.contains("UpdateTime") && dict["UpdateTime"] != nil {
                    self.updateTime = dict["UpdateTime"] as! Int64
                }
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! String
                }
            }
        }
        public var intention: [QueryIntentionListResponseBody.Data.Intention]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.intention != nil {
                var tmp : [Any] = []
                for k in self.intention! {
                    tmp.append(k.toMap())
                }
                map["Intention"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Intention") && dict["Intention"] != nil {
                var tmp : [QueryIntentionListResponseBody.Data.Intention] = []
                for v in dict["Intention"] as! [Any] {
                    var model = QueryIntentionListResponseBody.Data.Intention()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.intention = tmp
            }
        }
    }
    public var currentPageNum: Int32?

    public var data: QueryIntentionListResponseBody.Data?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalItemNum: Int32?

    public var totalPageNum: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPageNum != nil {
            map["CurrentPageNum"] = self.currentPageNum!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalItemNum != nil {
            map["TotalItemNum"] = self.totalItemNum!
        }
        if self.totalPageNum != nil {
            map["TotalPageNum"] = self.totalPageNum!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPageNum") && dict["CurrentPageNum"] != nil {
            self.currentPageNum = dict["CurrentPageNum"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = QueryIntentionListResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalItemNum") && dict["TotalItemNum"] != nil {
            self.totalItemNum = dict["TotalItemNum"] as! Int32
        }
        if dict.keys.contains("TotalPageNum") && dict["TotalPageNum"] != nil {
            self.totalPageNum = dict["TotalPageNum"] as! Int32
        }
    }
}

public class QueryIntentionListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryIntentionListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryIntentionListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryIntentionOwnerRequest : Tea.TeaModel {
    public var bizId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
    }
}

public class QueryIntentionOwnerResponseBody : Tea.TeaModel {
    public class Module : Tea.TeaModel {
        public var ownerId: Double?

        public var ownerName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ownerId != nil {
                map["OwnerId"] = self.ownerId!
            }
            if self.ownerName != nil {
                map["OwnerName"] = self.ownerName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
                self.ownerId = dict["OwnerId"] as! Double
            }
            if dict.keys.contains("OwnerName") && dict["OwnerName"] != nil {
                self.ownerName = dict["OwnerName"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMsg: String?

    public var module: QueryIntentionOwnerResponseBody.Module?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.module?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["ErrorMsg"] = self.errorMsg!
        }
        if self.module != nil {
            map["Module"] = self.module?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMsg") && dict["ErrorMsg"] != nil {
            self.errorMsg = dict["ErrorMsg"] as! String
        }
        if dict.keys.contains("Module") && dict["Module"] != nil {
            var model = QueryIntentionOwnerResponseBody.Module()
            model.fromMap(dict["Module"] as! [String: Any])
            self.module = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class QueryIntentionOwnerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryIntentionOwnerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryIntentionOwnerResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryIntentionPriceRequest : Tea.TeaModel {
    public var channel: String?

    public var intentionBizId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.channel != nil {
            map["Channel"] = self.channel!
        }
        if self.intentionBizId != nil {
            map["IntentionBizId"] = self.intentionBizId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Channel") && dict["Channel"] != nil {
            self.channel = dict["Channel"] as! String
        }
        if dict.keys.contains("IntentionBizId") && dict["IntentionBizId"] != nil {
            self.intentionBizId = dict["IntentionBizId"] as! String
        }
    }
}

public class QueryIntentionPriceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class TmProduces : Tea.TeaModel {
            public class FirstClassification : Tea.TeaModel {
                public var classificationCode: String?

                public var classificationName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.classificationCode != nil {
                        map["ClassificationCode"] = self.classificationCode!
                    }
                    if self.classificationName != nil {
                        map["ClassificationName"] = self.classificationName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ClassificationCode") && dict["ClassificationCode"] != nil {
                        self.classificationCode = dict["ClassificationCode"] as! String
                    }
                    if dict.keys.contains("ClassificationName") && dict["ClassificationName"] != nil {
                        self.classificationName = dict["ClassificationName"] as! String
                    }
                }
            }
            public class ThirdClassification : Tea.TeaModel {
                public class ThirdClassifications : Tea.TeaModel {
                    public var classificationCode: String?

                    public var classificationName: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.classificationCode != nil {
                            map["ClassificationCode"] = self.classificationCode!
                        }
                        if self.classificationName != nil {
                            map["ClassificationName"] = self.classificationName!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ClassificationCode") && dict["ClassificationCode"] != nil {
                            self.classificationCode = dict["ClassificationCode"] as! String
                        }
                        if dict.keys.contains("ClassificationName") && dict["ClassificationName"] != nil {
                            self.classificationName = dict["ClassificationName"] as! String
                        }
                    }
                }
                public var thirdClassifications: [QueryIntentionPriceResponseBody.Data.TmProduces.ThirdClassification.ThirdClassifications]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.thirdClassifications != nil {
                        var tmp : [Any] = []
                        for k in self.thirdClassifications! {
                            tmp.append(k.toMap())
                        }
                        map["ThirdClassifications"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ThirdClassifications") && dict["ThirdClassifications"] != nil {
                        var tmp : [QueryIntentionPriceResponseBody.Data.TmProduces.ThirdClassification.ThirdClassifications] = []
                        for v in dict["ThirdClassifications"] as! [Any] {
                            var model = QueryIntentionPriceResponseBody.Data.TmProduces.ThirdClassification.ThirdClassifications()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.thirdClassifications = tmp
                    }
                }
            }
            public var bizId: String?

            public var createTime: Int64?

            public var firstClassification: QueryIntentionPriceResponseBody.Data.TmProduces.FirstClassification?

            public var loaUrl: String?

            public var materialId: String?

            public var materialName: String?

            public var note: String?

            public var orderPrice: Double?

            public var servicePrice: Double?

            public var status: Int32?

            public var supplementId: Int64?

            public var supplementStatus: Int32?

            public var thirdClassification: QueryIntentionPriceResponseBody.Data.TmProduces.ThirdClassification?

            public var tmIcon: String?

            public var tmName: String?

            public var tmNumber: String?

            public var totalPrice: Double?

            public var type: Int32?

            public var updateTime: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.firstClassification?.validate()
                try self.thirdClassification?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bizId != nil {
                    map["BizId"] = self.bizId!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.firstClassification != nil {
                    map["FirstClassification"] = self.firstClassification?.toMap()
                }
                if self.loaUrl != nil {
                    map["LoaUrl"] = self.loaUrl!
                }
                if self.materialId != nil {
                    map["MaterialId"] = self.materialId!
                }
                if self.materialName != nil {
                    map["MaterialName"] = self.materialName!
                }
                if self.note != nil {
                    map["Note"] = self.note!
                }
                if self.orderPrice != nil {
                    map["OrderPrice"] = self.orderPrice!
                }
                if self.servicePrice != nil {
                    map["ServicePrice"] = self.servicePrice!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.supplementId != nil {
                    map["SupplementId"] = self.supplementId!
                }
                if self.supplementStatus != nil {
                    map["SupplementStatus"] = self.supplementStatus!
                }
                if self.thirdClassification != nil {
                    map["ThirdClassification"] = self.thirdClassification?.toMap()
                }
                if self.tmIcon != nil {
                    map["TmIcon"] = self.tmIcon!
                }
                if self.tmName != nil {
                    map["TmName"] = self.tmName!
                }
                if self.tmNumber != nil {
                    map["TmNumber"] = self.tmNumber!
                }
                if self.totalPrice != nil {
                    map["TotalPrice"] = self.totalPrice!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BizId") && dict["BizId"] != nil {
                    self.bizId = dict["BizId"] as! String
                }
                if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("FirstClassification") && dict["FirstClassification"] != nil {
                    var model = QueryIntentionPriceResponseBody.Data.TmProduces.FirstClassification()
                    model.fromMap(dict["FirstClassification"] as! [String: Any])
                    self.firstClassification = model
                }
                if dict.keys.contains("LoaUrl") && dict["LoaUrl"] != nil {
                    self.loaUrl = dict["LoaUrl"] as! String
                }
                if dict.keys.contains("MaterialId") && dict["MaterialId"] != nil {
                    self.materialId = dict["MaterialId"] as! String
                }
                if dict.keys.contains("MaterialName") && dict["MaterialName"] != nil {
                    self.materialName = dict["MaterialName"] as! String
                }
                if dict.keys.contains("Note") && dict["Note"] != nil {
                    self.note = dict["Note"] as! String
                }
                if dict.keys.contains("OrderPrice") && dict["OrderPrice"] != nil {
                    self.orderPrice = dict["OrderPrice"] as! Double
                }
                if dict.keys.contains("ServicePrice") && dict["ServicePrice"] != nil {
                    self.servicePrice = dict["ServicePrice"] as! Double
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! Int32
                }
                if dict.keys.contains("SupplementId") && dict["SupplementId"] != nil {
                    self.supplementId = dict["SupplementId"] as! Int64
                }
                if dict.keys.contains("SupplementStatus") && dict["SupplementStatus"] != nil {
                    self.supplementStatus = dict["SupplementStatus"] as! Int32
                }
                if dict.keys.contains("ThirdClassification") && dict["ThirdClassification"] != nil {
                    var model = QueryIntentionPriceResponseBody.Data.TmProduces.ThirdClassification()
                    model.fromMap(dict["ThirdClassification"] as! [String: Any])
                    self.thirdClassification = model
                }
                if dict.keys.contains("TmIcon") && dict["TmIcon"] != nil {
                    self.tmIcon = dict["TmIcon"] as! String
                }
                if dict.keys.contains("TmName") && dict["TmName"] != nil {
                    self.tmName = dict["TmName"] as! String
                }
                if dict.keys.contains("TmNumber") && dict["TmNumber"] != nil {
                    self.tmNumber = dict["TmNumber"] as! String
                }
                if dict.keys.contains("TotalPrice") && dict["TotalPrice"] != nil {
                    self.totalPrice = dict["TotalPrice"] as! Double
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! Int32
                }
                if dict.keys.contains("UpdateTime") && dict["UpdateTime"] != nil {
                    self.updateTime = dict["UpdateTime"] as! Int64
                }
            }
        }
        public var tmProduces: [QueryIntentionPriceResponseBody.Data.TmProduces]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tmProduces != nil {
                var tmp : [Any] = []
                for k in self.tmProduces! {
                    tmp.append(k.toMap())
                }
                map["TmProduces"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TmProduces") && dict["TmProduces"] != nil {
                var tmp : [QueryIntentionPriceResponseBody.Data.TmProduces] = []
                for v in dict["TmProduces"] as! [Any] {
                    var model = QueryIntentionPriceResponseBody.Data.TmProduces()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tmProduces = tmp
            }
        }
    }
    public var currentPageNum: Int32?

    public var data: QueryIntentionPriceResponseBody.Data?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalItemNum: Int32?

    public var totalPageNum: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPageNum != nil {
            map["CurrentPageNum"] = self.currentPageNum!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalItemNum != nil {
            map["TotalItemNum"] = self.totalItemNum!
        }
        if self.totalPageNum != nil {
            map["TotalPageNum"] = self.totalPageNum!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPageNum") && dict["CurrentPageNum"] != nil {
            self.currentPageNum = dict["CurrentPageNum"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = QueryIntentionPriceResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalItemNum") && dict["TotalItemNum"] != nil {
            self.totalItemNum = dict["TotalItemNum"] as! Int32
        }
        if dict.keys.contains("TotalPageNum") && dict["TotalPageNum"] != nil {
            self.totalPageNum = dict["TotalPageNum"] as! Int32
        }
    }
}

public class QueryIntentionPriceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryIntentionPriceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryIntentionPriceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryMaterialRequest : Tea.TeaModel {
    public var id: Int64?

    public var queryUnconfirmedInfo: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.queryUnconfirmedInfo != nil {
            map["QueryUnconfirmedInfo"] = self.queryUnconfirmedInfo!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("QueryUnconfirmedInfo") && dict["QueryUnconfirmedInfo"] != nil {
            self.queryUnconfirmedInfo = dict["QueryUnconfirmedInfo"] as! Bool
        }
    }
}

public class QueryMaterialResponseBody : Tea.TeaModel {
    public class ReviewAdditionalFiles : Tea.TeaModel {
        public var reviewAdditionalFile: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.reviewAdditionalFile != nil {
                map["ReviewAdditionalFile"] = self.reviewAdditionalFile!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ReviewAdditionalFile") && dict["ReviewAdditionalFile"] != nil {
                self.reviewAdditionalFile = dict["ReviewAdditionalFile"] as! [String]
            }
        }
    }
    public var address: String?

    public var businessLicenceUrl: String?

    public var cardNumber: String?

    public var city: String?

    public var contactAddress: String?

    public var contactCity: String?

    public var contactCounty: String?

    public var contactDistrict: String?

    public var contactEmail: String?

    public var contactName: String?

    public var contactNumber: String?

    public var contactProvince: String?

    public var contactZipcode: String?

    public var country: String?

    public var EAddress: String?

    public var EName: String?

    public var evidenceCatalogPath: String?

    public var evidenceOfservicePath: String?

    public var evidencePath: String?

    public var expirationDate: Int64?

    public var factandreasonPdfPath: String?

    public var fgsqPath: String?

    public var fileBgPath: String?

    public var fileFsSqPath: String?

    public var fileGtPath: String?

    public var fileYgPath: String?

    public var id: Int64?

    public var idCardName: String?

    public var idCardNumber: String?

    public var idCardUrl: String?

    public var legalNoticeKey: String?

    public var legalNoticeUrl: String?

    public var loaStatus: Int32?

    public var loaUrl: String?

    public var materialVersion: String?

    public var name: String?

    public var note: String?

    public var passportUrl: String?

    public var personalType: Int64?

    public var principalDescription: String?

    public var principalName: Int32?

    public var province: String?

    public var reason: String?

    public var region: Int32?

    public var requestId: String?

    public var reviewAdditionalFiles: QueryMaterialResponseBody.ReviewAdditionalFiles?

    public var reviewApplicationFile: String?

    public var status: Int32?

    public var supplementEvidenceCatalogFile: String?

    public var supplementEvidenceMaterialFile: String?

    public var supplementReasonFile: String?

    public var systemVersion: String?

    public var town: String?

    public var type: Int32?

    public var validDate: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.reviewAdditionalFiles?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.address != nil {
            map["Address"] = self.address!
        }
        if self.businessLicenceUrl != nil {
            map["BusinessLicenceUrl"] = self.businessLicenceUrl!
        }
        if self.cardNumber != nil {
            map["CardNumber"] = self.cardNumber!
        }
        if self.city != nil {
            map["City"] = self.city!
        }
        if self.contactAddress != nil {
            map["ContactAddress"] = self.contactAddress!
        }
        if self.contactCity != nil {
            map["ContactCity"] = self.contactCity!
        }
        if self.contactCounty != nil {
            map["ContactCounty"] = self.contactCounty!
        }
        if self.contactDistrict != nil {
            map["ContactDistrict"] = self.contactDistrict!
        }
        if self.contactEmail != nil {
            map["ContactEmail"] = self.contactEmail!
        }
        if self.contactName != nil {
            map["ContactName"] = self.contactName!
        }
        if self.contactNumber != nil {
            map["ContactNumber"] = self.contactNumber!
        }
        if self.contactProvince != nil {
            map["ContactProvince"] = self.contactProvince!
        }
        if self.contactZipcode != nil {
            map["ContactZipcode"] = self.contactZipcode!
        }
        if self.country != nil {
            map["Country"] = self.country!
        }
        if self.EAddress != nil {
            map["EAddress"] = self.EAddress!
        }
        if self.EName != nil {
            map["EName"] = self.EName!
        }
        if self.evidenceCatalogPath != nil {
            map["EvidenceCatalogPath"] = self.evidenceCatalogPath!
        }
        if self.evidenceOfservicePath != nil {
            map["EvidenceOfservicePath"] = self.evidenceOfservicePath!
        }
        if self.evidencePath != nil {
            map["EvidencePath"] = self.evidencePath!
        }
        if self.expirationDate != nil {
            map["ExpirationDate"] = self.expirationDate!
        }
        if self.factandreasonPdfPath != nil {
            map["FactandreasonPdfPath"] = self.factandreasonPdfPath!
        }
        if self.fgsqPath != nil {
            map["FgsqPath"] = self.fgsqPath!
        }
        if self.fileBgPath != nil {
            map["FileBgPath"] = self.fileBgPath!
        }
        if self.fileFsSqPath != nil {
            map["FileFsSqPath"] = self.fileFsSqPath!
        }
        if self.fileGtPath != nil {
            map["FileGtPath"] = self.fileGtPath!
        }
        if self.fileYgPath != nil {
            map["FileYgPath"] = self.fileYgPath!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.idCardName != nil {
            map["IdCardName"] = self.idCardName!
        }
        if self.idCardNumber != nil {
            map["IdCardNumber"] = self.idCardNumber!
        }
        if self.idCardUrl != nil {
            map["IdCardUrl"] = self.idCardUrl!
        }
        if self.legalNoticeKey != nil {
            map["LegalNoticeKey"] = self.legalNoticeKey!
        }
        if self.legalNoticeUrl != nil {
            map["LegalNoticeUrl"] = self.legalNoticeUrl!
        }
        if self.loaStatus != nil {
            map["LoaStatus"] = self.loaStatus!
        }
        if self.loaUrl != nil {
            map["LoaUrl"] = self.loaUrl!
        }
        if self.materialVersion != nil {
            map["MaterialVersion"] = self.materialVersion!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.note != nil {
            map["Note"] = self.note!
        }
        if self.passportUrl != nil {
            map["PassportUrl"] = self.passportUrl!
        }
        if self.personalType != nil {
            map["PersonalType"] = self.personalType!
        }
        if self.principalDescription != nil {
            map["PrincipalDescription"] = self.principalDescription!
        }
        if self.principalName != nil {
            map["PrincipalName"] = self.principalName!
        }
        if self.province != nil {
            map["Province"] = self.province!
        }
        if self.reason != nil {
            map["Reason"] = self.reason!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.reviewAdditionalFiles != nil {
            map["ReviewAdditionalFiles"] = self.reviewAdditionalFiles?.toMap()
        }
        if self.reviewApplicationFile != nil {
            map["ReviewApplicationFile"] = self.reviewApplicationFile!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.supplementEvidenceCatalogFile != nil {
            map["SupplementEvidenceCatalogFile"] = self.supplementEvidenceCatalogFile!
        }
        if self.supplementEvidenceMaterialFile != nil {
            map["SupplementEvidenceMaterialFile"] = self.supplementEvidenceMaterialFile!
        }
        if self.supplementReasonFile != nil {
            map["SupplementReasonFile"] = self.supplementReasonFile!
        }
        if self.systemVersion != nil {
            map["SystemVersion"] = self.systemVersion!
        }
        if self.town != nil {
            map["Town"] = self.town!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.validDate != nil {
            map["ValidDate"] = self.validDate!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Address") && dict["Address"] != nil {
            self.address = dict["Address"] as! String
        }
        if dict.keys.contains("BusinessLicenceUrl") && dict["BusinessLicenceUrl"] != nil {
            self.businessLicenceUrl = dict["BusinessLicenceUrl"] as! String
        }
        if dict.keys.contains("CardNumber") && dict["CardNumber"] != nil {
            self.cardNumber = dict["CardNumber"] as! String
        }
        if dict.keys.contains("City") && dict["City"] != nil {
            self.city = dict["City"] as! String
        }
        if dict.keys.contains("ContactAddress") && dict["ContactAddress"] != nil {
            self.contactAddress = dict["ContactAddress"] as! String
        }
        if dict.keys.contains("ContactCity") && dict["ContactCity"] != nil {
            self.contactCity = dict["ContactCity"] as! String
        }
        if dict.keys.contains("ContactCounty") && dict["ContactCounty"] != nil {
            self.contactCounty = dict["ContactCounty"] as! String
        }
        if dict.keys.contains("ContactDistrict") && dict["ContactDistrict"] != nil {
            self.contactDistrict = dict["ContactDistrict"] as! String
        }
        if dict.keys.contains("ContactEmail") && dict["ContactEmail"] != nil {
            self.contactEmail = dict["ContactEmail"] as! String
        }
        if dict.keys.contains("ContactName") && dict["ContactName"] != nil {
            self.contactName = dict["ContactName"] as! String
        }
        if dict.keys.contains("ContactNumber") && dict["ContactNumber"] != nil {
            self.contactNumber = dict["ContactNumber"] as! String
        }
        if dict.keys.contains("ContactProvince") && dict["ContactProvince"] != nil {
            self.contactProvince = dict["ContactProvince"] as! String
        }
        if dict.keys.contains("ContactZipcode") && dict["ContactZipcode"] != nil {
            self.contactZipcode = dict["ContactZipcode"] as! String
        }
        if dict.keys.contains("Country") && dict["Country"] != nil {
            self.country = dict["Country"] as! String
        }
        if dict.keys.contains("EAddress") && dict["EAddress"] != nil {
            self.EAddress = dict["EAddress"] as! String
        }
        if dict.keys.contains("EName") && dict["EName"] != nil {
            self.EName = dict["EName"] as! String
        }
        if dict.keys.contains("EvidenceCatalogPath") && dict["EvidenceCatalogPath"] != nil {
            self.evidenceCatalogPath = dict["EvidenceCatalogPath"] as! String
        }
        if dict.keys.contains("EvidenceOfservicePath") && dict["EvidenceOfservicePath"] != nil {
            self.evidenceOfservicePath = dict["EvidenceOfservicePath"] as! String
        }
        if dict.keys.contains("EvidencePath") && dict["EvidencePath"] != nil {
            self.evidencePath = dict["EvidencePath"] as! String
        }
        if dict.keys.contains("ExpirationDate") && dict["ExpirationDate"] != nil {
            self.expirationDate = dict["ExpirationDate"] as! Int64
        }
        if dict.keys.contains("FactandreasonPdfPath") && dict["FactandreasonPdfPath"] != nil {
            self.factandreasonPdfPath = dict["FactandreasonPdfPath"] as! String
        }
        if dict.keys.contains("FgsqPath") && dict["FgsqPath"] != nil {
            self.fgsqPath = dict["FgsqPath"] as! String
        }
        if dict.keys.contains("FileBgPath") && dict["FileBgPath"] != nil {
            self.fileBgPath = dict["FileBgPath"] as! String
        }
        if dict.keys.contains("FileFsSqPath") && dict["FileFsSqPath"] != nil {
            self.fileFsSqPath = dict["FileFsSqPath"] as! String
        }
        if dict.keys.contains("FileGtPath") && dict["FileGtPath"] != nil {
            self.fileGtPath = dict["FileGtPath"] as! String
        }
        if dict.keys.contains("FileYgPath") && dict["FileYgPath"] != nil {
            self.fileYgPath = dict["FileYgPath"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("IdCardName") && dict["IdCardName"] != nil {
            self.idCardName = dict["IdCardName"] as! String
        }
        if dict.keys.contains("IdCardNumber") && dict["IdCardNumber"] != nil {
            self.idCardNumber = dict["IdCardNumber"] as! String
        }
        if dict.keys.contains("IdCardUrl") && dict["IdCardUrl"] != nil {
            self.idCardUrl = dict["IdCardUrl"] as! String
        }
        if dict.keys.contains("LegalNoticeKey") && dict["LegalNoticeKey"] != nil {
            self.legalNoticeKey = dict["LegalNoticeKey"] as! String
        }
        if dict.keys.contains("LegalNoticeUrl") && dict["LegalNoticeUrl"] != nil {
            self.legalNoticeUrl = dict["LegalNoticeUrl"] as! String
        }
        if dict.keys.contains("LoaStatus") && dict["LoaStatus"] != nil {
            self.loaStatus = dict["LoaStatus"] as! Int32
        }
        if dict.keys.contains("LoaUrl") && dict["LoaUrl"] != nil {
            self.loaUrl = dict["LoaUrl"] as! String
        }
        if dict.keys.contains("MaterialVersion") && dict["MaterialVersion"] != nil {
            self.materialVersion = dict["MaterialVersion"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Note") && dict["Note"] != nil {
            self.note = dict["Note"] as! String
        }
        if dict.keys.contains("PassportUrl") && dict["PassportUrl"] != nil {
            self.passportUrl = dict["PassportUrl"] as! String
        }
        if dict.keys.contains("PersonalType") && dict["PersonalType"] != nil {
            self.personalType = dict["PersonalType"] as! Int64
        }
        if dict.keys.contains("PrincipalDescription") && dict["PrincipalDescription"] != nil {
            self.principalDescription = dict["PrincipalDescription"] as! String
        }
        if dict.keys.contains("PrincipalName") && dict["PrincipalName"] != nil {
            self.principalName = dict["PrincipalName"] as! Int32
        }
        if dict.keys.contains("Province") && dict["Province"] != nil {
            self.province = dict["Province"] as! String
        }
        if dict.keys.contains("Reason") && dict["Reason"] != nil {
            self.reason = dict["Reason"] as! String
        }
        if dict.keys.contains("Region") && dict["Region"] != nil {
            self.region = dict["Region"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ReviewAdditionalFiles") && dict["ReviewAdditionalFiles"] != nil {
            var model = QueryMaterialResponseBody.ReviewAdditionalFiles()
            model.fromMap(dict["ReviewAdditionalFiles"] as! [String: Any])
            self.reviewAdditionalFiles = model
        }
        if dict.keys.contains("ReviewApplicationFile") && dict["ReviewApplicationFile"] != nil {
            self.reviewApplicationFile = dict["ReviewApplicationFile"] as! String
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! Int32
        }
        if dict.keys.contains("SupplementEvidenceCatalogFile") && dict["SupplementEvidenceCatalogFile"] != nil {
            self.supplementEvidenceCatalogFile = dict["SupplementEvidenceCatalogFile"] as! String
        }
        if dict.keys.contains("SupplementEvidenceMaterialFile") && dict["SupplementEvidenceMaterialFile"] != nil {
            self.supplementEvidenceMaterialFile = dict["SupplementEvidenceMaterialFile"] as! String
        }
        if dict.keys.contains("SupplementReasonFile") && dict["SupplementReasonFile"] != nil {
            self.supplementReasonFile = dict["SupplementReasonFile"] as! String
        }
        if dict.keys.contains("SystemVersion") && dict["SystemVersion"] != nil {
            self.systemVersion = dict["SystemVersion"] as! String
        }
        if dict.keys.contains("Town") && dict["Town"] != nil {
            self.town = dict["Town"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! Int32
        }
        if dict.keys.contains("ValidDate") && dict["ValidDate"] != nil {
            self.validDate = dict["ValidDate"] as! Int64
        }
    }
}

public class QueryMaterialResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryMaterialResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryMaterialResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryMaterialListRequest : Tea.TeaModel {
    public var cardNumber: String?

    public var materialId: Int64?

    public var materialVersion: String?

    public var name: String?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var principalName: Int32?

    public var region: Int32?

    public var status: Int32?

    public var systemVersion: String?

    public var type: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cardNumber != nil {
            map["CardNumber"] = self.cardNumber!
        }
        if self.materialId != nil {
            map["MaterialId"] = self.materialId!
        }
        if self.materialVersion != nil {
            map["MaterialVersion"] = self.materialVersion!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.principalName != nil {
            map["PrincipalName"] = self.principalName!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.systemVersion != nil {
            map["SystemVersion"] = self.systemVersion!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CardNumber") && dict["CardNumber"] != nil {
            self.cardNumber = dict["CardNumber"] as! String
        }
        if dict.keys.contains("MaterialId") && dict["MaterialId"] != nil {
            self.materialId = dict["MaterialId"] as! Int64
        }
        if dict.keys.contains("MaterialVersion") && dict["MaterialVersion"] != nil {
            self.materialVersion = dict["MaterialVersion"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PageNum") && dict["PageNum"] != nil {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("PrincipalName") && dict["PrincipalName"] != nil {
            self.principalName = dict["PrincipalName"] as! Int32
        }
        if dict.keys.contains("Region") && dict["Region"] != nil {
            self.region = dict["Region"] as! Int32
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! Int32
        }
        if dict.keys.contains("SystemVersion") && dict["SystemVersion"] != nil {
            self.systemVersion = dict["SystemVersion"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! Int32
        }
    }
}

public class QueryMaterialListResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Trademark : Tea.TeaModel {
            public var cardNumber: String?

            public var contactName: String?

            public var id: Int64?

            public var loaKey: String?

            public var loaStatus: Int32?

            public var materialVersion: String?

            public var name: String?

            public var principalDescription: String?

            public var principalName: Int32?

            public var reason: String?

            public var region: Int32?

            public var status: Int32?

            public var systemVersion: String?

            public var type: Int32?

            public var validDate: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cardNumber != nil {
                    map["CardNumber"] = self.cardNumber!
                }
                if self.contactName != nil {
                    map["ContactName"] = self.contactName!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.loaKey != nil {
                    map["LoaKey"] = self.loaKey!
                }
                if self.loaStatus != nil {
                    map["LoaStatus"] = self.loaStatus!
                }
                if self.materialVersion != nil {
                    map["MaterialVersion"] = self.materialVersion!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.principalDescription != nil {
                    map["PrincipalDescription"] = self.principalDescription!
                }
                if self.principalName != nil {
                    map["PrincipalName"] = self.principalName!
                }
                if self.reason != nil {
                    map["Reason"] = self.reason!
                }
                if self.region != nil {
                    map["Region"] = self.region!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.systemVersion != nil {
                    map["SystemVersion"] = self.systemVersion!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.validDate != nil {
                    map["ValidDate"] = self.validDate!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CardNumber") && dict["CardNumber"] != nil {
                    self.cardNumber = dict["CardNumber"] as! String
                }
                if dict.keys.contains("ContactName") && dict["ContactName"] != nil {
                    self.contactName = dict["ContactName"] as! String
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("LoaKey") && dict["LoaKey"] != nil {
                    self.loaKey = dict["LoaKey"] as! String
                }
                if dict.keys.contains("LoaStatus") && dict["LoaStatus"] != nil {
                    self.loaStatus = dict["LoaStatus"] as! Int32
                }
                if dict.keys.contains("MaterialVersion") && dict["MaterialVersion"] != nil {
                    self.materialVersion = dict["MaterialVersion"] as! String
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("PrincipalDescription") && dict["PrincipalDescription"] != nil {
                    self.principalDescription = dict["PrincipalDescription"] as! String
                }
                if dict.keys.contains("PrincipalName") && dict["PrincipalName"] != nil {
                    self.principalName = dict["PrincipalName"] as! Int32
                }
                if dict.keys.contains("Reason") && dict["Reason"] != nil {
                    self.reason = dict["Reason"] as! String
                }
                if dict.keys.contains("Region") && dict["Region"] != nil {
                    self.region = dict["Region"] as! Int32
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! Int32
                }
                if dict.keys.contains("SystemVersion") && dict["SystemVersion"] != nil {
                    self.systemVersion = dict["SystemVersion"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! Int32
                }
                if dict.keys.contains("ValidDate") && dict["ValidDate"] != nil {
                    self.validDate = dict["ValidDate"] as! Int64
                }
            }
        }
        public var trademark: [QueryMaterialListResponseBody.Data.Trademark]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.trademark != nil {
                var tmp : [Any] = []
                for k in self.trademark! {
                    tmp.append(k.toMap())
                }
                map["Trademark"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Trademark") && dict["Trademark"] != nil {
                var tmp : [QueryMaterialListResponseBody.Data.Trademark] = []
                for v in dict["Trademark"] as! [Any] {
                    var model = QueryMaterialListResponseBody.Data.Trademark()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.trademark = tmp
            }
        }
    }
    public var currentPageNum: Int32?

    public var data: QueryMaterialListResponseBody.Data?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalItemNum: Int32?

    public var totalPageNum: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPageNum != nil {
            map["CurrentPageNum"] = self.currentPageNum!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalItemNum != nil {
            map["TotalItemNum"] = self.totalItemNum!
        }
        if self.totalPageNum != nil {
            map["TotalPageNum"] = self.totalPageNum!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPageNum") && dict["CurrentPageNum"] != nil {
            self.currentPageNum = dict["CurrentPageNum"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = QueryMaterialListResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalItemNum") && dict["TotalItemNum"] != nil {
            self.totalItemNum = dict["TotalItemNum"] as! Int32
        }
        if dict.keys.contains("TotalPageNum") && dict["TotalPageNum"] != nil {
            self.totalPageNum = dict["TotalPageNum"] as! Int32
        }
    }
}

public class QueryMaterialListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryMaterialListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryMaterialListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryMonitorKeywordsRequest : Tea.TeaModel {
    public var keywords: [String]?

    public var ruleType: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.keywords != nil {
            map["Keywords"] = self.keywords!
        }
        if self.ruleType != nil {
            map["RuleType"] = self.ruleType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Keywords") && dict["Keywords"] != nil {
            self.keywords = dict["Keywords"] as! [String]
        }
        if dict.keys.contains("RuleType") && dict["RuleType"] != nil {
            self.ruleType = dict["RuleType"] as! Int32
        }
    }
}

public class QueryMonitorKeywordsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var keywords: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.keywords != nil {
                map["Keywords"] = self.keywords!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Keywords") && dict["Keywords"] != nil {
                self.keywords = dict["Keywords"] as! [String]
            }
        }
    }
    public var data: QueryMonitorKeywordsResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = QueryMonitorKeywordsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class QueryMonitorKeywordsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryMonitorKeywordsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryMonitorKeywordsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryOfficialFileCustomListRequest : Tea.TeaModel {
    public var pageNum: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNum") && dict["PageNum"] != nil {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class QueryOfficialFileCustomListResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class CustomList : Tea.TeaModel {
            public var createTime: Int64?

            public var downloadUrl: String?

            public var endAcceptTime: Int64?

            public var expireTime: Int64?

            public var remark: String?

            public var startAcceptTime: Int64?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.downloadUrl != nil {
                    map["DownloadUrl"] = self.downloadUrl!
                }
                if self.endAcceptTime != nil {
                    map["EndAcceptTime"] = self.endAcceptTime!
                }
                if self.expireTime != nil {
                    map["ExpireTime"] = self.expireTime!
                }
                if self.remark != nil {
                    map["Remark"] = self.remark!
                }
                if self.startAcceptTime != nil {
                    map["StartAcceptTime"] = self.startAcceptTime!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("DownloadUrl") && dict["DownloadUrl"] != nil {
                    self.downloadUrl = dict["DownloadUrl"] as! String
                }
                if dict.keys.contains("EndAcceptTime") && dict["EndAcceptTime"] != nil {
                    self.endAcceptTime = dict["EndAcceptTime"] as! Int64
                }
                if dict.keys.contains("ExpireTime") && dict["ExpireTime"] != nil {
                    self.expireTime = dict["ExpireTime"] as! Int64
                }
                if dict.keys.contains("Remark") && dict["Remark"] != nil {
                    self.remark = dict["Remark"] as! String
                }
                if dict.keys.contains("StartAcceptTime") && dict["StartAcceptTime"] != nil {
                    self.startAcceptTime = dict["StartAcceptTime"] as! Int64
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var customList: [QueryOfficialFileCustomListResponseBody.Data.CustomList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.customList != nil {
                var tmp : [Any] = []
                for k in self.customList! {
                    tmp.append(k.toMap())
                }
                map["CustomList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CustomList") && dict["CustomList"] != nil {
                var tmp : [QueryOfficialFileCustomListResponseBody.Data.CustomList] = []
                for v in dict["CustomList"] as! [Any] {
                    var model = QueryOfficialFileCustomListResponseBody.Data.CustomList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.customList = tmp
            }
        }
    }
    public var currentPageNum: Int32?

    public var data: QueryOfficialFileCustomListResponseBody.Data?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalItemNum: Int32?

    public var totalPageNum: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPageNum != nil {
            map["CurrentPageNum"] = self.currentPageNum!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalItemNum != nil {
            map["TotalItemNum"] = self.totalItemNum!
        }
        if self.totalPageNum != nil {
            map["TotalPageNum"] = self.totalPageNum!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPageNum") && dict["CurrentPageNum"] != nil {
            self.currentPageNum = dict["CurrentPageNum"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = QueryOfficialFileCustomListResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalItemNum") && dict["TotalItemNum"] != nil {
            self.totalItemNum = dict["TotalItemNum"] as! Int32
        }
        if dict.keys.contains("TotalPageNum") && dict["TotalPageNum"] != nil {
            self.totalPageNum = dict["TotalPageNum"] as! Int32
        }
    }
}

public class QueryOfficialFileCustomListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryOfficialFileCustomListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryOfficialFileCustomListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryOrderLogisticsListRequest : Tea.TeaModel {
    public var fileType: String?

    public var pageNum: Int64?

    public var pageSize: Int64?

    public var produceOrderId: String?

    public var registerNumber: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileType != nil {
            map["FileType"] = self.fileType!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.produceOrderId != nil {
            map["ProduceOrderId"] = self.produceOrderId!
        }
        if self.registerNumber != nil {
            map["RegisterNumber"] = self.registerNumber!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FileType") && dict["FileType"] != nil {
            self.fileType = dict["FileType"] as! String
        }
        if dict.keys.contains("PageNum") && dict["PageNum"] != nil {
            self.pageNum = dict["PageNum"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("ProduceOrderId") && dict["ProduceOrderId"] != nil {
            self.produceOrderId = dict["ProduceOrderId"] as! String
        }
        if dict.keys.contains("RegisterNumber") && dict["RegisterNumber"] != nil {
            self.registerNumber = dict["RegisterNumber"] as! String
        }
    }
}

public class QueryOrderLogisticsListResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var bizId: String?

        public var fileIdentifier: String?

        public var fileType: String?

        public var logisticsNo: String?

        public var produceOrderId: String?

        public var tmIcon: String?

        public var tmName: String?

        public var tmNumber: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bizId != nil {
                map["BizId"] = self.bizId!
            }
            if self.fileIdentifier != nil {
                map["FileIdentifier"] = self.fileIdentifier!
            }
            if self.fileType != nil {
                map["FileType"] = self.fileType!
            }
            if self.logisticsNo != nil {
                map["LogisticsNo"] = self.logisticsNo!
            }
            if self.produceOrderId != nil {
                map["ProduceOrderId"] = self.produceOrderId!
            }
            if self.tmIcon != nil {
                map["TmIcon"] = self.tmIcon!
            }
            if self.tmName != nil {
                map["TmName"] = self.tmName!
            }
            if self.tmNumber != nil {
                map["TmNumber"] = self.tmNumber!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BizId") && dict["BizId"] != nil {
                self.bizId = dict["BizId"] as! String
            }
            if dict.keys.contains("FileIdentifier") && dict["FileIdentifier"] != nil {
                self.fileIdentifier = dict["FileIdentifier"] as! String
            }
            if dict.keys.contains("FileType") && dict["FileType"] != nil {
                self.fileType = dict["FileType"] as! String
            }
            if dict.keys.contains("LogisticsNo") && dict["LogisticsNo"] != nil {
                self.logisticsNo = dict["LogisticsNo"] as! String
            }
            if dict.keys.contains("ProduceOrderId") && dict["ProduceOrderId"] != nil {
                self.produceOrderId = dict["ProduceOrderId"] as! String
            }
            if dict.keys.contains("TmIcon") && dict["TmIcon"] != nil {
                self.tmIcon = dict["TmIcon"] as! String
            }
            if dict.keys.contains("TmName") && dict["TmName"] != nil {
                self.tmName = dict["TmName"] as! String
            }
            if dict.keys.contains("TmNumber") && dict["TmNumber"] != nil {
                self.tmNumber = dict["TmNumber"] as! String
            }
        }
    }
    public var currentPageNum: Int32?

    public var data: [QueryOrderLogisticsListResponseBody.Data]?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalItemNum: Int32?

    public var totalPageNum: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPageNum != nil {
            map["CurrentPageNum"] = self.currentPageNum!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalItemNum != nil {
            map["TotalItemNum"] = self.totalItemNum!
        }
        if self.totalPageNum != nil {
            map["TotalPageNum"] = self.totalPageNum!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPageNum") && dict["CurrentPageNum"] != nil {
            self.currentPageNum = dict["CurrentPageNum"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [QueryOrderLogisticsListResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = QueryOrderLogisticsListResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalItemNum") && dict["TotalItemNum"] != nil {
            self.totalItemNum = dict["TotalItemNum"] as! Int32
        }
        if dict.keys.contains("TotalPageNum") && dict["TotalPageNum"] != nil {
            self.totalPageNum = dict["TotalPageNum"] as! Int32
        }
    }
}

public class QueryOrderLogisticsListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryOrderLogisticsListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryOrderLogisticsListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryOssResourcesRequest : Tea.TeaModel {
    public var bizId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
    }
}

public class QueryOssResourcesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class TaskList : Tea.TeaModel {
            public var bizId: String?

            public var createTime: Int64?

            public var name: String?

            public var ossUrl: String?

            public var updateTime: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bizId != nil {
                    map["BizId"] = self.bizId!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.ossUrl != nil {
                    map["OssUrl"] = self.ossUrl!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BizId") && dict["BizId"] != nil {
                    self.bizId = dict["BizId"] as! String
                }
                if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("OssUrl") && dict["OssUrl"] != nil {
                    self.ossUrl = dict["OssUrl"] as! String
                }
                if dict.keys.contains("UpdateTime") && dict["UpdateTime"] != nil {
                    self.updateTime = dict["UpdateTime"] as! Int64
                }
            }
        }
        public var taskList: [QueryOssResourcesResponseBody.Data.TaskList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.taskList != nil {
                var tmp : [Any] = []
                for k in self.taskList! {
                    tmp.append(k.toMap())
                }
                map["TaskList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TaskList") && dict["TaskList"] != nil {
                var tmp : [QueryOssResourcesResponseBody.Data.TaskList] = []
                for v in dict["TaskList"] as! [Any] {
                    var model = QueryOssResourcesResponseBody.Data.TaskList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.taskList = tmp
            }
        }
    }
    public var data: QueryOssResourcesResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = QueryOssResourcesResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class QueryOssResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryOssResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryOssResourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryProduceDetailRequest : Tea.TeaModel {
    public var applyNo: String?

    public var bizId: String?

    public var orderId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applyNo != nil {
            map["ApplyNo"] = self.applyNo!
        }
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApplyNo") && dict["ApplyNo"] != nil {
            self.applyNo = dict["ApplyNo"] as! String
        }
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
            self.orderId = dict["OrderId"] as! String
        }
    }
}

public class QueryProduceDetailResponseBody : Tea.TeaModel {
    public class Flags : Tea.TeaModel {
        public var flags: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.flags != nil {
                map["Flags"] = self.flags!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Flags") && dict["Flags"] != nil {
                self.flags = dict["Flags"] as! [String]
            }
        }
    }
    public class LeafCodes : Tea.TeaModel {
        public class LeafCodes : Tea.TeaModel {
            public var code: String?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Code") && dict["Code"] != nil {
                    self.code = dict["Code"] as! String
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
            }
        }
        public var leafCodes: [QueryProduceDetailResponseBody.LeafCodes.LeafCodes]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.leafCodes != nil {
                var tmp : [Any] = []
                for k in self.leafCodes! {
                    tmp.append(k.toMap())
                }
                map["LeafCodes"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LeafCodes") && dict["LeafCodes"] != nil {
                var tmp : [QueryProduceDetailResponseBody.LeafCodes.LeafCodes] = []
                for v in dict["LeafCodes"] as! [Any] {
                    var model = QueryProduceDetailResponseBody.LeafCodes.LeafCodes()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.leafCodes = tmp
            }
        }
    }
    public class MaterialDetail : Tea.TeaModel {
        public var address: String?

        public var businessLicenceUrl: String?

        public var cardNumber: String?

        public var city: String?

        public var contactAddress: String?

        public var contactEmail: String?

        public var contactName: String?

        public var contactNumber: String?

        public var contactZipcode: String?

        public var country: String?

        public var EAddress: String?

        public var EName: String?

        public var expirationDate: String?

        public var idCardUrl: String?

        public var loaUrl: String?

        public var name: String?

        public var passportUrl: String?

        public var province: String?

        public var region: Int32?

        public var status: Int32?

        public var town: String?

        public var type: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.address != nil {
                map["Address"] = self.address!
            }
            if self.businessLicenceUrl != nil {
                map["BusinessLicenceUrl"] = self.businessLicenceUrl!
            }
            if self.cardNumber != nil {
                map["CardNumber"] = self.cardNumber!
            }
            if self.city != nil {
                map["City"] = self.city!
            }
            if self.contactAddress != nil {
                map["ContactAddress"] = self.contactAddress!
            }
            if self.contactEmail != nil {
                map["ContactEmail"] = self.contactEmail!
            }
            if self.contactName != nil {
                map["ContactName"] = self.contactName!
            }
            if self.contactNumber != nil {
                map["ContactNumber"] = self.contactNumber!
            }
            if self.contactZipcode != nil {
                map["ContactZipcode"] = self.contactZipcode!
            }
            if self.country != nil {
                map["Country"] = self.country!
            }
            if self.EAddress != nil {
                map["EAddress"] = self.EAddress!
            }
            if self.EName != nil {
                map["EName"] = self.EName!
            }
            if self.expirationDate != nil {
                map["ExpirationDate"] = self.expirationDate!
            }
            if self.idCardUrl != nil {
                map["IdCardUrl"] = self.idCardUrl!
            }
            if self.loaUrl != nil {
                map["LoaUrl"] = self.loaUrl!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.passportUrl != nil {
                map["PassportUrl"] = self.passportUrl!
            }
            if self.province != nil {
                map["Province"] = self.province!
            }
            if self.region != nil {
                map["Region"] = self.region!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.town != nil {
                map["Town"] = self.town!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Address") && dict["Address"] != nil {
                self.address = dict["Address"] as! String
            }
            if dict.keys.contains("BusinessLicenceUrl") && dict["BusinessLicenceUrl"] != nil {
                self.businessLicenceUrl = dict["BusinessLicenceUrl"] as! String
            }
            if dict.keys.contains("CardNumber") && dict["CardNumber"] != nil {
                self.cardNumber = dict["CardNumber"] as! String
            }
            if dict.keys.contains("City") && dict["City"] != nil {
                self.city = dict["City"] as! String
            }
            if dict.keys.contains("ContactAddress") && dict["ContactAddress"] != nil {
                self.contactAddress = dict["ContactAddress"] as! String
            }
            if dict.keys.contains("ContactEmail") && dict["ContactEmail"] != nil {
                self.contactEmail = dict["ContactEmail"] as! String
            }
            if dict.keys.contains("ContactName") && dict["ContactName"] != nil {
                self.contactName = dict["ContactName"] as! String
            }
            if dict.keys.contains("ContactNumber") && dict["ContactNumber"] != nil {
                self.contactNumber = dict["ContactNumber"] as! String
            }
            if dict.keys.contains("ContactZipcode") && dict["ContactZipcode"] != nil {
                self.contactZipcode = dict["ContactZipcode"] as! String
            }
            if dict.keys.contains("Country") && dict["Country"] != nil {
                self.country = dict["Country"] as! String
            }
            if dict.keys.contains("EAddress") && dict["EAddress"] != nil {
                self.EAddress = dict["EAddress"] as! String
            }
            if dict.keys.contains("EName") && dict["EName"] != nil {
                self.EName = dict["EName"] as! String
            }
            if dict.keys.contains("ExpirationDate") && dict["ExpirationDate"] != nil {
                self.expirationDate = dict["ExpirationDate"] as! String
            }
            if dict.keys.contains("IdCardUrl") && dict["IdCardUrl"] != nil {
                self.idCardUrl = dict["IdCardUrl"] as! String
            }
            if dict.keys.contains("LoaUrl") && dict["LoaUrl"] != nil {
                self.loaUrl = dict["LoaUrl"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("PassportUrl") && dict["PassportUrl"] != nil {
                self.passportUrl = dict["PassportUrl"] as! String
            }
            if dict.keys.contains("Province") && dict["Province"] != nil {
                self.province = dict["Province"] as! String
            }
            if dict.keys.contains("Region") && dict["Region"] != nil {
                self.region = dict["Region"] as! Int32
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("Town") && dict["Town"] != nil {
                self.town = dict["Town"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! Int32
            }
        }
    }
    public class RootCode : Tea.TeaModel {
        public var code: String?

        public var name: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") && dict["Code"] != nil {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
        }
    }
    public var acceptUrl: String?

    public var agreementId: String?

    public var bizId: String?

    public var cnInfoUrl: String?

    public var extendInfo: [String: Any]?

    public var flags: QueryProduceDetailResponseBody.Flags?

    public var grayIconUrl: String?

    public var issueDate: String?

    public var leafCodes: QueryProduceDetailResponseBody.LeafCodes?

    public var loaUrl: String?

    public var materialDetail: QueryProduceDetailResponseBody.MaterialDetail?

    public var note: String?

    public var orderId: String?

    public var principalName: Int32?

    public var requestId: String?

    public var rootCode: QueryProduceDetailResponseBody.RootCode?

    public var status: Int32?

    public var submitCount: Int32?

    public var tmIcon: String?

    public var tmName: String?

    public var tmNameType: Int32?

    public var tmNumber: String?

    public var tmOrderId: String?

    public var type: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.flags?.validate()
        try self.leafCodes?.validate()
        try self.materialDetail?.validate()
        try self.rootCode?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptUrl != nil {
            map["AcceptUrl"] = self.acceptUrl!
        }
        if self.agreementId != nil {
            map["AgreementId"] = self.agreementId!
        }
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.cnInfoUrl != nil {
            map["CnInfoUrl"] = self.cnInfoUrl!
        }
        if self.extendInfo != nil {
            map["ExtendInfo"] = self.extendInfo!
        }
        if self.flags != nil {
            map["Flags"] = self.flags?.toMap()
        }
        if self.grayIconUrl != nil {
            map["GrayIconUrl"] = self.grayIconUrl!
        }
        if self.issueDate != nil {
            map["IssueDate"] = self.issueDate!
        }
        if self.leafCodes != nil {
            map["LeafCodes"] = self.leafCodes?.toMap()
        }
        if self.loaUrl != nil {
            map["LoaUrl"] = self.loaUrl!
        }
        if self.materialDetail != nil {
            map["MaterialDetail"] = self.materialDetail?.toMap()
        }
        if self.note != nil {
            map["Note"] = self.note!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.principalName != nil {
            map["PrincipalName"] = self.principalName!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.rootCode != nil {
            map["RootCode"] = self.rootCode?.toMap()
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.submitCount != nil {
            map["SubmitCount"] = self.submitCount!
        }
        if self.tmIcon != nil {
            map["TmIcon"] = self.tmIcon!
        }
        if self.tmName != nil {
            map["TmName"] = self.tmName!
        }
        if self.tmNameType != nil {
            map["TmNameType"] = self.tmNameType!
        }
        if self.tmNumber != nil {
            map["TmNumber"] = self.tmNumber!
        }
        if self.tmOrderId != nil {
            map["TmOrderId"] = self.tmOrderId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptUrl") && dict["AcceptUrl"] != nil {
            self.acceptUrl = dict["AcceptUrl"] as! String
        }
        if dict.keys.contains("AgreementId") && dict["AgreementId"] != nil {
            self.agreementId = dict["AgreementId"] as! String
        }
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("CnInfoUrl") && dict["CnInfoUrl"] != nil {
            self.cnInfoUrl = dict["CnInfoUrl"] as! String
        }
        if dict.keys.contains("ExtendInfo") && dict["ExtendInfo"] != nil {
            self.extendInfo = dict["ExtendInfo"] as! [String: Any]
        }
        if dict.keys.contains("Flags") && dict["Flags"] != nil {
            var model = QueryProduceDetailResponseBody.Flags()
            model.fromMap(dict["Flags"] as! [String: Any])
            self.flags = model
        }
        if dict.keys.contains("GrayIconUrl") && dict["GrayIconUrl"] != nil {
            self.grayIconUrl = dict["GrayIconUrl"] as! String
        }
        if dict.keys.contains("IssueDate") && dict["IssueDate"] != nil {
            self.issueDate = dict["IssueDate"] as! String
        }
        if dict.keys.contains("LeafCodes") && dict["LeafCodes"] != nil {
            var model = QueryProduceDetailResponseBody.LeafCodes()
            model.fromMap(dict["LeafCodes"] as! [String: Any])
            self.leafCodes = model
        }
        if dict.keys.contains("LoaUrl") && dict["LoaUrl"] != nil {
            self.loaUrl = dict["LoaUrl"] as! String
        }
        if dict.keys.contains("MaterialDetail") && dict["MaterialDetail"] != nil {
            var model = QueryProduceDetailResponseBody.MaterialDetail()
            model.fromMap(dict["MaterialDetail"] as! [String: Any])
            self.materialDetail = model
        }
        if dict.keys.contains("Note") && dict["Note"] != nil {
            self.note = dict["Note"] as! String
        }
        if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
            self.orderId = dict["OrderId"] as! String
        }
        if dict.keys.contains("PrincipalName") && dict["PrincipalName"] != nil {
            self.principalName = dict["PrincipalName"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RootCode") && dict["RootCode"] != nil {
            var model = QueryProduceDetailResponseBody.RootCode()
            model.fromMap(dict["RootCode"] as! [String: Any])
            self.rootCode = model
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! Int32
        }
        if dict.keys.contains("SubmitCount") && dict["SubmitCount"] != nil {
            self.submitCount = dict["SubmitCount"] as! Int32
        }
        if dict.keys.contains("TmIcon") && dict["TmIcon"] != nil {
            self.tmIcon = dict["TmIcon"] as! String
        }
        if dict.keys.contains("TmName") && dict["TmName"] != nil {
            self.tmName = dict["TmName"] as! String
        }
        if dict.keys.contains("TmNameType") && dict["TmNameType"] != nil {
            self.tmNameType = dict["TmNameType"] as! Int32
        }
        if dict.keys.contains("TmNumber") && dict["TmNumber"] != nil {
            self.tmNumber = dict["TmNumber"] as! String
        }
        if dict.keys.contains("TmOrderId") && dict["TmOrderId"] != nil {
            self.tmOrderId = dict["TmOrderId"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! Int32
        }
    }
}

public class QueryProduceDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryProduceDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryProduceDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryProduceListRequest : Tea.TeaModel {
    public var bizId: String?

    public var createTimeLeft: Int64?

    public var createTimeRight: Int64?

    public var materialName: String?

    public var orderId: String?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var status: Int32?

    public var tmName: String?

    public var tmNumber: String?

    public var type: Int32?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.createTimeLeft != nil {
            map["CreateTimeLeft"] = self.createTimeLeft!
        }
        if self.createTimeRight != nil {
            map["CreateTimeRight"] = self.createTimeRight!
        }
        if self.materialName != nil {
            map["MaterialName"] = self.materialName!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.tmName != nil {
            map["TmName"] = self.tmName!
        }
        if self.tmNumber != nil {
            map["TmNumber"] = self.tmNumber!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("CreateTimeLeft") && dict["CreateTimeLeft"] != nil {
            self.createTimeLeft = dict["CreateTimeLeft"] as! Int64
        }
        if dict.keys.contains("CreateTimeRight") && dict["CreateTimeRight"] != nil {
            self.createTimeRight = dict["CreateTimeRight"] as! Int64
        }
        if dict.keys.contains("MaterialName") && dict["MaterialName"] != nil {
            self.materialName = dict["MaterialName"] as! String
        }
        if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
            self.orderId = dict["OrderId"] as! String
        }
        if dict.keys.contains("PageNum") && dict["PageNum"] != nil {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! Int32
        }
        if dict.keys.contains("TmName") && dict["TmName"] != nil {
            self.tmName = dict["TmName"] as! String
        }
        if dict.keys.contains("TmNumber") && dict["TmNumber"] != nil {
            self.tmNumber = dict["TmNumber"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! Int32
        }
        if dict.keys.contains("UserId") && dict["UserId"] != nil {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class QueryProduceListResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class TmProduces : Tea.TeaModel {
            public class Classification : Tea.TeaModel {
                public var classificationCode: String?

                public var classificationName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.classificationCode != nil {
                        map["ClassificationCode"] = self.classificationCode!
                    }
                    if self.classificationName != nil {
                        map["ClassificationName"] = self.classificationName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ClassificationCode") && dict["ClassificationCode"] != nil {
                        self.classificationCode = dict["ClassificationCode"] as! String
                    }
                    if dict.keys.contains("ClassificationName") && dict["ClassificationName"] != nil {
                        self.classificationName = dict["ClassificationName"] as! String
                    }
                }
            }
            public var agreementId: String?

            public var bizId: String?

            public var classification: QueryProduceListResponseBody.Data.TmProduces.Classification?

            public var createTime: Int64?

            public var loaUrl: String?

            public var materialName: String?

            public var note: String?

            public var orderId: String?

            public var orderPrice: Double?

            public var principalName: Int32?

            public var receiptUrl: String?

            public var status: Int32?

            public var submitCount: Int32?

            public var tmIcon: String?

            public var tmName: String?

            public var tmNumber: String?

            public var type: Int32?

            public var updateTime: Int64?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.classification?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.agreementId != nil {
                    map["AgreementId"] = self.agreementId!
                }
                if self.bizId != nil {
                    map["BizId"] = self.bizId!
                }
                if self.classification != nil {
                    map["Classification"] = self.classification?.toMap()
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.loaUrl != nil {
                    map["LoaUrl"] = self.loaUrl!
                }
                if self.materialName != nil {
                    map["MaterialName"] = self.materialName!
                }
                if self.note != nil {
                    map["Note"] = self.note!
                }
                if self.orderId != nil {
                    map["OrderId"] = self.orderId!
                }
                if self.orderPrice != nil {
                    map["OrderPrice"] = self.orderPrice!
                }
                if self.principalName != nil {
                    map["PrincipalName"] = self.principalName!
                }
                if self.receiptUrl != nil {
                    map["ReceiptUrl"] = self.receiptUrl!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.submitCount != nil {
                    map["SubmitCount"] = self.submitCount!
                }
                if self.tmIcon != nil {
                    map["TmIcon"] = self.tmIcon!
                }
                if self.tmName != nil {
                    map["TmName"] = self.tmName!
                }
                if self.tmNumber != nil {
                    map["TmNumber"] = self.tmNumber!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AgreementId") && dict["AgreementId"] != nil {
                    self.agreementId = dict["AgreementId"] as! String
                }
                if dict.keys.contains("BizId") && dict["BizId"] != nil {
                    self.bizId = dict["BizId"] as! String
                }
                if dict.keys.contains("Classification") && dict["Classification"] != nil {
                    var model = QueryProduceListResponseBody.Data.TmProduces.Classification()
                    model.fromMap(dict["Classification"] as! [String: Any])
                    self.classification = model
                }
                if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("LoaUrl") && dict["LoaUrl"] != nil {
                    self.loaUrl = dict["LoaUrl"] as! String
                }
                if dict.keys.contains("MaterialName") && dict["MaterialName"] != nil {
                    self.materialName = dict["MaterialName"] as! String
                }
                if dict.keys.contains("Note") && dict["Note"] != nil {
                    self.note = dict["Note"] as! String
                }
                if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
                    self.orderId = dict["OrderId"] as! String
                }
                if dict.keys.contains("OrderPrice") && dict["OrderPrice"] != nil {
                    self.orderPrice = dict["OrderPrice"] as! Double
                }
                if dict.keys.contains("PrincipalName") && dict["PrincipalName"] != nil {
                    self.principalName = dict["PrincipalName"] as! Int32
                }
                if dict.keys.contains("ReceiptUrl") && dict["ReceiptUrl"] != nil {
                    self.receiptUrl = dict["ReceiptUrl"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! Int32
                }
                if dict.keys.contains("SubmitCount") && dict["SubmitCount"] != nil {
                    self.submitCount = dict["SubmitCount"] as! Int32
                }
                if dict.keys.contains("TmIcon") && dict["TmIcon"] != nil {
                    self.tmIcon = dict["TmIcon"] as! String
                }
                if dict.keys.contains("TmName") && dict["TmName"] != nil {
                    self.tmName = dict["TmName"] as! String
                }
                if dict.keys.contains("TmNumber") && dict["TmNumber"] != nil {
                    self.tmNumber = dict["TmNumber"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! Int32
                }
                if dict.keys.contains("UpdateTime") && dict["UpdateTime"] != nil {
                    self.updateTime = dict["UpdateTime"] as! Int64
                }
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! String
                }
            }
        }
        public var tmProduces: [QueryProduceListResponseBody.Data.TmProduces]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tmProduces != nil {
                var tmp : [Any] = []
                for k in self.tmProduces! {
                    tmp.append(k.toMap())
                }
                map["TmProduces"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TmProduces") && dict["TmProduces"] != nil {
                var tmp : [QueryProduceListResponseBody.Data.TmProduces] = []
                for v in dict["TmProduces"] as! [Any] {
                    var model = QueryProduceListResponseBody.Data.TmProduces()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tmProduces = tmp
            }
        }
    }
    public var currentPageNum: Int32?

    public var data: QueryProduceListResponseBody.Data?

    public var nextPage: Bool?

    public var pageSize: Int32?

    public var prePage: Bool?

    public var requestId: String?

    public var totalItemNum: Int32?

    public var totalPageNum: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPageNum != nil {
            map["CurrentPageNum"] = self.currentPageNum!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.nextPage != nil {
            map["NextPage"] = self.nextPage!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.prePage != nil {
            map["PrePage"] = self.prePage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalItemNum != nil {
            map["TotalItemNum"] = self.totalItemNum!
        }
        if self.totalPageNum != nil {
            map["TotalPageNum"] = self.totalPageNum!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPageNum") && dict["CurrentPageNum"] != nil {
            self.currentPageNum = dict["CurrentPageNum"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = QueryProduceListResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("NextPage") && dict["NextPage"] != nil {
            self.nextPage = dict["NextPage"] as! Bool
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("PrePage") && dict["PrePage"] != nil {
            self.prePage = dict["PrePage"] as! Bool
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalItemNum") && dict["TotalItemNum"] != nil {
            self.totalItemNum = dict["TotalItemNum"] as! Int32
        }
        if dict.keys.contains("TotalPageNum") && dict["TotalPageNum"] != nil {
            self.totalPageNum = dict["TotalPageNum"] as! Int32
        }
    }
}

public class QueryProduceListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryProduceListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryProduceListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryQrCodeUploadStatusRequest : Tea.TeaModel {
    public var fieldKey: String?

    public var ossKey: String?

    public var uuid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fieldKey != nil {
            map["FieldKey"] = self.fieldKey!
        }
        if self.ossKey != nil {
            map["OssKey"] = self.ossKey!
        }
        if self.uuid != nil {
            map["Uuid"] = self.uuid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FieldKey") && dict["FieldKey"] != nil {
            self.fieldKey = dict["FieldKey"] as! String
        }
        if dict.keys.contains("OssKey") && dict["OssKey"] != nil {
            self.ossKey = dict["OssKey"] as! String
        }
        if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
            self.uuid = dict["Uuid"] as! String
        }
    }
}

public class QueryQrCodeUploadStatusResponseBody : Tea.TeaModel {
    public var ossKey: String?

    public var ossUrl: String?

    public var requestId: String?

    public var status: Int32?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ossKey != nil {
            map["OssKey"] = self.ossKey!
        }
        if self.ossUrl != nil {
            map["OssUrl"] = self.ossUrl!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OssKey") && dict["OssKey"] != nil {
            self.ossKey = dict["OssKey"] as! String
        }
        if dict.keys.contains("OssUrl") && dict["OssUrl"] != nil {
            self.ossUrl = dict["OssUrl"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! Int32
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class QueryQrCodeUploadStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryQrCodeUploadStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryQrCodeUploadStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QuerySbjRuleRequest : Tea.TeaModel {
    public var bizType: String?

    public var ruleId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizType != nil {
            map["BizType"] = self.bizType!
        }
        if self.ruleId != nil {
            map["RuleId"] = self.ruleId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizType") && dict["BizType"] != nil {
            self.bizType = dict["BizType"] as! String
        }
        if dict.keys.contains("RuleId") && dict["RuleId"] != nil {
            self.ruleId = dict["RuleId"] as! String
        }
    }
}

public class QuerySbjRuleResponseBody : Tea.TeaModel {
    public class SbjRuleList : Tea.TeaModel {
        public class SbjRuleItem : Tea.TeaModel {
            public class FrontendOptions : Tea.TeaModel {
                public class FrontendOption : Tea.TeaModel {
                    public var title: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.title != nil {
                            map["title"] = self.title!
                        }
                        if self.value != nil {
                            map["value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("title") && dict["title"] != nil {
                            self.title = dict["title"] as! String
                        }
                        if dict.keys.contains("value") && dict["value"] != nil {
                            self.value = dict["value"] as! String
                        }
                    }
                }
                public var frontendOption: [QuerySbjRuleResponseBody.SbjRuleList.SbjRuleItem.FrontendOptions.FrontendOption]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.frontendOption != nil {
                        var tmp : [Any] = []
                        for k in self.frontendOption! {
                            tmp.append(k.toMap())
                        }
                        map["FrontendOption"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("FrontendOption") && dict["FrontendOption"] != nil {
                        var tmp : [QuerySbjRuleResponseBody.SbjRuleList.SbjRuleItem.FrontendOptions.FrontendOption] = []
                        for v in dict["FrontendOption"] as! [Any] {
                            var model = QuerySbjRuleResponseBody.SbjRuleList.SbjRuleItem.FrontendOptions.FrontendOption()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.frontendOption = tmp
                    }
                }
            }
            public var defaultValue: String?

            public var espExtFieldName: String?

            public var fieldName: String?

            public var fileType: String?

            public var frontendOptions: QuerySbjRuleResponseBody.SbjRuleList.SbjRuleItem.FrontendOptions?

            public var frontendType: String?

            public var requiredExpression: String?

            public var sbjFieldId: String?

            public var showExpression: String?

            public var trademarkServiceExpression: String?

            public var validateRegularExpression: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.frontendOptions?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.defaultValue != nil {
                    map["DefaultValue"] = self.defaultValue!
                }
                if self.espExtFieldName != nil {
                    map["EspExtFieldName"] = self.espExtFieldName!
                }
                if self.fieldName != nil {
                    map["FieldName"] = self.fieldName!
                }
                if self.fileType != nil {
                    map["FileType"] = self.fileType!
                }
                if self.frontendOptions != nil {
                    map["FrontendOptions"] = self.frontendOptions?.toMap()
                }
                if self.frontendType != nil {
                    map["FrontendType"] = self.frontendType!
                }
                if self.requiredExpression != nil {
                    map["RequiredExpression"] = self.requiredExpression!
                }
                if self.sbjFieldId != nil {
                    map["SbjFieldId"] = self.sbjFieldId!
                }
                if self.showExpression != nil {
                    map["ShowExpression"] = self.showExpression!
                }
                if self.trademarkServiceExpression != nil {
                    map["TrademarkServiceExpression"] = self.trademarkServiceExpression!
                }
                if self.validateRegularExpression != nil {
                    map["ValidateRegularExpression"] = self.validateRegularExpression!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DefaultValue") && dict["DefaultValue"] != nil {
                    self.defaultValue = dict["DefaultValue"] as! String
                }
                if dict.keys.contains("EspExtFieldName") && dict["EspExtFieldName"] != nil {
                    self.espExtFieldName = dict["EspExtFieldName"] as! String
                }
                if dict.keys.contains("FieldName") && dict["FieldName"] != nil {
                    self.fieldName = dict["FieldName"] as! String
                }
                if dict.keys.contains("FileType") && dict["FileType"] != nil {
                    self.fileType = dict["FileType"] as! String
                }
                if dict.keys.contains("FrontendOptions") && dict["FrontendOptions"] != nil {
                    var model = QuerySbjRuleResponseBody.SbjRuleList.SbjRuleItem.FrontendOptions()
                    model.fromMap(dict["FrontendOptions"] as! [String: Any])
                    self.frontendOptions = model
                }
                if dict.keys.contains("FrontendType") && dict["FrontendType"] != nil {
                    self.frontendType = dict["FrontendType"] as! String
                }
                if dict.keys.contains("RequiredExpression") && dict["RequiredExpression"] != nil {
                    self.requiredExpression = dict["RequiredExpression"] as! String
                }
                if dict.keys.contains("SbjFieldId") && dict["SbjFieldId"] != nil {
                    self.sbjFieldId = dict["SbjFieldId"] as! String
                }
                if dict.keys.contains("ShowExpression") && dict["ShowExpression"] != nil {
                    self.showExpression = dict["ShowExpression"] as! String
                }
                if dict.keys.contains("TrademarkServiceExpression") && dict["TrademarkServiceExpression"] != nil {
                    self.trademarkServiceExpression = dict["TrademarkServiceExpression"] as! String
                }
                if dict.keys.contains("ValidateRegularExpression") && dict["ValidateRegularExpression"] != nil {
                    self.validateRegularExpression = dict["ValidateRegularExpression"] as! String
                }
            }
        }
        public var sbjRuleItem: [QuerySbjRuleResponseBody.SbjRuleList.SbjRuleItem]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.sbjRuleItem != nil {
                var tmp : [Any] = []
                for k in self.sbjRuleItem! {
                    tmp.append(k.toMap())
                }
                map["SbjRuleItem"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SbjRuleItem") && dict["SbjRuleItem"] != nil {
                var tmp : [QuerySbjRuleResponseBody.SbjRuleList.SbjRuleItem] = []
                for v in dict["SbjRuleItem"] as! [Any] {
                    var model = QuerySbjRuleResponseBody.SbjRuleList.SbjRuleItem()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.sbjRuleItem = tmp
            }
        }
    }
    public var bizType: String?

    public var requestId: String?

    public var ruleId: String?

    public var sbjRuleList: QuerySbjRuleResponseBody.SbjRuleList?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.sbjRuleList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizType != nil {
            map["BizType"] = self.bizType!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.ruleId != nil {
            map["RuleId"] = self.ruleId!
        }
        if self.sbjRuleList != nil {
            map["SbjRuleList"] = self.sbjRuleList?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizType") && dict["BizType"] != nil {
            self.bizType = dict["BizType"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RuleId") && dict["RuleId"] != nil {
            self.ruleId = dict["RuleId"] as! String
        }
        if dict.keys.contains("SbjRuleList") && dict["SbjRuleList"] != nil {
            var model = QuerySbjRuleResponseBody.SbjRuleList()
            model.fromMap(dict["SbjRuleList"] as! [String: Any])
            self.sbjRuleList = model
        }
    }
}

public class QuerySbjRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QuerySbjRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QuerySbjRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QuerySupplementDetailRequest : Tea.TeaModel {
    public var id: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
    }
}

public class QuerySupplementDetailResponseBody : Tea.TeaModel {
    public class FileTemplateUrls : Tea.TeaModel {
        public var fileTemplateUrls: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fileTemplateUrls != nil {
                map["FileTemplateUrls"] = self.fileTemplateUrls!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FileTemplateUrls") && dict["FileTemplateUrls"] != nil {
                self.fileTemplateUrls = dict["FileTemplateUrls"] as! [String]
            }
        }
    }
    public var acceptDeadTime: Int64?

    public var acceptTime: Int64?

    public var content: String?

    public var fileName: String?

    public var fileTemplateUrls: QuerySupplementDetailResponseBody.FileTemplateUrls?

    public var id: Int64?

    public var operateTime: Int64?

    public var reason: String?

    public var requestId: String?

    public var sbjDeadTime: Int64?

    public var sendTime: Int64?

    public var serialNumber: String?

    public var status: Int32?

    public var tmNumber: String?

    public var type: Int32?

    public var uploadFileTemplateUrl: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.fileTemplateUrls?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptDeadTime != nil {
            map["AcceptDeadTime"] = self.acceptDeadTime!
        }
        if self.acceptTime != nil {
            map["AcceptTime"] = self.acceptTime!
        }
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.fileName != nil {
            map["FileName"] = self.fileName!
        }
        if self.fileTemplateUrls != nil {
            map["FileTemplateUrls"] = self.fileTemplateUrls?.toMap()
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.operateTime != nil {
            map["OperateTime"] = self.operateTime!
        }
        if self.reason != nil {
            map["Reason"] = self.reason!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sbjDeadTime != nil {
            map["SbjDeadTime"] = self.sbjDeadTime!
        }
        if self.sendTime != nil {
            map["SendTime"] = self.sendTime!
        }
        if self.serialNumber != nil {
            map["SerialNumber"] = self.serialNumber!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.tmNumber != nil {
            map["TmNumber"] = self.tmNumber!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.uploadFileTemplateUrl != nil {
            map["UploadFileTemplateUrl"] = self.uploadFileTemplateUrl!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptDeadTime") && dict["AcceptDeadTime"] != nil {
            self.acceptDeadTime = dict["AcceptDeadTime"] as! Int64
        }
        if dict.keys.contains("AcceptTime") && dict["AcceptTime"] != nil {
            self.acceptTime = dict["AcceptTime"] as! Int64
        }
        if dict.keys.contains("Content") && dict["Content"] != nil {
            self.content = dict["Content"] as! String
        }
        if dict.keys.contains("FileName") && dict["FileName"] != nil {
            self.fileName = dict["FileName"] as! String
        }
        if dict.keys.contains("FileTemplateUrls") && dict["FileTemplateUrls"] != nil {
            var model = QuerySupplementDetailResponseBody.FileTemplateUrls()
            model.fromMap(dict["FileTemplateUrls"] as! [String: Any])
            self.fileTemplateUrls = model
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("OperateTime") && dict["OperateTime"] != nil {
            self.operateTime = dict["OperateTime"] as! Int64
        }
        if dict.keys.contains("Reason") && dict["Reason"] != nil {
            self.reason = dict["Reason"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SbjDeadTime") && dict["SbjDeadTime"] != nil {
            self.sbjDeadTime = dict["SbjDeadTime"] as! Int64
        }
        if dict.keys.contains("SendTime") && dict["SendTime"] != nil {
            self.sendTime = dict["SendTime"] as! Int64
        }
        if dict.keys.contains("SerialNumber") && dict["SerialNumber"] != nil {
            self.serialNumber = dict["SerialNumber"] as! String
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! Int32
        }
        if dict.keys.contains("TmNumber") && dict["TmNumber"] != nil {
            self.tmNumber = dict["TmNumber"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! Int32
        }
        if dict.keys.contains("UploadFileTemplateUrl") && dict["UploadFileTemplateUrl"] != nil {
            self.uploadFileTemplateUrl = dict["UploadFileTemplateUrl"] as! String
        }
    }
}

public class QuerySupplementDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QuerySupplementDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QuerySupplementDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryTaskListRequest : Tea.TeaModel {
    public var bizType: String?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizType != nil {
            map["BizType"] = self.bizType!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizType") && dict["BizType"] != nil {
            self.bizType = dict["BizType"] as! String
        }
        if dict.keys.contains("PageNum") && dict["PageNum"] != nil {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class QueryTaskListResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class TaskList : Tea.TeaModel {
            public var completeTime: Int64?

            public var createTime: Int64?

            public var errMsg: String?

            public var fileName: String?

            public var result: String?

            public var taskStatus: String?

            public var taskType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.completeTime != nil {
                    map["CompleteTime"] = self.completeTime!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.errMsg != nil {
                    map["ErrMsg"] = self.errMsg!
                }
                if self.fileName != nil {
                    map["FileName"] = self.fileName!
                }
                if self.result != nil {
                    map["Result"] = self.result!
                }
                if self.taskStatus != nil {
                    map["TaskStatus"] = self.taskStatus!
                }
                if self.taskType != nil {
                    map["TaskType"] = self.taskType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CompleteTime") && dict["CompleteTime"] != nil {
                    self.completeTime = dict["CompleteTime"] as! Int64
                }
                if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("ErrMsg") && dict["ErrMsg"] != nil {
                    self.errMsg = dict["ErrMsg"] as! String
                }
                if dict.keys.contains("FileName") && dict["FileName"] != nil {
                    self.fileName = dict["FileName"] as! String
                }
                if dict.keys.contains("Result") && dict["Result"] != nil {
                    self.result = dict["Result"] as! String
                }
                if dict.keys.contains("TaskStatus") && dict["TaskStatus"] != nil {
                    self.taskStatus = dict["TaskStatus"] as! String
                }
                if dict.keys.contains("TaskType") && dict["TaskType"] != nil {
                    self.taskType = dict["TaskType"] as! String
                }
            }
        }
        public var taskList: [QueryTaskListResponseBody.Data.TaskList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.taskList != nil {
                var tmp : [Any] = []
                for k in self.taskList! {
                    tmp.append(k.toMap())
                }
                map["TaskList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TaskList") && dict["TaskList"] != nil {
                var tmp : [QueryTaskListResponseBody.Data.TaskList] = []
                for v in dict["TaskList"] as! [Any] {
                    var model = QueryTaskListResponseBody.Data.TaskList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.taskList = tmp
            }
        }
    }
    public var currentPageNum: Int32?

    public var data: QueryTaskListResponseBody.Data?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalItemNum: Int32?

    public var totalPageNum: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPageNum != nil {
            map["CurrentPageNum"] = self.currentPageNum!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalItemNum != nil {
            map["TotalItemNum"] = self.totalItemNum!
        }
        if self.totalPageNum != nil {
            map["TotalPageNum"] = self.totalPageNum!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPageNum") && dict["CurrentPageNum"] != nil {
            self.currentPageNum = dict["CurrentPageNum"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = QueryTaskListResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalItemNum") && dict["TotalItemNum"] != nil {
            self.totalItemNum = dict["TotalItemNum"] as! Int32
        }
        if dict.keys.contains("TotalPageNum") && dict["TotalPageNum"] != nil {
            self.totalPageNum = dict["TotalPageNum"] as! Int32
        }
    }
}

public class QueryTaskListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryTaskListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryTaskListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryTmCollectionPageListRequest : Tea.TeaModel {
    public var pageNum: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNum") && dict["PageNum"] != nil {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class QueryTmCollectionPageListResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Trademark : Tea.TeaModel {
            public var classification: String?

            public var collected: Bool?

            public var collectionContent: String?

            public var id: Int64?

            public var itemId: String?

            public var tmName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.classification != nil {
                    map["Classification"] = self.classification!
                }
                if self.collected != nil {
                    map["Collected"] = self.collected!
                }
                if self.collectionContent != nil {
                    map["CollectionContent"] = self.collectionContent!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.itemId != nil {
                    map["ItemId"] = self.itemId!
                }
                if self.tmName != nil {
                    map["TmName"] = self.tmName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Classification") && dict["Classification"] != nil {
                    self.classification = dict["Classification"] as! String
                }
                if dict.keys.contains("Collected") && dict["Collected"] != nil {
                    self.collected = dict["Collected"] as! Bool
                }
                if dict.keys.contains("CollectionContent") && dict["CollectionContent"] != nil {
                    self.collectionContent = dict["CollectionContent"] as! String
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("ItemId") && dict["ItemId"] != nil {
                    self.itemId = dict["ItemId"] as! String
                }
                if dict.keys.contains("TmName") && dict["TmName"] != nil {
                    self.tmName = dict["TmName"] as! String
                }
            }
        }
        public var trademark: [QueryTmCollectionPageListResponseBody.Data.Trademark]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.trademark != nil {
                var tmp : [Any] = []
                for k in self.trademark! {
                    tmp.append(k.toMap())
                }
                map["Trademark"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Trademark") && dict["Trademark"] != nil {
                var tmp : [QueryTmCollectionPageListResponseBody.Data.Trademark] = []
                for v in dict["Trademark"] as! [Any] {
                    var model = QueryTmCollectionPageListResponseBody.Data.Trademark()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.trademark = tmp
            }
        }
    }
    public var currentPageNum: Int32?

    public var data: QueryTmCollectionPageListResponseBody.Data?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalItemNum: Int32?

    public var totalPageNum: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPageNum != nil {
            map["CurrentPageNum"] = self.currentPageNum!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalItemNum != nil {
            map["TotalItemNum"] = self.totalItemNum!
        }
        if self.totalPageNum != nil {
            map["TotalPageNum"] = self.totalPageNum!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPageNum") && dict["CurrentPageNum"] != nil {
            self.currentPageNum = dict["CurrentPageNum"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = QueryTmCollectionPageListResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalItemNum") && dict["TotalItemNum"] != nil {
            self.totalItemNum = dict["TotalItemNum"] as! Int32
        }
        if dict.keys.contains("TotalPageNum") && dict["TotalPageNum"] != nil {
            self.totalPageNum = dict["TotalPageNum"] as! Int32
        }
    }
}

public class QueryTmCollectionPageListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryTmCollectionPageListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryTmCollectionPageListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryTmSbjProduceRequest : Tea.TeaModel {
    public var highPriorityBizTypeStr: String?

    public var highPriorityMaterialNameStr: String?

    public var highPriorityOrderIdStr: String?

    public var highPriorityUserIdStr: String?

    public var principalKey: String?

    public var principalName: String?

    public var producerType: String?

    public var queryOrderPageSize: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.highPriorityBizTypeStr != nil {
            map["HighPriorityBizTypeStr"] = self.highPriorityBizTypeStr!
        }
        if self.highPriorityMaterialNameStr != nil {
            map["HighPriorityMaterialNameStr"] = self.highPriorityMaterialNameStr!
        }
        if self.highPriorityOrderIdStr != nil {
            map["HighPriorityOrderIdStr"] = self.highPriorityOrderIdStr!
        }
        if self.highPriorityUserIdStr != nil {
            map["HighPriorityUserIdStr"] = self.highPriorityUserIdStr!
        }
        if self.principalKey != nil {
            map["PrincipalKey"] = self.principalKey!
        }
        if self.principalName != nil {
            map["PrincipalName"] = self.principalName!
        }
        if self.producerType != nil {
            map["ProducerType"] = self.producerType!
        }
        if self.queryOrderPageSize != nil {
            map["QueryOrderPageSize"] = self.queryOrderPageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("HighPriorityBizTypeStr") && dict["HighPriorityBizTypeStr"] != nil {
            self.highPriorityBizTypeStr = dict["HighPriorityBizTypeStr"] as! String
        }
        if dict.keys.contains("HighPriorityMaterialNameStr") && dict["HighPriorityMaterialNameStr"] != nil {
            self.highPriorityMaterialNameStr = dict["HighPriorityMaterialNameStr"] as! String
        }
        if dict.keys.contains("HighPriorityOrderIdStr") && dict["HighPriorityOrderIdStr"] != nil {
            self.highPriorityOrderIdStr = dict["HighPriorityOrderIdStr"] as! String
        }
        if dict.keys.contains("HighPriorityUserIdStr") && dict["HighPriorityUserIdStr"] != nil {
            self.highPriorityUserIdStr = dict["HighPriorityUserIdStr"] as! String
        }
        if dict.keys.contains("PrincipalKey") && dict["PrincipalKey"] != nil {
            self.principalKey = dict["PrincipalKey"] as! String
        }
        if dict.keys.contains("PrincipalName") && dict["PrincipalName"] != nil {
            self.principalName = dict["PrincipalName"] as! String
        }
        if dict.keys.contains("ProducerType") && dict["ProducerType"] != nil {
            self.producerType = dict["ProducerType"] as! String
        }
        if dict.keys.contains("QueryOrderPageSize") && dict["QueryOrderPageSize"] != nil {
            self.queryOrderPageSize = dict["QueryOrderPageSize"] as! Int64
        }
    }
}

public class QueryTmSbjProduceResponseBody : Tea.TeaModel {
    public class Moudle : Tea.TeaModel {
        public class TmSbjProduceList : Tea.TeaModel {
            public class Extend : Tea.TeaModel {
                public var bid: Int64?

                public var blackIcon: Bool?

                public var loaOssKey: String?

                public var logoGoodsId: String?

                public var materialId: String?

                public var submitCount: Int64?

                public var tmNametype: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bid != nil {
                        map["Bid"] = self.bid!
                    }
                    if self.blackIcon != nil {
                        map["BlackIcon"] = self.blackIcon!
                    }
                    if self.loaOssKey != nil {
                        map["LoaOssKey"] = self.loaOssKey!
                    }
                    if self.logoGoodsId != nil {
                        map["LogoGoodsId"] = self.logoGoodsId!
                    }
                    if self.materialId != nil {
                        map["MaterialId"] = self.materialId!
                    }
                    if self.submitCount != nil {
                        map["SubmitCount"] = self.submitCount!
                    }
                    if self.tmNametype != nil {
                        map["TmNametype"] = self.tmNametype!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bid") && dict["Bid"] != nil {
                        self.bid = dict["Bid"] as! Int64
                    }
                    if dict.keys.contains("BlackIcon") && dict["BlackIcon"] != nil {
                        self.blackIcon = dict["BlackIcon"] as! Bool
                    }
                    if dict.keys.contains("LoaOssKey") && dict["LoaOssKey"] != nil {
                        self.loaOssKey = dict["LoaOssKey"] as! String
                    }
                    if dict.keys.contains("LogoGoodsId") && dict["LogoGoodsId"] != nil {
                        self.logoGoodsId = dict["LogoGoodsId"] as! String
                    }
                    if dict.keys.contains("MaterialId") && dict["MaterialId"] != nil {
                        self.materialId = dict["MaterialId"] as! String
                    }
                    if dict.keys.contains("SubmitCount") && dict["SubmitCount"] != nil {
                        self.submitCount = dict["SubmitCount"] as! Int64
                    }
                    if dict.keys.contains("TmNametype") && dict["TmNametype"] != nil {
                        self.tmNametype = dict["TmNametype"] as! Int64
                    }
                }
            }
            public var bitFlag: Int64?

            public var bizId: String?

            public var classificationCode: String?

            public var deleteFlag: String?

            public var env: String?

            public var extend: QueryTmSbjProduceResponseBody.Moudle.TmSbjProduceList.Extend?

            public var loaId: Int64?

            public var mainOrderId: String?

            public var materialId: Int64?

            public var materialName: String?

            public var orderId: String?

            public var orderPrice: Double?

            public var principalKey: String?

            public var principalName: String?

            public var productType: String?

            public var riskSource: String?

            public var status: String?

            public var submitAuditTime: Int64?

            public var submitStatus: String?

            public var submitTime: Int64?

            public var submitTimes: Int64?

            public var tmCode: String?

            public var tmIcon: String?

            public var tmName: String?

            public var type: String?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.extend?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bitFlag != nil {
                    map["BitFlag"] = self.bitFlag!
                }
                if self.bizId != nil {
                    map["BizId"] = self.bizId!
                }
                if self.classificationCode != nil {
                    map["ClassificationCode"] = self.classificationCode!
                }
                if self.deleteFlag != nil {
                    map["DeleteFlag"] = self.deleteFlag!
                }
                if self.env != nil {
                    map["Env"] = self.env!
                }
                if self.extend != nil {
                    map["Extend"] = self.extend?.toMap()
                }
                if self.loaId != nil {
                    map["LoaId"] = self.loaId!
                }
                if self.mainOrderId != nil {
                    map["MainOrderId"] = self.mainOrderId!
                }
                if self.materialId != nil {
                    map["MaterialId"] = self.materialId!
                }
                if self.materialName != nil {
                    map["MaterialName"] = self.materialName!
                }
                if self.orderId != nil {
                    map["OrderId"] = self.orderId!
                }
                if self.orderPrice != nil {
                    map["OrderPrice"] = self.orderPrice!
                }
                if self.principalKey != nil {
                    map["PrincipalKey"] = self.principalKey!
                }
                if self.principalName != nil {
                    map["PrincipalName"] = self.principalName!
                }
                if self.productType != nil {
                    map["ProductType"] = self.productType!
                }
                if self.riskSource != nil {
                    map["RiskSource"] = self.riskSource!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.submitAuditTime != nil {
                    map["SubmitAuditTime"] = self.submitAuditTime!
                }
                if self.submitStatus != nil {
                    map["SubmitStatus"] = self.submitStatus!
                }
                if self.submitTime != nil {
                    map["SubmitTime"] = self.submitTime!
                }
                if self.submitTimes != nil {
                    map["SubmitTimes"] = self.submitTimes!
                }
                if self.tmCode != nil {
                    map["TmCode"] = self.tmCode!
                }
                if self.tmIcon != nil {
                    map["TmIcon"] = self.tmIcon!
                }
                if self.tmName != nil {
                    map["TmName"] = self.tmName!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BitFlag") && dict["BitFlag"] != nil {
                    self.bitFlag = dict["BitFlag"] as! Int64
                }
                if dict.keys.contains("BizId") && dict["BizId"] != nil {
                    self.bizId = dict["BizId"] as! String
                }
                if dict.keys.contains("ClassificationCode") && dict["ClassificationCode"] != nil {
                    self.classificationCode = dict["ClassificationCode"] as! String
                }
                if dict.keys.contains("DeleteFlag") && dict["DeleteFlag"] != nil {
                    self.deleteFlag = dict["DeleteFlag"] as! String
                }
                if dict.keys.contains("Env") && dict["Env"] != nil {
                    self.env = dict["Env"] as! String
                }
                if dict.keys.contains("Extend") && dict["Extend"] != nil {
                    var model = QueryTmSbjProduceResponseBody.Moudle.TmSbjProduceList.Extend()
                    model.fromMap(dict["Extend"] as! [String: Any])
                    self.extend = model
                }
                if dict.keys.contains("LoaId") && dict["LoaId"] != nil {
                    self.loaId = dict["LoaId"] as! Int64
                }
                if dict.keys.contains("MainOrderId") && dict["MainOrderId"] != nil {
                    self.mainOrderId = dict["MainOrderId"] as! String
                }
                if dict.keys.contains("MaterialId") && dict["MaterialId"] != nil {
                    self.materialId = dict["MaterialId"] as! Int64
                }
                if dict.keys.contains("MaterialName") && dict["MaterialName"] != nil {
                    self.materialName = dict["MaterialName"] as! String
                }
                if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
                    self.orderId = dict["OrderId"] as! String
                }
                if dict.keys.contains("OrderPrice") && dict["OrderPrice"] != nil {
                    self.orderPrice = dict["OrderPrice"] as! Double
                }
                if dict.keys.contains("PrincipalKey") && dict["PrincipalKey"] != nil {
                    self.principalKey = dict["PrincipalKey"] as! String
                }
                if dict.keys.contains("PrincipalName") && dict["PrincipalName"] != nil {
                    self.principalName = dict["PrincipalName"] as! String
                }
                if dict.keys.contains("ProductType") && dict["ProductType"] != nil {
                    self.productType = dict["ProductType"] as! String
                }
                if dict.keys.contains("RiskSource") && dict["RiskSource"] != nil {
                    self.riskSource = dict["RiskSource"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("SubmitAuditTime") && dict["SubmitAuditTime"] != nil {
                    self.submitAuditTime = dict["SubmitAuditTime"] as! Int64
                }
                if dict.keys.contains("SubmitStatus") && dict["SubmitStatus"] != nil {
                    self.submitStatus = dict["SubmitStatus"] as! String
                }
                if dict.keys.contains("SubmitTime") && dict["SubmitTime"] != nil {
                    self.submitTime = dict["SubmitTime"] as! Int64
                }
                if dict.keys.contains("SubmitTimes") && dict["SubmitTimes"] != nil {
                    self.submitTimes = dict["SubmitTimes"] as! Int64
                }
                if dict.keys.contains("TmCode") && dict["TmCode"] != nil {
                    self.tmCode = dict["TmCode"] as! String
                }
                if dict.keys.contains("TmIcon") && dict["TmIcon"] != nil {
                    self.tmIcon = dict["TmIcon"] as! String
                }
                if dict.keys.contains("TmName") && dict["TmName"] != nil {
                    self.tmName = dict["TmName"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! String
                }
            }
        }
        public var tmSbjProduceList: [QueryTmSbjProduceResponseBody.Moudle.TmSbjProduceList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tmSbjProduceList != nil {
                var tmp : [Any] = []
                for k in self.tmSbjProduceList! {
                    tmp.append(k.toMap())
                }
                map["TmSbjProduceList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TmSbjProduceList") && dict["TmSbjProduceList"] != nil {
                var tmp : [QueryTmSbjProduceResponseBody.Moudle.TmSbjProduceList] = []
                for v in dict["TmSbjProduceList"] as! [Any] {
                    var model = QueryTmSbjProduceResponseBody.Moudle.TmSbjProduceList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tmSbjProduceList = tmp
            }
        }
    }
    public var moudle: QueryTmSbjProduceResponseBody.Moudle?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.moudle?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.moudle != nil {
            map["Moudle"] = self.moudle?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Moudle") && dict["Moudle"] != nil {
            var model = QueryTmSbjProduceResponseBody.Moudle()
            model.fromMap(dict["Moudle"] as! [String: Any])
            self.moudle = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class QueryTmSbjProduceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryTmSbjProduceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryTmSbjProduceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryTmSbjProduceDetailRequest : Tea.TeaModel {
    public var bizId: String?

    public var orderId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
            self.orderId = dict["OrderId"] as! String
        }
    }
}

public class QueryTmSbjProduceDetailResponseBody : Tea.TeaModel {
    public class Flags : Tea.TeaModel {
        public var flags: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.flags != nil {
                map["Flags"] = self.flags!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Flags") && dict["Flags"] != nil {
                self.flags = dict["Flags"] as! [String]
            }
        }
    }
    public class LeafCodes : Tea.TeaModel {
        public class LeafCodes : Tea.TeaModel {
            public var code: String?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Code") && dict["Code"] != nil {
                    self.code = dict["Code"] as! String
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
            }
        }
        public var leafCodes: [QueryTmSbjProduceDetailResponseBody.LeafCodes.LeafCodes]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.leafCodes != nil {
                var tmp : [Any] = []
                for k in self.leafCodes! {
                    tmp.append(k.toMap())
                }
                map["LeafCodes"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LeafCodes") && dict["LeafCodes"] != nil {
                var tmp : [QueryTmSbjProduceDetailResponseBody.LeafCodes.LeafCodes] = []
                for v in dict["LeafCodes"] as! [Any] {
                    var model = QueryTmSbjProduceDetailResponseBody.LeafCodes.LeafCodes()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.leafCodes = tmp
            }
        }
    }
    public class MaterialDetail : Tea.TeaModel {
        public var address: String?

        public var businessLicenceUrl: String?

        public var cardNumber: String?

        public var city: String?

        public var contactAddress: String?

        public var contactEmail: String?

        public var contactName: String?

        public var contactNumber: String?

        public var contactProvince: String?

        public var contactZipcode: String?

        public var country: String?

        public var detailedContactAddress: String?

        public var EAddress: String?

        public var EName: String?

        public var expirationDate: String?

        public var idCardNumber: String?

        public var idCardUrl: String?

        public var loaUrl: String?

        public var name: String?

        public var passportUrl: String?

        public var personalType: Int32?

        public var province: String?

        public var region: Int32?

        public var status: Int32?

        public var town: String?

        public var type: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.address != nil {
                map["Address"] = self.address!
            }
            if self.businessLicenceUrl != nil {
                map["BusinessLicenceUrl"] = self.businessLicenceUrl!
            }
            if self.cardNumber != nil {
                map["CardNumber"] = self.cardNumber!
            }
            if self.city != nil {
                map["City"] = self.city!
            }
            if self.contactAddress != nil {
                map["ContactAddress"] = self.contactAddress!
            }
            if self.contactEmail != nil {
                map["ContactEmail"] = self.contactEmail!
            }
            if self.contactName != nil {
                map["ContactName"] = self.contactName!
            }
            if self.contactNumber != nil {
                map["ContactNumber"] = self.contactNumber!
            }
            if self.contactProvince != nil {
                map["ContactProvince"] = self.contactProvince!
            }
            if self.contactZipcode != nil {
                map["ContactZipcode"] = self.contactZipcode!
            }
            if self.country != nil {
                map["Country"] = self.country!
            }
            if self.detailedContactAddress != nil {
                map["DetailedContactAddress"] = self.detailedContactAddress!
            }
            if self.EAddress != nil {
                map["EAddress"] = self.EAddress!
            }
            if self.EName != nil {
                map["EName"] = self.EName!
            }
            if self.expirationDate != nil {
                map["ExpirationDate"] = self.expirationDate!
            }
            if self.idCardNumber != nil {
                map["IdCardNumber"] = self.idCardNumber!
            }
            if self.idCardUrl != nil {
                map["IdCardUrl"] = self.idCardUrl!
            }
            if self.loaUrl != nil {
                map["LoaUrl"] = self.loaUrl!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.passportUrl != nil {
                map["PassportUrl"] = self.passportUrl!
            }
            if self.personalType != nil {
                map["PersonalType"] = self.personalType!
            }
            if self.province != nil {
                map["Province"] = self.province!
            }
            if self.region != nil {
                map["Region"] = self.region!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.town != nil {
                map["Town"] = self.town!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Address") && dict["Address"] != nil {
                self.address = dict["Address"] as! String
            }
            if dict.keys.contains("BusinessLicenceUrl") && dict["BusinessLicenceUrl"] != nil {
                self.businessLicenceUrl = dict["BusinessLicenceUrl"] as! String
            }
            if dict.keys.contains("CardNumber") && dict["CardNumber"] != nil {
                self.cardNumber = dict["CardNumber"] as! String
            }
            if dict.keys.contains("City") && dict["City"] != nil {
                self.city = dict["City"] as! String
            }
            if dict.keys.contains("ContactAddress") && dict["ContactAddress"] != nil {
                self.contactAddress = dict["ContactAddress"] as! String
            }
            if dict.keys.contains("ContactEmail") && dict["ContactEmail"] != nil {
                self.contactEmail = dict["ContactEmail"] as! String
            }
            if dict.keys.contains("ContactName") && dict["ContactName"] != nil {
                self.contactName = dict["ContactName"] as! String
            }
            if dict.keys.contains("ContactNumber") && dict["ContactNumber"] != nil {
                self.contactNumber = dict["ContactNumber"] as! String
            }
            if dict.keys.contains("ContactProvince") && dict["ContactProvince"] != nil {
                self.contactProvince = dict["ContactProvince"] as! String
            }
            if dict.keys.contains("ContactZipcode") && dict["ContactZipcode"] != nil {
                self.contactZipcode = dict["ContactZipcode"] as! String
            }
            if dict.keys.contains("Country") && dict["Country"] != nil {
                self.country = dict["Country"] as! String
            }
            if dict.keys.contains("DetailedContactAddress") && dict["DetailedContactAddress"] != nil {
                self.detailedContactAddress = dict["DetailedContactAddress"] as! String
            }
            if dict.keys.contains("EAddress") && dict["EAddress"] != nil {
                self.EAddress = dict["EAddress"] as! String
            }
            if dict.keys.contains("EName") && dict["EName"] != nil {
                self.EName = dict["EName"] as! String
            }
            if dict.keys.contains("ExpirationDate") && dict["ExpirationDate"] != nil {
                self.expirationDate = dict["ExpirationDate"] as! String
            }
            if dict.keys.contains("IdCardNumber") && dict["IdCardNumber"] != nil {
                self.idCardNumber = dict["IdCardNumber"] as! String
            }
            if dict.keys.contains("IdCardUrl") && dict["IdCardUrl"] != nil {
                self.idCardUrl = dict["IdCardUrl"] as! String
            }
            if dict.keys.contains("LoaUrl") && dict["LoaUrl"] != nil {
                self.loaUrl = dict["LoaUrl"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("PassportUrl") && dict["PassportUrl"] != nil {
                self.passportUrl = dict["PassportUrl"] as! String
            }
            if dict.keys.contains("PersonalType") && dict["PersonalType"] != nil {
                self.personalType = dict["PersonalType"] as! Int32
            }
            if dict.keys.contains("Province") && dict["Province"] != nil {
                self.province = dict["Province"] as! String
            }
            if dict.keys.contains("Region") && dict["Region"] != nil {
                self.region = dict["Region"] as! Int32
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("Town") && dict["Town"] != nil {
                self.town = dict["Town"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! Int32
            }
        }
    }
    public class RootCode : Tea.TeaModel {
        public var code: String?

        public var name: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") && dict["Code"] != nil {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
        }
    }
    public var acceptUrl: String?

    public var bizId: String?

    public var cnInfoUrl: String?

    public var extendInfo: [String: Any]?

    public var flags: QueryTmSbjProduceDetailResponseBody.Flags?

    public var grayIconUrl: String?

    public var issueDate: String?

    public var leafCodes: QueryTmSbjProduceDetailResponseBody.LeafCodes?

    public var loaUrl: String?

    public var materialDetail: QueryTmSbjProduceDetailResponseBody.MaterialDetail?

    public var materialName: String?

    public var note: String?

    public var orderId: String?

    public var principalName: Int32?

    public var requestId: String?

    public var rootCode: QueryTmSbjProduceDetailResponseBody.RootCode?

    public var status: Int32?

    public var submitCount: Int32?

    public var submitStatus: String?

    public var tmIcon: String?

    public var tmName: String?

    public var tmNameType: Int32?

    public var tmNumber: String?

    public var tmOrderId: String?

    public var type: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.flags?.validate()
        try self.leafCodes?.validate()
        try self.materialDetail?.validate()
        try self.rootCode?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptUrl != nil {
            map["AcceptUrl"] = self.acceptUrl!
        }
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.cnInfoUrl != nil {
            map["CnInfoUrl"] = self.cnInfoUrl!
        }
        if self.extendInfo != nil {
            map["ExtendInfo"] = self.extendInfo!
        }
        if self.flags != nil {
            map["Flags"] = self.flags?.toMap()
        }
        if self.grayIconUrl != nil {
            map["GrayIconUrl"] = self.grayIconUrl!
        }
        if self.issueDate != nil {
            map["IssueDate"] = self.issueDate!
        }
        if self.leafCodes != nil {
            map["LeafCodes"] = self.leafCodes?.toMap()
        }
        if self.loaUrl != nil {
            map["LoaUrl"] = self.loaUrl!
        }
        if self.materialDetail != nil {
            map["MaterialDetail"] = self.materialDetail?.toMap()
        }
        if self.materialName != nil {
            map["MaterialName"] = self.materialName!
        }
        if self.note != nil {
            map["Note"] = self.note!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.principalName != nil {
            map["PrincipalName"] = self.principalName!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.rootCode != nil {
            map["RootCode"] = self.rootCode?.toMap()
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.submitCount != nil {
            map["SubmitCount"] = self.submitCount!
        }
        if self.submitStatus != nil {
            map["SubmitStatus"] = self.submitStatus!
        }
        if self.tmIcon != nil {
            map["TmIcon"] = self.tmIcon!
        }
        if self.tmName != nil {
            map["TmName"] = self.tmName!
        }
        if self.tmNameType != nil {
            map["TmNameType"] = self.tmNameType!
        }
        if self.tmNumber != nil {
            map["TmNumber"] = self.tmNumber!
        }
        if self.tmOrderId != nil {
            map["TmOrderId"] = self.tmOrderId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptUrl") && dict["AcceptUrl"] != nil {
            self.acceptUrl = dict["AcceptUrl"] as! String
        }
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("CnInfoUrl") && dict["CnInfoUrl"] != nil {
            self.cnInfoUrl = dict["CnInfoUrl"] as! String
        }
        if dict.keys.contains("ExtendInfo") && dict["ExtendInfo"] != nil {
            self.extendInfo = dict["ExtendInfo"] as! [String: Any]
        }
        if dict.keys.contains("Flags") && dict["Flags"] != nil {
            var model = QueryTmSbjProduceDetailResponseBody.Flags()
            model.fromMap(dict["Flags"] as! [String: Any])
            self.flags = model
        }
        if dict.keys.contains("GrayIconUrl") && dict["GrayIconUrl"] != nil {
            self.grayIconUrl = dict["GrayIconUrl"] as! String
        }
        if dict.keys.contains("IssueDate") && dict["IssueDate"] != nil {
            self.issueDate = dict["IssueDate"] as! String
        }
        if dict.keys.contains("LeafCodes") && dict["LeafCodes"] != nil {
            var model = QueryTmSbjProduceDetailResponseBody.LeafCodes()
            model.fromMap(dict["LeafCodes"] as! [String: Any])
            self.leafCodes = model
        }
        if dict.keys.contains("LoaUrl") && dict["LoaUrl"] != nil {
            self.loaUrl = dict["LoaUrl"] as! String
        }
        if dict.keys.contains("MaterialDetail") && dict["MaterialDetail"] != nil {
            var model = QueryTmSbjProduceDetailResponseBody.MaterialDetail()
            model.fromMap(dict["MaterialDetail"] as! [String: Any])
            self.materialDetail = model
        }
        if dict.keys.contains("MaterialName") && dict["MaterialName"] != nil {
            self.materialName = dict["MaterialName"] as! String
        }
        if dict.keys.contains("Note") && dict["Note"] != nil {
            self.note = dict["Note"] as! String
        }
        if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
            self.orderId = dict["OrderId"] as! String
        }
        if dict.keys.contains("PrincipalName") && dict["PrincipalName"] != nil {
            self.principalName = dict["PrincipalName"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RootCode") && dict["RootCode"] != nil {
            var model = QueryTmSbjProduceDetailResponseBody.RootCode()
            model.fromMap(dict["RootCode"] as! [String: Any])
            self.rootCode = model
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! Int32
        }
        if dict.keys.contains("SubmitCount") && dict["SubmitCount"] != nil {
            self.submitCount = dict["SubmitCount"] as! Int32
        }
        if dict.keys.contains("SubmitStatus") && dict["SubmitStatus"] != nil {
            self.submitStatus = dict["SubmitStatus"] as! String
        }
        if dict.keys.contains("TmIcon") && dict["TmIcon"] != nil {
            self.tmIcon = dict["TmIcon"] as! String
        }
        if dict.keys.contains("TmName") && dict["TmName"] != nil {
            self.tmName = dict["TmName"] as! String
        }
        if dict.keys.contains("TmNameType") && dict["TmNameType"] != nil {
            self.tmNameType = dict["TmNameType"] as! Int32
        }
        if dict.keys.contains("TmNumber") && dict["TmNumber"] != nil {
            self.tmNumber = dict["TmNumber"] as! String
        }
        if dict.keys.contains("TmOrderId") && dict["TmOrderId"] != nil {
            self.tmOrderId = dict["TmOrderId"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! Int32
        }
    }
}

public class QueryTmSbjProduceDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryTmSbjProduceDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryTmSbjProduceDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryTradeIntentionUserListRequest : Tea.TeaModel {
    public var begin: Int64?

    public var bizId: String?

    public var end: Int64?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var status: Int32?

    public var type: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.begin != nil {
            map["Begin"] = self.begin!
        }
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.end != nil {
            map["End"] = self.end!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Begin") && dict["Begin"] != nil {
            self.begin = dict["Begin"] as! Int64
        }
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("End") && dict["End"] != nil {
            self.end = dict["End"] as! Int64
        }
        if dict.keys.contains("PageNum") && dict["PageNum"] != nil {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! Int32
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! Int32
        }
    }
}

public class QueryTradeIntentionUserListResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Trademark : Tea.TeaModel {
            public var bizId: String?

            public var classification: String?

            public var description_: String?

            public var documentDate: String?

            public var documentName: String?

            public var documentUrl: String?

            public var grade: Int32?

            public var mobile: String?

            public var registerNumber: String?

            public var status: Int32?

            public var type: Int32?

            public var userName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bizId != nil {
                    map["BizId"] = self.bizId!
                }
                if self.classification != nil {
                    map["Classification"] = self.classification!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.documentDate != nil {
                    map["DocumentDate"] = self.documentDate!
                }
                if self.documentName != nil {
                    map["DocumentName"] = self.documentName!
                }
                if self.documentUrl != nil {
                    map["DocumentUrl"] = self.documentUrl!
                }
                if self.grade != nil {
                    map["Grade"] = self.grade!
                }
                if self.mobile != nil {
                    map["Mobile"] = self.mobile!
                }
                if self.registerNumber != nil {
                    map["RegisterNumber"] = self.registerNumber!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.userName != nil {
                    map["UserName"] = self.userName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BizId") && dict["BizId"] != nil {
                    self.bizId = dict["BizId"] as! String
                }
                if dict.keys.contains("Classification") && dict["Classification"] != nil {
                    self.classification = dict["Classification"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("DocumentDate") && dict["DocumentDate"] != nil {
                    self.documentDate = dict["DocumentDate"] as! String
                }
                if dict.keys.contains("DocumentName") && dict["DocumentName"] != nil {
                    self.documentName = dict["DocumentName"] as! String
                }
                if dict.keys.contains("DocumentUrl") && dict["DocumentUrl"] != nil {
                    self.documentUrl = dict["DocumentUrl"] as! String
                }
                if dict.keys.contains("Grade") && dict["Grade"] != nil {
                    self.grade = dict["Grade"] as! Int32
                }
                if dict.keys.contains("Mobile") && dict["Mobile"] != nil {
                    self.mobile = dict["Mobile"] as! String
                }
                if dict.keys.contains("RegisterNumber") && dict["RegisterNumber"] != nil {
                    self.registerNumber = dict["RegisterNumber"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! Int32
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! Int32
                }
                if dict.keys.contains("UserName") && dict["UserName"] != nil {
                    self.userName = dict["UserName"] as! String
                }
            }
        }
        public var trademark: [QueryTradeIntentionUserListResponseBody.Data.Trademark]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.trademark != nil {
                var tmp : [Any] = []
                for k in self.trademark! {
                    tmp.append(k.toMap())
                }
                map["Trademark"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Trademark") && dict["Trademark"] != nil {
                var tmp : [QueryTradeIntentionUserListResponseBody.Data.Trademark] = []
                for v in dict["Trademark"] as! [Any] {
                    var model = QueryTradeIntentionUserListResponseBody.Data.Trademark()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.trademark = tmp
            }
        }
    }
    public var currentPageNum: Int32?

    public var data: QueryTradeIntentionUserListResponseBody.Data?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalItemNum: Int32?

    public var totalPageNum: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPageNum != nil {
            map["CurrentPageNum"] = self.currentPageNum!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalItemNum != nil {
            map["TotalItemNum"] = self.totalItemNum!
        }
        if self.totalPageNum != nil {
            map["TotalPageNum"] = self.totalPageNum!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPageNum") && dict["CurrentPageNum"] != nil {
            self.currentPageNum = dict["CurrentPageNum"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = QueryTradeIntentionUserListResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalItemNum") && dict["TotalItemNum"] != nil {
            self.totalItemNum = dict["TotalItemNum"] as! Int32
        }
        if dict.keys.contains("TotalPageNum") && dict["TotalPageNum"] != nil {
            self.totalPageNum = dict["TotalPageNum"] as! Int32
        }
    }
}

public class QueryTradeIntentionUserListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryTradeIntentionUserListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryTradeIntentionUserListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryTradeMarkApplicationDetailRequest : Tea.TeaModel {
    public var bizId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
    }
}

public class QueryTradeMarkApplicationDetailResponseBody : Tea.TeaModel {
    public class AdminUploads : Tea.TeaModel {
        public var licensePicUrl: String?

        public var loaPicUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.licensePicUrl != nil {
                map["LicensePicUrl"] = self.licensePicUrl!
            }
            if self.loaPicUrl != nil {
                map["LoaPicUrl"] = self.loaPicUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LicensePicUrl") && dict["LicensePicUrl"] != nil {
                self.licensePicUrl = dict["LicensePicUrl"] as! String
            }
            if dict.keys.contains("LoaPicUrl") && dict["LoaPicUrl"] != nil {
                self.loaPicUrl = dict["LoaPicUrl"] as! String
            }
        }
    }
    public class FirstClassification : Tea.TeaModel {
        public var code: String?

        public var name: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") && dict["Code"] != nil {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
        }
    }
    public class Flags : Tea.TeaModel {
        public var flag: [Int32]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.flag != nil {
                map["Flag"] = self.flag!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Flag") && dict["Flag"] != nil {
                self.flag = dict["Flag"] as! [Int32]
            }
        }
    }
    public class JudgeResultUrl : Tea.TeaModel {
        public var judgeResultUrl: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.judgeResultUrl != nil {
                map["JudgeResultUrl"] = self.judgeResultUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("JudgeResultUrl") && dict["JudgeResultUrl"] != nil {
                self.judgeResultUrl = dict["JudgeResultUrl"] as! [String]
            }
        }
    }
    public class MaterialDetail : Tea.TeaModel {
        public class ReviewAdditionalFiles : Tea.TeaModel {
            public var reviewAdditionalFile: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.reviewAdditionalFile != nil {
                    map["ReviewAdditionalFile"] = self.reviewAdditionalFile!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ReviewAdditionalFile") && dict["ReviewAdditionalFile"] != nil {
                    self.reviewAdditionalFile = dict["ReviewAdditionalFile"] as! [String]
                }
            }
        }
        public var address: String?

        public var businessLicenceUrl: String?

        public var cardNumber: String?

        public var city: String?

        public var contactAddress: String?

        public var contactCity: String?

        public var contactDistrict: String?

        public var contactEmail: String?

        public var contactName: String?

        public var contactNumber: String?

        public var contactProvince: String?

        public var contactZipcode: String?

        public var country: String?

        public var detailedContactAddress: String?

        public var EAddress: String?

        public var EName: String?

        public var expirationDate: String?

        public var factAndReasonPdfPath: String?

        public var idCardName: String?

        public var idCardNumber: String?

        public var idCardUrl: String?

        public var legalNoticeUrl: String?

        public var loaUrl: String?

        public var materialVersion: String?

        public var name: String?

        public var passportUrl: String?

        public var personalType: Int64?

        public var principalName: Int32?

        public var province: String?

        public var region: Int32?

        public var reviewAdditionalFiles: QueryTradeMarkApplicationDetailResponseBody.MaterialDetail.ReviewAdditionalFiles?

        public var reviewApplicationFile: String?

        public var status: Int32?

        public var supplementEvidenceCatalogFile: String?

        public var supplementEvidenceMaterialFile: String?

        public var supplementReasonFile: String?

        public var town: String?

        public var type: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.reviewAdditionalFiles?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.address != nil {
                map["Address"] = self.address!
            }
            if self.businessLicenceUrl != nil {
                map["BusinessLicenceUrl"] = self.businessLicenceUrl!
            }
            if self.cardNumber != nil {
                map["CardNumber"] = self.cardNumber!
            }
            if self.city != nil {
                map["City"] = self.city!
            }
            if self.contactAddress != nil {
                map["ContactAddress"] = self.contactAddress!
            }
            if self.contactCity != nil {
                map["ContactCity"] = self.contactCity!
            }
            if self.contactDistrict != nil {
                map["ContactDistrict"] = self.contactDistrict!
            }
            if self.contactEmail != nil {
                map["ContactEmail"] = self.contactEmail!
            }
            if self.contactName != nil {
                map["ContactName"] = self.contactName!
            }
            if self.contactNumber != nil {
                map["ContactNumber"] = self.contactNumber!
            }
            if self.contactProvince != nil {
                map["ContactProvince"] = self.contactProvince!
            }
            if self.contactZipcode != nil {
                map["ContactZipcode"] = self.contactZipcode!
            }
            if self.country != nil {
                map["Country"] = self.country!
            }
            if self.detailedContactAddress != nil {
                map["DetailedContactAddress"] = self.detailedContactAddress!
            }
            if self.EAddress != nil {
                map["EAddress"] = self.EAddress!
            }
            if self.EName != nil {
                map["EName"] = self.EName!
            }
            if self.expirationDate != nil {
                map["ExpirationDate"] = self.expirationDate!
            }
            if self.factAndReasonPdfPath != nil {
                map["FactAndReasonPdfPath"] = self.factAndReasonPdfPath!
            }
            if self.idCardName != nil {
                map["IdCardName"] = self.idCardName!
            }
            if self.idCardNumber != nil {
                map["IdCardNumber"] = self.idCardNumber!
            }
            if self.idCardUrl != nil {
                map["IdCardUrl"] = self.idCardUrl!
            }
            if self.legalNoticeUrl != nil {
                map["LegalNoticeUrl"] = self.legalNoticeUrl!
            }
            if self.loaUrl != nil {
                map["LoaUrl"] = self.loaUrl!
            }
            if self.materialVersion != nil {
                map["MaterialVersion"] = self.materialVersion!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.passportUrl != nil {
                map["PassportUrl"] = self.passportUrl!
            }
            if self.personalType != nil {
                map["PersonalType"] = self.personalType!
            }
            if self.principalName != nil {
                map["PrincipalName"] = self.principalName!
            }
            if self.province != nil {
                map["Province"] = self.province!
            }
            if self.region != nil {
                map["Region"] = self.region!
            }
            if self.reviewAdditionalFiles != nil {
                map["ReviewAdditionalFiles"] = self.reviewAdditionalFiles?.toMap()
            }
            if self.reviewApplicationFile != nil {
                map["ReviewApplicationFile"] = self.reviewApplicationFile!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.supplementEvidenceCatalogFile != nil {
                map["SupplementEvidenceCatalogFile"] = self.supplementEvidenceCatalogFile!
            }
            if self.supplementEvidenceMaterialFile != nil {
                map["SupplementEvidenceMaterialFile"] = self.supplementEvidenceMaterialFile!
            }
            if self.supplementReasonFile != nil {
                map["SupplementReasonFile"] = self.supplementReasonFile!
            }
            if self.town != nil {
                map["Town"] = self.town!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Address") && dict["Address"] != nil {
                self.address = dict["Address"] as! String
            }
            if dict.keys.contains("BusinessLicenceUrl") && dict["BusinessLicenceUrl"] != nil {
                self.businessLicenceUrl = dict["BusinessLicenceUrl"] as! String
            }
            if dict.keys.contains("CardNumber") && dict["CardNumber"] != nil {
                self.cardNumber = dict["CardNumber"] as! String
            }
            if dict.keys.contains("City") && dict["City"] != nil {
                self.city = dict["City"] as! String
            }
            if dict.keys.contains("ContactAddress") && dict["ContactAddress"] != nil {
                self.contactAddress = dict["ContactAddress"] as! String
            }
            if dict.keys.contains("ContactCity") && dict["ContactCity"] != nil {
                self.contactCity = dict["ContactCity"] as! String
            }
            if dict.keys.contains("ContactDistrict") && dict["ContactDistrict"] != nil {
                self.contactDistrict = dict["ContactDistrict"] as! String
            }
            if dict.keys.contains("ContactEmail") && dict["ContactEmail"] != nil {
                self.contactEmail = dict["ContactEmail"] as! String
            }
            if dict.keys.contains("ContactName") && dict["ContactName"] != nil {
                self.contactName = dict["ContactName"] as! String
            }
            if dict.keys.contains("ContactNumber") && dict["ContactNumber"] != nil {
                self.contactNumber = dict["ContactNumber"] as! String
            }
            if dict.keys.contains("ContactProvince") && dict["ContactProvince"] != nil {
                self.contactProvince = dict["ContactProvince"] as! String
            }
            if dict.keys.contains("ContactZipcode") && dict["ContactZipcode"] != nil {
                self.contactZipcode = dict["ContactZipcode"] as! String
            }
            if dict.keys.contains("Country") && dict["Country"] != nil {
                self.country = dict["Country"] as! String
            }
            if dict.keys.contains("DetailedContactAddress") && dict["DetailedContactAddress"] != nil {
                self.detailedContactAddress = dict["DetailedContactAddress"] as! String
            }
            if dict.keys.contains("EAddress") && dict["EAddress"] != nil {
                self.EAddress = dict["EAddress"] as! String
            }
            if dict.keys.contains("EName") && dict["EName"] != nil {
                self.EName = dict["EName"] as! String
            }
            if dict.keys.contains("ExpirationDate") && dict["ExpirationDate"] != nil {
                self.expirationDate = dict["ExpirationDate"] as! String
            }
            if dict.keys.contains("FactAndReasonPdfPath") && dict["FactAndReasonPdfPath"] != nil {
                self.factAndReasonPdfPath = dict["FactAndReasonPdfPath"] as! String
            }
            if dict.keys.contains("IdCardName") && dict["IdCardName"] != nil {
                self.idCardName = dict["IdCardName"] as! String
            }
            if dict.keys.contains("IdCardNumber") && dict["IdCardNumber"] != nil {
                self.idCardNumber = dict["IdCardNumber"] as! String
            }
            if dict.keys.contains("IdCardUrl") && dict["IdCardUrl"] != nil {
                self.idCardUrl = dict["IdCardUrl"] as! String
            }
            if dict.keys.contains("LegalNoticeUrl") && dict["LegalNoticeUrl"] != nil {
                self.legalNoticeUrl = dict["LegalNoticeUrl"] as! String
            }
            if dict.keys.contains("LoaUrl") && dict["LoaUrl"] != nil {
                self.loaUrl = dict["LoaUrl"] as! String
            }
            if dict.keys.contains("MaterialVersion") && dict["MaterialVersion"] != nil {
                self.materialVersion = dict["MaterialVersion"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("PassportUrl") && dict["PassportUrl"] != nil {
                self.passportUrl = dict["PassportUrl"] as! String
            }
            if dict.keys.contains("PersonalType") && dict["PersonalType"] != nil {
                self.personalType = dict["PersonalType"] as! Int64
            }
            if dict.keys.contains("PrincipalName") && dict["PrincipalName"] != nil {
                self.principalName = dict["PrincipalName"] as! Int32
            }
            if dict.keys.contains("Province") && dict["Province"] != nil {
                self.province = dict["Province"] as! String
            }
            if dict.keys.contains("Region") && dict["Region"] != nil {
                self.region = dict["Region"] as! Int32
            }
            if dict.keys.contains("ReviewAdditionalFiles") && dict["ReviewAdditionalFiles"] != nil {
                var model = QueryTradeMarkApplicationDetailResponseBody.MaterialDetail.ReviewAdditionalFiles()
                model.fromMap(dict["ReviewAdditionalFiles"] as! [String: Any])
                self.reviewAdditionalFiles = model
            }
            if dict.keys.contains("ReviewApplicationFile") && dict["ReviewApplicationFile"] != nil {
                self.reviewApplicationFile = dict["ReviewApplicationFile"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("SupplementEvidenceCatalogFile") && dict["SupplementEvidenceCatalogFile"] != nil {
                self.supplementEvidenceCatalogFile = dict["SupplementEvidenceCatalogFile"] as! String
            }
            if dict.keys.contains("SupplementEvidenceMaterialFile") && dict["SupplementEvidenceMaterialFile"] != nil {
                self.supplementEvidenceMaterialFile = dict["SupplementEvidenceMaterialFile"] as! String
            }
            if dict.keys.contains("SupplementReasonFile") && dict["SupplementReasonFile"] != nil {
                self.supplementReasonFile = dict["SupplementReasonFile"] as! String
            }
            if dict.keys.contains("Town") && dict["Town"] != nil {
                self.town = dict["Town"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! Int32
            }
        }
    }
    public class ReceiptUrl : Tea.TeaModel {
        public var receiptUrl: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.receiptUrl != nil {
                map["ReceiptUrl"] = self.receiptUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ReceiptUrl") && dict["ReceiptUrl"] != nil {
                self.receiptUrl = dict["ReceiptUrl"] as! [String]
            }
        }
    }
    public class RenewResponse : Tea.TeaModel {
        public var address: String?

        public var engAddress: String?

        public var engName: String?

        public var name: String?

        public var registerTime: Int64?

        public var submitSbjtime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.address != nil {
                map["Address"] = self.address!
            }
            if self.engAddress != nil {
                map["EngAddress"] = self.engAddress!
            }
            if self.engName != nil {
                map["EngName"] = self.engName!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.registerTime != nil {
                map["RegisterTime"] = self.registerTime!
            }
            if self.submitSbjtime != nil {
                map["SubmitSbjtime"] = self.submitSbjtime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Address") && dict["Address"] != nil {
                self.address = dict["Address"] as! String
            }
            if dict.keys.contains("EngAddress") && dict["EngAddress"] != nil {
                self.engAddress = dict["EngAddress"] as! String
            }
            if dict.keys.contains("EngName") && dict["EngName"] != nil {
                self.engName = dict["EngName"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("RegisterTime") && dict["RegisterTime"] != nil {
                self.registerTime = dict["RegisterTime"] as! Int64
            }
            if dict.keys.contains("SubmitSbjtime") && dict["SubmitSbjtime"] != nil {
                self.submitSbjtime = dict["SubmitSbjtime"] as! Int64
            }
        }
    }
    public class ReviewOfficialFiles : Tea.TeaModel {
        public class ReviewSupplements : Tea.TeaModel {
            public var reviewSupplement: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.reviewSupplement != nil {
                    map["ReviewSupplement"] = self.reviewSupplement!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ReviewSupplement") && dict["ReviewSupplement"] != nil {
                    self.reviewSupplement = dict["ReviewSupplement"] as! [String]
                }
            }
        }
        public var reviewAudit: String?

        public var reviewKeep: String?

        public var reviewPart: String?

        public var reviewPass: String?

        public var reviewSupplements: QueryTradeMarkApplicationDetailResponseBody.ReviewOfficialFiles.ReviewSupplements?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.reviewSupplements?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.reviewAudit != nil {
                map["ReviewAudit"] = self.reviewAudit!
            }
            if self.reviewKeep != nil {
                map["ReviewKeep"] = self.reviewKeep!
            }
            if self.reviewPart != nil {
                map["ReviewPart"] = self.reviewPart!
            }
            if self.reviewPass != nil {
                map["ReviewPass"] = self.reviewPass!
            }
            if self.reviewSupplements != nil {
                map["ReviewSupplements"] = self.reviewSupplements?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ReviewAudit") && dict["ReviewAudit"] != nil {
                self.reviewAudit = dict["ReviewAudit"] as! String
            }
            if dict.keys.contains("ReviewKeep") && dict["ReviewKeep"] != nil {
                self.reviewKeep = dict["ReviewKeep"] as! String
            }
            if dict.keys.contains("ReviewPart") && dict["ReviewPart"] != nil {
                self.reviewPart = dict["ReviewPart"] as! String
            }
            if dict.keys.contains("ReviewPass") && dict["ReviewPass"] != nil {
                self.reviewPass = dict["ReviewPass"] as! String
            }
            if dict.keys.contains("ReviewSupplements") && dict["ReviewSupplements"] != nil {
                var model = QueryTradeMarkApplicationDetailResponseBody.ReviewOfficialFiles.ReviewSupplements()
                model.fromMap(dict["ReviewSupplements"] as! [String: Any])
                self.reviewSupplements = model
            }
        }
    }
    public class Supplements : Tea.TeaModel {
        public class Supplements : Tea.TeaModel {
            public class FileTemplateUrls : Tea.TeaModel {
                public var fileTemplateUrls: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.fileTemplateUrls != nil {
                        map["FileTemplateUrls"] = self.fileTemplateUrls!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("FileTemplateUrls") && dict["FileTemplateUrls"] != nil {
                        self.fileTemplateUrls = dict["FileTemplateUrls"] as! [String]
                    }
                }
            }
            public var acceptDeadTime: Int64?

            public var acceptTime: Int64?

            public var batchNum: String?

            public var content: String?

            public var fileTemplateUrls: QueryTradeMarkApplicationDetailResponseBody.Supplements.Supplements.FileTemplateUrls?

            public var filename: String?

            public var id: Int64?

            public var operateTime: Int64?

            public var orderId: String?

            public var sbjDeadTime: Int64?

            public var sendTime: Int64?

            public var serialNumber: String?

            public var status: Int32?

            public var tmNumber: String?

            public var type: Int32?

            public var uploadFileTemplateUrl: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.fileTemplateUrls?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.acceptDeadTime != nil {
                    map["AcceptDeadTime"] = self.acceptDeadTime!
                }
                if self.acceptTime != nil {
                    map["AcceptTime"] = self.acceptTime!
                }
                if self.batchNum != nil {
                    map["BatchNum"] = self.batchNum!
                }
                if self.content != nil {
                    map["Content"] = self.content!
                }
                if self.fileTemplateUrls != nil {
                    map["FileTemplateUrls"] = self.fileTemplateUrls?.toMap()
                }
                if self.filename != nil {
                    map["Filename"] = self.filename!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.operateTime != nil {
                    map["OperateTime"] = self.operateTime!
                }
                if self.orderId != nil {
                    map["OrderId"] = self.orderId!
                }
                if self.sbjDeadTime != nil {
                    map["SbjDeadTime"] = self.sbjDeadTime!
                }
                if self.sendTime != nil {
                    map["SendTime"] = self.sendTime!
                }
                if self.serialNumber != nil {
                    map["SerialNumber"] = self.serialNumber!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.tmNumber != nil {
                    map["TmNumber"] = self.tmNumber!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.uploadFileTemplateUrl != nil {
                    map["UploadFileTemplateUrl"] = self.uploadFileTemplateUrl!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AcceptDeadTime") && dict["AcceptDeadTime"] != nil {
                    self.acceptDeadTime = dict["AcceptDeadTime"] as! Int64
                }
                if dict.keys.contains("AcceptTime") && dict["AcceptTime"] != nil {
                    self.acceptTime = dict["AcceptTime"] as! Int64
                }
                if dict.keys.contains("BatchNum") && dict["BatchNum"] != nil {
                    self.batchNum = dict["BatchNum"] as! String
                }
                if dict.keys.contains("Content") && dict["Content"] != nil {
                    self.content = dict["Content"] as! String
                }
                if dict.keys.contains("FileTemplateUrls") && dict["FileTemplateUrls"] != nil {
                    var model = QueryTradeMarkApplicationDetailResponseBody.Supplements.Supplements.FileTemplateUrls()
                    model.fromMap(dict["FileTemplateUrls"] as! [String: Any])
                    self.fileTemplateUrls = model
                }
                if dict.keys.contains("Filename") && dict["Filename"] != nil {
                    self.filename = dict["Filename"] as! String
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("OperateTime") && dict["OperateTime"] != nil {
                    self.operateTime = dict["OperateTime"] as! Int64
                }
                if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
                    self.orderId = dict["OrderId"] as! String
                }
                if dict.keys.contains("SbjDeadTime") && dict["SbjDeadTime"] != nil {
                    self.sbjDeadTime = dict["SbjDeadTime"] as! Int64
                }
                if dict.keys.contains("SendTime") && dict["SendTime"] != nil {
                    self.sendTime = dict["SendTime"] as! Int64
                }
                if dict.keys.contains("SerialNumber") && dict["SerialNumber"] != nil {
                    self.serialNumber = dict["SerialNumber"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! Int32
                }
                if dict.keys.contains("TmNumber") && dict["TmNumber"] != nil {
                    self.tmNumber = dict["TmNumber"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! Int32
                }
                if dict.keys.contains("UploadFileTemplateUrl") && dict["UploadFileTemplateUrl"] != nil {
                    self.uploadFileTemplateUrl = dict["UploadFileTemplateUrl"] as! String
                }
            }
        }
        public var supplements: [QueryTradeMarkApplicationDetailResponseBody.Supplements.Supplements]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.supplements != nil {
                var tmp : [Any] = []
                for k in self.supplements! {
                    tmp.append(k.toMap())
                }
                map["Supplements"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Supplements") && dict["Supplements"] != nil {
                var tmp : [QueryTradeMarkApplicationDetailResponseBody.Supplements.Supplements] = []
                for v in dict["Supplements"] as! [Any] {
                    var model = QueryTradeMarkApplicationDetailResponseBody.Supplements.Supplements()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.supplements = tmp
            }
        }
    }
    public class ThirdClassification : Tea.TeaModel {
        public class ThirdClassifications : Tea.TeaModel {
            public var code: String?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Code") && dict["Code"] != nil {
                    self.code = dict["Code"] as! String
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
            }
        }
        public var thirdClassifications: [QueryTradeMarkApplicationDetailResponseBody.ThirdClassification.ThirdClassifications]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.thirdClassifications != nil {
                var tmp : [Any] = []
                for k in self.thirdClassifications! {
                    tmp.append(k.toMap())
                }
                map["ThirdClassifications"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ThirdClassifications") && dict["ThirdClassifications"] != nil {
                var tmp : [QueryTradeMarkApplicationDetailResponseBody.ThirdClassification.ThirdClassifications] = []
                for v in dict["ThirdClassifications"] as! [Any] {
                    var model = QueryTradeMarkApplicationDetailResponseBody.ThirdClassification.ThirdClassifications()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.thirdClassifications = tmp
            }
        }
    }
    public var acceptUrl: String?

    public var adminUploads: QueryTradeMarkApplicationDetailResponseBody.AdminUploads?

    public var bizId: String?

    public var createTime: Int64?

    public var extendInfo: [String: Any]?

    public var firstClassification: QueryTradeMarkApplicationDetailResponseBody.FirstClassification?

    public var flags: QueryTradeMarkApplicationDetailResponseBody.Flags?

    public var grayIconUrl: String?

    public var judgeResultUrl: QueryTradeMarkApplicationDetailResponseBody.JudgeResultUrl?

    public var legalNoticeUrl: String?

    public var loaUrl: String?

    public var logisticsCertificateUrl: String?

    public var logisticsNo: String?

    public var materialDetail: QueryTradeMarkApplicationDetailResponseBody.MaterialDetail?

    public var materialId: Int64?

    public var notAcceptUrl: String?

    public var note: String?

    public var orderId: String?

    public var orderPrice: Double?

    public var partnerCode: String?

    public var partnerMobile: String?

    public var partnerName: String?

    public var principalName: Int32?

    public var receiptUrl: QueryTradeMarkApplicationDetailResponseBody.ReceiptUrl?

    public var recvUserLogistics: String?

    public var renewResponse: QueryTradeMarkApplicationDetailResponseBody.RenewResponse?

    public var requestId: String?

    public var reviewOfficialFiles: QueryTradeMarkApplicationDetailResponseBody.ReviewOfficialFiles?

    public var sendSbjLogistics: String?

    public var sendTime: String?

    public var sendUserLogistics: String?

    public var servicePrice: Double?

    public var specification: Int32?

    public var status: Int32?

    public var submitAuditTime: Int64?

    public var submitTime: Int64?

    public var supplements: QueryTradeMarkApplicationDetailResponseBody.Supplements?

    public var systemVersion: String?

    public var thirdClassification: QueryTradeMarkApplicationDetailResponseBody.ThirdClassification?

    public var tmIcon: String?

    public var tmName: String?

    public var tmNameType: Int32?

    public var tmNumber: String?

    public var totalPrice: Double?

    public var type: Int32?

    public var updateTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.adminUploads?.validate()
        try self.firstClassification?.validate()
        try self.flags?.validate()
        try self.judgeResultUrl?.validate()
        try self.materialDetail?.validate()
        try self.receiptUrl?.validate()
        try self.renewResponse?.validate()
        try self.reviewOfficialFiles?.validate()
        try self.supplements?.validate()
        try self.thirdClassification?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptUrl != nil {
            map["AcceptUrl"] = self.acceptUrl!
        }
        if self.adminUploads != nil {
            map["AdminUploads"] = self.adminUploads?.toMap()
        }
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.extendInfo != nil {
            map["ExtendInfo"] = self.extendInfo!
        }
        if self.firstClassification != nil {
            map["FirstClassification"] = self.firstClassification?.toMap()
        }
        if self.flags != nil {
            map["Flags"] = self.flags?.toMap()
        }
        if self.grayIconUrl != nil {
            map["GrayIconUrl"] = self.grayIconUrl!
        }
        if self.judgeResultUrl != nil {
            map["JudgeResultUrl"] = self.judgeResultUrl?.toMap()
        }
        if self.legalNoticeUrl != nil {
            map["LegalNoticeUrl"] = self.legalNoticeUrl!
        }
        if self.loaUrl != nil {
            map["LoaUrl"] = self.loaUrl!
        }
        if self.logisticsCertificateUrl != nil {
            map["LogisticsCertificateUrl"] = self.logisticsCertificateUrl!
        }
        if self.logisticsNo != nil {
            map["LogisticsNo"] = self.logisticsNo!
        }
        if self.materialDetail != nil {
            map["MaterialDetail"] = self.materialDetail?.toMap()
        }
        if self.materialId != nil {
            map["MaterialId"] = self.materialId!
        }
        if self.notAcceptUrl != nil {
            map["NotAcceptUrl"] = self.notAcceptUrl!
        }
        if self.note != nil {
            map["Note"] = self.note!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.orderPrice != nil {
            map["OrderPrice"] = self.orderPrice!
        }
        if self.partnerCode != nil {
            map["PartnerCode"] = self.partnerCode!
        }
        if self.partnerMobile != nil {
            map["PartnerMobile"] = self.partnerMobile!
        }
        if self.partnerName != nil {
            map["PartnerName"] = self.partnerName!
        }
        if self.principalName != nil {
            map["PrincipalName"] = self.principalName!
        }
        if self.receiptUrl != nil {
            map["ReceiptUrl"] = self.receiptUrl?.toMap()
        }
        if self.recvUserLogistics != nil {
            map["RecvUserLogistics"] = self.recvUserLogistics!
        }
        if self.renewResponse != nil {
            map["RenewResponse"] = self.renewResponse?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.reviewOfficialFiles != nil {
            map["ReviewOfficialFiles"] = self.reviewOfficialFiles?.toMap()
        }
        if self.sendSbjLogistics != nil {
            map["SendSbjLogistics"] = self.sendSbjLogistics!
        }
        if self.sendTime != nil {
            map["SendTime"] = self.sendTime!
        }
        if self.sendUserLogistics != nil {
            map["SendUserLogistics"] = self.sendUserLogistics!
        }
        if self.servicePrice != nil {
            map["ServicePrice"] = self.servicePrice!
        }
        if self.specification != nil {
            map["Specification"] = self.specification!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.submitAuditTime != nil {
            map["SubmitAuditTime"] = self.submitAuditTime!
        }
        if self.submitTime != nil {
            map["SubmitTime"] = self.submitTime!
        }
        if self.supplements != nil {
            map["Supplements"] = self.supplements?.toMap()
        }
        if self.systemVersion != nil {
            map["SystemVersion"] = self.systemVersion!
        }
        if self.thirdClassification != nil {
            map["ThirdClassification"] = self.thirdClassification?.toMap()
        }
        if self.tmIcon != nil {
            map["TmIcon"] = self.tmIcon!
        }
        if self.tmName != nil {
            map["TmName"] = self.tmName!
        }
        if self.tmNameType != nil {
            map["TmNameType"] = self.tmNameType!
        }
        if self.tmNumber != nil {
            map["TmNumber"] = self.tmNumber!
        }
        if self.totalPrice != nil {
            map["TotalPrice"] = self.totalPrice!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.updateTime != nil {
            map["UpdateTime"] = self.updateTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptUrl") && dict["AcceptUrl"] != nil {
            self.acceptUrl = dict["AcceptUrl"] as! String
        }
        if dict.keys.contains("AdminUploads") && dict["AdminUploads"] != nil {
            var model = QueryTradeMarkApplicationDetailResponseBody.AdminUploads()
            model.fromMap(dict["AdminUploads"] as! [String: Any])
            self.adminUploads = model
        }
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
            self.createTime = dict["CreateTime"] as! Int64
        }
        if dict.keys.contains("ExtendInfo") && dict["ExtendInfo"] != nil {
            self.extendInfo = dict["ExtendInfo"] as! [String: Any]
        }
        if dict.keys.contains("FirstClassification") && dict["FirstClassification"] != nil {
            var model = QueryTradeMarkApplicationDetailResponseBody.FirstClassification()
            model.fromMap(dict["FirstClassification"] as! [String: Any])
            self.firstClassification = model
        }
        if dict.keys.contains("Flags") && dict["Flags"] != nil {
            var model = QueryTradeMarkApplicationDetailResponseBody.Flags()
            model.fromMap(dict["Flags"] as! [String: Any])
            self.flags = model
        }
        if dict.keys.contains("GrayIconUrl") && dict["GrayIconUrl"] != nil {
            self.grayIconUrl = dict["GrayIconUrl"] as! String
        }
        if dict.keys.contains("JudgeResultUrl") && dict["JudgeResultUrl"] != nil {
            var model = QueryTradeMarkApplicationDetailResponseBody.JudgeResultUrl()
            model.fromMap(dict["JudgeResultUrl"] as! [String: Any])
            self.judgeResultUrl = model
        }
        if dict.keys.contains("LegalNoticeUrl") && dict["LegalNoticeUrl"] != nil {
            self.legalNoticeUrl = dict["LegalNoticeUrl"] as! String
        }
        if dict.keys.contains("LoaUrl") && dict["LoaUrl"] != nil {
            self.loaUrl = dict["LoaUrl"] as! String
        }
        if dict.keys.contains("LogisticsCertificateUrl") && dict["LogisticsCertificateUrl"] != nil {
            self.logisticsCertificateUrl = dict["LogisticsCertificateUrl"] as! String
        }
        if dict.keys.contains("LogisticsNo") && dict["LogisticsNo"] != nil {
            self.logisticsNo = dict["LogisticsNo"] as! String
        }
        if dict.keys.contains("MaterialDetail") && dict["MaterialDetail"] != nil {
            var model = QueryTradeMarkApplicationDetailResponseBody.MaterialDetail()
            model.fromMap(dict["MaterialDetail"] as! [String: Any])
            self.materialDetail = model
        }
        if dict.keys.contains("MaterialId") && dict["MaterialId"] != nil {
            self.materialId = dict["MaterialId"] as! Int64
        }
        if dict.keys.contains("NotAcceptUrl") && dict["NotAcceptUrl"] != nil {
            self.notAcceptUrl = dict["NotAcceptUrl"] as! String
        }
        if dict.keys.contains("Note") && dict["Note"] != nil {
            self.note = dict["Note"] as! String
        }
        if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
            self.orderId = dict["OrderId"] as! String
        }
        if dict.keys.contains("OrderPrice") && dict["OrderPrice"] != nil {
            self.orderPrice = dict["OrderPrice"] as! Double
        }
        if dict.keys.contains("PartnerCode") && dict["PartnerCode"] != nil {
            self.partnerCode = dict["PartnerCode"] as! String
        }
        if dict.keys.contains("PartnerMobile") && dict["PartnerMobile"] != nil {
            self.partnerMobile = dict["PartnerMobile"] as! String
        }
        if dict.keys.contains("PartnerName") && dict["PartnerName"] != nil {
            self.partnerName = dict["PartnerName"] as! String
        }
        if dict.keys.contains("PrincipalName") && dict["PrincipalName"] != nil {
            self.principalName = dict["PrincipalName"] as! Int32
        }
        if dict.keys.contains("ReceiptUrl") && dict["ReceiptUrl"] != nil {
            var model = QueryTradeMarkApplicationDetailResponseBody.ReceiptUrl()
            model.fromMap(dict["ReceiptUrl"] as! [String: Any])
            self.receiptUrl = model
        }
        if dict.keys.contains("RecvUserLogistics") && dict["RecvUserLogistics"] != nil {
            self.recvUserLogistics = dict["RecvUserLogistics"] as! String
        }
        if dict.keys.contains("RenewResponse") && dict["RenewResponse"] != nil {
            var model = QueryTradeMarkApplicationDetailResponseBody.RenewResponse()
            model.fromMap(dict["RenewResponse"] as! [String: Any])
            self.renewResponse = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ReviewOfficialFiles") && dict["ReviewOfficialFiles"] != nil {
            var model = QueryTradeMarkApplicationDetailResponseBody.ReviewOfficialFiles()
            model.fromMap(dict["ReviewOfficialFiles"] as! [String: Any])
            self.reviewOfficialFiles = model
        }
        if dict.keys.contains("SendSbjLogistics") && dict["SendSbjLogistics"] != nil {
            self.sendSbjLogistics = dict["SendSbjLogistics"] as! String
        }
        if dict.keys.contains("SendTime") && dict["SendTime"] != nil {
            self.sendTime = dict["SendTime"] as! String
        }
        if dict.keys.contains("SendUserLogistics") && dict["SendUserLogistics"] != nil {
            self.sendUserLogistics = dict["SendUserLogistics"] as! String
        }
        if dict.keys.contains("ServicePrice") && dict["ServicePrice"] != nil {
            self.servicePrice = dict["ServicePrice"] as! Double
        }
        if dict.keys.contains("Specification") && dict["Specification"] != nil {
            self.specification = dict["Specification"] as! Int32
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! Int32
        }
        if dict.keys.contains("SubmitAuditTime") && dict["SubmitAuditTime"] != nil {
            self.submitAuditTime = dict["SubmitAuditTime"] as! Int64
        }
        if dict.keys.contains("SubmitTime") && dict["SubmitTime"] != nil {
            self.submitTime = dict["SubmitTime"] as! Int64
        }
        if dict.keys.contains("Supplements") && dict["Supplements"] != nil {
            var model = QueryTradeMarkApplicationDetailResponseBody.Supplements()
            model.fromMap(dict["Supplements"] as! [String: Any])
            self.supplements = model
        }
        if dict.keys.contains("SystemVersion") && dict["SystemVersion"] != nil {
            self.systemVersion = dict["SystemVersion"] as! String
        }
        if dict.keys.contains("ThirdClassification") && dict["ThirdClassification"] != nil {
            var model = QueryTradeMarkApplicationDetailResponseBody.ThirdClassification()
            model.fromMap(dict["ThirdClassification"] as! [String: Any])
            self.thirdClassification = model
        }
        if dict.keys.contains("TmIcon") && dict["TmIcon"] != nil {
            self.tmIcon = dict["TmIcon"] as! String
        }
        if dict.keys.contains("TmName") && dict["TmName"] != nil {
            self.tmName = dict["TmName"] as! String
        }
        if dict.keys.contains("TmNameType") && dict["TmNameType"] != nil {
            self.tmNameType = dict["TmNameType"] as! Int32
        }
        if dict.keys.contains("TmNumber") && dict["TmNumber"] != nil {
            self.tmNumber = dict["TmNumber"] as! String
        }
        if dict.keys.contains("TotalPrice") && dict["TotalPrice"] != nil {
            self.totalPrice = dict["TotalPrice"] as! Double
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! Int32
        }
        if dict.keys.contains("UpdateTime") && dict["UpdateTime"] != nil {
            self.updateTime = dict["UpdateTime"] as! Int64
        }
    }
}

public class QueryTradeMarkApplicationDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryTradeMarkApplicationDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryTradeMarkApplicationDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryTradeMarkApplicationLogsRequest : Tea.TeaModel {
    public var bizId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
    }
}

public class QueryTradeMarkApplicationLogsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Data : Tea.TeaModel {
            public var bizId: String?

            public var bizStatus: Int32?

            public var extendContent: String?

            public var note: String?

            public var operateTime: Int64?

            public var operateType: Int32?

            public var toBizStatus: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bizId != nil {
                    map["BizId"] = self.bizId!
                }
                if self.bizStatus != nil {
                    map["BizStatus"] = self.bizStatus!
                }
                if self.extendContent != nil {
                    map["ExtendContent"] = self.extendContent!
                }
                if self.note != nil {
                    map["Note"] = self.note!
                }
                if self.operateTime != nil {
                    map["OperateTime"] = self.operateTime!
                }
                if self.operateType != nil {
                    map["OperateType"] = self.operateType!
                }
                if self.toBizStatus != nil {
                    map["ToBizStatus"] = self.toBizStatus!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BizId") && dict["BizId"] != nil {
                    self.bizId = dict["BizId"] as! String
                }
                if dict.keys.contains("BizStatus") && dict["BizStatus"] != nil {
                    self.bizStatus = dict["BizStatus"] as! Int32
                }
                if dict.keys.contains("ExtendContent") && dict["ExtendContent"] != nil {
                    self.extendContent = dict["ExtendContent"] as! String
                }
                if dict.keys.contains("Note") && dict["Note"] != nil {
                    self.note = dict["Note"] as! String
                }
                if dict.keys.contains("OperateTime") && dict["OperateTime"] != nil {
                    self.operateTime = dict["OperateTime"] as! Int64
                }
                if dict.keys.contains("OperateType") && dict["OperateType"] != nil {
                    self.operateType = dict["OperateType"] as! Int32
                }
                if dict.keys.contains("ToBizStatus") && dict["ToBizStatus"] != nil {
                    self.toBizStatus = dict["ToBizStatus"] as! Int32
                }
            }
        }
        public var data: [QueryTradeMarkApplicationLogsResponseBody.Data.Data]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.data != nil {
                var tmp : [Any] = []
                for k in self.data! {
                    tmp.append(k.toMap())
                }
                map["Data"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Data") && dict["Data"] != nil {
                var tmp : [QueryTradeMarkApplicationLogsResponseBody.Data.Data] = []
                for v in dict["Data"] as! [Any] {
                    var model = QueryTradeMarkApplicationLogsResponseBody.Data.Data()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.data = tmp
            }
        }
    }
    public var data: QueryTradeMarkApplicationLogsResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = QueryTradeMarkApplicationLogsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class QueryTradeMarkApplicationLogsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryTradeMarkApplicationLogsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryTradeMarkApplicationLogsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryTradeMarkApplicationsRequest : Tea.TeaModel {
    public var bizId: String?

    public var classificationCode: String?

    public var hidden: Int32?

    public var intentionBizId: String?

    public var logisticsNo: String?

    public var materialName: String?

    public var orderId: String?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var productType: Int32?

    public var sortFiled: String?

    public var sortOrder: String?

    public var specification: Int32?

    public var status: Int32?

    public var supplementStatus: Int32?

    public var tmName: String?

    public var tmNumber: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.classificationCode != nil {
            map["ClassificationCode"] = self.classificationCode!
        }
        if self.hidden != nil {
            map["Hidden"] = self.hidden!
        }
        if self.intentionBizId != nil {
            map["IntentionBizId"] = self.intentionBizId!
        }
        if self.logisticsNo != nil {
            map["LogisticsNo"] = self.logisticsNo!
        }
        if self.materialName != nil {
            map["MaterialName"] = self.materialName!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.productType != nil {
            map["ProductType"] = self.productType!
        }
        if self.sortFiled != nil {
            map["SortFiled"] = self.sortFiled!
        }
        if self.sortOrder != nil {
            map["SortOrder"] = self.sortOrder!
        }
        if self.specification != nil {
            map["Specification"] = self.specification!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.supplementStatus != nil {
            map["SupplementStatus"] = self.supplementStatus!
        }
        if self.tmName != nil {
            map["TmName"] = self.tmName!
        }
        if self.tmNumber != nil {
            map["TmNumber"] = self.tmNumber!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("ClassificationCode") && dict["ClassificationCode"] != nil {
            self.classificationCode = dict["ClassificationCode"] as! String
        }
        if dict.keys.contains("Hidden") && dict["Hidden"] != nil {
            self.hidden = dict["Hidden"] as! Int32
        }
        if dict.keys.contains("IntentionBizId") && dict["IntentionBizId"] != nil {
            self.intentionBizId = dict["IntentionBizId"] as! String
        }
        if dict.keys.contains("LogisticsNo") && dict["LogisticsNo"] != nil {
            self.logisticsNo = dict["LogisticsNo"] as! String
        }
        if dict.keys.contains("MaterialName") && dict["MaterialName"] != nil {
            self.materialName = dict["MaterialName"] as! String
        }
        if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
            self.orderId = dict["OrderId"] as! String
        }
        if dict.keys.contains("PageNum") && dict["PageNum"] != nil {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ProductType") && dict["ProductType"] != nil {
            self.productType = dict["ProductType"] as! Int32
        }
        if dict.keys.contains("SortFiled") && dict["SortFiled"] != nil {
            self.sortFiled = dict["SortFiled"] as! String
        }
        if dict.keys.contains("SortOrder") && dict["SortOrder"] != nil {
            self.sortOrder = dict["SortOrder"] as! String
        }
        if dict.keys.contains("Specification") && dict["Specification"] != nil {
            self.specification = dict["Specification"] as! Int32
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! Int32
        }
        if dict.keys.contains("SupplementStatus") && dict["SupplementStatus"] != nil {
            self.supplementStatus = dict["SupplementStatus"] as! Int32
        }
        if dict.keys.contains("TmName") && dict["TmName"] != nil {
            self.tmName = dict["TmName"] as! String
        }
        if dict.keys.contains("TmNumber") && dict["TmNumber"] != nil {
            self.tmNumber = dict["TmNumber"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class QueryTradeMarkApplicationsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class TmProduces : Tea.TeaModel {
            public class FirstClassification : Tea.TeaModel {
                public var classificationCode: String?

                public var classificationName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.classificationCode != nil {
                        map["ClassificationCode"] = self.classificationCode!
                    }
                    if self.classificationName != nil {
                        map["ClassificationName"] = self.classificationName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ClassificationCode") && dict["ClassificationCode"] != nil {
                        self.classificationCode = dict["ClassificationCode"] as! String
                    }
                    if dict.keys.contains("ClassificationName") && dict["ClassificationName"] != nil {
                        self.classificationName = dict["ClassificationName"] as! String
                    }
                }
            }
            public class Flags : Tea.TeaModel {
                public var flags: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.flags != nil {
                        map["Flags"] = self.flags!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Flags") && dict["Flags"] != nil {
                        self.flags = dict["Flags"] as! [String]
                    }
                }
            }
            public class RenewResponse : Tea.TeaModel {
                public var address: String?

                public var engAddress: String?

                public var engName: String?

                public var name: String?

                public var registerTime: Int64?

                public var submitSbjtime: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.address != nil {
                        map["Address"] = self.address!
                    }
                    if self.engAddress != nil {
                        map["EngAddress"] = self.engAddress!
                    }
                    if self.engName != nil {
                        map["EngName"] = self.engName!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.registerTime != nil {
                        map["RegisterTime"] = self.registerTime!
                    }
                    if self.submitSbjtime != nil {
                        map["SubmitSbjtime"] = self.submitSbjtime!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Address") && dict["Address"] != nil {
                        self.address = dict["Address"] as! String
                    }
                    if dict.keys.contains("EngAddress") && dict["EngAddress"] != nil {
                        self.engAddress = dict["EngAddress"] as! String
                    }
                    if dict.keys.contains("EngName") && dict["EngName"] != nil {
                        self.engName = dict["EngName"] as! String
                    }
                    if dict.keys.contains("Name") && dict["Name"] != nil {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("RegisterTime") && dict["RegisterTime"] != nil {
                        self.registerTime = dict["RegisterTime"] as! Int64
                    }
                    if dict.keys.contains("SubmitSbjtime") && dict["SubmitSbjtime"] != nil {
                        self.submitSbjtime = dict["SubmitSbjtime"] as! Int64
                    }
                }
            }
            public class ThirdClassification : Tea.TeaModel {
                public class ThirdClassifications : Tea.TeaModel {
                    public var classificationCode: String?

                    public var classificationName: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.classificationCode != nil {
                            map["ClassificationCode"] = self.classificationCode!
                        }
                        if self.classificationName != nil {
                            map["ClassificationName"] = self.classificationName!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ClassificationCode") && dict["ClassificationCode"] != nil {
                            self.classificationCode = dict["ClassificationCode"] as! String
                        }
                        if dict.keys.contains("ClassificationName") && dict["ClassificationName"] != nil {
                            self.classificationName = dict["ClassificationName"] as! String
                        }
                    }
                }
                public var thirdClassifications: [QueryTradeMarkApplicationsResponseBody.Data.TmProduces.ThirdClassification.ThirdClassifications]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.thirdClassifications != nil {
                        var tmp : [Any] = []
                        for k in self.thirdClassifications! {
                            tmp.append(k.toMap())
                        }
                        map["ThirdClassifications"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ThirdClassifications") && dict["ThirdClassifications"] != nil {
                        var tmp : [QueryTradeMarkApplicationsResponseBody.Data.TmProduces.ThirdClassification.ThirdClassifications] = []
                        for v in dict["ThirdClassifications"] as! [Any] {
                            var model = QueryTradeMarkApplicationsResponseBody.Data.TmProduces.ThirdClassification.ThirdClassifications()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.thirdClassifications = tmp
                    }
                }
            }
            public var agreementId: String?

            public var bizId: String?

            public var createTime: Int64?

            public var firstClassification: QueryTradeMarkApplicationsResponseBody.Data.TmProduces.FirstClassification?

            public var flags: QueryTradeMarkApplicationsResponseBody.Data.TmProduces.Flags?

            public var loaUrl: String?

            public var materialId: Int64?

            public var materialName: String?

            public var note: String?

            public var orderId: String?

            public var orderPrice: Double?

            public var principalName: Int32?

            public var remark: String?

            public var renewResponse: QueryTradeMarkApplicationsResponseBody.Data.TmProduces.RenewResponse?

            public var servicePrice: Double?

            public var showGoToDefendButton: Bool?

            public var specification: Int32?

            public var status: Int32?

            public var submitAuditTime: Int64?

            public var submitTime: Int64?

            public var supplementId: Int64?

            public var supplementStatus: Int32?

            public var systemVersion: String?

            public var thirdClassification: QueryTradeMarkApplicationsResponseBody.Data.TmProduces.ThirdClassification?

            public var tmIcon: String?

            public var tmName: String?

            public var tmNumber: String?

            public var totalPrice: Double?

            public var type: Int32?

            public var updateTime: Int64?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.firstClassification?.validate()
                try self.flags?.validate()
                try self.renewResponse?.validate()
                try self.thirdClassification?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.agreementId != nil {
                    map["AgreementId"] = self.agreementId!
                }
                if self.bizId != nil {
                    map["BizId"] = self.bizId!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.firstClassification != nil {
                    map["FirstClassification"] = self.firstClassification?.toMap()
                }
                if self.flags != nil {
                    map["Flags"] = self.flags?.toMap()
                }
                if self.loaUrl != nil {
                    map["LoaUrl"] = self.loaUrl!
                }
                if self.materialId != nil {
                    map["MaterialId"] = self.materialId!
                }
                if self.materialName != nil {
                    map["MaterialName"] = self.materialName!
                }
                if self.note != nil {
                    map["Note"] = self.note!
                }
                if self.orderId != nil {
                    map["OrderId"] = self.orderId!
                }
                if self.orderPrice != nil {
                    map["OrderPrice"] = self.orderPrice!
                }
                if self.principalName != nil {
                    map["PrincipalName"] = self.principalName!
                }
                if self.remark != nil {
                    map["Remark"] = self.remark!
                }
                if self.renewResponse != nil {
                    map["RenewResponse"] = self.renewResponse?.toMap()
                }
                if self.servicePrice != nil {
                    map["ServicePrice"] = self.servicePrice!
                }
                if self.showGoToDefendButton != nil {
                    map["ShowGoToDefendButton"] = self.showGoToDefendButton!
                }
                if self.specification != nil {
                    map["Specification"] = self.specification!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.submitAuditTime != nil {
                    map["SubmitAuditTime"] = self.submitAuditTime!
                }
                if self.submitTime != nil {
                    map["SubmitTime"] = self.submitTime!
                }
                if self.supplementId != nil {
                    map["SupplementId"] = self.supplementId!
                }
                if self.supplementStatus != nil {
                    map["SupplementStatus"] = self.supplementStatus!
                }
                if self.systemVersion != nil {
                    map["SystemVersion"] = self.systemVersion!
                }
                if self.thirdClassification != nil {
                    map["ThirdClassification"] = self.thirdClassification?.toMap()
                }
                if self.tmIcon != nil {
                    map["TmIcon"] = self.tmIcon!
                }
                if self.tmName != nil {
                    map["TmName"] = self.tmName!
                }
                if self.tmNumber != nil {
                    map["TmNumber"] = self.tmNumber!
                }
                if self.totalPrice != nil {
                    map["TotalPrice"] = self.totalPrice!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AgreementId") && dict["AgreementId"] != nil {
                    self.agreementId = dict["AgreementId"] as! String
                }
                if dict.keys.contains("BizId") && dict["BizId"] != nil {
                    self.bizId = dict["BizId"] as! String
                }
                if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("FirstClassification") && dict["FirstClassification"] != nil {
                    var model = QueryTradeMarkApplicationsResponseBody.Data.TmProduces.FirstClassification()
                    model.fromMap(dict["FirstClassification"] as! [String: Any])
                    self.firstClassification = model
                }
                if dict.keys.contains("Flags") && dict["Flags"] != nil {
                    var model = QueryTradeMarkApplicationsResponseBody.Data.TmProduces.Flags()
                    model.fromMap(dict["Flags"] as! [String: Any])
                    self.flags = model
                }
                if dict.keys.contains("LoaUrl") && dict["LoaUrl"] != nil {
                    self.loaUrl = dict["LoaUrl"] as! String
                }
                if dict.keys.contains("MaterialId") && dict["MaterialId"] != nil {
                    self.materialId = dict["MaterialId"] as! Int64
                }
                if dict.keys.contains("MaterialName") && dict["MaterialName"] != nil {
                    self.materialName = dict["MaterialName"] as! String
                }
                if dict.keys.contains("Note") && dict["Note"] != nil {
                    self.note = dict["Note"] as! String
                }
                if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
                    self.orderId = dict["OrderId"] as! String
                }
                if dict.keys.contains("OrderPrice") && dict["OrderPrice"] != nil {
                    self.orderPrice = dict["OrderPrice"] as! Double
                }
                if dict.keys.contains("PrincipalName") && dict["PrincipalName"] != nil {
                    self.principalName = dict["PrincipalName"] as! Int32
                }
                if dict.keys.contains("Remark") && dict["Remark"] != nil {
                    self.remark = dict["Remark"] as! String
                }
                if dict.keys.contains("RenewResponse") && dict["RenewResponse"] != nil {
                    var model = QueryTradeMarkApplicationsResponseBody.Data.TmProduces.RenewResponse()
                    model.fromMap(dict["RenewResponse"] as! [String: Any])
                    self.renewResponse = model
                }
                if dict.keys.contains("ServicePrice") && dict["ServicePrice"] != nil {
                    self.servicePrice = dict["ServicePrice"] as! Double
                }
                if dict.keys.contains("ShowGoToDefendButton") && dict["ShowGoToDefendButton"] != nil {
                    self.showGoToDefendButton = dict["ShowGoToDefendButton"] as! Bool
                }
                if dict.keys.contains("Specification") && dict["Specification"] != nil {
                    self.specification = dict["Specification"] as! Int32
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! Int32
                }
                if dict.keys.contains("SubmitAuditTime") && dict["SubmitAuditTime"] != nil {
                    self.submitAuditTime = dict["SubmitAuditTime"] as! Int64
                }
                if dict.keys.contains("SubmitTime") && dict["SubmitTime"] != nil {
                    self.submitTime = dict["SubmitTime"] as! Int64
                }
                if dict.keys.contains("SupplementId") && dict["SupplementId"] != nil {
                    self.supplementId = dict["SupplementId"] as! Int64
                }
                if dict.keys.contains("SupplementStatus") && dict["SupplementStatus"] != nil {
                    self.supplementStatus = dict["SupplementStatus"] as! Int32
                }
                if dict.keys.contains("SystemVersion") && dict["SystemVersion"] != nil {
                    self.systemVersion = dict["SystemVersion"] as! String
                }
                if dict.keys.contains("ThirdClassification") && dict["ThirdClassification"] != nil {
                    var model = QueryTradeMarkApplicationsResponseBody.Data.TmProduces.ThirdClassification()
                    model.fromMap(dict["ThirdClassification"] as! [String: Any])
                    self.thirdClassification = model
                }
                if dict.keys.contains("TmIcon") && dict["TmIcon"] != nil {
                    self.tmIcon = dict["TmIcon"] as! String
                }
                if dict.keys.contains("TmName") && dict["TmName"] != nil {
                    self.tmName = dict["TmName"] as! String
                }
                if dict.keys.contains("TmNumber") && dict["TmNumber"] != nil {
                    self.tmNumber = dict["TmNumber"] as! String
                }
                if dict.keys.contains("TotalPrice") && dict["TotalPrice"] != nil {
                    self.totalPrice = dict["TotalPrice"] as! Double
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! Int32
                }
                if dict.keys.contains("UpdateTime") && dict["UpdateTime"] != nil {
                    self.updateTime = dict["UpdateTime"] as! Int64
                }
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! String
                }
            }
        }
        public var tmProduces: [QueryTradeMarkApplicationsResponseBody.Data.TmProduces]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tmProduces != nil {
                var tmp : [Any] = []
                for k in self.tmProduces! {
                    tmp.append(k.toMap())
                }
                map["TmProduces"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TmProduces") && dict["TmProduces"] != nil {
                var tmp : [QueryTradeMarkApplicationsResponseBody.Data.TmProduces] = []
                for v in dict["TmProduces"] as! [Any] {
                    var model = QueryTradeMarkApplicationsResponseBody.Data.TmProduces()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tmProduces = tmp
            }
        }
    }
    public var currentPageNum: Int32?

    public var data: QueryTradeMarkApplicationsResponseBody.Data?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalItemNum: Int32?

    public var totalPageNum: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPageNum != nil {
            map["CurrentPageNum"] = self.currentPageNum!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalItemNum != nil {
            map["TotalItemNum"] = self.totalItemNum!
        }
        if self.totalPageNum != nil {
            map["TotalPageNum"] = self.totalPageNum!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPageNum") && dict["CurrentPageNum"] != nil {
            self.currentPageNum = dict["CurrentPageNum"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = QueryTradeMarkApplicationsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalItemNum") && dict["TotalItemNum"] != nil {
            self.totalItemNum = dict["TotalItemNum"] as! Int32
        }
        if dict.keys.contains("TotalPageNum") && dict["TotalPageNum"] != nil {
            self.totalPageNum = dict["TotalPageNum"] as! Int32
        }
    }
}

public class QueryTradeMarkApplicationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryTradeMarkApplicationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryTradeMarkApplicationsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryTradeMarkApplicationsByIntentionRequest : Tea.TeaModel {
    public var channel: String?

    public var intentionBizId: String?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var tmProduceStatus: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.channel != nil {
            map["Channel"] = self.channel!
        }
        if self.intentionBizId != nil {
            map["IntentionBizId"] = self.intentionBizId!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.tmProduceStatus != nil {
            map["TmProduceStatus"] = self.tmProduceStatus!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Channel") && dict["Channel"] != nil {
            self.channel = dict["Channel"] as! String
        }
        if dict.keys.contains("IntentionBizId") && dict["IntentionBizId"] != nil {
            self.intentionBizId = dict["IntentionBizId"] as! String
        }
        if dict.keys.contains("PageNum") && dict["PageNum"] != nil {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("TmProduceStatus") && dict["TmProduceStatus"] != nil {
            self.tmProduceStatus = dict["TmProduceStatus"] as! String
        }
    }
}

public class QueryTradeMarkApplicationsByIntentionResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class TmProduces : Tea.TeaModel {
            public class FirstClassification : Tea.TeaModel {
                public var classificationCode: String?

                public var classificationName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.classificationCode != nil {
                        map["ClassificationCode"] = self.classificationCode!
                    }
                    if self.classificationName != nil {
                        map["ClassificationName"] = self.classificationName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ClassificationCode") && dict["ClassificationCode"] != nil {
                        self.classificationCode = dict["ClassificationCode"] as! String
                    }
                    if dict.keys.contains("ClassificationName") && dict["ClassificationName"] != nil {
                        self.classificationName = dict["ClassificationName"] as! String
                    }
                }
            }
            public class ThirdClassification : Tea.TeaModel {
                public class ThirdClassifications : Tea.TeaModel {
                    public var classificationCode: String?

                    public var classificationName: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.classificationCode != nil {
                            map["ClassificationCode"] = self.classificationCode!
                        }
                        if self.classificationName != nil {
                            map["ClassificationName"] = self.classificationName!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ClassificationCode") && dict["ClassificationCode"] != nil {
                            self.classificationCode = dict["ClassificationCode"] as! String
                        }
                        if dict.keys.contains("ClassificationName") && dict["ClassificationName"] != nil {
                            self.classificationName = dict["ClassificationName"] as! String
                        }
                    }
                }
                public var thirdClassifications: [QueryTradeMarkApplicationsByIntentionResponseBody.Data.TmProduces.ThirdClassification.ThirdClassifications]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.thirdClassifications != nil {
                        var tmp : [Any] = []
                        for k in self.thirdClassifications! {
                            tmp.append(k.toMap())
                        }
                        map["ThirdClassifications"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ThirdClassifications") && dict["ThirdClassifications"] != nil {
                        var tmp : [QueryTradeMarkApplicationsByIntentionResponseBody.Data.TmProduces.ThirdClassification.ThirdClassifications] = []
                        for v in dict["ThirdClassifications"] as! [Any] {
                            var model = QueryTradeMarkApplicationsByIntentionResponseBody.Data.TmProduces.ThirdClassification.ThirdClassifications()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.thirdClassifications = tmp
                    }
                }
            }
            public var bizId: String?

            public var createTime: Int64?

            public var firstClassification: QueryTradeMarkApplicationsByIntentionResponseBody.Data.TmProduces.FirstClassification?

            public var loaUrl: String?

            public var materialId: String?

            public var materialName: String?

            public var note: String?

            public var orderPrice: Double?

            public var principalDescription: String?

            public var principalValue: Int32?

            public var servicePrice: Double?

            public var status: Int32?

            public var supplementId: Int64?

            public var supplementStatus: Int32?

            public var thirdClassification: QueryTradeMarkApplicationsByIntentionResponseBody.Data.TmProduces.ThirdClassification?

            public var tmIcon: String?

            public var tmName: String?

            public var tmNumber: String?

            public var totalPrice: Double?

            public var type: Int32?

            public var updateTime: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.firstClassification?.validate()
                try self.thirdClassification?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bizId != nil {
                    map["BizId"] = self.bizId!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.firstClassification != nil {
                    map["FirstClassification"] = self.firstClassification?.toMap()
                }
                if self.loaUrl != nil {
                    map["LoaUrl"] = self.loaUrl!
                }
                if self.materialId != nil {
                    map["MaterialId"] = self.materialId!
                }
                if self.materialName != nil {
                    map["MaterialName"] = self.materialName!
                }
                if self.note != nil {
                    map["Note"] = self.note!
                }
                if self.orderPrice != nil {
                    map["OrderPrice"] = self.orderPrice!
                }
                if self.principalDescription != nil {
                    map["PrincipalDescription"] = self.principalDescription!
                }
                if self.principalValue != nil {
                    map["PrincipalValue"] = self.principalValue!
                }
                if self.servicePrice != nil {
                    map["ServicePrice"] = self.servicePrice!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.supplementId != nil {
                    map["SupplementId"] = self.supplementId!
                }
                if self.supplementStatus != nil {
                    map["SupplementStatus"] = self.supplementStatus!
                }
                if self.thirdClassification != nil {
                    map["ThirdClassification"] = self.thirdClassification?.toMap()
                }
                if self.tmIcon != nil {
                    map["TmIcon"] = self.tmIcon!
                }
                if self.tmName != nil {
                    map["TmName"] = self.tmName!
                }
                if self.tmNumber != nil {
                    map["TmNumber"] = self.tmNumber!
                }
                if self.totalPrice != nil {
                    map["TotalPrice"] = self.totalPrice!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BizId") && dict["BizId"] != nil {
                    self.bizId = dict["BizId"] as! String
                }
                if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("FirstClassification") && dict["FirstClassification"] != nil {
                    var model = QueryTradeMarkApplicationsByIntentionResponseBody.Data.TmProduces.FirstClassification()
                    model.fromMap(dict["FirstClassification"] as! [String: Any])
                    self.firstClassification = model
                }
                if dict.keys.contains("LoaUrl") && dict["LoaUrl"] != nil {
                    self.loaUrl = dict["LoaUrl"] as! String
                }
                if dict.keys.contains("MaterialId") && dict["MaterialId"] != nil {
                    self.materialId = dict["MaterialId"] as! String
                }
                if dict.keys.contains("MaterialName") && dict["MaterialName"] != nil {
                    self.materialName = dict["MaterialName"] as! String
                }
                if dict.keys.contains("Note") && dict["Note"] != nil {
                    self.note = dict["Note"] as! String
                }
                if dict.keys.contains("OrderPrice") && dict["OrderPrice"] != nil {
                    self.orderPrice = dict["OrderPrice"] as! Double
                }
                if dict.keys.contains("PrincipalDescription") && dict["PrincipalDescription"] != nil {
                    self.principalDescription = dict["PrincipalDescription"] as! String
                }
                if dict.keys.contains("PrincipalValue") && dict["PrincipalValue"] != nil {
                    self.principalValue = dict["PrincipalValue"] as! Int32
                }
                if dict.keys.contains("ServicePrice") && dict["ServicePrice"] != nil {
                    self.servicePrice = dict["ServicePrice"] as! Double
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! Int32
                }
                if dict.keys.contains("SupplementId") && dict["SupplementId"] != nil {
                    self.supplementId = dict["SupplementId"] as! Int64
                }
                if dict.keys.contains("SupplementStatus") && dict["SupplementStatus"] != nil {
                    self.supplementStatus = dict["SupplementStatus"] as! Int32
                }
                if dict.keys.contains("ThirdClassification") && dict["ThirdClassification"] != nil {
                    var model = QueryTradeMarkApplicationsByIntentionResponseBody.Data.TmProduces.ThirdClassification()
                    model.fromMap(dict["ThirdClassification"] as! [String: Any])
                    self.thirdClassification = model
                }
                if dict.keys.contains("TmIcon") && dict["TmIcon"] != nil {
                    self.tmIcon = dict["TmIcon"] as! String
                }
                if dict.keys.contains("TmName") && dict["TmName"] != nil {
                    self.tmName = dict["TmName"] as! String
                }
                if dict.keys.contains("TmNumber") && dict["TmNumber"] != nil {
                    self.tmNumber = dict["TmNumber"] as! String
                }
                if dict.keys.contains("TotalPrice") && dict["TotalPrice"] != nil {
                    self.totalPrice = dict["TotalPrice"] as! Double
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! Int32
                }
                if dict.keys.contains("UpdateTime") && dict["UpdateTime"] != nil {
                    self.updateTime = dict["UpdateTime"] as! Int64
                }
            }
        }
        public var tmProduces: [QueryTradeMarkApplicationsByIntentionResponseBody.Data.TmProduces]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tmProduces != nil {
                var tmp : [Any] = []
                for k in self.tmProduces! {
                    tmp.append(k.toMap())
                }
                map["TmProduces"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TmProduces") && dict["TmProduces"] != nil {
                var tmp : [QueryTradeMarkApplicationsByIntentionResponseBody.Data.TmProduces] = []
                for v in dict["TmProduces"] as! [Any] {
                    var model = QueryTradeMarkApplicationsByIntentionResponseBody.Data.TmProduces()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tmProduces = tmp
            }
        }
    }
    public var currentPageNum: Int32?

    public var data: QueryTradeMarkApplicationsByIntentionResponseBody.Data?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalItemNum: Int32?

    public var totalPageNum: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPageNum != nil {
            map["CurrentPageNum"] = self.currentPageNum!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalItemNum != nil {
            map["TotalItemNum"] = self.totalItemNum!
        }
        if self.totalPageNum != nil {
            map["TotalPageNum"] = self.totalPageNum!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPageNum") && dict["CurrentPageNum"] != nil {
            self.currentPageNum = dict["CurrentPageNum"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = QueryTradeMarkApplicationsByIntentionResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalItemNum") && dict["TotalItemNum"] != nil {
            self.totalItemNum = dict["TotalItemNum"] as! Int32
        }
        if dict.keys.contains("TotalPageNum") && dict["TotalPageNum"] != nil {
            self.totalPageNum = dict["TotalPageNum"] as! Int32
        }
    }
}

public class QueryTradeMarkApplicationsByIntentionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryTradeMarkApplicationsByIntentionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryTradeMarkApplicationsByIntentionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryTradeProduceDetailRequest : Tea.TeaModel {
    public var bizId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
    }
}

public class QueryTradeProduceDetailResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var allowCancel: Bool?

        public var bizId: String?

        public var buyerStatus: Int32?

        public var classification: String?

        public var confiscateAmount: Double?

        public var createTime: Int64?

        public var exclusiveDateLimit: String?

        public var extend: [String: Any]?

        public var finalAmount: Double?

        public var icon: String?

        public var operateNote: String?

        public var paidAmount: Double?

        public var preAmount: Double?

        public var preOrderId: String?

        public var refundAmount: Double?

        public var registerNumber: String?

        public var share: String?

        public var source: Int32?

        public var thirdCode: String?

        public var tmName: String?

        public var updateTime: Int64?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.allowCancel != nil {
                map["AllowCancel"] = self.allowCancel!
            }
            if self.bizId != nil {
                map["BizId"] = self.bizId!
            }
            if self.buyerStatus != nil {
                map["BuyerStatus"] = self.buyerStatus!
            }
            if self.classification != nil {
                map["Classification"] = self.classification!
            }
            if self.confiscateAmount != nil {
                map["ConfiscateAmount"] = self.confiscateAmount!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.exclusiveDateLimit != nil {
                map["ExclusiveDateLimit"] = self.exclusiveDateLimit!
            }
            if self.extend != nil {
                map["Extend"] = self.extend!
            }
            if self.finalAmount != nil {
                map["FinalAmount"] = self.finalAmount!
            }
            if self.icon != nil {
                map["Icon"] = self.icon!
            }
            if self.operateNote != nil {
                map["OperateNote"] = self.operateNote!
            }
            if self.paidAmount != nil {
                map["PaidAmount"] = self.paidAmount!
            }
            if self.preAmount != nil {
                map["PreAmount"] = self.preAmount!
            }
            if self.preOrderId != nil {
                map["PreOrderId"] = self.preOrderId!
            }
            if self.refundAmount != nil {
                map["RefundAmount"] = self.refundAmount!
            }
            if self.registerNumber != nil {
                map["RegisterNumber"] = self.registerNumber!
            }
            if self.share != nil {
                map["Share"] = self.share!
            }
            if self.source != nil {
                map["Source"] = self.source!
            }
            if self.thirdCode != nil {
                map["ThirdCode"] = self.thirdCode!
            }
            if self.tmName != nil {
                map["TmName"] = self.tmName!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AllowCancel") && dict["AllowCancel"] != nil {
                self.allowCancel = dict["AllowCancel"] as! Bool
            }
            if dict.keys.contains("BizId") && dict["BizId"] != nil {
                self.bizId = dict["BizId"] as! String
            }
            if dict.keys.contains("BuyerStatus") && dict["BuyerStatus"] != nil {
                self.buyerStatus = dict["BuyerStatus"] as! Int32
            }
            if dict.keys.contains("Classification") && dict["Classification"] != nil {
                self.classification = dict["Classification"] as! String
            }
            if dict.keys.contains("ConfiscateAmount") && dict["ConfiscateAmount"] != nil {
                self.confiscateAmount = dict["ConfiscateAmount"] as! Double
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("ExclusiveDateLimit") && dict["ExclusiveDateLimit"] != nil {
                self.exclusiveDateLimit = dict["ExclusiveDateLimit"] as! String
            }
            if dict.keys.contains("Extend") && dict["Extend"] != nil {
                self.extend = dict["Extend"] as! [String: Any]
            }
            if dict.keys.contains("FinalAmount") && dict["FinalAmount"] != nil {
                self.finalAmount = dict["FinalAmount"] as! Double
            }
            if dict.keys.contains("Icon") && dict["Icon"] != nil {
                self.icon = dict["Icon"] as! String
            }
            if dict.keys.contains("OperateNote") && dict["OperateNote"] != nil {
                self.operateNote = dict["OperateNote"] as! String
            }
            if dict.keys.contains("PaidAmount") && dict["PaidAmount"] != nil {
                self.paidAmount = dict["PaidAmount"] as! Double
            }
            if dict.keys.contains("PreAmount") && dict["PreAmount"] != nil {
                self.preAmount = dict["PreAmount"] as! Double
            }
            if dict.keys.contains("PreOrderId") && dict["PreOrderId"] != nil {
                self.preOrderId = dict["PreOrderId"] as! String
            }
            if dict.keys.contains("RefundAmount") && dict["RefundAmount"] != nil {
                self.refundAmount = dict["RefundAmount"] as! Double
            }
            if dict.keys.contains("RegisterNumber") && dict["RegisterNumber"] != nil {
                self.registerNumber = dict["RegisterNumber"] as! String
            }
            if dict.keys.contains("Share") && dict["Share"] != nil {
                self.share = dict["Share"] as! String
            }
            if dict.keys.contains("Source") && dict["Source"] != nil {
                self.source = dict["Source"] as! Int32
            }
            if dict.keys.contains("ThirdCode") && dict["ThirdCode"] != nil {
                self.thirdCode = dict["ThirdCode"] as! String
            }
            if dict.keys.contains("TmName") && dict["TmName"] != nil {
                self.tmName = dict["TmName"] as! String
            }
            if dict.keys.contains("UpdateTime") && dict["UpdateTime"] != nil {
                self.updateTime = dict["UpdateTime"] as! Int64
            }
            if dict.keys.contains("UserId") && dict["UserId"] != nil {
                self.userId = dict["UserId"] as! String
            }
        }
    }
    public var data: QueryTradeProduceDetailResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = QueryTradeProduceDetailResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class QueryTradeProduceDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryTradeProduceDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryTradeProduceDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryTradeProduceListRequest : Tea.TeaModel {
    public var bizId: String?

    public var buyerStatus: Int32?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var preOrderId: String?

    public var registerNumber: String?

    public var sortFiled: String?

    public var sortOrder: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.buyerStatus != nil {
            map["BuyerStatus"] = self.buyerStatus!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.preOrderId != nil {
            map["PreOrderId"] = self.preOrderId!
        }
        if self.registerNumber != nil {
            map["RegisterNumber"] = self.registerNumber!
        }
        if self.sortFiled != nil {
            map["SortFiled"] = self.sortFiled!
        }
        if self.sortOrder != nil {
            map["SortOrder"] = self.sortOrder!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("BuyerStatus") && dict["BuyerStatus"] != nil {
            self.buyerStatus = dict["BuyerStatus"] as! Int32
        }
        if dict.keys.contains("PageNum") && dict["PageNum"] != nil {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("PreOrderId") && dict["PreOrderId"] != nil {
            self.preOrderId = dict["PreOrderId"] as! String
        }
        if dict.keys.contains("RegisterNumber") && dict["RegisterNumber"] != nil {
            self.registerNumber = dict["RegisterNumber"] as! String
        }
        if dict.keys.contains("SortFiled") && dict["SortFiled"] != nil {
            self.sortFiled = dict["SortFiled"] as! String
        }
        if dict.keys.contains("SortOrder") && dict["SortOrder"] != nil {
            self.sortOrder = dict["SortOrder"] as! String
        }
    }
}

public class QueryTradeProduceListResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class TradeProduces : Tea.TeaModel {
            public var allowCancel: Bool?

            public var bizId: String?

            public var buyerStatus: Int32?

            public var classification: String?

            public var createTime: Int64?

            public var failReason: Int32?

            public var finalAmount: Double?

            public var icon: String?

            public var operateNote: String?

            public var preAmount: Double?

            public var preOrderId: String?

            public var registerNumber: String?

            public var source: Int32?

            public var updateTime: Int64?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.allowCancel != nil {
                    map["AllowCancel"] = self.allowCancel!
                }
                if self.bizId != nil {
                    map["BizId"] = self.bizId!
                }
                if self.buyerStatus != nil {
                    map["BuyerStatus"] = self.buyerStatus!
                }
                if self.classification != nil {
                    map["Classification"] = self.classification!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.failReason != nil {
                    map["FailReason"] = self.failReason!
                }
                if self.finalAmount != nil {
                    map["FinalAmount"] = self.finalAmount!
                }
                if self.icon != nil {
                    map["Icon"] = self.icon!
                }
                if self.operateNote != nil {
                    map["OperateNote"] = self.operateNote!
                }
                if self.preAmount != nil {
                    map["PreAmount"] = self.preAmount!
                }
                if self.preOrderId != nil {
                    map["PreOrderId"] = self.preOrderId!
                }
                if self.registerNumber != nil {
                    map["RegisterNumber"] = self.registerNumber!
                }
                if self.source != nil {
                    map["Source"] = self.source!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AllowCancel") && dict["AllowCancel"] != nil {
                    self.allowCancel = dict["AllowCancel"] as! Bool
                }
                if dict.keys.contains("BizId") && dict["BizId"] != nil {
                    self.bizId = dict["BizId"] as! String
                }
                if dict.keys.contains("BuyerStatus") && dict["BuyerStatus"] != nil {
                    self.buyerStatus = dict["BuyerStatus"] as! Int32
                }
                if dict.keys.contains("Classification") && dict["Classification"] != nil {
                    self.classification = dict["Classification"] as! String
                }
                if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("FailReason") && dict["FailReason"] != nil {
                    self.failReason = dict["FailReason"] as! Int32
                }
                if dict.keys.contains("FinalAmount") && dict["FinalAmount"] != nil {
                    self.finalAmount = dict["FinalAmount"] as! Double
                }
                if dict.keys.contains("Icon") && dict["Icon"] != nil {
                    self.icon = dict["Icon"] as! String
                }
                if dict.keys.contains("OperateNote") && dict["OperateNote"] != nil {
                    self.operateNote = dict["OperateNote"] as! String
                }
                if dict.keys.contains("PreAmount") && dict["PreAmount"] != nil {
                    self.preAmount = dict["PreAmount"] as! Double
                }
                if dict.keys.contains("PreOrderId") && dict["PreOrderId"] != nil {
                    self.preOrderId = dict["PreOrderId"] as! String
                }
                if dict.keys.contains("RegisterNumber") && dict["RegisterNumber"] != nil {
                    self.registerNumber = dict["RegisterNumber"] as! String
                }
                if dict.keys.contains("Source") && dict["Source"] != nil {
                    self.source = dict["Source"] as! Int32
                }
                if dict.keys.contains("UpdateTime") && dict["UpdateTime"] != nil {
                    self.updateTime = dict["UpdateTime"] as! Int64
                }
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! String
                }
            }
        }
        public var tradeProduces: [QueryTradeProduceListResponseBody.Data.TradeProduces]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tradeProduces != nil {
                var tmp : [Any] = []
                for k in self.tradeProduces! {
                    tmp.append(k.toMap())
                }
                map["TradeProduces"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TradeProduces") && dict["TradeProduces"] != nil {
                var tmp : [QueryTradeProduceListResponseBody.Data.TradeProduces] = []
                for v in dict["TradeProduces"] as! [Any] {
                    var model = QueryTradeProduceListResponseBody.Data.TradeProduces()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tradeProduces = tmp
            }
        }
    }
    public var currentPageNum: Int32?

    public var data: QueryTradeProduceListResponseBody.Data?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalItemNum: Int32?

    public var totalPageNum: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPageNum != nil {
            map["CurrentPageNum"] = self.currentPageNum!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalItemNum != nil {
            map["TotalItemNum"] = self.totalItemNum!
        }
        if self.totalPageNum != nil {
            map["TotalPageNum"] = self.totalPageNum!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPageNum") && dict["CurrentPageNum"] != nil {
            self.currentPageNum = dict["CurrentPageNum"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = QueryTradeProduceListResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalItemNum") && dict["TotalItemNum"] != nil {
            self.totalItemNum = dict["TotalItemNum"] as! Int32
        }
        if dict.keys.contains("TotalPageNum") && dict["TotalPageNum"] != nil {
            self.totalPageNum = dict["TotalPageNum"] as! Int32
        }
    }
}

public class QueryTradeProduceListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryTradeProduceListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryTradeProduceListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryTrademarkDetailByApplyNumberRequest : Tea.TeaModel {
    public var applyNumber: String?

    public var env: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applyNumber != nil {
            map["ApplyNumber"] = self.applyNumber!
        }
        if self.env != nil {
            map["Env"] = self.env!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApplyNumber") && dict["ApplyNumber"] != nil {
            self.applyNumber = dict["ApplyNumber"] as! String
        }
        if dict.keys.contains("Env") && dict["Env"] != nil {
            self.env = dict["Env"] as! String
        }
    }
}

public class QueryTrademarkDetailByApplyNumberResponseBody : Tea.TeaModel {
    public class Moudle : Tea.TeaModel {
        public class LeafCodes : Tea.TeaModel {
            public class LeafCode : Tea.TeaModel {
                public var classificationCode: String?

                public var classificationName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.classificationCode != nil {
                        map["ClassificationCode"] = self.classificationCode!
                    }
                    if self.classificationName != nil {
                        map["ClassificationName"] = self.classificationName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ClassificationCode") && dict["ClassificationCode"] != nil {
                        self.classificationCode = dict["ClassificationCode"] as! String
                    }
                    if dict.keys.contains("ClassificationName") && dict["ClassificationName"] != nil {
                        self.classificationName = dict["ClassificationName"] as! String
                    }
                }
            }
            public var leafCode: [QueryTrademarkDetailByApplyNumberResponseBody.Moudle.LeafCodes.LeafCode]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.leafCode != nil {
                    var tmp : [Any] = []
                    for k in self.leafCode! {
                        tmp.append(k.toMap())
                    }
                    map["leafCode"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("leafCode") && dict["leafCode"] != nil {
                    var tmp : [QueryTrademarkDetailByApplyNumberResponseBody.Moudle.LeafCodes.LeafCode] = []
                    for v in dict["leafCode"] as! [Any] {
                        var model = QueryTrademarkDetailByApplyNumberResponseBody.Moudle.LeafCodes.LeafCode()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.leafCode = tmp
                }
            }
        }
        public class MaterialInfo : Tea.TeaModel {
            public var address: String?

            public var businessLicenceUrl: String?

            public var cardNumber: String?

            public var cnInfoUrl: String?

            public var contactAddress: String?

            public var contactEmail: String?

            public var contactName: String?

            public var contactPhoneNumber: String?

            public var contactZipCode: String?

            public var country: String?

            public var EAddress: String?

            public var EName: String?

            public var idCardNumber: String?

            public var idCardUrl: String?

            public var loaKey: String?

            public var loaUrl: String?

            public var name: String?

            public var passportUrl: String?

            public var personalType: Int32?

            public var postCode: String?

            public var province: String?

            public var reasonFileOssKey: String?

            public var region: Int32?

            public var reviewFileMap: [String: Any]?

            public var type: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.address != nil {
                    map["Address"] = self.address!
                }
                if self.businessLicenceUrl != nil {
                    map["BusinessLicenceUrl"] = self.businessLicenceUrl!
                }
                if self.cardNumber != nil {
                    map["CardNumber"] = self.cardNumber!
                }
                if self.cnInfoUrl != nil {
                    map["CnInfoUrl"] = self.cnInfoUrl!
                }
                if self.contactAddress != nil {
                    map["ContactAddress"] = self.contactAddress!
                }
                if self.contactEmail != nil {
                    map["ContactEmail"] = self.contactEmail!
                }
                if self.contactName != nil {
                    map["ContactName"] = self.contactName!
                }
                if self.contactPhoneNumber != nil {
                    map["ContactPhoneNumber"] = self.contactPhoneNumber!
                }
                if self.contactZipCode != nil {
                    map["ContactZipCode"] = self.contactZipCode!
                }
                if self.country != nil {
                    map["Country"] = self.country!
                }
                if self.EAddress != nil {
                    map["EAddress"] = self.EAddress!
                }
                if self.EName != nil {
                    map["EName"] = self.EName!
                }
                if self.idCardNumber != nil {
                    map["IdCardNumber"] = self.idCardNumber!
                }
                if self.idCardUrl != nil {
                    map["IdCardUrl"] = self.idCardUrl!
                }
                if self.loaKey != nil {
                    map["LoaKey"] = self.loaKey!
                }
                if self.loaUrl != nil {
                    map["LoaUrl"] = self.loaUrl!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.passportUrl != nil {
                    map["PassportUrl"] = self.passportUrl!
                }
                if self.personalType != nil {
                    map["PersonalType"] = self.personalType!
                }
                if self.postCode != nil {
                    map["PostCode"] = self.postCode!
                }
                if self.province != nil {
                    map["Province"] = self.province!
                }
                if self.reasonFileOssKey != nil {
                    map["ReasonFileOssKey"] = self.reasonFileOssKey!
                }
                if self.region != nil {
                    map["Region"] = self.region!
                }
                if self.reviewFileMap != nil {
                    map["ReviewFileMap"] = self.reviewFileMap!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Address") && dict["Address"] != nil {
                    self.address = dict["Address"] as! String
                }
                if dict.keys.contains("BusinessLicenceUrl") && dict["BusinessLicenceUrl"] != nil {
                    self.businessLicenceUrl = dict["BusinessLicenceUrl"] as! String
                }
                if dict.keys.contains("CardNumber") && dict["CardNumber"] != nil {
                    self.cardNumber = dict["CardNumber"] as! String
                }
                if dict.keys.contains("CnInfoUrl") && dict["CnInfoUrl"] != nil {
                    self.cnInfoUrl = dict["CnInfoUrl"] as! String
                }
                if dict.keys.contains("ContactAddress") && dict["ContactAddress"] != nil {
                    self.contactAddress = dict["ContactAddress"] as! String
                }
                if dict.keys.contains("ContactEmail") && dict["ContactEmail"] != nil {
                    self.contactEmail = dict["ContactEmail"] as! String
                }
                if dict.keys.contains("ContactName") && dict["ContactName"] != nil {
                    self.contactName = dict["ContactName"] as! String
                }
                if dict.keys.contains("ContactPhoneNumber") && dict["ContactPhoneNumber"] != nil {
                    self.contactPhoneNumber = dict["ContactPhoneNumber"] as! String
                }
                if dict.keys.contains("ContactZipCode") && dict["ContactZipCode"] != nil {
                    self.contactZipCode = dict["ContactZipCode"] as! String
                }
                if dict.keys.contains("Country") && dict["Country"] != nil {
                    self.country = dict["Country"] as! String
                }
                if dict.keys.contains("EAddress") && dict["EAddress"] != nil {
                    self.EAddress = dict["EAddress"] as! String
                }
                if dict.keys.contains("EName") && dict["EName"] != nil {
                    self.EName = dict["EName"] as! String
                }
                if dict.keys.contains("IdCardNumber") && dict["IdCardNumber"] != nil {
                    self.idCardNumber = dict["IdCardNumber"] as! String
                }
                if dict.keys.contains("IdCardUrl") && dict["IdCardUrl"] != nil {
                    self.idCardUrl = dict["IdCardUrl"] as! String
                }
                if dict.keys.contains("LoaKey") && dict["LoaKey"] != nil {
                    self.loaKey = dict["LoaKey"] as! String
                }
                if dict.keys.contains("LoaUrl") && dict["LoaUrl"] != nil {
                    self.loaUrl = dict["LoaUrl"] as! String
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("PassportUrl") && dict["PassportUrl"] != nil {
                    self.passportUrl = dict["PassportUrl"] as! String
                }
                if dict.keys.contains("PersonalType") && dict["PersonalType"] != nil {
                    self.personalType = dict["PersonalType"] as! Int32
                }
                if dict.keys.contains("PostCode") && dict["PostCode"] != nil {
                    self.postCode = dict["PostCode"] as! String
                }
                if dict.keys.contains("Province") && dict["Province"] != nil {
                    self.province = dict["Province"] as! String
                }
                if dict.keys.contains("ReasonFileOssKey") && dict["ReasonFileOssKey"] != nil {
                    self.reasonFileOssKey = dict["ReasonFileOssKey"] as! String
                }
                if dict.keys.contains("Region") && dict["Region"] != nil {
                    self.region = dict["Region"] as! Int32
                }
                if dict.keys.contains("ReviewFileMap") && dict["ReviewFileMap"] != nil {
                    self.reviewFileMap = dict["ReviewFileMap"] as! [String: Any]
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! Int32
                }
            }
        }
        public class RootCode : Tea.TeaModel {
            public var classificationCode: String?

            public var classificationName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.classificationCode != nil {
                    map["ClassificationCode"] = self.classificationCode!
                }
                if self.classificationName != nil {
                    map["ClassificationName"] = self.classificationName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ClassificationCode") && dict["ClassificationCode"] != nil {
                    self.classificationCode = dict["ClassificationCode"] as! String
                }
                if dict.keys.contains("ClassificationName") && dict["ClassificationName"] != nil {
                    self.classificationName = dict["ClassificationName"] as! String
                }
            }
        }
        public var bitFlag: Int32?

        public var bizId: String?

        public var bizType: String?

        public var extendInfo: [String: Any]?

        public var grayIconUrl: String?

        public var icon: String?

        public var leafCodes: QueryTrademarkDetailByApplyNumberResponseBody.Moudle.LeafCodes?

        public var materialInfo: QueryTrademarkDetailByApplyNumberResponseBody.Moudle.MaterialInfo?

        public var orderId: String?

        public var partnerCode: String?

        public var principalKey: String?

        public var principalName: String?

        public var produceType: String?

        public var rootCode: QueryTrademarkDetailByApplyNumberResponseBody.Moudle.RootCode?

        public var status: String?

        public var statusStr: String?

        public var submitAuditTimeStr: String?

        public var submitAuditTimeValue: Int64?

        public var submitStatus: String?

        public var submitTimeStr: String?

        public var submitTimeValue: Int64?

        public var submitTimes: Int32?

        public var trademarkName: String?

        public var trademarkNameType: Int32?

        public var trademarkNumber: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.leafCodes?.validate()
            try self.materialInfo?.validate()
            try self.rootCode?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bitFlag != nil {
                map["BitFlag"] = self.bitFlag!
            }
            if self.bizId != nil {
                map["BizId"] = self.bizId!
            }
            if self.bizType != nil {
                map["BizType"] = self.bizType!
            }
            if self.extendInfo != nil {
                map["ExtendInfo"] = self.extendInfo!
            }
            if self.grayIconUrl != nil {
                map["GrayIconUrl"] = self.grayIconUrl!
            }
            if self.icon != nil {
                map["Icon"] = self.icon!
            }
            if self.leafCodes != nil {
                map["LeafCodes"] = self.leafCodes?.toMap()
            }
            if self.materialInfo != nil {
                map["MaterialInfo"] = self.materialInfo?.toMap()
            }
            if self.orderId != nil {
                map["OrderId"] = self.orderId!
            }
            if self.partnerCode != nil {
                map["PartnerCode"] = self.partnerCode!
            }
            if self.principalKey != nil {
                map["PrincipalKey"] = self.principalKey!
            }
            if self.principalName != nil {
                map["PrincipalName"] = self.principalName!
            }
            if self.produceType != nil {
                map["ProduceType"] = self.produceType!
            }
            if self.rootCode != nil {
                map["RootCode"] = self.rootCode?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.statusStr != nil {
                map["StatusStr"] = self.statusStr!
            }
            if self.submitAuditTimeStr != nil {
                map["SubmitAuditTimeStr"] = self.submitAuditTimeStr!
            }
            if self.submitAuditTimeValue != nil {
                map["SubmitAuditTimeValue"] = self.submitAuditTimeValue!
            }
            if self.submitStatus != nil {
                map["SubmitStatus"] = self.submitStatus!
            }
            if self.submitTimeStr != nil {
                map["SubmitTimeStr"] = self.submitTimeStr!
            }
            if self.submitTimeValue != nil {
                map["SubmitTimeValue"] = self.submitTimeValue!
            }
            if self.submitTimes != nil {
                map["SubmitTimes"] = self.submitTimes!
            }
            if self.trademarkName != nil {
                map["TrademarkName"] = self.trademarkName!
            }
            if self.trademarkNameType != nil {
                map["TrademarkNameType"] = self.trademarkNameType!
            }
            if self.trademarkNumber != nil {
                map["TrademarkNumber"] = self.trademarkNumber!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BitFlag") && dict["BitFlag"] != nil {
                self.bitFlag = dict["BitFlag"] as! Int32
            }
            if dict.keys.contains("BizId") && dict["BizId"] != nil {
                self.bizId = dict["BizId"] as! String
            }
            if dict.keys.contains("BizType") && dict["BizType"] != nil {
                self.bizType = dict["BizType"] as! String
            }
            if dict.keys.contains("ExtendInfo") && dict["ExtendInfo"] != nil {
                self.extendInfo = dict["ExtendInfo"] as! [String: Any]
            }
            if dict.keys.contains("GrayIconUrl") && dict["GrayIconUrl"] != nil {
                self.grayIconUrl = dict["GrayIconUrl"] as! String
            }
            if dict.keys.contains("Icon") && dict["Icon"] != nil {
                self.icon = dict["Icon"] as! String
            }
            if dict.keys.contains("LeafCodes") && dict["LeafCodes"] != nil {
                var model = QueryTrademarkDetailByApplyNumberResponseBody.Moudle.LeafCodes()
                model.fromMap(dict["LeafCodes"] as! [String: Any])
                self.leafCodes = model
            }
            if dict.keys.contains("MaterialInfo") && dict["MaterialInfo"] != nil {
                var model = QueryTrademarkDetailByApplyNumberResponseBody.Moudle.MaterialInfo()
                model.fromMap(dict["MaterialInfo"] as! [String: Any])
                self.materialInfo = model
            }
            if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
                self.orderId = dict["OrderId"] as! String
            }
            if dict.keys.contains("PartnerCode") && dict["PartnerCode"] != nil {
                self.partnerCode = dict["PartnerCode"] as! String
            }
            if dict.keys.contains("PrincipalKey") && dict["PrincipalKey"] != nil {
                self.principalKey = dict["PrincipalKey"] as! String
            }
            if dict.keys.contains("PrincipalName") && dict["PrincipalName"] != nil {
                self.principalName = dict["PrincipalName"] as! String
            }
            if dict.keys.contains("ProduceType") && dict["ProduceType"] != nil {
                self.produceType = dict["ProduceType"] as! String
            }
            if dict.keys.contains("RootCode") && dict["RootCode"] != nil {
                var model = QueryTrademarkDetailByApplyNumberResponseBody.Moudle.RootCode()
                model.fromMap(dict["RootCode"] as! [String: Any])
                self.rootCode = model
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("StatusStr") && dict["StatusStr"] != nil {
                self.statusStr = dict["StatusStr"] as! String
            }
            if dict.keys.contains("SubmitAuditTimeStr") && dict["SubmitAuditTimeStr"] != nil {
                self.submitAuditTimeStr = dict["SubmitAuditTimeStr"] as! String
            }
            if dict.keys.contains("SubmitAuditTimeValue") && dict["SubmitAuditTimeValue"] != nil {
                self.submitAuditTimeValue = dict["SubmitAuditTimeValue"] as! Int64
            }
            if dict.keys.contains("SubmitStatus") && dict["SubmitStatus"] != nil {
                self.submitStatus = dict["SubmitStatus"] as! String
            }
            if dict.keys.contains("SubmitTimeStr") && dict["SubmitTimeStr"] != nil {
                self.submitTimeStr = dict["SubmitTimeStr"] as! String
            }
            if dict.keys.contains("SubmitTimeValue") && dict["SubmitTimeValue"] != nil {
                self.submitTimeValue = dict["SubmitTimeValue"] as! Int64
            }
            if dict.keys.contains("SubmitTimes") && dict["SubmitTimes"] != nil {
                self.submitTimes = dict["SubmitTimes"] as! Int32
            }
            if dict.keys.contains("TrademarkName") && dict["TrademarkName"] != nil {
                self.trademarkName = dict["TrademarkName"] as! String
            }
            if dict.keys.contains("TrademarkNameType") && dict["TrademarkNameType"] != nil {
                self.trademarkNameType = dict["TrademarkNameType"] as! Int32
            }
            if dict.keys.contains("TrademarkNumber") && dict["TrademarkNumber"] != nil {
                self.trademarkNumber = dict["TrademarkNumber"] as! String
            }
        }
    }
    public var moudle: QueryTrademarkDetailByApplyNumberResponseBody.Moudle?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.moudle?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.moudle != nil {
            map["Moudle"] = self.moudle?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Moudle") && dict["Moudle"] != nil {
            var model = QueryTrademarkDetailByApplyNumberResponseBody.Moudle()
            model.fromMap(dict["Moudle"] as! [String: Any])
            self.moudle = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class QueryTrademarkDetailByApplyNumberResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryTrademarkDetailByApplyNumberResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryTrademarkDetailByApplyNumberResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryTrademarkDetailByApplyNumberEspRequest : Tea.TeaModel {
    public var applyNumber: String?

    public var bizType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applyNumber != nil {
            map["ApplyNumber"] = self.applyNumber!
        }
        if self.bizType != nil {
            map["BizType"] = self.bizType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApplyNumber") && dict["ApplyNumber"] != nil {
            self.applyNumber = dict["ApplyNumber"] as! String
        }
        if dict.keys.contains("BizType") && dict["BizType"] != nil {
            self.bizType = dict["BizType"] as! String
        }
    }
}

public class QueryTrademarkDetailByApplyNumberEspResponseBody : Tea.TeaModel {
    public class Moudle : Tea.TeaModel {
        public class LeafCodes : Tea.TeaModel {
            public class LeafCode : Tea.TeaModel {
                public var classificationCode: String?

                public var classificationName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.classificationCode != nil {
                        map["ClassificationCode"] = self.classificationCode!
                    }
                    if self.classificationName != nil {
                        map["ClassificationName"] = self.classificationName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ClassificationCode") && dict["ClassificationCode"] != nil {
                        self.classificationCode = dict["ClassificationCode"] as! String
                    }
                    if dict.keys.contains("ClassificationName") && dict["ClassificationName"] != nil {
                        self.classificationName = dict["ClassificationName"] as! String
                    }
                }
            }
            public var leafCode: [QueryTrademarkDetailByApplyNumberEspResponseBody.Moudle.LeafCodes.LeafCode]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.leafCode != nil {
                    var tmp : [Any] = []
                    for k in self.leafCode! {
                        tmp.append(k.toMap())
                    }
                    map["leafCode"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("leafCode") && dict["leafCode"] != nil {
                    var tmp : [QueryTrademarkDetailByApplyNumberEspResponseBody.Moudle.LeafCodes.LeafCode] = []
                    for v in dict["leafCode"] as! [Any] {
                        var model = QueryTrademarkDetailByApplyNumberEspResponseBody.Moudle.LeafCodes.LeafCode()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.leafCode = tmp
                }
            }
        }
        public class MaterialInfo : Tea.TeaModel {
            public var address: String?

            public var businessLicenceUrl: String?

            public var cardNumber: String?

            public var cnInfoUrl: String?

            public var contactAddress: String?

            public var contactEmail: String?

            public var contactName: String?

            public var contactPhoneNumber: String?

            public var contactZipCode: String?

            public var country: String?

            public var EAddress: String?

            public var EName: String?

            public var idCardNumber: String?

            public var idCardUrl: String?

            public var loaKey: String?

            public var loaUrl: String?

            public var name: String?

            public var passportUrl: String?

            public var personalType: Int32?

            public var postCode: String?

            public var province: String?

            public var reasonFileOssKey: String?

            public var region: Int32?

            public var reviewFileMap: [String: Any]?

            public var type: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.address != nil {
                    map["Address"] = self.address!
                }
                if self.businessLicenceUrl != nil {
                    map["BusinessLicenceUrl"] = self.businessLicenceUrl!
                }
                if self.cardNumber != nil {
                    map["CardNumber"] = self.cardNumber!
                }
                if self.cnInfoUrl != nil {
                    map["CnInfoUrl"] = self.cnInfoUrl!
                }
                if self.contactAddress != nil {
                    map["ContactAddress"] = self.contactAddress!
                }
                if self.contactEmail != nil {
                    map["ContactEmail"] = self.contactEmail!
                }
                if self.contactName != nil {
                    map["ContactName"] = self.contactName!
                }
                if self.contactPhoneNumber != nil {
                    map["ContactPhoneNumber"] = self.contactPhoneNumber!
                }
                if self.contactZipCode != nil {
                    map["ContactZipCode"] = self.contactZipCode!
                }
                if self.country != nil {
                    map["Country"] = self.country!
                }
                if self.EAddress != nil {
                    map["EAddress"] = self.EAddress!
                }
                if self.EName != nil {
                    map["EName"] = self.EName!
                }
                if self.idCardNumber != nil {
                    map["IdCardNumber"] = self.idCardNumber!
                }
                if self.idCardUrl != nil {
                    map["IdCardUrl"] = self.idCardUrl!
                }
                if self.loaKey != nil {
                    map["LoaKey"] = self.loaKey!
                }
                if self.loaUrl != nil {
                    map["LoaUrl"] = self.loaUrl!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.passportUrl != nil {
                    map["PassportUrl"] = self.passportUrl!
                }
                if self.personalType != nil {
                    map["PersonalType"] = self.personalType!
                }
                if self.postCode != nil {
                    map["PostCode"] = self.postCode!
                }
                if self.province != nil {
                    map["Province"] = self.province!
                }
                if self.reasonFileOssKey != nil {
                    map["ReasonFileOssKey"] = self.reasonFileOssKey!
                }
                if self.region != nil {
                    map["Region"] = self.region!
                }
                if self.reviewFileMap != nil {
                    map["ReviewFileMap"] = self.reviewFileMap!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Address") && dict["Address"] != nil {
                    self.address = dict["Address"] as! String
                }
                if dict.keys.contains("BusinessLicenceUrl") && dict["BusinessLicenceUrl"] != nil {
                    self.businessLicenceUrl = dict["BusinessLicenceUrl"] as! String
                }
                if dict.keys.contains("CardNumber") && dict["CardNumber"] != nil {
                    self.cardNumber = dict["CardNumber"] as! String
                }
                if dict.keys.contains("CnInfoUrl") && dict["CnInfoUrl"] != nil {
                    self.cnInfoUrl = dict["CnInfoUrl"] as! String
                }
                if dict.keys.contains("ContactAddress") && dict["ContactAddress"] != nil {
                    self.contactAddress = dict["ContactAddress"] as! String
                }
                if dict.keys.contains("ContactEmail") && dict["ContactEmail"] != nil {
                    self.contactEmail = dict["ContactEmail"] as! String
                }
                if dict.keys.contains("ContactName") && dict["ContactName"] != nil {
                    self.contactName = dict["ContactName"] as! String
                }
                if dict.keys.contains("ContactPhoneNumber") && dict["ContactPhoneNumber"] != nil {
                    self.contactPhoneNumber = dict["ContactPhoneNumber"] as! String
                }
                if dict.keys.contains("ContactZipCode") && dict["ContactZipCode"] != nil {
                    self.contactZipCode = dict["ContactZipCode"] as! String
                }
                if dict.keys.contains("Country") && dict["Country"] != nil {
                    self.country = dict["Country"] as! String
                }
                if dict.keys.contains("EAddress") && dict["EAddress"] != nil {
                    self.EAddress = dict["EAddress"] as! String
                }
                if dict.keys.contains("EName") && dict["EName"] != nil {
                    self.EName = dict["EName"] as! String
                }
                if dict.keys.contains("IdCardNumber") && dict["IdCardNumber"] != nil {
                    self.idCardNumber = dict["IdCardNumber"] as! String
                }
                if dict.keys.contains("IdCardUrl") && dict["IdCardUrl"] != nil {
                    self.idCardUrl = dict["IdCardUrl"] as! String
                }
                if dict.keys.contains("LoaKey") && dict["LoaKey"] != nil {
                    self.loaKey = dict["LoaKey"] as! String
                }
                if dict.keys.contains("LoaUrl") && dict["LoaUrl"] != nil {
                    self.loaUrl = dict["LoaUrl"] as! String
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("PassportUrl") && dict["PassportUrl"] != nil {
                    self.passportUrl = dict["PassportUrl"] as! String
                }
                if dict.keys.contains("PersonalType") && dict["PersonalType"] != nil {
                    self.personalType = dict["PersonalType"] as! Int32
                }
                if dict.keys.contains("PostCode") && dict["PostCode"] != nil {
                    self.postCode = dict["PostCode"] as! String
                }
                if dict.keys.contains("Province") && dict["Province"] != nil {
                    self.province = dict["Province"] as! String
                }
                if dict.keys.contains("ReasonFileOssKey") && dict["ReasonFileOssKey"] != nil {
                    self.reasonFileOssKey = dict["ReasonFileOssKey"] as! String
                }
                if dict.keys.contains("Region") && dict["Region"] != nil {
                    self.region = dict["Region"] as! Int32
                }
                if dict.keys.contains("ReviewFileMap") && dict["ReviewFileMap"] != nil {
                    self.reviewFileMap = dict["ReviewFileMap"] as! [String: Any]
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! Int32
                }
            }
        }
        public class RootCode : Tea.TeaModel {
            public var classificationCode: String?

            public var classificationName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.classificationCode != nil {
                    map["ClassificationCode"] = self.classificationCode!
                }
                if self.classificationName != nil {
                    map["ClassificationName"] = self.classificationName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ClassificationCode") && dict["ClassificationCode"] != nil {
                    self.classificationCode = dict["ClassificationCode"] as! String
                }
                if dict.keys.contains("ClassificationName") && dict["ClassificationName"] != nil {
                    self.classificationName = dict["ClassificationName"] as! String
                }
            }
        }
        public var bitFlag: Int32?

        public var bizId: String?

        public var bizType: String?

        public var extendInfo: [String: Any]?

        public var grayIconUrl: String?

        public var icon: String?

        public var leafCodes: QueryTrademarkDetailByApplyNumberEspResponseBody.Moudle.LeafCodes?

        public var materialInfo: QueryTrademarkDetailByApplyNumberEspResponseBody.Moudle.MaterialInfo?

        public var orderId: String?

        public var partnerCode: String?

        public var principalKey: String?

        public var principalName: String?

        public var produceType: String?

        public var rootCode: QueryTrademarkDetailByApplyNumberEspResponseBody.Moudle.RootCode?

        public var status: String?

        public var statusStr: String?

        public var submitAuditTimeStr: String?

        public var submitAuditTimeValue: Int64?

        public var submitStatus: String?

        public var submitTimeStr: String?

        public var submitTimeValue: Int64?

        public var submitTimes: Int32?

        public var trademarkName: String?

        public var trademarkNameType: Int32?

        public var trademarkNumber: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.leafCodes?.validate()
            try self.materialInfo?.validate()
            try self.rootCode?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bitFlag != nil {
                map["BitFlag"] = self.bitFlag!
            }
            if self.bizId != nil {
                map["BizId"] = self.bizId!
            }
            if self.bizType != nil {
                map["BizType"] = self.bizType!
            }
            if self.extendInfo != nil {
                map["ExtendInfo"] = self.extendInfo!
            }
            if self.grayIconUrl != nil {
                map["GrayIconUrl"] = self.grayIconUrl!
            }
            if self.icon != nil {
                map["Icon"] = self.icon!
            }
            if self.leafCodes != nil {
                map["LeafCodes"] = self.leafCodes?.toMap()
            }
            if self.materialInfo != nil {
                map["MaterialInfo"] = self.materialInfo?.toMap()
            }
            if self.orderId != nil {
                map["OrderId"] = self.orderId!
            }
            if self.partnerCode != nil {
                map["PartnerCode"] = self.partnerCode!
            }
            if self.principalKey != nil {
                map["PrincipalKey"] = self.principalKey!
            }
            if self.principalName != nil {
                map["PrincipalName"] = self.principalName!
            }
            if self.produceType != nil {
                map["ProduceType"] = self.produceType!
            }
            if self.rootCode != nil {
                map["RootCode"] = self.rootCode?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.statusStr != nil {
                map["StatusStr"] = self.statusStr!
            }
            if self.submitAuditTimeStr != nil {
                map["SubmitAuditTimeStr"] = self.submitAuditTimeStr!
            }
            if self.submitAuditTimeValue != nil {
                map["SubmitAuditTimeValue"] = self.submitAuditTimeValue!
            }
            if self.submitStatus != nil {
                map["SubmitStatus"] = self.submitStatus!
            }
            if self.submitTimeStr != nil {
                map["SubmitTimeStr"] = self.submitTimeStr!
            }
            if self.submitTimeValue != nil {
                map["SubmitTimeValue"] = self.submitTimeValue!
            }
            if self.submitTimes != nil {
                map["SubmitTimes"] = self.submitTimes!
            }
            if self.trademarkName != nil {
                map["TrademarkName"] = self.trademarkName!
            }
            if self.trademarkNameType != nil {
                map["TrademarkNameType"] = self.trademarkNameType!
            }
            if self.trademarkNumber != nil {
                map["TrademarkNumber"] = self.trademarkNumber!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BitFlag") && dict["BitFlag"] != nil {
                self.bitFlag = dict["BitFlag"] as! Int32
            }
            if dict.keys.contains("BizId") && dict["BizId"] != nil {
                self.bizId = dict["BizId"] as! String
            }
            if dict.keys.contains("BizType") && dict["BizType"] != nil {
                self.bizType = dict["BizType"] as! String
            }
            if dict.keys.contains("ExtendInfo") && dict["ExtendInfo"] != nil {
                self.extendInfo = dict["ExtendInfo"] as! [String: Any]
            }
            if dict.keys.contains("GrayIconUrl") && dict["GrayIconUrl"] != nil {
                self.grayIconUrl = dict["GrayIconUrl"] as! String
            }
            if dict.keys.contains("Icon") && dict["Icon"] != nil {
                self.icon = dict["Icon"] as! String
            }
            if dict.keys.contains("LeafCodes") && dict["LeafCodes"] != nil {
                var model = QueryTrademarkDetailByApplyNumberEspResponseBody.Moudle.LeafCodes()
                model.fromMap(dict["LeafCodes"] as! [String: Any])
                self.leafCodes = model
            }
            if dict.keys.contains("MaterialInfo") && dict["MaterialInfo"] != nil {
                var model = QueryTrademarkDetailByApplyNumberEspResponseBody.Moudle.MaterialInfo()
                model.fromMap(dict["MaterialInfo"] as! [String: Any])
                self.materialInfo = model
            }
            if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
                self.orderId = dict["OrderId"] as! String
            }
            if dict.keys.contains("PartnerCode") && dict["PartnerCode"] != nil {
                self.partnerCode = dict["PartnerCode"] as! String
            }
            if dict.keys.contains("PrincipalKey") && dict["PrincipalKey"] != nil {
                self.principalKey = dict["PrincipalKey"] as! String
            }
            if dict.keys.contains("PrincipalName") && dict["PrincipalName"] != nil {
                self.principalName = dict["PrincipalName"] as! String
            }
            if dict.keys.contains("ProduceType") && dict["ProduceType"] != nil {
                self.produceType = dict["ProduceType"] as! String
            }
            if dict.keys.contains("RootCode") && dict["RootCode"] != nil {
                var model = QueryTrademarkDetailByApplyNumberEspResponseBody.Moudle.RootCode()
                model.fromMap(dict["RootCode"] as! [String: Any])
                self.rootCode = model
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("StatusStr") && dict["StatusStr"] != nil {
                self.statusStr = dict["StatusStr"] as! String
            }
            if dict.keys.contains("SubmitAuditTimeStr") && dict["SubmitAuditTimeStr"] != nil {
                self.submitAuditTimeStr = dict["SubmitAuditTimeStr"] as! String
            }
            if dict.keys.contains("SubmitAuditTimeValue") && dict["SubmitAuditTimeValue"] != nil {
                self.submitAuditTimeValue = dict["SubmitAuditTimeValue"] as! Int64
            }
            if dict.keys.contains("SubmitStatus") && dict["SubmitStatus"] != nil {
                self.submitStatus = dict["SubmitStatus"] as! String
            }
            if dict.keys.contains("SubmitTimeStr") && dict["SubmitTimeStr"] != nil {
                self.submitTimeStr = dict["SubmitTimeStr"] as! String
            }
            if dict.keys.contains("SubmitTimeValue") && dict["SubmitTimeValue"] != nil {
                self.submitTimeValue = dict["SubmitTimeValue"] as! Int64
            }
            if dict.keys.contains("SubmitTimes") && dict["SubmitTimes"] != nil {
                self.submitTimes = dict["SubmitTimes"] as! Int32
            }
            if dict.keys.contains("TrademarkName") && dict["TrademarkName"] != nil {
                self.trademarkName = dict["TrademarkName"] as! String
            }
            if dict.keys.contains("TrademarkNameType") && dict["TrademarkNameType"] != nil {
                self.trademarkNameType = dict["TrademarkNameType"] as! Int32
            }
            if dict.keys.contains("TrademarkNumber") && dict["TrademarkNumber"] != nil {
                self.trademarkNumber = dict["TrademarkNumber"] as! String
            }
        }
    }
    public var moudle: QueryTrademarkDetailByApplyNumberEspResponseBody.Moudle?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.moudle?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.moudle != nil {
            map["Moudle"] = self.moudle?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Moudle") && dict["Moudle"] != nil {
            var model = QueryTrademarkDetailByApplyNumberEspResponseBody.Moudle()
            model.fromMap(dict["Moudle"] as! [String: Any])
            self.moudle = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class QueryTrademarkDetailByApplyNumberEspResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryTrademarkDetailByApplyNumberEspResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryTrademarkDetailByApplyNumberEspResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryTrademarkModelDetailRequest : Tea.TeaModel {
    public var bizId: String?

    public var env: String?

    public var orderId: String?

    public var reviewSupplementMaterial: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.env != nil {
            map["Env"] = self.env!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.reviewSupplementMaterial != nil {
            map["ReviewSupplementMaterial"] = self.reviewSupplementMaterial!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("Env") && dict["Env"] != nil {
            self.env = dict["Env"] as! String
        }
        if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
            self.orderId = dict["OrderId"] as! String
        }
        if dict.keys.contains("ReviewSupplementMaterial") && dict["ReviewSupplementMaterial"] != nil {
            self.reviewSupplementMaterial = dict["ReviewSupplementMaterial"] as! Bool
        }
    }
}

public class QueryTrademarkModelDetailResponseBody : Tea.TeaModel {
    public class Moudle : Tea.TeaModel {
        public class LeafCodes : Tea.TeaModel {
            public class LeafCode : Tea.TeaModel {
                public var classificationCode: String?

                public var classificationName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.classificationCode != nil {
                        map["ClassificationCode"] = self.classificationCode!
                    }
                    if self.classificationName != nil {
                        map["ClassificationName"] = self.classificationName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ClassificationCode") && dict["ClassificationCode"] != nil {
                        self.classificationCode = dict["ClassificationCode"] as! String
                    }
                    if dict.keys.contains("ClassificationName") && dict["ClassificationName"] != nil {
                        self.classificationName = dict["ClassificationName"] as! String
                    }
                }
            }
            public var leafCode: [QueryTrademarkModelDetailResponseBody.Moudle.LeafCodes.LeafCode]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.leafCode != nil {
                    var tmp : [Any] = []
                    for k in self.leafCode! {
                        tmp.append(k.toMap())
                    }
                    map["leafCode"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("leafCode") && dict["leafCode"] != nil {
                    var tmp : [QueryTrademarkModelDetailResponseBody.Moudle.LeafCodes.LeafCode] = []
                    for v in dict["leafCode"] as! [Any] {
                        var model = QueryTrademarkModelDetailResponseBody.Moudle.LeafCodes.LeafCode()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.leafCode = tmp
                }
            }
        }
        public class MaterialInfo : Tea.TeaModel {
            public var address: String?

            public var businessLicenceUrl: String?

            public var cardNumber: String?

            public var cnInfoUrl: String?

            public var contactAddress: String?

            public var contactEmail: String?

            public var contactName: String?

            public var contactPhoneNumber: String?

            public var contactZipCode: String?

            public var country: String?

            public var EAddress: String?

            public var EName: String?

            public var idCardNumber: String?

            public var idCardUrl: String?

            public var loaKey: String?

            public var loaUrl: String?

            public var name: String?

            public var passportUrl: String?

            public var personalType: Int32?

            public var postCode: String?

            public var province: String?

            public var reasonFileOssKey: String?

            public var region: Int32?

            public var reviewFileMap: [String: Any]?

            public var type: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.address != nil {
                    map["Address"] = self.address!
                }
                if self.businessLicenceUrl != nil {
                    map["BusinessLicenceUrl"] = self.businessLicenceUrl!
                }
                if self.cardNumber != nil {
                    map["CardNumber"] = self.cardNumber!
                }
                if self.cnInfoUrl != nil {
                    map["CnInfoUrl"] = self.cnInfoUrl!
                }
                if self.contactAddress != nil {
                    map["ContactAddress"] = self.contactAddress!
                }
                if self.contactEmail != nil {
                    map["ContactEmail"] = self.contactEmail!
                }
                if self.contactName != nil {
                    map["ContactName"] = self.contactName!
                }
                if self.contactPhoneNumber != nil {
                    map["ContactPhoneNumber"] = self.contactPhoneNumber!
                }
                if self.contactZipCode != nil {
                    map["ContactZipCode"] = self.contactZipCode!
                }
                if self.country != nil {
                    map["Country"] = self.country!
                }
                if self.EAddress != nil {
                    map["EAddress"] = self.EAddress!
                }
                if self.EName != nil {
                    map["EName"] = self.EName!
                }
                if self.idCardNumber != nil {
                    map["IdCardNumber"] = self.idCardNumber!
                }
                if self.idCardUrl != nil {
                    map["IdCardUrl"] = self.idCardUrl!
                }
                if self.loaKey != nil {
                    map["LoaKey"] = self.loaKey!
                }
                if self.loaUrl != nil {
                    map["LoaUrl"] = self.loaUrl!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.passportUrl != nil {
                    map["PassportUrl"] = self.passportUrl!
                }
                if self.personalType != nil {
                    map["PersonalType"] = self.personalType!
                }
                if self.postCode != nil {
                    map["PostCode"] = self.postCode!
                }
                if self.province != nil {
                    map["Province"] = self.province!
                }
                if self.reasonFileOssKey != nil {
                    map["ReasonFileOssKey"] = self.reasonFileOssKey!
                }
                if self.region != nil {
                    map["Region"] = self.region!
                }
                if self.reviewFileMap != nil {
                    map["ReviewFileMap"] = self.reviewFileMap!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Address") && dict["Address"] != nil {
                    self.address = dict["Address"] as! String
                }
                if dict.keys.contains("BusinessLicenceUrl") && dict["BusinessLicenceUrl"] != nil {
                    self.businessLicenceUrl = dict["BusinessLicenceUrl"] as! String
                }
                if dict.keys.contains("CardNumber") && dict["CardNumber"] != nil {
                    self.cardNumber = dict["CardNumber"] as! String
                }
                if dict.keys.contains("CnInfoUrl") && dict["CnInfoUrl"] != nil {
                    self.cnInfoUrl = dict["CnInfoUrl"] as! String
                }
                if dict.keys.contains("ContactAddress") && dict["ContactAddress"] != nil {
                    self.contactAddress = dict["ContactAddress"] as! String
                }
                if dict.keys.contains("ContactEmail") && dict["ContactEmail"] != nil {
                    self.contactEmail = dict["ContactEmail"] as! String
                }
                if dict.keys.contains("ContactName") && dict["ContactName"] != nil {
                    self.contactName = dict["ContactName"] as! String
                }
                if dict.keys.contains("ContactPhoneNumber") && dict["ContactPhoneNumber"] != nil {
                    self.contactPhoneNumber = dict["ContactPhoneNumber"] as! String
                }
                if dict.keys.contains("ContactZipCode") && dict["ContactZipCode"] != nil {
                    self.contactZipCode = dict["ContactZipCode"] as! String
                }
                if dict.keys.contains("Country") && dict["Country"] != nil {
                    self.country = dict["Country"] as! String
                }
                if dict.keys.contains("EAddress") && dict["EAddress"] != nil {
                    self.EAddress = dict["EAddress"] as! String
                }
                if dict.keys.contains("EName") && dict["EName"] != nil {
                    self.EName = dict["EName"] as! String
                }
                if dict.keys.contains("IdCardNumber") && dict["IdCardNumber"] != nil {
                    self.idCardNumber = dict["IdCardNumber"] as! String
                }
                if dict.keys.contains("IdCardUrl") && dict["IdCardUrl"] != nil {
                    self.idCardUrl = dict["IdCardUrl"] as! String
                }
                if dict.keys.contains("LoaKey") && dict["LoaKey"] != nil {
                    self.loaKey = dict["LoaKey"] as! String
                }
                if dict.keys.contains("LoaUrl") && dict["LoaUrl"] != nil {
                    self.loaUrl = dict["LoaUrl"] as! String
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("PassportUrl") && dict["PassportUrl"] != nil {
                    self.passportUrl = dict["PassportUrl"] as! String
                }
                if dict.keys.contains("PersonalType") && dict["PersonalType"] != nil {
                    self.personalType = dict["PersonalType"] as! Int32
                }
                if dict.keys.contains("PostCode") && dict["PostCode"] != nil {
                    self.postCode = dict["PostCode"] as! String
                }
                if dict.keys.contains("Province") && dict["Province"] != nil {
                    self.province = dict["Province"] as! String
                }
                if dict.keys.contains("ReasonFileOssKey") && dict["ReasonFileOssKey"] != nil {
                    self.reasonFileOssKey = dict["ReasonFileOssKey"] as! String
                }
                if dict.keys.contains("Region") && dict["Region"] != nil {
                    self.region = dict["Region"] as! Int32
                }
                if dict.keys.contains("ReviewFileMap") && dict["ReviewFileMap"] != nil {
                    self.reviewFileMap = dict["ReviewFileMap"] as! [String: Any]
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! Int32
                }
            }
        }
        public class RootCode : Tea.TeaModel {
            public var classificationCode: String?

            public var classificationName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.classificationCode != nil {
                    map["ClassificationCode"] = self.classificationCode!
                }
                if self.classificationName != nil {
                    map["ClassificationName"] = self.classificationName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ClassificationCode") && dict["ClassificationCode"] != nil {
                    self.classificationCode = dict["ClassificationCode"] as! String
                }
                if dict.keys.contains("ClassificationName") && dict["ClassificationName"] != nil {
                    self.classificationName = dict["ClassificationName"] as! String
                }
            }
        }
        public var bitFlag: Int32?

        public var bizId: String?

        public var bizType: String?

        public var extendInfo: [String: Any]?

        public var grayIconUrl: String?

        public var icon: String?

        public var leafCodes: QueryTrademarkModelDetailResponseBody.Moudle.LeafCodes?

        public var materialInfo: QueryTrademarkModelDetailResponseBody.Moudle.MaterialInfo?

        public var orderId: String?

        public var partnerCode: String?

        public var principalKey: String?

        public var principalName: String?

        public var produceType: String?

        public var requestId: String?

        public var rootCode: QueryTrademarkModelDetailResponseBody.Moudle.RootCode?

        public var status: String?

        public var statusStr: String?

        public var submitAuditTimeStr: String?

        public var submitAuditTimeValue: Int64?

        public var submitStatus: String?

        public var submitTimeStr: String?

        public var submitTimeValue: Int64?

        public var submitTimes: Int32?

        public var trademarkName: String?

        public var trademarkNameType: Int32?

        public var trademarkNumber: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.leafCodes?.validate()
            try self.materialInfo?.validate()
            try self.rootCode?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bitFlag != nil {
                map["BitFlag"] = self.bitFlag!
            }
            if self.bizId != nil {
                map["BizId"] = self.bizId!
            }
            if self.bizType != nil {
                map["BizType"] = self.bizType!
            }
            if self.extendInfo != nil {
                map["ExtendInfo"] = self.extendInfo!
            }
            if self.grayIconUrl != nil {
                map["GrayIconUrl"] = self.grayIconUrl!
            }
            if self.icon != nil {
                map["Icon"] = self.icon!
            }
            if self.leafCodes != nil {
                map["LeafCodes"] = self.leafCodes?.toMap()
            }
            if self.materialInfo != nil {
                map["MaterialInfo"] = self.materialInfo?.toMap()
            }
            if self.orderId != nil {
                map["OrderId"] = self.orderId!
            }
            if self.partnerCode != nil {
                map["PartnerCode"] = self.partnerCode!
            }
            if self.principalKey != nil {
                map["PrincipalKey"] = self.principalKey!
            }
            if self.principalName != nil {
                map["PrincipalName"] = self.principalName!
            }
            if self.produceType != nil {
                map["ProduceType"] = self.produceType!
            }
            if self.requestId != nil {
                map["RequestId"] = self.requestId!
            }
            if self.rootCode != nil {
                map["RootCode"] = self.rootCode?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.statusStr != nil {
                map["StatusStr"] = self.statusStr!
            }
            if self.submitAuditTimeStr != nil {
                map["SubmitAuditTimeStr"] = self.submitAuditTimeStr!
            }
            if self.submitAuditTimeValue != nil {
                map["SubmitAuditTimeValue"] = self.submitAuditTimeValue!
            }
            if self.submitStatus != nil {
                map["SubmitStatus"] = self.submitStatus!
            }
            if self.submitTimeStr != nil {
                map["SubmitTimeStr"] = self.submitTimeStr!
            }
            if self.submitTimeValue != nil {
                map["SubmitTimeValue"] = self.submitTimeValue!
            }
            if self.submitTimes != nil {
                map["SubmitTimes"] = self.submitTimes!
            }
            if self.trademarkName != nil {
                map["TrademarkName"] = self.trademarkName!
            }
            if self.trademarkNameType != nil {
                map["TrademarkNameType"] = self.trademarkNameType!
            }
            if self.trademarkNumber != nil {
                map["TrademarkNumber"] = self.trademarkNumber!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BitFlag") && dict["BitFlag"] != nil {
                self.bitFlag = dict["BitFlag"] as! Int32
            }
            if dict.keys.contains("BizId") && dict["BizId"] != nil {
                self.bizId = dict["BizId"] as! String
            }
            if dict.keys.contains("BizType") && dict["BizType"] != nil {
                self.bizType = dict["BizType"] as! String
            }
            if dict.keys.contains("ExtendInfo") && dict["ExtendInfo"] != nil {
                self.extendInfo = dict["ExtendInfo"] as! [String: Any]
            }
            if dict.keys.contains("GrayIconUrl") && dict["GrayIconUrl"] != nil {
                self.grayIconUrl = dict["GrayIconUrl"] as! String
            }
            if dict.keys.contains("Icon") && dict["Icon"] != nil {
                self.icon = dict["Icon"] as! String
            }
            if dict.keys.contains("LeafCodes") && dict["LeafCodes"] != nil {
                var model = QueryTrademarkModelDetailResponseBody.Moudle.LeafCodes()
                model.fromMap(dict["LeafCodes"] as! [String: Any])
                self.leafCodes = model
            }
            if dict.keys.contains("MaterialInfo") && dict["MaterialInfo"] != nil {
                var model = QueryTrademarkModelDetailResponseBody.Moudle.MaterialInfo()
                model.fromMap(dict["MaterialInfo"] as! [String: Any])
                self.materialInfo = model
            }
            if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
                self.orderId = dict["OrderId"] as! String
            }
            if dict.keys.contains("PartnerCode") && dict["PartnerCode"] != nil {
                self.partnerCode = dict["PartnerCode"] as! String
            }
            if dict.keys.contains("PrincipalKey") && dict["PrincipalKey"] != nil {
                self.principalKey = dict["PrincipalKey"] as! String
            }
            if dict.keys.contains("PrincipalName") && dict["PrincipalName"] != nil {
                self.principalName = dict["PrincipalName"] as! String
            }
            if dict.keys.contains("ProduceType") && dict["ProduceType"] != nil {
                self.produceType = dict["ProduceType"] as! String
            }
            if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
                self.requestId = dict["RequestId"] as! String
            }
            if dict.keys.contains("RootCode") && dict["RootCode"] != nil {
                var model = QueryTrademarkModelDetailResponseBody.Moudle.RootCode()
                model.fromMap(dict["RootCode"] as! [String: Any])
                self.rootCode = model
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("StatusStr") && dict["StatusStr"] != nil {
                self.statusStr = dict["StatusStr"] as! String
            }
            if dict.keys.contains("SubmitAuditTimeStr") && dict["SubmitAuditTimeStr"] != nil {
                self.submitAuditTimeStr = dict["SubmitAuditTimeStr"] as! String
            }
            if dict.keys.contains("SubmitAuditTimeValue") && dict["SubmitAuditTimeValue"] != nil {
                self.submitAuditTimeValue = dict["SubmitAuditTimeValue"] as! Int64
            }
            if dict.keys.contains("SubmitStatus") && dict["SubmitStatus"] != nil {
                self.submitStatus = dict["SubmitStatus"] as! String
            }
            if dict.keys.contains("SubmitTimeStr") && dict["SubmitTimeStr"] != nil {
                self.submitTimeStr = dict["SubmitTimeStr"] as! String
            }
            if dict.keys.contains("SubmitTimeValue") && dict["SubmitTimeValue"] != nil {
                self.submitTimeValue = dict["SubmitTimeValue"] as! Int64
            }
            if dict.keys.contains("SubmitTimes") && dict["SubmitTimes"] != nil {
                self.submitTimes = dict["SubmitTimes"] as! Int32
            }
            if dict.keys.contains("TrademarkName") && dict["TrademarkName"] != nil {
                self.trademarkName = dict["TrademarkName"] as! String
            }
            if dict.keys.contains("TrademarkNameType") && dict["TrademarkNameType"] != nil {
                self.trademarkNameType = dict["TrademarkNameType"] as! Int32
            }
            if dict.keys.contains("TrademarkNumber") && dict["TrademarkNumber"] != nil {
                self.trademarkNumber = dict["TrademarkNumber"] as! String
            }
        }
    }
    public var moudle: QueryTrademarkModelDetailResponseBody.Moudle?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.moudle?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.moudle != nil {
            map["Moudle"] = self.moudle?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Moudle") && dict["Moudle"] != nil {
            var model = QueryTrademarkModelDetailResponseBody.Moudle()
            model.fromMap(dict["Moudle"] as! [String: Any])
            self.moudle = model
        }
    }
}

public class QueryTrademarkModelDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryTrademarkModelDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryTrademarkModelDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryTrademarkModelEspDetailRequest : Tea.TeaModel {
    public var bizId: String?

    public var bizType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.bizType != nil {
            map["BizType"] = self.bizType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("BizType") && dict["BizType"] != nil {
            self.bizType = dict["BizType"] as! String
        }
    }
}

public class QueryTrademarkModelEspDetailResponseBody : Tea.TeaModel {
    public class Moudle : Tea.TeaModel {
        public class LeafCodes : Tea.TeaModel {
            public class LeafCode : Tea.TeaModel {
                public var classificationCode: String?

                public var classificationName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.classificationCode != nil {
                        map["ClassificationCode"] = self.classificationCode!
                    }
                    if self.classificationName != nil {
                        map["ClassificationName"] = self.classificationName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ClassificationCode") && dict["ClassificationCode"] != nil {
                        self.classificationCode = dict["ClassificationCode"] as! String
                    }
                    if dict.keys.contains("ClassificationName") && dict["ClassificationName"] != nil {
                        self.classificationName = dict["ClassificationName"] as! String
                    }
                }
            }
            public var leafCode: [QueryTrademarkModelEspDetailResponseBody.Moudle.LeafCodes.LeafCode]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.leafCode != nil {
                    var tmp : [Any] = []
                    for k in self.leafCode! {
                        tmp.append(k.toMap())
                    }
                    map["leafCode"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("leafCode") && dict["leafCode"] != nil {
                    var tmp : [QueryTrademarkModelEspDetailResponseBody.Moudle.LeafCodes.LeafCode] = []
                    for v in dict["leafCode"] as! [Any] {
                        var model = QueryTrademarkModelEspDetailResponseBody.Moudle.LeafCodes.LeafCode()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.leafCode = tmp
                }
            }
        }
        public class MaterialInfo : Tea.TeaModel {
            public var address: String?

            public var businessLicenceUrl: String?

            public var cardNumber: String?

            public var cnInfoUrl: String?

            public var contactAddress: String?

            public var contactEmail: String?

            public var contactZipCode: String?

            public var country: String?

            public var EAddress: String?

            public var EName: String?

            public var idCardNumber: String?

            public var idCardUrl: String?

            public var loaKey: String?

            public var loaUrl: String?

            public var name: String?

            public var passportUrl: String?

            public var personalType: String?

            public var postCode: String?

            public var province: String?

            public var reasonFileOssKey: String?

            public var region: Int32?

            public var type: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.address != nil {
                    map["Address"] = self.address!
                }
                if self.businessLicenceUrl != nil {
                    map["BusinessLicenceUrl"] = self.businessLicenceUrl!
                }
                if self.cardNumber != nil {
                    map["CardNumber"] = self.cardNumber!
                }
                if self.cnInfoUrl != nil {
                    map["CnInfoUrl"] = self.cnInfoUrl!
                }
                if self.contactAddress != nil {
                    map["ContactAddress"] = self.contactAddress!
                }
                if self.contactEmail != nil {
                    map["ContactEmail"] = self.contactEmail!
                }
                if self.contactZipCode != nil {
                    map["ContactZipCode"] = self.contactZipCode!
                }
                if self.country != nil {
                    map["Country"] = self.country!
                }
                if self.EAddress != nil {
                    map["EAddress"] = self.EAddress!
                }
                if self.EName != nil {
                    map["EName"] = self.EName!
                }
                if self.idCardNumber != nil {
                    map["IdCardNumber"] = self.idCardNumber!
                }
                if self.idCardUrl != nil {
                    map["IdCardUrl"] = self.idCardUrl!
                }
                if self.loaKey != nil {
                    map["LoaKey"] = self.loaKey!
                }
                if self.loaUrl != nil {
                    map["LoaUrl"] = self.loaUrl!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.passportUrl != nil {
                    map["PassportUrl"] = self.passportUrl!
                }
                if self.personalType != nil {
                    map["PersonalType"] = self.personalType!
                }
                if self.postCode != nil {
                    map["PostCode"] = self.postCode!
                }
                if self.province != nil {
                    map["Province"] = self.province!
                }
                if self.reasonFileOssKey != nil {
                    map["ReasonFileOssKey"] = self.reasonFileOssKey!
                }
                if self.region != nil {
                    map["Region"] = self.region!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Address") && dict["Address"] != nil {
                    self.address = dict["Address"] as! String
                }
                if dict.keys.contains("BusinessLicenceUrl") && dict["BusinessLicenceUrl"] != nil {
                    self.businessLicenceUrl = dict["BusinessLicenceUrl"] as! String
                }
                if dict.keys.contains("CardNumber") && dict["CardNumber"] != nil {
                    self.cardNumber = dict["CardNumber"] as! String
                }
                if dict.keys.contains("CnInfoUrl") && dict["CnInfoUrl"] != nil {
                    self.cnInfoUrl = dict["CnInfoUrl"] as! String
                }
                if dict.keys.contains("ContactAddress") && dict["ContactAddress"] != nil {
                    self.contactAddress = dict["ContactAddress"] as! String
                }
                if dict.keys.contains("ContactEmail") && dict["ContactEmail"] != nil {
                    self.contactEmail = dict["ContactEmail"] as! String
                }
                if dict.keys.contains("ContactZipCode") && dict["ContactZipCode"] != nil {
                    self.contactZipCode = dict["ContactZipCode"] as! String
                }
                if dict.keys.contains("Country") && dict["Country"] != nil {
                    self.country = dict["Country"] as! String
                }
                if dict.keys.contains("EAddress") && dict["EAddress"] != nil {
                    self.EAddress = dict["EAddress"] as! String
                }
                if dict.keys.contains("EName") && dict["EName"] != nil {
                    self.EName = dict["EName"] as! String
                }
                if dict.keys.contains("IdCardNumber") && dict["IdCardNumber"] != nil {
                    self.idCardNumber = dict["IdCardNumber"] as! String
                }
                if dict.keys.contains("IdCardUrl") && dict["IdCardUrl"] != nil {
                    self.idCardUrl = dict["IdCardUrl"] as! String
                }
                if dict.keys.contains("LoaKey") && dict["LoaKey"] != nil {
                    self.loaKey = dict["LoaKey"] as! String
                }
                if dict.keys.contains("LoaUrl") && dict["LoaUrl"] != nil {
                    self.loaUrl = dict["LoaUrl"] as! String
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("PassportUrl") && dict["PassportUrl"] != nil {
                    self.passportUrl = dict["PassportUrl"] as! String
                }
                if dict.keys.contains("PersonalType") && dict["PersonalType"] != nil {
                    self.personalType = dict["PersonalType"] as! String
                }
                if dict.keys.contains("PostCode") && dict["PostCode"] != nil {
                    self.postCode = dict["PostCode"] as! String
                }
                if dict.keys.contains("Province") && dict["Province"] != nil {
                    self.province = dict["Province"] as! String
                }
                if dict.keys.contains("ReasonFileOssKey") && dict["ReasonFileOssKey"] != nil {
                    self.reasonFileOssKey = dict["ReasonFileOssKey"] as! String
                }
                if dict.keys.contains("Region") && dict["Region"] != nil {
                    self.region = dict["Region"] as! Int32
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! Int32
                }
            }
        }
        public class RootCode : Tea.TeaModel {
            public var classificationCode: String?

            public var classificationName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.classificationCode != nil {
                    map["ClassificationCode"] = self.classificationCode!
                }
                if self.classificationName != nil {
                    map["ClassificationName"] = self.classificationName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ClassificationCode") && dict["ClassificationCode"] != nil {
                    self.classificationCode = dict["ClassificationCode"] as! String
                }
                if dict.keys.contains("ClassificationName") && dict["ClassificationName"] != nil {
                    self.classificationName = dict["ClassificationName"] as! String
                }
            }
        }
        public var bitFlag: Int32?

        public var bizId: String?

        public var bizType: String?

        public var extendInfo: [String: Any]?

        public var grayIconUrl: String?

        public var icon: String?

        public var leafCodes: QueryTrademarkModelEspDetailResponseBody.Moudle.LeafCodes?

        public var materialInfo: QueryTrademarkModelEspDetailResponseBody.Moudle.MaterialInfo?

        public var orderId: String?

        public var partnerCode: String?

        public var principalKey: String?

        public var principalName: String?

        public var produceType: String?

        public var requestId: String?

        public var rootCode: QueryTrademarkModelEspDetailResponseBody.Moudle.RootCode?

        public var status: String?

        public var statusStr: String?

        public var submitAuditTime: Int64?

        public var submitStatus: String?

        public var submitTime: Int64?

        public var submitTimes: Int32?

        public var trademarkName: String?

        public var trademarkNameType: Int32?

        public var trademarkNumber: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.leafCodes?.validate()
            try self.materialInfo?.validate()
            try self.rootCode?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bitFlag != nil {
                map["BitFlag"] = self.bitFlag!
            }
            if self.bizId != nil {
                map["BizId"] = self.bizId!
            }
            if self.bizType != nil {
                map["BizType"] = self.bizType!
            }
            if self.extendInfo != nil {
                map["ExtendInfo"] = self.extendInfo!
            }
            if self.grayIconUrl != nil {
                map["GrayIconUrl"] = self.grayIconUrl!
            }
            if self.icon != nil {
                map["Icon"] = self.icon!
            }
            if self.leafCodes != nil {
                map["LeafCodes"] = self.leafCodes?.toMap()
            }
            if self.materialInfo != nil {
                map["MaterialInfo"] = self.materialInfo?.toMap()
            }
            if self.orderId != nil {
                map["OrderId"] = self.orderId!
            }
            if self.partnerCode != nil {
                map["PartnerCode"] = self.partnerCode!
            }
            if self.principalKey != nil {
                map["PrincipalKey"] = self.principalKey!
            }
            if self.principalName != nil {
                map["PrincipalName"] = self.principalName!
            }
            if self.produceType != nil {
                map["ProduceType"] = self.produceType!
            }
            if self.requestId != nil {
                map["RequestId"] = self.requestId!
            }
            if self.rootCode != nil {
                map["RootCode"] = self.rootCode?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.statusStr != nil {
                map["StatusStr"] = self.statusStr!
            }
            if self.submitAuditTime != nil {
                map["SubmitAuditTime"] = self.submitAuditTime!
            }
            if self.submitStatus != nil {
                map["SubmitStatus"] = self.submitStatus!
            }
            if self.submitTime != nil {
                map["SubmitTime"] = self.submitTime!
            }
            if self.submitTimes != nil {
                map["SubmitTimes"] = self.submitTimes!
            }
            if self.trademarkName != nil {
                map["TrademarkName"] = self.trademarkName!
            }
            if self.trademarkNameType != nil {
                map["TrademarkNameType"] = self.trademarkNameType!
            }
            if self.trademarkNumber != nil {
                map["TrademarkNumber"] = self.trademarkNumber!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BitFlag") && dict["BitFlag"] != nil {
                self.bitFlag = dict["BitFlag"] as! Int32
            }
            if dict.keys.contains("BizId") && dict["BizId"] != nil {
                self.bizId = dict["BizId"] as! String
            }
            if dict.keys.contains("BizType") && dict["BizType"] != nil {
                self.bizType = dict["BizType"] as! String
            }
            if dict.keys.contains("ExtendInfo") && dict["ExtendInfo"] != nil {
                self.extendInfo = dict["ExtendInfo"] as! [String: Any]
            }
            if dict.keys.contains("GrayIconUrl") && dict["GrayIconUrl"] != nil {
                self.grayIconUrl = dict["GrayIconUrl"] as! String
            }
            if dict.keys.contains("Icon") && dict["Icon"] != nil {
                self.icon = dict["Icon"] as! String
            }
            if dict.keys.contains("LeafCodes") && dict["LeafCodes"] != nil {
                var model = QueryTrademarkModelEspDetailResponseBody.Moudle.LeafCodes()
                model.fromMap(dict["LeafCodes"] as! [String: Any])
                self.leafCodes = model
            }
            if dict.keys.contains("MaterialInfo") && dict["MaterialInfo"] != nil {
                var model = QueryTrademarkModelEspDetailResponseBody.Moudle.MaterialInfo()
                model.fromMap(dict["MaterialInfo"] as! [String: Any])
                self.materialInfo = model
            }
            if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
                self.orderId = dict["OrderId"] as! String
            }
            if dict.keys.contains("PartnerCode") && dict["PartnerCode"] != nil {
                self.partnerCode = dict["PartnerCode"] as! String
            }
            if dict.keys.contains("PrincipalKey") && dict["PrincipalKey"] != nil {
                self.principalKey = dict["PrincipalKey"] as! String
            }
            if dict.keys.contains("PrincipalName") && dict["PrincipalName"] != nil {
                self.principalName = dict["PrincipalName"] as! String
            }
            if dict.keys.contains("ProduceType") && dict["ProduceType"] != nil {
                self.produceType = dict["ProduceType"] as! String
            }
            if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
                self.requestId = dict["RequestId"] as! String
            }
            if dict.keys.contains("RootCode") && dict["RootCode"] != nil {
                var model = QueryTrademarkModelEspDetailResponseBody.Moudle.RootCode()
                model.fromMap(dict["RootCode"] as! [String: Any])
                self.rootCode = model
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("StatusStr") && dict["StatusStr"] != nil {
                self.statusStr = dict["StatusStr"] as! String
            }
            if dict.keys.contains("SubmitAuditTime") && dict["SubmitAuditTime"] != nil {
                self.submitAuditTime = dict["SubmitAuditTime"] as! Int64
            }
            if dict.keys.contains("SubmitStatus") && dict["SubmitStatus"] != nil {
                self.submitStatus = dict["SubmitStatus"] as! String
            }
            if dict.keys.contains("SubmitTime") && dict["SubmitTime"] != nil {
                self.submitTime = dict["SubmitTime"] as! Int64
            }
            if dict.keys.contains("SubmitTimes") && dict["SubmitTimes"] != nil {
                self.submitTimes = dict["SubmitTimes"] as! Int32
            }
            if dict.keys.contains("TrademarkName") && dict["TrademarkName"] != nil {
                self.trademarkName = dict["TrademarkName"] as! String
            }
            if dict.keys.contains("TrademarkNameType") && dict["TrademarkNameType"] != nil {
                self.trademarkNameType = dict["TrademarkNameType"] as! Int32
            }
            if dict.keys.contains("TrademarkNumber") && dict["TrademarkNumber"] != nil {
                self.trademarkNumber = dict["TrademarkNumber"] as! String
            }
        }
    }
    public var moudle: QueryTrademarkModelEspDetailResponseBody.Moudle?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.moudle?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.moudle != nil {
            map["Moudle"] = self.moudle?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Moudle") && dict["Moudle"] != nil {
            var model = QueryTrademarkModelEspDetailResponseBody.Moudle()
            model.fromMap(dict["Moudle"] as! [String: Any])
            self.moudle = model
        }
    }
}

public class QueryTrademarkModelEspDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryTrademarkModelEspDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryTrademarkModelEspDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryTrademarkModelEspListRequest : Tea.TeaModel {
    public var bizId: String?

    public var bizType: String?

    public var env: String?

    public var orderId: String?

    public var orderIdsStr: String?

    public var orderInstanceId: String?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var principalKey: String?

    public var principalName: String?

    public var status: String?

    public var submitStatus: String?

    public var submitTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.bizType != nil {
            map["BizType"] = self.bizType!
        }
        if self.env != nil {
            map["Env"] = self.env!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.orderIdsStr != nil {
            map["OrderIdsStr"] = self.orderIdsStr!
        }
        if self.orderInstanceId != nil {
            map["OrderInstanceId"] = self.orderInstanceId!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.principalKey != nil {
            map["PrincipalKey"] = self.principalKey!
        }
        if self.principalName != nil {
            map["PrincipalName"] = self.principalName!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.submitStatus != nil {
            map["SubmitStatus"] = self.submitStatus!
        }
        if self.submitTime != nil {
            map["SubmitTime"] = self.submitTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("BizType") && dict["BizType"] != nil {
            self.bizType = dict["BizType"] as! String
        }
        if dict.keys.contains("Env") && dict["Env"] != nil {
            self.env = dict["Env"] as! String
        }
        if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
            self.orderId = dict["OrderId"] as! String
        }
        if dict.keys.contains("OrderIdsStr") && dict["OrderIdsStr"] != nil {
            self.orderIdsStr = dict["OrderIdsStr"] as! String
        }
        if dict.keys.contains("OrderInstanceId") && dict["OrderInstanceId"] != nil {
            self.orderInstanceId = dict["OrderInstanceId"] as! String
        }
        if dict.keys.contains("PageNum") && dict["PageNum"] != nil {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("PrincipalKey") && dict["PrincipalKey"] != nil {
            self.principalKey = dict["PrincipalKey"] as! String
        }
        if dict.keys.contains("PrincipalName") && dict["PrincipalName"] != nil {
            self.principalName = dict["PrincipalName"] as! String
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("SubmitStatus") && dict["SubmitStatus"] != nil {
            self.submitStatus = dict["SubmitStatus"] as! String
        }
        if dict.keys.contains("SubmitTime") && dict["SubmitTime"] != nil {
            self.submitTime = dict["SubmitTime"] as! String
        }
    }
}

public class QueryTrademarkModelEspListResponseBody : Tea.TeaModel {
    public class Moudle : Tea.TeaModel {
        public class Data : Tea.TeaModel {
            public class Item : Tea.TeaModel {
                public class LeafCodes : Tea.TeaModel {
                    public class LeafCode : Tea.TeaModel {
                        public var classificationCode: String?

                        public var classificationName: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.classificationCode != nil {
                                map["ClassificationCode"] = self.classificationCode!
                            }
                            if self.classificationName != nil {
                                map["ClassificationName"] = self.classificationName!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("ClassificationCode") && dict["ClassificationCode"] != nil {
                                self.classificationCode = dict["ClassificationCode"] as! String
                            }
                            if dict.keys.contains("ClassificationName") && dict["ClassificationName"] != nil {
                                self.classificationName = dict["ClassificationName"] as! String
                            }
                        }
                    }
                    public var leafCode: [QueryTrademarkModelEspListResponseBody.Moudle.Data.Item.LeafCodes.LeafCode]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.leafCode != nil {
                            var tmp : [Any] = []
                            for k in self.leafCode! {
                                tmp.append(k.toMap())
                            }
                            map["leafCode"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("leafCode") && dict["leafCode"] != nil {
                            var tmp : [QueryTrademarkModelEspListResponseBody.Moudle.Data.Item.LeafCodes.LeafCode] = []
                            for v in dict["leafCode"] as! [Any] {
                                var model = QueryTrademarkModelEspListResponseBody.Moudle.Data.Item.LeafCodes.LeafCode()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.leafCode = tmp
                        }
                    }
                }
                public class MaterialInfo : Tea.TeaModel {
                    public var address: String?

                    public var businessLicenceUrl: String?

                    public var cardNumber: String?

                    public var cnInfoUrl: String?

                    public var contactAddress: String?

                    public var contactEmail: String?

                    public var contactZipCode: String?

                    public var country: String?

                    public var EAddress: String?

                    public var EName: String?

                    public var idCardNumber: String?

                    public var idCardUrl: String?

                    public var loaKey: String?

                    public var loaUrl: String?

                    public var name: String?

                    public var passportUrl: String?

                    public var personalType: String?

                    public var postCode: String?

                    public var province: String?

                    public var reasonFileOssKey: String?

                    public var region: Int32?

                    public var type: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.address != nil {
                            map["Address"] = self.address!
                        }
                        if self.businessLicenceUrl != nil {
                            map["BusinessLicenceUrl"] = self.businessLicenceUrl!
                        }
                        if self.cardNumber != nil {
                            map["CardNumber"] = self.cardNumber!
                        }
                        if self.cnInfoUrl != nil {
                            map["CnInfoUrl"] = self.cnInfoUrl!
                        }
                        if self.contactAddress != nil {
                            map["ContactAddress"] = self.contactAddress!
                        }
                        if self.contactEmail != nil {
                            map["ContactEmail"] = self.contactEmail!
                        }
                        if self.contactZipCode != nil {
                            map["ContactZipCode"] = self.contactZipCode!
                        }
                        if self.country != nil {
                            map["Country"] = self.country!
                        }
                        if self.EAddress != nil {
                            map["EAddress"] = self.EAddress!
                        }
                        if self.EName != nil {
                            map["EName"] = self.EName!
                        }
                        if self.idCardNumber != nil {
                            map["IdCardNumber"] = self.idCardNumber!
                        }
                        if self.idCardUrl != nil {
                            map["IdCardUrl"] = self.idCardUrl!
                        }
                        if self.loaKey != nil {
                            map["LoaKey"] = self.loaKey!
                        }
                        if self.loaUrl != nil {
                            map["LoaUrl"] = self.loaUrl!
                        }
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        if self.passportUrl != nil {
                            map["PassportUrl"] = self.passportUrl!
                        }
                        if self.personalType != nil {
                            map["PersonalType"] = self.personalType!
                        }
                        if self.postCode != nil {
                            map["PostCode"] = self.postCode!
                        }
                        if self.province != nil {
                            map["Province"] = self.province!
                        }
                        if self.reasonFileOssKey != nil {
                            map["ReasonFileOssKey"] = self.reasonFileOssKey!
                        }
                        if self.region != nil {
                            map["Region"] = self.region!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Address") && dict["Address"] != nil {
                            self.address = dict["Address"] as! String
                        }
                        if dict.keys.contains("BusinessLicenceUrl") && dict["BusinessLicenceUrl"] != nil {
                            self.businessLicenceUrl = dict["BusinessLicenceUrl"] as! String
                        }
                        if dict.keys.contains("CardNumber") && dict["CardNumber"] != nil {
                            self.cardNumber = dict["CardNumber"] as! String
                        }
                        if dict.keys.contains("CnInfoUrl") && dict["CnInfoUrl"] != nil {
                            self.cnInfoUrl = dict["CnInfoUrl"] as! String
                        }
                        if dict.keys.contains("ContactAddress") && dict["ContactAddress"] != nil {
                            self.contactAddress = dict["ContactAddress"] as! String
                        }
                        if dict.keys.contains("ContactEmail") && dict["ContactEmail"] != nil {
                            self.contactEmail = dict["ContactEmail"] as! String
                        }
                        if dict.keys.contains("ContactZipCode") && dict["ContactZipCode"] != nil {
                            self.contactZipCode = dict["ContactZipCode"] as! String
                        }
                        if dict.keys.contains("Country") && dict["Country"] != nil {
                            self.country = dict["Country"] as! String
                        }
                        if dict.keys.contains("EAddress") && dict["EAddress"] != nil {
                            self.EAddress = dict["EAddress"] as! String
                        }
                        if dict.keys.contains("EName") && dict["EName"] != nil {
                            self.EName = dict["EName"] as! String
                        }
                        if dict.keys.contains("IdCardNumber") && dict["IdCardNumber"] != nil {
                            self.idCardNumber = dict["IdCardNumber"] as! String
                        }
                        if dict.keys.contains("IdCardUrl") && dict["IdCardUrl"] != nil {
                            self.idCardUrl = dict["IdCardUrl"] as! String
                        }
                        if dict.keys.contains("LoaKey") && dict["LoaKey"] != nil {
                            self.loaKey = dict["LoaKey"] as! String
                        }
                        if dict.keys.contains("LoaUrl") && dict["LoaUrl"] != nil {
                            self.loaUrl = dict["LoaUrl"] as! String
                        }
                        if dict.keys.contains("Name") && dict["Name"] != nil {
                            self.name = dict["Name"] as! String
                        }
                        if dict.keys.contains("PassportUrl") && dict["PassportUrl"] != nil {
                            self.passportUrl = dict["PassportUrl"] as! String
                        }
                        if dict.keys.contains("PersonalType") && dict["PersonalType"] != nil {
                            self.personalType = dict["PersonalType"] as! String
                        }
                        if dict.keys.contains("PostCode") && dict["PostCode"] != nil {
                            self.postCode = dict["PostCode"] as! String
                        }
                        if dict.keys.contains("Province") && dict["Province"] != nil {
                            self.province = dict["Province"] as! String
                        }
                        if dict.keys.contains("ReasonFileOssKey") && dict["ReasonFileOssKey"] != nil {
                            self.reasonFileOssKey = dict["ReasonFileOssKey"] as! String
                        }
                        if dict.keys.contains("Region") && dict["Region"] != nil {
                            self.region = dict["Region"] as! Int32
                        }
                        if dict.keys.contains("Type") && dict["Type"] != nil {
                            self.type = dict["Type"] as! Int32
                        }
                    }
                }
                public class RootCode : Tea.TeaModel {
                    public var classificationCode: String?

                    public var classificationName: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.classificationCode != nil {
                            map["ClassificationCode"] = self.classificationCode!
                        }
                        if self.classificationName != nil {
                            map["ClassificationName"] = self.classificationName!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ClassificationCode") && dict["ClassificationCode"] != nil {
                            self.classificationCode = dict["ClassificationCode"] as! String
                        }
                        if dict.keys.contains("ClassificationName") && dict["ClassificationName"] != nil {
                            self.classificationName = dict["ClassificationName"] as! String
                        }
                    }
                }
                public var bitFlag: Int32?

                public var bizId: String?

                public var bizType: String?

                public var extendInfo: [String: Any]?

                public var grayIconUrl: String?

                public var icon: String?

                public var leafCodes: QueryTrademarkModelEspListResponseBody.Moudle.Data.Item.LeafCodes?

                public var materialInfo: QueryTrademarkModelEspListResponseBody.Moudle.Data.Item.MaterialInfo?

                public var orderId: String?

                public var partnerCode: String?

                public var principalKey: String?

                public var principalName: String?

                public var produceType: String?

                public var rootCode: QueryTrademarkModelEspListResponseBody.Moudle.Data.Item.RootCode?

                public var status: String?

                public var statusStr: String?

                public var submitAuditTime: Int64?

                public var submitStatus: String?

                public var submitTime: Int64?

                public var submitTimes: Int32?

                public var trademarkName: String?

                public var trademarkNameType: Int32?

                public var trademarkNumber: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.leafCodes?.validate()
                    try self.materialInfo?.validate()
                    try self.rootCode?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitFlag != nil {
                        map["BitFlag"] = self.bitFlag!
                    }
                    if self.bizId != nil {
                        map["BizId"] = self.bizId!
                    }
                    if self.bizType != nil {
                        map["BizType"] = self.bizType!
                    }
                    if self.extendInfo != nil {
                        map["ExtendInfo"] = self.extendInfo!
                    }
                    if self.grayIconUrl != nil {
                        map["GrayIconUrl"] = self.grayIconUrl!
                    }
                    if self.icon != nil {
                        map["Icon"] = self.icon!
                    }
                    if self.leafCodes != nil {
                        map["LeafCodes"] = self.leafCodes?.toMap()
                    }
                    if self.materialInfo != nil {
                        map["MaterialInfo"] = self.materialInfo?.toMap()
                    }
                    if self.orderId != nil {
                        map["OrderId"] = self.orderId!
                    }
                    if self.partnerCode != nil {
                        map["PartnerCode"] = self.partnerCode!
                    }
                    if self.principalKey != nil {
                        map["PrincipalKey"] = self.principalKey!
                    }
                    if self.principalName != nil {
                        map["PrincipalName"] = self.principalName!
                    }
                    if self.produceType != nil {
                        map["ProduceType"] = self.produceType!
                    }
                    if self.rootCode != nil {
                        map["RootCode"] = self.rootCode?.toMap()
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    if self.statusStr != nil {
                        map["StatusStr"] = self.statusStr!
                    }
                    if self.submitAuditTime != nil {
                        map["SubmitAuditTime"] = self.submitAuditTime!
                    }
                    if self.submitStatus != nil {
                        map["SubmitStatus"] = self.submitStatus!
                    }
                    if self.submitTime != nil {
                        map["SubmitTime"] = self.submitTime!
                    }
                    if self.submitTimes != nil {
                        map["SubmitTimes"] = self.submitTimes!
                    }
                    if self.trademarkName != nil {
                        map["TrademarkName"] = self.trademarkName!
                    }
                    if self.trademarkNameType != nil {
                        map["TrademarkNameType"] = self.trademarkNameType!
                    }
                    if self.trademarkNumber != nil {
                        map["TrademarkNumber"] = self.trademarkNumber!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("BitFlag") && dict["BitFlag"] != nil {
                        self.bitFlag = dict["BitFlag"] as! Int32
                    }
                    if dict.keys.contains("BizId") && dict["BizId"] != nil {
                        self.bizId = dict["BizId"] as! String
                    }
                    if dict.keys.contains("BizType") && dict["BizType"] != nil {
                        self.bizType = dict["BizType"] as! String
                    }
                    if dict.keys.contains("ExtendInfo") && dict["ExtendInfo"] != nil {
                        self.extendInfo = dict["ExtendInfo"] as! [String: Any]
                    }
                    if dict.keys.contains("GrayIconUrl") && dict["GrayIconUrl"] != nil {
                        self.grayIconUrl = dict["GrayIconUrl"] as! String
                    }
                    if dict.keys.contains("Icon") && dict["Icon"] != nil {
                        self.icon = dict["Icon"] as! String
                    }
                    if dict.keys.contains("LeafCodes") && dict["LeafCodes"] != nil {
                        var model = QueryTrademarkModelEspListResponseBody.Moudle.Data.Item.LeafCodes()
                        model.fromMap(dict["LeafCodes"] as! [String: Any])
                        self.leafCodes = model
                    }
                    if dict.keys.contains("MaterialInfo") && dict["MaterialInfo"] != nil {
                        var model = QueryTrademarkModelEspListResponseBody.Moudle.Data.Item.MaterialInfo()
                        model.fromMap(dict["MaterialInfo"] as! [String: Any])
                        self.materialInfo = model
                    }
                    if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
                        self.orderId = dict["OrderId"] as! String
                    }
                    if dict.keys.contains("PartnerCode") && dict["PartnerCode"] != nil {
                        self.partnerCode = dict["PartnerCode"] as! String
                    }
                    if dict.keys.contains("PrincipalKey") && dict["PrincipalKey"] != nil {
                        self.principalKey = dict["PrincipalKey"] as! String
                    }
                    if dict.keys.contains("PrincipalName") && dict["PrincipalName"] != nil {
                        self.principalName = dict["PrincipalName"] as! String
                    }
                    if dict.keys.contains("ProduceType") && dict["ProduceType"] != nil {
                        self.produceType = dict["ProduceType"] as! String
                    }
                    if dict.keys.contains("RootCode") && dict["RootCode"] != nil {
                        var model = QueryTrademarkModelEspListResponseBody.Moudle.Data.Item.RootCode()
                        model.fromMap(dict["RootCode"] as! [String: Any])
                        self.rootCode = model
                    }
                    if dict.keys.contains("Status") && dict["Status"] != nil {
                        self.status = dict["Status"] as! String
                    }
                    if dict.keys.contains("StatusStr") && dict["StatusStr"] != nil {
                        self.statusStr = dict["StatusStr"] as! String
                    }
                    if dict.keys.contains("SubmitAuditTime") && dict["SubmitAuditTime"] != nil {
                        self.submitAuditTime = dict["SubmitAuditTime"] as! Int64
                    }
                    if dict.keys.contains("SubmitStatus") && dict["SubmitStatus"] != nil {
                        self.submitStatus = dict["SubmitStatus"] as! String
                    }
                    if dict.keys.contains("SubmitTime") && dict["SubmitTime"] != nil {
                        self.submitTime = dict["SubmitTime"] as! Int64
                    }
                    if dict.keys.contains("SubmitTimes") && dict["SubmitTimes"] != nil {
                        self.submitTimes = dict["SubmitTimes"] as! Int32
                    }
                    if dict.keys.contains("TrademarkName") && dict["TrademarkName"] != nil {
                        self.trademarkName = dict["TrademarkName"] as! String
                    }
                    if dict.keys.contains("TrademarkNameType") && dict["TrademarkNameType"] != nil {
                        self.trademarkNameType = dict["TrademarkNameType"] as! Int32
                    }
                    if dict.keys.contains("TrademarkNumber") && dict["TrademarkNumber"] != nil {
                        self.trademarkNumber = dict["TrademarkNumber"] as! String
                    }
                }
            }
            public var item: [QueryTrademarkModelEspListResponseBody.Moudle.Data.Item]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.item != nil {
                    var tmp : [Any] = []
                    for k in self.item! {
                        tmp.append(k.toMap())
                    }
                    map["item"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("item") && dict["item"] != nil {
                    var tmp : [QueryTrademarkModelEspListResponseBody.Moudle.Data.Item] = []
                    for v in dict["item"] as! [Any] {
                        var model = QueryTrademarkModelEspListResponseBody.Moudle.Data.Item()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.item = tmp
                }
            }
        }
        public var data: QueryTrademarkModelEspListResponseBody.Moudle.Data?

        public var requestId: String?

        public var totalPageNum: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.data?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.data != nil {
                map["Data"] = self.data?.toMap()
            }
            if self.requestId != nil {
                map["RequestId"] = self.requestId!
            }
            if self.totalPageNum != nil {
                map["TotalPageNum"] = self.totalPageNum!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Data") && dict["Data"] != nil {
                var model = QueryTrademarkModelEspListResponseBody.Moudle.Data()
                model.fromMap(dict["Data"] as! [String: Any])
                self.data = model
            }
            if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
                self.requestId = dict["RequestId"] as! String
            }
            if dict.keys.contains("TotalPageNum") && dict["TotalPageNum"] != nil {
                self.totalPageNum = dict["TotalPageNum"] as! Int32
            }
        }
    }
    public var moudle: QueryTrademarkModelEspListResponseBody.Moudle?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.moudle?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.moudle != nil {
            map["Moudle"] = self.moudle?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Moudle") && dict["Moudle"] != nil {
            var model = QueryTrademarkModelEspListResponseBody.Moudle()
            model.fromMap(dict["Moudle"] as! [String: Any])
            self.moudle = model
        }
    }
}

public class QueryTrademarkModelEspListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryTrademarkModelEspListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryTrademarkModelEspListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryTrademarkModelListRequest : Tea.TeaModel {
    public var env: String?

    public var orderIdsStr: String?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var principalKey: String?

    public var principalName: String?

    public var produceTypesStr: String?

    public var status: String?

    public var submitStart: String?

    public var submitStatus: String?

    public var submitTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.env != nil {
            map["Env"] = self.env!
        }
        if self.orderIdsStr != nil {
            map["OrderIdsStr"] = self.orderIdsStr!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.principalKey != nil {
            map["PrincipalKey"] = self.principalKey!
        }
        if self.principalName != nil {
            map["PrincipalName"] = self.principalName!
        }
        if self.produceTypesStr != nil {
            map["ProduceTypesStr"] = self.produceTypesStr!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.submitStart != nil {
            map["SubmitStart"] = self.submitStart!
        }
        if self.submitStatus != nil {
            map["SubmitStatus"] = self.submitStatus!
        }
        if self.submitTime != nil {
            map["SubmitTime"] = self.submitTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Env") && dict["Env"] != nil {
            self.env = dict["Env"] as! String
        }
        if dict.keys.contains("OrderIdsStr") && dict["OrderIdsStr"] != nil {
            self.orderIdsStr = dict["OrderIdsStr"] as! String
        }
        if dict.keys.contains("PageNum") && dict["PageNum"] != nil {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("PrincipalKey") && dict["PrincipalKey"] != nil {
            self.principalKey = dict["PrincipalKey"] as! String
        }
        if dict.keys.contains("PrincipalName") && dict["PrincipalName"] != nil {
            self.principalName = dict["PrincipalName"] as! String
        }
        if dict.keys.contains("ProduceTypesStr") && dict["ProduceTypesStr"] != nil {
            self.produceTypesStr = dict["ProduceTypesStr"] as! String
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("SubmitStart") && dict["SubmitStart"] != nil {
            self.submitStart = dict["SubmitStart"] as! String
        }
        if dict.keys.contains("SubmitStatus") && dict["SubmitStatus"] != nil {
            self.submitStatus = dict["SubmitStatus"] as! String
        }
        if dict.keys.contains("SubmitTime") && dict["SubmitTime"] != nil {
            self.submitTime = dict["SubmitTime"] as! String
        }
    }
}

public class QueryTrademarkModelListResponseBody : Tea.TeaModel {
    public class Moudle : Tea.TeaModel {
        public class Data : Tea.TeaModel {
            public class Item : Tea.TeaModel {
                public class LeafCodes : Tea.TeaModel {
                    public class LeafCode : Tea.TeaModel {
                        public var classificationCode: String?

                        public var classificationName: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.classificationCode != nil {
                                map["ClassificationCode"] = self.classificationCode!
                            }
                            if self.classificationName != nil {
                                map["ClassificationName"] = self.classificationName!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("ClassificationCode") && dict["ClassificationCode"] != nil {
                                self.classificationCode = dict["ClassificationCode"] as! String
                            }
                            if dict.keys.contains("ClassificationName") && dict["ClassificationName"] != nil {
                                self.classificationName = dict["ClassificationName"] as! String
                            }
                        }
                    }
                    public var leafCode: [QueryTrademarkModelListResponseBody.Moudle.Data.Item.LeafCodes.LeafCode]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.leafCode != nil {
                            var tmp : [Any] = []
                            for k in self.leafCode! {
                                tmp.append(k.toMap())
                            }
                            map["leafCode"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("leafCode") && dict["leafCode"] != nil {
                            var tmp : [QueryTrademarkModelListResponseBody.Moudle.Data.Item.LeafCodes.LeafCode] = []
                            for v in dict["leafCode"] as! [Any] {
                                var model = QueryTrademarkModelListResponseBody.Moudle.Data.Item.LeafCodes.LeafCode()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.leafCode = tmp
                        }
                    }
                }
                public class MaterialInfo : Tea.TeaModel {
                    public var address: String?

                    public var businessLicenceUrl: String?

                    public var cardNumber: String?

                    public var cnInfoUrl: String?

                    public var contactAddress: String?

                    public var contactEmail: String?

                    public var contactZipCode: String?

                    public var country: String?

                    public var EAddress: String?

                    public var EName: String?

                    public var idCardNumber: String?

                    public var idCardUrl: String?

                    public var loaKey: String?

                    public var loaUrl: String?

                    public var name: String?

                    public var passportUrl: String?

                    public var personalType: Int32?

                    public var postCode: String?

                    public var province: String?

                    public var reasonFileOssKey: String?

                    public var region: Int32?

                    public var type: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.address != nil {
                            map["Address"] = self.address!
                        }
                        if self.businessLicenceUrl != nil {
                            map["BusinessLicenceUrl"] = self.businessLicenceUrl!
                        }
                        if self.cardNumber != nil {
                            map["CardNumber"] = self.cardNumber!
                        }
                        if self.cnInfoUrl != nil {
                            map["CnInfoUrl"] = self.cnInfoUrl!
                        }
                        if self.contactAddress != nil {
                            map["ContactAddress"] = self.contactAddress!
                        }
                        if self.contactEmail != nil {
                            map["ContactEmail"] = self.contactEmail!
                        }
                        if self.contactZipCode != nil {
                            map["ContactZipCode"] = self.contactZipCode!
                        }
                        if self.country != nil {
                            map["Country"] = self.country!
                        }
                        if self.EAddress != nil {
                            map["EAddress"] = self.EAddress!
                        }
                        if self.EName != nil {
                            map["EName"] = self.EName!
                        }
                        if self.idCardNumber != nil {
                            map["IdCardNumber"] = self.idCardNumber!
                        }
                        if self.idCardUrl != nil {
                            map["IdCardUrl"] = self.idCardUrl!
                        }
                        if self.loaKey != nil {
                            map["LoaKey"] = self.loaKey!
                        }
                        if self.loaUrl != nil {
                            map["LoaUrl"] = self.loaUrl!
                        }
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        if self.passportUrl != nil {
                            map["PassportUrl"] = self.passportUrl!
                        }
                        if self.personalType != nil {
                            map["PersonalType"] = self.personalType!
                        }
                        if self.postCode != nil {
                            map["PostCode"] = self.postCode!
                        }
                        if self.province != nil {
                            map["Province"] = self.province!
                        }
                        if self.reasonFileOssKey != nil {
                            map["ReasonFileOssKey"] = self.reasonFileOssKey!
                        }
                        if self.region != nil {
                            map["Region"] = self.region!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Address") && dict["Address"] != nil {
                            self.address = dict["Address"] as! String
                        }
                        if dict.keys.contains("BusinessLicenceUrl") && dict["BusinessLicenceUrl"] != nil {
                            self.businessLicenceUrl = dict["BusinessLicenceUrl"] as! String
                        }
                        if dict.keys.contains("CardNumber") && dict["CardNumber"] != nil {
                            self.cardNumber = dict["CardNumber"] as! String
                        }
                        if dict.keys.contains("CnInfoUrl") && dict["CnInfoUrl"] != nil {
                            self.cnInfoUrl = dict["CnInfoUrl"] as! String
                        }
                        if dict.keys.contains("ContactAddress") && dict["ContactAddress"] != nil {
                            self.contactAddress = dict["ContactAddress"] as! String
                        }
                        if dict.keys.contains("ContactEmail") && dict["ContactEmail"] != nil {
                            self.contactEmail = dict["ContactEmail"] as! String
                        }
                        if dict.keys.contains("ContactZipCode") && dict["ContactZipCode"] != nil {
                            self.contactZipCode = dict["ContactZipCode"] as! String
                        }
                        if dict.keys.contains("Country") && dict["Country"] != nil {
                            self.country = dict["Country"] as! String
                        }
                        if dict.keys.contains("EAddress") && dict["EAddress"] != nil {
                            self.EAddress = dict["EAddress"] as! String
                        }
                        if dict.keys.contains("EName") && dict["EName"] != nil {
                            self.EName = dict["EName"] as! String
                        }
                        if dict.keys.contains("IdCardNumber") && dict["IdCardNumber"] != nil {
                            self.idCardNumber = dict["IdCardNumber"] as! String
                        }
                        if dict.keys.contains("IdCardUrl") && dict["IdCardUrl"] != nil {
                            self.idCardUrl = dict["IdCardUrl"] as! String
                        }
                        if dict.keys.contains("LoaKey") && dict["LoaKey"] != nil {
                            self.loaKey = dict["LoaKey"] as! String
                        }
                        if dict.keys.contains("LoaUrl") && dict["LoaUrl"] != nil {
                            self.loaUrl = dict["LoaUrl"] as! String
                        }
                        if dict.keys.contains("Name") && dict["Name"] != nil {
                            self.name = dict["Name"] as! String
                        }
                        if dict.keys.contains("PassportUrl") && dict["PassportUrl"] != nil {
                            self.passportUrl = dict["PassportUrl"] as! String
                        }
                        if dict.keys.contains("PersonalType") && dict["PersonalType"] != nil {
                            self.personalType = dict["PersonalType"] as! Int32
                        }
                        if dict.keys.contains("PostCode") && dict["PostCode"] != nil {
                            self.postCode = dict["PostCode"] as! String
                        }
                        if dict.keys.contains("Province") && dict["Province"] != nil {
                            self.province = dict["Province"] as! String
                        }
                        if dict.keys.contains("ReasonFileOssKey") && dict["ReasonFileOssKey"] != nil {
                            self.reasonFileOssKey = dict["ReasonFileOssKey"] as! String
                        }
                        if dict.keys.contains("Region") && dict["Region"] != nil {
                            self.region = dict["Region"] as! Int32
                        }
                        if dict.keys.contains("Type") && dict["Type"] != nil {
                            self.type = dict["Type"] as! Int32
                        }
                    }
                }
                public class RootCode : Tea.TeaModel {
                    public var classificationCode: String?

                    public var classificationName: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.classificationCode != nil {
                            map["ClassificationCode"] = self.classificationCode!
                        }
                        if self.classificationName != nil {
                            map["ClassificationName"] = self.classificationName!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ClassificationCode") && dict["ClassificationCode"] != nil {
                            self.classificationCode = dict["ClassificationCode"] as! String
                        }
                        if dict.keys.contains("ClassificationName") && dict["ClassificationName"] != nil {
                            self.classificationName = dict["ClassificationName"] as! String
                        }
                    }
                }
                public var bitFlag: Int32?

                public var bizId: String?

                public var bizType: String?

                public var extendInfo: [String: Any]?

                public var grayIconUrl: String?

                public var icon: String?

                public var leafCodes: QueryTrademarkModelListResponseBody.Moudle.Data.Item.LeafCodes?

                public var materialInfo: QueryTrademarkModelListResponseBody.Moudle.Data.Item.MaterialInfo?

                public var orderId: String?

                public var partnerCode: String?

                public var principalKey: String?

                public var principalName: String?

                public var produceType: String?

                public var rootCode: QueryTrademarkModelListResponseBody.Moudle.Data.Item.RootCode?

                public var status: String?

                public var statusStr: String?

                public var submitAuditTimeStr: String?

                public var submitAuditTimeValue: Int64?

                public var submitStatus: String?

                public var submitTimeStr: String?

                public var submitTimeValue: Int64?

                public var submitTimes: Int32?

                public var trademarkName: String?

                public var trademarkNameType: Int32?

                public var trademarkNumber: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.leafCodes?.validate()
                    try self.materialInfo?.validate()
                    try self.rootCode?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitFlag != nil {
                        map["BitFlag"] = self.bitFlag!
                    }
                    if self.bizId != nil {
                        map["BizId"] = self.bizId!
                    }
                    if self.bizType != nil {
                        map["BizType"] = self.bizType!
                    }
                    if self.extendInfo != nil {
                        map["ExtendInfo"] = self.extendInfo!
                    }
                    if self.grayIconUrl != nil {
                        map["GrayIconUrl"] = self.grayIconUrl!
                    }
                    if self.icon != nil {
                        map["Icon"] = self.icon!
                    }
                    if self.leafCodes != nil {
                        map["LeafCodes"] = self.leafCodes?.toMap()
                    }
                    if self.materialInfo != nil {
                        map["MaterialInfo"] = self.materialInfo?.toMap()
                    }
                    if self.orderId != nil {
                        map["OrderId"] = self.orderId!
                    }
                    if self.partnerCode != nil {
                        map["PartnerCode"] = self.partnerCode!
                    }
                    if self.principalKey != nil {
                        map["PrincipalKey"] = self.principalKey!
                    }
                    if self.principalName != nil {
                        map["PrincipalName"] = self.principalName!
                    }
                    if self.produceType != nil {
                        map["ProduceType"] = self.produceType!
                    }
                    if self.rootCode != nil {
                        map["RootCode"] = self.rootCode?.toMap()
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    if self.statusStr != nil {
                        map["StatusStr"] = self.statusStr!
                    }
                    if self.submitAuditTimeStr != nil {
                        map["SubmitAuditTimeStr"] = self.submitAuditTimeStr!
                    }
                    if self.submitAuditTimeValue != nil {
                        map["SubmitAuditTimeValue"] = self.submitAuditTimeValue!
                    }
                    if self.submitStatus != nil {
                        map["SubmitStatus"] = self.submitStatus!
                    }
                    if self.submitTimeStr != nil {
                        map["SubmitTimeStr"] = self.submitTimeStr!
                    }
                    if self.submitTimeValue != nil {
                        map["SubmitTimeValue"] = self.submitTimeValue!
                    }
                    if self.submitTimes != nil {
                        map["SubmitTimes"] = self.submitTimes!
                    }
                    if self.trademarkName != nil {
                        map["TrademarkName"] = self.trademarkName!
                    }
                    if self.trademarkNameType != nil {
                        map["TrademarkNameType"] = self.trademarkNameType!
                    }
                    if self.trademarkNumber != nil {
                        map["TrademarkNumber"] = self.trademarkNumber!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("BitFlag") && dict["BitFlag"] != nil {
                        self.bitFlag = dict["BitFlag"] as! Int32
                    }
                    if dict.keys.contains("BizId") && dict["BizId"] != nil {
                        self.bizId = dict["BizId"] as! String
                    }
                    if dict.keys.contains("BizType") && dict["BizType"] != nil {
                        self.bizType = dict["BizType"] as! String
                    }
                    if dict.keys.contains("ExtendInfo") && dict["ExtendInfo"] != nil {
                        self.extendInfo = dict["ExtendInfo"] as! [String: Any]
                    }
                    if dict.keys.contains("GrayIconUrl") && dict["GrayIconUrl"] != nil {
                        self.grayIconUrl = dict["GrayIconUrl"] as! String
                    }
                    if dict.keys.contains("Icon") && dict["Icon"] != nil {
                        self.icon = dict["Icon"] as! String
                    }
                    if dict.keys.contains("LeafCodes") && dict["LeafCodes"] != nil {
                        var model = QueryTrademarkModelListResponseBody.Moudle.Data.Item.LeafCodes()
                        model.fromMap(dict["LeafCodes"] as! [String: Any])
                        self.leafCodes = model
                    }
                    if dict.keys.contains("MaterialInfo") && dict["MaterialInfo"] != nil {
                        var model = QueryTrademarkModelListResponseBody.Moudle.Data.Item.MaterialInfo()
                        model.fromMap(dict["MaterialInfo"] as! [String: Any])
                        self.materialInfo = model
                    }
                    if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
                        self.orderId = dict["OrderId"] as! String
                    }
                    if dict.keys.contains("PartnerCode") && dict["PartnerCode"] != nil {
                        self.partnerCode = dict["PartnerCode"] as! String
                    }
                    if dict.keys.contains("PrincipalKey") && dict["PrincipalKey"] != nil {
                        self.principalKey = dict["PrincipalKey"] as! String
                    }
                    if dict.keys.contains("PrincipalName") && dict["PrincipalName"] != nil {
                        self.principalName = dict["PrincipalName"] as! String
                    }
                    if dict.keys.contains("ProduceType") && dict["ProduceType"] != nil {
                        self.produceType = dict["ProduceType"] as! String
                    }
                    if dict.keys.contains("RootCode") && dict["RootCode"] != nil {
                        var model = QueryTrademarkModelListResponseBody.Moudle.Data.Item.RootCode()
                        model.fromMap(dict["RootCode"] as! [String: Any])
                        self.rootCode = model
                    }
                    if dict.keys.contains("Status") && dict["Status"] != nil {
                        self.status = dict["Status"] as! String
                    }
                    if dict.keys.contains("StatusStr") && dict["StatusStr"] != nil {
                        self.statusStr = dict["StatusStr"] as! String
                    }
                    if dict.keys.contains("SubmitAuditTimeStr") && dict["SubmitAuditTimeStr"] != nil {
                        self.submitAuditTimeStr = dict["SubmitAuditTimeStr"] as! String
                    }
                    if dict.keys.contains("SubmitAuditTimeValue") && dict["SubmitAuditTimeValue"] != nil {
                        self.submitAuditTimeValue = dict["SubmitAuditTimeValue"] as! Int64
                    }
                    if dict.keys.contains("SubmitStatus") && dict["SubmitStatus"] != nil {
                        self.submitStatus = dict["SubmitStatus"] as! String
                    }
                    if dict.keys.contains("SubmitTimeStr") && dict["SubmitTimeStr"] != nil {
                        self.submitTimeStr = dict["SubmitTimeStr"] as! String
                    }
                    if dict.keys.contains("SubmitTimeValue") && dict["SubmitTimeValue"] != nil {
                        self.submitTimeValue = dict["SubmitTimeValue"] as! Int64
                    }
                    if dict.keys.contains("SubmitTimes") && dict["SubmitTimes"] != nil {
                        self.submitTimes = dict["SubmitTimes"] as! Int32
                    }
                    if dict.keys.contains("TrademarkName") && dict["TrademarkName"] != nil {
                        self.trademarkName = dict["TrademarkName"] as! String
                    }
                    if dict.keys.contains("TrademarkNameType") && dict["TrademarkNameType"] != nil {
                        self.trademarkNameType = dict["TrademarkNameType"] as! Int32
                    }
                    if dict.keys.contains("TrademarkNumber") && dict["TrademarkNumber"] != nil {
                        self.trademarkNumber = dict["TrademarkNumber"] as! String
                    }
                }
            }
            public var item: [QueryTrademarkModelListResponseBody.Moudle.Data.Item]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.item != nil {
                    var tmp : [Any] = []
                    for k in self.item! {
                        tmp.append(k.toMap())
                    }
                    map["item"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("item") && dict["item"] != nil {
                    var tmp : [QueryTrademarkModelListResponseBody.Moudle.Data.Item] = []
                    for v in dict["item"] as! [Any] {
                        var model = QueryTrademarkModelListResponseBody.Moudle.Data.Item()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.item = tmp
                }
            }
        }
        public var data: QueryTrademarkModelListResponseBody.Moudle.Data?

        public var requestId: String?

        public var totalPageNum: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.data?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.data != nil {
                map["Data"] = self.data?.toMap()
            }
            if self.requestId != nil {
                map["RequestId"] = self.requestId!
            }
            if self.totalPageNum != nil {
                map["TotalPageNum"] = self.totalPageNum!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Data") && dict["Data"] != nil {
                var model = QueryTrademarkModelListResponseBody.Moudle.Data()
                model.fromMap(dict["Data"] as! [String: Any])
                self.data = model
            }
            if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
                self.requestId = dict["RequestId"] as! String
            }
            if dict.keys.contains("TotalPageNum") && dict["TotalPageNum"] != nil {
                self.totalPageNum = dict["TotalPageNum"] as! Int32
            }
        }
    }
    public var moudle: QueryTrademarkModelListResponseBody.Moudle?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.moudle?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.moudle != nil {
            map["Moudle"] = self.moudle?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Moudle") && dict["Moudle"] != nil {
            var model = QueryTrademarkModelListResponseBody.Moudle()
            model.fromMap(dict["Moudle"] as! [String: Any])
            self.moudle = model
        }
    }
}

public class QueryTrademarkModelListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryTrademarkModelListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryTrademarkModelListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryTrademarkMonitorResultsRequest : Tea.TeaModel {
    public var actionType: Int32?

    public var applyYear: String?

    public var classification: String?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var procedureStatus: Int32?

    public var registrationNumber: String?

    public var ruleId: Int64?

    public var tmName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.actionType != nil {
            map["ActionType"] = self.actionType!
        }
        if self.applyYear != nil {
            map["ApplyYear"] = self.applyYear!
        }
        if self.classification != nil {
            map["Classification"] = self.classification!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.procedureStatus != nil {
            map["ProcedureStatus"] = self.procedureStatus!
        }
        if self.registrationNumber != nil {
            map["RegistrationNumber"] = self.registrationNumber!
        }
        if self.ruleId != nil {
            map["RuleId"] = self.ruleId!
        }
        if self.tmName != nil {
            map["TmName"] = self.tmName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ActionType") && dict["ActionType"] != nil {
            self.actionType = dict["ActionType"] as! Int32
        }
        if dict.keys.contains("ApplyYear") && dict["ApplyYear"] != nil {
            self.applyYear = dict["ApplyYear"] as! String
        }
        if dict.keys.contains("Classification") && dict["Classification"] != nil {
            self.classification = dict["Classification"] as! String
        }
        if dict.keys.contains("PageNum") && dict["PageNum"] != nil {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ProcedureStatus") && dict["ProcedureStatus"] != nil {
            self.procedureStatus = dict["ProcedureStatus"] as! Int32
        }
        if dict.keys.contains("RegistrationNumber") && dict["RegistrationNumber"] != nil {
            self.registrationNumber = dict["RegistrationNumber"] as! String
        }
        if dict.keys.contains("RuleId") && dict["RuleId"] != nil {
            self.ruleId = dict["RuleId"] as! Int64
        }
        if dict.keys.contains("TmName") && dict["TmName"] != nil {
            self.tmName = dict["TmName"] as! String
        }
    }
}

public class QueryTrademarkMonitorResultsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class TmMonitorResult : Tea.TeaModel {
            public var applyDate: String?

            public var chesanEndDate: String?

            public var classification: String?

            public var dataCreateTime: Int64?

            public var dataUpdateTime: Int64?

            public var ownerEnName: String?

            public var ownerName: String?

            public var registrationNumber: String?

            public var ruleId: String?

            public var tmImage: String?

            public var tmName: String?

            public var tmProcedureStatusDesc: String?

            public var tmUid: String?

            public var userId: String?

            public var wuxiaoEndDate: String?

            public var xuzhanEndDate: String?

            public var yiyiEndDate: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.applyDate != nil {
                    map["ApplyDate"] = self.applyDate!
                }
                if self.chesanEndDate != nil {
                    map["ChesanEndDate"] = self.chesanEndDate!
                }
                if self.classification != nil {
                    map["Classification"] = self.classification!
                }
                if self.dataCreateTime != nil {
                    map["DataCreateTime"] = self.dataCreateTime!
                }
                if self.dataUpdateTime != nil {
                    map["DataUpdateTime"] = self.dataUpdateTime!
                }
                if self.ownerEnName != nil {
                    map["OwnerEnName"] = self.ownerEnName!
                }
                if self.ownerName != nil {
                    map["OwnerName"] = self.ownerName!
                }
                if self.registrationNumber != nil {
                    map["RegistrationNumber"] = self.registrationNumber!
                }
                if self.ruleId != nil {
                    map["RuleId"] = self.ruleId!
                }
                if self.tmImage != nil {
                    map["TmImage"] = self.tmImage!
                }
                if self.tmName != nil {
                    map["TmName"] = self.tmName!
                }
                if self.tmProcedureStatusDesc != nil {
                    map["TmProcedureStatusDesc"] = self.tmProcedureStatusDesc!
                }
                if self.tmUid != nil {
                    map["TmUid"] = self.tmUid!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.wuxiaoEndDate != nil {
                    map["WuxiaoEndDate"] = self.wuxiaoEndDate!
                }
                if self.xuzhanEndDate != nil {
                    map["XuzhanEndDate"] = self.xuzhanEndDate!
                }
                if self.yiyiEndDate != nil {
                    map["YiyiEndDate"] = self.yiyiEndDate!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ApplyDate") && dict["ApplyDate"] != nil {
                    self.applyDate = dict["ApplyDate"] as! String
                }
                if dict.keys.contains("ChesanEndDate") && dict["ChesanEndDate"] != nil {
                    self.chesanEndDate = dict["ChesanEndDate"] as! String
                }
                if dict.keys.contains("Classification") && dict["Classification"] != nil {
                    self.classification = dict["Classification"] as! String
                }
                if dict.keys.contains("DataCreateTime") && dict["DataCreateTime"] != nil {
                    self.dataCreateTime = dict["DataCreateTime"] as! Int64
                }
                if dict.keys.contains("DataUpdateTime") && dict["DataUpdateTime"] != nil {
                    self.dataUpdateTime = dict["DataUpdateTime"] as! Int64
                }
                if dict.keys.contains("OwnerEnName") && dict["OwnerEnName"] != nil {
                    self.ownerEnName = dict["OwnerEnName"] as! String
                }
                if dict.keys.contains("OwnerName") && dict["OwnerName"] != nil {
                    self.ownerName = dict["OwnerName"] as! String
                }
                if dict.keys.contains("RegistrationNumber") && dict["RegistrationNumber"] != nil {
                    self.registrationNumber = dict["RegistrationNumber"] as! String
                }
                if dict.keys.contains("RuleId") && dict["RuleId"] != nil {
                    self.ruleId = dict["RuleId"] as! String
                }
                if dict.keys.contains("TmImage") && dict["TmImage"] != nil {
                    self.tmImage = dict["TmImage"] as! String
                }
                if dict.keys.contains("TmName") && dict["TmName"] != nil {
                    self.tmName = dict["TmName"] as! String
                }
                if dict.keys.contains("TmProcedureStatusDesc") && dict["TmProcedureStatusDesc"] != nil {
                    self.tmProcedureStatusDesc = dict["TmProcedureStatusDesc"] as! String
                }
                if dict.keys.contains("TmUid") && dict["TmUid"] != nil {
                    self.tmUid = dict["TmUid"] as! String
                }
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("WuxiaoEndDate") && dict["WuxiaoEndDate"] != nil {
                    self.wuxiaoEndDate = dict["WuxiaoEndDate"] as! String
                }
                if dict.keys.contains("XuzhanEndDate") && dict["XuzhanEndDate"] != nil {
                    self.xuzhanEndDate = dict["XuzhanEndDate"] as! String
                }
                if dict.keys.contains("YiyiEndDate") && dict["YiyiEndDate"] != nil {
                    self.yiyiEndDate = dict["YiyiEndDate"] as! String
                }
            }
        }
        public var tmMonitorResult: [QueryTrademarkMonitorResultsResponseBody.Data.TmMonitorResult]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tmMonitorResult != nil {
                var tmp : [Any] = []
                for k in self.tmMonitorResult! {
                    tmp.append(k.toMap())
                }
                map["TmMonitorResult"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TmMonitorResult") && dict["TmMonitorResult"] != nil {
                var tmp : [QueryTrademarkMonitorResultsResponseBody.Data.TmMonitorResult] = []
                for v in dict["TmMonitorResult"] as! [Any] {
                    var model = QueryTrademarkMonitorResultsResponseBody.Data.TmMonitorResult()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tmMonitorResult = tmp
            }
        }
    }
    public var currentPageNum: Int32?

    public var data: QueryTrademarkMonitorResultsResponseBody.Data?

    public var nextPage: Bool?

    public var pageSize: Int32?

    public var prePage: Bool?

    public var requestId: String?

    public var totalItemNum: Int32?

    public var totalPageNum: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPageNum != nil {
            map["CurrentPageNum"] = self.currentPageNum!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.nextPage != nil {
            map["NextPage"] = self.nextPage!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.prePage != nil {
            map["PrePage"] = self.prePage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalItemNum != nil {
            map["TotalItemNum"] = self.totalItemNum!
        }
        if self.totalPageNum != nil {
            map["TotalPageNum"] = self.totalPageNum!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPageNum") && dict["CurrentPageNum"] != nil {
            self.currentPageNum = dict["CurrentPageNum"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = QueryTrademarkMonitorResultsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("NextPage") && dict["NextPage"] != nil {
            self.nextPage = dict["NextPage"] as! Bool
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("PrePage") && dict["PrePage"] != nil {
            self.prePage = dict["PrePage"] as! Bool
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalItemNum") && dict["TotalItemNum"] != nil {
            self.totalItemNum = dict["TotalItemNum"] as! Int32
        }
        if dict.keys.contains("TotalPageNum") && dict["TotalPageNum"] != nil {
            self.totalPageNum = dict["TotalPageNum"] as! Int32
        }
    }
}

public class QueryTrademarkMonitorResultsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryTrademarkMonitorResultsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryTrademarkMonitorResultsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryTrademarkMonitorRulesRequest : Tea.TeaModel {
    public var id: String?

    public var notifyUpdate: Int32?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var ruleName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.notifyUpdate != nil {
            map["NotifyUpdate"] = self.notifyUpdate!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.ruleName != nil {
            map["RuleName"] = self.ruleName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("NotifyUpdate") && dict["NotifyUpdate"] != nil {
            self.notifyUpdate = dict["NotifyUpdate"] as! Int32
        }
        if dict.keys.contains("PageNum") && dict["PageNum"] != nil {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RuleName") && dict["RuleName"] != nil {
            self.ruleName = dict["RuleName"] as! String
        }
    }
}

public class QueryTrademarkMonitorRulesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class TmMonitorRule : Tea.TeaModel {
            public var createTime: String?

            public var endTime: String?

            public var env: String?

            public var id: String?

            public var lastFinishTime: String?

            public var lastRunTime: String?

            public var lastUpdateTime: String?

            public var notifyUpdate: Int32?

            public var ruleDetail: String?

            public var ruleExtend: String?

            public var ruleKeyword: String?

            public var ruleName: String?

            public var ruleSource: String?

            public var ruleStatus: String?

            public var ruleType: Int32?

            public var startTime: String?

            public var updateTime: String?

            public var userId: String?

            public var version: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.env != nil {
                    map["Env"] = self.env!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.lastFinishTime != nil {
                    map["LastFinishTime"] = self.lastFinishTime!
                }
                if self.lastRunTime != nil {
                    map["LastRunTime"] = self.lastRunTime!
                }
                if self.lastUpdateTime != nil {
                    map["LastUpdateTime"] = self.lastUpdateTime!
                }
                if self.notifyUpdate != nil {
                    map["NotifyUpdate"] = self.notifyUpdate!
                }
                if self.ruleDetail != nil {
                    map["RuleDetail"] = self.ruleDetail!
                }
                if self.ruleExtend != nil {
                    map["RuleExtend"] = self.ruleExtend!
                }
                if self.ruleKeyword != nil {
                    map["RuleKeyword"] = self.ruleKeyword!
                }
                if self.ruleName != nil {
                    map["RuleName"] = self.ruleName!
                }
                if self.ruleSource != nil {
                    map["RuleSource"] = self.ruleSource!
                }
                if self.ruleStatus != nil {
                    map["RuleStatus"] = self.ruleStatus!
                }
                if self.ruleType != nil {
                    map["RuleType"] = self.ruleType!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.version != nil {
                    map["Version"] = self.version!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
                    self.endTime = dict["EndTime"] as! String
                }
                if dict.keys.contains("Env") && dict["Env"] != nil {
                    self.env = dict["Env"] as! String
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("LastFinishTime") && dict["LastFinishTime"] != nil {
                    self.lastFinishTime = dict["LastFinishTime"] as! String
                }
                if dict.keys.contains("LastRunTime") && dict["LastRunTime"] != nil {
                    self.lastRunTime = dict["LastRunTime"] as! String
                }
                if dict.keys.contains("LastUpdateTime") && dict["LastUpdateTime"] != nil {
                    self.lastUpdateTime = dict["LastUpdateTime"] as! String
                }
                if dict.keys.contains("NotifyUpdate") && dict["NotifyUpdate"] != nil {
                    self.notifyUpdate = dict["NotifyUpdate"] as! Int32
                }
                if dict.keys.contains("RuleDetail") && dict["RuleDetail"] != nil {
                    self.ruleDetail = dict["RuleDetail"] as! String
                }
                if dict.keys.contains("RuleExtend") && dict["RuleExtend"] != nil {
                    self.ruleExtend = dict["RuleExtend"] as! String
                }
                if dict.keys.contains("RuleKeyword") && dict["RuleKeyword"] != nil {
                    self.ruleKeyword = dict["RuleKeyword"] as! String
                }
                if dict.keys.contains("RuleName") && dict["RuleName"] != nil {
                    self.ruleName = dict["RuleName"] as! String
                }
                if dict.keys.contains("RuleSource") && dict["RuleSource"] != nil {
                    self.ruleSource = dict["RuleSource"] as! String
                }
                if dict.keys.contains("RuleStatus") && dict["RuleStatus"] != nil {
                    self.ruleStatus = dict["RuleStatus"] as! String
                }
                if dict.keys.contains("RuleType") && dict["RuleType"] != nil {
                    self.ruleType = dict["RuleType"] as! Int32
                }
                if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
                    self.startTime = dict["StartTime"] as! String
                }
                if dict.keys.contains("UpdateTime") && dict["UpdateTime"] != nil {
                    self.updateTime = dict["UpdateTime"] as! String
                }
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("Version") && dict["Version"] != nil {
                    self.version = dict["Version"] as! Int32
                }
            }
        }
        public var tmMonitorRule: [QueryTrademarkMonitorRulesResponseBody.Data.TmMonitorRule]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tmMonitorRule != nil {
                var tmp : [Any] = []
                for k in self.tmMonitorRule! {
                    tmp.append(k.toMap())
                }
                map["TmMonitorRule"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TmMonitorRule") && dict["TmMonitorRule"] != nil {
                var tmp : [QueryTrademarkMonitorRulesResponseBody.Data.TmMonitorRule] = []
                for v in dict["TmMonitorRule"] as! [Any] {
                    var model = QueryTrademarkMonitorRulesResponseBody.Data.TmMonitorRule()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tmMonitorRule = tmp
            }
        }
    }
    public var currentPageNum: Int32?

    public var data: QueryTrademarkMonitorRulesResponseBody.Data?

    public var nextPage: Bool?

    public var pageSize: Int32?

    public var prePage: Bool?

    public var requestId: String?

    public var totalItemNum: Int32?

    public var totalPageNum: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPageNum != nil {
            map["CurrentPageNum"] = self.currentPageNum!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.nextPage != nil {
            map["NextPage"] = self.nextPage!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.prePage != nil {
            map["PrePage"] = self.prePage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalItemNum != nil {
            map["TotalItemNum"] = self.totalItemNum!
        }
        if self.totalPageNum != nil {
            map["TotalPageNum"] = self.totalPageNum!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPageNum") && dict["CurrentPageNum"] != nil {
            self.currentPageNum = dict["CurrentPageNum"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = QueryTrademarkMonitorRulesResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("NextPage") && dict["NextPage"] != nil {
            self.nextPage = dict["NextPage"] as! Bool
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("PrePage") && dict["PrePage"] != nil {
            self.prePage = dict["PrePage"] as! Bool
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalItemNum") && dict["TotalItemNum"] != nil {
            self.totalItemNum = dict["TotalItemNum"] as! Int32
        }
        if dict.keys.contains("TotalPageNum") && dict["TotalPageNum"] != nil {
            self.totalPageNum = dict["TotalPageNum"] as! Int32
        }
    }
}

public class QueryTrademarkMonitorRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryTrademarkMonitorRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryTrademarkMonitorRulesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryTrademarkOnSaleRequest : Tea.TeaModel {
    public var classification: String?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var registerCode: String?

    public var registerNumber: String?

    public var tmType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.classification != nil {
            map["Classification"] = self.classification!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.registerCode != nil {
            map["RegisterCode"] = self.registerCode!
        }
        if self.registerNumber != nil {
            map["RegisterNumber"] = self.registerNumber!
        }
        if self.tmType != nil {
            map["TmType"] = self.tmType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Classification") && dict["Classification"] != nil {
            self.classification = dict["Classification"] as! String
        }
        if dict.keys.contains("PageNum") && dict["PageNum"] != nil {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegisterCode") && dict["RegisterCode"] != nil {
            self.registerCode = dict["RegisterCode"] as! String
        }
        if dict.keys.contains("RegisterNumber") && dict["RegisterNumber"] != nil {
            self.registerNumber = dict["RegisterNumber"] as! String
        }
        if dict.keys.contains("TmType") && dict["TmType"] != nil {
            self.tmType = dict["TmType"] as! String
        }
    }
}

public class QueryTrademarkOnSaleResponseBody : Tea.TeaModel {
    public class Trademarks : Tea.TeaModel {
        public var auditResult: String?

        public var classification: String?

        public var icon: String?

        public var orderPrice: String?

        public var registrationNumber: String?

        public var status: Int64?

        public var tmType: String?

        public var trademarkName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.auditResult != nil {
                map["AuditResult"] = self.auditResult!
            }
            if self.classification != nil {
                map["Classification"] = self.classification!
            }
            if self.icon != nil {
                map["Icon"] = self.icon!
            }
            if self.orderPrice != nil {
                map["OrderPrice"] = self.orderPrice!
            }
            if self.registrationNumber != nil {
                map["RegistrationNumber"] = self.registrationNumber!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.tmType != nil {
                map["TmType"] = self.tmType!
            }
            if self.trademarkName != nil {
                map["TrademarkName"] = self.trademarkName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AuditResult") && dict["AuditResult"] != nil {
                self.auditResult = dict["AuditResult"] as! String
            }
            if dict.keys.contains("Classification") && dict["Classification"] != nil {
                self.classification = dict["Classification"] as! String
            }
            if dict.keys.contains("Icon") && dict["Icon"] != nil {
                self.icon = dict["Icon"] as! String
            }
            if dict.keys.contains("OrderPrice") && dict["OrderPrice"] != nil {
                self.orderPrice = dict["OrderPrice"] as! String
            }
            if dict.keys.contains("RegistrationNumber") && dict["RegistrationNumber"] != nil {
                self.registrationNumber = dict["RegistrationNumber"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! Int64
            }
            if dict.keys.contains("TmType") && dict["TmType"] != nil {
                self.tmType = dict["TmType"] as! String
            }
            if dict.keys.contains("TrademarkName") && dict["TrademarkName"] != nil {
                self.trademarkName = dict["TrademarkName"] as! String
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public var totalPageNumber: Int32?

    public var trademarks: [QueryTrademarkOnSaleResponseBody.Trademarks]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.totalPageNumber != nil {
            map["TotalPageNumber"] = self.totalPageNumber!
        }
        if self.trademarks != nil {
            var tmp : [Any] = []
            for k in self.trademarks! {
                tmp.append(k.toMap())
            }
            map["Trademarks"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
        if dict.keys.contains("TotalPageNumber") && dict["TotalPageNumber"] != nil {
            self.totalPageNumber = dict["TotalPageNumber"] as! Int32
        }
        if dict.keys.contains("Trademarks") && dict["Trademarks"] != nil {
            var tmp : [QueryTrademarkOnSaleResponseBody.Trademarks] = []
            for v in dict["Trademarks"] as! [Any] {
                var model = QueryTrademarkOnSaleResponseBody.Trademarks()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.trademarks = tmp
        }
    }
}

public class QueryTrademarkOnSaleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryTrademarkOnSaleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryTrademarkOnSaleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryTrademarkPriceRequest : Tea.TeaModel {
    public var orderData: [String: Any]?

    public var tmIcon: String?

    public var tmName: String?

    public var type: Int32?

    public var userId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderData != nil {
            map["OrderData"] = self.orderData!
        }
        if self.tmIcon != nil {
            map["TmIcon"] = self.tmIcon!
        }
        if self.tmName != nil {
            map["TmName"] = self.tmName!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderData") && dict["OrderData"] != nil {
            self.orderData = dict["OrderData"] as! [String: Any]
        }
        if dict.keys.contains("TmIcon") && dict["TmIcon"] != nil {
            self.tmIcon = dict["TmIcon"] as! String
        }
        if dict.keys.contains("TmName") && dict["TmName"] != nil {
            self.tmName = dict["TmName"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! Int32
        }
        if dict.keys.contains("UserId") && dict["UserId"] != nil {
            self.userId = dict["UserId"] as! Int64
        }
    }
}

public class QueryTrademarkPriceShrinkRequest : Tea.TeaModel {
    public var orderDataShrink: String?

    public var tmIcon: String?

    public var tmName: String?

    public var type: Int32?

    public var userId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderDataShrink != nil {
            map["OrderData"] = self.orderDataShrink!
        }
        if self.tmIcon != nil {
            map["TmIcon"] = self.tmIcon!
        }
        if self.tmName != nil {
            map["TmName"] = self.tmName!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderData") && dict["OrderData"] != nil {
            self.orderDataShrink = dict["OrderData"] as! String
        }
        if dict.keys.contains("TmIcon") && dict["TmIcon"] != nil {
            self.tmIcon = dict["TmIcon"] as! String
        }
        if dict.keys.contains("TmName") && dict["TmName"] != nil {
            self.tmName = dict["TmName"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! Int32
        }
        if dict.keys.contains("UserId") && dict["UserId"] != nil {
            self.userId = dict["UserId"] as! Int64
        }
    }
}

public class QueryTrademarkPriceResponseBody : Tea.TeaModel {
    public class Prices : Tea.TeaModel {
        public class Prices : Tea.TeaModel {
            public var classificationCode: String?

            public var currency: String?

            public var discountPrice: Double?

            public var originalPrice: Double?

            public var tradePrice: Double?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.classificationCode != nil {
                    map["ClassificationCode"] = self.classificationCode!
                }
                if self.currency != nil {
                    map["Currency"] = self.currency!
                }
                if self.discountPrice != nil {
                    map["DiscountPrice"] = self.discountPrice!
                }
                if self.originalPrice != nil {
                    map["OriginalPrice"] = self.originalPrice!
                }
                if self.tradePrice != nil {
                    map["TradePrice"] = self.tradePrice!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ClassificationCode") && dict["ClassificationCode"] != nil {
                    self.classificationCode = dict["ClassificationCode"] as! String
                }
                if dict.keys.contains("Currency") && dict["Currency"] != nil {
                    self.currency = dict["Currency"] as! String
                }
                if dict.keys.contains("DiscountPrice") && dict["DiscountPrice"] != nil {
                    self.discountPrice = dict["DiscountPrice"] as! Double
                }
                if dict.keys.contains("OriginalPrice") && dict["OriginalPrice"] != nil {
                    self.originalPrice = dict["OriginalPrice"] as! Double
                }
                if dict.keys.contains("TradePrice") && dict["TradePrice"] != nil {
                    self.tradePrice = dict["TradePrice"] as! Double
                }
            }
        }
        public var prices: [QueryTrademarkPriceResponseBody.Prices.Prices]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.prices != nil {
                var tmp : [Any] = []
                for k in self.prices! {
                    tmp.append(k.toMap())
                }
                map["Prices"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Prices") && dict["Prices"] != nil {
                var tmp : [QueryTrademarkPriceResponseBody.Prices.Prices] = []
                for v in dict["Prices"] as! [Any] {
                    var model = QueryTrademarkPriceResponseBody.Prices.Prices()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.prices = tmp
            }
        }
    }
    public var currency: String?

    public var discountPrice: Double?

    public var originalPrice: Double?

    public var prices: QueryTrademarkPriceResponseBody.Prices?

    public var requestId: String?

    public var tradePrice: Double?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.prices?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currency != nil {
            map["Currency"] = self.currency!
        }
        if self.discountPrice != nil {
            map["DiscountPrice"] = self.discountPrice!
        }
        if self.originalPrice != nil {
            map["OriginalPrice"] = self.originalPrice!
        }
        if self.prices != nil {
            map["Prices"] = self.prices?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.tradePrice != nil {
            map["TradePrice"] = self.tradePrice!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Currency") && dict["Currency"] != nil {
            self.currency = dict["Currency"] as! String
        }
        if dict.keys.contains("DiscountPrice") && dict["DiscountPrice"] != nil {
            self.discountPrice = dict["DiscountPrice"] as! Double
        }
        if dict.keys.contains("OriginalPrice") && dict["OriginalPrice"] != nil {
            self.originalPrice = dict["OriginalPrice"] as! Double
        }
        if dict.keys.contains("Prices") && dict["Prices"] != nil {
            var model = QueryTrademarkPriceResponseBody.Prices()
            model.fromMap(dict["Prices"] as! [String: Any])
            self.prices = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TradePrice") && dict["TradePrice"] != nil {
            self.tradePrice = dict["TradePrice"] as! Double
        }
    }
}

public class QueryTrademarkPriceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryTrademarkPriceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryTrademarkPriceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryTrademarkUploadAuditResultRequest : Tea.TeaModel {
    public var classification: String?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var registerCode: String?

    public var registerNumber: String?

    public var tmType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.classification != nil {
            map["Classification"] = self.classification!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.registerCode != nil {
            map["RegisterCode"] = self.registerCode!
        }
        if self.registerNumber != nil {
            map["RegisterNumber"] = self.registerNumber!
        }
        if self.tmType != nil {
            map["TmType"] = self.tmType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Classification") && dict["Classification"] != nil {
            self.classification = dict["Classification"] as! String
        }
        if dict.keys.contains("PageNum") && dict["PageNum"] != nil {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegisterCode") && dict["RegisterCode"] != nil {
            self.registerCode = dict["RegisterCode"] as! String
        }
        if dict.keys.contains("RegisterNumber") && dict["RegisterNumber"] != nil {
            self.registerNumber = dict["RegisterNumber"] as! String
        }
        if dict.keys.contains("TmType") && dict["TmType"] != nil {
            self.tmType = dict["TmType"] as! String
        }
    }
}

public class QueryTrademarkUploadAuditResultResponseBody : Tea.TeaModel {
    public class Trademarks : Tea.TeaModel {
        public var auditResult: String?

        public var classification: String?

        public var icon: String?

        public var orderPrice: String?

        public var registrationNumber: String?

        public var status: Int64?

        public var tmType: String?

        public var trademarkName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.auditResult != nil {
                map["AuditResult"] = self.auditResult!
            }
            if self.classification != nil {
                map["Classification"] = self.classification!
            }
            if self.icon != nil {
                map["Icon"] = self.icon!
            }
            if self.orderPrice != nil {
                map["OrderPrice"] = self.orderPrice!
            }
            if self.registrationNumber != nil {
                map["RegistrationNumber"] = self.registrationNumber!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.tmType != nil {
                map["TmType"] = self.tmType!
            }
            if self.trademarkName != nil {
                map["TrademarkName"] = self.trademarkName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AuditResult") && dict["AuditResult"] != nil {
                self.auditResult = dict["AuditResult"] as! String
            }
            if dict.keys.contains("Classification") && dict["Classification"] != nil {
                self.classification = dict["Classification"] as! String
            }
            if dict.keys.contains("Icon") && dict["Icon"] != nil {
                self.icon = dict["Icon"] as! String
            }
            if dict.keys.contains("OrderPrice") && dict["OrderPrice"] != nil {
                self.orderPrice = dict["OrderPrice"] as! String
            }
            if dict.keys.contains("RegistrationNumber") && dict["RegistrationNumber"] != nil {
                self.registrationNumber = dict["RegistrationNumber"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! Int64
            }
            if dict.keys.contains("TmType") && dict["TmType"] != nil {
                self.tmType = dict["TmType"] as! String
            }
            if dict.keys.contains("TrademarkName") && dict["TrademarkName"] != nil {
                self.trademarkName = dict["TrademarkName"] as! String
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public var totalPageNumber: Int32?

    public var trademarks: [QueryTrademarkUploadAuditResultResponseBody.Trademarks]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.totalPageNumber != nil {
            map["TotalPageNumber"] = self.totalPageNumber!
        }
        if self.trademarks != nil {
            var tmp : [Any] = []
            for k in self.trademarks! {
                tmp.append(k.toMap())
            }
            map["Trademarks"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
        if dict.keys.contains("TotalPageNumber") && dict["TotalPageNumber"] != nil {
            self.totalPageNumber = dict["TotalPageNumber"] as! Int32
        }
        if dict.keys.contains("Trademarks") && dict["Trademarks"] != nil {
            var tmp : [QueryTrademarkUploadAuditResultResponseBody.Trademarks] = []
            for v in dict["Trademarks"] as! [Any] {
                var model = QueryTrademarkUploadAuditResultResponseBody.Trademarks()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.trademarks = tmp
        }
    }
}

public class QueryTrademarkUploadAuditResultResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryTrademarkUploadAuditResultResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryTrademarkUploadAuditResultResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RecordBankBalanceRequest : Tea.TeaModel {
    public var actionDate: Int64?

    public var balance: String?

    public var principalName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.actionDate != nil {
            map["ActionDate"] = self.actionDate!
        }
        if self.balance != nil {
            map["Balance"] = self.balance!
        }
        if self.principalName != nil {
            map["PrincipalName"] = self.principalName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ActionDate") && dict["ActionDate"] != nil {
            self.actionDate = dict["ActionDate"] as! Int64
        }
        if dict.keys.contains("Balance") && dict["Balance"] != nil {
            self.balance = dict["Balance"] as! String
        }
        if dict.keys.contains("PrincipalName") && dict["PrincipalName"] != nil {
            self.principalName = dict["PrincipalName"] as! String
        }
    }
}

public class RecordBankBalanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") && dict["Result"] != nil {
            self.result = dict["Result"] as! Bool
        }
    }
}

public class RecordBankBalanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RecordBankBalanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RecordBankBalanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RefundProduceRequest : Tea.TeaModel {
    public var bizId: String?

    public var refundType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.refundType != nil {
            map["RefundType"] = self.refundType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("RefundType") && dict["RefundType"] != nil {
            self.refundType = dict["RefundType"] as! String
        }
    }
}

public class RefundProduceResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMsg: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["ErrorMsg"] = self.errorMsg!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMsg") && dict["ErrorMsg"] != nil {
            self.errorMsg = dict["ErrorMsg"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class RefundProduceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RefundProduceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RefundProduceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RefuseAdditionalMaterialRequest : Tea.TeaModel {
    public var bizId: String?

    public var note: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.note != nil {
            map["Note"] = self.note!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("Note") && dict["Note"] != nil {
            self.note = dict["Note"] as! String
        }
    }
}

public class RefuseAdditionalMaterialResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMsg: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["ErrorMsg"] = self.errorMsg!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMsg") && dict["ErrorMsg"] != nil {
            self.errorMsg = dict["ErrorMsg"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class RefuseAdditionalMaterialResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RefuseAdditionalMaterialResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RefuseAdditionalMaterialResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RefuseApplicantRequest : Tea.TeaModel {
    public var bizId: String?

    public var note: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.note != nil {
            map["Note"] = self.note!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("Note") && dict["Note"] != nil {
            self.note = dict["Note"] as! String
        }
    }
}

public class RefuseApplicantResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMsg: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["ErrorMsg"] = self.errorMsg!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMsg") && dict["ErrorMsg"] != nil {
            self.errorMsg = dict["ErrorMsg"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class RefuseApplicantResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RefuseApplicantResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RefuseApplicantResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RejectApplicantRequest : Tea.TeaModel {
    public var instanceId: String?

    public var note: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.note != nil {
            map["Note"] = self.note!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Note") && dict["Note"] != nil {
            self.note = dict["Note"] as! String
        }
    }
}

public class RejectApplicantResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RejectApplicantResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RejectApplicantResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RejectApplicantResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SaveClassificationConditionsRequest : Tea.TeaModel {
    public var bizId: String?

    public var condition: String?

    public var type: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.condition != nil {
            map["Condition"] = self.condition!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("Condition") && dict["Condition"] != nil {
            self.condition = dict["Condition"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! Int32
        }
    }
}

public class SaveClassificationConditionsResponseBody : Tea.TeaModel {
    public class InvalidList : Tea.TeaModel {
        public var classificationCode: String?

        public var classificationName: String?

        public var officialCode: String?

        public var parentCode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.classificationCode != nil {
                map["ClassificationCode"] = self.classificationCode!
            }
            if self.classificationName != nil {
                map["ClassificationName"] = self.classificationName!
            }
            if self.officialCode != nil {
                map["OfficialCode"] = self.officialCode!
            }
            if self.parentCode != nil {
                map["ParentCode"] = self.parentCode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClassificationCode") && dict["ClassificationCode"] != nil {
                self.classificationCode = dict["ClassificationCode"] as! String
            }
            if dict.keys.contains("ClassificationName") && dict["ClassificationName"] != nil {
                self.classificationName = dict["ClassificationName"] as! String
            }
            if dict.keys.contains("OfficialCode") && dict["OfficialCode"] != nil {
                self.officialCode = dict["OfficialCode"] as! String
            }
            if dict.keys.contains("ParentCode") && dict["ParentCode"] != nil {
                self.parentCode = dict["ParentCode"] as! String
            }
        }
    }
    public var errorMsg: String?

    public var invalidList: [SaveClassificationConditionsResponseBody.InvalidList]?

    public var requestId: String?

    public var success: Bool?

    public var tagName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorMsg != nil {
            map["ErrorMsg"] = self.errorMsg!
        }
        if self.invalidList != nil {
            var tmp : [Any] = []
            for k in self.invalidList! {
                tmp.append(k.toMap())
            }
            map["InvalidList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.tagName != nil {
            map["TagName"] = self.tagName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorMsg") && dict["ErrorMsg"] != nil {
            self.errorMsg = dict["ErrorMsg"] as! String
        }
        if dict.keys.contains("InvalidList") && dict["InvalidList"] != nil {
            var tmp : [SaveClassificationConditionsResponseBody.InvalidList] = []
            for v in dict["InvalidList"] as! [Any] {
                var model = SaveClassificationConditionsResponseBody.InvalidList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.invalidList = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TagName") && dict["TagName"] != nil {
            self.tagName = dict["TagName"] as! String
        }
    }
}

public class SaveClassificationConditionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SaveClassificationConditionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SaveClassificationConditionsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SaveExtensionAttributeRequest : Tea.TeaModel {
    public var attributeKey: String?

    public var attributeValue: String?

    public var bizId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attributeKey != nil {
            map["AttributeKey"] = self.attributeKey!
        }
        if self.attributeValue != nil {
            map["AttributeValue"] = self.attributeValue!
        }
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AttributeKey") && dict["AttributeKey"] != nil {
            self.attributeKey = dict["AttributeKey"] as! String
        }
        if dict.keys.contains("AttributeValue") && dict["AttributeValue"] != nil {
            self.attributeValue = dict["AttributeValue"] as! String
        }
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
    }
}

public class SaveExtensionAttributeResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class SaveExtensionAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SaveExtensionAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SaveExtensionAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SaveTaskRequest : Tea.TeaModel {
    public var bizType: String?

    public var request: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizType != nil {
            map["BizType"] = self.bizType!
        }
        if self.request != nil {
            map["Request"] = self.request!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizType") && dict["BizType"] != nil {
            self.bizType = dict["BizType"] as! String
        }
        if dict.keys.contains("Request") && dict["Request"] != nil {
            self.request = dict["Request"] as! String
        }
    }
}

public class SaveTaskResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SaveTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SaveTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SaveTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SaveTaskForOfficialFileCustomRequest : Tea.TeaModel {
    public var endAcceptTime: Int64?

    public var startAcceptTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endAcceptTime != nil {
            map["EndAcceptTime"] = self.endAcceptTime!
        }
        if self.startAcceptTime != nil {
            map["StartAcceptTime"] = self.startAcceptTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndAcceptTime") && dict["EndAcceptTime"] != nil {
            self.endAcceptTime = dict["EndAcceptTime"] as! Int64
        }
        if dict.keys.contains("StartAcceptTime") && dict["StartAcceptTime"] != nil {
            self.startAcceptTime = dict["StartAcceptTime"] as! Int64
        }
    }
}

public class SaveTaskForOfficialFileCustomResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class SaveTaskForOfficialFileCustomResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SaveTaskForOfficialFileCustomResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SaveTaskForOfficialFileCustomResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SaveTradeMarkReviewMaterialDetailRequest : Tea.TeaModel {
    public var additionalOssKeyList: [String: Any]?

    public var address: String?

    public var applicationOssKey: String?

    public var bizId: String?

    public var businessLicenceOssKey: String?

    public var cardNumber: String?

    public var changeName: Bool?

    public var contactAddress: String?

    public var contactEmail: String?

    public var contactName: String?

    public var contactNumber: String?

    public var country: String?

    public var engAddress: String?

    public var engName: String?

    public var idCardOssKey: String?

    public var legalNoticeOssKey: String?

    public var loaOssKey: String?

    public var name: String?

    public var passportOssKey: String?

    public var province: String?

    public var region: Int32?

    public var reviewMaterialAdditionalJson: String?

    public var separate: Bool?

    public var submitOnline: Bool?

    public var submitType: Int32?

    public var supplementFlag: Bool?

    public var type: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.additionalOssKeyList != nil {
            map["AdditionalOssKeyList"] = self.additionalOssKeyList!
        }
        if self.address != nil {
            map["Address"] = self.address!
        }
        if self.applicationOssKey != nil {
            map["ApplicationOssKey"] = self.applicationOssKey!
        }
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.businessLicenceOssKey != nil {
            map["BusinessLicenceOssKey"] = self.businessLicenceOssKey!
        }
        if self.cardNumber != nil {
            map["CardNumber"] = self.cardNumber!
        }
        if self.changeName != nil {
            map["ChangeName"] = self.changeName!
        }
        if self.contactAddress != nil {
            map["ContactAddress"] = self.contactAddress!
        }
        if self.contactEmail != nil {
            map["ContactEmail"] = self.contactEmail!
        }
        if self.contactName != nil {
            map["ContactName"] = self.contactName!
        }
        if self.contactNumber != nil {
            map["ContactNumber"] = self.contactNumber!
        }
        if self.country != nil {
            map["Country"] = self.country!
        }
        if self.engAddress != nil {
            map["EngAddress"] = self.engAddress!
        }
        if self.engName != nil {
            map["EngName"] = self.engName!
        }
        if self.idCardOssKey != nil {
            map["IdCardOssKey"] = self.idCardOssKey!
        }
        if self.legalNoticeOssKey != nil {
            map["LegalNoticeOssKey"] = self.legalNoticeOssKey!
        }
        if self.loaOssKey != nil {
            map["LoaOssKey"] = self.loaOssKey!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.passportOssKey != nil {
            map["PassportOssKey"] = self.passportOssKey!
        }
        if self.province != nil {
            map["Province"] = self.province!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.reviewMaterialAdditionalJson != nil {
            map["ReviewMaterialAdditionalJson"] = self.reviewMaterialAdditionalJson!
        }
        if self.separate != nil {
            map["Separate"] = self.separate!
        }
        if self.submitOnline != nil {
            map["SubmitOnline"] = self.submitOnline!
        }
        if self.submitType != nil {
            map["SubmitType"] = self.submitType!
        }
        if self.supplementFlag != nil {
            map["SupplementFlag"] = self.supplementFlag!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AdditionalOssKeyList") && dict["AdditionalOssKeyList"] != nil {
            self.additionalOssKeyList = dict["AdditionalOssKeyList"] as! [String: Any]
        }
        if dict.keys.contains("Address") && dict["Address"] != nil {
            self.address = dict["Address"] as! String
        }
        if dict.keys.contains("ApplicationOssKey") && dict["ApplicationOssKey"] != nil {
            self.applicationOssKey = dict["ApplicationOssKey"] as! String
        }
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("BusinessLicenceOssKey") && dict["BusinessLicenceOssKey"] != nil {
            self.businessLicenceOssKey = dict["BusinessLicenceOssKey"] as! String
        }
        if dict.keys.contains("CardNumber") && dict["CardNumber"] != nil {
            self.cardNumber = dict["CardNumber"] as! String
        }
        if dict.keys.contains("ChangeName") && dict["ChangeName"] != nil {
            self.changeName = dict["ChangeName"] as! Bool
        }
        if dict.keys.contains("ContactAddress") && dict["ContactAddress"] != nil {
            self.contactAddress = dict["ContactAddress"] as! String
        }
        if dict.keys.contains("ContactEmail") && dict["ContactEmail"] != nil {
            self.contactEmail = dict["ContactEmail"] as! String
        }
        if dict.keys.contains("ContactName") && dict["ContactName"] != nil {
            self.contactName = dict["ContactName"] as! String
        }
        if dict.keys.contains("ContactNumber") && dict["ContactNumber"] != nil {
            self.contactNumber = dict["ContactNumber"] as! String
        }
        if dict.keys.contains("Country") && dict["Country"] != nil {
            self.country = dict["Country"] as! String
        }
        if dict.keys.contains("EngAddress") && dict["EngAddress"] != nil {
            self.engAddress = dict["EngAddress"] as! String
        }
        if dict.keys.contains("EngName") && dict["EngName"] != nil {
            self.engName = dict["EngName"] as! String
        }
        if dict.keys.contains("IdCardOssKey") && dict["IdCardOssKey"] != nil {
            self.idCardOssKey = dict["IdCardOssKey"] as! String
        }
        if dict.keys.contains("LegalNoticeOssKey") && dict["LegalNoticeOssKey"] != nil {
            self.legalNoticeOssKey = dict["LegalNoticeOssKey"] as! String
        }
        if dict.keys.contains("LoaOssKey") && dict["LoaOssKey"] != nil {
            self.loaOssKey = dict["LoaOssKey"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PassportOssKey") && dict["PassportOssKey"] != nil {
            self.passportOssKey = dict["PassportOssKey"] as! String
        }
        if dict.keys.contains("Province") && dict["Province"] != nil {
            self.province = dict["Province"] as! String
        }
        if dict.keys.contains("Region") && dict["Region"] != nil {
            self.region = dict["Region"] as! Int32
        }
        if dict.keys.contains("ReviewMaterialAdditionalJson") && dict["ReviewMaterialAdditionalJson"] != nil {
            self.reviewMaterialAdditionalJson = dict["ReviewMaterialAdditionalJson"] as! String
        }
        if dict.keys.contains("Separate") && dict["Separate"] != nil {
            self.separate = dict["Separate"] as! Bool
        }
        if dict.keys.contains("SubmitOnline") && dict["SubmitOnline"] != nil {
            self.submitOnline = dict["SubmitOnline"] as! Bool
        }
        if dict.keys.contains("SubmitType") && dict["SubmitType"] != nil {
            self.submitType = dict["SubmitType"] as! Int32
        }
        if dict.keys.contains("SupplementFlag") && dict["SupplementFlag"] != nil {
            self.supplementFlag = dict["SupplementFlag"] as! Bool
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! Int32
        }
    }
}

public class SaveTradeMarkReviewMaterialDetailShrinkRequest : Tea.TeaModel {
    public var additionalOssKeyListShrink: String?

    public var address: String?

    public var applicationOssKey: String?

    public var bizId: String?

    public var businessLicenceOssKey: String?

    public var cardNumber: String?

    public var changeName: Bool?

    public var contactAddress: String?

    public var contactEmail: String?

    public var contactName: String?

    public var contactNumber: String?

    public var country: String?

    public var engAddress: String?

    public var engName: String?

    public var idCardOssKey: String?

    public var legalNoticeOssKey: String?

    public var loaOssKey: String?

    public var name: String?

    public var passportOssKey: String?

    public var province: String?

    public var region: Int32?

    public var reviewMaterialAdditionalJson: String?

    public var separate: Bool?

    public var submitOnline: Bool?

    public var submitType: Int32?

    public var supplementFlag: Bool?

    public var type: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.additionalOssKeyListShrink != nil {
            map["AdditionalOssKeyList"] = self.additionalOssKeyListShrink!
        }
        if self.address != nil {
            map["Address"] = self.address!
        }
        if self.applicationOssKey != nil {
            map["ApplicationOssKey"] = self.applicationOssKey!
        }
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.businessLicenceOssKey != nil {
            map["BusinessLicenceOssKey"] = self.businessLicenceOssKey!
        }
        if self.cardNumber != nil {
            map["CardNumber"] = self.cardNumber!
        }
        if self.changeName != nil {
            map["ChangeName"] = self.changeName!
        }
        if self.contactAddress != nil {
            map["ContactAddress"] = self.contactAddress!
        }
        if self.contactEmail != nil {
            map["ContactEmail"] = self.contactEmail!
        }
        if self.contactName != nil {
            map["ContactName"] = self.contactName!
        }
        if self.contactNumber != nil {
            map["ContactNumber"] = self.contactNumber!
        }
        if self.country != nil {
            map["Country"] = self.country!
        }
        if self.engAddress != nil {
            map["EngAddress"] = self.engAddress!
        }
        if self.engName != nil {
            map["EngName"] = self.engName!
        }
        if self.idCardOssKey != nil {
            map["IdCardOssKey"] = self.idCardOssKey!
        }
        if self.legalNoticeOssKey != nil {
            map["LegalNoticeOssKey"] = self.legalNoticeOssKey!
        }
        if self.loaOssKey != nil {
            map["LoaOssKey"] = self.loaOssKey!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.passportOssKey != nil {
            map["PassportOssKey"] = self.passportOssKey!
        }
        if self.province != nil {
            map["Province"] = self.province!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.reviewMaterialAdditionalJson != nil {
            map["ReviewMaterialAdditionalJson"] = self.reviewMaterialAdditionalJson!
        }
        if self.separate != nil {
            map["Separate"] = self.separate!
        }
        if self.submitOnline != nil {
            map["SubmitOnline"] = self.submitOnline!
        }
        if self.submitType != nil {
            map["SubmitType"] = self.submitType!
        }
        if self.supplementFlag != nil {
            map["SupplementFlag"] = self.supplementFlag!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AdditionalOssKeyList") && dict["AdditionalOssKeyList"] != nil {
            self.additionalOssKeyListShrink = dict["AdditionalOssKeyList"] as! String
        }
        if dict.keys.contains("Address") && dict["Address"] != nil {
            self.address = dict["Address"] as! String
        }
        if dict.keys.contains("ApplicationOssKey") && dict["ApplicationOssKey"] != nil {
            self.applicationOssKey = dict["ApplicationOssKey"] as! String
        }
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("BusinessLicenceOssKey") && dict["BusinessLicenceOssKey"] != nil {
            self.businessLicenceOssKey = dict["BusinessLicenceOssKey"] as! String
        }
        if dict.keys.contains("CardNumber") && dict["CardNumber"] != nil {
            self.cardNumber = dict["CardNumber"] as! String
        }
        if dict.keys.contains("ChangeName") && dict["ChangeName"] != nil {
            self.changeName = dict["ChangeName"] as! Bool
        }
        if dict.keys.contains("ContactAddress") && dict["ContactAddress"] != nil {
            self.contactAddress = dict["ContactAddress"] as! String
        }
        if dict.keys.contains("ContactEmail") && dict["ContactEmail"] != nil {
            self.contactEmail = dict["ContactEmail"] as! String
        }
        if dict.keys.contains("ContactName") && dict["ContactName"] != nil {
            self.contactName = dict["ContactName"] as! String
        }
        if dict.keys.contains("ContactNumber") && dict["ContactNumber"] != nil {
            self.contactNumber = dict["ContactNumber"] as! String
        }
        if dict.keys.contains("Country") && dict["Country"] != nil {
            self.country = dict["Country"] as! String
        }
        if dict.keys.contains("EngAddress") && dict["EngAddress"] != nil {
            self.engAddress = dict["EngAddress"] as! String
        }
        if dict.keys.contains("EngName") && dict["EngName"] != nil {
            self.engName = dict["EngName"] as! String
        }
        if dict.keys.contains("IdCardOssKey") && dict["IdCardOssKey"] != nil {
            self.idCardOssKey = dict["IdCardOssKey"] as! String
        }
        if dict.keys.contains("LegalNoticeOssKey") && dict["LegalNoticeOssKey"] != nil {
            self.legalNoticeOssKey = dict["LegalNoticeOssKey"] as! String
        }
        if dict.keys.contains("LoaOssKey") && dict["LoaOssKey"] != nil {
            self.loaOssKey = dict["LoaOssKey"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PassportOssKey") && dict["PassportOssKey"] != nil {
            self.passportOssKey = dict["PassportOssKey"] as! String
        }
        if dict.keys.contains("Province") && dict["Province"] != nil {
            self.province = dict["Province"] as! String
        }
        if dict.keys.contains("Region") && dict["Region"] != nil {
            self.region = dict["Region"] as! Int32
        }
        if dict.keys.contains("ReviewMaterialAdditionalJson") && dict["ReviewMaterialAdditionalJson"] != nil {
            self.reviewMaterialAdditionalJson = dict["ReviewMaterialAdditionalJson"] as! String
        }
        if dict.keys.contains("Separate") && dict["Separate"] != nil {
            self.separate = dict["Separate"] as! Bool
        }
        if dict.keys.contains("SubmitOnline") && dict["SubmitOnline"] != nil {
            self.submitOnline = dict["SubmitOnline"] as! Bool
        }
        if dict.keys.contains("SubmitType") && dict["SubmitType"] != nil {
            self.submitType = dict["SubmitType"] as! Int32
        }
        if dict.keys.contains("SupplementFlag") && dict["SupplementFlag"] != nil {
            self.supplementFlag = dict["SupplementFlag"] as! Bool
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! Int32
        }
    }
}

public class SaveTradeMarkReviewMaterialDetailResponseBody : Tea.TeaModel {
    public var errorMsg: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorMsg != nil {
            map["ErrorMsg"] = self.errorMsg!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorMsg") && dict["ErrorMsg"] != nil {
            self.errorMsg = dict["ErrorMsg"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class SaveTradeMarkReviewMaterialDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SaveTradeMarkReviewMaterialDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SaveTradeMarkReviewMaterialDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SbjOperateRequest : Tea.TeaModel {
    public var amount: String?

    public var applyNo: String?

    public var auditStatus: Bool?

    public var bizId: String?

    public var fileDate: String?

    public var fileOssKey: String?

    public var message: String?

    public var operateType: String?

    public var orderNo: String?

    public var receiptOssKey: String?

    public var submittedSuccess: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.amount != nil {
            map["Amount"] = self.amount!
        }
        if self.applyNo != nil {
            map["ApplyNo"] = self.applyNo!
        }
        if self.auditStatus != nil {
            map["AuditStatus"] = self.auditStatus!
        }
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.fileDate != nil {
            map["FileDate"] = self.fileDate!
        }
        if self.fileOssKey != nil {
            map["FileOssKey"] = self.fileOssKey!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.operateType != nil {
            map["OperateType"] = self.operateType!
        }
        if self.orderNo != nil {
            map["OrderNo"] = self.orderNo!
        }
        if self.receiptOssKey != nil {
            map["ReceiptOssKey"] = self.receiptOssKey!
        }
        if self.submittedSuccess != nil {
            map["SubmittedSuccess"] = self.submittedSuccess!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Amount") && dict["Amount"] != nil {
            self.amount = dict["Amount"] as! String
        }
        if dict.keys.contains("ApplyNo") && dict["ApplyNo"] != nil {
            self.applyNo = dict["ApplyNo"] as! String
        }
        if dict.keys.contains("AuditStatus") && dict["AuditStatus"] != nil {
            self.auditStatus = dict["AuditStatus"] as! Bool
        }
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("FileDate") && dict["FileDate"] != nil {
            self.fileDate = dict["FileDate"] as! String
        }
        if dict.keys.contains("FileOssKey") && dict["FileOssKey"] != nil {
            self.fileOssKey = dict["FileOssKey"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("OperateType") && dict["OperateType"] != nil {
            self.operateType = dict["OperateType"] as! String
        }
        if dict.keys.contains("OrderNo") && dict["OrderNo"] != nil {
            self.orderNo = dict["OrderNo"] as! String
        }
        if dict.keys.contains("ReceiptOssKey") && dict["ReceiptOssKey"] != nil {
            self.receiptOssKey = dict["ReceiptOssKey"] as! String
        }
        if dict.keys.contains("SubmittedSuccess") && dict["SubmittedSuccess"] != nil {
            self.submittedSuccess = dict["SubmittedSuccess"] as! Bool
        }
    }
}

public class SbjOperateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class SbjOperateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SbjOperateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SbjOperateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SbjOperateNewRequest : Tea.TeaModel {
    public var addSubmitCount: Bool?

    public var allowResubmit: Bool?

    public var amount: String?

    public var applyNo: String?

    public var auditStatus: Bool?

    public var bizId: String?

    public var changeStatus: Bool?

    public var errorMsgScreenshot: String?

    public var fileDate: String?

    public var fileOssKey: String?

    public var message: String?

    public var operateType: String?

    public var orderNo: String?

    public var receiptOssKey: String?

    public var submittedSuccess: Bool?

    public var successType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addSubmitCount != nil {
            map["AddSubmitCount"] = self.addSubmitCount!
        }
        if self.allowResubmit != nil {
            map["AllowResubmit"] = self.allowResubmit!
        }
        if self.amount != nil {
            map["Amount"] = self.amount!
        }
        if self.applyNo != nil {
            map["ApplyNo"] = self.applyNo!
        }
        if self.auditStatus != nil {
            map["AuditStatus"] = self.auditStatus!
        }
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.changeStatus != nil {
            map["ChangeStatus"] = self.changeStatus!
        }
        if self.errorMsgScreenshot != nil {
            map["ErrorMsgScreenshot"] = self.errorMsgScreenshot!
        }
        if self.fileDate != nil {
            map["FileDate"] = self.fileDate!
        }
        if self.fileOssKey != nil {
            map["FileOssKey"] = self.fileOssKey!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.operateType != nil {
            map["OperateType"] = self.operateType!
        }
        if self.orderNo != nil {
            map["OrderNo"] = self.orderNo!
        }
        if self.receiptOssKey != nil {
            map["ReceiptOssKey"] = self.receiptOssKey!
        }
        if self.submittedSuccess != nil {
            map["SubmittedSuccess"] = self.submittedSuccess!
        }
        if self.successType != nil {
            map["SuccessType"] = self.successType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AddSubmitCount") && dict["AddSubmitCount"] != nil {
            self.addSubmitCount = dict["AddSubmitCount"] as! Bool
        }
        if dict.keys.contains("AllowResubmit") && dict["AllowResubmit"] != nil {
            self.allowResubmit = dict["AllowResubmit"] as! Bool
        }
        if dict.keys.contains("Amount") && dict["Amount"] != nil {
            self.amount = dict["Amount"] as! String
        }
        if dict.keys.contains("ApplyNo") && dict["ApplyNo"] != nil {
            self.applyNo = dict["ApplyNo"] as! String
        }
        if dict.keys.contains("AuditStatus") && dict["AuditStatus"] != nil {
            self.auditStatus = dict["AuditStatus"] as! Bool
        }
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("ChangeStatus") && dict["ChangeStatus"] != nil {
            self.changeStatus = dict["ChangeStatus"] as! Bool
        }
        if dict.keys.contains("ErrorMsgScreenshot") && dict["ErrorMsgScreenshot"] != nil {
            self.errorMsgScreenshot = dict["ErrorMsgScreenshot"] as! String
        }
        if dict.keys.contains("FileDate") && dict["FileDate"] != nil {
            self.fileDate = dict["FileDate"] as! String
        }
        if dict.keys.contains("FileOssKey") && dict["FileOssKey"] != nil {
            self.fileOssKey = dict["FileOssKey"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("OperateType") && dict["OperateType"] != nil {
            self.operateType = dict["OperateType"] as! String
        }
        if dict.keys.contains("OrderNo") && dict["OrderNo"] != nil {
            self.orderNo = dict["OrderNo"] as! String
        }
        if dict.keys.contains("ReceiptOssKey") && dict["ReceiptOssKey"] != nil {
            self.receiptOssKey = dict["ReceiptOssKey"] as! String
        }
        if dict.keys.contains("SubmittedSuccess") && dict["SubmittedSuccess"] != nil {
            self.submittedSuccess = dict["SubmittedSuccess"] as! Bool
        }
        if dict.keys.contains("SuccessType") && dict["SuccessType"] != nil {
            self.successType = dict["SuccessType"] as! String
        }
    }
}

public class SbjOperateNewResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class SbjOperateNewResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SbjOperateNewResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SbjOperateNewResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SbrainServiceExecuteRequest : Tea.TeaModel {
    public var executeParams: [String: Any]?

    public var productCode: String?

    public var referenceNo: String?

    public var referenceType: String?

    public var sceneCode: String?

    public var schemeId: Int64?

    public var servicePlace: String?

    public var source: String?

    public var target: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.executeParams != nil {
            map["ExecuteParams"] = self.executeParams!
        }
        if self.productCode != nil {
            map["ProductCode"] = self.productCode!
        }
        if self.referenceNo != nil {
            map["ReferenceNo"] = self.referenceNo!
        }
        if self.referenceType != nil {
            map["ReferenceType"] = self.referenceType!
        }
        if self.sceneCode != nil {
            map["SceneCode"] = self.sceneCode!
        }
        if self.schemeId != nil {
            map["SchemeId"] = self.schemeId!
        }
        if self.servicePlace != nil {
            map["ServicePlace"] = self.servicePlace!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        if self.target != nil {
            map["Target"] = self.target!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ExecuteParams") && dict["ExecuteParams"] != nil {
            self.executeParams = dict["ExecuteParams"] as! [String: Any]
        }
        if dict.keys.contains("ProductCode") && dict["ProductCode"] != nil {
            self.productCode = dict["ProductCode"] as! String
        }
        if dict.keys.contains("ReferenceNo") && dict["ReferenceNo"] != nil {
            self.referenceNo = dict["ReferenceNo"] as! String
        }
        if dict.keys.contains("ReferenceType") && dict["ReferenceType"] != nil {
            self.referenceType = dict["ReferenceType"] as! String
        }
        if dict.keys.contains("SceneCode") && dict["SceneCode"] != nil {
            self.sceneCode = dict["SceneCode"] as! String
        }
        if dict.keys.contains("SchemeId") && dict["SchemeId"] != nil {
            self.schemeId = dict["SchemeId"] as! Int64
        }
        if dict.keys.contains("ServicePlace") && dict["ServicePlace"] != nil {
            self.servicePlace = dict["ServicePlace"] as! String
        }
        if dict.keys.contains("Source") && dict["Source"] != nil {
            self.source = dict["Source"] as! String
        }
        if dict.keys.contains("Target") && dict["Target"] != nil {
            self.target = dict["Target"] as! String
        }
    }
}

public class SbrainServiceExecuteShrinkRequest : Tea.TeaModel {
    public var executeParamsShrink: String?

    public var productCode: String?

    public var referenceNo: String?

    public var referenceType: String?

    public var sceneCode: String?

    public var schemeId: Int64?

    public var servicePlace: String?

    public var source: String?

    public var target: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.executeParamsShrink != nil {
            map["ExecuteParams"] = self.executeParamsShrink!
        }
        if self.productCode != nil {
            map["ProductCode"] = self.productCode!
        }
        if self.referenceNo != nil {
            map["ReferenceNo"] = self.referenceNo!
        }
        if self.referenceType != nil {
            map["ReferenceType"] = self.referenceType!
        }
        if self.sceneCode != nil {
            map["SceneCode"] = self.sceneCode!
        }
        if self.schemeId != nil {
            map["SchemeId"] = self.schemeId!
        }
        if self.servicePlace != nil {
            map["ServicePlace"] = self.servicePlace!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        if self.target != nil {
            map["Target"] = self.target!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ExecuteParams") && dict["ExecuteParams"] != nil {
            self.executeParamsShrink = dict["ExecuteParams"] as! String
        }
        if dict.keys.contains("ProductCode") && dict["ProductCode"] != nil {
            self.productCode = dict["ProductCode"] as! String
        }
        if dict.keys.contains("ReferenceNo") && dict["ReferenceNo"] != nil {
            self.referenceNo = dict["ReferenceNo"] as! String
        }
        if dict.keys.contains("ReferenceType") && dict["ReferenceType"] != nil {
            self.referenceType = dict["ReferenceType"] as! String
        }
        if dict.keys.contains("SceneCode") && dict["SceneCode"] != nil {
            self.sceneCode = dict["SceneCode"] as! String
        }
        if dict.keys.contains("SchemeId") && dict["SchemeId"] != nil {
            self.schemeId = dict["SchemeId"] as! Int64
        }
        if dict.keys.contains("ServicePlace") && dict["ServicePlace"] != nil {
            self.servicePlace = dict["ServicePlace"] as! String
        }
        if dict.keys.contains("Source") && dict["Source"] != nil {
            self.source = dict["Source"] as! String
        }
        if dict.keys.contains("Target") && dict["Target"] != nil {
            self.target = dict["Target"] as! String
        }
    }
}

public class SbrainServiceExecuteResponseBody : Tea.TeaModel {
    public var data: Any?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! Any
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class SbrainServiceExecuteResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SbrainServiceExecuteResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SbrainServiceExecuteResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SbrainServiceHasRunningTaskBatchQueryRequest : Tea.TeaModel {
    public var productCode: String?

    public var referenceNos: [String]?

    public var referenceType: String?

    public var source: String?

    public var taskType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.productCode != nil {
            map["ProductCode"] = self.productCode!
        }
        if self.referenceNos != nil {
            map["ReferenceNos"] = self.referenceNos!
        }
        if self.referenceType != nil {
            map["ReferenceType"] = self.referenceType!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        if self.taskType != nil {
            map["TaskType"] = self.taskType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ProductCode") && dict["ProductCode"] != nil {
            self.productCode = dict["ProductCode"] as! String
        }
        if dict.keys.contains("ReferenceNos") && dict["ReferenceNos"] != nil {
            self.referenceNos = dict["ReferenceNos"] as! [String]
        }
        if dict.keys.contains("ReferenceType") && dict["ReferenceType"] != nil {
            self.referenceType = dict["ReferenceType"] as! String
        }
        if dict.keys.contains("Source") && dict["Source"] != nil {
            self.source = dict["Source"] as! String
        }
        if dict.keys.contains("TaskType") && dict["TaskType"] != nil {
            self.taskType = dict["TaskType"] as! String
        }
    }
}

public class SbrainServiceHasRunningTaskBatchQueryShrinkRequest : Tea.TeaModel {
    public var productCode: String?

    public var referenceNosShrink: String?

    public var referenceType: String?

    public var source: String?

    public var taskType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.productCode != nil {
            map["ProductCode"] = self.productCode!
        }
        if self.referenceNosShrink != nil {
            map["ReferenceNos"] = self.referenceNosShrink!
        }
        if self.referenceType != nil {
            map["ReferenceType"] = self.referenceType!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        if self.taskType != nil {
            map["TaskType"] = self.taskType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ProductCode") && dict["ProductCode"] != nil {
            self.productCode = dict["ProductCode"] as! String
        }
        if dict.keys.contains("ReferenceNos") && dict["ReferenceNos"] != nil {
            self.referenceNosShrink = dict["ReferenceNos"] as! String
        }
        if dict.keys.contains("ReferenceType") && dict["ReferenceType"] != nil {
            self.referenceType = dict["ReferenceType"] as! String
        }
        if dict.keys.contains("Source") && dict["Source"] != nil {
            self.source = dict["Source"] as! String
        }
        if dict.keys.contains("TaskType") && dict["TaskType"] != nil {
            self.taskType = dict["TaskType"] as! String
        }
    }
}

public class SbrainServiceHasRunningTaskBatchQueryResponseBody : Tea.TeaModel {
    public var data: Any?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! Any
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class SbrainServiceHasRunningTaskBatchQueryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SbrainServiceHasRunningTaskBatchQueryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SbrainServiceHasRunningTaskBatchQueryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SbrainServiceSchemeMatchRequest : Tea.TeaModel {
    public var matchParams: [String: Any]?

    public var productCode: String?

    public var referenceNo: String?

    public var referenceType: String?

    public var sceneCode: String?

    public var source: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.matchParams != nil {
            map["MatchParams"] = self.matchParams!
        }
        if self.productCode != nil {
            map["ProductCode"] = self.productCode!
        }
        if self.referenceNo != nil {
            map["ReferenceNo"] = self.referenceNo!
        }
        if self.referenceType != nil {
            map["ReferenceType"] = self.referenceType!
        }
        if self.sceneCode != nil {
            map["SceneCode"] = self.sceneCode!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MatchParams") && dict["MatchParams"] != nil {
            self.matchParams = dict["MatchParams"] as! [String: Any]
        }
        if dict.keys.contains("ProductCode") && dict["ProductCode"] != nil {
            self.productCode = dict["ProductCode"] as! String
        }
        if dict.keys.contains("ReferenceNo") && dict["ReferenceNo"] != nil {
            self.referenceNo = dict["ReferenceNo"] as! String
        }
        if dict.keys.contains("ReferenceType") && dict["ReferenceType"] != nil {
            self.referenceType = dict["ReferenceType"] as! String
        }
        if dict.keys.contains("SceneCode") && dict["SceneCode"] != nil {
            self.sceneCode = dict["SceneCode"] as! String
        }
        if dict.keys.contains("Source") && dict["Source"] != nil {
            self.source = dict["Source"] as! String
        }
    }
}

public class SbrainServiceSchemeMatchShrinkRequest : Tea.TeaModel {
    public var matchParamsShrink: String?

    public var productCode: String?

    public var referenceNo: String?

    public var referenceType: String?

    public var sceneCode: String?

    public var source: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.matchParamsShrink != nil {
            map["MatchParams"] = self.matchParamsShrink!
        }
        if self.productCode != nil {
            map["ProductCode"] = self.productCode!
        }
        if self.referenceNo != nil {
            map["ReferenceNo"] = self.referenceNo!
        }
        if self.referenceType != nil {
            map["ReferenceType"] = self.referenceType!
        }
        if self.sceneCode != nil {
            map["SceneCode"] = self.sceneCode!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MatchParams") && dict["MatchParams"] != nil {
            self.matchParamsShrink = dict["MatchParams"] as! String
        }
        if dict.keys.contains("ProductCode") && dict["ProductCode"] != nil {
            self.productCode = dict["ProductCode"] as! String
        }
        if dict.keys.contains("ReferenceNo") && dict["ReferenceNo"] != nil {
            self.referenceNo = dict["ReferenceNo"] as! String
        }
        if dict.keys.contains("ReferenceType") && dict["ReferenceType"] != nil {
            self.referenceType = dict["ReferenceType"] as! String
        }
        if dict.keys.contains("SceneCode") && dict["SceneCode"] != nil {
            self.sceneCode = dict["SceneCode"] as! String
        }
        if dict.keys.contains("Source") && dict["Source"] != nil {
            self.source = dict["Source"] as! String
        }
    }
}

public class SbrainServiceSchemeMatchResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class SchemeContent : Tea.TeaModel {
            public class ContentModules : Tea.TeaModel {
                public var tag: String?

                public var action: String?

                public var moduleData: String?

                public var moduleDataSource: String?

                public var moduleDataSourceType: String?

                public var name: String?

                public var target: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        map["Tag"] = self.tag!
                    }
                    if self.action != nil {
                        map["action"] = self.action!
                    }
                    if self.moduleData != nil {
                        map["moduleData"] = self.moduleData!
                    }
                    if self.moduleDataSource != nil {
                        map["moduleDataSource"] = self.moduleDataSource!
                    }
                    if self.moduleDataSourceType != nil {
                        map["moduleDataSourceType"] = self.moduleDataSourceType!
                    }
                    if self.name != nil {
                        map["name"] = self.name!
                    }
                    if self.target != nil {
                        map["target"] = self.target!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Tag") && dict["Tag"] != nil {
                        self.tag = dict["Tag"] as! String
                    }
                    if dict.keys.contains("action") && dict["action"] != nil {
                        self.action = dict["action"] as! String
                    }
                    if dict.keys.contains("moduleData") && dict["moduleData"] != nil {
                        self.moduleData = dict["moduleData"] as! String
                    }
                    if dict.keys.contains("moduleDataSource") && dict["moduleDataSource"] != nil {
                        self.moduleDataSource = dict["moduleDataSource"] as! String
                    }
                    if dict.keys.contains("moduleDataSourceType") && dict["moduleDataSourceType"] != nil {
                        self.moduleDataSourceType = dict["moduleDataSourceType"] as! String
                    }
                    if dict.keys.contains("name") && dict["name"] != nil {
                        self.name = dict["name"] as! String
                    }
                    if dict.keys.contains("target") && dict["target"] != nil {
                        self.target = dict["target"] as! String
                    }
                }
            }
            public var contentIndex: Int32?

            public var contentModules: [SbrainServiceSchemeMatchResponseBody.Data.SchemeContent.ContentModules]?

            public var display: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.contentIndex != nil {
                    map["ContentIndex"] = self.contentIndex!
                }
                if self.contentModules != nil {
                    var tmp : [Any] = []
                    for k in self.contentModules! {
                        tmp.append(k.toMap())
                    }
                    map["ContentModules"] = tmp
                }
                if self.display != nil {
                    map["Display"] = self.display!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ContentIndex") && dict["ContentIndex"] != nil {
                    self.contentIndex = dict["ContentIndex"] as! Int32
                }
                if dict.keys.contains("ContentModules") && dict["ContentModules"] != nil {
                    var tmp : [SbrainServiceSchemeMatchResponseBody.Data.SchemeContent.ContentModules] = []
                    for v in dict["ContentModules"] as! [Any] {
                        var model = SbrainServiceSchemeMatchResponseBody.Data.SchemeContent.ContentModules()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.contentModules = tmp
                }
                if dict.keys.contains("Display") && dict["Display"] != nil {
                    self.display = dict["Display"] as! String
                }
            }
        }
        public var sceneCode: String?

        public var schemeContent: SbrainServiceSchemeMatchResponseBody.Data.SchemeContent?

        public var schemeId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.schemeContent?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.sceneCode != nil {
                map["SceneCode"] = self.sceneCode!
            }
            if self.schemeContent != nil {
                map["SchemeContent"] = self.schemeContent?.toMap()
            }
            if self.schemeId != nil {
                map["SchemeId"] = self.schemeId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SceneCode") && dict["SceneCode"] != nil {
                self.sceneCode = dict["SceneCode"] as! String
            }
            if dict.keys.contains("SchemeContent") && dict["SchemeContent"] != nil {
                var model = SbrainServiceSchemeMatchResponseBody.Data.SchemeContent()
                model.fromMap(dict["SchemeContent"] as! [String: Any])
                self.schemeContent = model
            }
            if dict.keys.contains("SchemeId") && dict["SchemeId"] != nil {
                self.schemeId = dict["SchemeId"] as! Int64
            }
        }
    }
    public var data: SbrainServiceSchemeMatchResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = SbrainServiceSchemeMatchResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class SbrainServiceSchemeMatchResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SbrainServiceSchemeMatchResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SbrainServiceSchemeMatchResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SearchTmOnsalesRequest : Tea.TeaModel {
    public var classification: String?

    public var keyword: String?

    public var orderPriceLeft: Int64?

    public var orderPriceRight: Int64?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var productCode: String?

    public var queryAll: Bool?

    public var regLeft: Int32?

    public var regRight: Int32?

    public var registerNumber: String?

    public var sortName: String?

    public var sortOrder: String?

    public var tag: String?

    public var tmName: String?

    public var topSearch: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.classification != nil {
            map["Classification"] = self.classification!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.orderPriceLeft != nil {
            map["OrderPriceLeft"] = self.orderPriceLeft!
        }
        if self.orderPriceRight != nil {
            map["OrderPriceRight"] = self.orderPriceRight!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.productCode != nil {
            map["ProductCode"] = self.productCode!
        }
        if self.queryAll != nil {
            map["QueryAll"] = self.queryAll!
        }
        if self.regLeft != nil {
            map["RegLeft"] = self.regLeft!
        }
        if self.regRight != nil {
            map["RegRight"] = self.regRight!
        }
        if self.registerNumber != nil {
            map["RegisterNumber"] = self.registerNumber!
        }
        if self.sortName != nil {
            map["SortName"] = self.sortName!
        }
        if self.sortOrder != nil {
            map["SortOrder"] = self.sortOrder!
        }
        if self.tag != nil {
            map["Tag"] = self.tag!
        }
        if self.tmName != nil {
            map["TmName"] = self.tmName!
        }
        if self.topSearch != nil {
            map["TopSearch"] = self.topSearch!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Classification") && dict["Classification"] != nil {
            self.classification = dict["Classification"] as! String
        }
        if dict.keys.contains("Keyword") && dict["Keyword"] != nil {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("OrderPriceLeft") && dict["OrderPriceLeft"] != nil {
            self.orderPriceLeft = dict["OrderPriceLeft"] as! Int64
        }
        if dict.keys.contains("OrderPriceRight") && dict["OrderPriceRight"] != nil {
            self.orderPriceRight = dict["OrderPriceRight"] as! Int64
        }
        if dict.keys.contains("PageNum") && dict["PageNum"] != nil {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ProductCode") && dict["ProductCode"] != nil {
            self.productCode = dict["ProductCode"] as! String
        }
        if dict.keys.contains("QueryAll") && dict["QueryAll"] != nil {
            self.queryAll = dict["QueryAll"] as! Bool
        }
        if dict.keys.contains("RegLeft") && dict["RegLeft"] != nil {
            self.regLeft = dict["RegLeft"] as! Int32
        }
        if dict.keys.contains("RegRight") && dict["RegRight"] != nil {
            self.regRight = dict["RegRight"] as! Int32
        }
        if dict.keys.contains("RegisterNumber") && dict["RegisterNumber"] != nil {
            self.registerNumber = dict["RegisterNumber"] as! String
        }
        if dict.keys.contains("SortName") && dict["SortName"] != nil {
            self.sortName = dict["SortName"] as! String
        }
        if dict.keys.contains("SortOrder") && dict["SortOrder"] != nil {
            self.sortOrder = dict["SortOrder"] as! String
        }
        if dict.keys.contains("Tag") && dict["Tag"] != nil {
            self.tag = dict["Tag"] as! String
        }
        if dict.keys.contains("TmName") && dict["TmName"] != nil {
            self.tmName = dict["TmName"] as! String
        }
        if dict.keys.contains("TopSearch") && dict["TopSearch"] != nil {
            self.topSearch = dict["TopSearch"] as! String
        }
    }
}

public class SearchTmOnsalesResponseBody : Tea.TeaModel {
    public class Trademarks : Tea.TeaModel {
        public var classification: String?

        public var icon: String?

        public var orderPrice: String?

        public var partnerCode: String?

        public var productCode: String?

        public var productDesc: String?

        public var registrationNumber: String?

        public var status: Int64?

        public var trademarkName: String?

        public var uid: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.classification != nil {
                map["Classification"] = self.classification!
            }
            if self.icon != nil {
                map["Icon"] = self.icon!
            }
            if self.orderPrice != nil {
                map["OrderPrice"] = self.orderPrice!
            }
            if self.partnerCode != nil {
                map["PartnerCode"] = self.partnerCode!
            }
            if self.productCode != nil {
                map["ProductCode"] = self.productCode!
            }
            if self.productDesc != nil {
                map["ProductDesc"] = self.productDesc!
            }
            if self.registrationNumber != nil {
                map["RegistrationNumber"] = self.registrationNumber!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.trademarkName != nil {
                map["TrademarkName"] = self.trademarkName!
            }
            if self.uid != nil {
                map["Uid"] = self.uid!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Classification") && dict["Classification"] != nil {
                self.classification = dict["Classification"] as! String
            }
            if dict.keys.contains("Icon") && dict["Icon"] != nil {
                self.icon = dict["Icon"] as! String
            }
            if dict.keys.contains("OrderPrice") && dict["OrderPrice"] != nil {
                self.orderPrice = dict["OrderPrice"] as! String
            }
            if dict.keys.contains("PartnerCode") && dict["PartnerCode"] != nil {
                self.partnerCode = dict["PartnerCode"] as! String
            }
            if dict.keys.contains("ProductCode") && dict["ProductCode"] != nil {
                self.productCode = dict["ProductCode"] as! String
            }
            if dict.keys.contains("ProductDesc") && dict["ProductDesc"] != nil {
                self.productDesc = dict["ProductDesc"] as! String
            }
            if dict.keys.contains("RegistrationNumber") && dict["RegistrationNumber"] != nil {
                self.registrationNumber = dict["RegistrationNumber"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! Int64
            }
            if dict.keys.contains("TrademarkName") && dict["TrademarkName"] != nil {
                self.trademarkName = dict["TrademarkName"] as! String
            }
            if dict.keys.contains("Uid") && dict["Uid"] != nil {
                self.uid = dict["Uid"] as! String
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public var totalPageNumber: Int32?

    public var trademarks: [SearchTmOnsalesResponseBody.Trademarks]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.totalPageNumber != nil {
            map["TotalPageNumber"] = self.totalPageNumber!
        }
        if self.trademarks != nil {
            var tmp : [Any] = []
            for k in self.trademarks! {
                tmp.append(k.toMap())
            }
            map["Trademarks"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
        if dict.keys.contains("TotalPageNumber") && dict["TotalPageNumber"] != nil {
            self.totalPageNumber = dict["TotalPageNumber"] as! Int32
        }
        if dict.keys.contains("Trademarks") && dict["Trademarks"] != nil {
            var tmp : [SearchTmOnsalesResponseBody.Trademarks] = []
            for v in dict["Trademarks"] as! [Any] {
                var model = SearchTmOnsalesResponseBody.Trademarks()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.trademarks = tmp
        }
    }
}

public class SearchTmOnsalesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchTmOnsalesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SearchTmOnsalesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StartNotaryRequest : Tea.TeaModel {
    public var notaryOrderId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.notaryOrderId != nil {
            map["NotaryOrderId"] = self.notaryOrderId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NotaryOrderId") && dict["NotaryOrderId"] != nil {
            self.notaryOrderId = dict["NotaryOrderId"] as! Int64
        }
    }
}

public class StartNotaryResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMsg: String?

    public var notaryUrl: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["ErrorMsg"] = self.errorMsg!
        }
        if self.notaryUrl != nil {
            map["NotaryUrl"] = self.notaryUrl!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMsg") && dict["ErrorMsg"] != nil {
            self.errorMsg = dict["ErrorMsg"] as! String
        }
        if dict.keys.contains("NotaryUrl") && dict["NotaryUrl"] != nil {
            self.notaryUrl = dict["NotaryUrl"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class StartNotaryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartNotaryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = StartNotaryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StoreMaterialTemporarilyRequest : Tea.TeaModel {
    public var address: String?

    public var businessLicenceOssKey: String?

    public var cardNumber: String?

    public var city: String?

    public var contactAddress: String?

    public var contactCity: String?

    public var contactCounty: String?

    public var contactDistrict: String?

    public var contactEmail: String?

    public var contactName: String?

    public var contactNumber: String?

    public var contactProvince: String?

    public var contactZipcode: String?

    public var country: String?

    public var EAddress: String?

    public var EName: String?

    public var idCardName: String?

    public var idCardNumber: String?

    public var idCardOssKey: String?

    public var legalNoticeOssKey: String?

    public var loaOssKey: String?

    public var name: String?

    public var passportOssKey: String?

    public var personalType: Int64?

    public var principalName: Int32?

    public var province: String?

    public var region: String?

    public var town: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.address != nil {
            map["Address"] = self.address!
        }
        if self.businessLicenceOssKey != nil {
            map["BusinessLicenceOssKey"] = self.businessLicenceOssKey!
        }
        if self.cardNumber != nil {
            map["CardNumber"] = self.cardNumber!
        }
        if self.city != nil {
            map["City"] = self.city!
        }
        if self.contactAddress != nil {
            map["ContactAddress"] = self.contactAddress!
        }
        if self.contactCity != nil {
            map["ContactCity"] = self.contactCity!
        }
        if self.contactCounty != nil {
            map["ContactCounty"] = self.contactCounty!
        }
        if self.contactDistrict != nil {
            map["ContactDistrict"] = self.contactDistrict!
        }
        if self.contactEmail != nil {
            map["ContactEmail"] = self.contactEmail!
        }
        if self.contactName != nil {
            map["ContactName"] = self.contactName!
        }
        if self.contactNumber != nil {
            map["ContactNumber"] = self.contactNumber!
        }
        if self.contactProvince != nil {
            map["ContactProvince"] = self.contactProvince!
        }
        if self.contactZipcode != nil {
            map["ContactZipcode"] = self.contactZipcode!
        }
        if self.country != nil {
            map["Country"] = self.country!
        }
        if self.EAddress != nil {
            map["EAddress"] = self.EAddress!
        }
        if self.EName != nil {
            map["EName"] = self.EName!
        }
        if self.idCardName != nil {
            map["IdCardName"] = self.idCardName!
        }
        if self.idCardNumber != nil {
            map["IdCardNumber"] = self.idCardNumber!
        }
        if self.idCardOssKey != nil {
            map["IdCardOssKey"] = self.idCardOssKey!
        }
        if self.legalNoticeOssKey != nil {
            map["LegalNoticeOssKey"] = self.legalNoticeOssKey!
        }
        if self.loaOssKey != nil {
            map["LoaOssKey"] = self.loaOssKey!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.passportOssKey != nil {
            map["PassportOssKey"] = self.passportOssKey!
        }
        if self.personalType != nil {
            map["PersonalType"] = self.personalType!
        }
        if self.principalName != nil {
            map["PrincipalName"] = self.principalName!
        }
        if self.province != nil {
            map["Province"] = self.province!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.town != nil {
            map["Town"] = self.town!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Address") && dict["Address"] != nil {
            self.address = dict["Address"] as! String
        }
        if dict.keys.contains("BusinessLicenceOssKey") && dict["BusinessLicenceOssKey"] != nil {
            self.businessLicenceOssKey = dict["BusinessLicenceOssKey"] as! String
        }
        if dict.keys.contains("CardNumber") && dict["CardNumber"] != nil {
            self.cardNumber = dict["CardNumber"] as! String
        }
        if dict.keys.contains("City") && dict["City"] != nil {
            self.city = dict["City"] as! String
        }
        if dict.keys.contains("ContactAddress") && dict["ContactAddress"] != nil {
            self.contactAddress = dict["ContactAddress"] as! String
        }
        if dict.keys.contains("ContactCity") && dict["ContactCity"] != nil {
            self.contactCity = dict["ContactCity"] as! String
        }
        if dict.keys.contains("ContactCounty") && dict["ContactCounty"] != nil {
            self.contactCounty = dict["ContactCounty"] as! String
        }
        if dict.keys.contains("ContactDistrict") && dict["ContactDistrict"] != nil {
            self.contactDistrict = dict["ContactDistrict"] as! String
        }
        if dict.keys.contains("ContactEmail") && dict["ContactEmail"] != nil {
            self.contactEmail = dict["ContactEmail"] as! String
        }
        if dict.keys.contains("ContactName") && dict["ContactName"] != nil {
            self.contactName = dict["ContactName"] as! String
        }
        if dict.keys.contains("ContactNumber") && dict["ContactNumber"] != nil {
            self.contactNumber = dict["ContactNumber"] as! String
        }
        if dict.keys.contains("ContactProvince") && dict["ContactProvince"] != nil {
            self.contactProvince = dict["ContactProvince"] as! String
        }
        if dict.keys.contains("ContactZipcode") && dict["ContactZipcode"] != nil {
            self.contactZipcode = dict["ContactZipcode"] as! String
        }
        if dict.keys.contains("Country") && dict["Country"] != nil {
            self.country = dict["Country"] as! String
        }
        if dict.keys.contains("EAddress") && dict["EAddress"] != nil {
            self.EAddress = dict["EAddress"] as! String
        }
        if dict.keys.contains("EName") && dict["EName"] != nil {
            self.EName = dict["EName"] as! String
        }
        if dict.keys.contains("IdCardName") && dict["IdCardName"] != nil {
            self.idCardName = dict["IdCardName"] as! String
        }
        if dict.keys.contains("IdCardNumber") && dict["IdCardNumber"] != nil {
            self.idCardNumber = dict["IdCardNumber"] as! String
        }
        if dict.keys.contains("IdCardOssKey") && dict["IdCardOssKey"] != nil {
            self.idCardOssKey = dict["IdCardOssKey"] as! String
        }
        if dict.keys.contains("LegalNoticeOssKey") && dict["LegalNoticeOssKey"] != nil {
            self.legalNoticeOssKey = dict["LegalNoticeOssKey"] as! String
        }
        if dict.keys.contains("LoaOssKey") && dict["LoaOssKey"] != nil {
            self.loaOssKey = dict["LoaOssKey"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PassportOssKey") && dict["PassportOssKey"] != nil {
            self.passportOssKey = dict["PassportOssKey"] as! String
        }
        if dict.keys.contains("PersonalType") && dict["PersonalType"] != nil {
            self.personalType = dict["PersonalType"] as! Int64
        }
        if dict.keys.contains("PrincipalName") && dict["PrincipalName"] != nil {
            self.principalName = dict["PrincipalName"] as! Int32
        }
        if dict.keys.contains("Province") && dict["Province"] != nil {
            self.province = dict["Province"] as! String
        }
        if dict.keys.contains("Region") && dict["Region"] != nil {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("Town") && dict["Town"] != nil {
            self.town = dict["Town"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class StoreMaterialTemporarilyResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class StoreMaterialTemporarilyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StoreMaterialTemporarilyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = StoreMaterialTemporarilyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitSupplementRequest : Tea.TeaModel {
    public var content: String?

    public var id: Int64?

    public var operateType: String?

    public var uploadOssKeyList: [String: Any]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.operateType != nil {
            map["OperateType"] = self.operateType!
        }
        if self.uploadOssKeyList != nil {
            map["UploadOssKeyList"] = self.uploadOssKeyList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Content") && dict["Content"] != nil {
            self.content = dict["Content"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("OperateType") && dict["OperateType"] != nil {
            self.operateType = dict["OperateType"] as! String
        }
        if dict.keys.contains("UploadOssKeyList") && dict["UploadOssKeyList"] != nil {
            self.uploadOssKeyList = dict["UploadOssKeyList"] as! [String: Any]
        }
    }
}

public class SubmitSupplementShrinkRequest : Tea.TeaModel {
    public var content: String?

    public var id: Int64?

    public var operateType: String?

    public var uploadOssKeyListShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.operateType != nil {
            map["OperateType"] = self.operateType!
        }
        if self.uploadOssKeyListShrink != nil {
            map["UploadOssKeyList"] = self.uploadOssKeyListShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Content") && dict["Content"] != nil {
            self.content = dict["Content"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("OperateType") && dict["OperateType"] != nil {
            self.operateType = dict["OperateType"] as! String
        }
        if dict.keys.contains("UploadOssKeyList") && dict["UploadOssKeyList"] != nil {
            self.uploadOssKeyListShrink = dict["UploadOssKeyList"] as! String
        }
    }
}

public class SubmitSupplementResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMsg: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["ErrorMsg"] = self.errorMsg!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMsg") && dict["ErrorMsg"] != nil {
            self.errorMsg = dict["ErrorMsg"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class SubmitSupplementResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitSupplementResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SubmitSupplementResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitTrademarkApplicationComplaintRequest : Tea.TeaModel {
    public var bizId: String?

    public var content: String?

    public var files: [String: Any]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.files != nil {
            map["Files"] = self.files!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("Content") && dict["Content"] != nil {
            self.content = dict["Content"] as! String
        }
        if dict.keys.contains("Files") && dict["Files"] != nil {
            self.files = dict["Files"] as! [String: Any]
        }
    }
}

public class SubmitTrademarkApplicationComplaintShrinkRequest : Tea.TeaModel {
    public var bizId: String?

    public var content: String?

    public var filesShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.filesShrink != nil {
            map["Files"] = self.filesShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("Content") && dict["Content"] != nil {
            self.content = dict["Content"] as! String
        }
        if dict.keys.contains("Files") && dict["Files"] != nil {
            self.filesShrink = dict["Files"] as! String
        }
    }
}

public class SubmitTrademarkApplicationComplaintResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitTrademarkApplicationComplaintResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitTrademarkApplicationComplaintResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SubmitTrademarkApplicationComplaintResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SyncTrademarkRequest : Tea.TeaModel {
    public var beginTime: Int64?

    public var classificationCode: String?

    public var description_: String?

    public var endTime: Int64?

    public var label: String?

    public var originalPrice: Double?

    public var ownerEnName: String?

    public var ownerName: String?

    public var reason: String?

    public var regAnnDate: Int64?

    public var secondaryClassification: String?

    public var status: String?

    public var thirdClassification: String?

    public var tmIcon: String?

    public var tmName: String?

    public var tmNumber: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.beginTime != nil {
            map["BeginTime"] = self.beginTime!
        }
        if self.classificationCode != nil {
            map["ClassificationCode"] = self.classificationCode!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.label != nil {
            map["Label"] = self.label!
        }
        if self.originalPrice != nil {
            map["OriginalPrice"] = self.originalPrice!
        }
        if self.ownerEnName != nil {
            map["OwnerEnName"] = self.ownerEnName!
        }
        if self.ownerName != nil {
            map["OwnerName"] = self.ownerName!
        }
        if self.reason != nil {
            map["Reason"] = self.reason!
        }
        if self.regAnnDate != nil {
            map["RegAnnDate"] = self.regAnnDate!
        }
        if self.secondaryClassification != nil {
            map["SecondaryClassification"] = self.secondaryClassification!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.thirdClassification != nil {
            map["ThirdClassification"] = self.thirdClassification!
        }
        if self.tmIcon != nil {
            map["TmIcon"] = self.tmIcon!
        }
        if self.tmName != nil {
            map["TmName"] = self.tmName!
        }
        if self.tmNumber != nil {
            map["TmNumber"] = self.tmNumber!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BeginTime") && dict["BeginTime"] != nil {
            self.beginTime = dict["BeginTime"] as! Int64
        }
        if dict.keys.contains("ClassificationCode") && dict["ClassificationCode"] != nil {
            self.classificationCode = dict["ClassificationCode"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("Label") && dict["Label"] != nil {
            self.label = dict["Label"] as! String
        }
        if dict.keys.contains("OriginalPrice") && dict["OriginalPrice"] != nil {
            self.originalPrice = dict["OriginalPrice"] as! Double
        }
        if dict.keys.contains("OwnerEnName") && dict["OwnerEnName"] != nil {
            self.ownerEnName = dict["OwnerEnName"] as! String
        }
        if dict.keys.contains("OwnerName") && dict["OwnerName"] != nil {
            self.ownerName = dict["OwnerName"] as! String
        }
        if dict.keys.contains("Reason") && dict["Reason"] != nil {
            self.reason = dict["Reason"] as! String
        }
        if dict.keys.contains("RegAnnDate") && dict["RegAnnDate"] != nil {
            self.regAnnDate = dict["RegAnnDate"] as! Int64
        }
        if dict.keys.contains("SecondaryClassification") && dict["SecondaryClassification"] != nil {
            self.secondaryClassification = dict["SecondaryClassification"] as! String
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("ThirdClassification") && dict["ThirdClassification"] != nil {
            self.thirdClassification = dict["ThirdClassification"] as! String
        }
        if dict.keys.contains("TmIcon") && dict["TmIcon"] != nil {
            self.tmIcon = dict["TmIcon"] as! String
        }
        if dict.keys.contains("TmName") && dict["TmName"] != nil {
            self.tmName = dict["TmName"] as! String
        }
        if dict.keys.contains("TmNumber") && dict["TmNumber"] != nil {
            self.tmNumber = dict["TmNumber"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class SyncTrademarkResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SyncTrademarkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SyncTrademarkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SyncTrademarkResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateApplicantContacterRequest : Tea.TeaModel {
    public var applicantId: Int64?

    public var bizId: String?

    public var contactAddress: String?

    public var contactCity: String?

    public var contactDistrict: String?

    public var contactEmail: String?

    public var contactName: String?

    public var contactNumber: String?

    public var contactProvince: String?

    public var contactZipCode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicantId != nil {
            map["ApplicantId"] = self.applicantId!
        }
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.contactAddress != nil {
            map["ContactAddress"] = self.contactAddress!
        }
        if self.contactCity != nil {
            map["ContactCity"] = self.contactCity!
        }
        if self.contactDistrict != nil {
            map["ContactDistrict"] = self.contactDistrict!
        }
        if self.contactEmail != nil {
            map["ContactEmail"] = self.contactEmail!
        }
        if self.contactName != nil {
            map["ContactName"] = self.contactName!
        }
        if self.contactNumber != nil {
            map["ContactNumber"] = self.contactNumber!
        }
        if self.contactProvince != nil {
            map["ContactProvince"] = self.contactProvince!
        }
        if self.contactZipCode != nil {
            map["ContactZipCode"] = self.contactZipCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApplicantId") && dict["ApplicantId"] != nil {
            self.applicantId = dict["ApplicantId"] as! Int64
        }
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("ContactAddress") && dict["ContactAddress"] != nil {
            self.contactAddress = dict["ContactAddress"] as! String
        }
        if dict.keys.contains("ContactCity") && dict["ContactCity"] != nil {
            self.contactCity = dict["ContactCity"] as! String
        }
        if dict.keys.contains("ContactDistrict") && dict["ContactDistrict"] != nil {
            self.contactDistrict = dict["ContactDistrict"] as! String
        }
        if dict.keys.contains("ContactEmail") && dict["ContactEmail"] != nil {
            self.contactEmail = dict["ContactEmail"] as! String
        }
        if dict.keys.contains("ContactName") && dict["ContactName"] != nil {
            self.contactName = dict["ContactName"] as! String
        }
        if dict.keys.contains("ContactNumber") && dict["ContactNumber"] != nil {
            self.contactNumber = dict["ContactNumber"] as! String
        }
        if dict.keys.contains("ContactProvince") && dict["ContactProvince"] != nil {
            self.contactProvince = dict["ContactProvince"] as! String
        }
        if dict.keys.contains("ContactZipCode") && dict["ContactZipCode"] != nil {
            self.contactZipCode = dict["ContactZipCode"] as! String
        }
    }
}

public class UpdateApplicantContacterResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateApplicantContacterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateApplicantContacterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateApplicantContacterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateMaterialRequest : Tea.TeaModel {
    public var address: String?

    public var businessLicenceOssKey: String?

    public var cardNumber: String?

    public var city: String?

    public var contactAddress: String?

    public var contactCity: String?

    public var contactCounty: String?

    public var contactDistrict: String?

    public var contactEmail: String?

    public var contactName: String?

    public var contactNumber: String?

    public var contactProvince: String?

    public var contactZipcode: String?

    public var EAddress: String?

    public var EName: String?

    public var id: Int64?

    public var idCardName: String?

    public var idCardNumber: String?

    public var idCardOssKey: String?

    public var legalNoticeOssKey: String?

    public var loaId: Int64?

    public var loaOssKey: String?

    public var name: String?

    public var passportOssKey: String?

    public var personalType: Int64?

    public var province: String?

    public var town: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.address != nil {
            map["Address"] = self.address!
        }
        if self.businessLicenceOssKey != nil {
            map["BusinessLicenceOssKey"] = self.businessLicenceOssKey!
        }
        if self.cardNumber != nil {
            map["CardNumber"] = self.cardNumber!
        }
        if self.city != nil {
            map["City"] = self.city!
        }
        if self.contactAddress != nil {
            map["ContactAddress"] = self.contactAddress!
        }
        if self.contactCity != nil {
            map["ContactCity"] = self.contactCity!
        }
        if self.contactCounty != nil {
            map["ContactCounty"] = self.contactCounty!
        }
        if self.contactDistrict != nil {
            map["ContactDistrict"] = self.contactDistrict!
        }
        if self.contactEmail != nil {
            map["ContactEmail"] = self.contactEmail!
        }
        if self.contactName != nil {
            map["ContactName"] = self.contactName!
        }
        if self.contactNumber != nil {
            map["ContactNumber"] = self.contactNumber!
        }
        if self.contactProvince != nil {
            map["ContactProvince"] = self.contactProvince!
        }
        if self.contactZipcode != nil {
            map["ContactZipcode"] = self.contactZipcode!
        }
        if self.EAddress != nil {
            map["EAddress"] = self.EAddress!
        }
        if self.EName != nil {
            map["EName"] = self.EName!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.idCardName != nil {
            map["IdCardName"] = self.idCardName!
        }
        if self.idCardNumber != nil {
            map["IdCardNumber"] = self.idCardNumber!
        }
        if self.idCardOssKey != nil {
            map["IdCardOssKey"] = self.idCardOssKey!
        }
        if self.legalNoticeOssKey != nil {
            map["LegalNoticeOssKey"] = self.legalNoticeOssKey!
        }
        if self.loaId != nil {
            map["LoaId"] = self.loaId!
        }
        if self.loaOssKey != nil {
            map["LoaOssKey"] = self.loaOssKey!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.passportOssKey != nil {
            map["PassportOssKey"] = self.passportOssKey!
        }
        if self.personalType != nil {
            map["PersonalType"] = self.personalType!
        }
        if self.province != nil {
            map["Province"] = self.province!
        }
        if self.town != nil {
            map["Town"] = self.town!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Address") && dict["Address"] != nil {
            self.address = dict["Address"] as! String
        }
        if dict.keys.contains("BusinessLicenceOssKey") && dict["BusinessLicenceOssKey"] != nil {
            self.businessLicenceOssKey = dict["BusinessLicenceOssKey"] as! String
        }
        if dict.keys.contains("CardNumber") && dict["CardNumber"] != nil {
            self.cardNumber = dict["CardNumber"] as! String
        }
        if dict.keys.contains("City") && dict["City"] != nil {
            self.city = dict["City"] as! String
        }
        if dict.keys.contains("ContactAddress") && dict["ContactAddress"] != nil {
            self.contactAddress = dict["ContactAddress"] as! String
        }
        if dict.keys.contains("ContactCity") && dict["ContactCity"] != nil {
            self.contactCity = dict["ContactCity"] as! String
        }
        if dict.keys.contains("ContactCounty") && dict["ContactCounty"] != nil {
            self.contactCounty = dict["ContactCounty"] as! String
        }
        if dict.keys.contains("ContactDistrict") && dict["ContactDistrict"] != nil {
            self.contactDistrict = dict["ContactDistrict"] as! String
        }
        if dict.keys.contains("ContactEmail") && dict["ContactEmail"] != nil {
            self.contactEmail = dict["ContactEmail"] as! String
        }
        if dict.keys.contains("ContactName") && dict["ContactName"] != nil {
            self.contactName = dict["ContactName"] as! String
        }
        if dict.keys.contains("ContactNumber") && dict["ContactNumber"] != nil {
            self.contactNumber = dict["ContactNumber"] as! String
        }
        if dict.keys.contains("ContactProvince") && dict["ContactProvince"] != nil {
            self.contactProvince = dict["ContactProvince"] as! String
        }
        if dict.keys.contains("ContactZipcode") && dict["ContactZipcode"] != nil {
            self.contactZipcode = dict["ContactZipcode"] as! String
        }
        if dict.keys.contains("EAddress") && dict["EAddress"] != nil {
            self.EAddress = dict["EAddress"] as! String
        }
        if dict.keys.contains("EName") && dict["EName"] != nil {
            self.EName = dict["EName"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("IdCardName") && dict["IdCardName"] != nil {
            self.idCardName = dict["IdCardName"] as! String
        }
        if dict.keys.contains("IdCardNumber") && dict["IdCardNumber"] != nil {
            self.idCardNumber = dict["IdCardNumber"] as! String
        }
        if dict.keys.contains("IdCardOssKey") && dict["IdCardOssKey"] != nil {
            self.idCardOssKey = dict["IdCardOssKey"] as! String
        }
        if dict.keys.contains("LegalNoticeOssKey") && dict["LegalNoticeOssKey"] != nil {
            self.legalNoticeOssKey = dict["LegalNoticeOssKey"] as! String
        }
        if dict.keys.contains("LoaId") && dict["LoaId"] != nil {
            self.loaId = dict["LoaId"] as! Int64
        }
        if dict.keys.contains("LoaOssKey") && dict["LoaOssKey"] != nil {
            self.loaOssKey = dict["LoaOssKey"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PassportOssKey") && dict["PassportOssKey"] != nil {
            self.passportOssKey = dict["PassportOssKey"] as! String
        }
        if dict.keys.contains("PersonalType") && dict["PersonalType"] != nil {
            self.personalType = dict["PersonalType"] as! Int64
        }
        if dict.keys.contains("Province") && dict["Province"] != nil {
            self.province = dict["Province"] as! String
        }
        if dict.keys.contains("Town") && dict["Town"] != nil {
            self.town = dict["Town"] as! String
        }
    }
}

public class UpdateMaterialResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateMaterialResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateMaterialResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateMaterialResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateProduceRequest : Tea.TeaModel {
    public var bizId: String?

    public var bizType: String?

    public var extMap: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.bizType != nil {
            map["BizType"] = self.bizType!
        }
        if self.extMap != nil {
            map["ExtMap"] = self.extMap!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("BizType") && dict["BizType"] != nil {
            self.bizType = dict["BizType"] as! String
        }
        if dict.keys.contains("ExtMap") && dict["ExtMap"] != nil {
            self.extMap = dict["ExtMap"] as! String
        }
    }
}

public class UpdateProduceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class UpdateProduceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateProduceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateProduceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateProduceLoaIdRequest : Tea.TeaModel {
    public var bizId: String?

    public var loaOssKey: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.loaOssKey != nil {
            map["LoaOssKey"] = self.loaOssKey!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("LoaOssKey") && dict["LoaOssKey"] != nil {
            self.loaOssKey = dict["LoaOssKey"] as! String
        }
    }
}

public class UpdateProduceLoaIdResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateProduceLoaIdResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateProduceLoaIdResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateProduceLoaIdResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateSendMaterialNumRequest : Tea.TeaModel {
    public var bizId: String?

    public var num: String?

    public var operateType: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.num != nil {
            map["Num"] = self.num!
        }
        if self.operateType != nil {
            map["OperateType"] = self.operateType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("Num") && dict["Num"] != nil {
            self.num = dict["Num"] as! String
        }
        if dict.keys.contains("OperateType") && dict["OperateType"] != nil {
            self.operateType = dict["OperateType"] as! Int32
        }
    }
}

public class UpdateSendMaterialNumResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMsg: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["ErrorMsg"] = self.errorMsg!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMsg") && dict["ErrorMsg"] != nil {
            self.errorMsg = dict["ErrorMsg"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateSendMaterialNumResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateSendMaterialNumResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateSendMaterialNumResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateTrademarkNameRequest : Tea.TeaModel {
    public var bizId: String?

    public var clientToken: String?

    public var tmComment: String?

    public var tmIcon: String?

    public var tmName: String?

    public var type: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.tmComment != nil {
            map["TmComment"] = self.tmComment!
        }
        if self.tmIcon != nil {
            map["TmIcon"] = self.tmIcon!
        }
        if self.tmName != nil {
            map["TmName"] = self.tmName!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("TmComment") && dict["TmComment"] != nil {
            self.tmComment = dict["TmComment"] as! String
        }
        if dict.keys.contains("TmIcon") && dict["TmIcon"] != nil {
            self.tmIcon = dict["TmIcon"] as! String
        }
        if dict.keys.contains("TmName") && dict["TmName"] != nil {
            self.tmName = dict["TmName"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! Int64
        }
    }
}

public class UpdateTrademarkNameResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMsg: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["ErrorMsg"] = self.errorMsg!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMsg") && dict["ErrorMsg"] != nil {
            self.errorMsg = dict["ErrorMsg"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateTrademarkNameResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateTrademarkNameResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateTrademarkNameResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateTrademarkOnsaleRequest : Tea.TeaModel {
    public var beginTime: Int64?

    public var classificationCode: String?

    public var description_: String?

    public var endTime: Int64?

    public var label: String?

    public var originalPrice: Double?

    public var ownerEnName: String?

    public var ownerName: String?

    public var reason: String?

    public var regAnnDate: Int64?

    public var secondaryClassification: String?

    public var thirdClassification: String?

    public var tmIcon: String?

    public var tmName: String?

    public var tmNumber: String?

    public var tmType: String?

    public var tradeTmDetailJson: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.beginTime != nil {
            map["BeginTime"] = self.beginTime!
        }
        if self.classificationCode != nil {
            map["ClassificationCode"] = self.classificationCode!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.label != nil {
            map["Label"] = self.label!
        }
        if self.originalPrice != nil {
            map["OriginalPrice"] = self.originalPrice!
        }
        if self.ownerEnName != nil {
            map["OwnerEnName"] = self.ownerEnName!
        }
        if self.ownerName != nil {
            map["OwnerName"] = self.ownerName!
        }
        if self.reason != nil {
            map["Reason"] = self.reason!
        }
        if self.regAnnDate != nil {
            map["RegAnnDate"] = self.regAnnDate!
        }
        if self.secondaryClassification != nil {
            map["SecondaryClassification"] = self.secondaryClassification!
        }
        if self.thirdClassification != nil {
            map["ThirdClassification"] = self.thirdClassification!
        }
        if self.tmIcon != nil {
            map["TmIcon"] = self.tmIcon!
        }
        if self.tmName != nil {
            map["TmName"] = self.tmName!
        }
        if self.tmNumber != nil {
            map["TmNumber"] = self.tmNumber!
        }
        if self.tmType != nil {
            map["TmType"] = self.tmType!
        }
        if self.tradeTmDetailJson != nil {
            map["TradeTmDetailJson"] = self.tradeTmDetailJson!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BeginTime") && dict["BeginTime"] != nil {
            self.beginTime = dict["BeginTime"] as! Int64
        }
        if dict.keys.contains("ClassificationCode") && dict["ClassificationCode"] != nil {
            self.classificationCode = dict["ClassificationCode"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("Label") && dict["Label"] != nil {
            self.label = dict["Label"] as! String
        }
        if dict.keys.contains("OriginalPrice") && dict["OriginalPrice"] != nil {
            self.originalPrice = dict["OriginalPrice"] as! Double
        }
        if dict.keys.contains("OwnerEnName") && dict["OwnerEnName"] != nil {
            self.ownerEnName = dict["OwnerEnName"] as! String
        }
        if dict.keys.contains("OwnerName") && dict["OwnerName"] != nil {
            self.ownerName = dict["OwnerName"] as! String
        }
        if dict.keys.contains("Reason") && dict["Reason"] != nil {
            self.reason = dict["Reason"] as! String
        }
        if dict.keys.contains("RegAnnDate") && dict["RegAnnDate"] != nil {
            self.regAnnDate = dict["RegAnnDate"] as! Int64
        }
        if dict.keys.contains("SecondaryClassification") && dict["SecondaryClassification"] != nil {
            self.secondaryClassification = dict["SecondaryClassification"] as! String
        }
        if dict.keys.contains("ThirdClassification") && dict["ThirdClassification"] != nil {
            self.thirdClassification = dict["ThirdClassification"] as! String
        }
        if dict.keys.contains("TmIcon") && dict["TmIcon"] != nil {
            self.tmIcon = dict["TmIcon"] as! String
        }
        if dict.keys.contains("TmName") && dict["TmName"] != nil {
            self.tmName = dict["TmName"] as! String
        }
        if dict.keys.contains("TmNumber") && dict["TmNumber"] != nil {
            self.tmNumber = dict["TmNumber"] as! String
        }
        if dict.keys.contains("TmType") && dict["TmType"] != nil {
            self.tmType = dict["TmType"] as! String
        }
        if dict.keys.contains("TradeTmDetailJson") && dict["TradeTmDetailJson"] != nil {
            self.tradeTmDetailJson = dict["TradeTmDetailJson"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class UpdateTrademarkOnsaleResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateTrademarkOnsaleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateTrademarkOnsaleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateTrademarkOnsaleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UploadNotaryDataRequest : Tea.TeaModel {
    public var bizOrderNo: String?

    public var notaryType: Int32?

    public var uploadContext: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizOrderNo != nil {
            map["BizOrderNo"] = self.bizOrderNo!
        }
        if self.notaryType != nil {
            map["NotaryType"] = self.notaryType!
        }
        if self.uploadContext != nil {
            map["UploadContext"] = self.uploadContext!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizOrderNo") && dict["BizOrderNo"] != nil {
            self.bizOrderNo = dict["BizOrderNo"] as! String
        }
        if dict.keys.contains("NotaryType") && dict["NotaryType"] != nil {
            self.notaryType = dict["NotaryType"] as! Int32
        }
        if dict.keys.contains("UploadContext") && dict["UploadContext"] != nil {
            self.uploadContext = dict["UploadContext"] as! String
        }
    }
}

public class UploadNotaryDataResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var userAuthUrl: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.userAuthUrl != nil {
            map["UserAuthUrl"] = self.userAuthUrl!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("UserAuthUrl") && dict["UserAuthUrl"] != nil {
            self.userAuthUrl = dict["UserAuthUrl"] as! String
        }
    }
}

public class UploadNotaryDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UploadNotaryDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UploadNotaryDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UploadTrademarkOnSaleRequest : Tea.TeaModel {
    public var beginTime: Int64?

    public var classificationCode: String?

    public var description_: String?

    public var endTime: Int64?

    public var label: String?

    public var originalPrice: Double?

    public var ownerEnName: String?

    public var ownerName: String?

    public var reason: String?

    public var regAnnDate: Int64?

    public var secondaryClassification: String?

    public var status: String?

    public var thirdClassification: String?

    public var tmIcon: String?

    public var tmName: String?

    public var tmNumber: String?

    public var tmType: String?

    public var tradeTmDetailJson: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.beginTime != nil {
            map["BeginTime"] = self.beginTime!
        }
        if self.classificationCode != nil {
            map["ClassificationCode"] = self.classificationCode!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.label != nil {
            map["Label"] = self.label!
        }
        if self.originalPrice != nil {
            map["OriginalPrice"] = self.originalPrice!
        }
        if self.ownerEnName != nil {
            map["OwnerEnName"] = self.ownerEnName!
        }
        if self.ownerName != nil {
            map["OwnerName"] = self.ownerName!
        }
        if self.reason != nil {
            map["Reason"] = self.reason!
        }
        if self.regAnnDate != nil {
            map["RegAnnDate"] = self.regAnnDate!
        }
        if self.secondaryClassification != nil {
            map["SecondaryClassification"] = self.secondaryClassification!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.thirdClassification != nil {
            map["ThirdClassification"] = self.thirdClassification!
        }
        if self.tmIcon != nil {
            map["TmIcon"] = self.tmIcon!
        }
        if self.tmName != nil {
            map["TmName"] = self.tmName!
        }
        if self.tmNumber != nil {
            map["TmNumber"] = self.tmNumber!
        }
        if self.tmType != nil {
            map["TmType"] = self.tmType!
        }
        if self.tradeTmDetailJson != nil {
            map["TradeTmDetailJson"] = self.tradeTmDetailJson!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BeginTime") && dict["BeginTime"] != nil {
            self.beginTime = dict["BeginTime"] as! Int64
        }
        if dict.keys.contains("ClassificationCode") && dict["ClassificationCode"] != nil {
            self.classificationCode = dict["ClassificationCode"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("Label") && dict["Label"] != nil {
            self.label = dict["Label"] as! String
        }
        if dict.keys.contains("OriginalPrice") && dict["OriginalPrice"] != nil {
            self.originalPrice = dict["OriginalPrice"] as! Double
        }
        if dict.keys.contains("OwnerEnName") && dict["OwnerEnName"] != nil {
            self.ownerEnName = dict["OwnerEnName"] as! String
        }
        if dict.keys.contains("OwnerName") && dict["OwnerName"] != nil {
            self.ownerName = dict["OwnerName"] as! String
        }
        if dict.keys.contains("Reason") && dict["Reason"] != nil {
            self.reason = dict["Reason"] as! String
        }
        if dict.keys.contains("RegAnnDate") && dict["RegAnnDate"] != nil {
            self.regAnnDate = dict["RegAnnDate"] as! Int64
        }
        if dict.keys.contains("SecondaryClassification") && dict["SecondaryClassification"] != nil {
            self.secondaryClassification = dict["SecondaryClassification"] as! String
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("ThirdClassification") && dict["ThirdClassification"] != nil {
            self.thirdClassification = dict["ThirdClassification"] as! String
        }
        if dict.keys.contains("TmIcon") && dict["TmIcon"] != nil {
            self.tmIcon = dict["TmIcon"] as! String
        }
        if dict.keys.contains("TmName") && dict["TmName"] != nil {
            self.tmName = dict["TmName"] as! String
        }
        if dict.keys.contains("TmNumber") && dict["TmNumber"] != nil {
            self.tmNumber = dict["TmNumber"] as! String
        }
        if dict.keys.contains("TmType") && dict["TmType"] != nil {
            self.tmType = dict["TmType"] as! String
        }
        if dict.keys.contains("TradeTmDetailJson") && dict["TradeTmDetailJson"] != nil {
            self.tradeTmDetailJson = dict["TradeTmDetailJson"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class UploadTrademarkOnSaleResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UploadTrademarkOnSaleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UploadTrademarkOnSaleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UploadTrademarkOnSaleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class WriteCommunicationLogRequest : Tea.TeaModel {
    public var bizId: String?

    public var note: String?

    public var targetId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.note != nil {
            map["Note"] = self.note!
        }
        if self.targetId != nil {
            map["TargetId"] = self.targetId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("Note") && dict["Note"] != nil {
            self.note = dict["Note"] as! String
        }
        if dict.keys.contains("TargetId") && dict["TargetId"] != nil {
            self.targetId = dict["TargetId"] as! String
        }
    }
}

public class WriteCommunicationLogResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMsg: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["ErrorMsg"] = self.errorMsg!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMsg") && dict["ErrorMsg"] != nil {
            self.errorMsg = dict["ErrorMsg"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class WriteCommunicationLogResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: WriteCommunicationLogResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = WriteCommunicationLogResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class WriteIntentionCommunicationLogRequest : Tea.TeaModel {
    public var bizId: String?

    public var note: String?

    public var reject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.note != nil {
            map["Note"] = self.note!
        }
        if self.reject != nil {
            map["Reject"] = self.reject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("Note") && dict["Note"] != nil {
            self.note = dict["Note"] as! String
        }
        if dict.keys.contains("Reject") && dict["Reject"] != nil {
            self.reject = dict["Reject"] as! Bool
        }
    }
}

public class WriteIntentionCommunicationLogResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMsg: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["ErrorMsg"] = self.errorMsg!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMsg") && dict["ErrorMsg"] != nil {
            self.errorMsg = dict["ErrorMsg"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class WriteIntentionCommunicationLogResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: WriteIntentionCommunicationLogResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = WriteIntentionCommunicationLogResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}
