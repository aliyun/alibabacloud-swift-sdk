import Foundation
import Tea
import TeaUtils
import AlibabacloudOpenApi
import AlibabaCloudOpenApiUtil
import AlibabacloudEndpointUtil

public class ApplyEciScalingConfigurationRequest : Tea.TeaModel {
    public var content: String?

    public var format: String?

    public var regionId: String?

    public var scalingConfigurationId: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.format != nil {
            map["Format"] = self.format!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.scalingConfigurationId != nil {
            map["ScalingConfigurationId"] = self.scalingConfigurationId!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Content"] as? String {
            self.content = value
        }
        if let value = dict["Format"] as? String {
            self.format = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ScalingConfigurationId"] as? String {
            self.scalingConfigurationId = value
        }
        if let value = dict["ScalingGroupId"] as? String {
            self.scalingGroupId = value
        }
    }
}

public class ApplyEciScalingConfigurationResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var scalingConfigurationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingConfigurationId != nil {
            map["ScalingConfigurationId"] = self.scalingConfigurationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ScalingConfigurationId"] as? String {
            self.scalingConfigurationId = value
        }
    }
}

public class ApplyEciScalingConfigurationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ApplyEciScalingConfigurationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ApplyEciScalingConfigurationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ApplyScalingGroupRequest : Tea.TeaModel {
    public var content: String?

    public var format: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.format != nil {
            map["Format"] = self.format!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Content"] as? String {
            self.content = value
        }
        if let value = dict["Format"] as? String {
            self.format = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class ApplyScalingGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ScalingGroupId"] as? String {
            self.scalingGroupId = value
        }
    }
}

public class ApplyScalingGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ApplyScalingGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ApplyScalingGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AttachAlbServerGroupsRequest : Tea.TeaModel {
    public class AlbServerGroups : Tea.TeaModel {
        public var albServerGroupId: String?

        public var port: Int32?

        public var weight: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.albServerGroupId != nil {
                map["AlbServerGroupId"] = self.albServerGroupId!
            }
            if self.port != nil {
                map["Port"] = self.port!
            }
            if self.weight != nil {
                map["Weight"] = self.weight!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AlbServerGroupId"] as? String {
                self.albServerGroupId = value
            }
            if let value = dict["Port"] as? Int32 {
                self.port = value
            }
            if let value = dict["Weight"] as? Int32 {
                self.weight = value
            }
        }
    }
    public var albServerGroups: [AttachAlbServerGroupsRequest.AlbServerGroups]?

    public var clientToken: String?

    public var forceAttach: Bool?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.albServerGroups != nil {
            var tmp : [Any] = []
            for k in self.albServerGroups! {
                tmp.append(k.toMap())
            }
            map["AlbServerGroups"] = tmp
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.forceAttach != nil {
            map["ForceAttach"] = self.forceAttach!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AlbServerGroups"] as? [Any?] {
            var tmp : [AttachAlbServerGroupsRequest.AlbServerGroups] = []
            for v in value {
                if v != nil {
                    var model = AttachAlbServerGroupsRequest.AlbServerGroups()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.albServerGroups = tmp
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["ForceAttach"] as? Bool {
            self.forceAttach = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ScalingGroupId"] as? String {
            self.scalingGroupId = value
        }
    }
}

public class AttachAlbServerGroupsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var scalingActivityId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingActivityId != nil {
            map["ScalingActivityId"] = self.scalingActivityId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ScalingActivityId"] as? String {
            self.scalingActivityId = value
        }
    }
}

public class AttachAlbServerGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AttachAlbServerGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AttachAlbServerGroupsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AttachDBInstancesRequest : Tea.TeaModel {
    public var attachMode: String?

    public var clientToken: String?

    public var DBInstances: [String]?

    public var forceAttach: Bool?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attachMode != nil {
            map["AttachMode"] = self.attachMode!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.DBInstances != nil {
            map["DBInstances"] = self.DBInstances!
        }
        if self.forceAttach != nil {
            map["ForceAttach"] = self.forceAttach!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AttachMode"] as? String {
            self.attachMode = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DBInstances"] as? [String] {
            self.DBInstances = value
        }
        if let value = dict["ForceAttach"] as? Bool {
            self.forceAttach = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ScalingGroupId"] as? String {
            self.scalingGroupId = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
    }
}

public class AttachDBInstancesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AttachDBInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AttachDBInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AttachDBInstancesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AttachInstancesRequest : Tea.TeaModel {
    public var clientToken: String?

    public var entrusted: Bool?

    public var ignoreInvalidInstance: Bool?

    public var instanceIds: [String]?

    public var lifecycleHook: Bool?

    public var loadBalancerWeights: [Int32]?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.entrusted != nil {
            map["Entrusted"] = self.entrusted!
        }
        if self.ignoreInvalidInstance != nil {
            map["IgnoreInvalidInstance"] = self.ignoreInvalidInstance!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.lifecycleHook != nil {
            map["LifecycleHook"] = self.lifecycleHook!
        }
        if self.loadBalancerWeights != nil {
            map["LoadBalancerWeights"] = self.loadBalancerWeights!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Entrusted"] as? Bool {
            self.entrusted = value
        }
        if let value = dict["IgnoreInvalidInstance"] as? Bool {
            self.ignoreInvalidInstance = value
        }
        if let value = dict["InstanceIds"] as? [String] {
            self.instanceIds = value
        }
        if let value = dict["LifecycleHook"] as? Bool {
            self.lifecycleHook = value
        }
        if let value = dict["LoadBalancerWeights"] as? [Int32] {
            self.loadBalancerWeights = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ScalingGroupId"] as? String {
            self.scalingGroupId = value
        }
    }
}

public class AttachInstancesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var scalingActivityId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingActivityId != nil {
            map["ScalingActivityId"] = self.scalingActivityId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ScalingActivityId"] as? String {
            self.scalingActivityId = value
        }
    }
}

public class AttachInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AttachInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AttachInstancesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AttachLoadBalancersRequest : Tea.TeaModel {
    public class LoadBalancerConfigs : Tea.TeaModel {
        public var loadBalancerId: String?

        public var weight: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.loadBalancerId != nil {
                map["LoadBalancerId"] = self.loadBalancerId!
            }
            if self.weight != nil {
                map["Weight"] = self.weight!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["LoadBalancerId"] as? String {
                self.loadBalancerId = value
            }
            if let value = dict["Weight"] as? Int32 {
                self.weight = value
            }
        }
    }
    public var async: Bool?

    public var clientToken: String?

    public var forceAttach: Bool?

    public var loadBalancerConfigs: [AttachLoadBalancersRequest.LoadBalancerConfigs]?

    public var loadBalancers: [String]?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.async != nil {
            map["Async"] = self.async!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.forceAttach != nil {
            map["ForceAttach"] = self.forceAttach!
        }
        if self.loadBalancerConfigs != nil {
            var tmp : [Any] = []
            for k in self.loadBalancerConfigs! {
                tmp.append(k.toMap())
            }
            map["LoadBalancerConfigs"] = tmp
        }
        if self.loadBalancers != nil {
            map["LoadBalancers"] = self.loadBalancers!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Async"] as? Bool {
            self.async = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["ForceAttach"] as? Bool {
            self.forceAttach = value
        }
        if let value = dict["LoadBalancerConfigs"] as? [Any?] {
            var tmp : [AttachLoadBalancersRequest.LoadBalancerConfigs] = []
            for v in value {
                if v != nil {
                    var model = AttachLoadBalancersRequest.LoadBalancerConfigs()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.loadBalancerConfigs = tmp
        }
        if let value = dict["LoadBalancers"] as? [String] {
            self.loadBalancers = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ScalingGroupId"] as? String {
            self.scalingGroupId = value
        }
    }
}

public class AttachLoadBalancersResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var scalingActivityId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingActivityId != nil {
            map["ScalingActivityId"] = self.scalingActivityId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ScalingActivityId"] as? String {
            self.scalingActivityId = value
        }
    }
}

public class AttachLoadBalancersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AttachLoadBalancersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AttachLoadBalancersResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AttachServerGroupsRequest : Tea.TeaModel {
    public class ServerGroups : Tea.TeaModel {
        public var port: Int32?

        public var serverGroupId: String?

        public var type: String?

        public var weight: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.port != nil {
                map["Port"] = self.port!
            }
            if self.serverGroupId != nil {
                map["ServerGroupId"] = self.serverGroupId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.weight != nil {
                map["Weight"] = self.weight!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Port"] as? Int32 {
                self.port = value
            }
            if let value = dict["ServerGroupId"] as? String {
                self.serverGroupId = value
            }
            if let value = dict["Type"] as? String {
                self.type = value
            }
            if let value = dict["Weight"] as? Int32 {
                self.weight = value
            }
        }
    }
    public var clientToken: String?

    public var forceAttach: Bool?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public var serverGroups: [AttachServerGroupsRequest.ServerGroups]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.forceAttach != nil {
            map["ForceAttach"] = self.forceAttach!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        if self.serverGroups != nil {
            var tmp : [Any] = []
            for k in self.serverGroups! {
                tmp.append(k.toMap())
            }
            map["ServerGroups"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["ForceAttach"] as? Bool {
            self.forceAttach = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ScalingGroupId"] as? String {
            self.scalingGroupId = value
        }
        if let value = dict["ServerGroups"] as? [Any?] {
            var tmp : [AttachServerGroupsRequest.ServerGroups] = []
            for v in value {
                if v != nil {
                    var model = AttachServerGroupsRequest.ServerGroups()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.serverGroups = tmp
        }
    }
}

public class AttachServerGroupsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var scalingActivityId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingActivityId != nil {
            map["ScalingActivityId"] = self.scalingActivityId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ScalingActivityId"] as? String {
            self.scalingActivityId = value
        }
    }
}

public class AttachServerGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AttachServerGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AttachServerGroupsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AttachVServerGroupsRequest : Tea.TeaModel {
    public class VServerGroups : Tea.TeaModel {
        public class VServerGroupAttributes : Tea.TeaModel {
            public var port: Int32?

            public var VServerGroupId: String?

            public var weight: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.VServerGroupId != nil {
                    map["VServerGroupId"] = self.VServerGroupId!
                }
                if self.weight != nil {
                    map["Weight"] = self.weight!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Port"] as? Int32 {
                    self.port = value
                }
                if let value = dict["VServerGroupId"] as? String {
                    self.VServerGroupId = value
                }
                if let value = dict["Weight"] as? Int32 {
                    self.weight = value
                }
            }
        }
        public var loadBalancerId: String?

        public var VServerGroupAttributes: [AttachVServerGroupsRequest.VServerGroups.VServerGroupAttributes]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.loadBalancerId != nil {
                map["LoadBalancerId"] = self.loadBalancerId!
            }
            if self.VServerGroupAttributes != nil {
                var tmp : [Any] = []
                for k in self.VServerGroupAttributes! {
                    tmp.append(k.toMap())
                }
                map["VServerGroupAttributes"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["LoadBalancerId"] as? String {
                self.loadBalancerId = value
            }
            if let value = dict["VServerGroupAttributes"] as? [Any?] {
                var tmp : [AttachVServerGroupsRequest.VServerGroups.VServerGroupAttributes] = []
                for v in value {
                    if v != nil {
                        var model = AttachVServerGroupsRequest.VServerGroups.VServerGroupAttributes()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.VServerGroupAttributes = tmp
            }
        }
    }
    public var clientToken: String?

    public var forceAttach: Bool?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public var VServerGroups: [AttachVServerGroupsRequest.VServerGroups]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.forceAttach != nil {
            map["ForceAttach"] = self.forceAttach!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        if self.VServerGroups != nil {
            var tmp : [Any] = []
            for k in self.VServerGroups! {
                tmp.append(k.toMap())
            }
            map["VServerGroups"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["ForceAttach"] as? Bool {
            self.forceAttach = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ScalingGroupId"] as? String {
            self.scalingGroupId = value
        }
        if let value = dict["VServerGroups"] as? [Any?] {
            var tmp : [AttachVServerGroupsRequest.VServerGroups] = []
            for v in value {
                if v != nil {
                    var model = AttachVServerGroupsRequest.VServerGroups()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.VServerGroups = tmp
        }
    }
}

public class AttachVServerGroupsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AttachVServerGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AttachVServerGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AttachVServerGroupsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CancelInstanceRefreshRequest : Tea.TeaModel {
    public var instanceRefreshTaskId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceRefreshTaskId != nil {
            map["InstanceRefreshTaskId"] = self.instanceRefreshTaskId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceRefreshTaskId"] as? String {
            self.instanceRefreshTaskId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ScalingGroupId"] as? String {
            self.scalingGroupId = value
        }
    }
}

public class CancelInstanceRefreshResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CancelInstanceRefreshResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CancelInstanceRefreshResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CancelInstanceRefreshResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ChangeResourceGroupRequest : Tea.TeaModel {
    public var newResourceGroupId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceId: String?

    public var resourceOwnerAccount: String?

    public var resourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.newResourceGroupId != nil {
            map["NewResourceGroupId"] = self.newResourceGroupId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NewResourceGroupId"] as? String {
            self.newResourceGroupId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceId"] as? String {
            self.resourceId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
    }
}

public class ChangeResourceGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ChangeResourceGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ChangeResourceGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ChangeResourceGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CompleteLifecycleActionRequest : Tea.TeaModel {
    public var clientToken: String?

    public var lifecycleActionResult: String?

    public var lifecycleActionToken: String?

    public var lifecycleHookId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.lifecycleActionResult != nil {
            map["LifecycleActionResult"] = self.lifecycleActionResult!
        }
        if self.lifecycleActionToken != nil {
            map["LifecycleActionToken"] = self.lifecycleActionToken!
        }
        if self.lifecycleHookId != nil {
            map["LifecycleHookId"] = self.lifecycleHookId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["LifecycleActionResult"] as? String {
            self.lifecycleActionResult = value
        }
        if let value = dict["LifecycleActionToken"] as? String {
            self.lifecycleActionToken = value
        }
        if let value = dict["LifecycleHookId"] as? String {
            self.lifecycleHookId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
    }
}

public class CompleteLifecycleActionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CompleteLifecycleActionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CompleteLifecycleActionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CompleteLifecycleActionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateAlarmRequest : Tea.TeaModel {
    public class Dimensions : Tea.TeaModel {
        public var dimensionKey: String?

        public var dimensionValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dimensionKey != nil {
                map["DimensionKey"] = self.dimensionKey!
            }
            if self.dimensionValue != nil {
                map["DimensionValue"] = self.dimensionValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DimensionKey"] as? String {
                self.dimensionKey = value
            }
            if let value = dict["DimensionValue"] as? String {
                self.dimensionValue = value
            }
        }
    }
    public class Expressions : Tea.TeaModel {
        public var comparisonOperator: String?

        public var metricName: String?

        public var period: Int32?

        public var statistics: String?

        public var threshold: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.comparisonOperator != nil {
                map["ComparisonOperator"] = self.comparisonOperator!
            }
            if self.metricName != nil {
                map["MetricName"] = self.metricName!
            }
            if self.period != nil {
                map["Period"] = self.period!
            }
            if self.statistics != nil {
                map["Statistics"] = self.statistics!
            }
            if self.threshold != nil {
                map["Threshold"] = self.threshold!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ComparisonOperator"] as? String {
                self.comparisonOperator = value
            }
            if let value = dict["MetricName"] as? String {
                self.metricName = value
            }
            if let value = dict["Period"] as? Int32 {
                self.period = value
            }
            if let value = dict["Statistics"] as? String {
                self.statistics = value
            }
            if let value = dict["Threshold"] as? Double {
                self.threshold = value
            }
        }
    }
    public var alarmActions: [String]?

    public var comparisonOperator: String?

    public var description_: String?

    public var dimensions: [CreateAlarmRequest.Dimensions]?

    public var effective: String?

    public var evaluationCount: Int32?

    public var expressions: [CreateAlarmRequest.Expressions]?

    public var expressionsLogicOperator: String?

    public var groupId: Int32?

    public var metricName: String?

    public var metricType: String?

    public var name: String?

    public var ownerId: Int64?

    public var period: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public var statistics: String?

    public var threshold: Double?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alarmActions != nil {
            map["AlarmActions"] = self.alarmActions!
        }
        if self.comparisonOperator != nil {
            map["ComparisonOperator"] = self.comparisonOperator!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.dimensions != nil {
            var tmp : [Any] = []
            for k in self.dimensions! {
                tmp.append(k.toMap())
            }
            map["Dimensions"] = tmp
        }
        if self.effective != nil {
            map["Effective"] = self.effective!
        }
        if self.evaluationCount != nil {
            map["EvaluationCount"] = self.evaluationCount!
        }
        if self.expressions != nil {
            var tmp : [Any] = []
            for k in self.expressions! {
                tmp.append(k.toMap())
            }
            map["Expressions"] = tmp
        }
        if self.expressionsLogicOperator != nil {
            map["ExpressionsLogicOperator"] = self.expressionsLogicOperator!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.metricName != nil {
            map["MetricName"] = self.metricName!
        }
        if self.metricType != nil {
            map["MetricType"] = self.metricType!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        if self.statistics != nil {
            map["Statistics"] = self.statistics!
        }
        if self.threshold != nil {
            map["Threshold"] = self.threshold!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AlarmActions"] as? [String] {
            self.alarmActions = value
        }
        if let value = dict["ComparisonOperator"] as? String {
            self.comparisonOperator = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["Dimensions"] as? [Any?] {
            var tmp : [CreateAlarmRequest.Dimensions] = []
            for v in value {
                if v != nil {
                    var model = CreateAlarmRequest.Dimensions()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.dimensions = tmp
        }
        if let value = dict["Effective"] as? String {
            self.effective = value
        }
        if let value = dict["EvaluationCount"] as? Int32 {
            self.evaluationCount = value
        }
        if let value = dict["Expressions"] as? [Any?] {
            var tmp : [CreateAlarmRequest.Expressions] = []
            for v in value {
                if v != nil {
                    var model = CreateAlarmRequest.Expressions()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.expressions = tmp
        }
        if let value = dict["ExpressionsLogicOperator"] as? String {
            self.expressionsLogicOperator = value
        }
        if let value = dict["GroupId"] as? Int32 {
            self.groupId = value
        }
        if let value = dict["MetricName"] as? String {
            self.metricName = value
        }
        if let value = dict["MetricType"] as? String {
            self.metricType = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Period"] as? Int32 {
            self.period = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ScalingGroupId"] as? String {
            self.scalingGroupId = value
        }
        if let value = dict["Statistics"] as? String {
            self.statistics = value
        }
        if let value = dict["Threshold"] as? Double {
            self.threshold = value
        }
    }
}

public class CreateAlarmResponseBody : Tea.TeaModel {
    public var alarmTaskId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alarmTaskId != nil {
            map["AlarmTaskId"] = self.alarmTaskId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AlarmTaskId"] as? String {
            self.alarmTaskId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateAlarmResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateAlarmResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateAlarmResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateDiagnoseReportRequest : Tea.TeaModel {
    public var regionId: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ScalingGroupId"] as? String {
            self.scalingGroupId = value
        }
    }
}

public class CreateDiagnoseReportResponseBody : Tea.TeaModel {
    public var reportId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.reportId != nil {
            map["ReportId"] = self.reportId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ReportId"] as? String {
            self.reportId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateDiagnoseReportResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDiagnoseReportResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateDiagnoseReportResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateEciScalingConfigurationRequest : Tea.TeaModel {
    public class AcrRegistryInfos : Tea.TeaModel {
        public var domains: [String]?

        public var instanceId: String?

        public var instanceName: String?

        public var regionId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.domains != nil {
                map["Domains"] = self.domains!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Domains"] as? [String] {
                self.domains = value
            }
            if let value = dict["InstanceId"] as? String {
                self.instanceId = value
            }
            if let value = dict["InstanceName"] as? String {
                self.instanceName = value
            }
            if let value = dict["RegionId"] as? String {
                self.regionId = value
            }
        }
    }
    public class Containers : Tea.TeaModel {
        public class LivenessProbe : Tea.TeaModel {
            public class Exec : Tea.TeaModel {
                public var commands: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.commands != nil {
                        map["Commands"] = self.commands!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Commands"] as? [String] {
                        self.commands = value
                    }
                }
            }
            public class HttpGet : Tea.TeaModel {
                public var path: String?

                public var port: Int32?

                public var scheme: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.path != nil {
                        map["Path"] = self.path!
                    }
                    if self.port != nil {
                        map["Port"] = self.port!
                    }
                    if self.scheme != nil {
                        map["Scheme"] = self.scheme!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Path"] as? String {
                        self.path = value
                    }
                    if let value = dict["Port"] as? Int32 {
                        self.port = value
                    }
                    if let value = dict["Scheme"] as? String {
                        self.scheme = value
                    }
                }
            }
            public class TcpSocket : Tea.TeaModel {
                public var port: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.port != nil {
                        map["Port"] = self.port!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Port"] as? Int32 {
                        self.port = value
                    }
                }
            }
            public var exec: CreateEciScalingConfigurationRequest.Containers.LivenessProbe.Exec?

            public var failureThreshold: Int32?

            public var httpGet: CreateEciScalingConfigurationRequest.Containers.LivenessProbe.HttpGet?

            public var initialDelaySeconds: Int32?

            public var periodSeconds: Int32?

            public var successThreshold: Int32?

            public var tcpSocket: CreateEciScalingConfigurationRequest.Containers.LivenessProbe.TcpSocket?

            public var timeoutSeconds: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.exec?.validate()
                try self.httpGet?.validate()
                try self.tcpSocket?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.exec != nil {
                    map["Exec"] = self.exec?.toMap()
                }
                if self.failureThreshold != nil {
                    map["FailureThreshold"] = self.failureThreshold!
                }
                if self.httpGet != nil {
                    map["HttpGet"] = self.httpGet?.toMap()
                }
                if self.initialDelaySeconds != nil {
                    map["InitialDelaySeconds"] = self.initialDelaySeconds!
                }
                if self.periodSeconds != nil {
                    map["PeriodSeconds"] = self.periodSeconds!
                }
                if self.successThreshold != nil {
                    map["SuccessThreshold"] = self.successThreshold!
                }
                if self.tcpSocket != nil {
                    map["TcpSocket"] = self.tcpSocket?.toMap()
                }
                if self.timeoutSeconds != nil {
                    map["TimeoutSeconds"] = self.timeoutSeconds!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Exec"] as? [String: Any?] {
                    var model = CreateEciScalingConfigurationRequest.Containers.LivenessProbe.Exec()
                    model.fromMap(value)
                    self.exec = model
                }
                if let value = dict["FailureThreshold"] as? Int32 {
                    self.failureThreshold = value
                }
                if let value = dict["HttpGet"] as? [String: Any?] {
                    var model = CreateEciScalingConfigurationRequest.Containers.LivenessProbe.HttpGet()
                    model.fromMap(value)
                    self.httpGet = model
                }
                if let value = dict["InitialDelaySeconds"] as? Int32 {
                    self.initialDelaySeconds = value
                }
                if let value = dict["PeriodSeconds"] as? Int32 {
                    self.periodSeconds = value
                }
                if let value = dict["SuccessThreshold"] as? Int32 {
                    self.successThreshold = value
                }
                if let value = dict["TcpSocket"] as? [String: Any?] {
                    var model = CreateEciScalingConfigurationRequest.Containers.LivenessProbe.TcpSocket()
                    model.fromMap(value)
                    self.tcpSocket = model
                }
                if let value = dict["TimeoutSeconds"] as? Int32 {
                    self.timeoutSeconds = value
                }
            }
        }
        public class ReadinessProbe : Tea.TeaModel {
            public class Exec : Tea.TeaModel {
                public var commands: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.commands != nil {
                        map["Commands"] = self.commands!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Commands"] as? [String] {
                        self.commands = value
                    }
                }
            }
            public class HttpGet : Tea.TeaModel {
                public var path: String?

                public var port: Int32?

                public var scheme: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.path != nil {
                        map["Path"] = self.path!
                    }
                    if self.port != nil {
                        map["Port"] = self.port!
                    }
                    if self.scheme != nil {
                        map["Scheme"] = self.scheme!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Path"] as? String {
                        self.path = value
                    }
                    if let value = dict["Port"] as? Int32 {
                        self.port = value
                    }
                    if let value = dict["Scheme"] as? String {
                        self.scheme = value
                    }
                }
            }
            public class TcpSocket : Tea.TeaModel {
                public var port: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.port != nil {
                        map["Port"] = self.port!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Port"] as? Int32 {
                        self.port = value
                    }
                }
            }
            public var exec: CreateEciScalingConfigurationRequest.Containers.ReadinessProbe.Exec?

            public var failureThreshold: Int32?

            public var httpGet: CreateEciScalingConfigurationRequest.Containers.ReadinessProbe.HttpGet?

            public var initialDelaySeconds: Int32?

            public var periodSeconds: Int32?

            public var successThreshold: Int32?

            public var tcpSocket: CreateEciScalingConfigurationRequest.Containers.ReadinessProbe.TcpSocket?

            public var timeoutSeconds: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.exec?.validate()
                try self.httpGet?.validate()
                try self.tcpSocket?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.exec != nil {
                    map["Exec"] = self.exec?.toMap()
                }
                if self.failureThreshold != nil {
                    map["FailureThreshold"] = self.failureThreshold!
                }
                if self.httpGet != nil {
                    map["HttpGet"] = self.httpGet?.toMap()
                }
                if self.initialDelaySeconds != nil {
                    map["InitialDelaySeconds"] = self.initialDelaySeconds!
                }
                if self.periodSeconds != nil {
                    map["PeriodSeconds"] = self.periodSeconds!
                }
                if self.successThreshold != nil {
                    map["SuccessThreshold"] = self.successThreshold!
                }
                if self.tcpSocket != nil {
                    map["TcpSocket"] = self.tcpSocket?.toMap()
                }
                if self.timeoutSeconds != nil {
                    map["TimeoutSeconds"] = self.timeoutSeconds!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Exec"] as? [String: Any?] {
                    var model = CreateEciScalingConfigurationRequest.Containers.ReadinessProbe.Exec()
                    model.fromMap(value)
                    self.exec = model
                }
                if let value = dict["FailureThreshold"] as? Int32 {
                    self.failureThreshold = value
                }
                if let value = dict["HttpGet"] as? [String: Any?] {
                    var model = CreateEciScalingConfigurationRequest.Containers.ReadinessProbe.HttpGet()
                    model.fromMap(value)
                    self.httpGet = model
                }
                if let value = dict["InitialDelaySeconds"] as? Int32 {
                    self.initialDelaySeconds = value
                }
                if let value = dict["PeriodSeconds"] as? Int32 {
                    self.periodSeconds = value
                }
                if let value = dict["SuccessThreshold"] as? Int32 {
                    self.successThreshold = value
                }
                if let value = dict["TcpSocket"] as? [String: Any?] {
                    var model = CreateEciScalingConfigurationRequest.Containers.ReadinessProbe.TcpSocket()
                    model.fromMap(value)
                    self.tcpSocket = model
                }
                if let value = dict["TimeoutSeconds"] as? Int32 {
                    self.timeoutSeconds = value
                }
            }
        }
        public class SecurityContext : Tea.TeaModel {
            public class Capability : Tea.TeaModel {
                public var add: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.add != nil {
                        map["Add"] = self.add!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Add"] as? [String] {
                        self.add = value
                    }
                }
            }
            public var capability: CreateEciScalingConfigurationRequest.Containers.SecurityContext.Capability?

            public var readOnlyRootFilesystem: Bool?

            public var runAsUser: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.capability?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.capability != nil {
                    map["Capability"] = self.capability?.toMap()
                }
                if self.readOnlyRootFilesystem != nil {
                    map["ReadOnlyRootFilesystem"] = self.readOnlyRootFilesystem!
                }
                if self.runAsUser != nil {
                    map["RunAsUser"] = self.runAsUser!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Capability"] as? [String: Any?] {
                    var model = CreateEciScalingConfigurationRequest.Containers.SecurityContext.Capability()
                    model.fromMap(value)
                    self.capability = model
                }
                if let value = dict["ReadOnlyRootFilesystem"] as? Bool {
                    self.readOnlyRootFilesystem = value
                }
                if let value = dict["RunAsUser"] as? Int64 {
                    self.runAsUser = value
                }
            }
        }
        public class EnvironmentVars : Tea.TeaModel {
            public var fieldRefFieldPath: String?

            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fieldRefFieldPath != nil {
                    map["FieldRefFieldPath"] = self.fieldRefFieldPath!
                }
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["FieldRefFieldPath"] as? String {
                    self.fieldRefFieldPath = value
                }
                if let value = dict["Key"] as? String {
                    self.key = value
                }
                if let value = dict["Value"] as? String {
                    self.value = value
                }
            }
        }
        public class Ports : Tea.TeaModel {
            public var port: Int32?

            public var protocol_: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.protocol_ != nil {
                    map["Protocol"] = self.protocol_!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Port"] as? Int32 {
                    self.port = value
                }
                if let value = dict["Protocol"] as? String {
                    self.protocol_ = value
                }
            }
        }
        public class VolumeMounts : Tea.TeaModel {
            public var mountPath: String?

            public var mountPropagation: String?

            public var name: String?

            public var readOnly: Bool?

            public var subPath: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.mountPath != nil {
                    map["MountPath"] = self.mountPath!
                }
                if self.mountPropagation != nil {
                    map["MountPropagation"] = self.mountPropagation!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.readOnly != nil {
                    map["ReadOnly"] = self.readOnly!
                }
                if self.subPath != nil {
                    map["SubPath"] = self.subPath!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["MountPath"] as? String {
                    self.mountPath = value
                }
                if let value = dict["MountPropagation"] as? String {
                    self.mountPropagation = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["ReadOnly"] as? Bool {
                    self.readOnly = value
                }
                if let value = dict["SubPath"] as? String {
                    self.subPath = value
                }
            }
        }
        public var livenessProbe: CreateEciScalingConfigurationRequest.Containers.LivenessProbe?

        public var readinessProbe: CreateEciScalingConfigurationRequest.Containers.ReadinessProbe?

        public var securityContext: CreateEciScalingConfigurationRequest.Containers.SecurityContext?

        public var args: [String]?

        public var commands: [String]?

        public var cpu: Double?

        public var environmentVars: [CreateEciScalingConfigurationRequest.Containers.EnvironmentVars]?

        public var gpu: Int32?

        public var image: String?

        public var imagePullPolicy: String?

        public var lifecyclePostStartHandlerExecs: [String]?

        public var lifecyclePostStartHandlerHttpGetHost: String?

        public var lifecyclePostStartHandlerHttpGetPath: String?

        public var lifecyclePostStartHandlerHttpGetPort: Int32?

        public var lifecyclePostStartHandlerHttpGetScheme: String?

        public var lifecyclePostStartHandlerTcpSocketHost: String?

        public var lifecyclePostStartHandlerTcpSocketPort: Int32?

        public var lifecyclePreStopHandlerExecs: [String]?

        public var lifecyclePreStopHandlerHttpGetHost: String?

        public var lifecyclePreStopHandlerHttpGetPath: String?

        public var lifecyclePreStopHandlerHttpGetPort: Int32?

        public var lifecyclePreStopHandlerHttpGetScheme: String?

        public var lifecyclePreStopHandlerTcpSocketHost: String?

        public var lifecyclePreStopHandlerTcpSocketPort: Int32?

        public var memory: Double?

        public var name: String?

        public var ports: [CreateEciScalingConfigurationRequest.Containers.Ports]?

        public var stdin: Bool?

        public var stdinOnce: Bool?

        public var tty: Bool?

        public var volumeMounts: [CreateEciScalingConfigurationRequest.Containers.VolumeMounts]?

        public var workingDir: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.livenessProbe?.validate()
            try self.readinessProbe?.validate()
            try self.securityContext?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.livenessProbe != nil {
                map["LivenessProbe"] = self.livenessProbe?.toMap()
            }
            if self.readinessProbe != nil {
                map["ReadinessProbe"] = self.readinessProbe?.toMap()
            }
            if self.securityContext != nil {
                map["SecurityContext"] = self.securityContext?.toMap()
            }
            if self.args != nil {
                map["Args"] = self.args!
            }
            if self.commands != nil {
                map["Commands"] = self.commands!
            }
            if self.cpu != nil {
                map["Cpu"] = self.cpu!
            }
            if self.environmentVars != nil {
                var tmp : [Any] = []
                for k in self.environmentVars! {
                    tmp.append(k.toMap())
                }
                map["EnvironmentVars"] = tmp
            }
            if self.gpu != nil {
                map["Gpu"] = self.gpu!
            }
            if self.image != nil {
                map["Image"] = self.image!
            }
            if self.imagePullPolicy != nil {
                map["ImagePullPolicy"] = self.imagePullPolicy!
            }
            if self.lifecyclePostStartHandlerExecs != nil {
                map["LifecyclePostStartHandlerExecs"] = self.lifecyclePostStartHandlerExecs!
            }
            if self.lifecyclePostStartHandlerHttpGetHost != nil {
                map["LifecyclePostStartHandlerHttpGetHost"] = self.lifecyclePostStartHandlerHttpGetHost!
            }
            if self.lifecyclePostStartHandlerHttpGetPath != nil {
                map["LifecyclePostStartHandlerHttpGetPath"] = self.lifecyclePostStartHandlerHttpGetPath!
            }
            if self.lifecyclePostStartHandlerHttpGetPort != nil {
                map["LifecyclePostStartHandlerHttpGetPort"] = self.lifecyclePostStartHandlerHttpGetPort!
            }
            if self.lifecyclePostStartHandlerHttpGetScheme != nil {
                map["LifecyclePostStartHandlerHttpGetScheme"] = self.lifecyclePostStartHandlerHttpGetScheme!
            }
            if self.lifecyclePostStartHandlerTcpSocketHost != nil {
                map["LifecyclePostStartHandlerTcpSocketHost"] = self.lifecyclePostStartHandlerTcpSocketHost!
            }
            if self.lifecyclePostStartHandlerTcpSocketPort != nil {
                map["LifecyclePostStartHandlerTcpSocketPort"] = self.lifecyclePostStartHandlerTcpSocketPort!
            }
            if self.lifecyclePreStopHandlerExecs != nil {
                map["LifecyclePreStopHandlerExecs"] = self.lifecyclePreStopHandlerExecs!
            }
            if self.lifecyclePreStopHandlerHttpGetHost != nil {
                map["LifecyclePreStopHandlerHttpGetHost"] = self.lifecyclePreStopHandlerHttpGetHost!
            }
            if self.lifecyclePreStopHandlerHttpGetPath != nil {
                map["LifecyclePreStopHandlerHttpGetPath"] = self.lifecyclePreStopHandlerHttpGetPath!
            }
            if self.lifecyclePreStopHandlerHttpGetPort != nil {
                map["LifecyclePreStopHandlerHttpGetPort"] = self.lifecyclePreStopHandlerHttpGetPort!
            }
            if self.lifecyclePreStopHandlerHttpGetScheme != nil {
                map["LifecyclePreStopHandlerHttpGetScheme"] = self.lifecyclePreStopHandlerHttpGetScheme!
            }
            if self.lifecyclePreStopHandlerTcpSocketHost != nil {
                map["LifecyclePreStopHandlerTcpSocketHost"] = self.lifecyclePreStopHandlerTcpSocketHost!
            }
            if self.lifecyclePreStopHandlerTcpSocketPort != nil {
                map["LifecyclePreStopHandlerTcpSocketPort"] = self.lifecyclePreStopHandlerTcpSocketPort!
            }
            if self.memory != nil {
                map["Memory"] = self.memory!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.ports != nil {
                var tmp : [Any] = []
                for k in self.ports! {
                    tmp.append(k.toMap())
                }
                map["Ports"] = tmp
            }
            if self.stdin != nil {
                map["Stdin"] = self.stdin!
            }
            if self.stdinOnce != nil {
                map["StdinOnce"] = self.stdinOnce!
            }
            if self.tty != nil {
                map["Tty"] = self.tty!
            }
            if self.volumeMounts != nil {
                var tmp : [Any] = []
                for k in self.volumeMounts! {
                    tmp.append(k.toMap())
                }
                map["VolumeMounts"] = tmp
            }
            if self.workingDir != nil {
                map["WorkingDir"] = self.workingDir!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["LivenessProbe"] as? [String: Any?] {
                var model = CreateEciScalingConfigurationRequest.Containers.LivenessProbe()
                model.fromMap(value)
                self.livenessProbe = model
            }
            if let value = dict["ReadinessProbe"] as? [String: Any?] {
                var model = CreateEciScalingConfigurationRequest.Containers.ReadinessProbe()
                model.fromMap(value)
                self.readinessProbe = model
            }
            if let value = dict["SecurityContext"] as? [String: Any?] {
                var model = CreateEciScalingConfigurationRequest.Containers.SecurityContext()
                model.fromMap(value)
                self.securityContext = model
            }
            if let value = dict["Args"] as? [String] {
                self.args = value
            }
            if let value = dict["Commands"] as? [String] {
                self.commands = value
            }
            if let value = dict["Cpu"] as? Double {
                self.cpu = value
            }
            if let value = dict["EnvironmentVars"] as? [Any?] {
                var tmp : [CreateEciScalingConfigurationRequest.Containers.EnvironmentVars] = []
                for v in value {
                    if v != nil {
                        var model = CreateEciScalingConfigurationRequest.Containers.EnvironmentVars()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.environmentVars = tmp
            }
            if let value = dict["Gpu"] as? Int32 {
                self.gpu = value
            }
            if let value = dict["Image"] as? String {
                self.image = value
            }
            if let value = dict["ImagePullPolicy"] as? String {
                self.imagePullPolicy = value
            }
            if let value = dict["LifecyclePostStartHandlerExecs"] as? [String] {
                self.lifecyclePostStartHandlerExecs = value
            }
            if let value = dict["LifecyclePostStartHandlerHttpGetHost"] as? String {
                self.lifecyclePostStartHandlerHttpGetHost = value
            }
            if let value = dict["LifecyclePostStartHandlerHttpGetPath"] as? String {
                self.lifecyclePostStartHandlerHttpGetPath = value
            }
            if let value = dict["LifecyclePostStartHandlerHttpGetPort"] as? Int32 {
                self.lifecyclePostStartHandlerHttpGetPort = value
            }
            if let value = dict["LifecyclePostStartHandlerHttpGetScheme"] as? String {
                self.lifecyclePostStartHandlerHttpGetScheme = value
            }
            if let value = dict["LifecyclePostStartHandlerTcpSocketHost"] as? String {
                self.lifecyclePostStartHandlerTcpSocketHost = value
            }
            if let value = dict["LifecyclePostStartHandlerTcpSocketPort"] as? Int32 {
                self.lifecyclePostStartHandlerTcpSocketPort = value
            }
            if let value = dict["LifecyclePreStopHandlerExecs"] as? [String] {
                self.lifecyclePreStopHandlerExecs = value
            }
            if let value = dict["LifecyclePreStopHandlerHttpGetHost"] as? String {
                self.lifecyclePreStopHandlerHttpGetHost = value
            }
            if let value = dict["LifecyclePreStopHandlerHttpGetPath"] as? String {
                self.lifecyclePreStopHandlerHttpGetPath = value
            }
            if let value = dict["LifecyclePreStopHandlerHttpGetPort"] as? Int32 {
                self.lifecyclePreStopHandlerHttpGetPort = value
            }
            if let value = dict["LifecyclePreStopHandlerHttpGetScheme"] as? String {
                self.lifecyclePreStopHandlerHttpGetScheme = value
            }
            if let value = dict["LifecyclePreStopHandlerTcpSocketHost"] as? String {
                self.lifecyclePreStopHandlerTcpSocketHost = value
            }
            if let value = dict["LifecyclePreStopHandlerTcpSocketPort"] as? Int32 {
                self.lifecyclePreStopHandlerTcpSocketPort = value
            }
            if let value = dict["Memory"] as? Double {
                self.memory = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["Ports"] as? [Any?] {
                var tmp : [CreateEciScalingConfigurationRequest.Containers.Ports] = []
                for v in value {
                    if v != nil {
                        var model = CreateEciScalingConfigurationRequest.Containers.Ports()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.ports = tmp
            }
            if let value = dict["Stdin"] as? Bool {
                self.stdin = value
            }
            if let value = dict["StdinOnce"] as? Bool {
                self.stdinOnce = value
            }
            if let value = dict["Tty"] as? Bool {
                self.tty = value
            }
            if let value = dict["VolumeMounts"] as? [Any?] {
                var tmp : [CreateEciScalingConfigurationRequest.Containers.VolumeMounts] = []
                for v in value {
                    if v != nil {
                        var model = CreateEciScalingConfigurationRequest.Containers.VolumeMounts()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.volumeMounts = tmp
            }
            if let value = dict["WorkingDir"] as? String {
                self.workingDir = value
            }
        }
    }
    public class DnsConfigOptions : Tea.TeaModel {
        public var name: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public class HostAliases : Tea.TeaModel {
        public var hostnames: [String]?

        public var ip: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.hostnames != nil {
                map["Hostnames"] = self.hostnames!
            }
            if self.ip != nil {
                map["Ip"] = self.ip!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Hostnames"] as? [String] {
                self.hostnames = value
            }
            if let value = dict["Ip"] as? String {
                self.ip = value
            }
        }
    }
    public class ImageRegistryCredentials : Tea.TeaModel {
        public var password: String?

        public var server: String?

        public var userName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.password != nil {
                map["Password"] = self.password!
            }
            if self.server != nil {
                map["Server"] = self.server!
            }
            if self.userName != nil {
                map["UserName"] = self.userName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Password"] as? String {
                self.password = value
            }
            if let value = dict["Server"] as? String {
                self.server = value
            }
            if let value = dict["UserName"] as? String {
                self.userName = value
            }
        }
    }
    public class InitContainers : Tea.TeaModel {
        public class SecurityContext : Tea.TeaModel {
            public class Capability : Tea.TeaModel {
                public var adds: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.adds != nil {
                        map["Adds"] = self.adds!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Adds"] as? [String] {
                        self.adds = value
                    }
                }
            }
            public var capability: CreateEciScalingConfigurationRequest.InitContainers.SecurityContext.Capability?

            public var readOnlyRootFilesystem: Bool?

            public var runAsUser: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.capability?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.capability != nil {
                    map["Capability"] = self.capability?.toMap()
                }
                if self.readOnlyRootFilesystem != nil {
                    map["ReadOnlyRootFilesystem"] = self.readOnlyRootFilesystem!
                }
                if self.runAsUser != nil {
                    map["RunAsUser"] = self.runAsUser!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Capability"] as? [String: Any?] {
                    var model = CreateEciScalingConfigurationRequest.InitContainers.SecurityContext.Capability()
                    model.fromMap(value)
                    self.capability = model
                }
                if let value = dict["ReadOnlyRootFilesystem"] as? Bool {
                    self.readOnlyRootFilesystem = value
                }
                if let value = dict["RunAsUser"] as? Int64 {
                    self.runAsUser = value
                }
            }
        }
        public class InitContainerEnvironmentVars : Tea.TeaModel {
            public var fieldRefFieldPath: String?

            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fieldRefFieldPath != nil {
                    map["FieldRefFieldPath"] = self.fieldRefFieldPath!
                }
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["FieldRefFieldPath"] as? String {
                    self.fieldRefFieldPath = value
                }
                if let value = dict["Key"] as? String {
                    self.key = value
                }
                if let value = dict["Value"] as? String {
                    self.value = value
                }
            }
        }
        public class InitContainerPorts : Tea.TeaModel {
            public var port: Int32?

            public var protocol_: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.protocol_ != nil {
                    map["Protocol"] = self.protocol_!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Port"] as? Int32 {
                    self.port = value
                }
                if let value = dict["Protocol"] as? String {
                    self.protocol_ = value
                }
            }
        }
        public class InitContainerVolumeMounts : Tea.TeaModel {
            public var mountPath: String?

            public var mountPropagation: String?

            public var name: String?

            public var readOnly: Bool?

            public var subPath: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.mountPath != nil {
                    map["MountPath"] = self.mountPath!
                }
                if self.mountPropagation != nil {
                    map["MountPropagation"] = self.mountPropagation!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.readOnly != nil {
                    map["ReadOnly"] = self.readOnly!
                }
                if self.subPath != nil {
                    map["SubPath"] = self.subPath!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["MountPath"] as? String {
                    self.mountPath = value
                }
                if let value = dict["MountPropagation"] as? String {
                    self.mountPropagation = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["ReadOnly"] as? Bool {
                    self.readOnly = value
                }
                if let value = dict["SubPath"] as? String {
                    self.subPath = value
                }
            }
        }
        public var securityContext: CreateEciScalingConfigurationRequest.InitContainers.SecurityContext?

        public var args: [String]?

        public var commands: [String]?

        public var cpu: Double?

        public var gpu: Int32?

        public var image: String?

        public var imagePullPolicy: String?

        public var initContainerEnvironmentVars: [CreateEciScalingConfigurationRequest.InitContainers.InitContainerEnvironmentVars]?

        public var initContainerPorts: [CreateEciScalingConfigurationRequest.InitContainers.InitContainerPorts]?

        public var initContainerVolumeMounts: [CreateEciScalingConfigurationRequest.InitContainers.InitContainerVolumeMounts]?

        public var memory: Double?

        public var name: String?

        public var workingDir: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.securityContext?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.securityContext != nil {
                map["SecurityContext"] = self.securityContext?.toMap()
            }
            if self.args != nil {
                map["Args"] = self.args!
            }
            if self.commands != nil {
                map["Commands"] = self.commands!
            }
            if self.cpu != nil {
                map["Cpu"] = self.cpu!
            }
            if self.gpu != nil {
                map["Gpu"] = self.gpu!
            }
            if self.image != nil {
                map["Image"] = self.image!
            }
            if self.imagePullPolicy != nil {
                map["ImagePullPolicy"] = self.imagePullPolicy!
            }
            if self.initContainerEnvironmentVars != nil {
                var tmp : [Any] = []
                for k in self.initContainerEnvironmentVars! {
                    tmp.append(k.toMap())
                }
                map["InitContainerEnvironmentVars"] = tmp
            }
            if self.initContainerPorts != nil {
                var tmp : [Any] = []
                for k in self.initContainerPorts! {
                    tmp.append(k.toMap())
                }
                map["InitContainerPorts"] = tmp
            }
            if self.initContainerVolumeMounts != nil {
                var tmp : [Any] = []
                for k in self.initContainerVolumeMounts! {
                    tmp.append(k.toMap())
                }
                map["InitContainerVolumeMounts"] = tmp
            }
            if self.memory != nil {
                map["Memory"] = self.memory!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.workingDir != nil {
                map["WorkingDir"] = self.workingDir!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["SecurityContext"] as? [String: Any?] {
                var model = CreateEciScalingConfigurationRequest.InitContainers.SecurityContext()
                model.fromMap(value)
                self.securityContext = model
            }
            if let value = dict["Args"] as? [String] {
                self.args = value
            }
            if let value = dict["Commands"] as? [String] {
                self.commands = value
            }
            if let value = dict["Cpu"] as? Double {
                self.cpu = value
            }
            if let value = dict["Gpu"] as? Int32 {
                self.gpu = value
            }
            if let value = dict["Image"] as? String {
                self.image = value
            }
            if let value = dict["ImagePullPolicy"] as? String {
                self.imagePullPolicy = value
            }
            if let value = dict["InitContainerEnvironmentVars"] as? [Any?] {
                var tmp : [CreateEciScalingConfigurationRequest.InitContainers.InitContainerEnvironmentVars] = []
                for v in value {
                    if v != nil {
                        var model = CreateEciScalingConfigurationRequest.InitContainers.InitContainerEnvironmentVars()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.initContainerEnvironmentVars = tmp
            }
            if let value = dict["InitContainerPorts"] as? [Any?] {
                var tmp : [CreateEciScalingConfigurationRequest.InitContainers.InitContainerPorts] = []
                for v in value {
                    if v != nil {
                        var model = CreateEciScalingConfigurationRequest.InitContainers.InitContainerPorts()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.initContainerPorts = tmp
            }
            if let value = dict["InitContainerVolumeMounts"] as? [Any?] {
                var tmp : [CreateEciScalingConfigurationRequest.InitContainers.InitContainerVolumeMounts] = []
                for v in value {
                    if v != nil {
                        var model = CreateEciScalingConfigurationRequest.InitContainers.InitContainerVolumeMounts()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.initContainerVolumeMounts = tmp
            }
            if let value = dict["Memory"] as? Double {
                self.memory = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["WorkingDir"] as? String {
                self.workingDir = value
            }
        }
    }
    public class SecurityContextSysctls : Tea.TeaModel {
        public var name: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public class Volumes : Tea.TeaModel {
        public class DiskVolume : Tea.TeaModel {
            public var diskId: String?

            public var diskSize: Int32?

            public var fsType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.diskId != nil {
                    map["DiskId"] = self.diskId!
                }
                if self.diskSize != nil {
                    map["DiskSize"] = self.diskSize!
                }
                if self.fsType != nil {
                    map["FsType"] = self.fsType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DiskId"] as? String {
                    self.diskId = value
                }
                if let value = dict["DiskSize"] as? Int32 {
                    self.diskSize = value
                }
                if let value = dict["FsType"] as? String {
                    self.fsType = value
                }
            }
        }
        public class EmptyDirVolume : Tea.TeaModel {
            public var medium: String?

            public var sizeLimit: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.medium != nil {
                    map["Medium"] = self.medium!
                }
                if self.sizeLimit != nil {
                    map["SizeLimit"] = self.sizeLimit!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Medium"] as? String {
                    self.medium = value
                }
                if let value = dict["SizeLimit"] as? String {
                    self.sizeLimit = value
                }
            }
        }
        public class FlexVolume : Tea.TeaModel {
            public var driver: String?

            public var fsType: String?

            public var options: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.driver != nil {
                    map["Driver"] = self.driver!
                }
                if self.fsType != nil {
                    map["FsType"] = self.fsType!
                }
                if self.options != nil {
                    map["Options"] = self.options!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Driver"] as? String {
                    self.driver = value
                }
                if let value = dict["FsType"] as? String {
                    self.fsType = value
                }
                if let value = dict["Options"] as? String {
                    self.options = value
                }
            }
        }
        public class HostPathVolume : Tea.TeaModel {
            public var path: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.path != nil {
                    map["Path"] = self.path!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Path"] as? String {
                    self.path = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
            }
        }
        public class NFSVolume : Tea.TeaModel {
            public var path: String?

            public var readOnly: Bool?

            public var server: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.path != nil {
                    map["Path"] = self.path!
                }
                if self.readOnly != nil {
                    map["ReadOnly"] = self.readOnly!
                }
                if self.server != nil {
                    map["Server"] = self.server!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Path"] as? String {
                    self.path = value
                }
                if let value = dict["ReadOnly"] as? Bool {
                    self.readOnly = value
                }
                if let value = dict["Server"] as? String {
                    self.server = value
                }
            }
        }
        public class ConfigFileVolumeConfigFileToPaths : Tea.TeaModel {
            public var content: String?

            public var mode: Int32?

            public var path: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.content != nil {
                    map["Content"] = self.content!
                }
                if self.mode != nil {
                    map["Mode"] = self.mode!
                }
                if self.path != nil {
                    map["Path"] = self.path!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Content"] as? String {
                    self.content = value
                }
                if let value = dict["Mode"] as? Int32 {
                    self.mode = value
                }
                if let value = dict["Path"] as? String {
                    self.path = value
                }
            }
        }
        public var diskVolume: CreateEciScalingConfigurationRequest.Volumes.DiskVolume?

        public var emptyDirVolume: CreateEciScalingConfigurationRequest.Volumes.EmptyDirVolume?

        public var flexVolume: CreateEciScalingConfigurationRequest.Volumes.FlexVolume?

        public var hostPathVolume: CreateEciScalingConfigurationRequest.Volumes.HostPathVolume?

        public var NFSVolume: CreateEciScalingConfigurationRequest.Volumes.NFSVolume?

        public var configFileVolumeConfigFileToPaths: [CreateEciScalingConfigurationRequest.Volumes.ConfigFileVolumeConfigFileToPaths]?

        public var configFileVolumeDefaultMode: Int32?

        public var name: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.diskVolume?.validate()
            try self.emptyDirVolume?.validate()
            try self.flexVolume?.validate()
            try self.hostPathVolume?.validate()
            try self.NFSVolume?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.diskVolume != nil {
                map["DiskVolume"] = self.diskVolume?.toMap()
            }
            if self.emptyDirVolume != nil {
                map["EmptyDirVolume"] = self.emptyDirVolume?.toMap()
            }
            if self.flexVolume != nil {
                map["FlexVolume"] = self.flexVolume?.toMap()
            }
            if self.hostPathVolume != nil {
                map["HostPathVolume"] = self.hostPathVolume?.toMap()
            }
            if self.NFSVolume != nil {
                map["NFSVolume"] = self.NFSVolume?.toMap()
            }
            if self.configFileVolumeConfigFileToPaths != nil {
                var tmp : [Any] = []
                for k in self.configFileVolumeConfigFileToPaths! {
                    tmp.append(k.toMap())
                }
                map["ConfigFileVolumeConfigFileToPaths"] = tmp
            }
            if self.configFileVolumeDefaultMode != nil {
                map["ConfigFileVolumeDefaultMode"] = self.configFileVolumeDefaultMode!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DiskVolume"] as? [String: Any?] {
                var model = CreateEciScalingConfigurationRequest.Volumes.DiskVolume()
                model.fromMap(value)
                self.diskVolume = model
            }
            if let value = dict["EmptyDirVolume"] as? [String: Any?] {
                var model = CreateEciScalingConfigurationRequest.Volumes.EmptyDirVolume()
                model.fromMap(value)
                self.emptyDirVolume = model
            }
            if let value = dict["FlexVolume"] as? [String: Any?] {
                var model = CreateEciScalingConfigurationRequest.Volumes.FlexVolume()
                model.fromMap(value)
                self.flexVolume = model
            }
            if let value = dict["HostPathVolume"] as? [String: Any?] {
                var model = CreateEciScalingConfigurationRequest.Volumes.HostPathVolume()
                model.fromMap(value)
                self.hostPathVolume = model
            }
            if let value = dict["NFSVolume"] as? [String: Any?] {
                var model = CreateEciScalingConfigurationRequest.Volumes.NFSVolume()
                model.fromMap(value)
                self.NFSVolume = model
            }
            if let value = dict["ConfigFileVolumeConfigFileToPaths"] as? [Any?] {
                var tmp : [CreateEciScalingConfigurationRequest.Volumes.ConfigFileVolumeConfigFileToPaths] = []
                for v in value {
                    if v != nil {
                        var model = CreateEciScalingConfigurationRequest.Volumes.ConfigFileVolumeConfigFileToPaths()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.configFileVolumeConfigFileToPaths = tmp
            }
            if let value = dict["ConfigFileVolumeDefaultMode"] as? Int32 {
                self.configFileVolumeDefaultMode = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["Type"] as? String {
                self.type = value
            }
        }
    }
    public var acrRegistryInfos: [CreateEciScalingConfigurationRequest.AcrRegistryInfos]?

    public var activeDeadlineSeconds: Int64?

    public var autoCreateEip: Bool?

    public var autoMatchImageCache: Bool?

    public var containerGroupName: String?

    public var containers: [CreateEciScalingConfigurationRequest.Containers]?

    public var costOptimization: Bool?

    public var cpu: Double?

    public var cpuOptionsCore: Int32?

    public var cpuOptionsThreadsPerCore: Int32?

    public var dataCacheBucket: String?

    public var dataCacheBurstingEnabled: Bool?

    public var dataCachePL: String?

    public var dataCacheProvisionedIops: Int32?

    public var description_: String?

    public var dnsConfigNameServers: [String]?

    public var dnsConfigOptions: [CreateEciScalingConfigurationRequest.DnsConfigOptions]?

    public var dnsConfigSearchs: [String]?

    public var dnsPolicy: String?

    public var egressBandwidth: Int64?

    public var eipBandwidth: Int32?

    public var enableSls: Bool?

    public var ephemeralStorage: Int32?

    public var gpuDriverVersion: String?

    public var hostAliases: [CreateEciScalingConfigurationRequest.HostAliases]?

    public var hostName: String?

    public var imageRegistryCredentials: [CreateEciScalingConfigurationRequest.ImageRegistryCredentials]?

    public var imageSnapshotId: String?

    public var ingressBandwidth: Int64?

    public var initContainers: [CreateEciScalingConfigurationRequest.InitContainers]?

    public var instanceFamilyLevel: String?

    public var instanceTypes: [String]?

    public var ipv6AddressCount: Int32?

    public var loadBalancerWeight: Int32?

    public var memory: Double?

    public var ntpServers: [String]?

    public var ownerId: Int64?

    public var ramRoleName: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var restartPolicy: String?

    public var scalingConfigurationName: String?

    public var scalingGroupId: String?

    public var securityContextSysctls: [CreateEciScalingConfigurationRequest.SecurityContextSysctls]?

    public var securityGroupId: String?

    public var spotPriceLimit: Double?

    public var spotStrategy: String?

    public var tags: [CreateEciScalingConfigurationRequest.Tags]?

    public var terminationGracePeriodSeconds: Int64?

    public var volumes: [CreateEciScalingConfigurationRequest.Volumes]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acrRegistryInfos != nil {
            var tmp : [Any] = []
            for k in self.acrRegistryInfos! {
                tmp.append(k.toMap())
            }
            map["AcrRegistryInfos"] = tmp
        }
        if self.activeDeadlineSeconds != nil {
            map["ActiveDeadlineSeconds"] = self.activeDeadlineSeconds!
        }
        if self.autoCreateEip != nil {
            map["AutoCreateEip"] = self.autoCreateEip!
        }
        if self.autoMatchImageCache != nil {
            map["AutoMatchImageCache"] = self.autoMatchImageCache!
        }
        if self.containerGroupName != nil {
            map["ContainerGroupName"] = self.containerGroupName!
        }
        if self.containers != nil {
            var tmp : [Any] = []
            for k in self.containers! {
                tmp.append(k.toMap())
            }
            map["Containers"] = tmp
        }
        if self.costOptimization != nil {
            map["CostOptimization"] = self.costOptimization!
        }
        if self.cpu != nil {
            map["Cpu"] = self.cpu!
        }
        if self.cpuOptionsCore != nil {
            map["CpuOptionsCore"] = self.cpuOptionsCore!
        }
        if self.cpuOptionsThreadsPerCore != nil {
            map["CpuOptionsThreadsPerCore"] = self.cpuOptionsThreadsPerCore!
        }
        if self.dataCacheBucket != nil {
            map["DataCacheBucket"] = self.dataCacheBucket!
        }
        if self.dataCacheBurstingEnabled != nil {
            map["DataCacheBurstingEnabled"] = self.dataCacheBurstingEnabled!
        }
        if self.dataCachePL != nil {
            map["DataCachePL"] = self.dataCachePL!
        }
        if self.dataCacheProvisionedIops != nil {
            map["DataCacheProvisionedIops"] = self.dataCacheProvisionedIops!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.dnsConfigNameServers != nil {
            map["DnsConfigNameServers"] = self.dnsConfigNameServers!
        }
        if self.dnsConfigOptions != nil {
            var tmp : [Any] = []
            for k in self.dnsConfigOptions! {
                tmp.append(k.toMap())
            }
            map["DnsConfigOptions"] = tmp
        }
        if self.dnsConfigSearchs != nil {
            map["DnsConfigSearchs"] = self.dnsConfigSearchs!
        }
        if self.dnsPolicy != nil {
            map["DnsPolicy"] = self.dnsPolicy!
        }
        if self.egressBandwidth != nil {
            map["EgressBandwidth"] = self.egressBandwidth!
        }
        if self.eipBandwidth != nil {
            map["EipBandwidth"] = self.eipBandwidth!
        }
        if self.enableSls != nil {
            map["EnableSls"] = self.enableSls!
        }
        if self.ephemeralStorage != nil {
            map["EphemeralStorage"] = self.ephemeralStorage!
        }
        if self.gpuDriverVersion != nil {
            map["GpuDriverVersion"] = self.gpuDriverVersion!
        }
        if self.hostAliases != nil {
            var tmp : [Any] = []
            for k in self.hostAliases! {
                tmp.append(k.toMap())
            }
            map["HostAliases"] = tmp
        }
        if self.hostName != nil {
            map["HostName"] = self.hostName!
        }
        if self.imageRegistryCredentials != nil {
            var tmp : [Any] = []
            for k in self.imageRegistryCredentials! {
                tmp.append(k.toMap())
            }
            map["ImageRegistryCredentials"] = tmp
        }
        if self.imageSnapshotId != nil {
            map["ImageSnapshotId"] = self.imageSnapshotId!
        }
        if self.ingressBandwidth != nil {
            map["IngressBandwidth"] = self.ingressBandwidth!
        }
        if self.initContainers != nil {
            var tmp : [Any] = []
            for k in self.initContainers! {
                tmp.append(k.toMap())
            }
            map["InitContainers"] = tmp
        }
        if self.instanceFamilyLevel != nil {
            map["InstanceFamilyLevel"] = self.instanceFamilyLevel!
        }
        if self.instanceTypes != nil {
            map["InstanceTypes"] = self.instanceTypes!
        }
        if self.ipv6AddressCount != nil {
            map["Ipv6AddressCount"] = self.ipv6AddressCount!
        }
        if self.loadBalancerWeight != nil {
            map["LoadBalancerWeight"] = self.loadBalancerWeight!
        }
        if self.memory != nil {
            map["Memory"] = self.memory!
        }
        if self.ntpServers != nil {
            map["NtpServers"] = self.ntpServers!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.ramRoleName != nil {
            map["RamRoleName"] = self.ramRoleName!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.restartPolicy != nil {
            map["RestartPolicy"] = self.restartPolicy!
        }
        if self.scalingConfigurationName != nil {
            map["ScalingConfigurationName"] = self.scalingConfigurationName!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        if self.securityContextSysctls != nil {
            var tmp : [Any] = []
            for k in self.securityContextSysctls! {
                tmp.append(k.toMap())
            }
            map["SecurityContextSysctls"] = tmp
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.spotPriceLimit != nil {
            map["SpotPriceLimit"] = self.spotPriceLimit!
        }
        if self.spotStrategy != nil {
            map["SpotStrategy"] = self.spotStrategy!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        if self.terminationGracePeriodSeconds != nil {
            map["TerminationGracePeriodSeconds"] = self.terminationGracePeriodSeconds!
        }
        if self.volumes != nil {
            var tmp : [Any] = []
            for k in self.volumes! {
                tmp.append(k.toMap())
            }
            map["Volumes"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AcrRegistryInfos"] as? [Any?] {
            var tmp : [CreateEciScalingConfigurationRequest.AcrRegistryInfos] = []
            for v in value {
                if v != nil {
                    var model = CreateEciScalingConfigurationRequest.AcrRegistryInfos()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.acrRegistryInfos = tmp
        }
        if let value = dict["ActiveDeadlineSeconds"] as? Int64 {
            self.activeDeadlineSeconds = value
        }
        if let value = dict["AutoCreateEip"] as? Bool {
            self.autoCreateEip = value
        }
        if let value = dict["AutoMatchImageCache"] as? Bool {
            self.autoMatchImageCache = value
        }
        if let value = dict["ContainerGroupName"] as? String {
            self.containerGroupName = value
        }
        if let value = dict["Containers"] as? [Any?] {
            var tmp : [CreateEciScalingConfigurationRequest.Containers] = []
            for v in value {
                if v != nil {
                    var model = CreateEciScalingConfigurationRequest.Containers()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.containers = tmp
        }
        if let value = dict["CostOptimization"] as? Bool {
            self.costOptimization = value
        }
        if let value = dict["Cpu"] as? Double {
            self.cpu = value
        }
        if let value = dict["CpuOptionsCore"] as? Int32 {
            self.cpuOptionsCore = value
        }
        if let value = dict["CpuOptionsThreadsPerCore"] as? Int32 {
            self.cpuOptionsThreadsPerCore = value
        }
        if let value = dict["DataCacheBucket"] as? String {
            self.dataCacheBucket = value
        }
        if let value = dict["DataCacheBurstingEnabled"] as? Bool {
            self.dataCacheBurstingEnabled = value
        }
        if let value = dict["DataCachePL"] as? String {
            self.dataCachePL = value
        }
        if let value = dict["DataCacheProvisionedIops"] as? Int32 {
            self.dataCacheProvisionedIops = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["DnsConfigNameServers"] as? [String] {
            self.dnsConfigNameServers = value
        }
        if let value = dict["DnsConfigOptions"] as? [Any?] {
            var tmp : [CreateEciScalingConfigurationRequest.DnsConfigOptions] = []
            for v in value {
                if v != nil {
                    var model = CreateEciScalingConfigurationRequest.DnsConfigOptions()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.dnsConfigOptions = tmp
        }
        if let value = dict["DnsConfigSearchs"] as? [String] {
            self.dnsConfigSearchs = value
        }
        if let value = dict["DnsPolicy"] as? String {
            self.dnsPolicy = value
        }
        if let value = dict["EgressBandwidth"] as? Int64 {
            self.egressBandwidth = value
        }
        if let value = dict["EipBandwidth"] as? Int32 {
            self.eipBandwidth = value
        }
        if let value = dict["EnableSls"] as? Bool {
            self.enableSls = value
        }
        if let value = dict["EphemeralStorage"] as? Int32 {
            self.ephemeralStorage = value
        }
        if let value = dict["GpuDriverVersion"] as? String {
            self.gpuDriverVersion = value
        }
        if let value = dict["HostAliases"] as? [Any?] {
            var tmp : [CreateEciScalingConfigurationRequest.HostAliases] = []
            for v in value {
                if v != nil {
                    var model = CreateEciScalingConfigurationRequest.HostAliases()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.hostAliases = tmp
        }
        if let value = dict["HostName"] as? String {
            self.hostName = value
        }
        if let value = dict["ImageRegistryCredentials"] as? [Any?] {
            var tmp : [CreateEciScalingConfigurationRequest.ImageRegistryCredentials] = []
            for v in value {
                if v != nil {
                    var model = CreateEciScalingConfigurationRequest.ImageRegistryCredentials()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.imageRegistryCredentials = tmp
        }
        if let value = dict["ImageSnapshotId"] as? String {
            self.imageSnapshotId = value
        }
        if let value = dict["IngressBandwidth"] as? Int64 {
            self.ingressBandwidth = value
        }
        if let value = dict["InitContainers"] as? [Any?] {
            var tmp : [CreateEciScalingConfigurationRequest.InitContainers] = []
            for v in value {
                if v != nil {
                    var model = CreateEciScalingConfigurationRequest.InitContainers()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.initContainers = tmp
        }
        if let value = dict["InstanceFamilyLevel"] as? String {
            self.instanceFamilyLevel = value
        }
        if let value = dict["InstanceTypes"] as? [String] {
            self.instanceTypes = value
        }
        if let value = dict["Ipv6AddressCount"] as? Int32 {
            self.ipv6AddressCount = value
        }
        if let value = dict["LoadBalancerWeight"] as? Int32 {
            self.loadBalancerWeight = value
        }
        if let value = dict["Memory"] as? Double {
            self.memory = value
        }
        if let value = dict["NtpServers"] as? [String] {
            self.ntpServers = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RamRoleName"] as? String {
            self.ramRoleName = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["RestartPolicy"] as? String {
            self.restartPolicy = value
        }
        if let value = dict["ScalingConfigurationName"] as? String {
            self.scalingConfigurationName = value
        }
        if let value = dict["ScalingGroupId"] as? String {
            self.scalingGroupId = value
        }
        if let value = dict["SecurityContextSysctls"] as? [Any?] {
            var tmp : [CreateEciScalingConfigurationRequest.SecurityContextSysctls] = []
            for v in value {
                if v != nil {
                    var model = CreateEciScalingConfigurationRequest.SecurityContextSysctls()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.securityContextSysctls = tmp
        }
        if let value = dict["SecurityGroupId"] as? String {
            self.securityGroupId = value
        }
        if let value = dict["SpotPriceLimit"] as? Double {
            self.spotPriceLimit = value
        }
        if let value = dict["SpotStrategy"] as? String {
            self.spotStrategy = value
        }
        if let value = dict["Tags"] as? [Any?] {
            var tmp : [CreateEciScalingConfigurationRequest.Tags] = []
            for v in value {
                if v != nil {
                    var model = CreateEciScalingConfigurationRequest.Tags()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tags = tmp
        }
        if let value = dict["TerminationGracePeriodSeconds"] as? Int64 {
            self.terminationGracePeriodSeconds = value
        }
        if let value = dict["Volumes"] as? [Any?] {
            var tmp : [CreateEciScalingConfigurationRequest.Volumes] = []
            for v in value {
                if v != nil {
                    var model = CreateEciScalingConfigurationRequest.Volumes()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.volumes = tmp
        }
    }
}

public class CreateEciScalingConfigurationResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var scalingConfigurationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingConfigurationId != nil {
            map["ScalingConfigurationId"] = self.scalingConfigurationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ScalingConfigurationId"] as? String {
            self.scalingConfigurationId = value
        }
    }
}

public class CreateEciScalingConfigurationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateEciScalingConfigurationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateEciScalingConfigurationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateLifecycleHookRequest : Tea.TeaModel {
    public var defaultResult: String?

    public var heartbeatTimeout: Int32?

    public var lifecycleHookName: String?

    public var lifecycleTransition: String?

    public var notificationArn: String?

    public var notificationMetadata: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.defaultResult != nil {
            map["DefaultResult"] = self.defaultResult!
        }
        if self.heartbeatTimeout != nil {
            map["HeartbeatTimeout"] = self.heartbeatTimeout!
        }
        if self.lifecycleHookName != nil {
            map["LifecycleHookName"] = self.lifecycleHookName!
        }
        if self.lifecycleTransition != nil {
            map["LifecycleTransition"] = self.lifecycleTransition!
        }
        if self.notificationArn != nil {
            map["NotificationArn"] = self.notificationArn!
        }
        if self.notificationMetadata != nil {
            map["NotificationMetadata"] = self.notificationMetadata!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DefaultResult"] as? String {
            self.defaultResult = value
        }
        if let value = dict["HeartbeatTimeout"] as? Int32 {
            self.heartbeatTimeout = value
        }
        if let value = dict["LifecycleHookName"] as? String {
            self.lifecycleHookName = value
        }
        if let value = dict["LifecycleTransition"] as? String {
            self.lifecycleTransition = value
        }
        if let value = dict["NotificationArn"] as? String {
            self.notificationArn = value
        }
        if let value = dict["NotificationMetadata"] as? String {
            self.notificationMetadata = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ScalingGroupId"] as? String {
            self.scalingGroupId = value
        }
    }
}

public class CreateLifecycleHookResponseBody : Tea.TeaModel {
    public var lifecycleHookId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lifecycleHookId != nil {
            map["LifecycleHookId"] = self.lifecycleHookId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["LifecycleHookId"] as? String {
            self.lifecycleHookId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateLifecycleHookResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateLifecycleHookResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateLifecycleHookResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateNotificationConfigurationRequest : Tea.TeaModel {
    public var notificationArn: String?

    public var notificationTypes: [String]?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public var timeZone: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.notificationArn != nil {
            map["NotificationArn"] = self.notificationArn!
        }
        if self.notificationTypes != nil {
            map["NotificationTypes"] = self.notificationTypes!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        if self.timeZone != nil {
            map["TimeZone"] = self.timeZone!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NotificationArn"] as? String {
            self.notificationArn = value
        }
        if let value = dict["NotificationTypes"] as? [String] {
            self.notificationTypes = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ScalingGroupId"] as? String {
            self.scalingGroupId = value
        }
        if let value = dict["TimeZone"] as? String {
            self.timeZone = value
        }
    }
}

public class CreateNotificationConfigurationResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateNotificationConfigurationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateNotificationConfigurationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateNotificationConfigurationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateScalingConfigurationRequest : Tea.TeaModel {
    public class ImageOptions : Tea.TeaModel {
        public var loginAsNonRoot: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.loginAsNonRoot != nil {
                map["LoginAsNonRoot"] = self.loginAsNonRoot!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["LoginAsNonRoot"] as? Bool {
                self.loginAsNonRoot = value
            }
        }
    }
    public class PrivatePoolOptions : Tea.TeaModel {
        public var id: String?

        public var matchCriteria: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.matchCriteria != nil {
                map["MatchCriteria"] = self.matchCriteria!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Id"] as? String {
                self.id = value
            }
            if let value = dict["MatchCriteria"] as? String {
                self.matchCriteria = value
            }
        }
    }
    public class SystemDisk : Tea.TeaModel {
        public var autoSnapshotPolicyId: String?

        public var burstingEnabled: Bool?

        public var category: String?

        public var description_: String?

        public var diskName: String?

        public var encryptAlgorithm: String?

        public var encrypted: Bool?

        public var KMSKeyId: String?

        public var performanceLevel: String?

        public var provisionedIops: Int64?

        public var size: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.autoSnapshotPolicyId != nil {
                map["AutoSnapshotPolicyId"] = self.autoSnapshotPolicyId!
            }
            if self.burstingEnabled != nil {
                map["BurstingEnabled"] = self.burstingEnabled!
            }
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.diskName != nil {
                map["DiskName"] = self.diskName!
            }
            if self.encryptAlgorithm != nil {
                map["EncryptAlgorithm"] = self.encryptAlgorithm!
            }
            if self.encrypted != nil {
                map["Encrypted"] = self.encrypted!
            }
            if self.KMSKeyId != nil {
                map["KMSKeyId"] = self.KMSKeyId!
            }
            if self.performanceLevel != nil {
                map["PerformanceLevel"] = self.performanceLevel!
            }
            if self.provisionedIops != nil {
                map["ProvisionedIops"] = self.provisionedIops!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AutoSnapshotPolicyId"] as? String {
                self.autoSnapshotPolicyId = value
            }
            if let value = dict["BurstingEnabled"] as? Bool {
                self.burstingEnabled = value
            }
            if let value = dict["Category"] as? String {
                self.category = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["DiskName"] as? String {
                self.diskName = value
            }
            if let value = dict["EncryptAlgorithm"] as? String {
                self.encryptAlgorithm = value
            }
            if let value = dict["Encrypted"] as? Bool {
                self.encrypted = value
            }
            if let value = dict["KMSKeyId"] as? String {
                self.KMSKeyId = value
            }
            if let value = dict["PerformanceLevel"] as? String {
                self.performanceLevel = value
            }
            if let value = dict["ProvisionedIops"] as? Int64 {
                self.provisionedIops = value
            }
            if let value = dict["Size"] as? Int32 {
                self.size = value
            }
        }
    }
    public class CustomPriorities : Tea.TeaModel {
        public var instanceType: String?

        public var vswitchId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.vswitchId != nil {
                map["VswitchId"] = self.vswitchId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["InstanceType"] as? String {
                self.instanceType = value
            }
            if let value = dict["VswitchId"] as? String {
                self.vswitchId = value
            }
        }
    }
    public class DataDisks : Tea.TeaModel {
        public var autoSnapshotPolicyId: String?

        public var burstingEnabled: Bool?

        public var categories: [String]?

        public var category: String?

        public var deleteWithInstance: Bool?

        public var description_: String?

        public var device: String?

        public var diskName: String?

        public var encrypted: String?

        public var KMSKeyId: String?

        public var performanceLevel: String?

        public var provisionedIops: Int64?

        public var size: Int32?

        public var snapshotId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.autoSnapshotPolicyId != nil {
                map["AutoSnapshotPolicyId"] = self.autoSnapshotPolicyId!
            }
            if self.burstingEnabled != nil {
                map["BurstingEnabled"] = self.burstingEnabled!
            }
            if self.categories != nil {
                map["Categories"] = self.categories!
            }
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.deleteWithInstance != nil {
                map["DeleteWithInstance"] = self.deleteWithInstance!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.device != nil {
                map["Device"] = self.device!
            }
            if self.diskName != nil {
                map["DiskName"] = self.diskName!
            }
            if self.encrypted != nil {
                map["Encrypted"] = self.encrypted!
            }
            if self.KMSKeyId != nil {
                map["KMSKeyId"] = self.KMSKeyId!
            }
            if self.performanceLevel != nil {
                map["PerformanceLevel"] = self.performanceLevel!
            }
            if self.provisionedIops != nil {
                map["ProvisionedIops"] = self.provisionedIops!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.snapshotId != nil {
                map["SnapshotId"] = self.snapshotId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AutoSnapshotPolicyId"] as? String {
                self.autoSnapshotPolicyId = value
            }
            if let value = dict["BurstingEnabled"] as? Bool {
                self.burstingEnabled = value
            }
            if let value = dict["Categories"] as? [String] {
                self.categories = value
            }
            if let value = dict["Category"] as? String {
                self.category = value
            }
            if let value = dict["DeleteWithInstance"] as? Bool {
                self.deleteWithInstance = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["Device"] as? String {
                self.device = value
            }
            if let value = dict["DiskName"] as? String {
                self.diskName = value
            }
            if let value = dict["Encrypted"] as? String {
                self.encrypted = value
            }
            if let value = dict["KMSKeyId"] as? String {
                self.KMSKeyId = value
            }
            if let value = dict["PerformanceLevel"] as? String {
                self.performanceLevel = value
            }
            if let value = dict["ProvisionedIops"] as? Int64 {
                self.provisionedIops = value
            }
            if let value = dict["Size"] as? Int32 {
                self.size = value
            }
            if let value = dict["SnapshotId"] as? String {
                self.snapshotId = value
            }
        }
    }
    public class InstancePatternInfos : Tea.TeaModel {
        public var architectures: [String]?

        public var burstablePerformance: String?

        public var cores: Int32?

        public var cpuArchitectures: [String]?

        public var excludedInstanceTypes: [String]?

        public var gpuSpecs: [String]?

        public var instanceCategories: [String]?

        public var instanceFamilyLevel: String?

        public var instanceTypeFamilies: [String]?

        public var maxPrice: Double?

        public var maximumCpuCoreCount: Int32?

        public var maximumGpuAmount: Int32?

        public var maximumMemorySize: Double?

        public var memory: Double?

        public var minimumBaselineCredit: Int32?

        public var minimumCpuCoreCount: Int32?

        public var minimumEniIpv6AddressQuantity: Int32?

        public var minimumEniPrivateIpAddressQuantity: Int32?

        public var minimumEniQuantity: Int32?

        public var minimumGpuAmount: Int32?

        public var minimumInitialCredit: Int32?

        public var minimumMemorySize: Double?

        public var physicalProcessorModels: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.architectures != nil {
                map["Architectures"] = self.architectures!
            }
            if self.burstablePerformance != nil {
                map["BurstablePerformance"] = self.burstablePerformance!
            }
            if self.cores != nil {
                map["Cores"] = self.cores!
            }
            if self.cpuArchitectures != nil {
                map["CpuArchitectures"] = self.cpuArchitectures!
            }
            if self.excludedInstanceTypes != nil {
                map["ExcludedInstanceTypes"] = self.excludedInstanceTypes!
            }
            if self.gpuSpecs != nil {
                map["GpuSpecs"] = self.gpuSpecs!
            }
            if self.instanceCategories != nil {
                map["InstanceCategories"] = self.instanceCategories!
            }
            if self.instanceFamilyLevel != nil {
                map["InstanceFamilyLevel"] = self.instanceFamilyLevel!
            }
            if self.instanceTypeFamilies != nil {
                map["InstanceTypeFamilies"] = self.instanceTypeFamilies!
            }
            if self.maxPrice != nil {
                map["MaxPrice"] = self.maxPrice!
            }
            if self.maximumCpuCoreCount != nil {
                map["MaximumCpuCoreCount"] = self.maximumCpuCoreCount!
            }
            if self.maximumGpuAmount != nil {
                map["MaximumGpuAmount"] = self.maximumGpuAmount!
            }
            if self.maximumMemorySize != nil {
                map["MaximumMemorySize"] = self.maximumMemorySize!
            }
            if self.memory != nil {
                map["Memory"] = self.memory!
            }
            if self.minimumBaselineCredit != nil {
                map["MinimumBaselineCredit"] = self.minimumBaselineCredit!
            }
            if self.minimumCpuCoreCount != nil {
                map["MinimumCpuCoreCount"] = self.minimumCpuCoreCount!
            }
            if self.minimumEniIpv6AddressQuantity != nil {
                map["MinimumEniIpv6AddressQuantity"] = self.minimumEniIpv6AddressQuantity!
            }
            if self.minimumEniPrivateIpAddressQuantity != nil {
                map["MinimumEniPrivateIpAddressQuantity"] = self.minimumEniPrivateIpAddressQuantity!
            }
            if self.minimumEniQuantity != nil {
                map["MinimumEniQuantity"] = self.minimumEniQuantity!
            }
            if self.minimumGpuAmount != nil {
                map["MinimumGpuAmount"] = self.minimumGpuAmount!
            }
            if self.minimumInitialCredit != nil {
                map["MinimumInitialCredit"] = self.minimumInitialCredit!
            }
            if self.minimumMemorySize != nil {
                map["MinimumMemorySize"] = self.minimumMemorySize!
            }
            if self.physicalProcessorModels != nil {
                map["PhysicalProcessorModels"] = self.physicalProcessorModels!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Architectures"] as? [String] {
                self.architectures = value
            }
            if let value = dict["BurstablePerformance"] as? String {
                self.burstablePerformance = value
            }
            if let value = dict["Cores"] as? Int32 {
                self.cores = value
            }
            if let value = dict["CpuArchitectures"] as? [String] {
                self.cpuArchitectures = value
            }
            if let value = dict["ExcludedInstanceTypes"] as? [String] {
                self.excludedInstanceTypes = value
            }
            if let value = dict["GpuSpecs"] as? [String] {
                self.gpuSpecs = value
            }
            if let value = dict["InstanceCategories"] as? [String] {
                self.instanceCategories = value
            }
            if let value = dict["InstanceFamilyLevel"] as? String {
                self.instanceFamilyLevel = value
            }
            if let value = dict["InstanceTypeFamilies"] as? [String] {
                self.instanceTypeFamilies = value
            }
            if let value = dict["MaxPrice"] as? Double {
                self.maxPrice = value
            }
            if let value = dict["MaximumCpuCoreCount"] as? Int32 {
                self.maximumCpuCoreCount = value
            }
            if let value = dict["MaximumGpuAmount"] as? Int32 {
                self.maximumGpuAmount = value
            }
            if let value = dict["MaximumMemorySize"] as? Double {
                self.maximumMemorySize = value
            }
            if let value = dict["Memory"] as? Double {
                self.memory = value
            }
            if let value = dict["MinimumBaselineCredit"] as? Int32 {
                self.minimumBaselineCredit = value
            }
            if let value = dict["MinimumCpuCoreCount"] as? Int32 {
                self.minimumCpuCoreCount = value
            }
            if let value = dict["MinimumEniIpv6AddressQuantity"] as? Int32 {
                self.minimumEniIpv6AddressQuantity = value
            }
            if let value = dict["MinimumEniPrivateIpAddressQuantity"] as? Int32 {
                self.minimumEniPrivateIpAddressQuantity = value
            }
            if let value = dict["MinimumEniQuantity"] as? Int32 {
                self.minimumEniQuantity = value
            }
            if let value = dict["MinimumGpuAmount"] as? Int32 {
                self.minimumGpuAmount = value
            }
            if let value = dict["MinimumInitialCredit"] as? Int32 {
                self.minimumInitialCredit = value
            }
            if let value = dict["MinimumMemorySize"] as? Double {
                self.minimumMemorySize = value
            }
            if let value = dict["PhysicalProcessorModels"] as? [String] {
                self.physicalProcessorModels = value
            }
        }
    }
    public class InstanceTypeOverrides : Tea.TeaModel {
        public var instanceType: String?

        public var weightedCapacity: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.weightedCapacity != nil {
                map["WeightedCapacity"] = self.weightedCapacity!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["InstanceType"] as? String {
                self.instanceType = value
            }
            if let value = dict["WeightedCapacity"] as? Int32 {
                self.weightedCapacity = value
            }
        }
    }
    public class NetworkInterfaces : Tea.TeaModel {
        public var instanceType: String?

        public var ipv6AddressCount: Int32?

        public var networkInterfaceTrafficMode: String?

        public var securityGroupIds: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.ipv6AddressCount != nil {
                map["Ipv6AddressCount"] = self.ipv6AddressCount!
            }
            if self.networkInterfaceTrafficMode != nil {
                map["NetworkInterfaceTrafficMode"] = self.networkInterfaceTrafficMode!
            }
            if self.securityGroupIds != nil {
                map["SecurityGroupIds"] = self.securityGroupIds!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["InstanceType"] as? String {
                self.instanceType = value
            }
            if let value = dict["Ipv6AddressCount"] as? Int32 {
                self.ipv6AddressCount = value
            }
            if let value = dict["NetworkInterfaceTrafficMode"] as? String {
                self.networkInterfaceTrafficMode = value
            }
            if let value = dict["SecurityGroupIds"] as? [String] {
                self.securityGroupIds = value
            }
        }
    }
    public class ResourcePoolOptions : Tea.TeaModel {
        public var privatePoolIds: [String]?

        public var strategy: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.privatePoolIds != nil {
                map["PrivatePoolIds"] = self.privatePoolIds!
            }
            if self.strategy != nil {
                map["Strategy"] = self.strategy!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["PrivatePoolIds"] as? [String] {
                self.privatePoolIds = value
            }
            if let value = dict["Strategy"] as? String {
                self.strategy = value
            }
        }
    }
    public class SecurityOptions : Tea.TeaModel {
        public var confidentialComputingMode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.confidentialComputingMode != nil {
                map["ConfidentialComputingMode"] = self.confidentialComputingMode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ConfidentialComputingMode"] as? String {
                self.confidentialComputingMode = value
            }
        }
    }
    public class SpotPriceLimits : Tea.TeaModel {
        public var instanceType: String?

        public var priceLimit: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.priceLimit != nil {
                map["PriceLimit"] = self.priceLimit!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["InstanceType"] as? String {
                self.instanceType = value
            }
            if let value = dict["PriceLimit"] as? Double {
                self.priceLimit = value
            }
        }
    }
    public var imageOptions: CreateScalingConfigurationRequest.ImageOptions?

    public var privatePoolOptions: CreateScalingConfigurationRequest.PrivatePoolOptions?

    public var systemDisk: CreateScalingConfigurationRequest.SystemDisk?

    public var affinity: String?

    public var clientToken: String?

    public var cpu: Int32?

    public var creditSpecification: String?

    public var customPriorities: [CreateScalingConfigurationRequest.CustomPriorities]?

    public var dataDisks: [CreateScalingConfigurationRequest.DataDisks]?

    public var dedicatedHostClusterId: String?

    public var dedicatedHostId: String?

    public var deletionProtection: Bool?

    public var deploymentSetId: String?

    public var hostName: String?

    public var hpcClusterId: String?

    public var httpEndpoint: String?

    public var httpTokens: String?

    public var imageFamily: String?

    public var imageId: String?

    public var imageName: String?

    public var instanceDescription: String?

    public var instanceName: String?

    public var instancePatternInfos: [CreateScalingConfigurationRequest.InstancePatternInfos]?

    public var instanceType: String?

    public var instanceTypeOverrides: [CreateScalingConfigurationRequest.InstanceTypeOverrides]?

    public var instanceTypes: [String]?

    public var internetChargeType: String?

    public var internetMaxBandwidthIn: Int32?

    public var internetMaxBandwidthOut: Int32?

    public var ioOptimized: String?

    public var ipv6AddressCount: Int32?

    public var keyPairName: String?

    public var loadBalancerWeight: Int32?

    public var memory: Int32?

    public var networkInterfaces: [CreateScalingConfigurationRequest.NetworkInterfaces]?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var password: String?

    public var passwordInherit: Bool?

    public var ramRoleName: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourcePoolOptions: CreateScalingConfigurationRequest.ResourcePoolOptions?

    public var scalingConfigurationName: String?

    public var scalingGroupId: String?

    public var schedulerOptions: [String: Any]?

    public var securityEnhancementStrategy: String?

    public var securityGroupId: String?

    public var securityGroupIds: [String]?

    public var securityOptions: CreateScalingConfigurationRequest.SecurityOptions?

    public var spotDuration: Int32?

    public var spotInterruptionBehavior: String?

    public var spotPriceLimits: [CreateScalingConfigurationRequest.SpotPriceLimits]?

    public var spotStrategy: String?

    public var storageSetId: String?

    public var storageSetPartitionNumber: Int32?

    public var systemDiskCategories: [String]?

    public var tags: String?

    public var tenancy: String?

    public var userData: String?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.imageOptions?.validate()
        try self.privatePoolOptions?.validate()
        try self.systemDisk?.validate()
        try self.resourcePoolOptions?.validate()
        try self.securityOptions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imageOptions != nil {
            map["ImageOptions"] = self.imageOptions?.toMap()
        }
        if self.privatePoolOptions != nil {
            map["PrivatePoolOptions"] = self.privatePoolOptions?.toMap()
        }
        if self.systemDisk != nil {
            map["SystemDisk"] = self.systemDisk?.toMap()
        }
        if self.affinity != nil {
            map["Affinity"] = self.affinity!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.cpu != nil {
            map["Cpu"] = self.cpu!
        }
        if self.creditSpecification != nil {
            map["CreditSpecification"] = self.creditSpecification!
        }
        if self.customPriorities != nil {
            var tmp : [Any] = []
            for k in self.customPriorities! {
                tmp.append(k.toMap())
            }
            map["CustomPriorities"] = tmp
        }
        if self.dataDisks != nil {
            var tmp : [Any] = []
            for k in self.dataDisks! {
                tmp.append(k.toMap())
            }
            map["DataDisks"] = tmp
        }
        if self.dedicatedHostClusterId != nil {
            map["DedicatedHostClusterId"] = self.dedicatedHostClusterId!
        }
        if self.dedicatedHostId != nil {
            map["DedicatedHostId"] = self.dedicatedHostId!
        }
        if self.deletionProtection != nil {
            map["DeletionProtection"] = self.deletionProtection!
        }
        if self.deploymentSetId != nil {
            map["DeploymentSetId"] = self.deploymentSetId!
        }
        if self.hostName != nil {
            map["HostName"] = self.hostName!
        }
        if self.hpcClusterId != nil {
            map["HpcClusterId"] = self.hpcClusterId!
        }
        if self.httpEndpoint != nil {
            map["HttpEndpoint"] = self.httpEndpoint!
        }
        if self.httpTokens != nil {
            map["HttpTokens"] = self.httpTokens!
        }
        if self.imageFamily != nil {
            map["ImageFamily"] = self.imageFamily!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.imageName != nil {
            map["ImageName"] = self.imageName!
        }
        if self.instanceDescription != nil {
            map["InstanceDescription"] = self.instanceDescription!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.instancePatternInfos != nil {
            var tmp : [Any] = []
            for k in self.instancePatternInfos! {
                tmp.append(k.toMap())
            }
            map["InstancePatternInfos"] = tmp
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.instanceTypeOverrides != nil {
            var tmp : [Any] = []
            for k in self.instanceTypeOverrides! {
                tmp.append(k.toMap())
            }
            map["InstanceTypeOverrides"] = tmp
        }
        if self.instanceTypes != nil {
            map["InstanceTypes"] = self.instanceTypes!
        }
        if self.internetChargeType != nil {
            map["InternetChargeType"] = self.internetChargeType!
        }
        if self.internetMaxBandwidthIn != nil {
            map["InternetMaxBandwidthIn"] = self.internetMaxBandwidthIn!
        }
        if self.internetMaxBandwidthOut != nil {
            map["InternetMaxBandwidthOut"] = self.internetMaxBandwidthOut!
        }
        if self.ioOptimized != nil {
            map["IoOptimized"] = self.ioOptimized!
        }
        if self.ipv6AddressCount != nil {
            map["Ipv6AddressCount"] = self.ipv6AddressCount!
        }
        if self.keyPairName != nil {
            map["KeyPairName"] = self.keyPairName!
        }
        if self.loadBalancerWeight != nil {
            map["LoadBalancerWeight"] = self.loadBalancerWeight!
        }
        if self.memory != nil {
            map["Memory"] = self.memory!
        }
        if self.networkInterfaces != nil {
            var tmp : [Any] = []
            for k in self.networkInterfaces! {
                tmp.append(k.toMap())
            }
            map["NetworkInterfaces"] = tmp
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        if self.passwordInherit != nil {
            map["PasswordInherit"] = self.passwordInherit!
        }
        if self.ramRoleName != nil {
            map["RamRoleName"] = self.ramRoleName!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourcePoolOptions != nil {
            map["ResourcePoolOptions"] = self.resourcePoolOptions?.toMap()
        }
        if self.scalingConfigurationName != nil {
            map["ScalingConfigurationName"] = self.scalingConfigurationName!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        if self.schedulerOptions != nil {
            map["SchedulerOptions"] = self.schedulerOptions!
        }
        if self.securityEnhancementStrategy != nil {
            map["SecurityEnhancementStrategy"] = self.securityEnhancementStrategy!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.securityGroupIds != nil {
            map["SecurityGroupIds"] = self.securityGroupIds!
        }
        if self.securityOptions != nil {
            map["SecurityOptions"] = self.securityOptions?.toMap()
        }
        if self.spotDuration != nil {
            map["SpotDuration"] = self.spotDuration!
        }
        if self.spotInterruptionBehavior != nil {
            map["SpotInterruptionBehavior"] = self.spotInterruptionBehavior!
        }
        if self.spotPriceLimits != nil {
            var tmp : [Any] = []
            for k in self.spotPriceLimits! {
                tmp.append(k.toMap())
            }
            map["SpotPriceLimits"] = tmp
        }
        if self.spotStrategy != nil {
            map["SpotStrategy"] = self.spotStrategy!
        }
        if self.storageSetId != nil {
            map["StorageSetId"] = self.storageSetId!
        }
        if self.storageSetPartitionNumber != nil {
            map["StorageSetPartitionNumber"] = self.storageSetPartitionNumber!
        }
        if self.systemDiskCategories != nil {
            map["SystemDiskCategories"] = self.systemDiskCategories!
        }
        if self.tags != nil {
            map["Tags"] = self.tags!
        }
        if self.tenancy != nil {
            map["Tenancy"] = self.tenancy!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ImageOptions"] as? [String: Any?] {
            var model = CreateScalingConfigurationRequest.ImageOptions()
            model.fromMap(value)
            self.imageOptions = model
        }
        if let value = dict["PrivatePoolOptions"] as? [String: Any?] {
            var model = CreateScalingConfigurationRequest.PrivatePoolOptions()
            model.fromMap(value)
            self.privatePoolOptions = model
        }
        if let value = dict["SystemDisk"] as? [String: Any?] {
            var model = CreateScalingConfigurationRequest.SystemDisk()
            model.fromMap(value)
            self.systemDisk = model
        }
        if let value = dict["Affinity"] as? String {
            self.affinity = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Cpu"] as? Int32 {
            self.cpu = value
        }
        if let value = dict["CreditSpecification"] as? String {
            self.creditSpecification = value
        }
        if let value = dict["CustomPriorities"] as? [Any?] {
            var tmp : [CreateScalingConfigurationRequest.CustomPriorities] = []
            for v in value {
                if v != nil {
                    var model = CreateScalingConfigurationRequest.CustomPriorities()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.customPriorities = tmp
        }
        if let value = dict["DataDisks"] as? [Any?] {
            var tmp : [CreateScalingConfigurationRequest.DataDisks] = []
            for v in value {
                if v != nil {
                    var model = CreateScalingConfigurationRequest.DataDisks()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.dataDisks = tmp
        }
        if let value = dict["DedicatedHostClusterId"] as? String {
            self.dedicatedHostClusterId = value
        }
        if let value = dict["DedicatedHostId"] as? String {
            self.dedicatedHostId = value
        }
        if let value = dict["DeletionProtection"] as? Bool {
            self.deletionProtection = value
        }
        if let value = dict["DeploymentSetId"] as? String {
            self.deploymentSetId = value
        }
        if let value = dict["HostName"] as? String {
            self.hostName = value
        }
        if let value = dict["HpcClusterId"] as? String {
            self.hpcClusterId = value
        }
        if let value = dict["HttpEndpoint"] as? String {
            self.httpEndpoint = value
        }
        if let value = dict["HttpTokens"] as? String {
            self.httpTokens = value
        }
        if let value = dict["ImageFamily"] as? String {
            self.imageFamily = value
        }
        if let value = dict["ImageId"] as? String {
            self.imageId = value
        }
        if let value = dict["ImageName"] as? String {
            self.imageName = value
        }
        if let value = dict["InstanceDescription"] as? String {
            self.instanceDescription = value
        }
        if let value = dict["InstanceName"] as? String {
            self.instanceName = value
        }
        if let value = dict["InstancePatternInfos"] as? [Any?] {
            var tmp : [CreateScalingConfigurationRequest.InstancePatternInfos] = []
            for v in value {
                if v != nil {
                    var model = CreateScalingConfigurationRequest.InstancePatternInfos()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.instancePatternInfos = tmp
        }
        if let value = dict["InstanceType"] as? String {
            self.instanceType = value
        }
        if let value = dict["InstanceTypeOverrides"] as? [Any?] {
            var tmp : [CreateScalingConfigurationRequest.InstanceTypeOverrides] = []
            for v in value {
                if v != nil {
                    var model = CreateScalingConfigurationRequest.InstanceTypeOverrides()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.instanceTypeOverrides = tmp
        }
        if let value = dict["InstanceTypes"] as? [String] {
            self.instanceTypes = value
        }
        if let value = dict["InternetChargeType"] as? String {
            self.internetChargeType = value
        }
        if let value = dict["InternetMaxBandwidthIn"] as? Int32 {
            self.internetMaxBandwidthIn = value
        }
        if let value = dict["InternetMaxBandwidthOut"] as? Int32 {
            self.internetMaxBandwidthOut = value
        }
        if let value = dict["IoOptimized"] as? String {
            self.ioOptimized = value
        }
        if let value = dict["Ipv6AddressCount"] as? Int32 {
            self.ipv6AddressCount = value
        }
        if let value = dict["KeyPairName"] as? String {
            self.keyPairName = value
        }
        if let value = dict["LoadBalancerWeight"] as? Int32 {
            self.loadBalancerWeight = value
        }
        if let value = dict["Memory"] as? Int32 {
            self.memory = value
        }
        if let value = dict["NetworkInterfaces"] as? [Any?] {
            var tmp : [CreateScalingConfigurationRequest.NetworkInterfaces] = []
            for v in value {
                if v != nil {
                    var model = CreateScalingConfigurationRequest.NetworkInterfaces()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.networkInterfaces = tmp
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Password"] as? String {
            self.password = value
        }
        if let value = dict["PasswordInherit"] as? Bool {
            self.passwordInherit = value
        }
        if let value = dict["RamRoleName"] as? String {
            self.ramRoleName = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourcePoolOptions"] as? [String: Any?] {
            var model = CreateScalingConfigurationRequest.ResourcePoolOptions()
            model.fromMap(value)
            self.resourcePoolOptions = model
        }
        if let value = dict["ScalingConfigurationName"] as? String {
            self.scalingConfigurationName = value
        }
        if let value = dict["ScalingGroupId"] as? String {
            self.scalingGroupId = value
        }
        if let value = dict["SchedulerOptions"] as? [String: Any] {
            self.schedulerOptions = value
        }
        if let value = dict["SecurityEnhancementStrategy"] as? String {
            self.securityEnhancementStrategy = value
        }
        if let value = dict["SecurityGroupId"] as? String {
            self.securityGroupId = value
        }
        if let value = dict["SecurityGroupIds"] as? [String] {
            self.securityGroupIds = value
        }
        if let value = dict["SecurityOptions"] as? [String: Any?] {
            var model = CreateScalingConfigurationRequest.SecurityOptions()
            model.fromMap(value)
            self.securityOptions = model
        }
        if let value = dict["SpotDuration"] as? Int32 {
            self.spotDuration = value
        }
        if let value = dict["SpotInterruptionBehavior"] as? String {
            self.spotInterruptionBehavior = value
        }
        if let value = dict["SpotPriceLimits"] as? [Any?] {
            var tmp : [CreateScalingConfigurationRequest.SpotPriceLimits] = []
            for v in value {
                if v != nil {
                    var model = CreateScalingConfigurationRequest.SpotPriceLimits()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.spotPriceLimits = tmp
        }
        if let value = dict["SpotStrategy"] as? String {
            self.spotStrategy = value
        }
        if let value = dict["StorageSetId"] as? String {
            self.storageSetId = value
        }
        if let value = dict["StorageSetPartitionNumber"] as? Int32 {
            self.storageSetPartitionNumber = value
        }
        if let value = dict["SystemDiskCategories"] as? [String] {
            self.systemDiskCategories = value
        }
        if let value = dict["Tags"] as? String {
            self.tags = value
        }
        if let value = dict["Tenancy"] as? String {
            self.tenancy = value
        }
        if let value = dict["UserData"] as? String {
            self.userData = value
        }
        if let value = dict["ZoneId"] as? String {
            self.zoneId = value
        }
    }
}

public class CreateScalingConfigurationShrinkRequest : Tea.TeaModel {
    public class ImageOptions : Tea.TeaModel {
        public var loginAsNonRoot: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.loginAsNonRoot != nil {
                map["LoginAsNonRoot"] = self.loginAsNonRoot!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["LoginAsNonRoot"] as? Bool {
                self.loginAsNonRoot = value
            }
        }
    }
    public class PrivatePoolOptions : Tea.TeaModel {
        public var id: String?

        public var matchCriteria: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.matchCriteria != nil {
                map["MatchCriteria"] = self.matchCriteria!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Id"] as? String {
                self.id = value
            }
            if let value = dict["MatchCriteria"] as? String {
                self.matchCriteria = value
            }
        }
    }
    public class SystemDisk : Tea.TeaModel {
        public var autoSnapshotPolicyId: String?

        public var burstingEnabled: Bool?

        public var category: String?

        public var description_: String?

        public var diskName: String?

        public var encryptAlgorithm: String?

        public var encrypted: Bool?

        public var KMSKeyId: String?

        public var performanceLevel: String?

        public var provisionedIops: Int64?

        public var size: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.autoSnapshotPolicyId != nil {
                map["AutoSnapshotPolicyId"] = self.autoSnapshotPolicyId!
            }
            if self.burstingEnabled != nil {
                map["BurstingEnabled"] = self.burstingEnabled!
            }
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.diskName != nil {
                map["DiskName"] = self.diskName!
            }
            if self.encryptAlgorithm != nil {
                map["EncryptAlgorithm"] = self.encryptAlgorithm!
            }
            if self.encrypted != nil {
                map["Encrypted"] = self.encrypted!
            }
            if self.KMSKeyId != nil {
                map["KMSKeyId"] = self.KMSKeyId!
            }
            if self.performanceLevel != nil {
                map["PerformanceLevel"] = self.performanceLevel!
            }
            if self.provisionedIops != nil {
                map["ProvisionedIops"] = self.provisionedIops!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AutoSnapshotPolicyId"] as? String {
                self.autoSnapshotPolicyId = value
            }
            if let value = dict["BurstingEnabled"] as? Bool {
                self.burstingEnabled = value
            }
            if let value = dict["Category"] as? String {
                self.category = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["DiskName"] as? String {
                self.diskName = value
            }
            if let value = dict["EncryptAlgorithm"] as? String {
                self.encryptAlgorithm = value
            }
            if let value = dict["Encrypted"] as? Bool {
                self.encrypted = value
            }
            if let value = dict["KMSKeyId"] as? String {
                self.KMSKeyId = value
            }
            if let value = dict["PerformanceLevel"] as? String {
                self.performanceLevel = value
            }
            if let value = dict["ProvisionedIops"] as? Int64 {
                self.provisionedIops = value
            }
            if let value = dict["Size"] as? Int32 {
                self.size = value
            }
        }
    }
    public class CustomPriorities : Tea.TeaModel {
        public var instanceType: String?

        public var vswitchId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.vswitchId != nil {
                map["VswitchId"] = self.vswitchId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["InstanceType"] as? String {
                self.instanceType = value
            }
            if let value = dict["VswitchId"] as? String {
                self.vswitchId = value
            }
        }
    }
    public class DataDisks : Tea.TeaModel {
        public var autoSnapshotPolicyId: String?

        public var burstingEnabled: Bool?

        public var categories: [String]?

        public var category: String?

        public var deleteWithInstance: Bool?

        public var description_: String?

        public var device: String?

        public var diskName: String?

        public var encrypted: String?

        public var KMSKeyId: String?

        public var performanceLevel: String?

        public var provisionedIops: Int64?

        public var size: Int32?

        public var snapshotId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.autoSnapshotPolicyId != nil {
                map["AutoSnapshotPolicyId"] = self.autoSnapshotPolicyId!
            }
            if self.burstingEnabled != nil {
                map["BurstingEnabled"] = self.burstingEnabled!
            }
            if self.categories != nil {
                map["Categories"] = self.categories!
            }
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.deleteWithInstance != nil {
                map["DeleteWithInstance"] = self.deleteWithInstance!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.device != nil {
                map["Device"] = self.device!
            }
            if self.diskName != nil {
                map["DiskName"] = self.diskName!
            }
            if self.encrypted != nil {
                map["Encrypted"] = self.encrypted!
            }
            if self.KMSKeyId != nil {
                map["KMSKeyId"] = self.KMSKeyId!
            }
            if self.performanceLevel != nil {
                map["PerformanceLevel"] = self.performanceLevel!
            }
            if self.provisionedIops != nil {
                map["ProvisionedIops"] = self.provisionedIops!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.snapshotId != nil {
                map["SnapshotId"] = self.snapshotId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AutoSnapshotPolicyId"] as? String {
                self.autoSnapshotPolicyId = value
            }
            if let value = dict["BurstingEnabled"] as? Bool {
                self.burstingEnabled = value
            }
            if let value = dict["Categories"] as? [String] {
                self.categories = value
            }
            if let value = dict["Category"] as? String {
                self.category = value
            }
            if let value = dict["DeleteWithInstance"] as? Bool {
                self.deleteWithInstance = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["Device"] as? String {
                self.device = value
            }
            if let value = dict["DiskName"] as? String {
                self.diskName = value
            }
            if let value = dict["Encrypted"] as? String {
                self.encrypted = value
            }
            if let value = dict["KMSKeyId"] as? String {
                self.KMSKeyId = value
            }
            if let value = dict["PerformanceLevel"] as? String {
                self.performanceLevel = value
            }
            if let value = dict["ProvisionedIops"] as? Int64 {
                self.provisionedIops = value
            }
            if let value = dict["Size"] as? Int32 {
                self.size = value
            }
            if let value = dict["SnapshotId"] as? String {
                self.snapshotId = value
            }
        }
    }
    public class InstancePatternInfos : Tea.TeaModel {
        public var architectures: [String]?

        public var burstablePerformance: String?

        public var cores: Int32?

        public var cpuArchitectures: [String]?

        public var excludedInstanceTypes: [String]?

        public var gpuSpecs: [String]?

        public var instanceCategories: [String]?

        public var instanceFamilyLevel: String?

        public var instanceTypeFamilies: [String]?

        public var maxPrice: Double?

        public var maximumCpuCoreCount: Int32?

        public var maximumGpuAmount: Int32?

        public var maximumMemorySize: Double?

        public var memory: Double?

        public var minimumBaselineCredit: Int32?

        public var minimumCpuCoreCount: Int32?

        public var minimumEniIpv6AddressQuantity: Int32?

        public var minimumEniPrivateIpAddressQuantity: Int32?

        public var minimumEniQuantity: Int32?

        public var minimumGpuAmount: Int32?

        public var minimumInitialCredit: Int32?

        public var minimumMemorySize: Double?

        public var physicalProcessorModels: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.architectures != nil {
                map["Architectures"] = self.architectures!
            }
            if self.burstablePerformance != nil {
                map["BurstablePerformance"] = self.burstablePerformance!
            }
            if self.cores != nil {
                map["Cores"] = self.cores!
            }
            if self.cpuArchitectures != nil {
                map["CpuArchitectures"] = self.cpuArchitectures!
            }
            if self.excludedInstanceTypes != nil {
                map["ExcludedInstanceTypes"] = self.excludedInstanceTypes!
            }
            if self.gpuSpecs != nil {
                map["GpuSpecs"] = self.gpuSpecs!
            }
            if self.instanceCategories != nil {
                map["InstanceCategories"] = self.instanceCategories!
            }
            if self.instanceFamilyLevel != nil {
                map["InstanceFamilyLevel"] = self.instanceFamilyLevel!
            }
            if self.instanceTypeFamilies != nil {
                map["InstanceTypeFamilies"] = self.instanceTypeFamilies!
            }
            if self.maxPrice != nil {
                map["MaxPrice"] = self.maxPrice!
            }
            if self.maximumCpuCoreCount != nil {
                map["MaximumCpuCoreCount"] = self.maximumCpuCoreCount!
            }
            if self.maximumGpuAmount != nil {
                map["MaximumGpuAmount"] = self.maximumGpuAmount!
            }
            if self.maximumMemorySize != nil {
                map["MaximumMemorySize"] = self.maximumMemorySize!
            }
            if self.memory != nil {
                map["Memory"] = self.memory!
            }
            if self.minimumBaselineCredit != nil {
                map["MinimumBaselineCredit"] = self.minimumBaselineCredit!
            }
            if self.minimumCpuCoreCount != nil {
                map["MinimumCpuCoreCount"] = self.minimumCpuCoreCount!
            }
            if self.minimumEniIpv6AddressQuantity != nil {
                map["MinimumEniIpv6AddressQuantity"] = self.minimumEniIpv6AddressQuantity!
            }
            if self.minimumEniPrivateIpAddressQuantity != nil {
                map["MinimumEniPrivateIpAddressQuantity"] = self.minimumEniPrivateIpAddressQuantity!
            }
            if self.minimumEniQuantity != nil {
                map["MinimumEniQuantity"] = self.minimumEniQuantity!
            }
            if self.minimumGpuAmount != nil {
                map["MinimumGpuAmount"] = self.minimumGpuAmount!
            }
            if self.minimumInitialCredit != nil {
                map["MinimumInitialCredit"] = self.minimumInitialCredit!
            }
            if self.minimumMemorySize != nil {
                map["MinimumMemorySize"] = self.minimumMemorySize!
            }
            if self.physicalProcessorModels != nil {
                map["PhysicalProcessorModels"] = self.physicalProcessorModels!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Architectures"] as? [String] {
                self.architectures = value
            }
            if let value = dict["BurstablePerformance"] as? String {
                self.burstablePerformance = value
            }
            if let value = dict["Cores"] as? Int32 {
                self.cores = value
            }
            if let value = dict["CpuArchitectures"] as? [String] {
                self.cpuArchitectures = value
            }
            if let value = dict["ExcludedInstanceTypes"] as? [String] {
                self.excludedInstanceTypes = value
            }
            if let value = dict["GpuSpecs"] as? [String] {
                self.gpuSpecs = value
            }
            if let value = dict["InstanceCategories"] as? [String] {
                self.instanceCategories = value
            }
            if let value = dict["InstanceFamilyLevel"] as? String {
                self.instanceFamilyLevel = value
            }
            if let value = dict["InstanceTypeFamilies"] as? [String] {
                self.instanceTypeFamilies = value
            }
            if let value = dict["MaxPrice"] as? Double {
                self.maxPrice = value
            }
            if let value = dict["MaximumCpuCoreCount"] as? Int32 {
                self.maximumCpuCoreCount = value
            }
            if let value = dict["MaximumGpuAmount"] as? Int32 {
                self.maximumGpuAmount = value
            }
            if let value = dict["MaximumMemorySize"] as? Double {
                self.maximumMemorySize = value
            }
            if let value = dict["Memory"] as? Double {
                self.memory = value
            }
            if let value = dict["MinimumBaselineCredit"] as? Int32 {
                self.minimumBaselineCredit = value
            }
            if let value = dict["MinimumCpuCoreCount"] as? Int32 {
                self.minimumCpuCoreCount = value
            }
            if let value = dict["MinimumEniIpv6AddressQuantity"] as? Int32 {
                self.minimumEniIpv6AddressQuantity = value
            }
            if let value = dict["MinimumEniPrivateIpAddressQuantity"] as? Int32 {
                self.minimumEniPrivateIpAddressQuantity = value
            }
            if let value = dict["MinimumEniQuantity"] as? Int32 {
                self.minimumEniQuantity = value
            }
            if let value = dict["MinimumGpuAmount"] as? Int32 {
                self.minimumGpuAmount = value
            }
            if let value = dict["MinimumInitialCredit"] as? Int32 {
                self.minimumInitialCredit = value
            }
            if let value = dict["MinimumMemorySize"] as? Double {
                self.minimumMemorySize = value
            }
            if let value = dict["PhysicalProcessorModels"] as? [String] {
                self.physicalProcessorModels = value
            }
        }
    }
    public class InstanceTypeOverrides : Tea.TeaModel {
        public var instanceType: String?

        public var weightedCapacity: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.weightedCapacity != nil {
                map["WeightedCapacity"] = self.weightedCapacity!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["InstanceType"] as? String {
                self.instanceType = value
            }
            if let value = dict["WeightedCapacity"] as? Int32 {
                self.weightedCapacity = value
            }
        }
    }
    public class NetworkInterfaces : Tea.TeaModel {
        public var instanceType: String?

        public var ipv6AddressCount: Int32?

        public var networkInterfaceTrafficMode: String?

        public var securityGroupIds: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.ipv6AddressCount != nil {
                map["Ipv6AddressCount"] = self.ipv6AddressCount!
            }
            if self.networkInterfaceTrafficMode != nil {
                map["NetworkInterfaceTrafficMode"] = self.networkInterfaceTrafficMode!
            }
            if self.securityGroupIds != nil {
                map["SecurityGroupIds"] = self.securityGroupIds!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["InstanceType"] as? String {
                self.instanceType = value
            }
            if let value = dict["Ipv6AddressCount"] as? Int32 {
                self.ipv6AddressCount = value
            }
            if let value = dict["NetworkInterfaceTrafficMode"] as? String {
                self.networkInterfaceTrafficMode = value
            }
            if let value = dict["SecurityGroupIds"] as? [String] {
                self.securityGroupIds = value
            }
        }
    }
    public class ResourcePoolOptions : Tea.TeaModel {
        public var privatePoolIds: [String]?

        public var strategy: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.privatePoolIds != nil {
                map["PrivatePoolIds"] = self.privatePoolIds!
            }
            if self.strategy != nil {
                map["Strategy"] = self.strategy!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["PrivatePoolIds"] as? [String] {
                self.privatePoolIds = value
            }
            if let value = dict["Strategy"] as? String {
                self.strategy = value
            }
        }
    }
    public class SecurityOptions : Tea.TeaModel {
        public var confidentialComputingMode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.confidentialComputingMode != nil {
                map["ConfidentialComputingMode"] = self.confidentialComputingMode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ConfidentialComputingMode"] as? String {
                self.confidentialComputingMode = value
            }
        }
    }
    public class SpotPriceLimits : Tea.TeaModel {
        public var instanceType: String?

        public var priceLimit: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.priceLimit != nil {
                map["PriceLimit"] = self.priceLimit!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["InstanceType"] as? String {
                self.instanceType = value
            }
            if let value = dict["PriceLimit"] as? Double {
                self.priceLimit = value
            }
        }
    }
    public var imageOptions: CreateScalingConfigurationShrinkRequest.ImageOptions?

    public var privatePoolOptions: CreateScalingConfigurationShrinkRequest.PrivatePoolOptions?

    public var systemDisk: CreateScalingConfigurationShrinkRequest.SystemDisk?

    public var affinity: String?

    public var clientToken: String?

    public var cpu: Int32?

    public var creditSpecification: String?

    public var customPriorities: [CreateScalingConfigurationShrinkRequest.CustomPriorities]?

    public var dataDisks: [CreateScalingConfigurationShrinkRequest.DataDisks]?

    public var dedicatedHostClusterId: String?

    public var dedicatedHostId: String?

    public var deletionProtection: Bool?

    public var deploymentSetId: String?

    public var hostName: String?

    public var hpcClusterId: String?

    public var httpEndpoint: String?

    public var httpTokens: String?

    public var imageFamily: String?

    public var imageId: String?

    public var imageName: String?

    public var instanceDescription: String?

    public var instanceName: String?

    public var instancePatternInfos: [CreateScalingConfigurationShrinkRequest.InstancePatternInfos]?

    public var instanceType: String?

    public var instanceTypeOverrides: [CreateScalingConfigurationShrinkRequest.InstanceTypeOverrides]?

    public var instanceTypes: [String]?

    public var internetChargeType: String?

    public var internetMaxBandwidthIn: Int32?

    public var internetMaxBandwidthOut: Int32?

    public var ioOptimized: String?

    public var ipv6AddressCount: Int32?

    public var keyPairName: String?

    public var loadBalancerWeight: Int32?

    public var memory: Int32?

    public var networkInterfaces: [CreateScalingConfigurationShrinkRequest.NetworkInterfaces]?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var password: String?

    public var passwordInherit: Bool?

    public var ramRoleName: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourcePoolOptions: CreateScalingConfigurationShrinkRequest.ResourcePoolOptions?

    public var scalingConfigurationName: String?

    public var scalingGroupId: String?

    public var schedulerOptionsShrink: String?

    public var securityEnhancementStrategy: String?

    public var securityGroupId: String?

    public var securityGroupIds: [String]?

    public var securityOptions: CreateScalingConfigurationShrinkRequest.SecurityOptions?

    public var spotDuration: Int32?

    public var spotInterruptionBehavior: String?

    public var spotPriceLimits: [CreateScalingConfigurationShrinkRequest.SpotPriceLimits]?

    public var spotStrategy: String?

    public var storageSetId: String?

    public var storageSetPartitionNumber: Int32?

    public var systemDiskCategories: [String]?

    public var tags: String?

    public var tenancy: String?

    public var userData: String?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.imageOptions?.validate()
        try self.privatePoolOptions?.validate()
        try self.systemDisk?.validate()
        try self.resourcePoolOptions?.validate()
        try self.securityOptions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imageOptions != nil {
            map["ImageOptions"] = self.imageOptions?.toMap()
        }
        if self.privatePoolOptions != nil {
            map["PrivatePoolOptions"] = self.privatePoolOptions?.toMap()
        }
        if self.systemDisk != nil {
            map["SystemDisk"] = self.systemDisk?.toMap()
        }
        if self.affinity != nil {
            map["Affinity"] = self.affinity!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.cpu != nil {
            map["Cpu"] = self.cpu!
        }
        if self.creditSpecification != nil {
            map["CreditSpecification"] = self.creditSpecification!
        }
        if self.customPriorities != nil {
            var tmp : [Any] = []
            for k in self.customPriorities! {
                tmp.append(k.toMap())
            }
            map["CustomPriorities"] = tmp
        }
        if self.dataDisks != nil {
            var tmp : [Any] = []
            for k in self.dataDisks! {
                tmp.append(k.toMap())
            }
            map["DataDisks"] = tmp
        }
        if self.dedicatedHostClusterId != nil {
            map["DedicatedHostClusterId"] = self.dedicatedHostClusterId!
        }
        if self.dedicatedHostId != nil {
            map["DedicatedHostId"] = self.dedicatedHostId!
        }
        if self.deletionProtection != nil {
            map["DeletionProtection"] = self.deletionProtection!
        }
        if self.deploymentSetId != nil {
            map["DeploymentSetId"] = self.deploymentSetId!
        }
        if self.hostName != nil {
            map["HostName"] = self.hostName!
        }
        if self.hpcClusterId != nil {
            map["HpcClusterId"] = self.hpcClusterId!
        }
        if self.httpEndpoint != nil {
            map["HttpEndpoint"] = self.httpEndpoint!
        }
        if self.httpTokens != nil {
            map["HttpTokens"] = self.httpTokens!
        }
        if self.imageFamily != nil {
            map["ImageFamily"] = self.imageFamily!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.imageName != nil {
            map["ImageName"] = self.imageName!
        }
        if self.instanceDescription != nil {
            map["InstanceDescription"] = self.instanceDescription!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.instancePatternInfos != nil {
            var tmp : [Any] = []
            for k in self.instancePatternInfos! {
                tmp.append(k.toMap())
            }
            map["InstancePatternInfos"] = tmp
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.instanceTypeOverrides != nil {
            var tmp : [Any] = []
            for k in self.instanceTypeOverrides! {
                tmp.append(k.toMap())
            }
            map["InstanceTypeOverrides"] = tmp
        }
        if self.instanceTypes != nil {
            map["InstanceTypes"] = self.instanceTypes!
        }
        if self.internetChargeType != nil {
            map["InternetChargeType"] = self.internetChargeType!
        }
        if self.internetMaxBandwidthIn != nil {
            map["InternetMaxBandwidthIn"] = self.internetMaxBandwidthIn!
        }
        if self.internetMaxBandwidthOut != nil {
            map["InternetMaxBandwidthOut"] = self.internetMaxBandwidthOut!
        }
        if self.ioOptimized != nil {
            map["IoOptimized"] = self.ioOptimized!
        }
        if self.ipv6AddressCount != nil {
            map["Ipv6AddressCount"] = self.ipv6AddressCount!
        }
        if self.keyPairName != nil {
            map["KeyPairName"] = self.keyPairName!
        }
        if self.loadBalancerWeight != nil {
            map["LoadBalancerWeight"] = self.loadBalancerWeight!
        }
        if self.memory != nil {
            map["Memory"] = self.memory!
        }
        if self.networkInterfaces != nil {
            var tmp : [Any] = []
            for k in self.networkInterfaces! {
                tmp.append(k.toMap())
            }
            map["NetworkInterfaces"] = tmp
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        if self.passwordInherit != nil {
            map["PasswordInherit"] = self.passwordInherit!
        }
        if self.ramRoleName != nil {
            map["RamRoleName"] = self.ramRoleName!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourcePoolOptions != nil {
            map["ResourcePoolOptions"] = self.resourcePoolOptions?.toMap()
        }
        if self.scalingConfigurationName != nil {
            map["ScalingConfigurationName"] = self.scalingConfigurationName!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        if self.schedulerOptionsShrink != nil {
            map["SchedulerOptions"] = self.schedulerOptionsShrink!
        }
        if self.securityEnhancementStrategy != nil {
            map["SecurityEnhancementStrategy"] = self.securityEnhancementStrategy!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.securityGroupIds != nil {
            map["SecurityGroupIds"] = self.securityGroupIds!
        }
        if self.securityOptions != nil {
            map["SecurityOptions"] = self.securityOptions?.toMap()
        }
        if self.spotDuration != nil {
            map["SpotDuration"] = self.spotDuration!
        }
        if self.spotInterruptionBehavior != nil {
            map["SpotInterruptionBehavior"] = self.spotInterruptionBehavior!
        }
        if self.spotPriceLimits != nil {
            var tmp : [Any] = []
            for k in self.spotPriceLimits! {
                tmp.append(k.toMap())
            }
            map["SpotPriceLimits"] = tmp
        }
        if self.spotStrategy != nil {
            map["SpotStrategy"] = self.spotStrategy!
        }
        if self.storageSetId != nil {
            map["StorageSetId"] = self.storageSetId!
        }
        if self.storageSetPartitionNumber != nil {
            map["StorageSetPartitionNumber"] = self.storageSetPartitionNumber!
        }
        if self.systemDiskCategories != nil {
            map["SystemDiskCategories"] = self.systemDiskCategories!
        }
        if self.tags != nil {
            map["Tags"] = self.tags!
        }
        if self.tenancy != nil {
            map["Tenancy"] = self.tenancy!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ImageOptions"] as? [String: Any?] {
            var model = CreateScalingConfigurationShrinkRequest.ImageOptions()
            model.fromMap(value)
            self.imageOptions = model
        }
        if let value = dict["PrivatePoolOptions"] as? [String: Any?] {
            var model = CreateScalingConfigurationShrinkRequest.PrivatePoolOptions()
            model.fromMap(value)
            self.privatePoolOptions = model
        }
        if let value = dict["SystemDisk"] as? [String: Any?] {
            var model = CreateScalingConfigurationShrinkRequest.SystemDisk()
            model.fromMap(value)
            self.systemDisk = model
        }
        if let value = dict["Affinity"] as? String {
            self.affinity = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Cpu"] as? Int32 {
            self.cpu = value
        }
        if let value = dict["CreditSpecification"] as? String {
            self.creditSpecification = value
        }
        if let value = dict["CustomPriorities"] as? [Any?] {
            var tmp : [CreateScalingConfigurationShrinkRequest.CustomPriorities] = []
            for v in value {
                if v != nil {
                    var model = CreateScalingConfigurationShrinkRequest.CustomPriorities()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.customPriorities = tmp
        }
        if let value = dict["DataDisks"] as? [Any?] {
            var tmp : [CreateScalingConfigurationShrinkRequest.DataDisks] = []
            for v in value {
                if v != nil {
                    var model = CreateScalingConfigurationShrinkRequest.DataDisks()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.dataDisks = tmp
        }
        if let value = dict["DedicatedHostClusterId"] as? String {
            self.dedicatedHostClusterId = value
        }
        if let value = dict["DedicatedHostId"] as? String {
            self.dedicatedHostId = value
        }
        if let value = dict["DeletionProtection"] as? Bool {
            self.deletionProtection = value
        }
        if let value = dict["DeploymentSetId"] as? String {
            self.deploymentSetId = value
        }
        if let value = dict["HostName"] as? String {
            self.hostName = value
        }
        if let value = dict["HpcClusterId"] as? String {
            self.hpcClusterId = value
        }
        if let value = dict["HttpEndpoint"] as? String {
            self.httpEndpoint = value
        }
        if let value = dict["HttpTokens"] as? String {
            self.httpTokens = value
        }
        if let value = dict["ImageFamily"] as? String {
            self.imageFamily = value
        }
        if let value = dict["ImageId"] as? String {
            self.imageId = value
        }
        if let value = dict["ImageName"] as? String {
            self.imageName = value
        }
        if let value = dict["InstanceDescription"] as? String {
            self.instanceDescription = value
        }
        if let value = dict["InstanceName"] as? String {
            self.instanceName = value
        }
        if let value = dict["InstancePatternInfos"] as? [Any?] {
            var tmp : [CreateScalingConfigurationShrinkRequest.InstancePatternInfos] = []
            for v in value {
                if v != nil {
                    var model = CreateScalingConfigurationShrinkRequest.InstancePatternInfos()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.instancePatternInfos = tmp
        }
        if let value = dict["InstanceType"] as? String {
            self.instanceType = value
        }
        if let value = dict["InstanceTypeOverrides"] as? [Any?] {
            var tmp : [CreateScalingConfigurationShrinkRequest.InstanceTypeOverrides] = []
            for v in value {
                if v != nil {
                    var model = CreateScalingConfigurationShrinkRequest.InstanceTypeOverrides()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.instanceTypeOverrides = tmp
        }
        if let value = dict["InstanceTypes"] as? [String] {
            self.instanceTypes = value
        }
        if let value = dict["InternetChargeType"] as? String {
            self.internetChargeType = value
        }
        if let value = dict["InternetMaxBandwidthIn"] as? Int32 {
            self.internetMaxBandwidthIn = value
        }
        if let value = dict["InternetMaxBandwidthOut"] as? Int32 {
            self.internetMaxBandwidthOut = value
        }
        if let value = dict["IoOptimized"] as? String {
            self.ioOptimized = value
        }
        if let value = dict["Ipv6AddressCount"] as? Int32 {
            self.ipv6AddressCount = value
        }
        if let value = dict["KeyPairName"] as? String {
            self.keyPairName = value
        }
        if let value = dict["LoadBalancerWeight"] as? Int32 {
            self.loadBalancerWeight = value
        }
        if let value = dict["Memory"] as? Int32 {
            self.memory = value
        }
        if let value = dict["NetworkInterfaces"] as? [Any?] {
            var tmp : [CreateScalingConfigurationShrinkRequest.NetworkInterfaces] = []
            for v in value {
                if v != nil {
                    var model = CreateScalingConfigurationShrinkRequest.NetworkInterfaces()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.networkInterfaces = tmp
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Password"] as? String {
            self.password = value
        }
        if let value = dict["PasswordInherit"] as? Bool {
            self.passwordInherit = value
        }
        if let value = dict["RamRoleName"] as? String {
            self.ramRoleName = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourcePoolOptions"] as? [String: Any?] {
            var model = CreateScalingConfigurationShrinkRequest.ResourcePoolOptions()
            model.fromMap(value)
            self.resourcePoolOptions = model
        }
        if let value = dict["ScalingConfigurationName"] as? String {
            self.scalingConfigurationName = value
        }
        if let value = dict["ScalingGroupId"] as? String {
            self.scalingGroupId = value
        }
        if let value = dict["SchedulerOptions"] as? String {
            self.schedulerOptionsShrink = value
        }
        if let value = dict["SecurityEnhancementStrategy"] as? String {
            self.securityEnhancementStrategy = value
        }
        if let value = dict["SecurityGroupId"] as? String {
            self.securityGroupId = value
        }
        if let value = dict["SecurityGroupIds"] as? [String] {
            self.securityGroupIds = value
        }
        if let value = dict["SecurityOptions"] as? [String: Any?] {
            var model = CreateScalingConfigurationShrinkRequest.SecurityOptions()
            model.fromMap(value)
            self.securityOptions = model
        }
        if let value = dict["SpotDuration"] as? Int32 {
            self.spotDuration = value
        }
        if let value = dict["SpotInterruptionBehavior"] as? String {
            self.spotInterruptionBehavior = value
        }
        if let value = dict["SpotPriceLimits"] as? [Any?] {
            var tmp : [CreateScalingConfigurationShrinkRequest.SpotPriceLimits] = []
            for v in value {
                if v != nil {
                    var model = CreateScalingConfigurationShrinkRequest.SpotPriceLimits()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.spotPriceLimits = tmp
        }
        if let value = dict["SpotStrategy"] as? String {
            self.spotStrategy = value
        }
        if let value = dict["StorageSetId"] as? String {
            self.storageSetId = value
        }
        if let value = dict["StorageSetPartitionNumber"] as? Int32 {
            self.storageSetPartitionNumber = value
        }
        if let value = dict["SystemDiskCategories"] as? [String] {
            self.systemDiskCategories = value
        }
        if let value = dict["Tags"] as? String {
            self.tags = value
        }
        if let value = dict["Tenancy"] as? String {
            self.tenancy = value
        }
        if let value = dict["UserData"] as? String {
            self.userData = value
        }
        if let value = dict["ZoneId"] as? String {
            self.zoneId = value
        }
    }
}

public class CreateScalingConfigurationResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var scalingConfigurationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingConfigurationId != nil {
            map["ScalingConfigurationId"] = self.scalingConfigurationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ScalingConfigurationId"] as? String {
            self.scalingConfigurationId = value
        }
    }
}

public class CreateScalingConfigurationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateScalingConfigurationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateScalingConfigurationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateScalingGroupRequest : Tea.TeaModel {
    public class AlbServerGroups : Tea.TeaModel {
        public var albServerGroupId: String?

        public var port: Int32?

        public var weight: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.albServerGroupId != nil {
                map["AlbServerGroupId"] = self.albServerGroupId!
            }
            if self.port != nil {
                map["Port"] = self.port!
            }
            if self.weight != nil {
                map["Weight"] = self.weight!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AlbServerGroupId"] as? String {
                self.albServerGroupId = value
            }
            if let value = dict["Port"] as? Int32 {
                self.port = value
            }
            if let value = dict["Weight"] as? Int32 {
                self.weight = value
            }
        }
    }
    public class CapacityOptions : Tea.TeaModel {
        public var compensateWithOnDemand: Bool?

        public var onDemandBaseCapacity: Int32?

        public var onDemandPercentageAboveBaseCapacity: Int32?

        public var priceComparisonMode: String?

        public var spotAutoReplaceOnDemand: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.compensateWithOnDemand != nil {
                map["CompensateWithOnDemand"] = self.compensateWithOnDemand!
            }
            if self.onDemandBaseCapacity != nil {
                map["OnDemandBaseCapacity"] = self.onDemandBaseCapacity!
            }
            if self.onDemandPercentageAboveBaseCapacity != nil {
                map["OnDemandPercentageAboveBaseCapacity"] = self.onDemandPercentageAboveBaseCapacity!
            }
            if self.priceComparisonMode != nil {
                map["PriceComparisonMode"] = self.priceComparisonMode!
            }
            if self.spotAutoReplaceOnDemand != nil {
                map["SpotAutoReplaceOnDemand"] = self.spotAutoReplaceOnDemand!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CompensateWithOnDemand"] as? Bool {
                self.compensateWithOnDemand = value
            }
            if let value = dict["OnDemandBaseCapacity"] as? Int32 {
                self.onDemandBaseCapacity = value
            }
            if let value = dict["OnDemandPercentageAboveBaseCapacity"] as? Int32 {
                self.onDemandPercentageAboveBaseCapacity = value
            }
            if let value = dict["PriceComparisonMode"] as? String {
                self.priceComparisonMode = value
            }
            if let value = dict["SpotAutoReplaceOnDemand"] as? Bool {
                self.spotAutoReplaceOnDemand = value
            }
        }
    }
    public class DBInstances : Tea.TeaModel {
        public var attachMode: String?

        public var DBInstanceId: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.attachMode != nil {
                map["AttachMode"] = self.attachMode!
            }
            if self.DBInstanceId != nil {
                map["DBInstanceId"] = self.DBInstanceId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AttachMode"] as? String {
                self.attachMode = value
            }
            if let value = dict["DBInstanceId"] as? String {
                self.DBInstanceId = value
            }
            if let value = dict["Type"] as? String {
                self.type = value
            }
        }
    }
    public class LaunchTemplateOverrides : Tea.TeaModel {
        public var instanceType: String?

        public var spotPriceLimit: Double?

        public var weightedCapacity: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.spotPriceLimit != nil {
                map["SpotPriceLimit"] = self.spotPriceLimit!
            }
            if self.weightedCapacity != nil {
                map["WeightedCapacity"] = self.weightedCapacity!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["InstanceType"] as? String {
                self.instanceType = value
            }
            if let value = dict["SpotPriceLimit"] as? Double {
                self.spotPriceLimit = value
            }
            if let value = dict["WeightedCapacity"] as? Int32 {
                self.weightedCapacity = value
            }
        }
    }
    public class LifecycleHooks : Tea.TeaModel {
        public var defaultResult: String?

        public var heartbeatTimeout: Int32?

        public var lifecycleHookName: String?

        public var lifecycleTransition: String?

        public var notificationArn: String?

        public var notificationMetadata: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.defaultResult != nil {
                map["DefaultResult"] = self.defaultResult!
            }
            if self.heartbeatTimeout != nil {
                map["HeartbeatTimeout"] = self.heartbeatTimeout!
            }
            if self.lifecycleHookName != nil {
                map["LifecycleHookName"] = self.lifecycleHookName!
            }
            if self.lifecycleTransition != nil {
                map["LifecycleTransition"] = self.lifecycleTransition!
            }
            if self.notificationArn != nil {
                map["NotificationArn"] = self.notificationArn!
            }
            if self.notificationMetadata != nil {
                map["NotificationMetadata"] = self.notificationMetadata!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DefaultResult"] as? String {
                self.defaultResult = value
            }
            if let value = dict["HeartbeatTimeout"] as? Int32 {
                self.heartbeatTimeout = value
            }
            if let value = dict["LifecycleHookName"] as? String {
                self.lifecycleHookName = value
            }
            if let value = dict["LifecycleTransition"] as? String {
                self.lifecycleTransition = value
            }
            if let value = dict["NotificationArn"] as? String {
                self.notificationArn = value
            }
            if let value = dict["NotificationMetadata"] as? String {
                self.notificationMetadata = value
            }
        }
    }
    public class LoadBalancerConfigs : Tea.TeaModel {
        public var loadBalancerId: String?

        public var weight: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.loadBalancerId != nil {
                map["LoadBalancerId"] = self.loadBalancerId!
            }
            if self.weight != nil {
                map["Weight"] = self.weight!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["LoadBalancerId"] as? String {
                self.loadBalancerId = value
            }
            if let value = dict["Weight"] as? Int32 {
                self.weight = value
            }
        }
    }
    public class ServerGroups : Tea.TeaModel {
        public var port: Int32?

        public var serverGroupId: String?

        public var type: String?

        public var weight: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.port != nil {
                map["Port"] = self.port!
            }
            if self.serverGroupId != nil {
                map["ServerGroupId"] = self.serverGroupId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.weight != nil {
                map["Weight"] = self.weight!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Port"] as? Int32 {
                self.port = value
            }
            if let value = dict["ServerGroupId"] as? String {
                self.serverGroupId = value
            }
            if let value = dict["Type"] as? String {
                self.type = value
            }
            if let value = dict["Weight"] as? Int32 {
                self.weight = value
            }
        }
    }
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var propagate: Bool?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.propagate != nil {
                map["Propagate"] = self.propagate!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Propagate"] as? Bool {
                self.propagate = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public class VServerGroups : Tea.TeaModel {
        public class VServerGroupAttributes : Tea.TeaModel {
            public var port: Int32?

            public var VServerGroupId: String?

            public var weight: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.VServerGroupId != nil {
                    map["VServerGroupId"] = self.VServerGroupId!
                }
                if self.weight != nil {
                    map["Weight"] = self.weight!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Port"] as? Int32 {
                    self.port = value
                }
                if let value = dict["VServerGroupId"] as? String {
                    self.VServerGroupId = value
                }
                if let value = dict["Weight"] as? Int32 {
                    self.weight = value
                }
            }
        }
        public var loadBalancerId: String?

        public var VServerGroupAttributes: [CreateScalingGroupRequest.VServerGroups.VServerGroupAttributes]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.loadBalancerId != nil {
                map["LoadBalancerId"] = self.loadBalancerId!
            }
            if self.VServerGroupAttributes != nil {
                var tmp : [Any] = []
                for k in self.VServerGroupAttributes! {
                    tmp.append(k.toMap())
                }
                map["VServerGroupAttributes"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["LoadBalancerId"] as? String {
                self.loadBalancerId = value
            }
            if let value = dict["VServerGroupAttributes"] as? [Any?] {
                var tmp : [CreateScalingGroupRequest.VServerGroups.VServerGroupAttributes] = []
                for v in value {
                    if v != nil {
                        var model = CreateScalingGroupRequest.VServerGroups.VServerGroupAttributes()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.VServerGroupAttributes = tmp
            }
        }
    }
    public var albServerGroups: [CreateScalingGroupRequest.AlbServerGroups]?

    public var allocationStrategy: String?

    public var azBalance: Bool?

    public var capacityOptions: CreateScalingGroupRequest.CapacityOptions?

    public var clientToken: String?

    public var compensateWithOnDemand: Bool?

    public var containerGroupId: String?

    public var customPolicyARN: String?

    public var DBInstanceIds: String?

    public var DBInstances: [CreateScalingGroupRequest.DBInstances]?

    public var defaultCooldown: Int32?

    public var desiredCapacity: Int32?

    public var groupDeletionProtection: Bool?

    public var groupType: String?

    public var healthCheckType: String?

    public var healthCheckTypes: [String]?

    public var instanceId: String?

    public var launchTemplateId: String?

    public var launchTemplateOverrides: [CreateScalingGroupRequest.LaunchTemplateOverrides]?

    public var launchTemplateVersion: String?

    public var lifecycleHooks: [CreateScalingGroupRequest.LifecycleHooks]?

    public var loadBalancerConfigs: [CreateScalingGroupRequest.LoadBalancerConfigs]?

    public var loadBalancerIds: String?

    public var maxInstanceLifetime: Int32?

    public var maxSize: Int32?

    public var minSize: Int32?

    public var multiAZPolicy: String?

    public var onDemandBaseCapacity: Int32?

    public var onDemandPercentageAboveBaseCapacity: Int32?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var removalPolicies: [String]?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var scalingGroupName: String?

    public var scalingPolicy: String?

    public var serverGroups: [CreateScalingGroupRequest.ServerGroups]?

    public var spotAllocationStrategy: String?

    public var spotInstancePools: Int32?

    public var spotInstanceRemedy: Bool?

    public var stopInstanceTimeout: Int32?

    public var syncAlarmRuleToCms: Bool?

    public var tags: [CreateScalingGroupRequest.Tags]?

    public var VServerGroups: [CreateScalingGroupRequest.VServerGroups]?

    public var vSwitchId: String?

    public var vSwitchIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.capacityOptions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.albServerGroups != nil {
            var tmp : [Any] = []
            for k in self.albServerGroups! {
                tmp.append(k.toMap())
            }
            map["AlbServerGroups"] = tmp
        }
        if self.allocationStrategy != nil {
            map["AllocationStrategy"] = self.allocationStrategy!
        }
        if self.azBalance != nil {
            map["AzBalance"] = self.azBalance!
        }
        if self.capacityOptions != nil {
            map["CapacityOptions"] = self.capacityOptions?.toMap()
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.compensateWithOnDemand != nil {
            map["CompensateWithOnDemand"] = self.compensateWithOnDemand!
        }
        if self.containerGroupId != nil {
            map["ContainerGroupId"] = self.containerGroupId!
        }
        if self.customPolicyARN != nil {
            map["CustomPolicyARN"] = self.customPolicyARN!
        }
        if self.DBInstanceIds != nil {
            map["DBInstanceIds"] = self.DBInstanceIds!
        }
        if self.DBInstances != nil {
            var tmp : [Any] = []
            for k in self.DBInstances! {
                tmp.append(k.toMap())
            }
            map["DBInstances"] = tmp
        }
        if self.defaultCooldown != nil {
            map["DefaultCooldown"] = self.defaultCooldown!
        }
        if self.desiredCapacity != nil {
            map["DesiredCapacity"] = self.desiredCapacity!
        }
        if self.groupDeletionProtection != nil {
            map["GroupDeletionProtection"] = self.groupDeletionProtection!
        }
        if self.groupType != nil {
            map["GroupType"] = self.groupType!
        }
        if self.healthCheckType != nil {
            map["HealthCheckType"] = self.healthCheckType!
        }
        if self.healthCheckTypes != nil {
            map["HealthCheckTypes"] = self.healthCheckTypes!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.launchTemplateId != nil {
            map["LaunchTemplateId"] = self.launchTemplateId!
        }
        if self.launchTemplateOverrides != nil {
            var tmp : [Any] = []
            for k in self.launchTemplateOverrides! {
                tmp.append(k.toMap())
            }
            map["LaunchTemplateOverrides"] = tmp
        }
        if self.launchTemplateVersion != nil {
            map["LaunchTemplateVersion"] = self.launchTemplateVersion!
        }
        if self.lifecycleHooks != nil {
            var tmp : [Any] = []
            for k in self.lifecycleHooks! {
                tmp.append(k.toMap())
            }
            map["LifecycleHooks"] = tmp
        }
        if self.loadBalancerConfigs != nil {
            var tmp : [Any] = []
            for k in self.loadBalancerConfigs! {
                tmp.append(k.toMap())
            }
            map["LoadBalancerConfigs"] = tmp
        }
        if self.loadBalancerIds != nil {
            map["LoadBalancerIds"] = self.loadBalancerIds!
        }
        if self.maxInstanceLifetime != nil {
            map["MaxInstanceLifetime"] = self.maxInstanceLifetime!
        }
        if self.maxSize != nil {
            map["MaxSize"] = self.maxSize!
        }
        if self.minSize != nil {
            map["MinSize"] = self.minSize!
        }
        if self.multiAZPolicy != nil {
            map["MultiAZPolicy"] = self.multiAZPolicy!
        }
        if self.onDemandBaseCapacity != nil {
            map["OnDemandBaseCapacity"] = self.onDemandBaseCapacity!
        }
        if self.onDemandPercentageAboveBaseCapacity != nil {
            map["OnDemandPercentageAboveBaseCapacity"] = self.onDemandPercentageAboveBaseCapacity!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.removalPolicies != nil {
            map["RemovalPolicies"] = self.removalPolicies!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupName != nil {
            map["ScalingGroupName"] = self.scalingGroupName!
        }
        if self.scalingPolicy != nil {
            map["ScalingPolicy"] = self.scalingPolicy!
        }
        if self.serverGroups != nil {
            var tmp : [Any] = []
            for k in self.serverGroups! {
                tmp.append(k.toMap())
            }
            map["ServerGroups"] = tmp
        }
        if self.spotAllocationStrategy != nil {
            map["SpotAllocationStrategy"] = self.spotAllocationStrategy!
        }
        if self.spotInstancePools != nil {
            map["SpotInstancePools"] = self.spotInstancePools!
        }
        if self.spotInstanceRemedy != nil {
            map["SpotInstanceRemedy"] = self.spotInstanceRemedy!
        }
        if self.stopInstanceTimeout != nil {
            map["StopInstanceTimeout"] = self.stopInstanceTimeout!
        }
        if self.syncAlarmRuleToCms != nil {
            map["SyncAlarmRuleToCms"] = self.syncAlarmRuleToCms!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        if self.VServerGroups != nil {
            var tmp : [Any] = []
            for k in self.VServerGroups! {
                tmp.append(k.toMap())
            }
            map["VServerGroups"] = tmp
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.vSwitchIds != nil {
            map["VSwitchIds"] = self.vSwitchIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AlbServerGroups"] as? [Any?] {
            var tmp : [CreateScalingGroupRequest.AlbServerGroups] = []
            for v in value {
                if v != nil {
                    var model = CreateScalingGroupRequest.AlbServerGroups()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.albServerGroups = tmp
        }
        if let value = dict["AllocationStrategy"] as? String {
            self.allocationStrategy = value
        }
        if let value = dict["AzBalance"] as? Bool {
            self.azBalance = value
        }
        if let value = dict["CapacityOptions"] as? [String: Any?] {
            var model = CreateScalingGroupRequest.CapacityOptions()
            model.fromMap(value)
            self.capacityOptions = model
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["CompensateWithOnDemand"] as? Bool {
            self.compensateWithOnDemand = value
        }
        if let value = dict["ContainerGroupId"] as? String {
            self.containerGroupId = value
        }
        if let value = dict["CustomPolicyARN"] as? String {
            self.customPolicyARN = value
        }
        if let value = dict["DBInstanceIds"] as? String {
            self.DBInstanceIds = value
        }
        if let value = dict["DBInstances"] as? [Any?] {
            var tmp : [CreateScalingGroupRequest.DBInstances] = []
            for v in value {
                if v != nil {
                    var model = CreateScalingGroupRequest.DBInstances()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.DBInstances = tmp
        }
        if let value = dict["DefaultCooldown"] as? Int32 {
            self.defaultCooldown = value
        }
        if let value = dict["DesiredCapacity"] as? Int32 {
            self.desiredCapacity = value
        }
        if let value = dict["GroupDeletionProtection"] as? Bool {
            self.groupDeletionProtection = value
        }
        if let value = dict["GroupType"] as? String {
            self.groupType = value
        }
        if let value = dict["HealthCheckType"] as? String {
            self.healthCheckType = value
        }
        if let value = dict["HealthCheckTypes"] as? [String] {
            self.healthCheckTypes = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["LaunchTemplateId"] as? String {
            self.launchTemplateId = value
        }
        if let value = dict["LaunchTemplateOverrides"] as? [Any?] {
            var tmp : [CreateScalingGroupRequest.LaunchTemplateOverrides] = []
            for v in value {
                if v != nil {
                    var model = CreateScalingGroupRequest.LaunchTemplateOverrides()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.launchTemplateOverrides = tmp
        }
        if let value = dict["LaunchTemplateVersion"] as? String {
            self.launchTemplateVersion = value
        }
        if let value = dict["LifecycleHooks"] as? [Any?] {
            var tmp : [CreateScalingGroupRequest.LifecycleHooks] = []
            for v in value {
                if v != nil {
                    var model = CreateScalingGroupRequest.LifecycleHooks()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.lifecycleHooks = tmp
        }
        if let value = dict["LoadBalancerConfigs"] as? [Any?] {
            var tmp : [CreateScalingGroupRequest.LoadBalancerConfigs] = []
            for v in value {
                if v != nil {
                    var model = CreateScalingGroupRequest.LoadBalancerConfigs()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.loadBalancerConfigs = tmp
        }
        if let value = dict["LoadBalancerIds"] as? String {
            self.loadBalancerIds = value
        }
        if let value = dict["MaxInstanceLifetime"] as? Int32 {
            self.maxInstanceLifetime = value
        }
        if let value = dict["MaxSize"] as? Int32 {
            self.maxSize = value
        }
        if let value = dict["MinSize"] as? Int32 {
            self.minSize = value
        }
        if let value = dict["MultiAZPolicy"] as? String {
            self.multiAZPolicy = value
        }
        if let value = dict["OnDemandBaseCapacity"] as? Int32 {
            self.onDemandBaseCapacity = value
        }
        if let value = dict["OnDemandPercentageAboveBaseCapacity"] as? Int32 {
            self.onDemandPercentageAboveBaseCapacity = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RemovalPolicies"] as? [String] {
            self.removalPolicies = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ScalingGroupName"] as? String {
            self.scalingGroupName = value
        }
        if let value = dict["ScalingPolicy"] as? String {
            self.scalingPolicy = value
        }
        if let value = dict["ServerGroups"] as? [Any?] {
            var tmp : [CreateScalingGroupRequest.ServerGroups] = []
            for v in value {
                if v != nil {
                    var model = CreateScalingGroupRequest.ServerGroups()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.serverGroups = tmp
        }
        if let value = dict["SpotAllocationStrategy"] as? String {
            self.spotAllocationStrategy = value
        }
        if let value = dict["SpotInstancePools"] as? Int32 {
            self.spotInstancePools = value
        }
        if let value = dict["SpotInstanceRemedy"] as? Bool {
            self.spotInstanceRemedy = value
        }
        if let value = dict["StopInstanceTimeout"] as? Int32 {
            self.stopInstanceTimeout = value
        }
        if let value = dict["SyncAlarmRuleToCms"] as? Bool {
            self.syncAlarmRuleToCms = value
        }
        if let value = dict["Tags"] as? [Any?] {
            var tmp : [CreateScalingGroupRequest.Tags] = []
            for v in value {
                if v != nil {
                    var model = CreateScalingGroupRequest.Tags()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tags = tmp
        }
        if let value = dict["VServerGroups"] as? [Any?] {
            var tmp : [CreateScalingGroupRequest.VServerGroups] = []
            for v in value {
                if v != nil {
                    var model = CreateScalingGroupRequest.VServerGroups()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.VServerGroups = tmp
        }
        if let value = dict["VSwitchId"] as? String {
            self.vSwitchId = value
        }
        if let value = dict["VSwitchIds"] as? [String] {
            self.vSwitchIds = value
        }
    }
}

public class CreateScalingGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ScalingGroupId"] as? String {
            self.scalingGroupId = value
        }
    }
}

public class CreateScalingGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateScalingGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateScalingGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateScalingRuleRequest : Tea.TeaModel {
    public class AlarmDimensions : Tea.TeaModel {
        public var dimensionKey: String?

        public var dimensionValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dimensionKey != nil {
                map["DimensionKey"] = self.dimensionKey!
            }
            if self.dimensionValue != nil {
                map["DimensionValue"] = self.dimensionValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DimensionKey"] as? String {
                self.dimensionKey = value
            }
            if let value = dict["DimensionValue"] as? String {
                self.dimensionValue = value
            }
        }
    }
    public class AlarmOptions : Tea.TeaModel {
        public var period: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.period != nil {
                map["Period"] = self.period!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Period"] as? Int32 {
                self.period = value
            }
        }
    }
    public class HybridMetrics : Tea.TeaModel {
        public class Dimensions : Tea.TeaModel {
            public var dimensionKey: String?

            public var dimensionValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dimensionKey != nil {
                    map["DimensionKey"] = self.dimensionKey!
                }
                if self.dimensionValue != nil {
                    map["DimensionValue"] = self.dimensionValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DimensionKey"] as? String {
                    self.dimensionKey = value
                }
                if let value = dict["DimensionValue"] as? String {
                    self.dimensionValue = value
                }
            }
        }
        public var dimensions: [CreateScalingRuleRequest.HybridMetrics.Dimensions]?

        public var expression: String?

        public var id: String?

        public var metricName: String?

        public var statistic: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dimensions != nil {
                var tmp : [Any] = []
                for k in self.dimensions! {
                    tmp.append(k.toMap())
                }
                map["Dimensions"] = tmp
            }
            if self.expression != nil {
                map["Expression"] = self.expression!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.metricName != nil {
                map["MetricName"] = self.metricName!
            }
            if self.statistic != nil {
                map["Statistic"] = self.statistic!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Dimensions"] as? [Any?] {
                var tmp : [CreateScalingRuleRequest.HybridMetrics.Dimensions] = []
                for v in value {
                    if v != nil {
                        var model = CreateScalingRuleRequest.HybridMetrics.Dimensions()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.dimensions = tmp
            }
            if let value = dict["Expression"] as? String {
                self.expression = value
            }
            if let value = dict["Id"] as? String {
                self.id = value
            }
            if let value = dict["MetricName"] as? String {
                self.metricName = value
            }
            if let value = dict["Statistic"] as? String {
                self.statistic = value
            }
        }
    }
    public class StepAdjustments : Tea.TeaModel {
        public var metricIntervalLowerBound: Double?

        public var metricIntervalUpperBound: Double?

        public var scalingAdjustment: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.metricIntervalLowerBound != nil {
                map["MetricIntervalLowerBound"] = self.metricIntervalLowerBound!
            }
            if self.metricIntervalUpperBound != nil {
                map["MetricIntervalUpperBound"] = self.metricIntervalUpperBound!
            }
            if self.scalingAdjustment != nil {
                map["ScalingAdjustment"] = self.scalingAdjustment!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["MetricIntervalLowerBound"] as? Double {
                self.metricIntervalLowerBound = value
            }
            if let value = dict["MetricIntervalUpperBound"] as? Double {
                self.metricIntervalUpperBound = value
            }
            if let value = dict["ScalingAdjustment"] as? Int32 {
                self.scalingAdjustment = value
            }
        }
    }
    public var adjustmentType: String?

    public var adjustmentValue: Int32?

    public var alarmDimensions: [CreateScalingRuleRequest.AlarmDimensions]?

    public var alarmOptions: CreateScalingRuleRequest.AlarmOptions?

    public var cooldown: Int32?

    public var disableScaleIn: Bool?

    public var estimatedInstanceWarmup: Int32?

    public var hybridMetrics: [CreateScalingRuleRequest.HybridMetrics]?

    public var hybridMonitorNamespace: String?

    public var initialMaxSize: Int32?

    public var metricName: String?

    public var metricType: String?

    public var minAdjustmentMagnitude: Int32?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var predictiveScalingMode: String?

    public var predictiveTaskBufferTime: Int32?

    public var predictiveValueBehavior: String?

    public var predictiveValueBuffer: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scaleInEvaluationCount: Int32?

    public var scaleOutEvaluationCount: Int32?

    public var scalingGroupId: String?

    public var scalingRuleName: String?

    public var scalingRuleType: String?

    public var stepAdjustments: [CreateScalingRuleRequest.StepAdjustments]?

    public var targetValue: Double?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.alarmOptions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.adjustmentType != nil {
            map["AdjustmentType"] = self.adjustmentType!
        }
        if self.adjustmentValue != nil {
            map["AdjustmentValue"] = self.adjustmentValue!
        }
        if self.alarmDimensions != nil {
            var tmp : [Any] = []
            for k in self.alarmDimensions! {
                tmp.append(k.toMap())
            }
            map["AlarmDimensions"] = tmp
        }
        if self.alarmOptions != nil {
            map["AlarmOptions"] = self.alarmOptions?.toMap()
        }
        if self.cooldown != nil {
            map["Cooldown"] = self.cooldown!
        }
        if self.disableScaleIn != nil {
            map["DisableScaleIn"] = self.disableScaleIn!
        }
        if self.estimatedInstanceWarmup != nil {
            map["EstimatedInstanceWarmup"] = self.estimatedInstanceWarmup!
        }
        if self.hybridMetrics != nil {
            var tmp : [Any] = []
            for k in self.hybridMetrics! {
                tmp.append(k.toMap())
            }
            map["HybridMetrics"] = tmp
        }
        if self.hybridMonitorNamespace != nil {
            map["HybridMonitorNamespace"] = self.hybridMonitorNamespace!
        }
        if self.initialMaxSize != nil {
            map["InitialMaxSize"] = self.initialMaxSize!
        }
        if self.metricName != nil {
            map["MetricName"] = self.metricName!
        }
        if self.metricType != nil {
            map["MetricType"] = self.metricType!
        }
        if self.minAdjustmentMagnitude != nil {
            map["MinAdjustmentMagnitude"] = self.minAdjustmentMagnitude!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.predictiveScalingMode != nil {
            map["PredictiveScalingMode"] = self.predictiveScalingMode!
        }
        if self.predictiveTaskBufferTime != nil {
            map["PredictiveTaskBufferTime"] = self.predictiveTaskBufferTime!
        }
        if self.predictiveValueBehavior != nil {
            map["PredictiveValueBehavior"] = self.predictiveValueBehavior!
        }
        if self.predictiveValueBuffer != nil {
            map["PredictiveValueBuffer"] = self.predictiveValueBuffer!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scaleInEvaluationCount != nil {
            map["ScaleInEvaluationCount"] = self.scaleInEvaluationCount!
        }
        if self.scaleOutEvaluationCount != nil {
            map["ScaleOutEvaluationCount"] = self.scaleOutEvaluationCount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        if self.scalingRuleName != nil {
            map["ScalingRuleName"] = self.scalingRuleName!
        }
        if self.scalingRuleType != nil {
            map["ScalingRuleType"] = self.scalingRuleType!
        }
        if self.stepAdjustments != nil {
            var tmp : [Any] = []
            for k in self.stepAdjustments! {
                tmp.append(k.toMap())
            }
            map["StepAdjustments"] = tmp
        }
        if self.targetValue != nil {
            map["TargetValue"] = self.targetValue!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AdjustmentType"] as? String {
            self.adjustmentType = value
        }
        if let value = dict["AdjustmentValue"] as? Int32 {
            self.adjustmentValue = value
        }
        if let value = dict["AlarmDimensions"] as? [Any?] {
            var tmp : [CreateScalingRuleRequest.AlarmDimensions] = []
            for v in value {
                if v != nil {
                    var model = CreateScalingRuleRequest.AlarmDimensions()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.alarmDimensions = tmp
        }
        if let value = dict["AlarmOptions"] as? [String: Any?] {
            var model = CreateScalingRuleRequest.AlarmOptions()
            model.fromMap(value)
            self.alarmOptions = model
        }
        if let value = dict["Cooldown"] as? Int32 {
            self.cooldown = value
        }
        if let value = dict["DisableScaleIn"] as? Bool {
            self.disableScaleIn = value
        }
        if let value = dict["EstimatedInstanceWarmup"] as? Int32 {
            self.estimatedInstanceWarmup = value
        }
        if let value = dict["HybridMetrics"] as? [Any?] {
            var tmp : [CreateScalingRuleRequest.HybridMetrics] = []
            for v in value {
                if v != nil {
                    var model = CreateScalingRuleRequest.HybridMetrics()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.hybridMetrics = tmp
        }
        if let value = dict["HybridMonitorNamespace"] as? String {
            self.hybridMonitorNamespace = value
        }
        if let value = dict["InitialMaxSize"] as? Int32 {
            self.initialMaxSize = value
        }
        if let value = dict["MetricName"] as? String {
            self.metricName = value
        }
        if let value = dict["MetricType"] as? String {
            self.metricType = value
        }
        if let value = dict["MinAdjustmentMagnitude"] as? Int32 {
            self.minAdjustmentMagnitude = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PredictiveScalingMode"] as? String {
            self.predictiveScalingMode = value
        }
        if let value = dict["PredictiveTaskBufferTime"] as? Int32 {
            self.predictiveTaskBufferTime = value
        }
        if let value = dict["PredictiveValueBehavior"] as? String {
            self.predictiveValueBehavior = value
        }
        if let value = dict["PredictiveValueBuffer"] as? Int32 {
            self.predictiveValueBuffer = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ScaleInEvaluationCount"] as? Int32 {
            self.scaleInEvaluationCount = value
        }
        if let value = dict["ScaleOutEvaluationCount"] as? Int32 {
            self.scaleOutEvaluationCount = value
        }
        if let value = dict["ScalingGroupId"] as? String {
            self.scalingGroupId = value
        }
        if let value = dict["ScalingRuleName"] as? String {
            self.scalingRuleName = value
        }
        if let value = dict["ScalingRuleType"] as? String {
            self.scalingRuleType = value
        }
        if let value = dict["StepAdjustments"] as? [Any?] {
            var tmp : [CreateScalingRuleRequest.StepAdjustments] = []
            for v in value {
                if v != nil {
                    var model = CreateScalingRuleRequest.StepAdjustments()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.stepAdjustments = tmp
        }
        if let value = dict["TargetValue"] as? Double {
            self.targetValue = value
        }
    }
}

public class CreateScalingRuleResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var scalingRuleAri: String?

    public var scalingRuleId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingRuleAri != nil {
            map["ScalingRuleAri"] = self.scalingRuleAri!
        }
        if self.scalingRuleId != nil {
            map["ScalingRuleId"] = self.scalingRuleId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ScalingRuleAri"] as? String {
            self.scalingRuleAri = value
        }
        if let value = dict["ScalingRuleId"] as? String {
            self.scalingRuleId = value
        }
    }
}

public class CreateScalingRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateScalingRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateScalingRuleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateScheduledTaskRequest : Tea.TeaModel {
    public var description_: String?

    public var desiredCapacity: Int32?

    public var launchExpirationTime: Int32?

    public var launchTime: String?

    public var maxValue: Int32?

    public var minValue: Int32?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var recurrenceEndTime: String?

    public var recurrenceType: String?

    public var recurrenceValue: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public var scheduledAction: String?

    public var scheduledTaskName: String?

    public var taskEnabled: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.desiredCapacity != nil {
            map["DesiredCapacity"] = self.desiredCapacity!
        }
        if self.launchExpirationTime != nil {
            map["LaunchExpirationTime"] = self.launchExpirationTime!
        }
        if self.launchTime != nil {
            map["LaunchTime"] = self.launchTime!
        }
        if self.maxValue != nil {
            map["MaxValue"] = self.maxValue!
        }
        if self.minValue != nil {
            map["MinValue"] = self.minValue!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.recurrenceEndTime != nil {
            map["RecurrenceEndTime"] = self.recurrenceEndTime!
        }
        if self.recurrenceType != nil {
            map["RecurrenceType"] = self.recurrenceType!
        }
        if self.recurrenceValue != nil {
            map["RecurrenceValue"] = self.recurrenceValue!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        if self.scheduledAction != nil {
            map["ScheduledAction"] = self.scheduledAction!
        }
        if self.scheduledTaskName != nil {
            map["ScheduledTaskName"] = self.scheduledTaskName!
        }
        if self.taskEnabled != nil {
            map["TaskEnabled"] = self.taskEnabled!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["DesiredCapacity"] as? Int32 {
            self.desiredCapacity = value
        }
        if let value = dict["LaunchExpirationTime"] as? Int32 {
            self.launchExpirationTime = value
        }
        if let value = dict["LaunchTime"] as? String {
            self.launchTime = value
        }
        if let value = dict["MaxValue"] as? Int32 {
            self.maxValue = value
        }
        if let value = dict["MinValue"] as? Int32 {
            self.minValue = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RecurrenceEndTime"] as? String {
            self.recurrenceEndTime = value
        }
        if let value = dict["RecurrenceType"] as? String {
            self.recurrenceType = value
        }
        if let value = dict["RecurrenceValue"] as? String {
            self.recurrenceValue = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ScalingGroupId"] as? String {
            self.scalingGroupId = value
        }
        if let value = dict["ScheduledAction"] as? String {
            self.scheduledAction = value
        }
        if let value = dict["ScheduledTaskName"] as? String {
            self.scheduledTaskName = value
        }
        if let value = dict["TaskEnabled"] as? Bool {
            self.taskEnabled = value
        }
    }
}

public class CreateScheduledTaskResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var scheduledTaskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scheduledTaskId != nil {
            map["ScheduledTaskId"] = self.scheduledTaskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ScheduledTaskId"] as? String {
            self.scheduledTaskId = value
        }
    }
}

public class CreateScheduledTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateScheduledTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateScheduledTaskResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeactivateScalingConfigurationRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var scalingConfigurationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingConfigurationId != nil {
            map["ScalingConfigurationId"] = self.scalingConfigurationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ScalingConfigurationId"] as? String {
            self.scalingConfigurationId = value
        }
    }
}

public class DeactivateScalingConfigurationResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeactivateScalingConfigurationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeactivateScalingConfigurationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeactivateScalingConfigurationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteAlarmRequest : Tea.TeaModel {
    public var alarmTaskId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alarmTaskId != nil {
            map["AlarmTaskId"] = self.alarmTaskId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AlarmTaskId"] as? String {
            self.alarmTaskId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
    }
}

public class DeleteAlarmResponseBody : Tea.TeaModel {
    public var alarmTaskId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alarmTaskId != nil {
            map["AlarmTaskId"] = self.alarmTaskId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AlarmTaskId"] as? String {
            self.alarmTaskId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteAlarmResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteAlarmResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteAlarmResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteEciScalingConfigurationRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingConfigurationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingConfigurationId != nil {
            map["ScalingConfigurationId"] = self.scalingConfigurationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ScalingConfigurationId"] as? String {
            self.scalingConfigurationId = value
        }
    }
}

public class DeleteEciScalingConfigurationResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteEciScalingConfigurationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteEciScalingConfigurationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteEciScalingConfigurationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteLifecycleHookRequest : Tea.TeaModel {
    public var lifecycleHookId: String?

    public var lifecycleHookName: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lifecycleHookId != nil {
            map["LifecycleHookId"] = self.lifecycleHookId!
        }
        if self.lifecycleHookName != nil {
            map["LifecycleHookName"] = self.lifecycleHookName!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["LifecycleHookId"] as? String {
            self.lifecycleHookId = value
        }
        if let value = dict["LifecycleHookName"] as? String {
            self.lifecycleHookName = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ScalingGroupId"] as? String {
            self.scalingGroupId = value
        }
    }
}

public class DeleteLifecycleHookResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteLifecycleHookResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLifecycleHookResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteLifecycleHookResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteNotificationConfigurationRequest : Tea.TeaModel {
    public var notificationArn: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.notificationArn != nil {
            map["NotificationArn"] = self.notificationArn!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NotificationArn"] as? String {
            self.notificationArn = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ScalingGroupId"] as? String {
            self.scalingGroupId = value
        }
    }
}

public class DeleteNotificationConfigurationResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteNotificationConfigurationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteNotificationConfigurationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteNotificationConfigurationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteScalingConfigurationRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var scalingConfigurationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingConfigurationId != nil {
            map["ScalingConfigurationId"] = self.scalingConfigurationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ScalingConfigurationId"] as? String {
            self.scalingConfigurationId = value
        }
    }
}

public class DeleteScalingConfigurationResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteScalingConfigurationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteScalingConfigurationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteScalingConfigurationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteScalingGroupRequest : Tea.TeaModel {
    public var forceDelete: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.forceDelete != nil {
            map["ForceDelete"] = self.forceDelete!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ForceDelete"] as? Bool {
            self.forceDelete = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ScalingGroupId"] as? String {
            self.scalingGroupId = value
        }
    }
}

public class DeleteScalingGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteScalingGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteScalingGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteScalingGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteScalingRuleRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingRuleId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingRuleId != nil {
            map["ScalingRuleId"] = self.scalingRuleId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ScalingRuleId"] as? String {
            self.scalingRuleId = value
        }
    }
}

public class DeleteScalingRuleResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteScalingRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteScalingRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteScalingRuleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteScheduledTaskRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scheduledTaskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scheduledTaskId != nil {
            map["ScheduledTaskId"] = self.scheduledTaskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ScheduledTaskId"] as? String {
            self.scheduledTaskId = value
        }
    }
}

public class DeleteScheduledTaskResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteScheduledTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteScheduledTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteScheduledTaskResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeAlarmsRequest : Tea.TeaModel {
    public var alarmTaskId: String?

    public var isEnable: Bool?

    public var metricName: String?

    public var metricType: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public var state: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alarmTaskId != nil {
            map["AlarmTaskId"] = self.alarmTaskId!
        }
        if self.isEnable != nil {
            map["IsEnable"] = self.isEnable!
        }
        if self.metricName != nil {
            map["MetricName"] = self.metricName!
        }
        if self.metricType != nil {
            map["MetricType"] = self.metricType!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AlarmTaskId"] as? String {
            self.alarmTaskId = value
        }
        if let value = dict["IsEnable"] as? Bool {
            self.isEnable = value
        }
        if let value = dict["MetricName"] as? String {
            self.metricName = value
        }
        if let value = dict["MetricType"] as? String {
            self.metricType = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ScalingGroupId"] as? String {
            self.scalingGroupId = value
        }
        if let value = dict["State"] as? String {
            self.state = value
        }
    }
}

public class DescribeAlarmsResponseBody : Tea.TeaModel {
    public class AlarmList : Tea.TeaModel {
        public class Dimensions : Tea.TeaModel {
            public var dimensionKey: String?

            public var dimensionValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dimensionKey != nil {
                    map["DimensionKey"] = self.dimensionKey!
                }
                if self.dimensionValue != nil {
                    map["DimensionValue"] = self.dimensionValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DimensionKey"] as? String {
                    self.dimensionKey = value
                }
                if let value = dict["DimensionValue"] as? String {
                    self.dimensionValue = value
                }
            }
        }
        public class Expressions : Tea.TeaModel {
            public var comparisonOperator: String?

            public var metricName: String?

            public var period: Int32?

            public var statistics: String?

            public var threshold: Double?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.comparisonOperator != nil {
                    map["ComparisonOperator"] = self.comparisonOperator!
                }
                if self.metricName != nil {
                    map["MetricName"] = self.metricName!
                }
                if self.period != nil {
                    map["Period"] = self.period!
                }
                if self.statistics != nil {
                    map["Statistics"] = self.statistics!
                }
                if self.threshold != nil {
                    map["Threshold"] = self.threshold!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ComparisonOperator"] as? String {
                    self.comparisonOperator = value
                }
                if let value = dict["MetricName"] as? String {
                    self.metricName = value
                }
                if let value = dict["Period"] as? Int32 {
                    self.period = value
                }
                if let value = dict["Statistics"] as? String {
                    self.statistics = value
                }
                if let value = dict["Threshold"] as? Double {
                    self.threshold = value
                }
            }
        }
        public class HybridMetrics : Tea.TeaModel {
            public class Dimensions : Tea.TeaModel {
                public var dimensionKey: String?

                public var dimensionValue: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dimensionKey != nil {
                        map["DimensionKey"] = self.dimensionKey!
                    }
                    if self.dimensionValue != nil {
                        map["DimensionValue"] = self.dimensionValue!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["DimensionKey"] as? String {
                        self.dimensionKey = value
                    }
                    if let value = dict["DimensionValue"] as? String {
                        self.dimensionValue = value
                    }
                }
            }
            public var dimensions: [DescribeAlarmsResponseBody.AlarmList.HybridMetrics.Dimensions]?

            public var expression: String?

            public var id: String?

            public var metricName: String?

            public var statistic: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dimensions != nil {
                    var tmp : [Any] = []
                    for k in self.dimensions! {
                        tmp.append(k.toMap())
                    }
                    map["Dimensions"] = tmp
                }
                if self.expression != nil {
                    map["Expression"] = self.expression!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.metricName != nil {
                    map["MetricName"] = self.metricName!
                }
                if self.statistic != nil {
                    map["Statistic"] = self.statistic!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Dimensions"] as? [Any?] {
                    var tmp : [DescribeAlarmsResponseBody.AlarmList.HybridMetrics.Dimensions] = []
                    for v in value {
                        if v != nil {
                            var model = DescribeAlarmsResponseBody.AlarmList.HybridMetrics.Dimensions()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.dimensions = tmp
                }
                if let value = dict["Expression"] as? String {
                    self.expression = value
                }
                if let value = dict["Id"] as? String {
                    self.id = value
                }
                if let value = dict["MetricName"] as? String {
                    self.metricName = value
                }
                if let value = dict["Statistic"] as? String {
                    self.statistic = value
                }
            }
        }
        public var alarmActions: [String]?

        public var alarmTaskId: String?

        public var comparisonOperator: String?

        public var description_: String?

        public var dimensions: [DescribeAlarmsResponseBody.AlarmList.Dimensions]?

        public var effective: String?

        public var enable: Bool?

        public var evaluationCount: Int32?

        public var expressions: [DescribeAlarmsResponseBody.AlarmList.Expressions]?

        public var expressionsLogicOperator: String?

        public var hybridMetrics: [DescribeAlarmsResponseBody.AlarmList.HybridMetrics]?

        public var hybridMonitorNamespace: String?

        public var metricName: String?

        public var metricType: String?

        public var name: String?

        public var period: Int32?

        public var promQL: String?

        public var scalingGroupId: String?

        public var state: String?

        public var statistics: String?

        public var threshold: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alarmActions != nil {
                map["AlarmActions"] = self.alarmActions!
            }
            if self.alarmTaskId != nil {
                map["AlarmTaskId"] = self.alarmTaskId!
            }
            if self.comparisonOperator != nil {
                map["ComparisonOperator"] = self.comparisonOperator!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.dimensions != nil {
                var tmp : [Any] = []
                for k in self.dimensions! {
                    tmp.append(k.toMap())
                }
                map["Dimensions"] = tmp
            }
            if self.effective != nil {
                map["Effective"] = self.effective!
            }
            if self.enable != nil {
                map["Enable"] = self.enable!
            }
            if self.evaluationCount != nil {
                map["EvaluationCount"] = self.evaluationCount!
            }
            if self.expressions != nil {
                var tmp : [Any] = []
                for k in self.expressions! {
                    tmp.append(k.toMap())
                }
                map["Expressions"] = tmp
            }
            if self.expressionsLogicOperator != nil {
                map["ExpressionsLogicOperator"] = self.expressionsLogicOperator!
            }
            if self.hybridMetrics != nil {
                var tmp : [Any] = []
                for k in self.hybridMetrics! {
                    tmp.append(k.toMap())
                }
                map["HybridMetrics"] = tmp
            }
            if self.hybridMonitorNamespace != nil {
                map["HybridMonitorNamespace"] = self.hybridMonitorNamespace!
            }
            if self.metricName != nil {
                map["MetricName"] = self.metricName!
            }
            if self.metricType != nil {
                map["MetricType"] = self.metricType!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.period != nil {
                map["Period"] = self.period!
            }
            if self.promQL != nil {
                map["PromQL"] = self.promQL!
            }
            if self.scalingGroupId != nil {
                map["ScalingGroupId"] = self.scalingGroupId!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.statistics != nil {
                map["Statistics"] = self.statistics!
            }
            if self.threshold != nil {
                map["Threshold"] = self.threshold!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AlarmActions"] as? [String] {
                self.alarmActions = value
            }
            if let value = dict["AlarmTaskId"] as? String {
                self.alarmTaskId = value
            }
            if let value = dict["ComparisonOperator"] as? String {
                self.comparisonOperator = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["Dimensions"] as? [Any?] {
                var tmp : [DescribeAlarmsResponseBody.AlarmList.Dimensions] = []
                for v in value {
                    if v != nil {
                        var model = DescribeAlarmsResponseBody.AlarmList.Dimensions()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.dimensions = tmp
            }
            if let value = dict["Effective"] as? String {
                self.effective = value
            }
            if let value = dict["Enable"] as? Bool {
                self.enable = value
            }
            if let value = dict["EvaluationCount"] as? Int32 {
                self.evaluationCount = value
            }
            if let value = dict["Expressions"] as? [Any?] {
                var tmp : [DescribeAlarmsResponseBody.AlarmList.Expressions] = []
                for v in value {
                    if v != nil {
                        var model = DescribeAlarmsResponseBody.AlarmList.Expressions()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.expressions = tmp
            }
            if let value = dict["ExpressionsLogicOperator"] as? String {
                self.expressionsLogicOperator = value
            }
            if let value = dict["HybridMetrics"] as? [Any?] {
                var tmp : [DescribeAlarmsResponseBody.AlarmList.HybridMetrics] = []
                for v in value {
                    if v != nil {
                        var model = DescribeAlarmsResponseBody.AlarmList.HybridMetrics()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.hybridMetrics = tmp
            }
            if let value = dict["HybridMonitorNamespace"] as? String {
                self.hybridMonitorNamespace = value
            }
            if let value = dict["MetricName"] as? String {
                self.metricName = value
            }
            if let value = dict["MetricType"] as? String {
                self.metricType = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["Period"] as? Int32 {
                self.period = value
            }
            if let value = dict["PromQL"] as? String {
                self.promQL = value
            }
            if let value = dict["ScalingGroupId"] as? String {
                self.scalingGroupId = value
            }
            if let value = dict["State"] as? String {
                self.state = value
            }
            if let value = dict["Statistics"] as? String {
                self.statistics = value
            }
            if let value = dict["Threshold"] as? Double {
                self.threshold = value
            }
        }
    }
    public var alarmList: [DescribeAlarmsResponseBody.AlarmList]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alarmList != nil {
            var tmp : [Any] = []
            for k in self.alarmList! {
                tmp.append(k.toMap())
            }
            map["AlarmList"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AlarmList"] as? [Any?] {
            var tmp : [DescribeAlarmsResponseBody.AlarmList] = []
            for v in value {
                if v != nil {
                    var model = DescribeAlarmsResponseBody.AlarmList()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.alarmList = tmp
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeAlarmsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAlarmsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeAlarmsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeAlertConfigurationRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ScalingGroupId"] as? String {
            self.scalingGroupId = value
        }
    }
}

public class DescribeAlertConfigurationResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var scaleStatuses: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scaleStatuses != nil {
            map["ScaleStatuses"] = self.scaleStatuses!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ScaleStatuses"] as? [String] {
            self.scaleStatuses = value
        }
    }
}

public class DescribeAlertConfigurationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAlertConfigurationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeAlertConfigurationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDiagnoseReportsRequest : Tea.TeaModel {
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var reportIds: [String]?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.reportIds != nil {
            map["ReportIds"] = self.reportIds!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ReportIds"] as? [String] {
            self.reportIds = value
        }
        if let value = dict["ScalingGroupId"] as? String {
            self.scalingGroupId = value
        }
    }
}

public class DescribeDiagnoseReportsResponseBody : Tea.TeaModel {
    public class Reports : Tea.TeaModel {
        public class Details : Tea.TeaModel {
            public var diagnoseType: String?

            public var errorCode: String?

            public var resourceId: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.diagnoseType != nil {
                    map["DiagnoseType"] = self.diagnoseType!
                }
                if self.errorCode != nil {
                    map["ErrorCode"] = self.errorCode!
                }
                if self.resourceId != nil {
                    map["ResourceId"] = self.resourceId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DiagnoseType"] as? String {
                    self.diagnoseType = value
                }
                if let value = dict["ErrorCode"] as? String {
                    self.errorCode = value
                }
                if let value = dict["ResourceId"] as? String {
                    self.resourceId = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
            }
        }
        public var creationTime: String?

        public var details: [DescribeDiagnoseReportsResponseBody.Reports.Details]?

        public var diagnoseStatus: String?

        public var processStatus: String?

        public var regionId: String?

        public var reportId: String?

        public var scalingGroupId: String?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.details != nil {
                var tmp : [Any] = []
                for k in self.details! {
                    tmp.append(k.toMap())
                }
                map["Details"] = tmp
            }
            if self.diagnoseStatus != nil {
                map["DiagnoseStatus"] = self.diagnoseStatus!
            }
            if self.processStatus != nil {
                map["ProcessStatus"] = self.processStatus!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.reportId != nil {
                map["ReportId"] = self.reportId!
            }
            if self.scalingGroupId != nil {
                map["ScalingGroupId"] = self.scalingGroupId!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CreationTime"] as? String {
                self.creationTime = value
            }
            if let value = dict["Details"] as? [Any?] {
                var tmp : [DescribeDiagnoseReportsResponseBody.Reports.Details] = []
                for v in value {
                    if v != nil {
                        var model = DescribeDiagnoseReportsResponseBody.Reports.Details()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.details = tmp
            }
            if let value = dict["DiagnoseStatus"] as? String {
                self.diagnoseStatus = value
            }
            if let value = dict["ProcessStatus"] as? String {
                self.processStatus = value
            }
            if let value = dict["RegionId"] as? String {
                self.regionId = value
            }
            if let value = dict["ReportId"] as? String {
                self.reportId = value
            }
            if let value = dict["ScalingGroupId"] as? String {
                self.scalingGroupId = value
            }
            if let value = dict["UserId"] as? String {
                self.userId = value
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var reports: [DescribeDiagnoseReportsResponseBody.Reports]?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.reports != nil {
            var tmp : [Any] = []
            for k in self.reports! {
                tmp.append(k.toMap())
            }
            map["Reports"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["Reports"] as? [Any?] {
            var tmp : [DescribeDiagnoseReportsResponseBody.Reports] = []
            for v in value {
                if v != nil {
                    var model = DescribeDiagnoseReportsResponseBody.Reports()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.reports = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeDiagnoseReportsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDiagnoseReportsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDiagnoseReportsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeEciScalingConfigurationDetailRequest : Tea.TeaModel {
    public var outputFormat: String?

    public var regionId: String?

    public var scalingConfigurationId: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.outputFormat != nil {
            map["OutputFormat"] = self.outputFormat!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.scalingConfigurationId != nil {
            map["ScalingConfigurationId"] = self.scalingConfigurationId!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OutputFormat"] as? String {
            self.outputFormat = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ScalingConfigurationId"] as? String {
            self.scalingConfigurationId = value
        }
        if let value = dict["ScalingGroupId"] as? String {
            self.scalingGroupId = value
        }
    }
}

public class DescribeEciScalingConfigurationDetailResponseBody : Tea.TeaModel {
    public class ScalingConfiguration : Tea.TeaModel {
        public class AcrRegistryInfos : Tea.TeaModel {
            public var domains: [String]?

            public var instanceId: String?

            public var instanceName: String?

            public var regionId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.domains != nil {
                    map["Domains"] = self.domains!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.instanceName != nil {
                    map["InstanceName"] = self.instanceName!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Domains"] as? [String] {
                    self.domains = value
                }
                if let value = dict["InstanceId"] as? String {
                    self.instanceId = value
                }
                if let value = dict["InstanceName"] as? String {
                    self.instanceName = value
                }
                if let value = dict["RegionId"] as? String {
                    self.regionId = value
                }
            }
        }
        public class Containers : Tea.TeaModel {
            public class EnvironmentVars : Tea.TeaModel {
                public var fieldRefFieldPath: String?

                public var key: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.fieldRefFieldPath != nil {
                        map["FieldRefFieldPath"] = self.fieldRefFieldPath!
                    }
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["FieldRefFieldPath"] as? String {
                        self.fieldRefFieldPath = value
                    }
                    if let value = dict["Key"] as? String {
                        self.key = value
                    }
                    if let value = dict["Value"] as? String {
                        self.value = value
                    }
                }
            }
            public class Ports : Tea.TeaModel {
                public var port: Int32?

                public var protocol_: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.port != nil {
                        map["Port"] = self.port!
                    }
                    if self.protocol_ != nil {
                        map["Protocol"] = self.protocol_!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Port"] as? Int32 {
                        self.port = value
                    }
                    if let value = dict["Protocol"] as? String {
                        self.protocol_ = value
                    }
                }
            }
            public class VolumeMounts : Tea.TeaModel {
                public var mountPath: String?

                public var mountPropagation: String?

                public var name: String?

                public var readOnly: Bool?

                public var subPath: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.mountPath != nil {
                        map["MountPath"] = self.mountPath!
                    }
                    if self.mountPropagation != nil {
                        map["MountPropagation"] = self.mountPropagation!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.readOnly != nil {
                        map["ReadOnly"] = self.readOnly!
                    }
                    if self.subPath != nil {
                        map["SubPath"] = self.subPath!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["MountPath"] as? String {
                        self.mountPath = value
                    }
                    if let value = dict["MountPropagation"] as? String {
                        self.mountPropagation = value
                    }
                    if let value = dict["Name"] as? String {
                        self.name = value
                    }
                    if let value = dict["ReadOnly"] as? Bool {
                        self.readOnly = value
                    }
                    if let value = dict["SubPath"] as? String {
                        self.subPath = value
                    }
                }
            }
            public var args: [String]?

            public var commands: [String]?

            public var cpu: Double?

            public var environmentVars: [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.Containers.EnvironmentVars]?

            public var gpu: Int32?

            public var image: String?

            public var imagePullPolicy: String?

            public var lifecyclePostStartHandlerExecs: [String]?

            public var lifecyclePostStartHandlerHttpGetHost: String?

            public var lifecyclePostStartHandlerHttpGetPath: String?

            public var lifecyclePostStartHandlerHttpGetPort: Int32?

            public var lifecyclePostStartHandlerHttpGetScheme: String?

            public var lifecyclePostStartHandlerTcpSocketHost: String?

            public var lifecyclePostStartHandlerTcpSocketPort: Int32?

            public var lifecyclePreStopHandlerExecs: [String]?

            public var lifecyclePreStopHandlerHttpGetHost: String?

            public var lifecyclePreStopHandlerHttpGetPath: String?

            public var lifecyclePreStopHandlerHttpGetPort: Int32?

            public var lifecyclePreStopHandlerHttpGetScheme: String?

            public var lifecyclePreStopHandlerTcpSocketHost: String?

            public var lifecyclePreStopHandlerTcpSocketPort: Int32?

            public var livenessProbeExecCommands: [String]?

            public var livenessProbeFailureThreshold: Int32?

            public var livenessProbeHttpGetPath: String?

            public var livenessProbeHttpGetPort: Int32?

            public var livenessProbeHttpGetScheme: String?

            public var livenessProbeInitialDelaySeconds: Int32?

            public var livenessProbePeriodSeconds: Int32?

            public var livenessProbeSuccessThreshold: Int32?

            public var livenessProbeTcpSocketPort: Int32?

            public var livenessProbeTimeoutSeconds: Int32?

            public var memory: Double?

            public var name: String?

            public var ports: [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.Containers.Ports]?

            public var readinessProbeExecCommands: [String]?

            public var readinessProbeFailureThreshold: Int32?

            public var readinessProbeHttpGetPath: String?

            public var readinessProbeHttpGetPort: Int32?

            public var readinessProbeHttpGetScheme: String?

            public var readinessProbeInitialDelaySeconds: Int32?

            public var readinessProbePeriodSeconds: Int32?

            public var readinessProbeSuccessThreshold: Int32?

            public var readinessProbeTcpSocketPort: Int32?

            public var readinessProbeTimeoutSeconds: Int32?

            public var securityContextCapabilityAdds: [String]?

            public var securityContextReadOnlyRootFilesystem: Bool?

            public var securityContextRunAsUser: Int64?

            public var stdin: Bool?

            public var stdinOnce: Bool?

            public var tty: Bool?

            public var volumeMounts: [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.Containers.VolumeMounts]?

            public var workingDir: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.args != nil {
                    map["Args"] = self.args!
                }
                if self.commands != nil {
                    map["Commands"] = self.commands!
                }
                if self.cpu != nil {
                    map["Cpu"] = self.cpu!
                }
                if self.environmentVars != nil {
                    var tmp : [Any] = []
                    for k in self.environmentVars! {
                        tmp.append(k.toMap())
                    }
                    map["EnvironmentVars"] = tmp
                }
                if self.gpu != nil {
                    map["Gpu"] = self.gpu!
                }
                if self.image != nil {
                    map["Image"] = self.image!
                }
                if self.imagePullPolicy != nil {
                    map["ImagePullPolicy"] = self.imagePullPolicy!
                }
                if self.lifecyclePostStartHandlerExecs != nil {
                    map["LifecyclePostStartHandlerExecs"] = self.lifecyclePostStartHandlerExecs!
                }
                if self.lifecyclePostStartHandlerHttpGetHost != nil {
                    map["LifecyclePostStartHandlerHttpGetHost"] = self.lifecyclePostStartHandlerHttpGetHost!
                }
                if self.lifecyclePostStartHandlerHttpGetPath != nil {
                    map["LifecyclePostStartHandlerHttpGetPath"] = self.lifecyclePostStartHandlerHttpGetPath!
                }
                if self.lifecyclePostStartHandlerHttpGetPort != nil {
                    map["LifecyclePostStartHandlerHttpGetPort"] = self.lifecyclePostStartHandlerHttpGetPort!
                }
                if self.lifecyclePostStartHandlerHttpGetScheme != nil {
                    map["LifecyclePostStartHandlerHttpGetScheme"] = self.lifecyclePostStartHandlerHttpGetScheme!
                }
                if self.lifecyclePostStartHandlerTcpSocketHost != nil {
                    map["LifecyclePostStartHandlerTcpSocketHost"] = self.lifecyclePostStartHandlerTcpSocketHost!
                }
                if self.lifecyclePostStartHandlerTcpSocketPort != nil {
                    map["LifecyclePostStartHandlerTcpSocketPort"] = self.lifecyclePostStartHandlerTcpSocketPort!
                }
                if self.lifecyclePreStopHandlerExecs != nil {
                    map["LifecyclePreStopHandlerExecs"] = self.lifecyclePreStopHandlerExecs!
                }
                if self.lifecyclePreStopHandlerHttpGetHost != nil {
                    map["LifecyclePreStopHandlerHttpGetHost"] = self.lifecyclePreStopHandlerHttpGetHost!
                }
                if self.lifecyclePreStopHandlerHttpGetPath != nil {
                    map["LifecyclePreStopHandlerHttpGetPath"] = self.lifecyclePreStopHandlerHttpGetPath!
                }
                if self.lifecyclePreStopHandlerHttpGetPort != nil {
                    map["LifecyclePreStopHandlerHttpGetPort"] = self.lifecyclePreStopHandlerHttpGetPort!
                }
                if self.lifecyclePreStopHandlerHttpGetScheme != nil {
                    map["LifecyclePreStopHandlerHttpGetScheme"] = self.lifecyclePreStopHandlerHttpGetScheme!
                }
                if self.lifecyclePreStopHandlerTcpSocketHost != nil {
                    map["LifecyclePreStopHandlerTcpSocketHost"] = self.lifecyclePreStopHandlerTcpSocketHost!
                }
                if self.lifecyclePreStopHandlerTcpSocketPort != nil {
                    map["LifecyclePreStopHandlerTcpSocketPort"] = self.lifecyclePreStopHandlerTcpSocketPort!
                }
                if self.livenessProbeExecCommands != nil {
                    map["LivenessProbeExecCommands"] = self.livenessProbeExecCommands!
                }
                if self.livenessProbeFailureThreshold != nil {
                    map["LivenessProbeFailureThreshold"] = self.livenessProbeFailureThreshold!
                }
                if self.livenessProbeHttpGetPath != nil {
                    map["LivenessProbeHttpGetPath"] = self.livenessProbeHttpGetPath!
                }
                if self.livenessProbeHttpGetPort != nil {
                    map["LivenessProbeHttpGetPort"] = self.livenessProbeHttpGetPort!
                }
                if self.livenessProbeHttpGetScheme != nil {
                    map["LivenessProbeHttpGetScheme"] = self.livenessProbeHttpGetScheme!
                }
                if self.livenessProbeInitialDelaySeconds != nil {
                    map["LivenessProbeInitialDelaySeconds"] = self.livenessProbeInitialDelaySeconds!
                }
                if self.livenessProbePeriodSeconds != nil {
                    map["LivenessProbePeriodSeconds"] = self.livenessProbePeriodSeconds!
                }
                if self.livenessProbeSuccessThreshold != nil {
                    map["LivenessProbeSuccessThreshold"] = self.livenessProbeSuccessThreshold!
                }
                if self.livenessProbeTcpSocketPort != nil {
                    map["LivenessProbeTcpSocketPort"] = self.livenessProbeTcpSocketPort!
                }
                if self.livenessProbeTimeoutSeconds != nil {
                    map["LivenessProbeTimeoutSeconds"] = self.livenessProbeTimeoutSeconds!
                }
                if self.memory != nil {
                    map["Memory"] = self.memory!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.ports != nil {
                    var tmp : [Any] = []
                    for k in self.ports! {
                        tmp.append(k.toMap())
                    }
                    map["Ports"] = tmp
                }
                if self.readinessProbeExecCommands != nil {
                    map["ReadinessProbeExecCommands"] = self.readinessProbeExecCommands!
                }
                if self.readinessProbeFailureThreshold != nil {
                    map["ReadinessProbeFailureThreshold"] = self.readinessProbeFailureThreshold!
                }
                if self.readinessProbeHttpGetPath != nil {
                    map["ReadinessProbeHttpGetPath"] = self.readinessProbeHttpGetPath!
                }
                if self.readinessProbeHttpGetPort != nil {
                    map["ReadinessProbeHttpGetPort"] = self.readinessProbeHttpGetPort!
                }
                if self.readinessProbeHttpGetScheme != nil {
                    map["ReadinessProbeHttpGetScheme"] = self.readinessProbeHttpGetScheme!
                }
                if self.readinessProbeInitialDelaySeconds != nil {
                    map["ReadinessProbeInitialDelaySeconds"] = self.readinessProbeInitialDelaySeconds!
                }
                if self.readinessProbePeriodSeconds != nil {
                    map["ReadinessProbePeriodSeconds"] = self.readinessProbePeriodSeconds!
                }
                if self.readinessProbeSuccessThreshold != nil {
                    map["ReadinessProbeSuccessThreshold"] = self.readinessProbeSuccessThreshold!
                }
                if self.readinessProbeTcpSocketPort != nil {
                    map["ReadinessProbeTcpSocketPort"] = self.readinessProbeTcpSocketPort!
                }
                if self.readinessProbeTimeoutSeconds != nil {
                    map["ReadinessProbeTimeoutSeconds"] = self.readinessProbeTimeoutSeconds!
                }
                if self.securityContextCapabilityAdds != nil {
                    map["SecurityContextCapabilityAdds"] = self.securityContextCapabilityAdds!
                }
                if self.securityContextReadOnlyRootFilesystem != nil {
                    map["SecurityContextReadOnlyRootFilesystem"] = self.securityContextReadOnlyRootFilesystem!
                }
                if self.securityContextRunAsUser != nil {
                    map["SecurityContextRunAsUser"] = self.securityContextRunAsUser!
                }
                if self.stdin != nil {
                    map["Stdin"] = self.stdin!
                }
                if self.stdinOnce != nil {
                    map["StdinOnce"] = self.stdinOnce!
                }
                if self.tty != nil {
                    map["Tty"] = self.tty!
                }
                if self.volumeMounts != nil {
                    var tmp : [Any] = []
                    for k in self.volumeMounts! {
                        tmp.append(k.toMap())
                    }
                    map["VolumeMounts"] = tmp
                }
                if self.workingDir != nil {
                    map["WorkingDir"] = self.workingDir!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Args"] as? [String] {
                    self.args = value
                }
                if let value = dict["Commands"] as? [String] {
                    self.commands = value
                }
                if let value = dict["Cpu"] as? Double {
                    self.cpu = value
                }
                if let value = dict["EnvironmentVars"] as? [Any?] {
                    var tmp : [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.Containers.EnvironmentVars] = []
                    for v in value {
                        if v != nil {
                            var model = DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.Containers.EnvironmentVars()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.environmentVars = tmp
                }
                if let value = dict["Gpu"] as? Int32 {
                    self.gpu = value
                }
                if let value = dict["Image"] as? String {
                    self.image = value
                }
                if let value = dict["ImagePullPolicy"] as? String {
                    self.imagePullPolicy = value
                }
                if let value = dict["LifecyclePostStartHandlerExecs"] as? [String] {
                    self.lifecyclePostStartHandlerExecs = value
                }
                if let value = dict["LifecyclePostStartHandlerHttpGetHost"] as? String {
                    self.lifecyclePostStartHandlerHttpGetHost = value
                }
                if let value = dict["LifecyclePostStartHandlerHttpGetPath"] as? String {
                    self.lifecyclePostStartHandlerHttpGetPath = value
                }
                if let value = dict["LifecyclePostStartHandlerHttpGetPort"] as? Int32 {
                    self.lifecyclePostStartHandlerHttpGetPort = value
                }
                if let value = dict["LifecyclePostStartHandlerHttpGetScheme"] as? String {
                    self.lifecyclePostStartHandlerHttpGetScheme = value
                }
                if let value = dict["LifecyclePostStartHandlerTcpSocketHost"] as? String {
                    self.lifecyclePostStartHandlerTcpSocketHost = value
                }
                if let value = dict["LifecyclePostStartHandlerTcpSocketPort"] as? Int32 {
                    self.lifecyclePostStartHandlerTcpSocketPort = value
                }
                if let value = dict["LifecyclePreStopHandlerExecs"] as? [String] {
                    self.lifecyclePreStopHandlerExecs = value
                }
                if let value = dict["LifecyclePreStopHandlerHttpGetHost"] as? String {
                    self.lifecyclePreStopHandlerHttpGetHost = value
                }
                if let value = dict["LifecyclePreStopHandlerHttpGetPath"] as? String {
                    self.lifecyclePreStopHandlerHttpGetPath = value
                }
                if let value = dict["LifecyclePreStopHandlerHttpGetPort"] as? Int32 {
                    self.lifecyclePreStopHandlerHttpGetPort = value
                }
                if let value = dict["LifecyclePreStopHandlerHttpGetScheme"] as? String {
                    self.lifecyclePreStopHandlerHttpGetScheme = value
                }
                if let value = dict["LifecyclePreStopHandlerTcpSocketHost"] as? String {
                    self.lifecyclePreStopHandlerTcpSocketHost = value
                }
                if let value = dict["LifecyclePreStopHandlerTcpSocketPort"] as? Int32 {
                    self.lifecyclePreStopHandlerTcpSocketPort = value
                }
                if let value = dict["LivenessProbeExecCommands"] as? [String] {
                    self.livenessProbeExecCommands = value
                }
                if let value = dict["LivenessProbeFailureThreshold"] as? Int32 {
                    self.livenessProbeFailureThreshold = value
                }
                if let value = dict["LivenessProbeHttpGetPath"] as? String {
                    self.livenessProbeHttpGetPath = value
                }
                if let value = dict["LivenessProbeHttpGetPort"] as? Int32 {
                    self.livenessProbeHttpGetPort = value
                }
                if let value = dict["LivenessProbeHttpGetScheme"] as? String {
                    self.livenessProbeHttpGetScheme = value
                }
                if let value = dict["LivenessProbeInitialDelaySeconds"] as? Int32 {
                    self.livenessProbeInitialDelaySeconds = value
                }
                if let value = dict["LivenessProbePeriodSeconds"] as? Int32 {
                    self.livenessProbePeriodSeconds = value
                }
                if let value = dict["LivenessProbeSuccessThreshold"] as? Int32 {
                    self.livenessProbeSuccessThreshold = value
                }
                if let value = dict["LivenessProbeTcpSocketPort"] as? Int32 {
                    self.livenessProbeTcpSocketPort = value
                }
                if let value = dict["LivenessProbeTimeoutSeconds"] as? Int32 {
                    self.livenessProbeTimeoutSeconds = value
                }
                if let value = dict["Memory"] as? Double {
                    self.memory = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["Ports"] as? [Any?] {
                    var tmp : [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.Containers.Ports] = []
                    for v in value {
                        if v != nil {
                            var model = DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.Containers.Ports()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.ports = tmp
                }
                if let value = dict["ReadinessProbeExecCommands"] as? [String] {
                    self.readinessProbeExecCommands = value
                }
                if let value = dict["ReadinessProbeFailureThreshold"] as? Int32 {
                    self.readinessProbeFailureThreshold = value
                }
                if let value = dict["ReadinessProbeHttpGetPath"] as? String {
                    self.readinessProbeHttpGetPath = value
                }
                if let value = dict["ReadinessProbeHttpGetPort"] as? Int32 {
                    self.readinessProbeHttpGetPort = value
                }
                if let value = dict["ReadinessProbeHttpGetScheme"] as? String {
                    self.readinessProbeHttpGetScheme = value
                }
                if let value = dict["ReadinessProbeInitialDelaySeconds"] as? Int32 {
                    self.readinessProbeInitialDelaySeconds = value
                }
                if let value = dict["ReadinessProbePeriodSeconds"] as? Int32 {
                    self.readinessProbePeriodSeconds = value
                }
                if let value = dict["ReadinessProbeSuccessThreshold"] as? Int32 {
                    self.readinessProbeSuccessThreshold = value
                }
                if let value = dict["ReadinessProbeTcpSocketPort"] as? Int32 {
                    self.readinessProbeTcpSocketPort = value
                }
                if let value = dict["ReadinessProbeTimeoutSeconds"] as? Int32 {
                    self.readinessProbeTimeoutSeconds = value
                }
                if let value = dict["SecurityContextCapabilityAdds"] as? [String] {
                    self.securityContextCapabilityAdds = value
                }
                if let value = dict["SecurityContextReadOnlyRootFilesystem"] as? Bool {
                    self.securityContextReadOnlyRootFilesystem = value
                }
                if let value = dict["SecurityContextRunAsUser"] as? Int64 {
                    self.securityContextRunAsUser = value
                }
                if let value = dict["Stdin"] as? Bool {
                    self.stdin = value
                }
                if let value = dict["StdinOnce"] as? Bool {
                    self.stdinOnce = value
                }
                if let value = dict["Tty"] as? Bool {
                    self.tty = value
                }
                if let value = dict["VolumeMounts"] as? [Any?] {
                    var tmp : [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.Containers.VolumeMounts] = []
                    for v in value {
                        if v != nil {
                            var model = DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.Containers.VolumeMounts()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.volumeMounts = tmp
                }
                if let value = dict["WorkingDir"] as? String {
                    self.workingDir = value
                }
            }
        }
        public class DnsConfigOptions : Tea.TeaModel {
            public var name: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["Value"] as? String {
                    self.value = value
                }
            }
        }
        public class HostAliases : Tea.TeaModel {
            public var hostnames: [String]?

            public var ip: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.hostnames != nil {
                    map["Hostnames"] = self.hostnames!
                }
                if self.ip != nil {
                    map["Ip"] = self.ip!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Hostnames"] as? [String] {
                    self.hostnames = value
                }
                if let value = dict["Ip"] as? String {
                    self.ip = value
                }
            }
        }
        public class ImageRegistryCredentials : Tea.TeaModel {
            public var password: String?

            public var server: String?

            public var userName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.password != nil {
                    map["Password"] = self.password!
                }
                if self.server != nil {
                    map["Server"] = self.server!
                }
                if self.userName != nil {
                    map["UserName"] = self.userName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Password"] as? String {
                    self.password = value
                }
                if let value = dict["Server"] as? String {
                    self.server = value
                }
                if let value = dict["UserName"] as? String {
                    self.userName = value
                }
            }
        }
        public class InitContainers : Tea.TeaModel {
            public class InitContainerEnvironmentVars : Tea.TeaModel {
                public var fieldRefFieldPath: String?

                public var key: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.fieldRefFieldPath != nil {
                        map["FieldRefFieldPath"] = self.fieldRefFieldPath!
                    }
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["FieldRefFieldPath"] as? String {
                        self.fieldRefFieldPath = value
                    }
                    if let value = dict["Key"] as? String {
                        self.key = value
                    }
                    if let value = dict["Value"] as? String {
                        self.value = value
                    }
                }
            }
            public class InitContainerPorts : Tea.TeaModel {
                public var port: Int32?

                public var protocol_: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.port != nil {
                        map["Port"] = self.port!
                    }
                    if self.protocol_ != nil {
                        map["Protocol"] = self.protocol_!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Port"] as? Int32 {
                        self.port = value
                    }
                    if let value = dict["Protocol"] as? String {
                        self.protocol_ = value
                    }
                }
            }
            public class InitContainerVolumeMounts : Tea.TeaModel {
                public var mountPath: String?

                public var mountPropagation: String?

                public var name: String?

                public var readOnly: Bool?

                public var subPath: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.mountPath != nil {
                        map["MountPath"] = self.mountPath!
                    }
                    if self.mountPropagation != nil {
                        map["MountPropagation"] = self.mountPropagation!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.readOnly != nil {
                        map["ReadOnly"] = self.readOnly!
                    }
                    if self.subPath != nil {
                        map["SubPath"] = self.subPath!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["MountPath"] as? String {
                        self.mountPath = value
                    }
                    if let value = dict["MountPropagation"] as? String {
                        self.mountPropagation = value
                    }
                    if let value = dict["Name"] as? String {
                        self.name = value
                    }
                    if let value = dict["ReadOnly"] as? Bool {
                        self.readOnly = value
                    }
                    if let value = dict["SubPath"] as? String {
                        self.subPath = value
                    }
                }
            }
            public var cpu: Double?

            public var gpu: Int32?

            public var image: String?

            public var imagePullPolicy: String?

            public var initContainerArgs: [String]?

            public var initContainerCommands: [String]?

            public var initContainerEnvironmentVars: [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.InitContainers.InitContainerEnvironmentVars]?

            public var initContainerPorts: [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.InitContainers.InitContainerPorts]?

            public var initContainerVolumeMounts: [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.InitContainers.InitContainerVolumeMounts]?

            public var memory: Double?

            public var name: String?

            public var securityContextCapabilityAdds: [String]?

            public var securityContextReadOnlyRootFilesystem: Bool?

            public var securityContextRunAsUser: String?

            public var workingDir: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cpu != nil {
                    map["Cpu"] = self.cpu!
                }
                if self.gpu != nil {
                    map["Gpu"] = self.gpu!
                }
                if self.image != nil {
                    map["Image"] = self.image!
                }
                if self.imagePullPolicy != nil {
                    map["ImagePullPolicy"] = self.imagePullPolicy!
                }
                if self.initContainerArgs != nil {
                    map["InitContainerArgs"] = self.initContainerArgs!
                }
                if self.initContainerCommands != nil {
                    map["InitContainerCommands"] = self.initContainerCommands!
                }
                if self.initContainerEnvironmentVars != nil {
                    var tmp : [Any] = []
                    for k in self.initContainerEnvironmentVars! {
                        tmp.append(k.toMap())
                    }
                    map["InitContainerEnvironmentVars"] = tmp
                }
                if self.initContainerPorts != nil {
                    var tmp : [Any] = []
                    for k in self.initContainerPorts! {
                        tmp.append(k.toMap())
                    }
                    map["InitContainerPorts"] = tmp
                }
                if self.initContainerVolumeMounts != nil {
                    var tmp : [Any] = []
                    for k in self.initContainerVolumeMounts! {
                        tmp.append(k.toMap())
                    }
                    map["InitContainerVolumeMounts"] = tmp
                }
                if self.memory != nil {
                    map["Memory"] = self.memory!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.securityContextCapabilityAdds != nil {
                    map["SecurityContextCapabilityAdds"] = self.securityContextCapabilityAdds!
                }
                if self.securityContextReadOnlyRootFilesystem != nil {
                    map["SecurityContextReadOnlyRootFilesystem"] = self.securityContextReadOnlyRootFilesystem!
                }
                if self.securityContextRunAsUser != nil {
                    map["SecurityContextRunAsUser"] = self.securityContextRunAsUser!
                }
                if self.workingDir != nil {
                    map["WorkingDir"] = self.workingDir!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Cpu"] as? Double {
                    self.cpu = value
                }
                if let value = dict["Gpu"] as? Int32 {
                    self.gpu = value
                }
                if let value = dict["Image"] as? String {
                    self.image = value
                }
                if let value = dict["ImagePullPolicy"] as? String {
                    self.imagePullPolicy = value
                }
                if let value = dict["InitContainerArgs"] as? [String] {
                    self.initContainerArgs = value
                }
                if let value = dict["InitContainerCommands"] as? [String] {
                    self.initContainerCommands = value
                }
                if let value = dict["InitContainerEnvironmentVars"] as? [Any?] {
                    var tmp : [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.InitContainers.InitContainerEnvironmentVars] = []
                    for v in value {
                        if v != nil {
                            var model = DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.InitContainers.InitContainerEnvironmentVars()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.initContainerEnvironmentVars = tmp
                }
                if let value = dict["InitContainerPorts"] as? [Any?] {
                    var tmp : [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.InitContainers.InitContainerPorts] = []
                    for v in value {
                        if v != nil {
                            var model = DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.InitContainers.InitContainerPorts()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.initContainerPorts = tmp
                }
                if let value = dict["InitContainerVolumeMounts"] as? [Any?] {
                    var tmp : [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.InitContainers.InitContainerVolumeMounts] = []
                    for v in value {
                        if v != nil {
                            var model = DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.InitContainers.InitContainerVolumeMounts()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.initContainerVolumeMounts = tmp
                }
                if let value = dict["Memory"] as? Double {
                    self.memory = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["SecurityContextCapabilityAdds"] as? [String] {
                    self.securityContextCapabilityAdds = value
                }
                if let value = dict["SecurityContextReadOnlyRootFilesystem"] as? Bool {
                    self.securityContextReadOnlyRootFilesystem = value
                }
                if let value = dict["SecurityContextRunAsUser"] as? String {
                    self.securityContextRunAsUser = value
                }
                if let value = dict["WorkingDir"] as? String {
                    self.workingDir = value
                }
            }
        }
        public class SecurityContextSysCtls : Tea.TeaModel {
            public var name: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["Value"] as? String {
                    self.value = value
                }
            }
        }
        public class Tags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Key"] as? String {
                    self.key = value
                }
                if let value = dict["Value"] as? String {
                    self.value = value
                }
            }
        }
        public class Volumes : Tea.TeaModel {
            public class ConfigFileVolumeConfigFileToPaths : Tea.TeaModel {
                public var content: String?

                public var mode: Int32?

                public var path: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.content != nil {
                        map["Content"] = self.content!
                    }
                    if self.mode != nil {
                        map["Mode"] = self.mode!
                    }
                    if self.path != nil {
                        map["Path"] = self.path!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Content"] as? String {
                        self.content = value
                    }
                    if let value = dict["Mode"] as? Int32 {
                        self.mode = value
                    }
                    if let value = dict["Path"] as? String {
                        self.path = value
                    }
                }
            }
            public var configFileVolumeConfigFileToPaths: [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.Volumes.ConfigFileVolumeConfigFileToPaths]?

            public var configFileVolumeDefaultMode: Int32?

            public var diskVolumeDiskId: String?

            public var diskVolumeDiskSize: Int32?

            public var diskVolumeFsType: String?

            public var emptyDirVolumeMedium: String?

            public var emptyDirVolumeSizeLimit: String?

            public var flexVolumeDriver: String?

            public var flexVolumeFsType: String?

            public var flexVolumeOptions: String?

            public var hostPathVolumePath: String?

            public var hostPathVolumeType: String?

            public var NFSVolumePath: String?

            public var NFSVolumeReadOnly: Bool?

            public var NFSVolumeServer: String?

            public var name: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.configFileVolumeConfigFileToPaths != nil {
                    var tmp : [Any] = []
                    for k in self.configFileVolumeConfigFileToPaths! {
                        tmp.append(k.toMap())
                    }
                    map["ConfigFileVolumeConfigFileToPaths"] = tmp
                }
                if self.configFileVolumeDefaultMode != nil {
                    map["ConfigFileVolumeDefaultMode"] = self.configFileVolumeDefaultMode!
                }
                if self.diskVolumeDiskId != nil {
                    map["DiskVolumeDiskId"] = self.diskVolumeDiskId!
                }
                if self.diskVolumeDiskSize != nil {
                    map["DiskVolumeDiskSize"] = self.diskVolumeDiskSize!
                }
                if self.diskVolumeFsType != nil {
                    map["DiskVolumeFsType"] = self.diskVolumeFsType!
                }
                if self.emptyDirVolumeMedium != nil {
                    map["EmptyDirVolumeMedium"] = self.emptyDirVolumeMedium!
                }
                if self.emptyDirVolumeSizeLimit != nil {
                    map["EmptyDirVolumeSizeLimit"] = self.emptyDirVolumeSizeLimit!
                }
                if self.flexVolumeDriver != nil {
                    map["FlexVolumeDriver"] = self.flexVolumeDriver!
                }
                if self.flexVolumeFsType != nil {
                    map["FlexVolumeFsType"] = self.flexVolumeFsType!
                }
                if self.flexVolumeOptions != nil {
                    map["FlexVolumeOptions"] = self.flexVolumeOptions!
                }
                if self.hostPathVolumePath != nil {
                    map["HostPathVolumePath"] = self.hostPathVolumePath!
                }
                if self.hostPathVolumeType != nil {
                    map["HostPathVolumeType"] = self.hostPathVolumeType!
                }
                if self.NFSVolumePath != nil {
                    map["NFSVolumePath"] = self.NFSVolumePath!
                }
                if self.NFSVolumeReadOnly != nil {
                    map["NFSVolumeReadOnly"] = self.NFSVolumeReadOnly!
                }
                if self.NFSVolumeServer != nil {
                    map["NFSVolumeServer"] = self.NFSVolumeServer!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ConfigFileVolumeConfigFileToPaths"] as? [Any?] {
                    var tmp : [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.Volumes.ConfigFileVolumeConfigFileToPaths] = []
                    for v in value {
                        if v != nil {
                            var model = DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.Volumes.ConfigFileVolumeConfigFileToPaths()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.configFileVolumeConfigFileToPaths = tmp
                }
                if let value = dict["ConfigFileVolumeDefaultMode"] as? Int32 {
                    self.configFileVolumeDefaultMode = value
                }
                if let value = dict["DiskVolumeDiskId"] as? String {
                    self.diskVolumeDiskId = value
                }
                if let value = dict["DiskVolumeDiskSize"] as? Int32 {
                    self.diskVolumeDiskSize = value
                }
                if let value = dict["DiskVolumeFsType"] as? String {
                    self.diskVolumeFsType = value
                }
                if let value = dict["EmptyDirVolumeMedium"] as? String {
                    self.emptyDirVolumeMedium = value
                }
                if let value = dict["EmptyDirVolumeSizeLimit"] as? String {
                    self.emptyDirVolumeSizeLimit = value
                }
                if let value = dict["FlexVolumeDriver"] as? String {
                    self.flexVolumeDriver = value
                }
                if let value = dict["FlexVolumeFsType"] as? String {
                    self.flexVolumeFsType = value
                }
                if let value = dict["FlexVolumeOptions"] as? String {
                    self.flexVolumeOptions = value
                }
                if let value = dict["HostPathVolumePath"] as? String {
                    self.hostPathVolumePath = value
                }
                if let value = dict["HostPathVolumeType"] as? String {
                    self.hostPathVolumeType = value
                }
                if let value = dict["NFSVolumePath"] as? String {
                    self.NFSVolumePath = value
                }
                if let value = dict["NFSVolumeReadOnly"] as? Bool {
                    self.NFSVolumeReadOnly = value
                }
                if let value = dict["NFSVolumeServer"] as? String {
                    self.NFSVolumeServer = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
            }
        }
        public var acrRegistryInfos: [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.AcrRegistryInfos]?

        public var activeDeadlineSeconds: Int32?

        public var autoCreateEip: Bool?

        public var autoMatchImageCache: Bool?

        public var computeCategory: [String]?

        public var containerGroupName: String?

        public var containers: [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.Containers]?

        public var costOptimization: Bool?

        public var cpu: Double?

        public var cpuOptionsCore: Int32?

        public var cpuOptionsThreadsPerCore: Int32?

        public var creationTime: String?

        public var dataCacheBucket: String?

        public var dataCacheBurstingEnabled: Bool?

        public var dataCachePL: String?

        public var dataCacheProvisionedIops: Int32?

        public var description_: String?

        public var dnsConfigNameServers: [String]?

        public var dnsConfigOptions: [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.DnsConfigOptions]?

        public var dnsConfigSearches: [String]?

        public var dnsPolicy: String?

        public var egressBandwidth: Int64?

        public var eipBandwidth: Int32?

        public var eipCommonBandwidthPackage: String?

        public var eipISP: String?

        public var eipPublicIpAddressPoolId: String?

        public var ephemeralStorage: Int32?

        public var hostAliases: [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.HostAliases]?

        public var hostName: String?

        public var imageRegistryCredentials: [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.ImageRegistryCredentials]?

        public var imageSnapshotId: String?

        public var ingressBandwidth: Int64?

        public var initContainers: [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.InitContainers]?

        public var instanceFamilyLevel: String?

        public var instanceTypes: [String]?

        public var ipv6AddressCount: Int32?

        public var lifecycleState: String?

        public var loadBalancerWeight: Int32?

        public var memory: Double?

        public var ntpServers: [String]?

        public var ramRoleName: String?

        public var regionId: String?

        public var resourceGroupId: String?

        public var restartPolicy: String?

        public var scalingConfigurationId: String?

        public var scalingConfigurationName: String?

        public var scalingGroupId: String?

        public var securityContextSysCtls: [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.SecurityContextSysCtls]?

        public var securityGroupId: String?

        public var slsEnable: Bool?

        public var spotPriceLimit: Double?

        public var spotStrategy: String?

        public var tags: [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.Tags]?

        public var terminationGracePeriodSeconds: Int32?

        public var volumes: [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.Volumes]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.acrRegistryInfos != nil {
                var tmp : [Any] = []
                for k in self.acrRegistryInfos! {
                    tmp.append(k.toMap())
                }
                map["AcrRegistryInfos"] = tmp
            }
            if self.activeDeadlineSeconds != nil {
                map["ActiveDeadlineSeconds"] = self.activeDeadlineSeconds!
            }
            if self.autoCreateEip != nil {
                map["AutoCreateEip"] = self.autoCreateEip!
            }
            if self.autoMatchImageCache != nil {
                map["AutoMatchImageCache"] = self.autoMatchImageCache!
            }
            if self.computeCategory != nil {
                map["ComputeCategory"] = self.computeCategory!
            }
            if self.containerGroupName != nil {
                map["ContainerGroupName"] = self.containerGroupName!
            }
            if self.containers != nil {
                var tmp : [Any] = []
                for k in self.containers! {
                    tmp.append(k.toMap())
                }
                map["Containers"] = tmp
            }
            if self.costOptimization != nil {
                map["CostOptimization"] = self.costOptimization!
            }
            if self.cpu != nil {
                map["Cpu"] = self.cpu!
            }
            if self.cpuOptionsCore != nil {
                map["CpuOptionsCore"] = self.cpuOptionsCore!
            }
            if self.cpuOptionsThreadsPerCore != nil {
                map["CpuOptionsThreadsPerCore"] = self.cpuOptionsThreadsPerCore!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.dataCacheBucket != nil {
                map["DataCacheBucket"] = self.dataCacheBucket!
            }
            if self.dataCacheBurstingEnabled != nil {
                map["DataCacheBurstingEnabled"] = self.dataCacheBurstingEnabled!
            }
            if self.dataCachePL != nil {
                map["DataCachePL"] = self.dataCachePL!
            }
            if self.dataCacheProvisionedIops != nil {
                map["DataCacheProvisionedIops"] = self.dataCacheProvisionedIops!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.dnsConfigNameServers != nil {
                map["DnsConfigNameServers"] = self.dnsConfigNameServers!
            }
            if self.dnsConfigOptions != nil {
                var tmp : [Any] = []
                for k in self.dnsConfigOptions! {
                    tmp.append(k.toMap())
                }
                map["DnsConfigOptions"] = tmp
            }
            if self.dnsConfigSearches != nil {
                map["DnsConfigSearches"] = self.dnsConfigSearches!
            }
            if self.dnsPolicy != nil {
                map["DnsPolicy"] = self.dnsPolicy!
            }
            if self.egressBandwidth != nil {
                map["EgressBandwidth"] = self.egressBandwidth!
            }
            if self.eipBandwidth != nil {
                map["EipBandwidth"] = self.eipBandwidth!
            }
            if self.eipCommonBandwidthPackage != nil {
                map["EipCommonBandwidthPackage"] = self.eipCommonBandwidthPackage!
            }
            if self.eipISP != nil {
                map["EipISP"] = self.eipISP!
            }
            if self.eipPublicIpAddressPoolId != nil {
                map["EipPublicIpAddressPoolId"] = self.eipPublicIpAddressPoolId!
            }
            if self.ephemeralStorage != nil {
                map["EphemeralStorage"] = self.ephemeralStorage!
            }
            if self.hostAliases != nil {
                var tmp : [Any] = []
                for k in self.hostAliases! {
                    tmp.append(k.toMap())
                }
                map["HostAliases"] = tmp
            }
            if self.hostName != nil {
                map["HostName"] = self.hostName!
            }
            if self.imageRegistryCredentials != nil {
                var tmp : [Any] = []
                for k in self.imageRegistryCredentials! {
                    tmp.append(k.toMap())
                }
                map["ImageRegistryCredentials"] = tmp
            }
            if self.imageSnapshotId != nil {
                map["ImageSnapshotId"] = self.imageSnapshotId!
            }
            if self.ingressBandwidth != nil {
                map["IngressBandwidth"] = self.ingressBandwidth!
            }
            if self.initContainers != nil {
                var tmp : [Any] = []
                for k in self.initContainers! {
                    tmp.append(k.toMap())
                }
                map["InitContainers"] = tmp
            }
            if self.instanceFamilyLevel != nil {
                map["InstanceFamilyLevel"] = self.instanceFamilyLevel!
            }
            if self.instanceTypes != nil {
                map["InstanceTypes"] = self.instanceTypes!
            }
            if self.ipv6AddressCount != nil {
                map["Ipv6AddressCount"] = self.ipv6AddressCount!
            }
            if self.lifecycleState != nil {
                map["LifecycleState"] = self.lifecycleState!
            }
            if self.loadBalancerWeight != nil {
                map["LoadBalancerWeight"] = self.loadBalancerWeight!
            }
            if self.memory != nil {
                map["Memory"] = self.memory!
            }
            if self.ntpServers != nil {
                map["NtpServers"] = self.ntpServers!
            }
            if self.ramRoleName != nil {
                map["RamRoleName"] = self.ramRoleName!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.restartPolicy != nil {
                map["RestartPolicy"] = self.restartPolicy!
            }
            if self.scalingConfigurationId != nil {
                map["ScalingConfigurationId"] = self.scalingConfigurationId!
            }
            if self.scalingConfigurationName != nil {
                map["ScalingConfigurationName"] = self.scalingConfigurationName!
            }
            if self.scalingGroupId != nil {
                map["ScalingGroupId"] = self.scalingGroupId!
            }
            if self.securityContextSysCtls != nil {
                var tmp : [Any] = []
                for k in self.securityContextSysCtls! {
                    tmp.append(k.toMap())
                }
                map["SecurityContextSysCtls"] = tmp
            }
            if self.securityGroupId != nil {
                map["SecurityGroupId"] = self.securityGroupId!
            }
            if self.slsEnable != nil {
                map["SlsEnable"] = self.slsEnable!
            }
            if self.spotPriceLimit != nil {
                map["SpotPriceLimit"] = self.spotPriceLimit!
            }
            if self.spotStrategy != nil {
                map["SpotStrategy"] = self.spotStrategy!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            if self.terminationGracePeriodSeconds != nil {
                map["TerminationGracePeriodSeconds"] = self.terminationGracePeriodSeconds!
            }
            if self.volumes != nil {
                var tmp : [Any] = []
                for k in self.volumes! {
                    tmp.append(k.toMap())
                }
                map["Volumes"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AcrRegistryInfos"] as? [Any?] {
                var tmp : [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.AcrRegistryInfos] = []
                for v in value {
                    if v != nil {
                        var model = DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.AcrRegistryInfos()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.acrRegistryInfos = tmp
            }
            if let value = dict["ActiveDeadlineSeconds"] as? Int32 {
                self.activeDeadlineSeconds = value
            }
            if let value = dict["AutoCreateEip"] as? Bool {
                self.autoCreateEip = value
            }
            if let value = dict["AutoMatchImageCache"] as? Bool {
                self.autoMatchImageCache = value
            }
            if let value = dict["ComputeCategory"] as? [String] {
                self.computeCategory = value
            }
            if let value = dict["ContainerGroupName"] as? String {
                self.containerGroupName = value
            }
            if let value = dict["Containers"] as? [Any?] {
                var tmp : [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.Containers] = []
                for v in value {
                    if v != nil {
                        var model = DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.Containers()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.containers = tmp
            }
            if let value = dict["CostOptimization"] as? Bool {
                self.costOptimization = value
            }
            if let value = dict["Cpu"] as? Double {
                self.cpu = value
            }
            if let value = dict["CpuOptionsCore"] as? Int32 {
                self.cpuOptionsCore = value
            }
            if let value = dict["CpuOptionsThreadsPerCore"] as? Int32 {
                self.cpuOptionsThreadsPerCore = value
            }
            if let value = dict["CreationTime"] as? String {
                self.creationTime = value
            }
            if let value = dict["DataCacheBucket"] as? String {
                self.dataCacheBucket = value
            }
            if let value = dict["DataCacheBurstingEnabled"] as? Bool {
                self.dataCacheBurstingEnabled = value
            }
            if let value = dict["DataCachePL"] as? String {
                self.dataCachePL = value
            }
            if let value = dict["DataCacheProvisionedIops"] as? Int32 {
                self.dataCacheProvisionedIops = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["DnsConfigNameServers"] as? [String] {
                self.dnsConfigNameServers = value
            }
            if let value = dict["DnsConfigOptions"] as? [Any?] {
                var tmp : [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.DnsConfigOptions] = []
                for v in value {
                    if v != nil {
                        var model = DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.DnsConfigOptions()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.dnsConfigOptions = tmp
            }
            if let value = dict["DnsConfigSearches"] as? [String] {
                self.dnsConfigSearches = value
            }
            if let value = dict["DnsPolicy"] as? String {
                self.dnsPolicy = value
            }
            if let value = dict["EgressBandwidth"] as? Int64 {
                self.egressBandwidth = value
            }
            if let value = dict["EipBandwidth"] as? Int32 {
                self.eipBandwidth = value
            }
            if let value = dict["EipCommonBandwidthPackage"] as? String {
                self.eipCommonBandwidthPackage = value
            }
            if let value = dict["EipISP"] as? String {
                self.eipISP = value
            }
            if let value = dict["EipPublicIpAddressPoolId"] as? String {
                self.eipPublicIpAddressPoolId = value
            }
            if let value = dict["EphemeralStorage"] as? Int32 {
                self.ephemeralStorage = value
            }
            if let value = dict["HostAliases"] as? [Any?] {
                var tmp : [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.HostAliases] = []
                for v in value {
                    if v != nil {
                        var model = DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.HostAliases()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.hostAliases = tmp
            }
            if let value = dict["HostName"] as? String {
                self.hostName = value
            }
            if let value = dict["ImageRegistryCredentials"] as? [Any?] {
                var tmp : [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.ImageRegistryCredentials] = []
                for v in value {
                    if v != nil {
                        var model = DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.ImageRegistryCredentials()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.imageRegistryCredentials = tmp
            }
            if let value = dict["ImageSnapshotId"] as? String {
                self.imageSnapshotId = value
            }
            if let value = dict["IngressBandwidth"] as? Int64 {
                self.ingressBandwidth = value
            }
            if let value = dict["InitContainers"] as? [Any?] {
                var tmp : [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.InitContainers] = []
                for v in value {
                    if v != nil {
                        var model = DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.InitContainers()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.initContainers = tmp
            }
            if let value = dict["InstanceFamilyLevel"] as? String {
                self.instanceFamilyLevel = value
            }
            if let value = dict["InstanceTypes"] as? [String] {
                self.instanceTypes = value
            }
            if let value = dict["Ipv6AddressCount"] as? Int32 {
                self.ipv6AddressCount = value
            }
            if let value = dict["LifecycleState"] as? String {
                self.lifecycleState = value
            }
            if let value = dict["LoadBalancerWeight"] as? Int32 {
                self.loadBalancerWeight = value
            }
            if let value = dict["Memory"] as? Double {
                self.memory = value
            }
            if let value = dict["NtpServers"] as? [String] {
                self.ntpServers = value
            }
            if let value = dict["RamRoleName"] as? String {
                self.ramRoleName = value
            }
            if let value = dict["RegionId"] as? String {
                self.regionId = value
            }
            if let value = dict["ResourceGroupId"] as? String {
                self.resourceGroupId = value
            }
            if let value = dict["RestartPolicy"] as? String {
                self.restartPolicy = value
            }
            if let value = dict["ScalingConfigurationId"] as? String {
                self.scalingConfigurationId = value
            }
            if let value = dict["ScalingConfigurationName"] as? String {
                self.scalingConfigurationName = value
            }
            if let value = dict["ScalingGroupId"] as? String {
                self.scalingGroupId = value
            }
            if let value = dict["SecurityContextSysCtls"] as? [Any?] {
                var tmp : [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.SecurityContextSysCtls] = []
                for v in value {
                    if v != nil {
                        var model = DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.SecurityContextSysCtls()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.securityContextSysCtls = tmp
            }
            if let value = dict["SecurityGroupId"] as? String {
                self.securityGroupId = value
            }
            if let value = dict["SlsEnable"] as? Bool {
                self.slsEnable = value
            }
            if let value = dict["SpotPriceLimit"] as? Double {
                self.spotPriceLimit = value
            }
            if let value = dict["SpotStrategy"] as? String {
                self.spotStrategy = value
            }
            if let value = dict["Tags"] as? [Any?] {
                var tmp : [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.Tags] = []
                for v in value {
                    if v != nil {
                        var model = DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.Tags()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tags = tmp
            }
            if let value = dict["TerminationGracePeriodSeconds"] as? Int32 {
                self.terminationGracePeriodSeconds = value
            }
            if let value = dict["Volumes"] as? [Any?] {
                var tmp : [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.Volumes] = []
                for v in value {
                    if v != nil {
                        var model = DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.Volumes()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.volumes = tmp
            }
        }
    }
    public var output: String?

    public var requestId: String?

    public var scalingConfiguration: DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.scalingConfiguration?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.output != nil {
            map["Output"] = self.output!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingConfiguration != nil {
            map["ScalingConfiguration"] = self.scalingConfiguration?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Output"] as? String {
            self.output = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ScalingConfiguration"] as? [String: Any?] {
            var model = DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration()
            model.fromMap(value)
            self.scalingConfiguration = model
        }
    }
}

public class DescribeEciScalingConfigurationDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEciScalingConfigurationDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeEciScalingConfigurationDetailResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeEciScalingConfigurationsRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var scalingConfigurationIds: [String]?

    public var scalingConfigurationNames: [String]?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.scalingConfigurationIds != nil {
            map["ScalingConfigurationIds"] = self.scalingConfigurationIds!
        }
        if self.scalingConfigurationNames != nil {
            map["ScalingConfigurationNames"] = self.scalingConfigurationNames!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ScalingConfigurationIds"] as? [String] {
            self.scalingConfigurationIds = value
        }
        if let value = dict["ScalingConfigurationNames"] as? [String] {
            self.scalingConfigurationNames = value
        }
        if let value = dict["ScalingGroupId"] as? String {
            self.scalingGroupId = value
        }
    }
}

public class DescribeEciScalingConfigurationsResponseBody : Tea.TeaModel {
    public class ScalingConfigurations : Tea.TeaModel {
        public class AcrRegistryInfos : Tea.TeaModel {
            public var domains: [String]?

            public var instanceId: String?

            public var instanceName: String?

            public var regionId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.domains != nil {
                    map["Domains"] = self.domains!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.instanceName != nil {
                    map["InstanceName"] = self.instanceName!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Domains"] as? [String] {
                    self.domains = value
                }
                if let value = dict["InstanceId"] as? String {
                    self.instanceId = value
                }
                if let value = dict["InstanceName"] as? String {
                    self.instanceName = value
                }
                if let value = dict["RegionId"] as? String {
                    self.regionId = value
                }
            }
        }
        public class Containers : Tea.TeaModel {
            public class EnvironmentVars : Tea.TeaModel {
                public var fieldRefFieldPath: String?

                public var key: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.fieldRefFieldPath != nil {
                        map["FieldRefFieldPath"] = self.fieldRefFieldPath!
                    }
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["FieldRefFieldPath"] as? String {
                        self.fieldRefFieldPath = value
                    }
                    if let value = dict["Key"] as? String {
                        self.key = value
                    }
                    if let value = dict["Value"] as? String {
                        self.value = value
                    }
                }
            }
            public class Ports : Tea.TeaModel {
                public var port: Int32?

                public var protocol_: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.port != nil {
                        map["Port"] = self.port!
                    }
                    if self.protocol_ != nil {
                        map["Protocol"] = self.protocol_!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Port"] as? Int32 {
                        self.port = value
                    }
                    if let value = dict["Protocol"] as? String {
                        self.protocol_ = value
                    }
                }
            }
            public class VolumeMounts : Tea.TeaModel {
                public var mountPath: String?

                public var mountPropagation: String?

                public var name: String?

                public var readOnly: Bool?

                public var subPath: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.mountPath != nil {
                        map["MountPath"] = self.mountPath!
                    }
                    if self.mountPropagation != nil {
                        map["MountPropagation"] = self.mountPropagation!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.readOnly != nil {
                        map["ReadOnly"] = self.readOnly!
                    }
                    if self.subPath != nil {
                        map["SubPath"] = self.subPath!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["MountPath"] as? String {
                        self.mountPath = value
                    }
                    if let value = dict["MountPropagation"] as? String {
                        self.mountPropagation = value
                    }
                    if let value = dict["Name"] as? String {
                        self.name = value
                    }
                    if let value = dict["ReadOnly"] as? Bool {
                        self.readOnly = value
                    }
                    if let value = dict["SubPath"] as? String {
                        self.subPath = value
                    }
                }
            }
            public var args: [String]?

            public var commands: [String]?

            public var cpu: Double?

            public var environmentVars: [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.Containers.EnvironmentVars]?

            public var gpu: Int32?

            public var image: String?

            public var imagePullPolicy: String?

            public var lifecyclePostStartHandlerExecs: [String]?

            public var lifecyclePostStartHandlerHttpGetHost: String?

            public var lifecyclePostStartHandlerHttpGetPath: String?

            public var lifecyclePostStartHandlerHttpGetPort: Int32?

            public var lifecyclePostStartHandlerHttpGetScheme: String?

            public var lifecyclePostStartHandlerTcpSocketHost: String?

            public var lifecyclePostStartHandlerTcpSocketPort: Int32?

            public var lifecyclePreStopHandlerExecs: [String]?

            public var lifecyclePreStopHandlerHttpGetHost: String?

            public var lifecyclePreStopHandlerHttpGetPath: String?

            public var lifecyclePreStopHandlerHttpGetPort: Int32?

            public var lifecyclePreStopHandlerHttpGetScheme: String?

            public var lifecyclePreStopHandlerTcpSocketHost: String?

            public var lifecyclePreStopHandlerTcpSocketPort: Int32?

            public var livenessProbeExecCommands: [String]?

            public var livenessProbeFailureThreshold: Int32?

            public var livenessProbeHttpGetPath: String?

            public var livenessProbeHttpGetPort: Int32?

            public var livenessProbeHttpGetScheme: String?

            public var livenessProbeInitialDelaySeconds: Int32?

            public var livenessProbePeriodSeconds: Int32?

            public var livenessProbeSuccessThreshold: Int32?

            public var livenessProbeTcpSocketPort: Int32?

            public var livenessProbeTimeoutSeconds: Int32?

            public var memory: Double?

            public var name: String?

            public var ports: [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.Containers.Ports]?

            public var readinessProbeExecCommands: [String]?

            public var readinessProbeFailureThreshold: Int32?

            public var readinessProbeHttpGetPath: String?

            public var readinessProbeHttpGetPort: Int32?

            public var readinessProbeHttpGetScheme: String?

            public var readinessProbeInitialDelaySeconds: Int32?

            public var readinessProbePeriodSeconds: Int32?

            public var readinessProbeSuccessThreshold: Int32?

            public var readinessProbeTcpSocketPort: Int32?

            public var readinessProbeTimeoutSeconds: Int32?

            public var securityContextCapabilityAdds: [String]?

            public var securityContextReadOnlyRootFilesystem: Bool?

            public var securityContextRunAsUser: Int64?

            public var stdin: Bool?

            public var stdinOnce: Bool?

            public var tty: Bool?

            public var volumeMounts: [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.Containers.VolumeMounts]?

            public var workingDir: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.args != nil {
                    map["Args"] = self.args!
                }
                if self.commands != nil {
                    map["Commands"] = self.commands!
                }
                if self.cpu != nil {
                    map["Cpu"] = self.cpu!
                }
                if self.environmentVars != nil {
                    var tmp : [Any] = []
                    for k in self.environmentVars! {
                        tmp.append(k.toMap())
                    }
                    map["EnvironmentVars"] = tmp
                }
                if self.gpu != nil {
                    map["Gpu"] = self.gpu!
                }
                if self.image != nil {
                    map["Image"] = self.image!
                }
                if self.imagePullPolicy != nil {
                    map["ImagePullPolicy"] = self.imagePullPolicy!
                }
                if self.lifecyclePostStartHandlerExecs != nil {
                    map["LifecyclePostStartHandlerExecs"] = self.lifecyclePostStartHandlerExecs!
                }
                if self.lifecyclePostStartHandlerHttpGetHost != nil {
                    map["LifecyclePostStartHandlerHttpGetHost"] = self.lifecyclePostStartHandlerHttpGetHost!
                }
                if self.lifecyclePostStartHandlerHttpGetPath != nil {
                    map["LifecyclePostStartHandlerHttpGetPath"] = self.lifecyclePostStartHandlerHttpGetPath!
                }
                if self.lifecyclePostStartHandlerHttpGetPort != nil {
                    map["LifecyclePostStartHandlerHttpGetPort"] = self.lifecyclePostStartHandlerHttpGetPort!
                }
                if self.lifecyclePostStartHandlerHttpGetScheme != nil {
                    map["LifecyclePostStartHandlerHttpGetScheme"] = self.lifecyclePostStartHandlerHttpGetScheme!
                }
                if self.lifecyclePostStartHandlerTcpSocketHost != nil {
                    map["LifecyclePostStartHandlerTcpSocketHost"] = self.lifecyclePostStartHandlerTcpSocketHost!
                }
                if self.lifecyclePostStartHandlerTcpSocketPort != nil {
                    map["LifecyclePostStartHandlerTcpSocketPort"] = self.lifecyclePostStartHandlerTcpSocketPort!
                }
                if self.lifecyclePreStopHandlerExecs != nil {
                    map["LifecyclePreStopHandlerExecs"] = self.lifecyclePreStopHandlerExecs!
                }
                if self.lifecyclePreStopHandlerHttpGetHost != nil {
                    map["LifecyclePreStopHandlerHttpGetHost"] = self.lifecyclePreStopHandlerHttpGetHost!
                }
                if self.lifecyclePreStopHandlerHttpGetPath != nil {
                    map["LifecyclePreStopHandlerHttpGetPath"] = self.lifecyclePreStopHandlerHttpGetPath!
                }
                if self.lifecyclePreStopHandlerHttpGetPort != nil {
                    map["LifecyclePreStopHandlerHttpGetPort"] = self.lifecyclePreStopHandlerHttpGetPort!
                }
                if self.lifecyclePreStopHandlerHttpGetScheme != nil {
                    map["LifecyclePreStopHandlerHttpGetScheme"] = self.lifecyclePreStopHandlerHttpGetScheme!
                }
                if self.lifecyclePreStopHandlerTcpSocketHost != nil {
                    map["LifecyclePreStopHandlerTcpSocketHost"] = self.lifecyclePreStopHandlerTcpSocketHost!
                }
                if self.lifecyclePreStopHandlerTcpSocketPort != nil {
                    map["LifecyclePreStopHandlerTcpSocketPort"] = self.lifecyclePreStopHandlerTcpSocketPort!
                }
                if self.livenessProbeExecCommands != nil {
                    map["LivenessProbeExecCommands"] = self.livenessProbeExecCommands!
                }
                if self.livenessProbeFailureThreshold != nil {
                    map["LivenessProbeFailureThreshold"] = self.livenessProbeFailureThreshold!
                }
                if self.livenessProbeHttpGetPath != nil {
                    map["LivenessProbeHttpGetPath"] = self.livenessProbeHttpGetPath!
                }
                if self.livenessProbeHttpGetPort != nil {
                    map["LivenessProbeHttpGetPort"] = self.livenessProbeHttpGetPort!
                }
                if self.livenessProbeHttpGetScheme != nil {
                    map["LivenessProbeHttpGetScheme"] = self.livenessProbeHttpGetScheme!
                }
                if self.livenessProbeInitialDelaySeconds != nil {
                    map["LivenessProbeInitialDelaySeconds"] = self.livenessProbeInitialDelaySeconds!
                }
                if self.livenessProbePeriodSeconds != nil {
                    map["LivenessProbePeriodSeconds"] = self.livenessProbePeriodSeconds!
                }
                if self.livenessProbeSuccessThreshold != nil {
                    map["LivenessProbeSuccessThreshold"] = self.livenessProbeSuccessThreshold!
                }
                if self.livenessProbeTcpSocketPort != nil {
                    map["LivenessProbeTcpSocketPort"] = self.livenessProbeTcpSocketPort!
                }
                if self.livenessProbeTimeoutSeconds != nil {
                    map["LivenessProbeTimeoutSeconds"] = self.livenessProbeTimeoutSeconds!
                }
                if self.memory != nil {
                    map["Memory"] = self.memory!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.ports != nil {
                    var tmp : [Any] = []
                    for k in self.ports! {
                        tmp.append(k.toMap())
                    }
                    map["Ports"] = tmp
                }
                if self.readinessProbeExecCommands != nil {
                    map["ReadinessProbeExecCommands"] = self.readinessProbeExecCommands!
                }
                if self.readinessProbeFailureThreshold != nil {
                    map["ReadinessProbeFailureThreshold"] = self.readinessProbeFailureThreshold!
                }
                if self.readinessProbeHttpGetPath != nil {
                    map["ReadinessProbeHttpGetPath"] = self.readinessProbeHttpGetPath!
                }
                if self.readinessProbeHttpGetPort != nil {
                    map["ReadinessProbeHttpGetPort"] = self.readinessProbeHttpGetPort!
                }
                if self.readinessProbeHttpGetScheme != nil {
                    map["ReadinessProbeHttpGetScheme"] = self.readinessProbeHttpGetScheme!
                }
                if self.readinessProbeInitialDelaySeconds != nil {
                    map["ReadinessProbeInitialDelaySeconds"] = self.readinessProbeInitialDelaySeconds!
                }
                if self.readinessProbePeriodSeconds != nil {
                    map["ReadinessProbePeriodSeconds"] = self.readinessProbePeriodSeconds!
                }
                if self.readinessProbeSuccessThreshold != nil {
                    map["ReadinessProbeSuccessThreshold"] = self.readinessProbeSuccessThreshold!
                }
                if self.readinessProbeTcpSocketPort != nil {
                    map["ReadinessProbeTcpSocketPort"] = self.readinessProbeTcpSocketPort!
                }
                if self.readinessProbeTimeoutSeconds != nil {
                    map["ReadinessProbeTimeoutSeconds"] = self.readinessProbeTimeoutSeconds!
                }
                if self.securityContextCapabilityAdds != nil {
                    map["SecurityContextCapabilityAdds"] = self.securityContextCapabilityAdds!
                }
                if self.securityContextReadOnlyRootFilesystem != nil {
                    map["SecurityContextReadOnlyRootFilesystem"] = self.securityContextReadOnlyRootFilesystem!
                }
                if self.securityContextRunAsUser != nil {
                    map["SecurityContextRunAsUser"] = self.securityContextRunAsUser!
                }
                if self.stdin != nil {
                    map["Stdin"] = self.stdin!
                }
                if self.stdinOnce != nil {
                    map["StdinOnce"] = self.stdinOnce!
                }
                if self.tty != nil {
                    map["Tty"] = self.tty!
                }
                if self.volumeMounts != nil {
                    var tmp : [Any] = []
                    for k in self.volumeMounts! {
                        tmp.append(k.toMap())
                    }
                    map["VolumeMounts"] = tmp
                }
                if self.workingDir != nil {
                    map["WorkingDir"] = self.workingDir!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Args"] as? [String] {
                    self.args = value
                }
                if let value = dict["Commands"] as? [String] {
                    self.commands = value
                }
                if let value = dict["Cpu"] as? Double {
                    self.cpu = value
                }
                if let value = dict["EnvironmentVars"] as? [Any?] {
                    var tmp : [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.Containers.EnvironmentVars] = []
                    for v in value {
                        if v != nil {
                            var model = DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.Containers.EnvironmentVars()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.environmentVars = tmp
                }
                if let value = dict["Gpu"] as? Int32 {
                    self.gpu = value
                }
                if let value = dict["Image"] as? String {
                    self.image = value
                }
                if let value = dict["ImagePullPolicy"] as? String {
                    self.imagePullPolicy = value
                }
                if let value = dict["LifecyclePostStartHandlerExecs"] as? [String] {
                    self.lifecyclePostStartHandlerExecs = value
                }
                if let value = dict["LifecyclePostStartHandlerHttpGetHost"] as? String {
                    self.lifecyclePostStartHandlerHttpGetHost = value
                }
                if let value = dict["LifecyclePostStartHandlerHttpGetPath"] as? String {
                    self.lifecyclePostStartHandlerHttpGetPath = value
                }
                if let value = dict["LifecyclePostStartHandlerHttpGetPort"] as? Int32 {
                    self.lifecyclePostStartHandlerHttpGetPort = value
                }
                if let value = dict["LifecyclePostStartHandlerHttpGetScheme"] as? String {
                    self.lifecyclePostStartHandlerHttpGetScheme = value
                }
                if let value = dict["LifecyclePostStartHandlerTcpSocketHost"] as? String {
                    self.lifecyclePostStartHandlerTcpSocketHost = value
                }
                if let value = dict["LifecyclePostStartHandlerTcpSocketPort"] as? Int32 {
                    self.lifecyclePostStartHandlerTcpSocketPort = value
                }
                if let value = dict["LifecyclePreStopHandlerExecs"] as? [String] {
                    self.lifecyclePreStopHandlerExecs = value
                }
                if let value = dict["LifecyclePreStopHandlerHttpGetHost"] as? String {
                    self.lifecyclePreStopHandlerHttpGetHost = value
                }
                if let value = dict["LifecyclePreStopHandlerHttpGetPath"] as? String {
                    self.lifecyclePreStopHandlerHttpGetPath = value
                }
                if let value = dict["LifecyclePreStopHandlerHttpGetPort"] as? Int32 {
                    self.lifecyclePreStopHandlerHttpGetPort = value
                }
                if let value = dict["LifecyclePreStopHandlerHttpGetScheme"] as? String {
                    self.lifecyclePreStopHandlerHttpGetScheme = value
                }
                if let value = dict["LifecyclePreStopHandlerTcpSocketHost"] as? String {
                    self.lifecyclePreStopHandlerTcpSocketHost = value
                }
                if let value = dict["LifecyclePreStopHandlerTcpSocketPort"] as? Int32 {
                    self.lifecyclePreStopHandlerTcpSocketPort = value
                }
                if let value = dict["LivenessProbeExecCommands"] as? [String] {
                    self.livenessProbeExecCommands = value
                }
                if let value = dict["LivenessProbeFailureThreshold"] as? Int32 {
                    self.livenessProbeFailureThreshold = value
                }
                if let value = dict["LivenessProbeHttpGetPath"] as? String {
                    self.livenessProbeHttpGetPath = value
                }
                if let value = dict["LivenessProbeHttpGetPort"] as? Int32 {
                    self.livenessProbeHttpGetPort = value
                }
                if let value = dict["LivenessProbeHttpGetScheme"] as? String {
                    self.livenessProbeHttpGetScheme = value
                }
                if let value = dict["LivenessProbeInitialDelaySeconds"] as? Int32 {
                    self.livenessProbeInitialDelaySeconds = value
                }
                if let value = dict["LivenessProbePeriodSeconds"] as? Int32 {
                    self.livenessProbePeriodSeconds = value
                }
                if let value = dict["LivenessProbeSuccessThreshold"] as? Int32 {
                    self.livenessProbeSuccessThreshold = value
                }
                if let value = dict["LivenessProbeTcpSocketPort"] as? Int32 {
                    self.livenessProbeTcpSocketPort = value
                }
                if let value = dict["LivenessProbeTimeoutSeconds"] as? Int32 {
                    self.livenessProbeTimeoutSeconds = value
                }
                if let value = dict["Memory"] as? Double {
                    self.memory = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["Ports"] as? [Any?] {
                    var tmp : [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.Containers.Ports] = []
                    for v in value {
                        if v != nil {
                            var model = DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.Containers.Ports()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.ports = tmp
                }
                if let value = dict["ReadinessProbeExecCommands"] as? [String] {
                    self.readinessProbeExecCommands = value
                }
                if let value = dict["ReadinessProbeFailureThreshold"] as? Int32 {
                    self.readinessProbeFailureThreshold = value
                }
                if let value = dict["ReadinessProbeHttpGetPath"] as? String {
                    self.readinessProbeHttpGetPath = value
                }
                if let value = dict["ReadinessProbeHttpGetPort"] as? Int32 {
                    self.readinessProbeHttpGetPort = value
                }
                if let value = dict["ReadinessProbeHttpGetScheme"] as? String {
                    self.readinessProbeHttpGetScheme = value
                }
                if let value = dict["ReadinessProbeInitialDelaySeconds"] as? Int32 {
                    self.readinessProbeInitialDelaySeconds = value
                }
                if let value = dict["ReadinessProbePeriodSeconds"] as? Int32 {
                    self.readinessProbePeriodSeconds = value
                }
                if let value = dict["ReadinessProbeSuccessThreshold"] as? Int32 {
                    self.readinessProbeSuccessThreshold = value
                }
                if let value = dict["ReadinessProbeTcpSocketPort"] as? Int32 {
                    self.readinessProbeTcpSocketPort = value
                }
                if let value = dict["ReadinessProbeTimeoutSeconds"] as? Int32 {
                    self.readinessProbeTimeoutSeconds = value
                }
                if let value = dict["SecurityContextCapabilityAdds"] as? [String] {
                    self.securityContextCapabilityAdds = value
                }
                if let value = dict["SecurityContextReadOnlyRootFilesystem"] as? Bool {
                    self.securityContextReadOnlyRootFilesystem = value
                }
                if let value = dict["SecurityContextRunAsUser"] as? Int64 {
                    self.securityContextRunAsUser = value
                }
                if let value = dict["Stdin"] as? Bool {
                    self.stdin = value
                }
                if let value = dict["StdinOnce"] as? Bool {
                    self.stdinOnce = value
                }
                if let value = dict["Tty"] as? Bool {
                    self.tty = value
                }
                if let value = dict["VolumeMounts"] as? [Any?] {
                    var tmp : [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.Containers.VolumeMounts] = []
                    for v in value {
                        if v != nil {
                            var model = DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.Containers.VolumeMounts()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.volumeMounts = tmp
                }
                if let value = dict["WorkingDir"] as? String {
                    self.workingDir = value
                }
            }
        }
        public class DnsConfigOptions : Tea.TeaModel {
            public var name: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["Value"] as? String {
                    self.value = value
                }
            }
        }
        public class HostAliases : Tea.TeaModel {
            public var hostnames: [String]?

            public var ip: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.hostnames != nil {
                    map["Hostnames"] = self.hostnames!
                }
                if self.ip != nil {
                    map["Ip"] = self.ip!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Hostnames"] as? [String] {
                    self.hostnames = value
                }
                if let value = dict["Ip"] as? String {
                    self.ip = value
                }
            }
        }
        public class ImageRegistryCredentials : Tea.TeaModel {
            public var password: String?

            public var server: String?

            public var userName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.password != nil {
                    map["Password"] = self.password!
                }
                if self.server != nil {
                    map["Server"] = self.server!
                }
                if self.userName != nil {
                    map["UserName"] = self.userName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Password"] as? String {
                    self.password = value
                }
                if let value = dict["Server"] as? String {
                    self.server = value
                }
                if let value = dict["UserName"] as? String {
                    self.userName = value
                }
            }
        }
        public class InitContainers : Tea.TeaModel {
            public class InitContainerEnvironmentVars : Tea.TeaModel {
                public var fieldRefFieldPath: String?

                public var key: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.fieldRefFieldPath != nil {
                        map["FieldRefFieldPath"] = self.fieldRefFieldPath!
                    }
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["FieldRefFieldPath"] as? String {
                        self.fieldRefFieldPath = value
                    }
                    if let value = dict["Key"] as? String {
                        self.key = value
                    }
                    if let value = dict["Value"] as? String {
                        self.value = value
                    }
                }
            }
            public class InitContainerPorts : Tea.TeaModel {
                public var port: Int32?

                public var protocol_: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.port != nil {
                        map["Port"] = self.port!
                    }
                    if self.protocol_ != nil {
                        map["Protocol"] = self.protocol_!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Port"] as? Int32 {
                        self.port = value
                    }
                    if let value = dict["Protocol"] as? String {
                        self.protocol_ = value
                    }
                }
            }
            public class InitContainerVolumeMounts : Tea.TeaModel {
                public var mountPath: String?

                public var mountPropagation: String?

                public var name: String?

                public var readOnly: Bool?

                public var subPath: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.mountPath != nil {
                        map["MountPath"] = self.mountPath!
                    }
                    if self.mountPropagation != nil {
                        map["MountPropagation"] = self.mountPropagation!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.readOnly != nil {
                        map["ReadOnly"] = self.readOnly!
                    }
                    if self.subPath != nil {
                        map["SubPath"] = self.subPath!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["MountPath"] as? String {
                        self.mountPath = value
                    }
                    if let value = dict["MountPropagation"] as? String {
                        self.mountPropagation = value
                    }
                    if let value = dict["Name"] as? String {
                        self.name = value
                    }
                    if let value = dict["ReadOnly"] as? Bool {
                        self.readOnly = value
                    }
                    if let value = dict["SubPath"] as? String {
                        self.subPath = value
                    }
                }
            }
            public var cpu: Double?

            public var gpu: Int32?

            public var image: String?

            public var imagePullPolicy: String?

            public var initContainerArgs: [String]?

            public var initContainerCommands: [String]?

            public var initContainerEnvironmentVars: [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.InitContainers.InitContainerEnvironmentVars]?

            public var initContainerPorts: [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.InitContainers.InitContainerPorts]?

            public var initContainerVolumeMounts: [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.InitContainers.InitContainerVolumeMounts]?

            public var memory: Double?

            public var name: String?

            public var securityContextCapabilityAdds: [String]?

            public var securityContextReadOnlyRootFilesystem: Bool?

            public var securityContextRunAsUser: String?

            public var workingDir: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cpu != nil {
                    map["Cpu"] = self.cpu!
                }
                if self.gpu != nil {
                    map["Gpu"] = self.gpu!
                }
                if self.image != nil {
                    map["Image"] = self.image!
                }
                if self.imagePullPolicy != nil {
                    map["ImagePullPolicy"] = self.imagePullPolicy!
                }
                if self.initContainerArgs != nil {
                    map["InitContainerArgs"] = self.initContainerArgs!
                }
                if self.initContainerCommands != nil {
                    map["InitContainerCommands"] = self.initContainerCommands!
                }
                if self.initContainerEnvironmentVars != nil {
                    var tmp : [Any] = []
                    for k in self.initContainerEnvironmentVars! {
                        tmp.append(k.toMap())
                    }
                    map["InitContainerEnvironmentVars"] = tmp
                }
                if self.initContainerPorts != nil {
                    var tmp : [Any] = []
                    for k in self.initContainerPorts! {
                        tmp.append(k.toMap())
                    }
                    map["InitContainerPorts"] = tmp
                }
                if self.initContainerVolumeMounts != nil {
                    var tmp : [Any] = []
                    for k in self.initContainerVolumeMounts! {
                        tmp.append(k.toMap())
                    }
                    map["InitContainerVolumeMounts"] = tmp
                }
                if self.memory != nil {
                    map["Memory"] = self.memory!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.securityContextCapabilityAdds != nil {
                    map["SecurityContextCapabilityAdds"] = self.securityContextCapabilityAdds!
                }
                if self.securityContextReadOnlyRootFilesystem != nil {
                    map["SecurityContextReadOnlyRootFilesystem"] = self.securityContextReadOnlyRootFilesystem!
                }
                if self.securityContextRunAsUser != nil {
                    map["SecurityContextRunAsUser"] = self.securityContextRunAsUser!
                }
                if self.workingDir != nil {
                    map["WorkingDir"] = self.workingDir!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Cpu"] as? Double {
                    self.cpu = value
                }
                if let value = dict["Gpu"] as? Int32 {
                    self.gpu = value
                }
                if let value = dict["Image"] as? String {
                    self.image = value
                }
                if let value = dict["ImagePullPolicy"] as? String {
                    self.imagePullPolicy = value
                }
                if let value = dict["InitContainerArgs"] as? [String] {
                    self.initContainerArgs = value
                }
                if let value = dict["InitContainerCommands"] as? [String] {
                    self.initContainerCommands = value
                }
                if let value = dict["InitContainerEnvironmentVars"] as? [Any?] {
                    var tmp : [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.InitContainers.InitContainerEnvironmentVars] = []
                    for v in value {
                        if v != nil {
                            var model = DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.InitContainers.InitContainerEnvironmentVars()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.initContainerEnvironmentVars = tmp
                }
                if let value = dict["InitContainerPorts"] as? [Any?] {
                    var tmp : [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.InitContainers.InitContainerPorts] = []
                    for v in value {
                        if v != nil {
                            var model = DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.InitContainers.InitContainerPorts()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.initContainerPorts = tmp
                }
                if let value = dict["InitContainerVolumeMounts"] as? [Any?] {
                    var tmp : [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.InitContainers.InitContainerVolumeMounts] = []
                    for v in value {
                        if v != nil {
                            var model = DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.InitContainers.InitContainerVolumeMounts()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.initContainerVolumeMounts = tmp
                }
                if let value = dict["Memory"] as? Double {
                    self.memory = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["SecurityContextCapabilityAdds"] as? [String] {
                    self.securityContextCapabilityAdds = value
                }
                if let value = dict["SecurityContextReadOnlyRootFilesystem"] as? Bool {
                    self.securityContextReadOnlyRootFilesystem = value
                }
                if let value = dict["SecurityContextRunAsUser"] as? String {
                    self.securityContextRunAsUser = value
                }
                if let value = dict["WorkingDir"] as? String {
                    self.workingDir = value
                }
            }
        }
        public class SecurityContextSysCtls : Tea.TeaModel {
            public var name: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["Value"] as? String {
                    self.value = value
                }
            }
        }
        public class Tags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Key"] as? String {
                    self.key = value
                }
                if let value = dict["Value"] as? String {
                    self.value = value
                }
            }
        }
        public class Volumes : Tea.TeaModel {
            public class ConfigFileVolumeConfigFileToPaths : Tea.TeaModel {
                public var content: String?

                public var mode: Int32?

                public var path: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.content != nil {
                        map["Content"] = self.content!
                    }
                    if self.mode != nil {
                        map["Mode"] = self.mode!
                    }
                    if self.path != nil {
                        map["Path"] = self.path!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Content"] as? String {
                        self.content = value
                    }
                    if let value = dict["Mode"] as? Int32 {
                        self.mode = value
                    }
                    if let value = dict["Path"] as? String {
                        self.path = value
                    }
                }
            }
            public var configFileVolumeConfigFileToPaths: [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.Volumes.ConfigFileVolumeConfigFileToPaths]?

            public var configFileVolumeDefaultMode: Int32?

            public var diskVolumeDiskId: String?

            public var diskVolumeDiskSize: Int32?

            public var diskVolumeFsType: String?

            public var emptyDirVolumeMedium: String?

            public var emptyDirVolumeSizeLimit: String?

            public var flexVolumeDriver: String?

            public var flexVolumeFsType: String?

            public var flexVolumeOptions: String?

            public var hostPathVolumePath: String?

            public var hostPathVolumeType: String?

            public var NFSVolumePath: String?

            public var NFSVolumeReadOnly: Bool?

            public var NFSVolumeServer: String?

            public var name: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.configFileVolumeConfigFileToPaths != nil {
                    var tmp : [Any] = []
                    for k in self.configFileVolumeConfigFileToPaths! {
                        tmp.append(k.toMap())
                    }
                    map["ConfigFileVolumeConfigFileToPaths"] = tmp
                }
                if self.configFileVolumeDefaultMode != nil {
                    map["ConfigFileVolumeDefaultMode"] = self.configFileVolumeDefaultMode!
                }
                if self.diskVolumeDiskId != nil {
                    map["DiskVolumeDiskId"] = self.diskVolumeDiskId!
                }
                if self.diskVolumeDiskSize != nil {
                    map["DiskVolumeDiskSize"] = self.diskVolumeDiskSize!
                }
                if self.diskVolumeFsType != nil {
                    map["DiskVolumeFsType"] = self.diskVolumeFsType!
                }
                if self.emptyDirVolumeMedium != nil {
                    map["EmptyDirVolumeMedium"] = self.emptyDirVolumeMedium!
                }
                if self.emptyDirVolumeSizeLimit != nil {
                    map["EmptyDirVolumeSizeLimit"] = self.emptyDirVolumeSizeLimit!
                }
                if self.flexVolumeDriver != nil {
                    map["FlexVolumeDriver"] = self.flexVolumeDriver!
                }
                if self.flexVolumeFsType != nil {
                    map["FlexVolumeFsType"] = self.flexVolumeFsType!
                }
                if self.flexVolumeOptions != nil {
                    map["FlexVolumeOptions"] = self.flexVolumeOptions!
                }
                if self.hostPathVolumePath != nil {
                    map["HostPathVolumePath"] = self.hostPathVolumePath!
                }
                if self.hostPathVolumeType != nil {
                    map["HostPathVolumeType"] = self.hostPathVolumeType!
                }
                if self.NFSVolumePath != nil {
                    map["NFSVolumePath"] = self.NFSVolumePath!
                }
                if self.NFSVolumeReadOnly != nil {
                    map["NFSVolumeReadOnly"] = self.NFSVolumeReadOnly!
                }
                if self.NFSVolumeServer != nil {
                    map["NFSVolumeServer"] = self.NFSVolumeServer!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ConfigFileVolumeConfigFileToPaths"] as? [Any?] {
                    var tmp : [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.Volumes.ConfigFileVolumeConfigFileToPaths] = []
                    for v in value {
                        if v != nil {
                            var model = DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.Volumes.ConfigFileVolumeConfigFileToPaths()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.configFileVolumeConfigFileToPaths = tmp
                }
                if let value = dict["ConfigFileVolumeDefaultMode"] as? Int32 {
                    self.configFileVolumeDefaultMode = value
                }
                if let value = dict["DiskVolumeDiskId"] as? String {
                    self.diskVolumeDiskId = value
                }
                if let value = dict["DiskVolumeDiskSize"] as? Int32 {
                    self.diskVolumeDiskSize = value
                }
                if let value = dict["DiskVolumeFsType"] as? String {
                    self.diskVolumeFsType = value
                }
                if let value = dict["EmptyDirVolumeMedium"] as? String {
                    self.emptyDirVolumeMedium = value
                }
                if let value = dict["EmptyDirVolumeSizeLimit"] as? String {
                    self.emptyDirVolumeSizeLimit = value
                }
                if let value = dict["FlexVolumeDriver"] as? String {
                    self.flexVolumeDriver = value
                }
                if let value = dict["FlexVolumeFsType"] as? String {
                    self.flexVolumeFsType = value
                }
                if let value = dict["FlexVolumeOptions"] as? String {
                    self.flexVolumeOptions = value
                }
                if let value = dict["HostPathVolumePath"] as? String {
                    self.hostPathVolumePath = value
                }
                if let value = dict["HostPathVolumeType"] as? String {
                    self.hostPathVolumeType = value
                }
                if let value = dict["NFSVolumePath"] as? String {
                    self.NFSVolumePath = value
                }
                if let value = dict["NFSVolumeReadOnly"] as? Bool {
                    self.NFSVolumeReadOnly = value
                }
                if let value = dict["NFSVolumeServer"] as? String {
                    self.NFSVolumeServer = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
            }
        }
        public var acrRegistryInfos: [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.AcrRegistryInfos]?

        public var activeDeadlineSeconds: Int32?

        public var autoCreateEip: Bool?

        public var autoMatchImageCache: Bool?

        public var containerGroupName: String?

        public var containers: [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.Containers]?

        public var costOptimization: Bool?

        public var cpu: Double?

        public var cpuOptionsCore: Int32?

        public var cpuOptionsThreadsPerCore: Int32?

        public var creationTime: String?

        public var dataCacheBucket: String?

        public var dataCacheBurstingEnabled: Bool?

        public var dataCachePL: String?

        public var dataCacheProvisionedIops: Int32?

        public var description_: String?

        public var dnsConfigNameServers: [String]?

        public var dnsConfigOptions: [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.DnsConfigOptions]?

        public var dnsConfigSearches: [String]?

        public var dnsPolicy: String?

        public var egressBandwidth: Int64?

        public var eipBandwidth: Int32?

        public var ephemeralStorage: Int32?

        public var gpuDriverVersion: String?

        public var hostAliases: [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.HostAliases]?

        public var hostName: String?

        public var imageRegistryCredentials: [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.ImageRegistryCredentials]?

        public var imageSnapshotId: String?

        public var ingressBandwidth: Int64?

        public var initContainers: [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.InitContainers]?

        public var instanceFamilyLevel: String?

        public var instanceTypes: [String]?

        public var ipv6AddressCount: Int32?

        public var lifecycleState: String?

        public var loadBalancerWeight: Int32?

        public var memory: Double?

        public var ntpServers: [String]?

        public var ramRoleName: String?

        public var regionId: String?

        public var resourceGroupId: String?

        public var restartPolicy: String?

        public var scalingConfigurationId: String?

        public var scalingConfigurationName: String?

        public var scalingGroupId: String?

        public var securityContextSysCtls: [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.SecurityContextSysCtls]?

        public var securityGroupId: String?

        public var slsEnable: Bool?

        public var spotPriceLimit: Double?

        public var spotStrategy: String?

        public var tags: [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.Tags]?

        public var terminationGracePeriodSeconds: Int32?

        public var volumes: [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.Volumes]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.acrRegistryInfos != nil {
                var tmp : [Any] = []
                for k in self.acrRegistryInfos! {
                    tmp.append(k.toMap())
                }
                map["AcrRegistryInfos"] = tmp
            }
            if self.activeDeadlineSeconds != nil {
                map["ActiveDeadlineSeconds"] = self.activeDeadlineSeconds!
            }
            if self.autoCreateEip != nil {
                map["AutoCreateEip"] = self.autoCreateEip!
            }
            if self.autoMatchImageCache != nil {
                map["AutoMatchImageCache"] = self.autoMatchImageCache!
            }
            if self.containerGroupName != nil {
                map["ContainerGroupName"] = self.containerGroupName!
            }
            if self.containers != nil {
                var tmp : [Any] = []
                for k in self.containers! {
                    tmp.append(k.toMap())
                }
                map["Containers"] = tmp
            }
            if self.costOptimization != nil {
                map["CostOptimization"] = self.costOptimization!
            }
            if self.cpu != nil {
                map["Cpu"] = self.cpu!
            }
            if self.cpuOptionsCore != nil {
                map["CpuOptionsCore"] = self.cpuOptionsCore!
            }
            if self.cpuOptionsThreadsPerCore != nil {
                map["CpuOptionsThreadsPerCore"] = self.cpuOptionsThreadsPerCore!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.dataCacheBucket != nil {
                map["DataCacheBucket"] = self.dataCacheBucket!
            }
            if self.dataCacheBurstingEnabled != nil {
                map["DataCacheBurstingEnabled"] = self.dataCacheBurstingEnabled!
            }
            if self.dataCachePL != nil {
                map["DataCachePL"] = self.dataCachePL!
            }
            if self.dataCacheProvisionedIops != nil {
                map["DataCacheProvisionedIops"] = self.dataCacheProvisionedIops!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.dnsConfigNameServers != nil {
                map["DnsConfigNameServers"] = self.dnsConfigNameServers!
            }
            if self.dnsConfigOptions != nil {
                var tmp : [Any] = []
                for k in self.dnsConfigOptions! {
                    tmp.append(k.toMap())
                }
                map["DnsConfigOptions"] = tmp
            }
            if self.dnsConfigSearches != nil {
                map["DnsConfigSearches"] = self.dnsConfigSearches!
            }
            if self.dnsPolicy != nil {
                map["DnsPolicy"] = self.dnsPolicy!
            }
            if self.egressBandwidth != nil {
                map["EgressBandwidth"] = self.egressBandwidth!
            }
            if self.eipBandwidth != nil {
                map["EipBandwidth"] = self.eipBandwidth!
            }
            if self.ephemeralStorage != nil {
                map["EphemeralStorage"] = self.ephemeralStorage!
            }
            if self.gpuDriverVersion != nil {
                map["GpuDriverVersion"] = self.gpuDriverVersion!
            }
            if self.hostAliases != nil {
                var tmp : [Any] = []
                for k in self.hostAliases! {
                    tmp.append(k.toMap())
                }
                map["HostAliases"] = tmp
            }
            if self.hostName != nil {
                map["HostName"] = self.hostName!
            }
            if self.imageRegistryCredentials != nil {
                var tmp : [Any] = []
                for k in self.imageRegistryCredentials! {
                    tmp.append(k.toMap())
                }
                map["ImageRegistryCredentials"] = tmp
            }
            if self.imageSnapshotId != nil {
                map["ImageSnapshotId"] = self.imageSnapshotId!
            }
            if self.ingressBandwidth != nil {
                map["IngressBandwidth"] = self.ingressBandwidth!
            }
            if self.initContainers != nil {
                var tmp : [Any] = []
                for k in self.initContainers! {
                    tmp.append(k.toMap())
                }
                map["InitContainers"] = tmp
            }
            if self.instanceFamilyLevel != nil {
                map["InstanceFamilyLevel"] = self.instanceFamilyLevel!
            }
            if self.instanceTypes != nil {
                map["InstanceTypes"] = self.instanceTypes!
            }
            if self.ipv6AddressCount != nil {
                map["Ipv6AddressCount"] = self.ipv6AddressCount!
            }
            if self.lifecycleState != nil {
                map["LifecycleState"] = self.lifecycleState!
            }
            if self.loadBalancerWeight != nil {
                map["LoadBalancerWeight"] = self.loadBalancerWeight!
            }
            if self.memory != nil {
                map["Memory"] = self.memory!
            }
            if self.ntpServers != nil {
                map["NtpServers"] = self.ntpServers!
            }
            if self.ramRoleName != nil {
                map["RamRoleName"] = self.ramRoleName!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.restartPolicy != nil {
                map["RestartPolicy"] = self.restartPolicy!
            }
            if self.scalingConfigurationId != nil {
                map["ScalingConfigurationId"] = self.scalingConfigurationId!
            }
            if self.scalingConfigurationName != nil {
                map["ScalingConfigurationName"] = self.scalingConfigurationName!
            }
            if self.scalingGroupId != nil {
                map["ScalingGroupId"] = self.scalingGroupId!
            }
            if self.securityContextSysCtls != nil {
                var tmp : [Any] = []
                for k in self.securityContextSysCtls! {
                    tmp.append(k.toMap())
                }
                map["SecurityContextSysCtls"] = tmp
            }
            if self.securityGroupId != nil {
                map["SecurityGroupId"] = self.securityGroupId!
            }
            if self.slsEnable != nil {
                map["SlsEnable"] = self.slsEnable!
            }
            if self.spotPriceLimit != nil {
                map["SpotPriceLimit"] = self.spotPriceLimit!
            }
            if self.spotStrategy != nil {
                map["SpotStrategy"] = self.spotStrategy!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            if self.terminationGracePeriodSeconds != nil {
                map["TerminationGracePeriodSeconds"] = self.terminationGracePeriodSeconds!
            }
            if self.volumes != nil {
                var tmp : [Any] = []
                for k in self.volumes! {
                    tmp.append(k.toMap())
                }
                map["Volumes"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AcrRegistryInfos"] as? [Any?] {
                var tmp : [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.AcrRegistryInfos] = []
                for v in value {
                    if v != nil {
                        var model = DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.AcrRegistryInfos()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.acrRegistryInfos = tmp
            }
            if let value = dict["ActiveDeadlineSeconds"] as? Int32 {
                self.activeDeadlineSeconds = value
            }
            if let value = dict["AutoCreateEip"] as? Bool {
                self.autoCreateEip = value
            }
            if let value = dict["AutoMatchImageCache"] as? Bool {
                self.autoMatchImageCache = value
            }
            if let value = dict["ContainerGroupName"] as? String {
                self.containerGroupName = value
            }
            if let value = dict["Containers"] as? [Any?] {
                var tmp : [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.Containers] = []
                for v in value {
                    if v != nil {
                        var model = DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.Containers()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.containers = tmp
            }
            if let value = dict["CostOptimization"] as? Bool {
                self.costOptimization = value
            }
            if let value = dict["Cpu"] as? Double {
                self.cpu = value
            }
            if let value = dict["CpuOptionsCore"] as? Int32 {
                self.cpuOptionsCore = value
            }
            if let value = dict["CpuOptionsThreadsPerCore"] as? Int32 {
                self.cpuOptionsThreadsPerCore = value
            }
            if let value = dict["CreationTime"] as? String {
                self.creationTime = value
            }
            if let value = dict["DataCacheBucket"] as? String {
                self.dataCacheBucket = value
            }
            if let value = dict["DataCacheBurstingEnabled"] as? Bool {
                self.dataCacheBurstingEnabled = value
            }
            if let value = dict["DataCachePL"] as? String {
                self.dataCachePL = value
            }
            if let value = dict["DataCacheProvisionedIops"] as? Int32 {
                self.dataCacheProvisionedIops = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["DnsConfigNameServers"] as? [String] {
                self.dnsConfigNameServers = value
            }
            if let value = dict["DnsConfigOptions"] as? [Any?] {
                var tmp : [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.DnsConfigOptions] = []
                for v in value {
                    if v != nil {
                        var model = DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.DnsConfigOptions()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.dnsConfigOptions = tmp
            }
            if let value = dict["DnsConfigSearches"] as? [String] {
                self.dnsConfigSearches = value
            }
            if let value = dict["DnsPolicy"] as? String {
                self.dnsPolicy = value
            }
            if let value = dict["EgressBandwidth"] as? Int64 {
                self.egressBandwidth = value
            }
            if let value = dict["EipBandwidth"] as? Int32 {
                self.eipBandwidth = value
            }
            if let value = dict["EphemeralStorage"] as? Int32 {
                self.ephemeralStorage = value
            }
            if let value = dict["GpuDriverVersion"] as? String {
                self.gpuDriverVersion = value
            }
            if let value = dict["HostAliases"] as? [Any?] {
                var tmp : [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.HostAliases] = []
                for v in value {
                    if v != nil {
                        var model = DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.HostAliases()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.hostAliases = tmp
            }
            if let value = dict["HostName"] as? String {
                self.hostName = value
            }
            if let value = dict["ImageRegistryCredentials"] as? [Any?] {
                var tmp : [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.ImageRegistryCredentials] = []
                for v in value {
                    if v != nil {
                        var model = DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.ImageRegistryCredentials()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.imageRegistryCredentials = tmp
            }
            if let value = dict["ImageSnapshotId"] as? String {
                self.imageSnapshotId = value
            }
            if let value = dict["IngressBandwidth"] as? Int64 {
                self.ingressBandwidth = value
            }
            if let value = dict["InitContainers"] as? [Any?] {
                var tmp : [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.InitContainers] = []
                for v in value {
                    if v != nil {
                        var model = DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.InitContainers()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.initContainers = tmp
            }
            if let value = dict["InstanceFamilyLevel"] as? String {
                self.instanceFamilyLevel = value
            }
            if let value = dict["InstanceTypes"] as? [String] {
                self.instanceTypes = value
            }
            if let value = dict["Ipv6AddressCount"] as? Int32 {
                self.ipv6AddressCount = value
            }
            if let value = dict["LifecycleState"] as? String {
                self.lifecycleState = value
            }
            if let value = dict["LoadBalancerWeight"] as? Int32 {
                self.loadBalancerWeight = value
            }
            if let value = dict["Memory"] as? Double {
                self.memory = value
            }
            if let value = dict["NtpServers"] as? [String] {
                self.ntpServers = value
            }
            if let value = dict["RamRoleName"] as? String {
                self.ramRoleName = value
            }
            if let value = dict["RegionId"] as? String {
                self.regionId = value
            }
            if let value = dict["ResourceGroupId"] as? String {
                self.resourceGroupId = value
            }
            if let value = dict["RestartPolicy"] as? String {
                self.restartPolicy = value
            }
            if let value = dict["ScalingConfigurationId"] as? String {
                self.scalingConfigurationId = value
            }
            if let value = dict["ScalingConfigurationName"] as? String {
                self.scalingConfigurationName = value
            }
            if let value = dict["ScalingGroupId"] as? String {
                self.scalingGroupId = value
            }
            if let value = dict["SecurityContextSysCtls"] as? [Any?] {
                var tmp : [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.SecurityContextSysCtls] = []
                for v in value {
                    if v != nil {
                        var model = DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.SecurityContextSysCtls()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.securityContextSysCtls = tmp
            }
            if let value = dict["SecurityGroupId"] as? String {
                self.securityGroupId = value
            }
            if let value = dict["SlsEnable"] as? Bool {
                self.slsEnable = value
            }
            if let value = dict["SpotPriceLimit"] as? Double {
                self.spotPriceLimit = value
            }
            if let value = dict["SpotStrategy"] as? String {
                self.spotStrategy = value
            }
            if let value = dict["Tags"] as? [Any?] {
                var tmp : [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.Tags] = []
                for v in value {
                    if v != nil {
                        var model = DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.Tags()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tags = tmp
            }
            if let value = dict["TerminationGracePeriodSeconds"] as? Int32 {
                self.terminationGracePeriodSeconds = value
            }
            if let value = dict["Volumes"] as? [Any?] {
                var tmp : [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.Volumes] = []
                for v in value {
                    if v != nil {
                        var model = DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.Volumes()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.volumes = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var scalingConfigurations: [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations]?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingConfigurations != nil {
            var tmp : [Any] = []
            for k in self.scalingConfigurations! {
                tmp.append(k.toMap())
            }
            map["ScalingConfigurations"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ScalingConfigurations"] as? [Any?] {
            var tmp : [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations] = []
            for v in value {
                if v != nil {
                    var model = DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.scalingConfigurations = tmp
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeEciScalingConfigurationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEciScalingConfigurationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeEciScalingConfigurationsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeElasticStrengthRequest : Tea.TeaModel {
    public var dataDiskCategories: [String]?

    public var imageFamily: String?

    public var imageId: String?

    public var imageName: String?

    public var instanceTypes: [String]?

    public var ipv6AddressCount: Int32?

    public var priorityStrategy: String?

    public var regionId: String?

    public var scalingGroupId: String?

    public var scalingGroupIds: [String]?

    public var spotStrategy: String?

    public var systemDiskCategories: [String]?

    public var vSwitchIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataDiskCategories != nil {
            map["DataDiskCategories"] = self.dataDiskCategories!
        }
        if self.imageFamily != nil {
            map["ImageFamily"] = self.imageFamily!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.imageName != nil {
            map["ImageName"] = self.imageName!
        }
        if self.instanceTypes != nil {
            map["InstanceTypes"] = self.instanceTypes!
        }
        if self.ipv6AddressCount != nil {
            map["Ipv6AddressCount"] = self.ipv6AddressCount!
        }
        if self.priorityStrategy != nil {
            map["PriorityStrategy"] = self.priorityStrategy!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        if self.scalingGroupIds != nil {
            map["ScalingGroupIds"] = self.scalingGroupIds!
        }
        if self.spotStrategy != nil {
            map["SpotStrategy"] = self.spotStrategy!
        }
        if self.systemDiskCategories != nil {
            map["SystemDiskCategories"] = self.systemDiskCategories!
        }
        if self.vSwitchIds != nil {
            map["VSwitchIds"] = self.vSwitchIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DataDiskCategories"] as? [String] {
            self.dataDiskCategories = value
        }
        if let value = dict["ImageFamily"] as? String {
            self.imageFamily = value
        }
        if let value = dict["ImageId"] as? String {
            self.imageId = value
        }
        if let value = dict["ImageName"] as? String {
            self.imageName = value
        }
        if let value = dict["InstanceTypes"] as? [String] {
            self.instanceTypes = value
        }
        if let value = dict["Ipv6AddressCount"] as? Int32 {
            self.ipv6AddressCount = value
        }
        if let value = dict["PriorityStrategy"] as? String {
            self.priorityStrategy = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ScalingGroupId"] as? String {
            self.scalingGroupId = value
        }
        if let value = dict["ScalingGroupIds"] as? [String] {
            self.scalingGroupIds = value
        }
        if let value = dict["SpotStrategy"] as? String {
            self.spotStrategy = value
        }
        if let value = dict["SystemDiskCategories"] as? [String] {
            self.systemDiskCategories = value
        }
        if let value = dict["VSwitchIds"] as? [String] {
            self.vSwitchIds = value
        }
    }
}

public class DescribeElasticStrengthResponseBody : Tea.TeaModel {
    public class ElasticStrengthModels : Tea.TeaModel {
        public class ResourcePools : Tea.TeaModel {
            public class InventoryHealth : Tea.TeaModel {
                public var adequacyScore: Int32?

                public var healthScore: Int32?

                public var hotScore: Int32?

                public var supplyScore: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.adequacyScore != nil {
                        map["AdequacyScore"] = self.adequacyScore!
                    }
                    if self.healthScore != nil {
                        map["HealthScore"] = self.healthScore!
                    }
                    if self.hotScore != nil {
                        map["HotScore"] = self.hotScore!
                    }
                    if self.supplyScore != nil {
                        map["SupplyScore"] = self.supplyScore!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["AdequacyScore"] as? Int32 {
                        self.adequacyScore = value
                    }
                    if let value = dict["HealthScore"] as? Int32 {
                        self.healthScore = value
                    }
                    if let value = dict["HotScore"] as? Int32 {
                        self.hotScore = value
                    }
                    if let value = dict["SupplyScore"] as? Int32 {
                        self.supplyScore = value
                    }
                }
            }
            public var code: String?

            public var instanceType: String?

            public var inventoryHealth: DescribeElasticStrengthResponseBody.ElasticStrengthModels.ResourcePools.InventoryHealth?

            public var msg: String?

            public var status: String?

            public var strength: Double?

            public var vSwitchIds: [String]?

            public var zoneId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.inventoryHealth?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.instanceType != nil {
                    map["InstanceType"] = self.instanceType!
                }
                if self.inventoryHealth != nil {
                    map["InventoryHealth"] = self.inventoryHealth?.toMap()
                }
                if self.msg != nil {
                    map["Msg"] = self.msg!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.strength != nil {
                    map["Strength"] = self.strength!
                }
                if self.vSwitchIds != nil {
                    map["VSwitchIds"] = self.vSwitchIds!
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Code"] as? String {
                    self.code = value
                }
                if let value = dict["InstanceType"] as? String {
                    self.instanceType = value
                }
                if let value = dict["InventoryHealth"] as? [String: Any?] {
                    var model = DescribeElasticStrengthResponseBody.ElasticStrengthModels.ResourcePools.InventoryHealth()
                    model.fromMap(value)
                    self.inventoryHealth = model
                }
                if let value = dict["Msg"] as? String {
                    self.msg = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
                if let value = dict["Strength"] as? Double {
                    self.strength = value
                }
                if let value = dict["VSwitchIds"] as? [String] {
                    self.vSwitchIds = value
                }
                if let value = dict["ZoneId"] as? String {
                    self.zoneId = value
                }
            }
        }
        public var elasticStrength: String?

        public var resourcePools: [DescribeElasticStrengthResponseBody.ElasticStrengthModels.ResourcePools]?

        public var scalingGroupId: String?

        public var totalStrength: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.elasticStrength != nil {
                map["ElasticStrength"] = self.elasticStrength!
            }
            if self.resourcePools != nil {
                var tmp : [Any] = []
                for k in self.resourcePools! {
                    tmp.append(k.toMap())
                }
                map["ResourcePools"] = tmp
            }
            if self.scalingGroupId != nil {
                map["ScalingGroupId"] = self.scalingGroupId!
            }
            if self.totalStrength != nil {
                map["TotalStrength"] = self.totalStrength!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ElasticStrength"] as? String {
                self.elasticStrength = value
            }
            if let value = dict["ResourcePools"] as? [Any?] {
                var tmp : [DescribeElasticStrengthResponseBody.ElasticStrengthModels.ResourcePools] = []
                for v in value {
                    if v != nil {
                        var model = DescribeElasticStrengthResponseBody.ElasticStrengthModels.ResourcePools()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.resourcePools = tmp
            }
            if let value = dict["ScalingGroupId"] as? String {
                self.scalingGroupId = value
            }
            if let value = dict["TotalStrength"] as? Double {
                self.totalStrength = value
            }
        }
    }
    public class ResourcePools : Tea.TeaModel {
        public class InventoryHealth : Tea.TeaModel {
            public var adequacyScore: Int32?

            public var healthScore: Int32?

            public var hotScore: Int32?

            public var supplyScore: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.adequacyScore != nil {
                    map["AdequacyScore"] = self.adequacyScore!
                }
                if self.healthScore != nil {
                    map["HealthScore"] = self.healthScore!
                }
                if self.hotScore != nil {
                    map["HotScore"] = self.hotScore!
                }
                if self.supplyScore != nil {
                    map["SupplyScore"] = self.supplyScore!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AdequacyScore"] as? Int32 {
                    self.adequacyScore = value
                }
                if let value = dict["HealthScore"] as? Int32 {
                    self.healthScore = value
                }
                if let value = dict["HotScore"] as? Int32 {
                    self.hotScore = value
                }
                if let value = dict["SupplyScore"] as? Int32 {
                    self.supplyScore = value
                }
            }
        }
        public var code: String?

        public var instanceType: String?

        public var inventoryHealth: DescribeElasticStrengthResponseBody.ResourcePools.InventoryHealth?

        public var msg: String?

        public var status: String?

        public var strength: Double?

        public var vSwitchIds: [String]?

        public var zoneId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.inventoryHealth?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.inventoryHealth != nil {
                map["InventoryHealth"] = self.inventoryHealth?.toMap()
            }
            if self.msg != nil {
                map["Msg"] = self.msg!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.strength != nil {
                map["Strength"] = self.strength!
            }
            if self.vSwitchIds != nil {
                map["VSwitchIds"] = self.vSwitchIds!
            }
            if self.zoneId != nil {
                map["ZoneId"] = self.zoneId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Code"] as? String {
                self.code = value
            }
            if let value = dict["InstanceType"] as? String {
                self.instanceType = value
            }
            if let value = dict["InventoryHealth"] as? [String: Any?] {
                var model = DescribeElasticStrengthResponseBody.ResourcePools.InventoryHealth()
                model.fromMap(value)
                self.inventoryHealth = model
            }
            if let value = dict["Msg"] as? String {
                self.msg = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
            if let value = dict["Strength"] as? Double {
                self.strength = value
            }
            if let value = dict["VSwitchIds"] as? [String] {
                self.vSwitchIds = value
            }
            if let value = dict["ZoneId"] as? String {
                self.zoneId = value
            }
        }
    }
    public var elasticStrength: String?

    public var elasticStrengthModels: [DescribeElasticStrengthResponseBody.ElasticStrengthModels]?

    public var requestId: String?

    public var resourcePools: [DescribeElasticStrengthResponseBody.ResourcePools]?

    public var totalStrength: Double?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.elasticStrength != nil {
            map["ElasticStrength"] = self.elasticStrength!
        }
        if self.elasticStrengthModels != nil {
            var tmp : [Any] = []
            for k in self.elasticStrengthModels! {
                tmp.append(k.toMap())
            }
            map["ElasticStrengthModels"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourcePools != nil {
            var tmp : [Any] = []
            for k in self.resourcePools! {
                tmp.append(k.toMap())
            }
            map["ResourcePools"] = tmp
        }
        if self.totalStrength != nil {
            map["TotalStrength"] = self.totalStrength!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ElasticStrength"] as? String {
            self.elasticStrength = value
        }
        if let value = dict["ElasticStrengthModels"] as? [Any?] {
            var tmp : [DescribeElasticStrengthResponseBody.ElasticStrengthModels] = []
            for v in value {
                if v != nil {
                    var model = DescribeElasticStrengthResponseBody.ElasticStrengthModels()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.elasticStrengthModels = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ResourcePools"] as? [Any?] {
            var tmp : [DescribeElasticStrengthResponseBody.ResourcePools] = []
            for v in value {
                if v != nil {
                    var model = DescribeElasticStrengthResponseBody.ResourcePools()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.resourcePools = tmp
        }
        if let value = dict["TotalStrength"] as? Double {
            self.totalStrength = value
        }
    }
}

public class DescribeElasticStrengthResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeElasticStrengthResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeElasticStrengthResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeInstanceRefreshesRequest : Tea.TeaModel {
    public var instanceRefreshTaskIds: [String]?

    public var maxResults: Int32?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceRefreshTaskIds != nil {
            map["InstanceRefreshTaskIds"] = self.instanceRefreshTaskIds!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceRefreshTaskIds"] as? [String] {
            self.instanceRefreshTaskIds = value
        }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ScalingGroupId"] as? String {
            self.scalingGroupId = value
        }
    }
}

public class DescribeInstanceRefreshesResponseBody : Tea.TeaModel {
    public class InstanceRefreshTasks : Tea.TeaModel {
        public class DesiredConfiguration : Tea.TeaModel {
            public var imageId: String?

            public var scalingConfigurationId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.imageId != nil {
                    map["ImageId"] = self.imageId!
                }
                if self.scalingConfigurationId != nil {
                    map["ScalingConfigurationId"] = self.scalingConfigurationId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ImageId"] as? String {
                    self.imageId = value
                }
                if let value = dict["ScalingConfigurationId"] as? String {
                    self.scalingConfigurationId = value
                }
            }
        }
        public var desiredConfiguration: DescribeInstanceRefreshesResponseBody.InstanceRefreshTasks.DesiredConfiguration?

        public var detail: String?

        public var endTime: String?

        public var finishedUpdateCapacity: Int32?

        public var instanceRefreshTaskId: String?

        public var maxHealthyPercentage: Int32?

        public var minHealthyPercentage: Int32?

        public var regionId: String?

        public var scalingGroupId: String?

        public var skipMatching: Bool?

        public var startTime: String?

        public var status: String?

        public var totalNeedUpdateCapacity: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.desiredConfiguration?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.desiredConfiguration != nil {
                map["DesiredConfiguration"] = self.desiredConfiguration?.toMap()
            }
            if self.detail != nil {
                map["Detail"] = self.detail!
            }
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.finishedUpdateCapacity != nil {
                map["FinishedUpdateCapacity"] = self.finishedUpdateCapacity!
            }
            if self.instanceRefreshTaskId != nil {
                map["InstanceRefreshTaskId"] = self.instanceRefreshTaskId!
            }
            if self.maxHealthyPercentage != nil {
                map["MaxHealthyPercentage"] = self.maxHealthyPercentage!
            }
            if self.minHealthyPercentage != nil {
                map["MinHealthyPercentage"] = self.minHealthyPercentage!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.scalingGroupId != nil {
                map["ScalingGroupId"] = self.scalingGroupId!
            }
            if self.skipMatching != nil {
                map["SkipMatching"] = self.skipMatching!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.totalNeedUpdateCapacity != nil {
                map["TotalNeedUpdateCapacity"] = self.totalNeedUpdateCapacity!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DesiredConfiguration"] as? [String: Any?] {
                var model = DescribeInstanceRefreshesResponseBody.InstanceRefreshTasks.DesiredConfiguration()
                model.fromMap(value)
                self.desiredConfiguration = model
            }
            if let value = dict["Detail"] as? String {
                self.detail = value
            }
            if let value = dict["EndTime"] as? String {
                self.endTime = value
            }
            if let value = dict["FinishedUpdateCapacity"] as? Int32 {
                self.finishedUpdateCapacity = value
            }
            if let value = dict["InstanceRefreshTaskId"] as? String {
                self.instanceRefreshTaskId = value
            }
            if let value = dict["MaxHealthyPercentage"] as? Int32 {
                self.maxHealthyPercentage = value
            }
            if let value = dict["MinHealthyPercentage"] as? Int32 {
                self.minHealthyPercentage = value
            }
            if let value = dict["RegionId"] as? String {
                self.regionId = value
            }
            if let value = dict["ScalingGroupId"] as? String {
                self.scalingGroupId = value
            }
            if let value = dict["SkipMatching"] as? Bool {
                self.skipMatching = value
            }
            if let value = dict["StartTime"] as? String {
                self.startTime = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
            if let value = dict["TotalNeedUpdateCapacity"] as? Int32 {
                self.totalNeedUpdateCapacity = value
            }
        }
    }
    public var instanceRefreshTasks: [DescribeInstanceRefreshesResponseBody.InstanceRefreshTasks]?

    public var maxResults: Int32?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceRefreshTasks != nil {
            var tmp : [Any] = []
            for k in self.instanceRefreshTasks! {
                tmp.append(k.toMap())
            }
            map["InstanceRefreshTasks"] = tmp
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceRefreshTasks"] as? [Any?] {
            var tmp : [DescribeInstanceRefreshesResponseBody.InstanceRefreshTasks] = []
            for v in value {
                if v != nil {
                    var model = DescribeInstanceRefreshesResponseBody.InstanceRefreshTasks()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.instanceRefreshTasks = tmp
        }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeInstanceRefreshesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstanceRefreshesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeInstanceRefreshesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLifecycleActionsRequest : Tea.TeaModel {
    public var lifecycleActionStatus: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingActivityId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lifecycleActionStatus != nil {
            map["LifecycleActionStatus"] = self.lifecycleActionStatus!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingActivityId != nil {
            map["ScalingActivityId"] = self.scalingActivityId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["LifecycleActionStatus"] as? String {
            self.lifecycleActionStatus = value
        }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ScalingActivityId"] as? String {
            self.scalingActivityId = value
        }
    }
}

public class DescribeLifecycleActionsResponseBody : Tea.TeaModel {
    public class LifecycleActions : Tea.TeaModel {
        public var instanceIds: [String]?

        public var lifecycleActionResult: String?

        public var lifecycleActionStatus: String?

        public var lifecycleActionToken: String?

        public var lifecycleHookId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceIds != nil {
                map["InstanceIds"] = self.instanceIds!
            }
            if self.lifecycleActionResult != nil {
                map["LifecycleActionResult"] = self.lifecycleActionResult!
            }
            if self.lifecycleActionStatus != nil {
                map["LifecycleActionStatus"] = self.lifecycleActionStatus!
            }
            if self.lifecycleActionToken != nil {
                map["LifecycleActionToken"] = self.lifecycleActionToken!
            }
            if self.lifecycleHookId != nil {
                map["LifecycleHookId"] = self.lifecycleHookId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["InstanceIds"] as? [String] {
                self.instanceIds = value
            }
            if let value = dict["LifecycleActionResult"] as? String {
                self.lifecycleActionResult = value
            }
            if let value = dict["LifecycleActionStatus"] as? String {
                self.lifecycleActionStatus = value
            }
            if let value = dict["LifecycleActionToken"] as? String {
                self.lifecycleActionToken = value
            }
            if let value = dict["LifecycleHookId"] as? String {
                self.lifecycleHookId = value
            }
        }
    }
    public var lifecycleActions: [DescribeLifecycleActionsResponseBody.LifecycleActions]?

    public var maxResults: Int32?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lifecycleActions != nil {
            var tmp : [Any] = []
            for k in self.lifecycleActions! {
                tmp.append(k.toMap())
            }
            map["LifecycleActions"] = tmp
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["LifecycleActions"] as? [Any?] {
            var tmp : [DescribeLifecycleActionsResponseBody.LifecycleActions] = []
            for v in value {
                if v != nil {
                    var model = DescribeLifecycleActionsResponseBody.LifecycleActions()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.lifecycleActions = tmp
        }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeLifecycleActionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLifecycleActionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLifecycleActionsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLifecycleHooksRequest : Tea.TeaModel {
    public var lifecycleHookIds: [String]?

    public var lifecycleHookName: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lifecycleHookIds != nil {
            map["LifecycleHookIds"] = self.lifecycleHookIds!
        }
        if self.lifecycleHookName != nil {
            map["LifecycleHookName"] = self.lifecycleHookName!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["LifecycleHookIds"] as? [String] {
            self.lifecycleHookIds = value
        }
        if let value = dict["LifecycleHookName"] as? String {
            self.lifecycleHookName = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ScalingGroupId"] as? String {
            self.scalingGroupId = value
        }
    }
}

public class DescribeLifecycleHooksResponseBody : Tea.TeaModel {
    public class LifecycleHooks : Tea.TeaModel {
        public var defaultResult: String?

        public var heartbeatTimeout: Int32?

        public var lifecycleHookId: String?

        public var lifecycleHookName: String?

        public var lifecycleHookStatus: String?

        public var lifecycleTransition: String?

        public var notificationArn: String?

        public var notificationMetadata: String?

        public var scalingGroupId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.defaultResult != nil {
                map["DefaultResult"] = self.defaultResult!
            }
            if self.heartbeatTimeout != nil {
                map["HeartbeatTimeout"] = self.heartbeatTimeout!
            }
            if self.lifecycleHookId != nil {
                map["LifecycleHookId"] = self.lifecycleHookId!
            }
            if self.lifecycleHookName != nil {
                map["LifecycleHookName"] = self.lifecycleHookName!
            }
            if self.lifecycleHookStatus != nil {
                map["LifecycleHookStatus"] = self.lifecycleHookStatus!
            }
            if self.lifecycleTransition != nil {
                map["LifecycleTransition"] = self.lifecycleTransition!
            }
            if self.notificationArn != nil {
                map["NotificationArn"] = self.notificationArn!
            }
            if self.notificationMetadata != nil {
                map["NotificationMetadata"] = self.notificationMetadata!
            }
            if self.scalingGroupId != nil {
                map["ScalingGroupId"] = self.scalingGroupId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DefaultResult"] as? String {
                self.defaultResult = value
            }
            if let value = dict["HeartbeatTimeout"] as? Int32 {
                self.heartbeatTimeout = value
            }
            if let value = dict["LifecycleHookId"] as? String {
                self.lifecycleHookId = value
            }
            if let value = dict["LifecycleHookName"] as? String {
                self.lifecycleHookName = value
            }
            if let value = dict["LifecycleHookStatus"] as? String {
                self.lifecycleHookStatus = value
            }
            if let value = dict["LifecycleTransition"] as? String {
                self.lifecycleTransition = value
            }
            if let value = dict["NotificationArn"] as? String {
                self.notificationArn = value
            }
            if let value = dict["NotificationMetadata"] as? String {
                self.notificationMetadata = value
            }
            if let value = dict["ScalingGroupId"] as? String {
                self.scalingGroupId = value
            }
        }
    }
    public var lifecycleHooks: [DescribeLifecycleHooksResponseBody.LifecycleHooks]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lifecycleHooks != nil {
            var tmp : [Any] = []
            for k in self.lifecycleHooks! {
                tmp.append(k.toMap())
            }
            map["LifecycleHooks"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["LifecycleHooks"] as? [Any?] {
            var tmp : [DescribeLifecycleHooksResponseBody.LifecycleHooks] = []
            for v in value {
                if v != nil {
                    var model = DescribeLifecycleHooksResponseBody.LifecycleHooks()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.lifecycleHooks = tmp
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeLifecycleHooksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLifecycleHooksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLifecycleHooksResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLimitationRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
    }
}

public class DescribeLimitationResponseBody : Tea.TeaModel {
    public var maxNumberOfAlbServerGroup: Int32?

    public var maxNumberOfDBInstances: Int32?

    public var maxNumberOfLifecycleHooks: Int32?

    public var maxNumberOfLoadBalancers: Int32?

    public var maxNumberOfMaxSize: Int32?

    public var maxNumberOfMinSize: Int32?

    public var maxNumberOfNlbServerGroup: Int32?

    public var maxNumberOfNotificationConfigurations: Int32?

    public var maxNumberOfScalingConfigurations: Int32?

    public var maxNumberOfScalingGroups: Int32?

    public var maxNumberOfScalingInstances: Int32?

    public var maxNumberOfScalingRules: Int32?

    public var maxNumberOfScheduledTasks: Int32?

    public var maxNumberOfVServerGroups: Int32?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxNumberOfAlbServerGroup != nil {
            map["MaxNumberOfAlbServerGroup"] = self.maxNumberOfAlbServerGroup!
        }
        if self.maxNumberOfDBInstances != nil {
            map["MaxNumberOfDBInstances"] = self.maxNumberOfDBInstances!
        }
        if self.maxNumberOfLifecycleHooks != nil {
            map["MaxNumberOfLifecycleHooks"] = self.maxNumberOfLifecycleHooks!
        }
        if self.maxNumberOfLoadBalancers != nil {
            map["MaxNumberOfLoadBalancers"] = self.maxNumberOfLoadBalancers!
        }
        if self.maxNumberOfMaxSize != nil {
            map["MaxNumberOfMaxSize"] = self.maxNumberOfMaxSize!
        }
        if self.maxNumberOfMinSize != nil {
            map["MaxNumberOfMinSize"] = self.maxNumberOfMinSize!
        }
        if self.maxNumberOfNlbServerGroup != nil {
            map["MaxNumberOfNlbServerGroup"] = self.maxNumberOfNlbServerGroup!
        }
        if self.maxNumberOfNotificationConfigurations != nil {
            map["MaxNumberOfNotificationConfigurations"] = self.maxNumberOfNotificationConfigurations!
        }
        if self.maxNumberOfScalingConfigurations != nil {
            map["MaxNumberOfScalingConfigurations"] = self.maxNumberOfScalingConfigurations!
        }
        if self.maxNumberOfScalingGroups != nil {
            map["MaxNumberOfScalingGroups"] = self.maxNumberOfScalingGroups!
        }
        if self.maxNumberOfScalingInstances != nil {
            map["MaxNumberOfScalingInstances"] = self.maxNumberOfScalingInstances!
        }
        if self.maxNumberOfScalingRules != nil {
            map["MaxNumberOfScalingRules"] = self.maxNumberOfScalingRules!
        }
        if self.maxNumberOfScheduledTasks != nil {
            map["MaxNumberOfScheduledTasks"] = self.maxNumberOfScheduledTasks!
        }
        if self.maxNumberOfVServerGroups != nil {
            map["MaxNumberOfVServerGroups"] = self.maxNumberOfVServerGroups!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["MaxNumberOfAlbServerGroup"] as? Int32 {
            self.maxNumberOfAlbServerGroup = value
        }
        if let value = dict["MaxNumberOfDBInstances"] as? Int32 {
            self.maxNumberOfDBInstances = value
        }
        if let value = dict["MaxNumberOfLifecycleHooks"] as? Int32 {
            self.maxNumberOfLifecycleHooks = value
        }
        if let value = dict["MaxNumberOfLoadBalancers"] as? Int32 {
            self.maxNumberOfLoadBalancers = value
        }
        if let value = dict["MaxNumberOfMaxSize"] as? Int32 {
            self.maxNumberOfMaxSize = value
        }
        if let value = dict["MaxNumberOfMinSize"] as? Int32 {
            self.maxNumberOfMinSize = value
        }
        if let value = dict["MaxNumberOfNlbServerGroup"] as? Int32 {
            self.maxNumberOfNlbServerGroup = value
        }
        if let value = dict["MaxNumberOfNotificationConfigurations"] as? Int32 {
            self.maxNumberOfNotificationConfigurations = value
        }
        if let value = dict["MaxNumberOfScalingConfigurations"] as? Int32 {
            self.maxNumberOfScalingConfigurations = value
        }
        if let value = dict["MaxNumberOfScalingGroups"] as? Int32 {
            self.maxNumberOfScalingGroups = value
        }
        if let value = dict["MaxNumberOfScalingInstances"] as? Int32 {
            self.maxNumberOfScalingInstances = value
        }
        if let value = dict["MaxNumberOfScalingRules"] as? Int32 {
            self.maxNumberOfScalingRules = value
        }
        if let value = dict["MaxNumberOfScheduledTasks"] as? Int32 {
            self.maxNumberOfScheduledTasks = value
        }
        if let value = dict["MaxNumberOfVServerGroups"] as? Int32 {
            self.maxNumberOfVServerGroups = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeLimitationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLimitationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLimitationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeNotificationConfigurationsRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ScalingGroupId"] as? String {
            self.scalingGroupId = value
        }
    }
}

public class DescribeNotificationConfigurationsResponseBody : Tea.TeaModel {
    public class NotificationConfigurationModels : Tea.TeaModel {
        public var notificationArn: String?

        public var notificationTypes: [String]?

        public var scalingGroupId: String?

        public var timeZone: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.notificationArn != nil {
                map["NotificationArn"] = self.notificationArn!
            }
            if self.notificationTypes != nil {
                map["NotificationTypes"] = self.notificationTypes!
            }
            if self.scalingGroupId != nil {
                map["ScalingGroupId"] = self.scalingGroupId!
            }
            if self.timeZone != nil {
                map["TimeZone"] = self.timeZone!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["NotificationArn"] as? String {
                self.notificationArn = value
            }
            if let value = dict["NotificationTypes"] as? [String] {
                self.notificationTypes = value
            }
            if let value = dict["ScalingGroupId"] as? String {
                self.scalingGroupId = value
            }
            if let value = dict["TimeZone"] as? String {
                self.timeZone = value
            }
        }
    }
    public var notificationConfigurationModels: [DescribeNotificationConfigurationsResponseBody.NotificationConfigurationModels]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.notificationConfigurationModels != nil {
            var tmp : [Any] = []
            for k in self.notificationConfigurationModels! {
                tmp.append(k.toMap())
            }
            map["NotificationConfigurationModels"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NotificationConfigurationModels"] as? [Any?] {
            var tmp : [DescribeNotificationConfigurationsResponseBody.NotificationConfigurationModels] = []
            for v in value {
                if v != nil {
                    var model = DescribeNotificationConfigurationsResponseBody.NotificationConfigurationModels()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.notificationConfigurationModels = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeNotificationConfigurationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeNotificationConfigurationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeNotificationConfigurationsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeNotificationTypesRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
    }
}

public class DescribeNotificationTypesResponseBody : Tea.TeaModel {
    public var notificationTypes: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.notificationTypes != nil {
            map["NotificationTypes"] = self.notificationTypes!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NotificationTypes"] as? [String] {
            self.notificationTypes = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeNotificationTypesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeNotificationTypesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeNotificationTypesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribePatternTypesRequest : Tea.TeaModel {
    public var architecture: [String]?

    public var burstablePerformance: String?

    public var channelId: Int64?

    public var cores: Int32?

    public var coresList: [Int32]?

    public var cpuArchitectures: [String]?

    public var excludedInstanceType: [String]?

    public var gpuSpecs: [String]?

    public var instanceCategories: [String]?

    public var instanceFamilyLevel: String?

    public var instanceTypeFamilies: [String]?

    public var maxPrice: Double?

    public var maximumCpuCoreCount: Int32?

    public var maximumGpuAmount: Int32?

    public var maximumMemorySize: Double?

    public var memory: Double?

    public var memoryList: [Double]?

    public var minimumBaselineCredit: Int32?

    public var minimumCpuCoreCount: Int32?

    public var minimumEniIpv6AddressQuantity: Int32?

    public var minimumEniPrivateIpAddressQuantity: Int32?

    public var minimumEniQuantity: Int32?

    public var minimumGpuAmount: Int32?

    public var minimumInitialCredit: Int32?

    public var minimumMemorySize: Double?

    public var physicalProcessorModels: [String]?

    public var regionId: String?

    public var spotStrategy: String?

    public var vSwitchId: [String]?

    public var zoneId: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.architecture != nil {
            map["Architecture"] = self.architecture!
        }
        if self.burstablePerformance != nil {
            map["BurstablePerformance"] = self.burstablePerformance!
        }
        if self.channelId != nil {
            map["ChannelId"] = self.channelId!
        }
        if self.cores != nil {
            map["Cores"] = self.cores!
        }
        if self.coresList != nil {
            map["CoresList"] = self.coresList!
        }
        if self.cpuArchitectures != nil {
            map["CpuArchitectures"] = self.cpuArchitectures!
        }
        if self.excludedInstanceType != nil {
            map["ExcludedInstanceType"] = self.excludedInstanceType!
        }
        if self.gpuSpecs != nil {
            map["GpuSpecs"] = self.gpuSpecs!
        }
        if self.instanceCategories != nil {
            map["InstanceCategories"] = self.instanceCategories!
        }
        if self.instanceFamilyLevel != nil {
            map["InstanceFamilyLevel"] = self.instanceFamilyLevel!
        }
        if self.instanceTypeFamilies != nil {
            map["InstanceTypeFamilies"] = self.instanceTypeFamilies!
        }
        if self.maxPrice != nil {
            map["MaxPrice"] = self.maxPrice!
        }
        if self.maximumCpuCoreCount != nil {
            map["MaximumCpuCoreCount"] = self.maximumCpuCoreCount!
        }
        if self.maximumGpuAmount != nil {
            map["MaximumGpuAmount"] = self.maximumGpuAmount!
        }
        if self.maximumMemorySize != nil {
            map["MaximumMemorySize"] = self.maximumMemorySize!
        }
        if self.memory != nil {
            map["Memory"] = self.memory!
        }
        if self.memoryList != nil {
            map["MemoryList"] = self.memoryList!
        }
        if self.minimumBaselineCredit != nil {
            map["MinimumBaselineCredit"] = self.minimumBaselineCredit!
        }
        if self.minimumCpuCoreCount != nil {
            map["MinimumCpuCoreCount"] = self.minimumCpuCoreCount!
        }
        if self.minimumEniIpv6AddressQuantity != nil {
            map["MinimumEniIpv6AddressQuantity"] = self.minimumEniIpv6AddressQuantity!
        }
        if self.minimumEniPrivateIpAddressQuantity != nil {
            map["MinimumEniPrivateIpAddressQuantity"] = self.minimumEniPrivateIpAddressQuantity!
        }
        if self.minimumEniQuantity != nil {
            map["MinimumEniQuantity"] = self.minimumEniQuantity!
        }
        if self.minimumGpuAmount != nil {
            map["MinimumGpuAmount"] = self.minimumGpuAmount!
        }
        if self.minimumInitialCredit != nil {
            map["MinimumInitialCredit"] = self.minimumInitialCredit!
        }
        if self.minimumMemorySize != nil {
            map["MinimumMemorySize"] = self.minimumMemorySize!
        }
        if self.physicalProcessorModels != nil {
            map["PhysicalProcessorModels"] = self.physicalProcessorModels!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.spotStrategy != nil {
            map["SpotStrategy"] = self.spotStrategy!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Architecture"] as? [String] {
            self.architecture = value
        }
        if let value = dict["BurstablePerformance"] as? String {
            self.burstablePerformance = value
        }
        if let value = dict["ChannelId"] as? Int64 {
            self.channelId = value
        }
        if let value = dict["Cores"] as? Int32 {
            self.cores = value
        }
        if let value = dict["CoresList"] as? [Int32] {
            self.coresList = value
        }
        if let value = dict["CpuArchitectures"] as? [String] {
            self.cpuArchitectures = value
        }
        if let value = dict["ExcludedInstanceType"] as? [String] {
            self.excludedInstanceType = value
        }
        if let value = dict["GpuSpecs"] as? [String] {
            self.gpuSpecs = value
        }
        if let value = dict["InstanceCategories"] as? [String] {
            self.instanceCategories = value
        }
        if let value = dict["InstanceFamilyLevel"] as? String {
            self.instanceFamilyLevel = value
        }
        if let value = dict["InstanceTypeFamilies"] as? [String] {
            self.instanceTypeFamilies = value
        }
        if let value = dict["MaxPrice"] as? Double {
            self.maxPrice = value
        }
        if let value = dict["MaximumCpuCoreCount"] as? Int32 {
            self.maximumCpuCoreCount = value
        }
        if let value = dict["MaximumGpuAmount"] as? Int32 {
            self.maximumGpuAmount = value
        }
        if let value = dict["MaximumMemorySize"] as? Double {
            self.maximumMemorySize = value
        }
        if let value = dict["Memory"] as? Double {
            self.memory = value
        }
        if let value = dict["MemoryList"] as? [Double] {
            self.memoryList = value
        }
        if let value = dict["MinimumBaselineCredit"] as? Int32 {
            self.minimumBaselineCredit = value
        }
        if let value = dict["MinimumCpuCoreCount"] as? Int32 {
            self.minimumCpuCoreCount = value
        }
        if let value = dict["MinimumEniIpv6AddressQuantity"] as? Int32 {
            self.minimumEniIpv6AddressQuantity = value
        }
        if let value = dict["MinimumEniPrivateIpAddressQuantity"] as? Int32 {
            self.minimumEniPrivateIpAddressQuantity = value
        }
        if let value = dict["MinimumEniQuantity"] as? Int32 {
            self.minimumEniQuantity = value
        }
        if let value = dict["MinimumGpuAmount"] as? Int32 {
            self.minimumGpuAmount = value
        }
        if let value = dict["MinimumInitialCredit"] as? Int32 {
            self.minimumInitialCredit = value
        }
        if let value = dict["MinimumMemorySize"] as? Double {
            self.minimumMemorySize = value
        }
        if let value = dict["PhysicalProcessorModels"] as? [String] {
            self.physicalProcessorModels = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["SpotStrategy"] as? String {
            self.spotStrategy = value
        }
        if let value = dict["VSwitchId"] as? [String] {
            self.vSwitchId = value
        }
        if let value = dict["ZoneId"] as? [String] {
            self.zoneId = value
        }
    }
}

public class DescribePatternTypesResponseBody : Tea.TeaModel {
    public class PatternTypes : Tea.TeaModel {
        public var cores: Int32?

        public var instanceFamilyLevel: String?

        public var instanceType: String?

        public var instanceTypeFamily: String?

        public var memory: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cores != nil {
                map["Cores"] = self.cores!
            }
            if self.instanceFamilyLevel != nil {
                map["InstanceFamilyLevel"] = self.instanceFamilyLevel!
            }
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.instanceTypeFamily != nil {
                map["InstanceTypeFamily"] = self.instanceTypeFamily!
            }
            if self.memory != nil {
                map["Memory"] = self.memory!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Cores"] as? Int32 {
                self.cores = value
            }
            if let value = dict["InstanceFamilyLevel"] as? String {
                self.instanceFamilyLevel = value
            }
            if let value = dict["InstanceType"] as? String {
                self.instanceType = value
            }
            if let value = dict["InstanceTypeFamily"] as? String {
                self.instanceTypeFamily = value
            }
            if let value = dict["Memory"] as? Double {
                self.memory = value
            }
        }
    }
    public var patternTypes: [DescribePatternTypesResponseBody.PatternTypes]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.patternTypes != nil {
            var tmp : [Any] = []
            for k in self.patternTypes! {
                tmp.append(k.toMap())
            }
            map["PatternTypes"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PatternTypes"] as? [Any?] {
            var tmp : [DescribePatternTypesResponseBody.PatternTypes] = []
            for v in value {
                if v != nil {
                    var model = DescribePatternTypesResponseBody.PatternTypes()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.patternTypes = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribePatternTypesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePatternTypesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribePatternTypesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeRegionsRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AcceptLanguage"] as? String {
            self.acceptLanguage = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeRegionsResponseBody : Tea.TeaModel {
    public class Regions : Tea.TeaModel {
        public var classicUnavailable: Bool?

        public var localName: String?

        public var regionEndpoint: String?

        public var regionId: String?

        public var vpcUnavailable: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.classicUnavailable != nil {
                map["ClassicUnavailable"] = self.classicUnavailable!
            }
            if self.localName != nil {
                map["LocalName"] = self.localName!
            }
            if self.regionEndpoint != nil {
                map["RegionEndpoint"] = self.regionEndpoint!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.vpcUnavailable != nil {
                map["VpcUnavailable"] = self.vpcUnavailable!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ClassicUnavailable"] as? Bool {
                self.classicUnavailable = value
            }
            if let value = dict["LocalName"] as? String {
                self.localName = value
            }
            if let value = dict["RegionEndpoint"] as? String {
                self.regionEndpoint = value
            }
            if let value = dict["RegionId"] as? String {
                self.regionId = value
            }
            if let value = dict["VpcUnavailable"] as? Bool {
                self.vpcUnavailable = value
            }
        }
    }
    public var regions: [DescribeRegionsResponseBody.Regions]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regions != nil {
            var tmp : [Any] = []
            for k in self.regions! {
                tmp.append(k.toMap())
            }
            map["Regions"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Regions"] as? [Any?] {
            var tmp : [DescribeRegionsResponseBody.Regions] = []
            for v in value {
                if v != nil {
                    var model = DescribeRegionsResponseBody.Regions()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.regions = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeRegionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRegionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeRegionsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeScalingActivitiesRequest : Tea.TeaModel {
    public var instanceRefreshTaskId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var scalingActivityIds: [String]?

    public var scalingGroupId: String?

    public var statusCode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceRefreshTaskId != nil {
            map["InstanceRefreshTaskId"] = self.instanceRefreshTaskId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.scalingActivityIds != nil {
            map["ScalingActivityIds"] = self.scalingActivityIds!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        if self.statusCode != nil {
            map["StatusCode"] = self.statusCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceRefreshTaskId"] as? String {
            self.instanceRefreshTaskId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ScalingActivityIds"] as? [String] {
            self.scalingActivityIds = value
        }
        if let value = dict["ScalingGroupId"] as? String {
            self.scalingGroupId = value
        }
        if let value = dict["StatusCode"] as? String {
            self.statusCode = value
        }
    }
}

public class DescribeScalingActivitiesResponseBody : Tea.TeaModel {
    public class ScalingActivities : Tea.TeaModel {
        public class ErrorMessages : Tea.TeaModel {
            public var code: String?

            public var description_: String?

            public var failedInstanceIds: [String]?

            public var message: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.failedInstanceIds != nil {
                    map["FailedInstanceIds"] = self.failedInstanceIds!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Code"] as? String {
                    self.code = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["FailedInstanceIds"] as? [String] {
                    self.failedInstanceIds = value
                }
                if let value = dict["Message"] as? String {
                    self.message = value
                }
            }
        }
        public class LifecycleHookContext : Tea.TeaModel {
            public var disableLifecycleHook: Bool?

            public var ignoredLifecycleHookIds: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.disableLifecycleHook != nil {
                    map["DisableLifecycleHook"] = self.disableLifecycleHook!
                }
                if self.ignoredLifecycleHookIds != nil {
                    map["IgnoredLifecycleHookIds"] = self.ignoredLifecycleHookIds!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DisableLifecycleHook"] as? Bool {
                    self.disableLifecycleHook = value
                }
                if let value = dict["IgnoredLifecycleHookIds"] as? [String] {
                    self.ignoredLifecycleHookIds = value
                }
            }
        }
        public var activityMetadata: String?

        public var attachedCapacity: String?

        public var autoCreatedCapacity: String?

        public var cause: String?

        public var createdCapacity: Int32?

        public var createdInstances: [String]?

        public var description_: String?

        public var destroyedCapacity: Int32?

        public var destroyedInstances: [String]?

        public var detail: String?

        public var endTime: String?

        public var errorCode: String?

        public var errorMessage: String?

        public var errorMessages: [DescribeScalingActivitiesResponseBody.ScalingActivities.ErrorMessages]?

        public var instanceRefreshTaskId: String?

        public var lifecycleHookContext: DescribeScalingActivitiesResponseBody.ScalingActivities.LifecycleHookContext?

        public var progress: Int32?

        public var scalingActivityId: String?

        public var scalingGroupId: String?

        public var scalingInstanceNumber: Int32?

        public var startTime: String?

        public var startedCapacity: Int32?

        public var startedInstances: [String]?

        public var statusCode: String?

        public var statusMessage: String?

        public var stoppedCapacity: Int32?

        public var stoppedInstances: [String]?

        public var totalCapacity: String?

        public var triggerSourceId: String?

        public var triggerSourceType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.lifecycleHookContext?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.activityMetadata != nil {
                map["ActivityMetadata"] = self.activityMetadata!
            }
            if self.attachedCapacity != nil {
                map["AttachedCapacity"] = self.attachedCapacity!
            }
            if self.autoCreatedCapacity != nil {
                map["AutoCreatedCapacity"] = self.autoCreatedCapacity!
            }
            if self.cause != nil {
                map["Cause"] = self.cause!
            }
            if self.createdCapacity != nil {
                map["CreatedCapacity"] = self.createdCapacity!
            }
            if self.createdInstances != nil {
                map["CreatedInstances"] = self.createdInstances!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.destroyedCapacity != nil {
                map["DestroyedCapacity"] = self.destroyedCapacity!
            }
            if self.destroyedInstances != nil {
                map["DestroyedInstances"] = self.destroyedInstances!
            }
            if self.detail != nil {
                map["Detail"] = self.detail!
            }
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.errorCode != nil {
                map["ErrorCode"] = self.errorCode!
            }
            if self.errorMessage != nil {
                map["ErrorMessage"] = self.errorMessage!
            }
            if self.errorMessages != nil {
                var tmp : [Any] = []
                for k in self.errorMessages! {
                    tmp.append(k.toMap())
                }
                map["ErrorMessages"] = tmp
            }
            if self.instanceRefreshTaskId != nil {
                map["InstanceRefreshTaskId"] = self.instanceRefreshTaskId!
            }
            if self.lifecycleHookContext != nil {
                map["LifecycleHookContext"] = self.lifecycleHookContext?.toMap()
            }
            if self.progress != nil {
                map["Progress"] = self.progress!
            }
            if self.scalingActivityId != nil {
                map["ScalingActivityId"] = self.scalingActivityId!
            }
            if self.scalingGroupId != nil {
                map["ScalingGroupId"] = self.scalingGroupId!
            }
            if self.scalingInstanceNumber != nil {
                map["ScalingInstanceNumber"] = self.scalingInstanceNumber!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.startedCapacity != nil {
                map["StartedCapacity"] = self.startedCapacity!
            }
            if self.startedInstances != nil {
                map["StartedInstances"] = self.startedInstances!
            }
            if self.statusCode != nil {
                map["StatusCode"] = self.statusCode!
            }
            if self.statusMessage != nil {
                map["StatusMessage"] = self.statusMessage!
            }
            if self.stoppedCapacity != nil {
                map["StoppedCapacity"] = self.stoppedCapacity!
            }
            if self.stoppedInstances != nil {
                map["StoppedInstances"] = self.stoppedInstances!
            }
            if self.totalCapacity != nil {
                map["TotalCapacity"] = self.totalCapacity!
            }
            if self.triggerSourceId != nil {
                map["TriggerSourceId"] = self.triggerSourceId!
            }
            if self.triggerSourceType != nil {
                map["TriggerSourceType"] = self.triggerSourceType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ActivityMetadata"] as? String {
                self.activityMetadata = value
            }
            if let value = dict["AttachedCapacity"] as? String {
                self.attachedCapacity = value
            }
            if let value = dict["AutoCreatedCapacity"] as? String {
                self.autoCreatedCapacity = value
            }
            if let value = dict["Cause"] as? String {
                self.cause = value
            }
            if let value = dict["CreatedCapacity"] as? Int32 {
                self.createdCapacity = value
            }
            if let value = dict["CreatedInstances"] as? [String] {
                self.createdInstances = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["DestroyedCapacity"] as? Int32 {
                self.destroyedCapacity = value
            }
            if let value = dict["DestroyedInstances"] as? [String] {
                self.destroyedInstances = value
            }
            if let value = dict["Detail"] as? String {
                self.detail = value
            }
            if let value = dict["EndTime"] as? String {
                self.endTime = value
            }
            if let value = dict["ErrorCode"] as? String {
                self.errorCode = value
            }
            if let value = dict["ErrorMessage"] as? String {
                self.errorMessage = value
            }
            if let value = dict["ErrorMessages"] as? [Any?] {
                var tmp : [DescribeScalingActivitiesResponseBody.ScalingActivities.ErrorMessages] = []
                for v in value {
                    if v != nil {
                        var model = DescribeScalingActivitiesResponseBody.ScalingActivities.ErrorMessages()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.errorMessages = tmp
            }
            if let value = dict["InstanceRefreshTaskId"] as? String {
                self.instanceRefreshTaskId = value
            }
            if let value = dict["LifecycleHookContext"] as? [String: Any?] {
                var model = DescribeScalingActivitiesResponseBody.ScalingActivities.LifecycleHookContext()
                model.fromMap(value)
                self.lifecycleHookContext = model
            }
            if let value = dict["Progress"] as? Int32 {
                self.progress = value
            }
            if let value = dict["ScalingActivityId"] as? String {
                self.scalingActivityId = value
            }
            if let value = dict["ScalingGroupId"] as? String {
                self.scalingGroupId = value
            }
            if let value = dict["ScalingInstanceNumber"] as? Int32 {
                self.scalingInstanceNumber = value
            }
            if let value = dict["StartTime"] as? String {
                self.startTime = value
            }
            if let value = dict["StartedCapacity"] as? Int32 {
                self.startedCapacity = value
            }
            if let value = dict["StartedInstances"] as? [String] {
                self.startedInstances = value
            }
            if let value = dict["StatusCode"] as? String {
                self.statusCode = value
            }
            if let value = dict["StatusMessage"] as? String {
                self.statusMessage = value
            }
            if let value = dict["StoppedCapacity"] as? Int32 {
                self.stoppedCapacity = value
            }
            if let value = dict["StoppedInstances"] as? [String] {
                self.stoppedInstances = value
            }
            if let value = dict["TotalCapacity"] as? String {
                self.totalCapacity = value
            }
            if let value = dict["TriggerSourceId"] as? String {
                self.triggerSourceId = value
            }
            if let value = dict["TriggerSourceType"] as? String {
                self.triggerSourceType = value
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var scalingActivities: [DescribeScalingActivitiesResponseBody.ScalingActivities]?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingActivities != nil {
            var tmp : [Any] = []
            for k in self.scalingActivities! {
                tmp.append(k.toMap())
            }
            map["ScalingActivities"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ScalingActivities"] as? [Any?] {
            var tmp : [DescribeScalingActivitiesResponseBody.ScalingActivities] = []
            for v in value {
                if v != nil {
                    var model = DescribeScalingActivitiesResponseBody.ScalingActivities()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.scalingActivities = tmp
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeScalingActivitiesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeScalingActivitiesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeScalingActivitiesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeScalingActivityDetailRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var scalingActivityId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.scalingActivityId != nil {
            map["ScalingActivityId"] = self.scalingActivityId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ScalingActivityId"] as? String {
            self.scalingActivityId = value
        }
    }
}

public class DescribeScalingActivityDetailResponseBody : Tea.TeaModel {
    public var detail: String?

    public var requestId: String?

    public var scalingActivityId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.detail != nil {
            map["Detail"] = self.detail!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingActivityId != nil {
            map["ScalingActivityId"] = self.scalingActivityId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Detail"] as? String {
            self.detail = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ScalingActivityId"] as? String {
            self.scalingActivityId = value
        }
    }
}

public class DescribeScalingActivityDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeScalingActivityDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeScalingActivityDetailResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeScalingConfigurationsRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var scalingConfigurationIds: [String]?

    public var scalingConfigurationNames: [String]?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.scalingConfigurationIds != nil {
            map["ScalingConfigurationIds"] = self.scalingConfigurationIds!
        }
        if self.scalingConfigurationNames != nil {
            map["ScalingConfigurationNames"] = self.scalingConfigurationNames!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ScalingConfigurationIds"] as? [String] {
            self.scalingConfigurationIds = value
        }
        if let value = dict["ScalingConfigurationNames"] as? [String] {
            self.scalingConfigurationNames = value
        }
        if let value = dict["ScalingGroupId"] as? String {
            self.scalingGroupId = value
        }
    }
}

public class DescribeScalingConfigurationsResponseBody : Tea.TeaModel {
    public class ScalingConfigurations : Tea.TeaModel {
        public class CustomPriorities : Tea.TeaModel {
            public var instanceType: String?

            public var vswitchId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.instanceType != nil {
                    map["InstanceType"] = self.instanceType!
                }
                if self.vswitchId != nil {
                    map["VswitchId"] = self.vswitchId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["InstanceType"] as? String {
                    self.instanceType = value
                }
                if let value = dict["VswitchId"] as? String {
                    self.vswitchId = value
                }
            }
        }
        public class DataDisks : Tea.TeaModel {
            public var autoSnapshotPolicyId: String?

            public var burstingEnabled: Bool?

            public var categories: [String]?

            public var category: String?

            public var deleteWithInstance: Bool?

            public var description_: String?

            public var device: String?

            public var diskName: String?

            public var encrypted: String?

            public var KMSKeyId: String?

            public var performanceLevel: String?

            public var provisionedIops: Int64?

            public var size: Int32?

            public var snapshotId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.autoSnapshotPolicyId != nil {
                    map["AutoSnapshotPolicyId"] = self.autoSnapshotPolicyId!
                }
                if self.burstingEnabled != nil {
                    map["BurstingEnabled"] = self.burstingEnabled!
                }
                if self.categories != nil {
                    map["Categories"] = self.categories!
                }
                if self.category != nil {
                    map["Category"] = self.category!
                }
                if self.deleteWithInstance != nil {
                    map["DeleteWithInstance"] = self.deleteWithInstance!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.device != nil {
                    map["Device"] = self.device!
                }
                if self.diskName != nil {
                    map["DiskName"] = self.diskName!
                }
                if self.encrypted != nil {
                    map["Encrypted"] = self.encrypted!
                }
                if self.KMSKeyId != nil {
                    map["KMSKeyId"] = self.KMSKeyId!
                }
                if self.performanceLevel != nil {
                    map["PerformanceLevel"] = self.performanceLevel!
                }
                if self.provisionedIops != nil {
                    map["ProvisionedIops"] = self.provisionedIops!
                }
                if self.size != nil {
                    map["Size"] = self.size!
                }
                if self.snapshotId != nil {
                    map["SnapshotId"] = self.snapshotId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AutoSnapshotPolicyId"] as? String {
                    self.autoSnapshotPolicyId = value
                }
                if let value = dict["BurstingEnabled"] as? Bool {
                    self.burstingEnabled = value
                }
                if let value = dict["Categories"] as? [String] {
                    self.categories = value
                }
                if let value = dict["Category"] as? String {
                    self.category = value
                }
                if let value = dict["DeleteWithInstance"] as? Bool {
                    self.deleteWithInstance = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["Device"] as? String {
                    self.device = value
                }
                if let value = dict["DiskName"] as? String {
                    self.diskName = value
                }
                if let value = dict["Encrypted"] as? String {
                    self.encrypted = value
                }
                if let value = dict["KMSKeyId"] as? String {
                    self.KMSKeyId = value
                }
                if let value = dict["PerformanceLevel"] as? String {
                    self.performanceLevel = value
                }
                if let value = dict["ProvisionedIops"] as? Int64 {
                    self.provisionedIops = value
                }
                if let value = dict["Size"] as? Int32 {
                    self.size = value
                }
                if let value = dict["SnapshotId"] as? String {
                    self.snapshotId = value
                }
            }
        }
        public class InstancePatternInfos : Tea.TeaModel {
            public var architectures: [String]?

            public var burstablePerformance: String?

            public var cores: Int32?

            public var cpuArchitectures: [String]?

            public var excludedInstanceTypes: [String]?

            public var gpuSpecs: [String]?

            public var instanceCategories: [String]?

            public var instanceFamilyLevel: String?

            public var instanceTypeFamilies: [String]?

            public var maxPrice: Double?

            public var maximumCpuCoreCount: Int32?

            public var maximumGpuAmount: Int32?

            public var maximumMemorySize: Double?

            public var memory: Double?

            public var minimumBaselineCredit: Int32?

            public var minimumCpuCoreCount: Int32?

            public var minimumEniIpv6AddressQuantity: Int32?

            public var minimumEniPrivateIpAddressQuantity: Int32?

            public var minimumEniQuantity: Int32?

            public var minimumGpuAmount: Int32?

            public var minimumInitialCredit: Int32?

            public var minimumMemorySize: Double?

            public var physicalProcessorModels: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.architectures != nil {
                    map["Architectures"] = self.architectures!
                }
                if self.burstablePerformance != nil {
                    map["BurstablePerformance"] = self.burstablePerformance!
                }
                if self.cores != nil {
                    map["Cores"] = self.cores!
                }
                if self.cpuArchitectures != nil {
                    map["CpuArchitectures"] = self.cpuArchitectures!
                }
                if self.excludedInstanceTypes != nil {
                    map["ExcludedInstanceTypes"] = self.excludedInstanceTypes!
                }
                if self.gpuSpecs != nil {
                    map["GpuSpecs"] = self.gpuSpecs!
                }
                if self.instanceCategories != nil {
                    map["InstanceCategories"] = self.instanceCategories!
                }
                if self.instanceFamilyLevel != nil {
                    map["InstanceFamilyLevel"] = self.instanceFamilyLevel!
                }
                if self.instanceTypeFamilies != nil {
                    map["InstanceTypeFamilies"] = self.instanceTypeFamilies!
                }
                if self.maxPrice != nil {
                    map["MaxPrice"] = self.maxPrice!
                }
                if self.maximumCpuCoreCount != nil {
                    map["MaximumCpuCoreCount"] = self.maximumCpuCoreCount!
                }
                if self.maximumGpuAmount != nil {
                    map["MaximumGpuAmount"] = self.maximumGpuAmount!
                }
                if self.maximumMemorySize != nil {
                    map["MaximumMemorySize"] = self.maximumMemorySize!
                }
                if self.memory != nil {
                    map["Memory"] = self.memory!
                }
                if self.minimumBaselineCredit != nil {
                    map["MinimumBaselineCredit"] = self.minimumBaselineCredit!
                }
                if self.minimumCpuCoreCount != nil {
                    map["MinimumCpuCoreCount"] = self.minimumCpuCoreCount!
                }
                if self.minimumEniIpv6AddressQuantity != nil {
                    map["MinimumEniIpv6AddressQuantity"] = self.minimumEniIpv6AddressQuantity!
                }
                if self.minimumEniPrivateIpAddressQuantity != nil {
                    map["MinimumEniPrivateIpAddressQuantity"] = self.minimumEniPrivateIpAddressQuantity!
                }
                if self.minimumEniQuantity != nil {
                    map["MinimumEniQuantity"] = self.minimumEniQuantity!
                }
                if self.minimumGpuAmount != nil {
                    map["MinimumGpuAmount"] = self.minimumGpuAmount!
                }
                if self.minimumInitialCredit != nil {
                    map["MinimumInitialCredit"] = self.minimumInitialCredit!
                }
                if self.minimumMemorySize != nil {
                    map["MinimumMemorySize"] = self.minimumMemorySize!
                }
                if self.physicalProcessorModels != nil {
                    map["PhysicalProcessorModels"] = self.physicalProcessorModels!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Architectures"] as? [String] {
                    self.architectures = value
                }
                if let value = dict["BurstablePerformance"] as? String {
                    self.burstablePerformance = value
                }
                if let value = dict["Cores"] as? Int32 {
                    self.cores = value
                }
                if let value = dict["CpuArchitectures"] as? [String] {
                    self.cpuArchitectures = value
                }
                if let value = dict["ExcludedInstanceTypes"] as? [String] {
                    self.excludedInstanceTypes = value
                }
                if let value = dict["GpuSpecs"] as? [String] {
                    self.gpuSpecs = value
                }
                if let value = dict["InstanceCategories"] as? [String] {
                    self.instanceCategories = value
                }
                if let value = dict["InstanceFamilyLevel"] as? String {
                    self.instanceFamilyLevel = value
                }
                if let value = dict["InstanceTypeFamilies"] as? [String] {
                    self.instanceTypeFamilies = value
                }
                if let value = dict["MaxPrice"] as? Double {
                    self.maxPrice = value
                }
                if let value = dict["MaximumCpuCoreCount"] as? Int32 {
                    self.maximumCpuCoreCount = value
                }
                if let value = dict["MaximumGpuAmount"] as? Int32 {
                    self.maximumGpuAmount = value
                }
                if let value = dict["MaximumMemorySize"] as? Double {
                    self.maximumMemorySize = value
                }
                if let value = dict["Memory"] as? Double {
                    self.memory = value
                }
                if let value = dict["MinimumBaselineCredit"] as? Int32 {
                    self.minimumBaselineCredit = value
                }
                if let value = dict["MinimumCpuCoreCount"] as? Int32 {
                    self.minimumCpuCoreCount = value
                }
                if let value = dict["MinimumEniIpv6AddressQuantity"] as? Int32 {
                    self.minimumEniIpv6AddressQuantity = value
                }
                if let value = dict["MinimumEniPrivateIpAddressQuantity"] as? Int32 {
                    self.minimumEniPrivateIpAddressQuantity = value
                }
                if let value = dict["MinimumEniQuantity"] as? Int32 {
                    self.minimumEniQuantity = value
                }
                if let value = dict["MinimumGpuAmount"] as? Int32 {
                    self.minimumGpuAmount = value
                }
                if let value = dict["MinimumInitialCredit"] as? Int32 {
                    self.minimumInitialCredit = value
                }
                if let value = dict["MinimumMemorySize"] as? Double {
                    self.minimumMemorySize = value
                }
                if let value = dict["PhysicalProcessorModels"] as? [String] {
                    self.physicalProcessorModels = value
                }
            }
        }
        public class NetworkInterfaces : Tea.TeaModel {
            public var instanceType: String?

            public var ipv6AddressCount: Int32?

            public var networkInterfaceTrafficMode: String?

            public var securityGroupIds: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.instanceType != nil {
                    map["InstanceType"] = self.instanceType!
                }
                if self.ipv6AddressCount != nil {
                    map["Ipv6AddressCount"] = self.ipv6AddressCount!
                }
                if self.networkInterfaceTrafficMode != nil {
                    map["NetworkInterfaceTrafficMode"] = self.networkInterfaceTrafficMode!
                }
                if self.securityGroupIds != nil {
                    map["SecurityGroupIds"] = self.securityGroupIds!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["InstanceType"] as? String {
                    self.instanceType = value
                }
                if let value = dict["Ipv6AddressCount"] as? Int32 {
                    self.ipv6AddressCount = value
                }
                if let value = dict["NetworkInterfaceTrafficMode"] as? String {
                    self.networkInterfaceTrafficMode = value
                }
                if let value = dict["SecurityGroupIds"] as? [String] {
                    self.securityGroupIds = value
                }
            }
        }
        public class ResourcePoolOptions : Tea.TeaModel {
            public var privatePoolIds: [String]?

            public var strategy: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.privatePoolIds != nil {
                    map["PrivatePoolIds"] = self.privatePoolIds!
                }
                if self.strategy != nil {
                    map["Strategy"] = self.strategy!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["PrivatePoolIds"] as? [String] {
                    self.privatePoolIds = value
                }
                if let value = dict["Strategy"] as? String {
                    self.strategy = value
                }
            }
        }
        public class SchedulerOptions : Tea.TeaModel {
            public var managedPrivateSpaceId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.managedPrivateSpaceId != nil {
                    map["ManagedPrivateSpaceId"] = self.managedPrivateSpaceId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ManagedPrivateSpaceId"] as? String {
                    self.managedPrivateSpaceId = value
                }
            }
        }
        public class SecurityOptions : Tea.TeaModel {
            public var confidentialComputingMode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.confidentialComputingMode != nil {
                    map["ConfidentialComputingMode"] = self.confidentialComputingMode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ConfidentialComputingMode"] as? String {
                    self.confidentialComputingMode = value
                }
            }
        }
        public class SpotPriceLimits : Tea.TeaModel {
            public var instanceType: String?

            public var priceLimit: Double?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.instanceType != nil {
                    map["InstanceType"] = self.instanceType!
                }
                if self.priceLimit != nil {
                    map["PriceLimit"] = self.priceLimit!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["InstanceType"] as? String {
                    self.instanceType = value
                }
                if let value = dict["PriceLimit"] as? Double {
                    self.priceLimit = value
                }
            }
        }
        public class Tags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Key"] as? String {
                    self.key = value
                }
                if let value = dict["Value"] as? String {
                    self.value = value
                }
            }
        }
        public var affinity: String?

        public var cpu: Int32?

        public var creationTime: String?

        public var creditSpecification: String?

        public var customPriorities: [DescribeScalingConfigurationsResponseBody.ScalingConfigurations.CustomPriorities]?

        public var dataDisks: [DescribeScalingConfigurationsResponseBody.ScalingConfigurations.DataDisks]?

        public var dedicatedHostClusterId: String?

        public var dedicatedHostId: String?

        public var deletionProtection: Bool?

        public var deploymentSetId: String?

        public var hostName: String?

        public var hpcClusterId: String?

        public var httpEndpoint: String?

        public var httpTokens: String?

        public var imageFamily: String?

        public var imageId: String?

        public var imageName: String?

        public var imageOptionsLoginAsNonRoot: Bool?

        public var imageOwnerAlias: String?

        public var instanceDescription: String?

        public var instanceGeneration: String?

        public var instanceName: String?

        public var instancePatternInfos: [DescribeScalingConfigurationsResponseBody.ScalingConfigurations.InstancePatternInfos]?

        public var instanceType: String?

        public var instanceTypes: [String]?

        public var internetChargeType: String?

        public var internetMaxBandwidthIn: Int32?

        public var internetMaxBandwidthOut: Int32?

        public var ioOptimized: String?

        public var ipv6AddressCount: Int32?

        public var keyPairName: String?

        public var lifecycleState: String?

        public var loadBalancerWeight: Int32?

        public var memory: Int32?

        public var networkInterfaces: [DescribeScalingConfigurationsResponseBody.ScalingConfigurations.NetworkInterfaces]?

        public var passwordInherit: Bool?

        public var passwordSetted: Bool?

        public var privatePoolOptions_id: String?

        public var privatePoolOptions_matchCriteria: String?

        public var ramRoleName: String?

        public var resourceGroupId: String?

        public var resourcePoolOptions: DescribeScalingConfigurationsResponseBody.ScalingConfigurations.ResourcePoolOptions?

        public var scalingConfigurationId: String?

        public var scalingConfigurationName: String?

        public var scalingGroupId: String?

        public var schedulerOptions: DescribeScalingConfigurationsResponseBody.ScalingConfigurations.SchedulerOptions?

        public var securityEnhancementStrategy: String?

        public var securityGroupId: String?

        public var securityGroupIds: [String]?

        public var securityOptions: DescribeScalingConfigurationsResponseBody.ScalingConfigurations.SecurityOptions?

        public var spotDuration: Int32?

        public var spotInterruptionBehavior: String?

        public var spotPriceLimits: [DescribeScalingConfigurationsResponseBody.ScalingConfigurations.SpotPriceLimits]?

        public var spotStrategy: String?

        public var storageSetId: String?

        public var storageSetPartitionNumber: Int32?

        public var systemDiskAutoSnapshotPolicyId: String?

        public var systemDiskBurstingEnabled: Bool?

        public var systemDiskCategories: [String]?

        public var systemDiskCategory: String?

        public var systemDiskDescription: String?

        public var systemDiskEncryptAlgorithm: String?

        public var systemDiskEncrypted: Bool?

        public var systemDiskKMSKeyId: String?

        public var systemDiskName: String?

        public var systemDiskPerformanceLevel: String?

        public var systemDiskProvisionedIops: Int64?

        public var systemDiskSize: Int32?

        public var tags: [DescribeScalingConfigurationsResponseBody.ScalingConfigurations.Tags]?

        public var tenancy: String?

        public var userData: String?

        public var weightedCapacities: [Int32]?

        public var zoneId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.resourcePoolOptions?.validate()
            try self.schedulerOptions?.validate()
            try self.securityOptions?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.affinity != nil {
                map["Affinity"] = self.affinity!
            }
            if self.cpu != nil {
                map["Cpu"] = self.cpu!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.creditSpecification != nil {
                map["CreditSpecification"] = self.creditSpecification!
            }
            if self.customPriorities != nil {
                var tmp : [Any] = []
                for k in self.customPriorities! {
                    tmp.append(k.toMap())
                }
                map["CustomPriorities"] = tmp
            }
            if self.dataDisks != nil {
                var tmp : [Any] = []
                for k in self.dataDisks! {
                    tmp.append(k.toMap())
                }
                map["DataDisks"] = tmp
            }
            if self.dedicatedHostClusterId != nil {
                map["DedicatedHostClusterId"] = self.dedicatedHostClusterId!
            }
            if self.dedicatedHostId != nil {
                map["DedicatedHostId"] = self.dedicatedHostId!
            }
            if self.deletionProtection != nil {
                map["DeletionProtection"] = self.deletionProtection!
            }
            if self.deploymentSetId != nil {
                map["DeploymentSetId"] = self.deploymentSetId!
            }
            if self.hostName != nil {
                map["HostName"] = self.hostName!
            }
            if self.hpcClusterId != nil {
                map["HpcClusterId"] = self.hpcClusterId!
            }
            if self.httpEndpoint != nil {
                map["HttpEndpoint"] = self.httpEndpoint!
            }
            if self.httpTokens != nil {
                map["HttpTokens"] = self.httpTokens!
            }
            if self.imageFamily != nil {
                map["ImageFamily"] = self.imageFamily!
            }
            if self.imageId != nil {
                map["ImageId"] = self.imageId!
            }
            if self.imageName != nil {
                map["ImageName"] = self.imageName!
            }
            if self.imageOptionsLoginAsNonRoot != nil {
                map["ImageOptionsLoginAsNonRoot"] = self.imageOptionsLoginAsNonRoot!
            }
            if self.imageOwnerAlias != nil {
                map["ImageOwnerAlias"] = self.imageOwnerAlias!
            }
            if self.instanceDescription != nil {
                map["InstanceDescription"] = self.instanceDescription!
            }
            if self.instanceGeneration != nil {
                map["InstanceGeneration"] = self.instanceGeneration!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.instancePatternInfos != nil {
                var tmp : [Any] = []
                for k in self.instancePatternInfos! {
                    tmp.append(k.toMap())
                }
                map["InstancePatternInfos"] = tmp
            }
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.instanceTypes != nil {
                map["InstanceTypes"] = self.instanceTypes!
            }
            if self.internetChargeType != nil {
                map["InternetChargeType"] = self.internetChargeType!
            }
            if self.internetMaxBandwidthIn != nil {
                map["InternetMaxBandwidthIn"] = self.internetMaxBandwidthIn!
            }
            if self.internetMaxBandwidthOut != nil {
                map["InternetMaxBandwidthOut"] = self.internetMaxBandwidthOut!
            }
            if self.ioOptimized != nil {
                map["IoOptimized"] = self.ioOptimized!
            }
            if self.ipv6AddressCount != nil {
                map["Ipv6AddressCount"] = self.ipv6AddressCount!
            }
            if self.keyPairName != nil {
                map["KeyPairName"] = self.keyPairName!
            }
            if self.lifecycleState != nil {
                map["LifecycleState"] = self.lifecycleState!
            }
            if self.loadBalancerWeight != nil {
                map["LoadBalancerWeight"] = self.loadBalancerWeight!
            }
            if self.memory != nil {
                map["Memory"] = self.memory!
            }
            if self.networkInterfaces != nil {
                var tmp : [Any] = []
                for k in self.networkInterfaces! {
                    tmp.append(k.toMap())
                }
                map["NetworkInterfaces"] = tmp
            }
            if self.passwordInherit != nil {
                map["PasswordInherit"] = self.passwordInherit!
            }
            if self.passwordSetted != nil {
                map["PasswordSetted"] = self.passwordSetted!
            }
            if self.privatePoolOptions_id != nil {
                map["PrivatePoolOptions.Id"] = self.privatePoolOptions_id!
            }
            if self.privatePoolOptions_matchCriteria != nil {
                map["PrivatePoolOptions.MatchCriteria"] = self.privatePoolOptions_matchCriteria!
            }
            if self.ramRoleName != nil {
                map["RamRoleName"] = self.ramRoleName!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.resourcePoolOptions != nil {
                map["ResourcePoolOptions"] = self.resourcePoolOptions?.toMap()
            }
            if self.scalingConfigurationId != nil {
                map["ScalingConfigurationId"] = self.scalingConfigurationId!
            }
            if self.scalingConfigurationName != nil {
                map["ScalingConfigurationName"] = self.scalingConfigurationName!
            }
            if self.scalingGroupId != nil {
                map["ScalingGroupId"] = self.scalingGroupId!
            }
            if self.schedulerOptions != nil {
                map["SchedulerOptions"] = self.schedulerOptions?.toMap()
            }
            if self.securityEnhancementStrategy != nil {
                map["SecurityEnhancementStrategy"] = self.securityEnhancementStrategy!
            }
            if self.securityGroupId != nil {
                map["SecurityGroupId"] = self.securityGroupId!
            }
            if self.securityGroupIds != nil {
                map["SecurityGroupIds"] = self.securityGroupIds!
            }
            if self.securityOptions != nil {
                map["SecurityOptions"] = self.securityOptions?.toMap()
            }
            if self.spotDuration != nil {
                map["SpotDuration"] = self.spotDuration!
            }
            if self.spotInterruptionBehavior != nil {
                map["SpotInterruptionBehavior"] = self.spotInterruptionBehavior!
            }
            if self.spotPriceLimits != nil {
                var tmp : [Any] = []
                for k in self.spotPriceLimits! {
                    tmp.append(k.toMap())
                }
                map["SpotPriceLimits"] = tmp
            }
            if self.spotStrategy != nil {
                map["SpotStrategy"] = self.spotStrategy!
            }
            if self.storageSetId != nil {
                map["StorageSetId"] = self.storageSetId!
            }
            if self.storageSetPartitionNumber != nil {
                map["StorageSetPartitionNumber"] = self.storageSetPartitionNumber!
            }
            if self.systemDiskAutoSnapshotPolicyId != nil {
                map["SystemDiskAutoSnapshotPolicyId"] = self.systemDiskAutoSnapshotPolicyId!
            }
            if self.systemDiskBurstingEnabled != nil {
                map["SystemDiskBurstingEnabled"] = self.systemDiskBurstingEnabled!
            }
            if self.systemDiskCategories != nil {
                map["SystemDiskCategories"] = self.systemDiskCategories!
            }
            if self.systemDiskCategory != nil {
                map["SystemDiskCategory"] = self.systemDiskCategory!
            }
            if self.systemDiskDescription != nil {
                map["SystemDiskDescription"] = self.systemDiskDescription!
            }
            if self.systemDiskEncryptAlgorithm != nil {
                map["SystemDiskEncryptAlgorithm"] = self.systemDiskEncryptAlgorithm!
            }
            if self.systemDiskEncrypted != nil {
                map["SystemDiskEncrypted"] = self.systemDiskEncrypted!
            }
            if self.systemDiskKMSKeyId != nil {
                map["SystemDiskKMSKeyId"] = self.systemDiskKMSKeyId!
            }
            if self.systemDiskName != nil {
                map["SystemDiskName"] = self.systemDiskName!
            }
            if self.systemDiskPerformanceLevel != nil {
                map["SystemDiskPerformanceLevel"] = self.systemDiskPerformanceLevel!
            }
            if self.systemDiskProvisionedIops != nil {
                map["SystemDiskProvisionedIops"] = self.systemDiskProvisionedIops!
            }
            if self.systemDiskSize != nil {
                map["SystemDiskSize"] = self.systemDiskSize!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            if self.tenancy != nil {
                map["Tenancy"] = self.tenancy!
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            if self.weightedCapacities != nil {
                map["WeightedCapacities"] = self.weightedCapacities!
            }
            if self.zoneId != nil {
                map["ZoneId"] = self.zoneId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Affinity"] as? String {
                self.affinity = value
            }
            if let value = dict["Cpu"] as? Int32 {
                self.cpu = value
            }
            if let value = dict["CreationTime"] as? String {
                self.creationTime = value
            }
            if let value = dict["CreditSpecification"] as? String {
                self.creditSpecification = value
            }
            if let value = dict["CustomPriorities"] as? [Any?] {
                var tmp : [DescribeScalingConfigurationsResponseBody.ScalingConfigurations.CustomPriorities] = []
                for v in value {
                    if v != nil {
                        var model = DescribeScalingConfigurationsResponseBody.ScalingConfigurations.CustomPriorities()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.customPriorities = tmp
            }
            if let value = dict["DataDisks"] as? [Any?] {
                var tmp : [DescribeScalingConfigurationsResponseBody.ScalingConfigurations.DataDisks] = []
                for v in value {
                    if v != nil {
                        var model = DescribeScalingConfigurationsResponseBody.ScalingConfigurations.DataDisks()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.dataDisks = tmp
            }
            if let value = dict["DedicatedHostClusterId"] as? String {
                self.dedicatedHostClusterId = value
            }
            if let value = dict["DedicatedHostId"] as? String {
                self.dedicatedHostId = value
            }
            if let value = dict["DeletionProtection"] as? Bool {
                self.deletionProtection = value
            }
            if let value = dict["DeploymentSetId"] as? String {
                self.deploymentSetId = value
            }
            if let value = dict["HostName"] as? String {
                self.hostName = value
            }
            if let value = dict["HpcClusterId"] as? String {
                self.hpcClusterId = value
            }
            if let value = dict["HttpEndpoint"] as? String {
                self.httpEndpoint = value
            }
            if let value = dict["HttpTokens"] as? String {
                self.httpTokens = value
            }
            if let value = dict["ImageFamily"] as? String {
                self.imageFamily = value
            }
            if let value = dict["ImageId"] as? String {
                self.imageId = value
            }
            if let value = dict["ImageName"] as? String {
                self.imageName = value
            }
            if let value = dict["ImageOptionsLoginAsNonRoot"] as? Bool {
                self.imageOptionsLoginAsNonRoot = value
            }
            if let value = dict["ImageOwnerAlias"] as? String {
                self.imageOwnerAlias = value
            }
            if let value = dict["InstanceDescription"] as? String {
                self.instanceDescription = value
            }
            if let value = dict["InstanceGeneration"] as? String {
                self.instanceGeneration = value
            }
            if let value = dict["InstanceName"] as? String {
                self.instanceName = value
            }
            if let value = dict["InstancePatternInfos"] as? [Any?] {
                var tmp : [DescribeScalingConfigurationsResponseBody.ScalingConfigurations.InstancePatternInfos] = []
                for v in value {
                    if v != nil {
                        var model = DescribeScalingConfigurationsResponseBody.ScalingConfigurations.InstancePatternInfos()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.instancePatternInfos = tmp
            }
            if let value = dict["InstanceType"] as? String {
                self.instanceType = value
            }
            if let value = dict["InstanceTypes"] as? [String] {
                self.instanceTypes = value
            }
            if let value = dict["InternetChargeType"] as? String {
                self.internetChargeType = value
            }
            if let value = dict["InternetMaxBandwidthIn"] as? Int32 {
                self.internetMaxBandwidthIn = value
            }
            if let value = dict["InternetMaxBandwidthOut"] as? Int32 {
                self.internetMaxBandwidthOut = value
            }
            if let value = dict["IoOptimized"] as? String {
                self.ioOptimized = value
            }
            if let value = dict["Ipv6AddressCount"] as? Int32 {
                self.ipv6AddressCount = value
            }
            if let value = dict["KeyPairName"] as? String {
                self.keyPairName = value
            }
            if let value = dict["LifecycleState"] as? String {
                self.lifecycleState = value
            }
            if let value = dict["LoadBalancerWeight"] as? Int32 {
                self.loadBalancerWeight = value
            }
            if let value = dict["Memory"] as? Int32 {
                self.memory = value
            }
            if let value = dict["NetworkInterfaces"] as? [Any?] {
                var tmp : [DescribeScalingConfigurationsResponseBody.ScalingConfigurations.NetworkInterfaces] = []
                for v in value {
                    if v != nil {
                        var model = DescribeScalingConfigurationsResponseBody.ScalingConfigurations.NetworkInterfaces()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.networkInterfaces = tmp
            }
            if let value = dict["PasswordInherit"] as? Bool {
                self.passwordInherit = value
            }
            if let value = dict["PasswordSetted"] as? Bool {
                self.passwordSetted = value
            }
            if let value = dict["PrivatePoolOptions.Id"] as? String {
                self.privatePoolOptions_id = value
            }
            if let value = dict["PrivatePoolOptions.MatchCriteria"] as? String {
                self.privatePoolOptions_matchCriteria = value
            }
            if let value = dict["RamRoleName"] as? String {
                self.ramRoleName = value
            }
            if let value = dict["ResourceGroupId"] as? String {
                self.resourceGroupId = value
            }
            if let value = dict["ResourcePoolOptions"] as? [String: Any?] {
                var model = DescribeScalingConfigurationsResponseBody.ScalingConfigurations.ResourcePoolOptions()
                model.fromMap(value)
                self.resourcePoolOptions = model
            }
            if let value = dict["ScalingConfigurationId"] as? String {
                self.scalingConfigurationId = value
            }
            if let value = dict["ScalingConfigurationName"] as? String {
                self.scalingConfigurationName = value
            }
            if let value = dict["ScalingGroupId"] as? String {
                self.scalingGroupId = value
            }
            if let value = dict["SchedulerOptions"] as? [String: Any?] {
                var model = DescribeScalingConfigurationsResponseBody.ScalingConfigurations.SchedulerOptions()
                model.fromMap(value)
                self.schedulerOptions = model
            }
            if let value = dict["SecurityEnhancementStrategy"] as? String {
                self.securityEnhancementStrategy = value
            }
            if let value = dict["SecurityGroupId"] as? String {
                self.securityGroupId = value
            }
            if let value = dict["SecurityGroupIds"] as? [String] {
                self.securityGroupIds = value
            }
            if let value = dict["SecurityOptions"] as? [String: Any?] {
                var model = DescribeScalingConfigurationsResponseBody.ScalingConfigurations.SecurityOptions()
                model.fromMap(value)
                self.securityOptions = model
            }
            if let value = dict["SpotDuration"] as? Int32 {
                self.spotDuration = value
            }
            if let value = dict["SpotInterruptionBehavior"] as? String {
                self.spotInterruptionBehavior = value
            }
            if let value = dict["SpotPriceLimits"] as? [Any?] {
                var tmp : [DescribeScalingConfigurationsResponseBody.ScalingConfigurations.SpotPriceLimits] = []
                for v in value {
                    if v != nil {
                        var model = DescribeScalingConfigurationsResponseBody.ScalingConfigurations.SpotPriceLimits()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.spotPriceLimits = tmp
            }
            if let value = dict["SpotStrategy"] as? String {
                self.spotStrategy = value
            }
            if let value = dict["StorageSetId"] as? String {
                self.storageSetId = value
            }
            if let value = dict["StorageSetPartitionNumber"] as? Int32 {
                self.storageSetPartitionNumber = value
            }
            if let value = dict["SystemDiskAutoSnapshotPolicyId"] as? String {
                self.systemDiskAutoSnapshotPolicyId = value
            }
            if let value = dict["SystemDiskBurstingEnabled"] as? Bool {
                self.systemDiskBurstingEnabled = value
            }
            if let value = dict["SystemDiskCategories"] as? [String] {
                self.systemDiskCategories = value
            }
            if let value = dict["SystemDiskCategory"] as? String {
                self.systemDiskCategory = value
            }
            if let value = dict["SystemDiskDescription"] as? String {
                self.systemDiskDescription = value
            }
            if let value = dict["SystemDiskEncryptAlgorithm"] as? String {
                self.systemDiskEncryptAlgorithm = value
            }
            if let value = dict["SystemDiskEncrypted"] as? Bool {
                self.systemDiskEncrypted = value
            }
            if let value = dict["SystemDiskKMSKeyId"] as? String {
                self.systemDiskKMSKeyId = value
            }
            if let value = dict["SystemDiskName"] as? String {
                self.systemDiskName = value
            }
            if let value = dict["SystemDiskPerformanceLevel"] as? String {
                self.systemDiskPerformanceLevel = value
            }
            if let value = dict["SystemDiskProvisionedIops"] as? Int64 {
                self.systemDiskProvisionedIops = value
            }
            if let value = dict["SystemDiskSize"] as? Int32 {
                self.systemDiskSize = value
            }
            if let value = dict["Tags"] as? [Any?] {
                var tmp : [DescribeScalingConfigurationsResponseBody.ScalingConfigurations.Tags] = []
                for v in value {
                    if v != nil {
                        var model = DescribeScalingConfigurationsResponseBody.ScalingConfigurations.Tags()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tags = tmp
            }
            if let value = dict["Tenancy"] as? String {
                self.tenancy = value
            }
            if let value = dict["UserData"] as? String {
                self.userData = value
            }
            if let value = dict["WeightedCapacities"] as? [Int32] {
                self.weightedCapacities = value
            }
            if let value = dict["ZoneId"] as? String {
                self.zoneId = value
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var scalingConfigurations: [DescribeScalingConfigurationsResponseBody.ScalingConfigurations]?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingConfigurations != nil {
            var tmp : [Any] = []
            for k in self.scalingConfigurations! {
                tmp.append(k.toMap())
            }
            map["ScalingConfigurations"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ScalingConfigurations"] as? [Any?] {
            var tmp : [DescribeScalingConfigurationsResponseBody.ScalingConfigurations] = []
            for v in value {
                if v != nil {
                    var model = DescribeScalingConfigurationsResponseBody.ScalingConfigurations()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.scalingConfigurations = tmp
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeScalingConfigurationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeScalingConfigurationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeScalingConfigurationsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeScalingGroupDetailRequest : Tea.TeaModel {
    public var outputFormat: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.outputFormat != nil {
            map["OutputFormat"] = self.outputFormat!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OutputFormat"] as? String {
            self.outputFormat = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ScalingGroupId"] as? String {
            self.scalingGroupId = value
        }
    }
}

public class DescribeScalingGroupDetailResponseBody : Tea.TeaModel {
    public class ScalingGroup : Tea.TeaModel {
        public class AlbServerGroups : Tea.TeaModel {
            public var albServerGroupId: String?

            public var port: Int32?

            public var weight: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.albServerGroupId != nil {
                    map["AlbServerGroupId"] = self.albServerGroupId!
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.weight != nil {
                    map["Weight"] = self.weight!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AlbServerGroupId"] as? String {
                    self.albServerGroupId = value
                }
                if let value = dict["Port"] as? Int32 {
                    self.port = value
                }
                if let value = dict["Weight"] as? Int32 {
                    self.weight = value
                }
            }
        }
        public class LaunchTemplateOverrides : Tea.TeaModel {
            public var instanceType: String?

            public var spotPriceLimit: Double?

            public var weightedCapacity: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.instanceType != nil {
                    map["InstanceType"] = self.instanceType!
                }
                if self.spotPriceLimit != nil {
                    map["SpotPriceLimit"] = self.spotPriceLimit!
                }
                if self.weightedCapacity != nil {
                    map["WeightedCapacity"] = self.weightedCapacity!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["InstanceType"] as? String {
                    self.instanceType = value
                }
                if let value = dict["SpotPriceLimit"] as? Double {
                    self.spotPriceLimit = value
                }
                if let value = dict["WeightedCapacity"] as? Int32 {
                    self.weightedCapacity = value
                }
            }
        }
        public class LoadBalancerConfigs : Tea.TeaModel {
            public var loadBalancerId: String?

            public var weight: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.loadBalancerId != nil {
                    map["LoadBalancerId"] = self.loadBalancerId!
                }
                if self.weight != nil {
                    map["Weight"] = self.weight!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["LoadBalancerId"] as? String {
                    self.loadBalancerId = value
                }
                if let value = dict["Weight"] as? Int32 {
                    self.weight = value
                }
            }
        }
        public class ServerGroups : Tea.TeaModel {
            public var port: Int32?

            public var serverGroupId: String?

            public var type: String?

            public var weight: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.serverGroupId != nil {
                    map["ServerGroupId"] = self.serverGroupId!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.weight != nil {
                    map["Weight"] = self.weight!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Port"] as? Int32 {
                    self.port = value
                }
                if let value = dict["ServerGroupId"] as? String {
                    self.serverGroupId = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
                if let value = dict["Weight"] as? Int32 {
                    self.weight = value
                }
            }
        }
        public class Tags : Tea.TeaModel {
            public var propagate: Bool?

            public var tagKey: String?

            public var tagValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.propagate != nil {
                    map["Propagate"] = self.propagate!
                }
                if self.tagKey != nil {
                    map["TagKey"] = self.tagKey!
                }
                if self.tagValue != nil {
                    map["TagValue"] = self.tagValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Propagate"] as? Bool {
                    self.propagate = value
                }
                if let value = dict["TagKey"] as? String {
                    self.tagKey = value
                }
                if let value = dict["TagValue"] as? String {
                    self.tagValue = value
                }
            }
        }
        public class VServerGroups : Tea.TeaModel {
            public class VServerGroupAttributes : Tea.TeaModel {
                public var port: Int32?

                public var VServerGroupId: String?

                public var weight: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.port != nil {
                        map["Port"] = self.port!
                    }
                    if self.VServerGroupId != nil {
                        map["VServerGroupId"] = self.VServerGroupId!
                    }
                    if self.weight != nil {
                        map["Weight"] = self.weight!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Port"] as? Int32 {
                        self.port = value
                    }
                    if let value = dict["VServerGroupId"] as? String {
                        self.VServerGroupId = value
                    }
                    if let value = dict["Weight"] as? Int32 {
                        self.weight = value
                    }
                }
            }
            public var loadBalancerId: String?

            public var VServerGroupAttributes: [DescribeScalingGroupDetailResponseBody.ScalingGroup.VServerGroups.VServerGroupAttributes]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.loadBalancerId != nil {
                    map["LoadBalancerId"] = self.loadBalancerId!
                }
                if self.VServerGroupAttributes != nil {
                    var tmp : [Any] = []
                    for k in self.VServerGroupAttributes! {
                        tmp.append(k.toMap())
                    }
                    map["VServerGroupAttributes"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["LoadBalancerId"] as? String {
                    self.loadBalancerId = value
                }
                if let value = dict["VServerGroupAttributes"] as? [Any?] {
                    var tmp : [DescribeScalingGroupDetailResponseBody.ScalingGroup.VServerGroups.VServerGroupAttributes] = []
                    for v in value {
                        if v != nil {
                            var model = DescribeScalingGroupDetailResponseBody.ScalingGroup.VServerGroups.VServerGroupAttributes()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.VServerGroupAttributes = tmp
                }
            }
        }
        public var activeCapacity: Int32?

        public var activeScalingConfigurationId: String?

        public var albServerGroups: [DescribeScalingGroupDetailResponseBody.ScalingGroup.AlbServerGroups]?

        public var allocationStrategy: String?

        public var azBalance: Bool?

        public var compensateWithOnDemand: Bool?

        public var creationTime: String?

        public var currentHostName: String?

        public var customPolicyARN: String?

        public var DBInstanceIds: [String]?

        public var defaultCooldown: Int32?

        public var desiredCapacity: Int32?

        public var enableDesiredCapacity: Bool?

        public var groupDeletionProtection: Bool?

        public var groupType: String?

        public var healthCheckType: String?

        public var healthCheckTypes: [String]?

        public var initCapacity: Int32?

        public var isElasticStrengthInAlarm: Bool?

        public var launchTemplateId: String?

        public var launchTemplateOverrides: [DescribeScalingGroupDetailResponseBody.ScalingGroup.LaunchTemplateOverrides]?

        public var launchTemplateVersion: String?

        public var lifecycleState: String?

        public var loadBalancerConfigs: [DescribeScalingGroupDetailResponseBody.ScalingGroup.LoadBalancerConfigs]?

        public var loadBalancerIds: [String]?

        public var maxInstanceLifetime: Int32?

        public var maxSize: Int32?

        public var minSize: Int32?

        public var modificationTime: String?

        public var monitorGroupId: String?

        public var multiAZPolicy: String?

        public var onDemandBaseCapacity: Int32?

        public var onDemandPercentageAboveBaseCapacity: Int32?

        public var pendingCapacity: Int32?

        public var pendingWaitCapacity: Int32?

        public var protectedCapacity: Int32?

        public var regionId: String?

        public var removalPolicies: [String]?

        public var removingCapacity: Int32?

        public var removingWaitCapacity: Int32?

        public var resourceGroupId: String?

        public var scalingGroupId: String?

        public var scalingGroupName: String?

        public var scalingPolicy: String?

        public var serverGroups: [DescribeScalingGroupDetailResponseBody.ScalingGroup.ServerGroups]?

        public var spotAllocationStrategy: String?

        public var spotInstancePools: Int32?

        public var spotInstanceRemedy: Bool?

        public var standbyCapacity: Int32?

        public var stoppedCapacity: Int32?

        public var suspendedProcesses: [String]?

        public var systemSuspended: Bool?

        public var tags: [DescribeScalingGroupDetailResponseBody.ScalingGroup.Tags]?

        public var totalCapacity: Int32?

        public var totalInstanceCount: Int32?

        public var VServerGroups: [DescribeScalingGroupDetailResponseBody.ScalingGroup.VServerGroups]?

        public var vSwitchId: String?

        public var vSwitchIds: [String]?

        public var vpcId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.activeCapacity != nil {
                map["ActiveCapacity"] = self.activeCapacity!
            }
            if self.activeScalingConfigurationId != nil {
                map["ActiveScalingConfigurationId"] = self.activeScalingConfigurationId!
            }
            if self.albServerGroups != nil {
                var tmp : [Any] = []
                for k in self.albServerGroups! {
                    tmp.append(k.toMap())
                }
                map["AlbServerGroups"] = tmp
            }
            if self.allocationStrategy != nil {
                map["AllocationStrategy"] = self.allocationStrategy!
            }
            if self.azBalance != nil {
                map["AzBalance"] = self.azBalance!
            }
            if self.compensateWithOnDemand != nil {
                map["CompensateWithOnDemand"] = self.compensateWithOnDemand!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.currentHostName != nil {
                map["CurrentHostName"] = self.currentHostName!
            }
            if self.customPolicyARN != nil {
                map["CustomPolicyARN"] = self.customPolicyARN!
            }
            if self.DBInstanceIds != nil {
                map["DBInstanceIds"] = self.DBInstanceIds!
            }
            if self.defaultCooldown != nil {
                map["DefaultCooldown"] = self.defaultCooldown!
            }
            if self.desiredCapacity != nil {
                map["DesiredCapacity"] = self.desiredCapacity!
            }
            if self.enableDesiredCapacity != nil {
                map["EnableDesiredCapacity"] = self.enableDesiredCapacity!
            }
            if self.groupDeletionProtection != nil {
                map["GroupDeletionProtection"] = self.groupDeletionProtection!
            }
            if self.groupType != nil {
                map["GroupType"] = self.groupType!
            }
            if self.healthCheckType != nil {
                map["HealthCheckType"] = self.healthCheckType!
            }
            if self.healthCheckTypes != nil {
                map["HealthCheckTypes"] = self.healthCheckTypes!
            }
            if self.initCapacity != nil {
                map["InitCapacity"] = self.initCapacity!
            }
            if self.isElasticStrengthInAlarm != nil {
                map["IsElasticStrengthInAlarm"] = self.isElasticStrengthInAlarm!
            }
            if self.launchTemplateId != nil {
                map["LaunchTemplateId"] = self.launchTemplateId!
            }
            if self.launchTemplateOverrides != nil {
                var tmp : [Any] = []
                for k in self.launchTemplateOverrides! {
                    tmp.append(k.toMap())
                }
                map["LaunchTemplateOverrides"] = tmp
            }
            if self.launchTemplateVersion != nil {
                map["LaunchTemplateVersion"] = self.launchTemplateVersion!
            }
            if self.lifecycleState != nil {
                map["LifecycleState"] = self.lifecycleState!
            }
            if self.loadBalancerConfigs != nil {
                var tmp : [Any] = []
                for k in self.loadBalancerConfigs! {
                    tmp.append(k.toMap())
                }
                map["LoadBalancerConfigs"] = tmp
            }
            if self.loadBalancerIds != nil {
                map["LoadBalancerIds"] = self.loadBalancerIds!
            }
            if self.maxInstanceLifetime != nil {
                map["MaxInstanceLifetime"] = self.maxInstanceLifetime!
            }
            if self.maxSize != nil {
                map["MaxSize"] = self.maxSize!
            }
            if self.minSize != nil {
                map["MinSize"] = self.minSize!
            }
            if self.modificationTime != nil {
                map["ModificationTime"] = self.modificationTime!
            }
            if self.monitorGroupId != nil {
                map["MonitorGroupId"] = self.monitorGroupId!
            }
            if self.multiAZPolicy != nil {
                map["MultiAZPolicy"] = self.multiAZPolicy!
            }
            if self.onDemandBaseCapacity != nil {
                map["OnDemandBaseCapacity"] = self.onDemandBaseCapacity!
            }
            if self.onDemandPercentageAboveBaseCapacity != nil {
                map["OnDemandPercentageAboveBaseCapacity"] = self.onDemandPercentageAboveBaseCapacity!
            }
            if self.pendingCapacity != nil {
                map["PendingCapacity"] = self.pendingCapacity!
            }
            if self.pendingWaitCapacity != nil {
                map["PendingWaitCapacity"] = self.pendingWaitCapacity!
            }
            if self.protectedCapacity != nil {
                map["ProtectedCapacity"] = self.protectedCapacity!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.removalPolicies != nil {
                map["RemovalPolicies"] = self.removalPolicies!
            }
            if self.removingCapacity != nil {
                map["RemovingCapacity"] = self.removingCapacity!
            }
            if self.removingWaitCapacity != nil {
                map["RemovingWaitCapacity"] = self.removingWaitCapacity!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.scalingGroupId != nil {
                map["ScalingGroupId"] = self.scalingGroupId!
            }
            if self.scalingGroupName != nil {
                map["ScalingGroupName"] = self.scalingGroupName!
            }
            if self.scalingPolicy != nil {
                map["ScalingPolicy"] = self.scalingPolicy!
            }
            if self.serverGroups != nil {
                var tmp : [Any] = []
                for k in self.serverGroups! {
                    tmp.append(k.toMap())
                }
                map["ServerGroups"] = tmp
            }
            if self.spotAllocationStrategy != nil {
                map["SpotAllocationStrategy"] = self.spotAllocationStrategy!
            }
            if self.spotInstancePools != nil {
                map["SpotInstancePools"] = self.spotInstancePools!
            }
            if self.spotInstanceRemedy != nil {
                map["SpotInstanceRemedy"] = self.spotInstanceRemedy!
            }
            if self.standbyCapacity != nil {
                map["StandbyCapacity"] = self.standbyCapacity!
            }
            if self.stoppedCapacity != nil {
                map["StoppedCapacity"] = self.stoppedCapacity!
            }
            if self.suspendedProcesses != nil {
                map["SuspendedProcesses"] = self.suspendedProcesses!
            }
            if self.systemSuspended != nil {
                map["SystemSuspended"] = self.systemSuspended!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            if self.totalCapacity != nil {
                map["TotalCapacity"] = self.totalCapacity!
            }
            if self.totalInstanceCount != nil {
                map["TotalInstanceCount"] = self.totalInstanceCount!
            }
            if self.VServerGroups != nil {
                var tmp : [Any] = []
                for k in self.VServerGroups! {
                    tmp.append(k.toMap())
                }
                map["VServerGroups"] = tmp
            }
            if self.vSwitchId != nil {
                map["VSwitchId"] = self.vSwitchId!
            }
            if self.vSwitchIds != nil {
                map["VSwitchIds"] = self.vSwitchIds!
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ActiveCapacity"] as? Int32 {
                self.activeCapacity = value
            }
            if let value = dict["ActiveScalingConfigurationId"] as? String {
                self.activeScalingConfigurationId = value
            }
            if let value = dict["AlbServerGroups"] as? [Any?] {
                var tmp : [DescribeScalingGroupDetailResponseBody.ScalingGroup.AlbServerGroups] = []
                for v in value {
                    if v != nil {
                        var model = DescribeScalingGroupDetailResponseBody.ScalingGroup.AlbServerGroups()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.albServerGroups = tmp
            }
            if let value = dict["AllocationStrategy"] as? String {
                self.allocationStrategy = value
            }
            if let value = dict["AzBalance"] as? Bool {
                self.azBalance = value
            }
            if let value = dict["CompensateWithOnDemand"] as? Bool {
                self.compensateWithOnDemand = value
            }
            if let value = dict["CreationTime"] as? String {
                self.creationTime = value
            }
            if let value = dict["CurrentHostName"] as? String {
                self.currentHostName = value
            }
            if let value = dict["CustomPolicyARN"] as? String {
                self.customPolicyARN = value
            }
            if let value = dict["DBInstanceIds"] as? [String] {
                self.DBInstanceIds = value
            }
            if let value = dict["DefaultCooldown"] as? Int32 {
                self.defaultCooldown = value
            }
            if let value = dict["DesiredCapacity"] as? Int32 {
                self.desiredCapacity = value
            }
            if let value = dict["EnableDesiredCapacity"] as? Bool {
                self.enableDesiredCapacity = value
            }
            if let value = dict["GroupDeletionProtection"] as? Bool {
                self.groupDeletionProtection = value
            }
            if let value = dict["GroupType"] as? String {
                self.groupType = value
            }
            if let value = dict["HealthCheckType"] as? String {
                self.healthCheckType = value
            }
            if let value = dict["HealthCheckTypes"] as? [String] {
                self.healthCheckTypes = value
            }
            if let value = dict["InitCapacity"] as? Int32 {
                self.initCapacity = value
            }
            if let value = dict["IsElasticStrengthInAlarm"] as? Bool {
                self.isElasticStrengthInAlarm = value
            }
            if let value = dict["LaunchTemplateId"] as? String {
                self.launchTemplateId = value
            }
            if let value = dict["LaunchTemplateOverrides"] as? [Any?] {
                var tmp : [DescribeScalingGroupDetailResponseBody.ScalingGroup.LaunchTemplateOverrides] = []
                for v in value {
                    if v != nil {
                        var model = DescribeScalingGroupDetailResponseBody.ScalingGroup.LaunchTemplateOverrides()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.launchTemplateOverrides = tmp
            }
            if let value = dict["LaunchTemplateVersion"] as? String {
                self.launchTemplateVersion = value
            }
            if let value = dict["LifecycleState"] as? String {
                self.lifecycleState = value
            }
            if let value = dict["LoadBalancerConfigs"] as? [Any?] {
                var tmp : [DescribeScalingGroupDetailResponseBody.ScalingGroup.LoadBalancerConfigs] = []
                for v in value {
                    if v != nil {
                        var model = DescribeScalingGroupDetailResponseBody.ScalingGroup.LoadBalancerConfigs()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.loadBalancerConfigs = tmp
            }
            if let value = dict["LoadBalancerIds"] as? [String] {
                self.loadBalancerIds = value
            }
            if let value = dict["MaxInstanceLifetime"] as? Int32 {
                self.maxInstanceLifetime = value
            }
            if let value = dict["MaxSize"] as? Int32 {
                self.maxSize = value
            }
            if let value = dict["MinSize"] as? Int32 {
                self.minSize = value
            }
            if let value = dict["ModificationTime"] as? String {
                self.modificationTime = value
            }
            if let value = dict["MonitorGroupId"] as? String {
                self.monitorGroupId = value
            }
            if let value = dict["MultiAZPolicy"] as? String {
                self.multiAZPolicy = value
            }
            if let value = dict["OnDemandBaseCapacity"] as? Int32 {
                self.onDemandBaseCapacity = value
            }
            if let value = dict["OnDemandPercentageAboveBaseCapacity"] as? Int32 {
                self.onDemandPercentageAboveBaseCapacity = value
            }
            if let value = dict["PendingCapacity"] as? Int32 {
                self.pendingCapacity = value
            }
            if let value = dict["PendingWaitCapacity"] as? Int32 {
                self.pendingWaitCapacity = value
            }
            if let value = dict["ProtectedCapacity"] as? Int32 {
                self.protectedCapacity = value
            }
            if let value = dict["RegionId"] as? String {
                self.regionId = value
            }
            if let value = dict["RemovalPolicies"] as? [String] {
                self.removalPolicies = value
            }
            if let value = dict["RemovingCapacity"] as? Int32 {
                self.removingCapacity = value
            }
            if let value = dict["RemovingWaitCapacity"] as? Int32 {
                self.removingWaitCapacity = value
            }
            if let value = dict["ResourceGroupId"] as? String {
                self.resourceGroupId = value
            }
            if let value = dict["ScalingGroupId"] as? String {
                self.scalingGroupId = value
            }
            if let value = dict["ScalingGroupName"] as? String {
                self.scalingGroupName = value
            }
            if let value = dict["ScalingPolicy"] as? String {
                self.scalingPolicy = value
            }
            if let value = dict["ServerGroups"] as? [Any?] {
                var tmp : [DescribeScalingGroupDetailResponseBody.ScalingGroup.ServerGroups] = []
                for v in value {
                    if v != nil {
                        var model = DescribeScalingGroupDetailResponseBody.ScalingGroup.ServerGroups()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.serverGroups = tmp
            }
            if let value = dict["SpotAllocationStrategy"] as? String {
                self.spotAllocationStrategy = value
            }
            if let value = dict["SpotInstancePools"] as? Int32 {
                self.spotInstancePools = value
            }
            if let value = dict["SpotInstanceRemedy"] as? Bool {
                self.spotInstanceRemedy = value
            }
            if let value = dict["StandbyCapacity"] as? Int32 {
                self.standbyCapacity = value
            }
            if let value = dict["StoppedCapacity"] as? Int32 {
                self.stoppedCapacity = value
            }
            if let value = dict["SuspendedProcesses"] as? [String] {
                self.suspendedProcesses = value
            }
            if let value = dict["SystemSuspended"] as? Bool {
                self.systemSuspended = value
            }
            if let value = dict["Tags"] as? [Any?] {
                var tmp : [DescribeScalingGroupDetailResponseBody.ScalingGroup.Tags] = []
                for v in value {
                    if v != nil {
                        var model = DescribeScalingGroupDetailResponseBody.ScalingGroup.Tags()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tags = tmp
            }
            if let value = dict["TotalCapacity"] as? Int32 {
                self.totalCapacity = value
            }
            if let value = dict["TotalInstanceCount"] as? Int32 {
                self.totalInstanceCount = value
            }
            if let value = dict["VServerGroups"] as? [Any?] {
                var tmp : [DescribeScalingGroupDetailResponseBody.ScalingGroup.VServerGroups] = []
                for v in value {
                    if v != nil {
                        var model = DescribeScalingGroupDetailResponseBody.ScalingGroup.VServerGroups()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.VServerGroups = tmp
            }
            if let value = dict["VSwitchId"] as? String {
                self.vSwitchId = value
            }
            if let value = dict["VSwitchIds"] as? [String] {
                self.vSwitchIds = value
            }
            if let value = dict["VpcId"] as? String {
                self.vpcId = value
            }
        }
    }
    public var output: String?

    public var requestId: String?

    public var scalingGroup: DescribeScalingGroupDetailResponseBody.ScalingGroup?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.scalingGroup?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.output != nil {
            map["Output"] = self.output!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingGroup != nil {
            map["ScalingGroup"] = self.scalingGroup?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Output"] as? String {
            self.output = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ScalingGroup"] as? [String: Any?] {
            var model = DescribeScalingGroupDetailResponseBody.ScalingGroup()
            model.fromMap(value)
            self.scalingGroup = model
        }
    }
}

public class DescribeScalingGroupDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeScalingGroupDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeScalingGroupDetailResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeScalingGroupDiagnoseDetailsRequest : Tea.TeaModel {
    public var regionId: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ScalingGroupId"] as? String {
            self.scalingGroupId = value
        }
    }
}

public class DescribeScalingGroupDiagnoseDetailsResponseBody : Tea.TeaModel {
    public class Details : Tea.TeaModel {
        public var diagnoseType: String?

        public var errorCode: String?

        public var resourceId: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.diagnoseType != nil {
                map["DiagnoseType"] = self.diagnoseType!
            }
            if self.errorCode != nil {
                map["ErrorCode"] = self.errorCode!
            }
            if self.resourceId != nil {
                map["ResourceId"] = self.resourceId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DiagnoseType"] as? String {
                self.diagnoseType = value
            }
            if let value = dict["ErrorCode"] as? String {
                self.errorCode = value
            }
            if let value = dict["ResourceId"] as? String {
                self.resourceId = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
        }
    }
    public var details: [DescribeScalingGroupDiagnoseDetailsResponseBody.Details]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.details != nil {
            var tmp : [Any] = []
            for k in self.details! {
                tmp.append(k.toMap())
            }
            map["Details"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Details"] as? [Any?] {
            var tmp : [DescribeScalingGroupDiagnoseDetailsResponseBody.Details] = []
            for v in value {
                if v != nil {
                    var model = DescribeScalingGroupDiagnoseDetailsResponseBody.Details()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.details = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeScalingGroupDiagnoseDetailsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeScalingGroupDiagnoseDetailsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeScalingGroupDiagnoseDetailsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeScalingGroupsRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var groupType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var scalingGroupIds: [String]?

    public var scalingGroupName: String?

    public var scalingGroupNames: [String]?

    public var tags: [DescribeScalingGroupsRequest.Tags]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupType != nil {
            map["GroupType"] = self.groupType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.scalingGroupIds != nil {
            map["ScalingGroupIds"] = self.scalingGroupIds!
        }
        if self.scalingGroupName != nil {
            map["ScalingGroupName"] = self.scalingGroupName!
        }
        if self.scalingGroupNames != nil {
            map["ScalingGroupNames"] = self.scalingGroupNames!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["GroupType"] as? String {
            self.groupType = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ScalingGroupIds"] as? [String] {
            self.scalingGroupIds = value
        }
        if let value = dict["ScalingGroupName"] as? String {
            self.scalingGroupName = value
        }
        if let value = dict["ScalingGroupNames"] as? [String] {
            self.scalingGroupNames = value
        }
        if let value = dict["Tags"] as? [Any?] {
            var tmp : [DescribeScalingGroupsRequest.Tags] = []
            for v in value {
                if v != nil {
                    var model = DescribeScalingGroupsRequest.Tags()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tags = tmp
        }
    }
}

public class DescribeScalingGroupsResponseBody : Tea.TeaModel {
    public class ScalingGroups : Tea.TeaModel {
        public class AlbServerGroups : Tea.TeaModel {
            public var albServerGroupId: String?

            public var port: Int32?

            public var weight: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.albServerGroupId != nil {
                    map["AlbServerGroupId"] = self.albServerGroupId!
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.weight != nil {
                    map["Weight"] = self.weight!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AlbServerGroupId"] as? String {
                    self.albServerGroupId = value
                }
                if let value = dict["Port"] as? Int32 {
                    self.port = value
                }
                if let value = dict["Weight"] as? Int32 {
                    self.weight = value
                }
            }
        }
        public class CapacityOptions : Tea.TeaModel {
            public var compensateWithOnDemand: Bool?

            public var onDemandBaseCapacity: Int32?

            public var onDemandPercentageAboveBaseCapacity: Int32?

            public var priceComparisonMode: String?

            public var spotAutoReplaceOnDemand: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.compensateWithOnDemand != nil {
                    map["CompensateWithOnDemand"] = self.compensateWithOnDemand!
                }
                if self.onDemandBaseCapacity != nil {
                    map["OnDemandBaseCapacity"] = self.onDemandBaseCapacity!
                }
                if self.onDemandPercentageAboveBaseCapacity != nil {
                    map["OnDemandPercentageAboveBaseCapacity"] = self.onDemandPercentageAboveBaseCapacity!
                }
                if self.priceComparisonMode != nil {
                    map["PriceComparisonMode"] = self.priceComparisonMode!
                }
                if self.spotAutoReplaceOnDemand != nil {
                    map["SpotAutoReplaceOnDemand"] = self.spotAutoReplaceOnDemand!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CompensateWithOnDemand"] as? Bool {
                    self.compensateWithOnDemand = value
                }
                if let value = dict["OnDemandBaseCapacity"] as? Int32 {
                    self.onDemandBaseCapacity = value
                }
                if let value = dict["OnDemandPercentageAboveBaseCapacity"] as? Int32 {
                    self.onDemandPercentageAboveBaseCapacity = value
                }
                if let value = dict["PriceComparisonMode"] as? String {
                    self.priceComparisonMode = value
                }
                if let value = dict["SpotAutoReplaceOnDemand"] as? Bool {
                    self.spotAutoReplaceOnDemand = value
                }
            }
        }
        public class DBInstances : Tea.TeaModel {
            public var DBInstanceId: String?

            public var securityGroupIds: [String]?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.DBInstanceId != nil {
                    map["DBInstanceId"] = self.DBInstanceId!
                }
                if self.securityGroupIds != nil {
                    map["SecurityGroupIds"] = self.securityGroupIds!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DBInstanceId"] as? String {
                    self.DBInstanceId = value
                }
                if let value = dict["SecurityGroupIds"] as? [String] {
                    self.securityGroupIds = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
            }
        }
        public class LaunchTemplateOverrides : Tea.TeaModel {
            public var instanceType: String?

            public var spotPriceLimit: Double?

            public var weightedCapacity: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.instanceType != nil {
                    map["InstanceType"] = self.instanceType!
                }
                if self.spotPriceLimit != nil {
                    map["SpotPriceLimit"] = self.spotPriceLimit!
                }
                if self.weightedCapacity != nil {
                    map["WeightedCapacity"] = self.weightedCapacity!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["InstanceType"] as? String {
                    self.instanceType = value
                }
                if let value = dict["SpotPriceLimit"] as? Double {
                    self.spotPriceLimit = value
                }
                if let value = dict["WeightedCapacity"] as? Int32 {
                    self.weightedCapacity = value
                }
            }
        }
        public class LoadBalancerConfigs : Tea.TeaModel {
            public var loadBalancerId: String?

            public var weight: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.loadBalancerId != nil {
                    map["LoadBalancerId"] = self.loadBalancerId!
                }
                if self.weight != nil {
                    map["Weight"] = self.weight!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["LoadBalancerId"] as? String {
                    self.loadBalancerId = value
                }
                if let value = dict["Weight"] as? Int32 {
                    self.weight = value
                }
            }
        }
        public class ServerGroups : Tea.TeaModel {
            public var port: Int32?

            public var serverGroupId: String?

            public var type: String?

            public var weight: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.serverGroupId != nil {
                    map["ServerGroupId"] = self.serverGroupId!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.weight != nil {
                    map["Weight"] = self.weight!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Port"] as? Int32 {
                    self.port = value
                }
                if let value = dict["ServerGroupId"] as? String {
                    self.serverGroupId = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
                if let value = dict["Weight"] as? Int32 {
                    self.weight = value
                }
            }
        }
        public class Tags : Tea.TeaModel {
            public var propagate: Bool?

            public var tagKey: String?

            public var tagValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.propagate != nil {
                    map["Propagate"] = self.propagate!
                }
                if self.tagKey != nil {
                    map["TagKey"] = self.tagKey!
                }
                if self.tagValue != nil {
                    map["TagValue"] = self.tagValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Propagate"] as? Bool {
                    self.propagate = value
                }
                if let value = dict["TagKey"] as? String {
                    self.tagKey = value
                }
                if let value = dict["TagValue"] as? String {
                    self.tagValue = value
                }
            }
        }
        public class VServerGroups : Tea.TeaModel {
            public class VServerGroupAttributes : Tea.TeaModel {
                public var port: Int32?

                public var VServerGroupId: String?

                public var weight: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.port != nil {
                        map["Port"] = self.port!
                    }
                    if self.VServerGroupId != nil {
                        map["VServerGroupId"] = self.VServerGroupId!
                    }
                    if self.weight != nil {
                        map["Weight"] = self.weight!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Port"] as? Int32 {
                        self.port = value
                    }
                    if let value = dict["VServerGroupId"] as? String {
                        self.VServerGroupId = value
                    }
                    if let value = dict["Weight"] as? Int32 {
                        self.weight = value
                    }
                }
            }
            public var loadBalancerId: String?

            public var VServerGroupAttributes: [DescribeScalingGroupsResponseBody.ScalingGroups.VServerGroups.VServerGroupAttributes]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.loadBalancerId != nil {
                    map["LoadBalancerId"] = self.loadBalancerId!
                }
                if self.VServerGroupAttributes != nil {
                    var tmp : [Any] = []
                    for k in self.VServerGroupAttributes! {
                        tmp.append(k.toMap())
                    }
                    map["VServerGroupAttributes"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["LoadBalancerId"] as? String {
                    self.loadBalancerId = value
                }
                if let value = dict["VServerGroupAttributes"] as? [Any?] {
                    var tmp : [DescribeScalingGroupsResponseBody.ScalingGroups.VServerGroups.VServerGroupAttributes] = []
                    for v in value {
                        if v != nil {
                            var model = DescribeScalingGroupsResponseBody.ScalingGroups.VServerGroups.VServerGroupAttributes()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.VServerGroupAttributes = tmp
                }
            }
        }
        public var activeCapacity: Int32?

        public var activeScalingConfigurationId: String?

        public var albServerGroups: [DescribeScalingGroupsResponseBody.ScalingGroups.AlbServerGroups]?

        public var allocationStrategy: String?

        public var azBalance: Bool?

        public var capacityOptions: DescribeScalingGroupsResponseBody.ScalingGroups.CapacityOptions?

        public var compensateWithOnDemand: Bool?

        public var creationTime: String?

        public var currentHostName: String?

        public var customPolicyARN: String?

        public var DBInstanceIds: [String]?

        public var DBInstances: [DescribeScalingGroupsResponseBody.ScalingGroups.DBInstances]?

        public var defaultCooldown: Int32?

        public var desiredCapacity: Int32?

        public var enableDesiredCapacity: Bool?

        public var groupDeletionProtection: Bool?

        public var groupType: String?

        public var healthCheckType: String?

        public var healthCheckTypes: [String]?

        public var initCapacity: Int32?

        public var isElasticStrengthInAlarm: Bool?

        public var launchTemplateId: String?

        public var launchTemplateOverrides: [DescribeScalingGroupsResponseBody.ScalingGroups.LaunchTemplateOverrides]?

        public var launchTemplateVersion: String?

        public var lifecycleState: String?

        public var loadBalancerConfigs: [DescribeScalingGroupsResponseBody.ScalingGroups.LoadBalancerConfigs]?

        public var loadBalancerIds: [String]?

        public var maxInstanceLifetime: Int32?

        public var maxSize: Int32?

        public var minSize: Int32?

        public var modificationTime: String?

        public var monitorGroupId: String?

        public var multiAZPolicy: String?

        public var onDemandBaseCapacity: Int32?

        public var onDemandPercentageAboveBaseCapacity: Int32?

        public var pendingCapacity: Int32?

        public var pendingWaitCapacity: Int32?

        public var protectedCapacity: Int32?

        public var regionId: String?

        public var removalPolicies: [String]?

        public var removingCapacity: Int32?

        public var removingWaitCapacity: Int32?

        public var resourceGroupId: String?

        public var scalingGroupId: String?

        public var scalingGroupName: String?

        public var scalingPolicy: String?

        public var serverGroups: [DescribeScalingGroupsResponseBody.ScalingGroups.ServerGroups]?

        public var spotAllocationStrategy: String?

        public var spotCapacity: Int32?

        public var spotInstancePools: Int32?

        public var spotInstanceRemedy: Bool?

        public var standbyCapacity: Int32?

        public var stopInstanceTimeout: Int32?

        public var stoppedCapacity: Int32?

        public var suspendedProcesses: [String]?

        public var systemSuspended: Bool?

        public var tags: [DescribeScalingGroupsResponseBody.ScalingGroups.Tags]?

        public var totalCapacity: Int32?

        public var totalInstanceCount: Int32?

        public var VServerGroups: [DescribeScalingGroupsResponseBody.ScalingGroups.VServerGroups]?

        public var vSwitchId: String?

        public var vSwitchIds: [String]?

        public var vpcId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.capacityOptions?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.activeCapacity != nil {
                map["ActiveCapacity"] = self.activeCapacity!
            }
            if self.activeScalingConfigurationId != nil {
                map["ActiveScalingConfigurationId"] = self.activeScalingConfigurationId!
            }
            if self.albServerGroups != nil {
                var tmp : [Any] = []
                for k in self.albServerGroups! {
                    tmp.append(k.toMap())
                }
                map["AlbServerGroups"] = tmp
            }
            if self.allocationStrategy != nil {
                map["AllocationStrategy"] = self.allocationStrategy!
            }
            if self.azBalance != nil {
                map["AzBalance"] = self.azBalance!
            }
            if self.capacityOptions != nil {
                map["CapacityOptions"] = self.capacityOptions?.toMap()
            }
            if self.compensateWithOnDemand != nil {
                map["CompensateWithOnDemand"] = self.compensateWithOnDemand!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.currentHostName != nil {
                map["CurrentHostName"] = self.currentHostName!
            }
            if self.customPolicyARN != nil {
                map["CustomPolicyARN"] = self.customPolicyARN!
            }
            if self.DBInstanceIds != nil {
                map["DBInstanceIds"] = self.DBInstanceIds!
            }
            if self.DBInstances != nil {
                var tmp : [Any] = []
                for k in self.DBInstances! {
                    tmp.append(k.toMap())
                }
                map["DBInstances"] = tmp
            }
            if self.defaultCooldown != nil {
                map["DefaultCooldown"] = self.defaultCooldown!
            }
            if self.desiredCapacity != nil {
                map["DesiredCapacity"] = self.desiredCapacity!
            }
            if self.enableDesiredCapacity != nil {
                map["EnableDesiredCapacity"] = self.enableDesiredCapacity!
            }
            if self.groupDeletionProtection != nil {
                map["GroupDeletionProtection"] = self.groupDeletionProtection!
            }
            if self.groupType != nil {
                map["GroupType"] = self.groupType!
            }
            if self.healthCheckType != nil {
                map["HealthCheckType"] = self.healthCheckType!
            }
            if self.healthCheckTypes != nil {
                map["HealthCheckTypes"] = self.healthCheckTypes!
            }
            if self.initCapacity != nil {
                map["InitCapacity"] = self.initCapacity!
            }
            if self.isElasticStrengthInAlarm != nil {
                map["IsElasticStrengthInAlarm"] = self.isElasticStrengthInAlarm!
            }
            if self.launchTemplateId != nil {
                map["LaunchTemplateId"] = self.launchTemplateId!
            }
            if self.launchTemplateOverrides != nil {
                var tmp : [Any] = []
                for k in self.launchTemplateOverrides! {
                    tmp.append(k.toMap())
                }
                map["LaunchTemplateOverrides"] = tmp
            }
            if self.launchTemplateVersion != nil {
                map["LaunchTemplateVersion"] = self.launchTemplateVersion!
            }
            if self.lifecycleState != nil {
                map["LifecycleState"] = self.lifecycleState!
            }
            if self.loadBalancerConfigs != nil {
                var tmp : [Any] = []
                for k in self.loadBalancerConfigs! {
                    tmp.append(k.toMap())
                }
                map["LoadBalancerConfigs"] = tmp
            }
            if self.loadBalancerIds != nil {
                map["LoadBalancerIds"] = self.loadBalancerIds!
            }
            if self.maxInstanceLifetime != nil {
                map["MaxInstanceLifetime"] = self.maxInstanceLifetime!
            }
            if self.maxSize != nil {
                map["MaxSize"] = self.maxSize!
            }
            if self.minSize != nil {
                map["MinSize"] = self.minSize!
            }
            if self.modificationTime != nil {
                map["ModificationTime"] = self.modificationTime!
            }
            if self.monitorGroupId != nil {
                map["MonitorGroupId"] = self.monitorGroupId!
            }
            if self.multiAZPolicy != nil {
                map["MultiAZPolicy"] = self.multiAZPolicy!
            }
            if self.onDemandBaseCapacity != nil {
                map["OnDemandBaseCapacity"] = self.onDemandBaseCapacity!
            }
            if self.onDemandPercentageAboveBaseCapacity != nil {
                map["OnDemandPercentageAboveBaseCapacity"] = self.onDemandPercentageAboveBaseCapacity!
            }
            if self.pendingCapacity != nil {
                map["PendingCapacity"] = self.pendingCapacity!
            }
            if self.pendingWaitCapacity != nil {
                map["PendingWaitCapacity"] = self.pendingWaitCapacity!
            }
            if self.protectedCapacity != nil {
                map["ProtectedCapacity"] = self.protectedCapacity!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.removalPolicies != nil {
                map["RemovalPolicies"] = self.removalPolicies!
            }
            if self.removingCapacity != nil {
                map["RemovingCapacity"] = self.removingCapacity!
            }
            if self.removingWaitCapacity != nil {
                map["RemovingWaitCapacity"] = self.removingWaitCapacity!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.scalingGroupId != nil {
                map["ScalingGroupId"] = self.scalingGroupId!
            }
            if self.scalingGroupName != nil {
                map["ScalingGroupName"] = self.scalingGroupName!
            }
            if self.scalingPolicy != nil {
                map["ScalingPolicy"] = self.scalingPolicy!
            }
            if self.serverGroups != nil {
                var tmp : [Any] = []
                for k in self.serverGroups! {
                    tmp.append(k.toMap())
                }
                map["ServerGroups"] = tmp
            }
            if self.spotAllocationStrategy != nil {
                map["SpotAllocationStrategy"] = self.spotAllocationStrategy!
            }
            if self.spotCapacity != nil {
                map["SpotCapacity"] = self.spotCapacity!
            }
            if self.spotInstancePools != nil {
                map["SpotInstancePools"] = self.spotInstancePools!
            }
            if self.spotInstanceRemedy != nil {
                map["SpotInstanceRemedy"] = self.spotInstanceRemedy!
            }
            if self.standbyCapacity != nil {
                map["StandbyCapacity"] = self.standbyCapacity!
            }
            if self.stopInstanceTimeout != nil {
                map["StopInstanceTimeout"] = self.stopInstanceTimeout!
            }
            if self.stoppedCapacity != nil {
                map["StoppedCapacity"] = self.stoppedCapacity!
            }
            if self.suspendedProcesses != nil {
                map["SuspendedProcesses"] = self.suspendedProcesses!
            }
            if self.systemSuspended != nil {
                map["SystemSuspended"] = self.systemSuspended!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            if self.totalCapacity != nil {
                map["TotalCapacity"] = self.totalCapacity!
            }
            if self.totalInstanceCount != nil {
                map["TotalInstanceCount"] = self.totalInstanceCount!
            }
            if self.VServerGroups != nil {
                var tmp : [Any] = []
                for k in self.VServerGroups! {
                    tmp.append(k.toMap())
                }
                map["VServerGroups"] = tmp
            }
            if self.vSwitchId != nil {
                map["VSwitchId"] = self.vSwitchId!
            }
            if self.vSwitchIds != nil {
                map["VSwitchIds"] = self.vSwitchIds!
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ActiveCapacity"] as? Int32 {
                self.activeCapacity = value
            }
            if let value = dict["ActiveScalingConfigurationId"] as? String {
                self.activeScalingConfigurationId = value
            }
            if let value = dict["AlbServerGroups"] as? [Any?] {
                var tmp : [DescribeScalingGroupsResponseBody.ScalingGroups.AlbServerGroups] = []
                for v in value {
                    if v != nil {
                        var model = DescribeScalingGroupsResponseBody.ScalingGroups.AlbServerGroups()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.albServerGroups = tmp
            }
            if let value = dict["AllocationStrategy"] as? String {
                self.allocationStrategy = value
            }
            if let value = dict["AzBalance"] as? Bool {
                self.azBalance = value
            }
            if let value = dict["CapacityOptions"] as? [String: Any?] {
                var model = DescribeScalingGroupsResponseBody.ScalingGroups.CapacityOptions()
                model.fromMap(value)
                self.capacityOptions = model
            }
            if let value = dict["CompensateWithOnDemand"] as? Bool {
                self.compensateWithOnDemand = value
            }
            if let value = dict["CreationTime"] as? String {
                self.creationTime = value
            }
            if let value = dict["CurrentHostName"] as? String {
                self.currentHostName = value
            }
            if let value = dict["CustomPolicyARN"] as? String {
                self.customPolicyARN = value
            }
            if let value = dict["DBInstanceIds"] as? [String] {
                self.DBInstanceIds = value
            }
            if let value = dict["DBInstances"] as? [Any?] {
                var tmp : [DescribeScalingGroupsResponseBody.ScalingGroups.DBInstances] = []
                for v in value {
                    if v != nil {
                        var model = DescribeScalingGroupsResponseBody.ScalingGroups.DBInstances()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.DBInstances = tmp
            }
            if let value = dict["DefaultCooldown"] as? Int32 {
                self.defaultCooldown = value
            }
            if let value = dict["DesiredCapacity"] as? Int32 {
                self.desiredCapacity = value
            }
            if let value = dict["EnableDesiredCapacity"] as? Bool {
                self.enableDesiredCapacity = value
            }
            if let value = dict["GroupDeletionProtection"] as? Bool {
                self.groupDeletionProtection = value
            }
            if let value = dict["GroupType"] as? String {
                self.groupType = value
            }
            if let value = dict["HealthCheckType"] as? String {
                self.healthCheckType = value
            }
            if let value = dict["HealthCheckTypes"] as? [String] {
                self.healthCheckTypes = value
            }
            if let value = dict["InitCapacity"] as? Int32 {
                self.initCapacity = value
            }
            if let value = dict["IsElasticStrengthInAlarm"] as? Bool {
                self.isElasticStrengthInAlarm = value
            }
            if let value = dict["LaunchTemplateId"] as? String {
                self.launchTemplateId = value
            }
            if let value = dict["LaunchTemplateOverrides"] as? [Any?] {
                var tmp : [DescribeScalingGroupsResponseBody.ScalingGroups.LaunchTemplateOverrides] = []
                for v in value {
                    if v != nil {
                        var model = DescribeScalingGroupsResponseBody.ScalingGroups.LaunchTemplateOverrides()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.launchTemplateOverrides = tmp
            }
            if let value = dict["LaunchTemplateVersion"] as? String {
                self.launchTemplateVersion = value
            }
            if let value = dict["LifecycleState"] as? String {
                self.lifecycleState = value
            }
            if let value = dict["LoadBalancerConfigs"] as? [Any?] {
                var tmp : [DescribeScalingGroupsResponseBody.ScalingGroups.LoadBalancerConfigs] = []
                for v in value {
                    if v != nil {
                        var model = DescribeScalingGroupsResponseBody.ScalingGroups.LoadBalancerConfigs()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.loadBalancerConfigs = tmp
            }
            if let value = dict["LoadBalancerIds"] as? [String] {
                self.loadBalancerIds = value
            }
            if let value = dict["MaxInstanceLifetime"] as? Int32 {
                self.maxInstanceLifetime = value
            }
            if let value = dict["MaxSize"] as? Int32 {
                self.maxSize = value
            }
            if let value = dict["MinSize"] as? Int32 {
                self.minSize = value
            }
            if let value = dict["ModificationTime"] as? String {
                self.modificationTime = value
            }
            if let value = dict["MonitorGroupId"] as? String {
                self.monitorGroupId = value
            }
            if let value = dict["MultiAZPolicy"] as? String {
                self.multiAZPolicy = value
            }
            if let value = dict["OnDemandBaseCapacity"] as? Int32 {
                self.onDemandBaseCapacity = value
            }
            if let value = dict["OnDemandPercentageAboveBaseCapacity"] as? Int32 {
                self.onDemandPercentageAboveBaseCapacity = value
            }
            if let value = dict["PendingCapacity"] as? Int32 {
                self.pendingCapacity = value
            }
            if let value = dict["PendingWaitCapacity"] as? Int32 {
                self.pendingWaitCapacity = value
            }
            if let value = dict["ProtectedCapacity"] as? Int32 {
                self.protectedCapacity = value
            }
            if let value = dict["RegionId"] as? String {
                self.regionId = value
            }
            if let value = dict["RemovalPolicies"] as? [String] {
                self.removalPolicies = value
            }
            if let value = dict["RemovingCapacity"] as? Int32 {
                self.removingCapacity = value
            }
            if let value = dict["RemovingWaitCapacity"] as? Int32 {
                self.removingWaitCapacity = value
            }
            if let value = dict["ResourceGroupId"] as? String {
                self.resourceGroupId = value
            }
            if let value = dict["ScalingGroupId"] as? String {
                self.scalingGroupId = value
            }
            if let value = dict["ScalingGroupName"] as? String {
                self.scalingGroupName = value
            }
            if let value = dict["ScalingPolicy"] as? String {
                self.scalingPolicy = value
            }
            if let value = dict["ServerGroups"] as? [Any?] {
                var tmp : [DescribeScalingGroupsResponseBody.ScalingGroups.ServerGroups] = []
                for v in value {
                    if v != nil {
                        var model = DescribeScalingGroupsResponseBody.ScalingGroups.ServerGroups()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.serverGroups = tmp
            }
            if let value = dict["SpotAllocationStrategy"] as? String {
                self.spotAllocationStrategy = value
            }
            if let value = dict["SpotCapacity"] as? Int32 {
                self.spotCapacity = value
            }
            if let value = dict["SpotInstancePools"] as? Int32 {
                self.spotInstancePools = value
            }
            if let value = dict["SpotInstanceRemedy"] as? Bool {
                self.spotInstanceRemedy = value
            }
            if let value = dict["StandbyCapacity"] as? Int32 {
                self.standbyCapacity = value
            }
            if let value = dict["StopInstanceTimeout"] as? Int32 {
                self.stopInstanceTimeout = value
            }
            if let value = dict["StoppedCapacity"] as? Int32 {
                self.stoppedCapacity = value
            }
            if let value = dict["SuspendedProcesses"] as? [String] {
                self.suspendedProcesses = value
            }
            if let value = dict["SystemSuspended"] as? Bool {
                self.systemSuspended = value
            }
            if let value = dict["Tags"] as? [Any?] {
                var tmp : [DescribeScalingGroupsResponseBody.ScalingGroups.Tags] = []
                for v in value {
                    if v != nil {
                        var model = DescribeScalingGroupsResponseBody.ScalingGroups.Tags()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tags = tmp
            }
            if let value = dict["TotalCapacity"] as? Int32 {
                self.totalCapacity = value
            }
            if let value = dict["TotalInstanceCount"] as? Int32 {
                self.totalInstanceCount = value
            }
            if let value = dict["VServerGroups"] as? [Any?] {
                var tmp : [DescribeScalingGroupsResponseBody.ScalingGroups.VServerGroups] = []
                for v in value {
                    if v != nil {
                        var model = DescribeScalingGroupsResponseBody.ScalingGroups.VServerGroups()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.VServerGroups = tmp
            }
            if let value = dict["VSwitchId"] as? String {
                self.vSwitchId = value
            }
            if let value = dict["VSwitchIds"] as? [String] {
                self.vSwitchIds = value
            }
            if let value = dict["VpcId"] as? String {
                self.vpcId = value
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var scalingGroups: [DescribeScalingGroupsResponseBody.ScalingGroups]?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingGroups != nil {
            var tmp : [Any] = []
            for k in self.scalingGroups! {
                tmp.append(k.toMap())
            }
            map["ScalingGroups"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ScalingGroups"] as? [Any?] {
            var tmp : [DescribeScalingGroupsResponseBody.ScalingGroups] = []
            for v in value {
                if v != nil {
                    var model = DescribeScalingGroupsResponseBody.ScalingGroups()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.scalingGroups = tmp
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeScalingGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeScalingGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeScalingGroupsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeScalingInstancesRequest : Tea.TeaModel {
    public var creationType: String?

    public var creationTypes: [String]?

    public var healthStatus: String?

    public var instanceIds: [String]?

    public var lifecycleState: String?

    public var lifecycleStates: [String]?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var scalingActivityId: String?

    public var scalingConfigurationId: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.creationType != nil {
            map["CreationType"] = self.creationType!
        }
        if self.creationTypes != nil {
            map["CreationTypes"] = self.creationTypes!
        }
        if self.healthStatus != nil {
            map["HealthStatus"] = self.healthStatus!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.lifecycleState != nil {
            map["LifecycleState"] = self.lifecycleState!
        }
        if self.lifecycleStates != nil {
            map["LifecycleStates"] = self.lifecycleStates!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.scalingActivityId != nil {
            map["ScalingActivityId"] = self.scalingActivityId!
        }
        if self.scalingConfigurationId != nil {
            map["ScalingConfigurationId"] = self.scalingConfigurationId!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CreationType"] as? String {
            self.creationType = value
        }
        if let value = dict["CreationTypes"] as? [String] {
            self.creationTypes = value
        }
        if let value = dict["HealthStatus"] as? String {
            self.healthStatus = value
        }
        if let value = dict["InstanceIds"] as? [String] {
            self.instanceIds = value
        }
        if let value = dict["LifecycleState"] as? String {
            self.lifecycleState = value
        }
        if let value = dict["LifecycleStates"] as? [String] {
            self.lifecycleStates = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ScalingActivityId"] as? String {
            self.scalingActivityId = value
        }
        if let value = dict["ScalingConfigurationId"] as? String {
            self.scalingConfigurationId = value
        }
        if let value = dict["ScalingGroupId"] as? String {
            self.scalingGroupId = value
        }
    }
}

public class DescribeScalingInstancesResponseBody : Tea.TeaModel {
    public class ScalingInstances : Tea.TeaModel {
        public var createdTime: String?

        public var creationTime: String?

        public var creationType: String?

        public var entrusted: Bool?

        public var healthStatus: String?

        public var instanceId: String?

        public var launchTemplateId: String?

        public var launchTemplateVersion: String?

        public var lifecycleState: String?

        public var loadBalancerWeight: Int32?

        public var privateIpAddress: String?

        public var scalingActivityId: String?

        public var scalingConfigurationId: String?

        public var scalingGroupId: String?

        public var scalingInstanceId: String?

        public var spotStrategy: String?

        public var warmupState: String?

        public var weightedCapacity: Int32?

        public var zoneId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createdTime != nil {
                map["CreatedTime"] = self.createdTime!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.creationType != nil {
                map["CreationType"] = self.creationType!
            }
            if self.entrusted != nil {
                map["Entrusted"] = self.entrusted!
            }
            if self.healthStatus != nil {
                map["HealthStatus"] = self.healthStatus!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.launchTemplateId != nil {
                map["LaunchTemplateId"] = self.launchTemplateId!
            }
            if self.launchTemplateVersion != nil {
                map["LaunchTemplateVersion"] = self.launchTemplateVersion!
            }
            if self.lifecycleState != nil {
                map["LifecycleState"] = self.lifecycleState!
            }
            if self.loadBalancerWeight != nil {
                map["LoadBalancerWeight"] = self.loadBalancerWeight!
            }
            if self.privateIpAddress != nil {
                map["PrivateIpAddress"] = self.privateIpAddress!
            }
            if self.scalingActivityId != nil {
                map["ScalingActivityId"] = self.scalingActivityId!
            }
            if self.scalingConfigurationId != nil {
                map["ScalingConfigurationId"] = self.scalingConfigurationId!
            }
            if self.scalingGroupId != nil {
                map["ScalingGroupId"] = self.scalingGroupId!
            }
            if self.scalingInstanceId != nil {
                map["ScalingInstanceId"] = self.scalingInstanceId!
            }
            if self.spotStrategy != nil {
                map["SpotStrategy"] = self.spotStrategy!
            }
            if self.warmupState != nil {
                map["WarmupState"] = self.warmupState!
            }
            if self.weightedCapacity != nil {
                map["WeightedCapacity"] = self.weightedCapacity!
            }
            if self.zoneId != nil {
                map["ZoneId"] = self.zoneId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CreatedTime"] as? String {
                self.createdTime = value
            }
            if let value = dict["CreationTime"] as? String {
                self.creationTime = value
            }
            if let value = dict["CreationType"] as? String {
                self.creationType = value
            }
            if let value = dict["Entrusted"] as? Bool {
                self.entrusted = value
            }
            if let value = dict["HealthStatus"] as? String {
                self.healthStatus = value
            }
            if let value = dict["InstanceId"] as? String {
                self.instanceId = value
            }
            if let value = dict["LaunchTemplateId"] as? String {
                self.launchTemplateId = value
            }
            if let value = dict["LaunchTemplateVersion"] as? String {
                self.launchTemplateVersion = value
            }
            if let value = dict["LifecycleState"] as? String {
                self.lifecycleState = value
            }
            if let value = dict["LoadBalancerWeight"] as? Int32 {
                self.loadBalancerWeight = value
            }
            if let value = dict["PrivateIpAddress"] as? String {
                self.privateIpAddress = value
            }
            if let value = dict["ScalingActivityId"] as? String {
                self.scalingActivityId = value
            }
            if let value = dict["ScalingConfigurationId"] as? String {
                self.scalingConfigurationId = value
            }
            if let value = dict["ScalingGroupId"] as? String {
                self.scalingGroupId = value
            }
            if let value = dict["ScalingInstanceId"] as? String {
                self.scalingInstanceId = value
            }
            if let value = dict["SpotStrategy"] as? String {
                self.spotStrategy = value
            }
            if let value = dict["WarmupState"] as? String {
                self.warmupState = value
            }
            if let value = dict["WeightedCapacity"] as? Int32 {
                self.weightedCapacity = value
            }
            if let value = dict["ZoneId"] as? String {
                self.zoneId = value
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var scalingInstances: [DescribeScalingInstancesResponseBody.ScalingInstances]?

    public var totalCount: Int32?

    public var totalSpotCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingInstances != nil {
            var tmp : [Any] = []
            for k in self.scalingInstances! {
                tmp.append(k.toMap())
            }
            map["ScalingInstances"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.totalSpotCount != nil {
            map["TotalSpotCount"] = self.totalSpotCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ScalingInstances"] as? [Any?] {
            var tmp : [DescribeScalingInstancesResponseBody.ScalingInstances] = []
            for v in value {
                if v != nil {
                    var model = DescribeScalingInstancesResponseBody.ScalingInstances()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.scalingInstances = tmp
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
        if let value = dict["TotalSpotCount"] as? Int32 {
            self.totalSpotCount = value
        }
    }
}

public class DescribeScalingInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeScalingInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeScalingInstancesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeScalingRulesRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var scalingGroupId: String?

    public var scalingRuleAris: [String]?

    public var scalingRuleIds: [String]?

    public var scalingRuleNames: [String]?

    public var scalingRuleType: String?

    public var showAlarmRules: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        if self.scalingRuleAris != nil {
            map["ScalingRuleAris"] = self.scalingRuleAris!
        }
        if self.scalingRuleIds != nil {
            map["ScalingRuleIds"] = self.scalingRuleIds!
        }
        if self.scalingRuleNames != nil {
            map["ScalingRuleNames"] = self.scalingRuleNames!
        }
        if self.scalingRuleType != nil {
            map["ScalingRuleType"] = self.scalingRuleType!
        }
        if self.showAlarmRules != nil {
            map["ShowAlarmRules"] = self.showAlarmRules!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ScalingGroupId"] as? String {
            self.scalingGroupId = value
        }
        if let value = dict["ScalingRuleAris"] as? [String] {
            self.scalingRuleAris = value
        }
        if let value = dict["ScalingRuleIds"] as? [String] {
            self.scalingRuleIds = value
        }
        if let value = dict["ScalingRuleNames"] as? [String] {
            self.scalingRuleNames = value
        }
        if let value = dict["ScalingRuleType"] as? String {
            self.scalingRuleType = value
        }
        if let value = dict["ShowAlarmRules"] as? Bool {
            self.showAlarmRules = value
        }
    }
}

public class DescribeScalingRulesResponseBody : Tea.TeaModel {
    public class ScalingRules : Tea.TeaModel {
        public class AlarmDimensions : Tea.TeaModel {
            public var dimensionKey: String?

            public var dimensionValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dimensionKey != nil {
                    map["DimensionKey"] = self.dimensionKey!
                }
                if self.dimensionValue != nil {
                    map["DimensionValue"] = self.dimensionValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DimensionKey"] as? String {
                    self.dimensionKey = value
                }
                if let value = dict["DimensionValue"] as? String {
                    self.dimensionValue = value
                }
            }
        }
        public class Alarms : Tea.TeaModel {
            public class Dimensions : Tea.TeaModel {
                public var dimensionKey: String?

                public var dimensionValue: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dimensionKey != nil {
                        map["DimensionKey"] = self.dimensionKey!
                    }
                    if self.dimensionValue != nil {
                        map["DimensionValue"] = self.dimensionValue!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["DimensionKey"] as? String {
                        self.dimensionKey = value
                    }
                    if let value = dict["DimensionValue"] as? String {
                        self.dimensionValue = value
                    }
                }
            }
            public var alarmTaskId: String?

            public var alarmTaskName: String?

            public var comparisonOperator: String?

            public var dimensions: [DescribeScalingRulesResponseBody.ScalingRules.Alarms.Dimensions]?

            public var evaluationCount: Int32?

            public var metricName: String?

            public var metricType: String?

            public var period: Int32?

            public var statistics: String?

            public var threshold: Double?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.alarmTaskId != nil {
                    map["AlarmTaskId"] = self.alarmTaskId!
                }
                if self.alarmTaskName != nil {
                    map["AlarmTaskName"] = self.alarmTaskName!
                }
                if self.comparisonOperator != nil {
                    map["ComparisonOperator"] = self.comparisonOperator!
                }
                if self.dimensions != nil {
                    var tmp : [Any] = []
                    for k in self.dimensions! {
                        tmp.append(k.toMap())
                    }
                    map["Dimensions"] = tmp
                }
                if self.evaluationCount != nil {
                    map["EvaluationCount"] = self.evaluationCount!
                }
                if self.metricName != nil {
                    map["MetricName"] = self.metricName!
                }
                if self.metricType != nil {
                    map["MetricType"] = self.metricType!
                }
                if self.period != nil {
                    map["Period"] = self.period!
                }
                if self.statistics != nil {
                    map["Statistics"] = self.statistics!
                }
                if self.threshold != nil {
                    map["Threshold"] = self.threshold!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AlarmTaskId"] as? String {
                    self.alarmTaskId = value
                }
                if let value = dict["AlarmTaskName"] as? String {
                    self.alarmTaskName = value
                }
                if let value = dict["ComparisonOperator"] as? String {
                    self.comparisonOperator = value
                }
                if let value = dict["Dimensions"] as? [Any?] {
                    var tmp : [DescribeScalingRulesResponseBody.ScalingRules.Alarms.Dimensions] = []
                    for v in value {
                        if v != nil {
                            var model = DescribeScalingRulesResponseBody.ScalingRules.Alarms.Dimensions()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.dimensions = tmp
                }
                if let value = dict["EvaluationCount"] as? Int32 {
                    self.evaluationCount = value
                }
                if let value = dict["MetricName"] as? String {
                    self.metricName = value
                }
                if let value = dict["MetricType"] as? String {
                    self.metricType = value
                }
                if let value = dict["Period"] as? Int32 {
                    self.period = value
                }
                if let value = dict["Statistics"] as? String {
                    self.statistics = value
                }
                if let value = dict["Threshold"] as? Double {
                    self.threshold = value
                }
            }
        }
        public class HybridMetrics : Tea.TeaModel {
            public class Dimensions : Tea.TeaModel {
                public var dimensionKey: String?

                public var dimensionValue: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dimensionKey != nil {
                        map["DimensionKey"] = self.dimensionKey!
                    }
                    if self.dimensionValue != nil {
                        map["DimensionValue"] = self.dimensionValue!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["DimensionKey"] as? String {
                        self.dimensionKey = value
                    }
                    if let value = dict["DimensionValue"] as? String {
                        self.dimensionValue = value
                    }
                }
            }
            public var dimensions: [DescribeScalingRulesResponseBody.ScalingRules.HybridMetrics.Dimensions]?

            public var expression: String?

            public var id: String?

            public var metricName: String?

            public var statistic: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dimensions != nil {
                    var tmp : [Any] = []
                    for k in self.dimensions! {
                        tmp.append(k.toMap())
                    }
                    map["Dimensions"] = tmp
                }
                if self.expression != nil {
                    map["Expression"] = self.expression!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.metricName != nil {
                    map["MetricName"] = self.metricName!
                }
                if self.statistic != nil {
                    map["Statistic"] = self.statistic!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Dimensions"] as? [Any?] {
                    var tmp : [DescribeScalingRulesResponseBody.ScalingRules.HybridMetrics.Dimensions] = []
                    for v in value {
                        if v != nil {
                            var model = DescribeScalingRulesResponseBody.ScalingRules.HybridMetrics.Dimensions()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.dimensions = tmp
                }
                if let value = dict["Expression"] as? String {
                    self.expression = value
                }
                if let value = dict["Id"] as? String {
                    self.id = value
                }
                if let value = dict["MetricName"] as? String {
                    self.metricName = value
                }
                if let value = dict["Statistic"] as? String {
                    self.statistic = value
                }
            }
        }
        public class StepAdjustments : Tea.TeaModel {
            public var metricIntervalLowerBound: Double?

            public var metricIntervalUpperBound: Double?

            public var scalingAdjustment: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.metricIntervalLowerBound != nil {
                    map["MetricIntervalLowerBound"] = self.metricIntervalLowerBound!
                }
                if self.metricIntervalUpperBound != nil {
                    map["MetricIntervalUpperBound"] = self.metricIntervalUpperBound!
                }
                if self.scalingAdjustment != nil {
                    map["ScalingAdjustment"] = self.scalingAdjustment!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["MetricIntervalLowerBound"] as? Double {
                    self.metricIntervalLowerBound = value
                }
                if let value = dict["MetricIntervalUpperBound"] as? Double {
                    self.metricIntervalUpperBound = value
                }
                if let value = dict["ScalingAdjustment"] as? Int32 {
                    self.scalingAdjustment = value
                }
            }
        }
        public var adjustmentType: String?

        public var adjustmentValue: Int32?

        public var alarmDimensions: [DescribeScalingRulesResponseBody.ScalingRules.AlarmDimensions]?

        public var alarms: [DescribeScalingRulesResponseBody.ScalingRules.Alarms]?

        public var cooldown: Int32?

        public var disableScaleIn: Bool?

        public var estimatedInstanceWarmup: Int32?

        public var hybridMetrics: [DescribeScalingRulesResponseBody.ScalingRules.HybridMetrics]?

        public var hybridMonitorNamespace: String?

        public var initialMaxSize: Int32?

        public var maxSize: Int32?

        public var metricName: String?

        public var metricType: String?

        public var minAdjustmentMagnitude: Int32?

        public var minSize: Int32?

        public var predictiveScalingMode: String?

        public var predictiveTaskBufferTime: Int32?

        public var predictiveValueBehavior: String?

        public var predictiveValueBuffer: Int32?

        public var scaleInEvaluationCount: Int32?

        public var scaleOutEvaluationCount: Int32?

        public var scalingGroupId: String?

        public var scalingRuleAri: String?

        public var scalingRuleId: String?

        public var scalingRuleName: String?

        public var scalingRuleType: String?

        public var stepAdjustments: [DescribeScalingRulesResponseBody.ScalingRules.StepAdjustments]?

        public var targetValue: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.adjustmentType != nil {
                map["AdjustmentType"] = self.adjustmentType!
            }
            if self.adjustmentValue != nil {
                map["AdjustmentValue"] = self.adjustmentValue!
            }
            if self.alarmDimensions != nil {
                var tmp : [Any] = []
                for k in self.alarmDimensions! {
                    tmp.append(k.toMap())
                }
                map["AlarmDimensions"] = tmp
            }
            if self.alarms != nil {
                var tmp : [Any] = []
                for k in self.alarms! {
                    tmp.append(k.toMap())
                }
                map["Alarms"] = tmp
            }
            if self.cooldown != nil {
                map["Cooldown"] = self.cooldown!
            }
            if self.disableScaleIn != nil {
                map["DisableScaleIn"] = self.disableScaleIn!
            }
            if self.estimatedInstanceWarmup != nil {
                map["EstimatedInstanceWarmup"] = self.estimatedInstanceWarmup!
            }
            if self.hybridMetrics != nil {
                var tmp : [Any] = []
                for k in self.hybridMetrics! {
                    tmp.append(k.toMap())
                }
                map["HybridMetrics"] = tmp
            }
            if self.hybridMonitorNamespace != nil {
                map["HybridMonitorNamespace"] = self.hybridMonitorNamespace!
            }
            if self.initialMaxSize != nil {
                map["InitialMaxSize"] = self.initialMaxSize!
            }
            if self.maxSize != nil {
                map["MaxSize"] = self.maxSize!
            }
            if self.metricName != nil {
                map["MetricName"] = self.metricName!
            }
            if self.metricType != nil {
                map["MetricType"] = self.metricType!
            }
            if self.minAdjustmentMagnitude != nil {
                map["MinAdjustmentMagnitude"] = self.minAdjustmentMagnitude!
            }
            if self.minSize != nil {
                map["MinSize"] = self.minSize!
            }
            if self.predictiveScalingMode != nil {
                map["PredictiveScalingMode"] = self.predictiveScalingMode!
            }
            if self.predictiveTaskBufferTime != nil {
                map["PredictiveTaskBufferTime"] = self.predictiveTaskBufferTime!
            }
            if self.predictiveValueBehavior != nil {
                map["PredictiveValueBehavior"] = self.predictiveValueBehavior!
            }
            if self.predictiveValueBuffer != nil {
                map["PredictiveValueBuffer"] = self.predictiveValueBuffer!
            }
            if self.scaleInEvaluationCount != nil {
                map["ScaleInEvaluationCount"] = self.scaleInEvaluationCount!
            }
            if self.scaleOutEvaluationCount != nil {
                map["ScaleOutEvaluationCount"] = self.scaleOutEvaluationCount!
            }
            if self.scalingGroupId != nil {
                map["ScalingGroupId"] = self.scalingGroupId!
            }
            if self.scalingRuleAri != nil {
                map["ScalingRuleAri"] = self.scalingRuleAri!
            }
            if self.scalingRuleId != nil {
                map["ScalingRuleId"] = self.scalingRuleId!
            }
            if self.scalingRuleName != nil {
                map["ScalingRuleName"] = self.scalingRuleName!
            }
            if self.scalingRuleType != nil {
                map["ScalingRuleType"] = self.scalingRuleType!
            }
            if self.stepAdjustments != nil {
                var tmp : [Any] = []
                for k in self.stepAdjustments! {
                    tmp.append(k.toMap())
                }
                map["StepAdjustments"] = tmp
            }
            if self.targetValue != nil {
                map["TargetValue"] = self.targetValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AdjustmentType"] as? String {
                self.adjustmentType = value
            }
            if let value = dict["AdjustmentValue"] as? Int32 {
                self.adjustmentValue = value
            }
            if let value = dict["AlarmDimensions"] as? [Any?] {
                var tmp : [DescribeScalingRulesResponseBody.ScalingRules.AlarmDimensions] = []
                for v in value {
                    if v != nil {
                        var model = DescribeScalingRulesResponseBody.ScalingRules.AlarmDimensions()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.alarmDimensions = tmp
            }
            if let value = dict["Alarms"] as? [Any?] {
                var tmp : [DescribeScalingRulesResponseBody.ScalingRules.Alarms] = []
                for v in value {
                    if v != nil {
                        var model = DescribeScalingRulesResponseBody.ScalingRules.Alarms()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.alarms = tmp
            }
            if let value = dict["Cooldown"] as? Int32 {
                self.cooldown = value
            }
            if let value = dict["DisableScaleIn"] as? Bool {
                self.disableScaleIn = value
            }
            if let value = dict["EstimatedInstanceWarmup"] as? Int32 {
                self.estimatedInstanceWarmup = value
            }
            if let value = dict["HybridMetrics"] as? [Any?] {
                var tmp : [DescribeScalingRulesResponseBody.ScalingRules.HybridMetrics] = []
                for v in value {
                    if v != nil {
                        var model = DescribeScalingRulesResponseBody.ScalingRules.HybridMetrics()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.hybridMetrics = tmp
            }
            if let value = dict["HybridMonitorNamespace"] as? String {
                self.hybridMonitorNamespace = value
            }
            if let value = dict["InitialMaxSize"] as? Int32 {
                self.initialMaxSize = value
            }
            if let value = dict["MaxSize"] as? Int32 {
                self.maxSize = value
            }
            if let value = dict["MetricName"] as? String {
                self.metricName = value
            }
            if let value = dict["MetricType"] as? String {
                self.metricType = value
            }
            if let value = dict["MinAdjustmentMagnitude"] as? Int32 {
                self.minAdjustmentMagnitude = value
            }
            if let value = dict["MinSize"] as? Int32 {
                self.minSize = value
            }
            if let value = dict["PredictiveScalingMode"] as? String {
                self.predictiveScalingMode = value
            }
            if let value = dict["PredictiveTaskBufferTime"] as? Int32 {
                self.predictiveTaskBufferTime = value
            }
            if let value = dict["PredictiveValueBehavior"] as? String {
                self.predictiveValueBehavior = value
            }
            if let value = dict["PredictiveValueBuffer"] as? Int32 {
                self.predictiveValueBuffer = value
            }
            if let value = dict["ScaleInEvaluationCount"] as? Int32 {
                self.scaleInEvaluationCount = value
            }
            if let value = dict["ScaleOutEvaluationCount"] as? Int32 {
                self.scaleOutEvaluationCount = value
            }
            if let value = dict["ScalingGroupId"] as? String {
                self.scalingGroupId = value
            }
            if let value = dict["ScalingRuleAri"] as? String {
                self.scalingRuleAri = value
            }
            if let value = dict["ScalingRuleId"] as? String {
                self.scalingRuleId = value
            }
            if let value = dict["ScalingRuleName"] as? String {
                self.scalingRuleName = value
            }
            if let value = dict["ScalingRuleType"] as? String {
                self.scalingRuleType = value
            }
            if let value = dict["StepAdjustments"] as? [Any?] {
                var tmp : [DescribeScalingRulesResponseBody.ScalingRules.StepAdjustments] = []
                for v in value {
                    if v != nil {
                        var model = DescribeScalingRulesResponseBody.ScalingRules.StepAdjustments()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.stepAdjustments = tmp
            }
            if let value = dict["TargetValue"] as? Double {
                self.targetValue = value
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var scalingRules: [DescribeScalingRulesResponseBody.ScalingRules]?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingRules != nil {
            var tmp : [Any] = []
            for k in self.scalingRules! {
                tmp.append(k.toMap())
            }
            map["ScalingRules"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ScalingRules"] as? [Any?] {
            var tmp : [DescribeScalingRulesResponseBody.ScalingRules] = []
            for v in value {
                if v != nil {
                    var model = DescribeScalingRulesResponseBody.ScalingRules()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.scalingRules = tmp
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeScalingRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeScalingRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeScalingRulesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeScheduledTasksRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var recurrenceType: String?

    public var recurrenceValue: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var scalingGroupId: String?

    public var scheduledActions: [String]?

    public var scheduledTaskIds: [String]?

    public var scheduledTaskNames: [String]?

    public var taskEnabled: Bool?

    public var taskName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.recurrenceType != nil {
            map["RecurrenceType"] = self.recurrenceType!
        }
        if self.recurrenceValue != nil {
            map["RecurrenceValue"] = self.recurrenceValue!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        if self.scheduledActions != nil {
            map["ScheduledActions"] = self.scheduledActions!
        }
        if self.scheduledTaskIds != nil {
            map["ScheduledTaskIds"] = self.scheduledTaskIds!
        }
        if self.scheduledTaskNames != nil {
            map["ScheduledTaskNames"] = self.scheduledTaskNames!
        }
        if self.taskEnabled != nil {
            map["TaskEnabled"] = self.taskEnabled!
        }
        if self.taskName != nil {
            map["TaskName"] = self.taskName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RecurrenceType"] as? String {
            self.recurrenceType = value
        }
        if let value = dict["RecurrenceValue"] as? String {
            self.recurrenceValue = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ScalingGroupId"] as? String {
            self.scalingGroupId = value
        }
        if let value = dict["ScheduledActions"] as? [String] {
            self.scheduledActions = value
        }
        if let value = dict["ScheduledTaskIds"] as? [String] {
            self.scheduledTaskIds = value
        }
        if let value = dict["ScheduledTaskNames"] as? [String] {
            self.scheduledTaskNames = value
        }
        if let value = dict["TaskEnabled"] as? Bool {
            self.taskEnabled = value
        }
        if let value = dict["TaskName"] as? String {
            self.taskName = value
        }
    }
}

public class DescribeScheduledTasksResponseBody : Tea.TeaModel {
    public class ScheduledTasks : Tea.TeaModel {
        public var description_: String?

        public var desiredCapacity: Int32?

        public var launchExpirationTime: Int32?

        public var launchTime: String?

        public var maxValue: Int32?

        public var minValue: Int32?

        public var recurrenceEndTime: String?

        public var recurrenceType: String?

        public var recurrenceValue: String?

        public var scalingGroupId: String?

        public var scheduledAction: String?

        public var scheduledTaskId: String?

        public var scheduledTaskName: String?

        public var taskEnabled: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.desiredCapacity != nil {
                map["DesiredCapacity"] = self.desiredCapacity!
            }
            if self.launchExpirationTime != nil {
                map["LaunchExpirationTime"] = self.launchExpirationTime!
            }
            if self.launchTime != nil {
                map["LaunchTime"] = self.launchTime!
            }
            if self.maxValue != nil {
                map["MaxValue"] = self.maxValue!
            }
            if self.minValue != nil {
                map["MinValue"] = self.minValue!
            }
            if self.recurrenceEndTime != nil {
                map["RecurrenceEndTime"] = self.recurrenceEndTime!
            }
            if self.recurrenceType != nil {
                map["RecurrenceType"] = self.recurrenceType!
            }
            if self.recurrenceValue != nil {
                map["RecurrenceValue"] = self.recurrenceValue!
            }
            if self.scalingGroupId != nil {
                map["ScalingGroupId"] = self.scalingGroupId!
            }
            if self.scheduledAction != nil {
                map["ScheduledAction"] = self.scheduledAction!
            }
            if self.scheduledTaskId != nil {
                map["ScheduledTaskId"] = self.scheduledTaskId!
            }
            if self.scheduledTaskName != nil {
                map["ScheduledTaskName"] = self.scheduledTaskName!
            }
            if self.taskEnabled != nil {
                map["TaskEnabled"] = self.taskEnabled!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["DesiredCapacity"] as? Int32 {
                self.desiredCapacity = value
            }
            if let value = dict["LaunchExpirationTime"] as? Int32 {
                self.launchExpirationTime = value
            }
            if let value = dict["LaunchTime"] as? String {
                self.launchTime = value
            }
            if let value = dict["MaxValue"] as? Int32 {
                self.maxValue = value
            }
            if let value = dict["MinValue"] as? Int32 {
                self.minValue = value
            }
            if let value = dict["RecurrenceEndTime"] as? String {
                self.recurrenceEndTime = value
            }
            if let value = dict["RecurrenceType"] as? String {
                self.recurrenceType = value
            }
            if let value = dict["RecurrenceValue"] as? String {
                self.recurrenceValue = value
            }
            if let value = dict["ScalingGroupId"] as? String {
                self.scalingGroupId = value
            }
            if let value = dict["ScheduledAction"] as? String {
                self.scheduledAction = value
            }
            if let value = dict["ScheduledTaskId"] as? String {
                self.scheduledTaskId = value
            }
            if let value = dict["ScheduledTaskName"] as? String {
                self.scheduledTaskName = value
            }
            if let value = dict["TaskEnabled"] as? Bool {
                self.taskEnabled = value
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var scheduledTasks: [DescribeScheduledTasksResponseBody.ScheduledTasks]?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scheduledTasks != nil {
            var tmp : [Any] = []
            for k in self.scheduledTasks! {
                tmp.append(k.toMap())
            }
            map["ScheduledTasks"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ScheduledTasks"] as? [Any?] {
            var tmp : [DescribeScheduledTasksResponseBody.ScheduledTasks] = []
            for v in value {
                if v != nil {
                    var model = DescribeScheduledTasksResponseBody.ScheduledTasks()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.scheduledTasks = tmp
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeScheduledTasksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeScheduledTasksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeScheduledTasksResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DetachAlbServerGroupsRequest : Tea.TeaModel {
    public class AlbServerGroups : Tea.TeaModel {
        public var albServerGroupId: String?

        public var port: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.albServerGroupId != nil {
                map["AlbServerGroupId"] = self.albServerGroupId!
            }
            if self.port != nil {
                map["Port"] = self.port!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AlbServerGroupId"] as? String {
                self.albServerGroupId = value
            }
            if let value = dict["Port"] as? Int32 {
                self.port = value
            }
        }
    }
    public var albServerGroups: [DetachAlbServerGroupsRequest.AlbServerGroups]?

    public var clientToken: String?

    public var forceDetach: Bool?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.albServerGroups != nil {
            var tmp : [Any] = []
            for k in self.albServerGroups! {
                tmp.append(k.toMap())
            }
            map["AlbServerGroups"] = tmp
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.forceDetach != nil {
            map["ForceDetach"] = self.forceDetach!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AlbServerGroups"] as? [Any?] {
            var tmp : [DetachAlbServerGroupsRequest.AlbServerGroups] = []
            for v in value {
                if v != nil {
                    var model = DetachAlbServerGroupsRequest.AlbServerGroups()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.albServerGroups = tmp
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["ForceDetach"] as? Bool {
            self.forceDetach = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ScalingGroupId"] as? String {
            self.scalingGroupId = value
        }
    }
}

public class DetachAlbServerGroupsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var scalingActivityId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingActivityId != nil {
            map["ScalingActivityId"] = self.scalingActivityId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ScalingActivityId"] as? String {
            self.scalingActivityId = value
        }
    }
}

public class DetachAlbServerGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DetachAlbServerGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DetachAlbServerGroupsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DetachDBInstancesRequest : Tea.TeaModel {
    public var clientToken: String?

    public var DBInstances: [String]?

    public var forceDetach: Bool?

    public var ownerId: Int64?

    public var regionId: String?

    public var removeSecurityGroup: Bool?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.DBInstances != nil {
            map["DBInstances"] = self.DBInstances!
        }
        if self.forceDetach != nil {
            map["ForceDetach"] = self.forceDetach!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.removeSecurityGroup != nil {
            map["RemoveSecurityGroup"] = self.removeSecurityGroup!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DBInstances"] as? [String] {
            self.DBInstances = value
        }
        if let value = dict["ForceDetach"] as? Bool {
            self.forceDetach = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RemoveSecurityGroup"] as? Bool {
            self.removeSecurityGroup = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ScalingGroupId"] as? String {
            self.scalingGroupId = value
        }
    }
}

public class DetachDBInstancesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DetachDBInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DetachDBInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DetachDBInstancesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DetachInstancesRequest : Tea.TeaModel {
    public var clientToken: String?

    public var decreaseDesiredCapacity: Bool?

    public var detachOption: String?

    public var ignoreInvalidInstance: Bool?

    public var instanceIds: [String]?

    public var lifecycleHook: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.decreaseDesiredCapacity != nil {
            map["DecreaseDesiredCapacity"] = self.decreaseDesiredCapacity!
        }
        if self.detachOption != nil {
            map["DetachOption"] = self.detachOption!
        }
        if self.ignoreInvalidInstance != nil {
            map["IgnoreInvalidInstance"] = self.ignoreInvalidInstance!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.lifecycleHook != nil {
            map["LifecycleHook"] = self.lifecycleHook!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DecreaseDesiredCapacity"] as? Bool {
            self.decreaseDesiredCapacity = value
        }
        if let value = dict["DetachOption"] as? String {
            self.detachOption = value
        }
        if let value = dict["IgnoreInvalidInstance"] as? Bool {
            self.ignoreInvalidInstance = value
        }
        if let value = dict["InstanceIds"] as? [String] {
            self.instanceIds = value
        }
        if let value = dict["LifecycleHook"] as? Bool {
            self.lifecycleHook = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ScalingGroupId"] as? String {
            self.scalingGroupId = value
        }
    }
}

public class DetachInstancesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var scalingActivityId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingActivityId != nil {
            map["ScalingActivityId"] = self.scalingActivityId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ScalingActivityId"] as? String {
            self.scalingActivityId = value
        }
    }
}

public class DetachInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DetachInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DetachInstancesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DetachLoadBalancersRequest : Tea.TeaModel {
    public var async: Bool?

    public var clientToken: String?

    public var forceDetach: Bool?

    public var loadBalancers: [String]?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.async != nil {
            map["Async"] = self.async!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.forceDetach != nil {
            map["ForceDetach"] = self.forceDetach!
        }
        if self.loadBalancers != nil {
            map["LoadBalancers"] = self.loadBalancers!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Async"] as? Bool {
            self.async = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["ForceDetach"] as? Bool {
            self.forceDetach = value
        }
        if let value = dict["LoadBalancers"] as? [String] {
            self.loadBalancers = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ScalingGroupId"] as? String {
            self.scalingGroupId = value
        }
    }
}

public class DetachLoadBalancersResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var scalingActivityId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingActivityId != nil {
            map["ScalingActivityId"] = self.scalingActivityId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ScalingActivityId"] as? String {
            self.scalingActivityId = value
        }
    }
}

public class DetachLoadBalancersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DetachLoadBalancersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DetachLoadBalancersResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DetachServerGroupsRequest : Tea.TeaModel {
    public class ServerGroups : Tea.TeaModel {
        public var port: Int32?

        public var serverGroupId: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.port != nil {
                map["Port"] = self.port!
            }
            if self.serverGroupId != nil {
                map["ServerGroupId"] = self.serverGroupId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Port"] as? Int32 {
                self.port = value
            }
            if let value = dict["ServerGroupId"] as? String {
                self.serverGroupId = value
            }
            if let value = dict["Type"] as? String {
                self.type = value
            }
        }
    }
    public var clientToken: String?

    public var forceDetach: Bool?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public var serverGroups: [DetachServerGroupsRequest.ServerGroups]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.forceDetach != nil {
            map["ForceDetach"] = self.forceDetach!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        if self.serverGroups != nil {
            var tmp : [Any] = []
            for k in self.serverGroups! {
                tmp.append(k.toMap())
            }
            map["ServerGroups"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["ForceDetach"] as? Bool {
            self.forceDetach = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ScalingGroupId"] as? String {
            self.scalingGroupId = value
        }
        if let value = dict["ServerGroups"] as? [Any?] {
            var tmp : [DetachServerGroupsRequest.ServerGroups] = []
            for v in value {
                if v != nil {
                    var model = DetachServerGroupsRequest.ServerGroups()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.serverGroups = tmp
        }
    }
}

public class DetachServerGroupsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var scalingActivityId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingActivityId != nil {
            map["ScalingActivityId"] = self.scalingActivityId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ScalingActivityId"] as? String {
            self.scalingActivityId = value
        }
    }
}

public class DetachServerGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DetachServerGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DetachServerGroupsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DetachVServerGroupsRequest : Tea.TeaModel {
    public class VServerGroups : Tea.TeaModel {
        public class VServerGroupAttributes : Tea.TeaModel {
            public var port: Int32?

            public var VServerGroupId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.VServerGroupId != nil {
                    map["VServerGroupId"] = self.VServerGroupId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Port"] as? Int32 {
                    self.port = value
                }
                if let value = dict["VServerGroupId"] as? String {
                    self.VServerGroupId = value
                }
            }
        }
        public var loadBalancerId: String?

        public var VServerGroupAttributes: [DetachVServerGroupsRequest.VServerGroups.VServerGroupAttributes]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.loadBalancerId != nil {
                map["LoadBalancerId"] = self.loadBalancerId!
            }
            if self.VServerGroupAttributes != nil {
                var tmp : [Any] = []
                for k in self.VServerGroupAttributes! {
                    tmp.append(k.toMap())
                }
                map["VServerGroupAttributes"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["LoadBalancerId"] as? String {
                self.loadBalancerId = value
            }
            if let value = dict["VServerGroupAttributes"] as? [Any?] {
                var tmp : [DetachVServerGroupsRequest.VServerGroups.VServerGroupAttributes] = []
                for v in value {
                    if v != nil {
                        var model = DetachVServerGroupsRequest.VServerGroups.VServerGroupAttributes()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.VServerGroupAttributes = tmp
            }
        }
    }
    public var clientToken: String?

    public var forceDetach: Bool?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public var VServerGroups: [DetachVServerGroupsRequest.VServerGroups]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.forceDetach != nil {
            map["ForceDetach"] = self.forceDetach!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        if self.VServerGroups != nil {
            var tmp : [Any] = []
            for k in self.VServerGroups! {
                tmp.append(k.toMap())
            }
            map["VServerGroups"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["ForceDetach"] as? Bool {
            self.forceDetach = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ScalingGroupId"] as? String {
            self.scalingGroupId = value
        }
        if let value = dict["VServerGroups"] as? [Any?] {
            var tmp : [DetachVServerGroupsRequest.VServerGroups] = []
            for v in value {
                if v != nil {
                    var model = DetachVServerGroupsRequest.VServerGroups()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.VServerGroups = tmp
        }
    }
}

public class DetachVServerGroupsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DetachVServerGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DetachVServerGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DetachVServerGroupsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DisableAlarmRequest : Tea.TeaModel {
    public var alarmTaskId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alarmTaskId != nil {
            map["AlarmTaskId"] = self.alarmTaskId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AlarmTaskId"] as? String {
            self.alarmTaskId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
    }
}

public class DisableAlarmResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DisableAlarmResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DisableAlarmResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DisableAlarmResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DisableScalingGroupRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ScalingGroupId"] as? String {
            self.scalingGroupId = value
        }
    }
}

public class DisableScalingGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DisableScalingGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DisableScalingGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DisableScalingGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class EnableAlarmRequest : Tea.TeaModel {
    public var alarmTaskId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alarmTaskId != nil {
            map["AlarmTaskId"] = self.alarmTaskId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AlarmTaskId"] as? String {
            self.alarmTaskId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
    }
}

public class EnableAlarmResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class EnableAlarmResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EnableAlarmResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = EnableAlarmResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class EnableScalingGroupRequest : Tea.TeaModel {
    public class LaunchTemplateOverrides : Tea.TeaModel {
        public var instanceType: String?

        public var weightedCapacity: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.weightedCapacity != nil {
                map["WeightedCapacity"] = self.weightedCapacity!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["InstanceType"] as? String {
                self.instanceType = value
            }
            if let value = dict["WeightedCapacity"] as? Int32 {
                self.weightedCapacity = value
            }
        }
    }
    public var activeScalingConfigurationId: String?

    public var instanceIds: [String]?

    public var launchTemplateId: String?

    public var launchTemplateOverrides: [EnableScalingGroupRequest.LaunchTemplateOverrides]?

    public var launchTemplateVersion: String?

    public var loadBalancerWeights: [Int32]?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.activeScalingConfigurationId != nil {
            map["ActiveScalingConfigurationId"] = self.activeScalingConfigurationId!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.launchTemplateId != nil {
            map["LaunchTemplateId"] = self.launchTemplateId!
        }
        if self.launchTemplateOverrides != nil {
            var tmp : [Any] = []
            for k in self.launchTemplateOverrides! {
                tmp.append(k.toMap())
            }
            map["LaunchTemplateOverrides"] = tmp
        }
        if self.launchTemplateVersion != nil {
            map["LaunchTemplateVersion"] = self.launchTemplateVersion!
        }
        if self.loadBalancerWeights != nil {
            map["LoadBalancerWeights"] = self.loadBalancerWeights!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ActiveScalingConfigurationId"] as? String {
            self.activeScalingConfigurationId = value
        }
        if let value = dict["InstanceIds"] as? [String] {
            self.instanceIds = value
        }
        if let value = dict["LaunchTemplateId"] as? String {
            self.launchTemplateId = value
        }
        if let value = dict["LaunchTemplateOverrides"] as? [Any?] {
            var tmp : [EnableScalingGroupRequest.LaunchTemplateOverrides] = []
            for v in value {
                if v != nil {
                    var model = EnableScalingGroupRequest.LaunchTemplateOverrides()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.launchTemplateOverrides = tmp
        }
        if let value = dict["LaunchTemplateVersion"] as? String {
            self.launchTemplateVersion = value
        }
        if let value = dict["LoadBalancerWeights"] as? [Int32] {
            self.loadBalancerWeights = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ScalingGroupId"] as? String {
            self.scalingGroupId = value
        }
    }
}

public class EnableScalingGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class EnableScalingGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EnableScalingGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = EnableScalingGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class EnterStandbyRequest : Tea.TeaModel {
    public var async: Bool?

    public var clientToken: String?

    public var instanceIds: [String]?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.async != nil {
            map["Async"] = self.async!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Async"] as? Bool {
            self.async = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["InstanceIds"] as? [String] {
            self.instanceIds = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ScalingGroupId"] as? String {
            self.scalingGroupId = value
        }
    }
}

public class EnterStandbyResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var scalingActivityId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingActivityId != nil {
            map["ScalingActivityId"] = self.scalingActivityId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ScalingActivityId"] as? String {
            self.scalingActivityId = value
        }
    }
}

public class EnterStandbyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EnterStandbyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = EnterStandbyResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ExecuteScalingRuleRequest : Tea.TeaModel {
    public var breachThreshold: Double?

    public var clientToken: String?

    public var metricValue: Double?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var scalingRuleAri: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.breachThreshold != nil {
            map["BreachThreshold"] = self.breachThreshold!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.metricValue != nil {
            map["MetricValue"] = self.metricValue!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.scalingRuleAri != nil {
            map["ScalingRuleAri"] = self.scalingRuleAri!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BreachThreshold"] as? Double {
            self.breachThreshold = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["MetricValue"] as? Double {
            self.metricValue = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ScalingRuleAri"] as? String {
            self.scalingRuleAri = value
        }
    }
}

public class ExecuteScalingRuleResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var scalingActivityId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingActivityId != nil {
            map["ScalingActivityId"] = self.scalingActivityId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ScalingActivityId"] as? String {
            self.scalingActivityId = value
        }
    }
}

public class ExecuteScalingRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ExecuteScalingRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ExecuteScalingRuleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ExitStandbyRequest : Tea.TeaModel {
    public var async: Bool?

    public var clientToken: String?

    public var instanceIds: [String]?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.async != nil {
            map["Async"] = self.async!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Async"] as? Bool {
            self.async = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["InstanceIds"] as? [String] {
            self.instanceIds = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ScalingGroupId"] as? String {
            self.scalingGroupId = value
        }
    }
}

public class ExitStandbyResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var scalingActivityId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingActivityId != nil {
            map["ScalingActivityId"] = self.scalingActivityId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ScalingActivityId"] as? String {
            self.scalingActivityId = value
        }
    }
}

public class ExitStandbyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ExitStandbyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ExitStandbyResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListTagKeysRequest : Tea.TeaModel {
    public var nextToken: String?

    public var ownerId: Int64?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
    }
}

public class ListTagKeysResponseBody : Tea.TeaModel {
    public var keys: [String]?

    public var nextToken: String?

    public var pageSize: Int32?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.keys != nil {
            map["Keys"] = self.keys!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Keys"] as? [String] {
            self.keys = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListTagKeysResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTagKeysResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListTagKeysResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListTagResourcesRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var nextToken: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceIds: [String]?

    public var resourceOwnerAccount: String?

    public var resourceType: String?

    public var tags: [ListTagResourcesRequest.Tags]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceIds != nil {
            map["ResourceIds"] = self.resourceIds!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceIds"] as? [String] {
            self.resourceIds = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
        if let value = dict["Tags"] as? [Any?] {
            var tmp : [ListTagResourcesRequest.Tags] = []
            for v in value {
                if v != nil {
                    var model = ListTagResourcesRequest.Tags()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tags = tmp
        }
    }
}

public class ListTagResourcesResponseBody : Tea.TeaModel {
    public class TagResources : Tea.TeaModel {
        public var propagate: Bool?

        public var resourceId: String?

        public var resourceType: String?

        public var tagKey: String?

        public var tagValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.propagate != nil {
                map["Propagate"] = self.propagate!
            }
            if self.resourceId != nil {
                map["ResourceId"] = self.resourceId!
            }
            if self.resourceType != nil {
                map["ResourceType"] = self.resourceType!
            }
            if self.tagKey != nil {
                map["TagKey"] = self.tagKey!
            }
            if self.tagValue != nil {
                map["TagValue"] = self.tagValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Propagate"] as? Bool {
                self.propagate = value
            }
            if let value = dict["ResourceId"] as? String {
                self.resourceId = value
            }
            if let value = dict["ResourceType"] as? String {
                self.resourceType = value
            }
            if let value = dict["TagKey"] as? String {
                self.tagKey = value
            }
            if let value = dict["TagValue"] as? String {
                self.tagValue = value
            }
        }
    }
    public var nextToken: String?

    public var requestId: String?

    public var tagResources: [ListTagResourcesResponseBody.TagResources]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.tagResources != nil {
            var tmp : [Any] = []
            for k in self.tagResources! {
                tmp.append(k.toMap())
            }
            map["TagResources"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TagResources"] as? [Any?] {
            var tmp : [ListTagResourcesResponseBody.TagResources] = []
            for v in value {
                if v != nil {
                    var model = ListTagResourcesResponseBody.TagResources()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tagResources = tmp
        }
    }
}

public class ListTagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListTagResourcesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListTagValuesRequest : Tea.TeaModel {
    public var key: String?

    public var nextToken: String?

    public var ownerId: Int64?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.key != nil {
            map["Key"] = self.key!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Key"] as? String {
            self.key = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
    }
}

public class ListTagValuesResponseBody : Tea.TeaModel {
    public var nextToken: String?

    public var pageSize: Int32?

    public var requestId: String?

    public var values: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.values != nil {
            map["Values"] = self.values!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Values"] as? [String] {
            self.values = value
        }
    }
}

public class ListTagValuesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTagValuesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListTagValuesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyAlarmRequest : Tea.TeaModel {
    public class Dimensions : Tea.TeaModel {
        public var dimensionKey: String?

        public var dimensionValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dimensionKey != nil {
                map["DimensionKey"] = self.dimensionKey!
            }
            if self.dimensionValue != nil {
                map["DimensionValue"] = self.dimensionValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DimensionKey"] as? String {
                self.dimensionKey = value
            }
            if let value = dict["DimensionValue"] as? String {
                self.dimensionValue = value
            }
        }
    }
    public class Expressions : Tea.TeaModel {
        public var comparisonOperator: String?

        public var metricName: String?

        public var period: Int32?

        public var statistics: String?

        public var threshold: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.comparisonOperator != nil {
                map["ComparisonOperator"] = self.comparisonOperator!
            }
            if self.metricName != nil {
                map["MetricName"] = self.metricName!
            }
            if self.period != nil {
                map["Period"] = self.period!
            }
            if self.statistics != nil {
                map["Statistics"] = self.statistics!
            }
            if self.threshold != nil {
                map["Threshold"] = self.threshold!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ComparisonOperator"] as? String {
                self.comparisonOperator = value
            }
            if let value = dict["MetricName"] as? String {
                self.metricName = value
            }
            if let value = dict["Period"] as? Int32 {
                self.period = value
            }
            if let value = dict["Statistics"] as? String {
                self.statistics = value
            }
            if let value = dict["Threshold"] as? Double {
                self.threshold = value
            }
        }
    }
    public var alarmActions: [String]?

    public var alarmTaskId: String?

    public var comparisonOperator: String?

    public var description_: String?

    public var dimensions: [ModifyAlarmRequest.Dimensions]?

    public var effective: String?

    public var evaluationCount: Int32?

    public var expressions: [ModifyAlarmRequest.Expressions]?

    public var expressionsLogicOperator: String?

    public var groupId: Int32?

    public var metricName: String?

    public var metricType: String?

    public var name: String?

    public var ownerId: Int64?

    public var period: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var statistics: String?

    public var threshold: Double?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alarmActions != nil {
            map["AlarmActions"] = self.alarmActions!
        }
        if self.alarmTaskId != nil {
            map["AlarmTaskId"] = self.alarmTaskId!
        }
        if self.comparisonOperator != nil {
            map["ComparisonOperator"] = self.comparisonOperator!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.dimensions != nil {
            var tmp : [Any] = []
            for k in self.dimensions! {
                tmp.append(k.toMap())
            }
            map["Dimensions"] = tmp
        }
        if self.effective != nil {
            map["Effective"] = self.effective!
        }
        if self.evaluationCount != nil {
            map["EvaluationCount"] = self.evaluationCount!
        }
        if self.expressions != nil {
            var tmp : [Any] = []
            for k in self.expressions! {
                tmp.append(k.toMap())
            }
            map["Expressions"] = tmp
        }
        if self.expressionsLogicOperator != nil {
            map["ExpressionsLogicOperator"] = self.expressionsLogicOperator!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.metricName != nil {
            map["MetricName"] = self.metricName!
        }
        if self.metricType != nil {
            map["MetricType"] = self.metricType!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.statistics != nil {
            map["Statistics"] = self.statistics!
        }
        if self.threshold != nil {
            map["Threshold"] = self.threshold!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AlarmActions"] as? [String] {
            self.alarmActions = value
        }
        if let value = dict["AlarmTaskId"] as? String {
            self.alarmTaskId = value
        }
        if let value = dict["ComparisonOperator"] as? String {
            self.comparisonOperator = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["Dimensions"] as? [Any?] {
            var tmp : [ModifyAlarmRequest.Dimensions] = []
            for v in value {
                if v != nil {
                    var model = ModifyAlarmRequest.Dimensions()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.dimensions = tmp
        }
        if let value = dict["Effective"] as? String {
            self.effective = value
        }
        if let value = dict["EvaluationCount"] as? Int32 {
            self.evaluationCount = value
        }
        if let value = dict["Expressions"] as? [Any?] {
            var tmp : [ModifyAlarmRequest.Expressions] = []
            for v in value {
                if v != nil {
                    var model = ModifyAlarmRequest.Expressions()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.expressions = tmp
        }
        if let value = dict["ExpressionsLogicOperator"] as? String {
            self.expressionsLogicOperator = value
        }
        if let value = dict["GroupId"] as? Int32 {
            self.groupId = value
        }
        if let value = dict["MetricName"] as? String {
            self.metricName = value
        }
        if let value = dict["MetricType"] as? String {
            self.metricType = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Period"] as? Int32 {
            self.period = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["Statistics"] as? String {
            self.statistics = value
        }
        if let value = dict["Threshold"] as? Double {
            self.threshold = value
        }
    }
}

public class ModifyAlarmResponseBody : Tea.TeaModel {
    public var alarmTaskId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alarmTaskId != nil {
            map["AlarmTaskId"] = self.alarmTaskId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AlarmTaskId"] as? String {
            self.alarmTaskId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyAlarmResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyAlarmResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyAlarmResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyAlertConfigurationRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scaleStatuses: [String]?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scaleStatuses != nil {
            map["ScaleStatuses"] = self.scaleStatuses!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ScaleStatuses"] as? [String] {
            self.scaleStatuses = value
        }
        if let value = dict["ScalingGroupId"] as? String {
            self.scalingGroupId = value
        }
    }
}

public class ModifyAlertConfigurationResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyAlertConfigurationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyAlertConfigurationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyAlertConfigurationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyEciScalingConfigurationRequest : Tea.TeaModel {
    public class AcrRegistryInfos : Tea.TeaModel {
        public var domains: [String]?

        public var instanceId: String?

        public var instanceName: String?

        public var regionId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.domains != nil {
                map["Domains"] = self.domains!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Domains"] as? [String] {
                self.domains = value
            }
            if let value = dict["InstanceId"] as? String {
                self.instanceId = value
            }
            if let value = dict["InstanceName"] as? String {
                self.instanceName = value
            }
            if let value = dict["RegionId"] as? String {
                self.regionId = value
            }
        }
    }
    public class Containers : Tea.TeaModel {
        public class LivenessProbe : Tea.TeaModel {
            public class Exec : Tea.TeaModel {
                public var commands: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.commands != nil {
                        map["Commands"] = self.commands!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Commands"] as? [String] {
                        self.commands = value
                    }
                }
            }
            public class HttpGet : Tea.TeaModel {
                public var path: String?

                public var port: Int32?

                public var scheme: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.path != nil {
                        map["Path"] = self.path!
                    }
                    if self.port != nil {
                        map["Port"] = self.port!
                    }
                    if self.scheme != nil {
                        map["Scheme"] = self.scheme!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Path"] as? String {
                        self.path = value
                    }
                    if let value = dict["Port"] as? Int32 {
                        self.port = value
                    }
                    if let value = dict["Scheme"] as? String {
                        self.scheme = value
                    }
                }
            }
            public class TcpSocket : Tea.TeaModel {
                public var port: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.port != nil {
                        map["Port"] = self.port!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Port"] as? Int32 {
                        self.port = value
                    }
                }
            }
            public var exec: ModifyEciScalingConfigurationRequest.Containers.LivenessProbe.Exec?

            public var failureThreshold: Int32?

            public var httpGet: ModifyEciScalingConfigurationRequest.Containers.LivenessProbe.HttpGet?

            public var initialDelaySeconds: Int32?

            public var periodSeconds: Int32?

            public var successThreshold: Int32?

            public var tcpSocket: ModifyEciScalingConfigurationRequest.Containers.LivenessProbe.TcpSocket?

            public var timeoutSeconds: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.exec?.validate()
                try self.httpGet?.validate()
                try self.tcpSocket?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.exec != nil {
                    map["Exec"] = self.exec?.toMap()
                }
                if self.failureThreshold != nil {
                    map["FailureThreshold"] = self.failureThreshold!
                }
                if self.httpGet != nil {
                    map["HttpGet"] = self.httpGet?.toMap()
                }
                if self.initialDelaySeconds != nil {
                    map["InitialDelaySeconds"] = self.initialDelaySeconds!
                }
                if self.periodSeconds != nil {
                    map["PeriodSeconds"] = self.periodSeconds!
                }
                if self.successThreshold != nil {
                    map["SuccessThreshold"] = self.successThreshold!
                }
                if self.tcpSocket != nil {
                    map["TcpSocket"] = self.tcpSocket?.toMap()
                }
                if self.timeoutSeconds != nil {
                    map["TimeoutSeconds"] = self.timeoutSeconds!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Exec"] as? [String: Any?] {
                    var model = ModifyEciScalingConfigurationRequest.Containers.LivenessProbe.Exec()
                    model.fromMap(value)
                    self.exec = model
                }
                if let value = dict["FailureThreshold"] as? Int32 {
                    self.failureThreshold = value
                }
                if let value = dict["HttpGet"] as? [String: Any?] {
                    var model = ModifyEciScalingConfigurationRequest.Containers.LivenessProbe.HttpGet()
                    model.fromMap(value)
                    self.httpGet = model
                }
                if let value = dict["InitialDelaySeconds"] as? Int32 {
                    self.initialDelaySeconds = value
                }
                if let value = dict["PeriodSeconds"] as? Int32 {
                    self.periodSeconds = value
                }
                if let value = dict["SuccessThreshold"] as? Int32 {
                    self.successThreshold = value
                }
                if let value = dict["TcpSocket"] as? [String: Any?] {
                    var model = ModifyEciScalingConfigurationRequest.Containers.LivenessProbe.TcpSocket()
                    model.fromMap(value)
                    self.tcpSocket = model
                }
                if let value = dict["TimeoutSeconds"] as? Int32 {
                    self.timeoutSeconds = value
                }
            }
        }
        public class ReadinessProbe : Tea.TeaModel {
            public class Exec : Tea.TeaModel {
                public var commands: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.commands != nil {
                        map["Commands"] = self.commands!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Commands"] as? [String] {
                        self.commands = value
                    }
                }
            }
            public class HttpGet : Tea.TeaModel {
                public var path: String?

                public var port: Int32?

                public var scheme: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.path != nil {
                        map["Path"] = self.path!
                    }
                    if self.port != nil {
                        map["Port"] = self.port!
                    }
                    if self.scheme != nil {
                        map["Scheme"] = self.scheme!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Path"] as? String {
                        self.path = value
                    }
                    if let value = dict["Port"] as? Int32 {
                        self.port = value
                    }
                    if let value = dict["Scheme"] as? String {
                        self.scheme = value
                    }
                }
            }
            public class TcpSocket : Tea.TeaModel {
                public var port: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.port != nil {
                        map["Port"] = self.port!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Port"] as? Int32 {
                        self.port = value
                    }
                }
            }
            public var exec: ModifyEciScalingConfigurationRequest.Containers.ReadinessProbe.Exec?

            public var failureThreshold: Int32?

            public var httpGet: ModifyEciScalingConfigurationRequest.Containers.ReadinessProbe.HttpGet?

            public var initialDelaySeconds: Int32?

            public var periodSeconds: Int32?

            public var successThreshold: Int32?

            public var tcpSocket: ModifyEciScalingConfigurationRequest.Containers.ReadinessProbe.TcpSocket?

            public var timeoutSeconds: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.exec?.validate()
                try self.httpGet?.validate()
                try self.tcpSocket?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.exec != nil {
                    map["Exec"] = self.exec?.toMap()
                }
                if self.failureThreshold != nil {
                    map["FailureThreshold"] = self.failureThreshold!
                }
                if self.httpGet != nil {
                    map["HttpGet"] = self.httpGet?.toMap()
                }
                if self.initialDelaySeconds != nil {
                    map["InitialDelaySeconds"] = self.initialDelaySeconds!
                }
                if self.periodSeconds != nil {
                    map["PeriodSeconds"] = self.periodSeconds!
                }
                if self.successThreshold != nil {
                    map["SuccessThreshold"] = self.successThreshold!
                }
                if self.tcpSocket != nil {
                    map["TcpSocket"] = self.tcpSocket?.toMap()
                }
                if self.timeoutSeconds != nil {
                    map["TimeoutSeconds"] = self.timeoutSeconds!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Exec"] as? [String: Any?] {
                    var model = ModifyEciScalingConfigurationRequest.Containers.ReadinessProbe.Exec()
                    model.fromMap(value)
                    self.exec = model
                }
                if let value = dict["FailureThreshold"] as? Int32 {
                    self.failureThreshold = value
                }
                if let value = dict["HttpGet"] as? [String: Any?] {
                    var model = ModifyEciScalingConfigurationRequest.Containers.ReadinessProbe.HttpGet()
                    model.fromMap(value)
                    self.httpGet = model
                }
                if let value = dict["InitialDelaySeconds"] as? Int32 {
                    self.initialDelaySeconds = value
                }
                if let value = dict["PeriodSeconds"] as? Int32 {
                    self.periodSeconds = value
                }
                if let value = dict["SuccessThreshold"] as? Int32 {
                    self.successThreshold = value
                }
                if let value = dict["TcpSocket"] as? [String: Any?] {
                    var model = ModifyEciScalingConfigurationRequest.Containers.ReadinessProbe.TcpSocket()
                    model.fromMap(value)
                    self.tcpSocket = model
                }
                if let value = dict["TimeoutSeconds"] as? Int32 {
                    self.timeoutSeconds = value
                }
            }
        }
        public class SecurityContext : Tea.TeaModel {
            public class Capability : Tea.TeaModel {
                public var adds: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.adds != nil {
                        map["Adds"] = self.adds!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Adds"] as? [String] {
                        self.adds = value
                    }
                }
            }
            public var capability: ModifyEciScalingConfigurationRequest.Containers.SecurityContext.Capability?

            public var readOnlyRootFilesystem: Bool?

            public var runAsUser: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.capability?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.capability != nil {
                    map["Capability"] = self.capability?.toMap()
                }
                if self.readOnlyRootFilesystem != nil {
                    map["ReadOnlyRootFilesystem"] = self.readOnlyRootFilesystem!
                }
                if self.runAsUser != nil {
                    map["RunAsUser"] = self.runAsUser!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Capability"] as? [String: Any?] {
                    var model = ModifyEciScalingConfigurationRequest.Containers.SecurityContext.Capability()
                    model.fromMap(value)
                    self.capability = model
                }
                if let value = dict["ReadOnlyRootFilesystem"] as? Bool {
                    self.readOnlyRootFilesystem = value
                }
                if let value = dict["RunAsUser"] as? Int64 {
                    self.runAsUser = value
                }
            }
        }
        public class EnvironmentVars : Tea.TeaModel {
            public class FieldRef : Tea.TeaModel {
                public var fieldPath: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.fieldPath != nil {
                        map["FieldPath"] = self.fieldPath!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["FieldPath"] as? String {
                        self.fieldPath = value
                    }
                }
            }
            public var fieldRef: ModifyEciScalingConfigurationRequest.Containers.EnvironmentVars.FieldRef?

            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.fieldRef?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fieldRef != nil {
                    map["FieldRef"] = self.fieldRef?.toMap()
                }
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["FieldRef"] as? [String: Any?] {
                    var model = ModifyEciScalingConfigurationRequest.Containers.EnvironmentVars.FieldRef()
                    model.fromMap(value)
                    self.fieldRef = model
                }
                if let value = dict["Key"] as? String {
                    self.key = value
                }
                if let value = dict["Value"] as? String {
                    self.value = value
                }
            }
        }
        public class Ports : Tea.TeaModel {
            public var port: Int32?

            public var protocol_: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.protocol_ != nil {
                    map["Protocol"] = self.protocol_!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Port"] as? Int32 {
                    self.port = value
                }
                if let value = dict["Protocol"] as? String {
                    self.protocol_ = value
                }
            }
        }
        public class VolumeMounts : Tea.TeaModel {
            public var mountPath: String?

            public var mountPropagation: String?

            public var name: String?

            public var readOnly: Bool?

            public var subPath: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.mountPath != nil {
                    map["MountPath"] = self.mountPath!
                }
                if self.mountPropagation != nil {
                    map["MountPropagation"] = self.mountPropagation!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.readOnly != nil {
                    map["ReadOnly"] = self.readOnly!
                }
                if self.subPath != nil {
                    map["SubPath"] = self.subPath!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["MountPath"] as? String {
                    self.mountPath = value
                }
                if let value = dict["MountPropagation"] as? String {
                    self.mountPropagation = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["ReadOnly"] as? Bool {
                    self.readOnly = value
                }
                if let value = dict["SubPath"] as? String {
                    self.subPath = value
                }
            }
        }
        public var livenessProbe: ModifyEciScalingConfigurationRequest.Containers.LivenessProbe?

        public var readinessProbe: ModifyEciScalingConfigurationRequest.Containers.ReadinessProbe?

        public var securityContext: ModifyEciScalingConfigurationRequest.Containers.SecurityContext?

        public var args: [String]?

        public var commands: [String]?

        public var cpu: Double?

        public var environmentVars: [ModifyEciScalingConfigurationRequest.Containers.EnvironmentVars]?

        public var gpu: Int32?

        public var image: String?

        public var imagePullPolicy: String?

        public var lifecyclePostStartHandlerExecs: [String]?

        public var lifecyclePostStartHandlerHttpGetHost: String?

        public var lifecyclePostStartHandlerHttpGetPath: String?

        public var lifecyclePostStartHandlerHttpGetPort: Int32?

        public var lifecyclePostStartHandlerHttpGetScheme: String?

        public var lifecyclePostStartHandlerTcpSocketHost: String?

        public var lifecyclePostStartHandlerTcpSocketPort: Int32?

        public var lifecyclePreStopHandlerExecs: [String]?

        public var lifecyclePreStopHandlerHttpGetHost: String?

        public var lifecyclePreStopHandlerHttpGetPath: String?

        public var lifecyclePreStopHandlerHttpGetPort: Int32?

        public var lifecyclePreStopHandlerHttpGetScheme: String?

        public var lifecyclePreStopHandlerTcpSocketHost: String?

        public var lifecyclePreStopHandlerTcpSocketPort: Int32?

        public var memory: Double?

        public var name: String?

        public var ports: [ModifyEciScalingConfigurationRequest.Containers.Ports]?

        public var stdin: Bool?

        public var stdinOnce: Bool?

        public var tty: Bool?

        public var volumeMounts: [ModifyEciScalingConfigurationRequest.Containers.VolumeMounts]?

        public var workingDir: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.livenessProbe?.validate()
            try self.readinessProbe?.validate()
            try self.securityContext?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.livenessProbe != nil {
                map["LivenessProbe"] = self.livenessProbe?.toMap()
            }
            if self.readinessProbe != nil {
                map["ReadinessProbe"] = self.readinessProbe?.toMap()
            }
            if self.securityContext != nil {
                map["SecurityContext"] = self.securityContext?.toMap()
            }
            if self.args != nil {
                map["Args"] = self.args!
            }
            if self.commands != nil {
                map["Commands"] = self.commands!
            }
            if self.cpu != nil {
                map["Cpu"] = self.cpu!
            }
            if self.environmentVars != nil {
                var tmp : [Any] = []
                for k in self.environmentVars! {
                    tmp.append(k.toMap())
                }
                map["EnvironmentVars"] = tmp
            }
            if self.gpu != nil {
                map["Gpu"] = self.gpu!
            }
            if self.image != nil {
                map["Image"] = self.image!
            }
            if self.imagePullPolicy != nil {
                map["ImagePullPolicy"] = self.imagePullPolicy!
            }
            if self.lifecyclePostStartHandlerExecs != nil {
                map["LifecyclePostStartHandlerExecs"] = self.lifecyclePostStartHandlerExecs!
            }
            if self.lifecyclePostStartHandlerHttpGetHost != nil {
                map["LifecyclePostStartHandlerHttpGetHost"] = self.lifecyclePostStartHandlerHttpGetHost!
            }
            if self.lifecyclePostStartHandlerHttpGetPath != nil {
                map["LifecyclePostStartHandlerHttpGetPath"] = self.lifecyclePostStartHandlerHttpGetPath!
            }
            if self.lifecyclePostStartHandlerHttpGetPort != nil {
                map["LifecyclePostStartHandlerHttpGetPort"] = self.lifecyclePostStartHandlerHttpGetPort!
            }
            if self.lifecyclePostStartHandlerHttpGetScheme != nil {
                map["LifecyclePostStartHandlerHttpGetScheme"] = self.lifecyclePostStartHandlerHttpGetScheme!
            }
            if self.lifecyclePostStartHandlerTcpSocketHost != nil {
                map["LifecyclePostStartHandlerTcpSocketHost"] = self.lifecyclePostStartHandlerTcpSocketHost!
            }
            if self.lifecyclePostStartHandlerTcpSocketPort != nil {
                map["LifecyclePostStartHandlerTcpSocketPort"] = self.lifecyclePostStartHandlerTcpSocketPort!
            }
            if self.lifecyclePreStopHandlerExecs != nil {
                map["LifecyclePreStopHandlerExecs"] = self.lifecyclePreStopHandlerExecs!
            }
            if self.lifecyclePreStopHandlerHttpGetHost != nil {
                map["LifecyclePreStopHandlerHttpGetHost"] = self.lifecyclePreStopHandlerHttpGetHost!
            }
            if self.lifecyclePreStopHandlerHttpGetPath != nil {
                map["LifecyclePreStopHandlerHttpGetPath"] = self.lifecyclePreStopHandlerHttpGetPath!
            }
            if self.lifecyclePreStopHandlerHttpGetPort != nil {
                map["LifecyclePreStopHandlerHttpGetPort"] = self.lifecyclePreStopHandlerHttpGetPort!
            }
            if self.lifecyclePreStopHandlerHttpGetScheme != nil {
                map["LifecyclePreStopHandlerHttpGetScheme"] = self.lifecyclePreStopHandlerHttpGetScheme!
            }
            if self.lifecyclePreStopHandlerTcpSocketHost != nil {
                map["LifecyclePreStopHandlerTcpSocketHost"] = self.lifecyclePreStopHandlerTcpSocketHost!
            }
            if self.lifecyclePreStopHandlerTcpSocketPort != nil {
                map["LifecyclePreStopHandlerTcpSocketPort"] = self.lifecyclePreStopHandlerTcpSocketPort!
            }
            if self.memory != nil {
                map["Memory"] = self.memory!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.ports != nil {
                var tmp : [Any] = []
                for k in self.ports! {
                    tmp.append(k.toMap())
                }
                map["Ports"] = tmp
            }
            if self.stdin != nil {
                map["Stdin"] = self.stdin!
            }
            if self.stdinOnce != nil {
                map["StdinOnce"] = self.stdinOnce!
            }
            if self.tty != nil {
                map["Tty"] = self.tty!
            }
            if self.volumeMounts != nil {
                var tmp : [Any] = []
                for k in self.volumeMounts! {
                    tmp.append(k.toMap())
                }
                map["VolumeMounts"] = tmp
            }
            if self.workingDir != nil {
                map["WorkingDir"] = self.workingDir!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["LivenessProbe"] as? [String: Any?] {
                var model = ModifyEciScalingConfigurationRequest.Containers.LivenessProbe()
                model.fromMap(value)
                self.livenessProbe = model
            }
            if let value = dict["ReadinessProbe"] as? [String: Any?] {
                var model = ModifyEciScalingConfigurationRequest.Containers.ReadinessProbe()
                model.fromMap(value)
                self.readinessProbe = model
            }
            if let value = dict["SecurityContext"] as? [String: Any?] {
                var model = ModifyEciScalingConfigurationRequest.Containers.SecurityContext()
                model.fromMap(value)
                self.securityContext = model
            }
            if let value = dict["Args"] as? [String] {
                self.args = value
            }
            if let value = dict["Commands"] as? [String] {
                self.commands = value
            }
            if let value = dict["Cpu"] as? Double {
                self.cpu = value
            }
            if let value = dict["EnvironmentVars"] as? [Any?] {
                var tmp : [ModifyEciScalingConfigurationRequest.Containers.EnvironmentVars] = []
                for v in value {
                    if v != nil {
                        var model = ModifyEciScalingConfigurationRequest.Containers.EnvironmentVars()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.environmentVars = tmp
            }
            if let value = dict["Gpu"] as? Int32 {
                self.gpu = value
            }
            if let value = dict["Image"] as? String {
                self.image = value
            }
            if let value = dict["ImagePullPolicy"] as? String {
                self.imagePullPolicy = value
            }
            if let value = dict["LifecyclePostStartHandlerExecs"] as? [String] {
                self.lifecyclePostStartHandlerExecs = value
            }
            if let value = dict["LifecyclePostStartHandlerHttpGetHost"] as? String {
                self.lifecyclePostStartHandlerHttpGetHost = value
            }
            if let value = dict["LifecyclePostStartHandlerHttpGetPath"] as? String {
                self.lifecyclePostStartHandlerHttpGetPath = value
            }
            if let value = dict["LifecyclePostStartHandlerHttpGetPort"] as? Int32 {
                self.lifecyclePostStartHandlerHttpGetPort = value
            }
            if let value = dict["LifecyclePostStartHandlerHttpGetScheme"] as? String {
                self.lifecyclePostStartHandlerHttpGetScheme = value
            }
            if let value = dict["LifecyclePostStartHandlerTcpSocketHost"] as? String {
                self.lifecyclePostStartHandlerTcpSocketHost = value
            }
            if let value = dict["LifecyclePostStartHandlerTcpSocketPort"] as? Int32 {
                self.lifecyclePostStartHandlerTcpSocketPort = value
            }
            if let value = dict["LifecyclePreStopHandlerExecs"] as? [String] {
                self.lifecyclePreStopHandlerExecs = value
            }
            if let value = dict["LifecyclePreStopHandlerHttpGetHost"] as? String {
                self.lifecyclePreStopHandlerHttpGetHost = value
            }
            if let value = dict["LifecyclePreStopHandlerHttpGetPath"] as? String {
                self.lifecyclePreStopHandlerHttpGetPath = value
            }
            if let value = dict["LifecyclePreStopHandlerHttpGetPort"] as? Int32 {
                self.lifecyclePreStopHandlerHttpGetPort = value
            }
            if let value = dict["LifecyclePreStopHandlerHttpGetScheme"] as? String {
                self.lifecyclePreStopHandlerHttpGetScheme = value
            }
            if let value = dict["LifecyclePreStopHandlerTcpSocketHost"] as? String {
                self.lifecyclePreStopHandlerTcpSocketHost = value
            }
            if let value = dict["LifecyclePreStopHandlerTcpSocketPort"] as? Int32 {
                self.lifecyclePreStopHandlerTcpSocketPort = value
            }
            if let value = dict["Memory"] as? Double {
                self.memory = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["Ports"] as? [Any?] {
                var tmp : [ModifyEciScalingConfigurationRequest.Containers.Ports] = []
                for v in value {
                    if v != nil {
                        var model = ModifyEciScalingConfigurationRequest.Containers.Ports()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.ports = tmp
            }
            if let value = dict["Stdin"] as? Bool {
                self.stdin = value
            }
            if let value = dict["StdinOnce"] as? Bool {
                self.stdinOnce = value
            }
            if let value = dict["Tty"] as? Bool {
                self.tty = value
            }
            if let value = dict["VolumeMounts"] as? [Any?] {
                var tmp : [ModifyEciScalingConfigurationRequest.Containers.VolumeMounts] = []
                for v in value {
                    if v != nil {
                        var model = ModifyEciScalingConfigurationRequest.Containers.VolumeMounts()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.volumeMounts = tmp
            }
            if let value = dict["WorkingDir"] as? String {
                self.workingDir = value
            }
        }
    }
    public class DnsConfigOptions : Tea.TeaModel {
        public var name: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public class HostAliases : Tea.TeaModel {
        public var hostnames: [String]?

        public var ip: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.hostnames != nil {
                map["Hostnames"] = self.hostnames!
            }
            if self.ip != nil {
                map["Ip"] = self.ip!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Hostnames"] as? [String] {
                self.hostnames = value
            }
            if let value = dict["Ip"] as? String {
                self.ip = value
            }
        }
    }
    public class ImageRegistryCredentials : Tea.TeaModel {
        public var password: String?

        public var server: String?

        public var userName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.password != nil {
                map["Password"] = self.password!
            }
            if self.server != nil {
                map["Server"] = self.server!
            }
            if self.userName != nil {
                map["UserName"] = self.userName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Password"] as? String {
                self.password = value
            }
            if let value = dict["Server"] as? String {
                self.server = value
            }
            if let value = dict["UserName"] as? String {
                self.userName = value
            }
        }
    }
    public class InitContainers : Tea.TeaModel {
        public class SecurityContext : Tea.TeaModel {
            public class Capability : Tea.TeaModel {
                public var adds: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.adds != nil {
                        map["Adds"] = self.adds!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Adds"] as? [String] {
                        self.adds = value
                    }
                }
            }
            public var capability: ModifyEciScalingConfigurationRequest.InitContainers.SecurityContext.Capability?

            public var readOnlyRootFilesystem: Bool?

            public var runAsUser: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.capability?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.capability != nil {
                    map["Capability"] = self.capability?.toMap()
                }
                if self.readOnlyRootFilesystem != nil {
                    map["ReadOnlyRootFilesystem"] = self.readOnlyRootFilesystem!
                }
                if self.runAsUser != nil {
                    map["RunAsUser"] = self.runAsUser!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Capability"] as? [String: Any?] {
                    var model = ModifyEciScalingConfigurationRequest.InitContainers.SecurityContext.Capability()
                    model.fromMap(value)
                    self.capability = model
                }
                if let value = dict["ReadOnlyRootFilesystem"] as? Bool {
                    self.readOnlyRootFilesystem = value
                }
                if let value = dict["RunAsUser"] as? Int64 {
                    self.runAsUser = value
                }
            }
        }
        public class InitContainerEnvironmentVars : Tea.TeaModel {
            public class FieldRef : Tea.TeaModel {
                public var fieldPath: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.fieldPath != nil {
                        map["FieldPath"] = self.fieldPath!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["FieldPath"] as? String {
                        self.fieldPath = value
                    }
                }
            }
            public var fieldRef: ModifyEciScalingConfigurationRequest.InitContainers.InitContainerEnvironmentVars.FieldRef?

            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.fieldRef?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fieldRef != nil {
                    map["FieldRef"] = self.fieldRef?.toMap()
                }
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["FieldRef"] as? [String: Any?] {
                    var model = ModifyEciScalingConfigurationRequest.InitContainers.InitContainerEnvironmentVars.FieldRef()
                    model.fromMap(value)
                    self.fieldRef = model
                }
                if let value = dict["Key"] as? String {
                    self.key = value
                }
                if let value = dict["Value"] as? String {
                    self.value = value
                }
            }
        }
        public class InitContainerPorts : Tea.TeaModel {
            public var port: Int32?

            public var protocol_: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.protocol_ != nil {
                    map["Protocol"] = self.protocol_!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Port"] as? Int32 {
                    self.port = value
                }
                if let value = dict["Protocol"] as? String {
                    self.protocol_ = value
                }
            }
        }
        public class InitContainerVolumeMounts : Tea.TeaModel {
            public var mountPath: String?

            public var mountPropagation: String?

            public var name: String?

            public var readOnly: Bool?

            public var subPath: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.mountPath != nil {
                    map["MountPath"] = self.mountPath!
                }
                if self.mountPropagation != nil {
                    map["MountPropagation"] = self.mountPropagation!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.readOnly != nil {
                    map["ReadOnly"] = self.readOnly!
                }
                if self.subPath != nil {
                    map["SubPath"] = self.subPath!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["MountPath"] as? String {
                    self.mountPath = value
                }
                if let value = dict["MountPropagation"] as? String {
                    self.mountPropagation = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["ReadOnly"] as? Bool {
                    self.readOnly = value
                }
                if let value = dict["SubPath"] as? String {
                    self.subPath = value
                }
            }
        }
        public var securityContext: ModifyEciScalingConfigurationRequest.InitContainers.SecurityContext?

        public var args: [String]?

        public var commands: [String]?

        public var cpu: Double?

        public var gpu: Int32?

        public var image: String?

        public var imagePullPolicy: String?

        public var initContainerEnvironmentVars: [ModifyEciScalingConfigurationRequest.InitContainers.InitContainerEnvironmentVars]?

        public var initContainerPorts: [ModifyEciScalingConfigurationRequest.InitContainers.InitContainerPorts]?

        public var initContainerVolumeMounts: [ModifyEciScalingConfigurationRequest.InitContainers.InitContainerVolumeMounts]?

        public var memory: Double?

        public var name: String?

        public var workingDir: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.securityContext?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.securityContext != nil {
                map["SecurityContext"] = self.securityContext?.toMap()
            }
            if self.args != nil {
                map["Args"] = self.args!
            }
            if self.commands != nil {
                map["Commands"] = self.commands!
            }
            if self.cpu != nil {
                map["Cpu"] = self.cpu!
            }
            if self.gpu != nil {
                map["Gpu"] = self.gpu!
            }
            if self.image != nil {
                map["Image"] = self.image!
            }
            if self.imagePullPolicy != nil {
                map["ImagePullPolicy"] = self.imagePullPolicy!
            }
            if self.initContainerEnvironmentVars != nil {
                var tmp : [Any] = []
                for k in self.initContainerEnvironmentVars! {
                    tmp.append(k.toMap())
                }
                map["InitContainerEnvironmentVars"] = tmp
            }
            if self.initContainerPorts != nil {
                var tmp : [Any] = []
                for k in self.initContainerPorts! {
                    tmp.append(k.toMap())
                }
                map["InitContainerPorts"] = tmp
            }
            if self.initContainerVolumeMounts != nil {
                var tmp : [Any] = []
                for k in self.initContainerVolumeMounts! {
                    tmp.append(k.toMap())
                }
                map["InitContainerVolumeMounts"] = tmp
            }
            if self.memory != nil {
                map["Memory"] = self.memory!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.workingDir != nil {
                map["WorkingDir"] = self.workingDir!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["SecurityContext"] as? [String: Any?] {
                var model = ModifyEciScalingConfigurationRequest.InitContainers.SecurityContext()
                model.fromMap(value)
                self.securityContext = model
            }
            if let value = dict["Args"] as? [String] {
                self.args = value
            }
            if let value = dict["Commands"] as? [String] {
                self.commands = value
            }
            if let value = dict["Cpu"] as? Double {
                self.cpu = value
            }
            if let value = dict["Gpu"] as? Int32 {
                self.gpu = value
            }
            if let value = dict["Image"] as? String {
                self.image = value
            }
            if let value = dict["ImagePullPolicy"] as? String {
                self.imagePullPolicy = value
            }
            if let value = dict["InitContainerEnvironmentVars"] as? [Any?] {
                var tmp : [ModifyEciScalingConfigurationRequest.InitContainers.InitContainerEnvironmentVars] = []
                for v in value {
                    if v != nil {
                        var model = ModifyEciScalingConfigurationRequest.InitContainers.InitContainerEnvironmentVars()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.initContainerEnvironmentVars = tmp
            }
            if let value = dict["InitContainerPorts"] as? [Any?] {
                var tmp : [ModifyEciScalingConfigurationRequest.InitContainers.InitContainerPorts] = []
                for v in value {
                    if v != nil {
                        var model = ModifyEciScalingConfigurationRequest.InitContainers.InitContainerPorts()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.initContainerPorts = tmp
            }
            if let value = dict["InitContainerVolumeMounts"] as? [Any?] {
                var tmp : [ModifyEciScalingConfigurationRequest.InitContainers.InitContainerVolumeMounts] = []
                for v in value {
                    if v != nil {
                        var model = ModifyEciScalingConfigurationRequest.InitContainers.InitContainerVolumeMounts()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.initContainerVolumeMounts = tmp
            }
            if let value = dict["Memory"] as? Double {
                self.memory = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["WorkingDir"] as? String {
                self.workingDir = value
            }
        }
    }
    public class SecurityContextSysCtls : Tea.TeaModel {
        public var name: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public class Volumes : Tea.TeaModel {
        public class DiskVolume : Tea.TeaModel {
            public var diskId: String?

            public var diskSize: Int32?

            public var fsType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.diskId != nil {
                    map["DiskId"] = self.diskId!
                }
                if self.diskSize != nil {
                    map["DiskSize"] = self.diskSize!
                }
                if self.fsType != nil {
                    map["FsType"] = self.fsType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DiskId"] as? String {
                    self.diskId = value
                }
                if let value = dict["DiskSize"] as? Int32 {
                    self.diskSize = value
                }
                if let value = dict["FsType"] as? String {
                    self.fsType = value
                }
            }
        }
        public class EmptyDirVolume : Tea.TeaModel {
            public var medium: String?

            public var sizeLimit: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.medium != nil {
                    map["Medium"] = self.medium!
                }
                if self.sizeLimit != nil {
                    map["SizeLimit"] = self.sizeLimit!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Medium"] as? String {
                    self.medium = value
                }
                if let value = dict["SizeLimit"] as? String {
                    self.sizeLimit = value
                }
            }
        }
        public class FlexVolume : Tea.TeaModel {
            public var driver: String?

            public var fsType: String?

            public var options: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.driver != nil {
                    map["Driver"] = self.driver!
                }
                if self.fsType != nil {
                    map["FsType"] = self.fsType!
                }
                if self.options != nil {
                    map["Options"] = self.options!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Driver"] as? String {
                    self.driver = value
                }
                if let value = dict["FsType"] as? String {
                    self.fsType = value
                }
                if let value = dict["Options"] as? String {
                    self.options = value
                }
            }
        }
        public class HostPathVolume : Tea.TeaModel {
            public var path: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.path != nil {
                    map["Path"] = self.path!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Path"] as? String {
                    self.path = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
            }
        }
        public class NFSVolume : Tea.TeaModel {
            public var path: String?

            public var readOnly: Bool?

            public var server: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.path != nil {
                    map["Path"] = self.path!
                }
                if self.readOnly != nil {
                    map["ReadOnly"] = self.readOnly!
                }
                if self.server != nil {
                    map["Server"] = self.server!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Path"] as? String {
                    self.path = value
                }
                if let value = dict["ReadOnly"] as? Bool {
                    self.readOnly = value
                }
                if let value = dict["Server"] as? String {
                    self.server = value
                }
            }
        }
        public class ConfigFileVolumeConfigFileToPath : Tea.TeaModel {
            public var content: String?

            public var mode: Int32?

            public var path: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.content != nil {
                    map["Content"] = self.content!
                }
                if self.mode != nil {
                    map["Mode"] = self.mode!
                }
                if self.path != nil {
                    map["Path"] = self.path!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Content"] as? String {
                    self.content = value
                }
                if let value = dict["Mode"] as? Int32 {
                    self.mode = value
                }
                if let value = dict["Path"] as? String {
                    self.path = value
                }
            }
        }
        public var diskVolume: ModifyEciScalingConfigurationRequest.Volumes.DiskVolume?

        public var emptyDirVolume: ModifyEciScalingConfigurationRequest.Volumes.EmptyDirVolume?

        public var flexVolume: ModifyEciScalingConfigurationRequest.Volumes.FlexVolume?

        public var hostPathVolume: ModifyEciScalingConfigurationRequest.Volumes.HostPathVolume?

        public var NFSVolume: ModifyEciScalingConfigurationRequest.Volumes.NFSVolume?

        public var configFileVolumeConfigFileToPath: [ModifyEciScalingConfigurationRequest.Volumes.ConfigFileVolumeConfigFileToPath]?

        public var configFileVolumeDefaultMode: Int32?

        public var name: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.diskVolume?.validate()
            try self.emptyDirVolume?.validate()
            try self.flexVolume?.validate()
            try self.hostPathVolume?.validate()
            try self.NFSVolume?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.diskVolume != nil {
                map["DiskVolume"] = self.diskVolume?.toMap()
            }
            if self.emptyDirVolume != nil {
                map["EmptyDirVolume"] = self.emptyDirVolume?.toMap()
            }
            if self.flexVolume != nil {
                map["FlexVolume"] = self.flexVolume?.toMap()
            }
            if self.hostPathVolume != nil {
                map["HostPathVolume"] = self.hostPathVolume?.toMap()
            }
            if self.NFSVolume != nil {
                map["NFSVolume"] = self.NFSVolume?.toMap()
            }
            if self.configFileVolumeConfigFileToPath != nil {
                var tmp : [Any] = []
                for k in self.configFileVolumeConfigFileToPath! {
                    tmp.append(k.toMap())
                }
                map["ConfigFileVolumeConfigFileToPath"] = tmp
            }
            if self.configFileVolumeDefaultMode != nil {
                map["ConfigFileVolumeDefaultMode"] = self.configFileVolumeDefaultMode!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DiskVolume"] as? [String: Any?] {
                var model = ModifyEciScalingConfigurationRequest.Volumes.DiskVolume()
                model.fromMap(value)
                self.diskVolume = model
            }
            if let value = dict["EmptyDirVolume"] as? [String: Any?] {
                var model = ModifyEciScalingConfigurationRequest.Volumes.EmptyDirVolume()
                model.fromMap(value)
                self.emptyDirVolume = model
            }
            if let value = dict["FlexVolume"] as? [String: Any?] {
                var model = ModifyEciScalingConfigurationRequest.Volumes.FlexVolume()
                model.fromMap(value)
                self.flexVolume = model
            }
            if let value = dict["HostPathVolume"] as? [String: Any?] {
                var model = ModifyEciScalingConfigurationRequest.Volumes.HostPathVolume()
                model.fromMap(value)
                self.hostPathVolume = model
            }
            if let value = dict["NFSVolume"] as? [String: Any?] {
                var model = ModifyEciScalingConfigurationRequest.Volumes.NFSVolume()
                model.fromMap(value)
                self.NFSVolume = model
            }
            if let value = dict["ConfigFileVolumeConfigFileToPath"] as? [Any?] {
                var tmp : [ModifyEciScalingConfigurationRequest.Volumes.ConfigFileVolumeConfigFileToPath] = []
                for v in value {
                    if v != nil {
                        var model = ModifyEciScalingConfigurationRequest.Volumes.ConfigFileVolumeConfigFileToPath()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.configFileVolumeConfigFileToPath = tmp
            }
            if let value = dict["ConfigFileVolumeDefaultMode"] as? Int32 {
                self.configFileVolumeDefaultMode = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["Type"] as? String {
                self.type = value
            }
        }
    }
    public var acrRegistryInfos: [ModifyEciScalingConfigurationRequest.AcrRegistryInfos]?

    public var activeDeadlineSeconds: Int64?

    public var autoCreateEip: Bool?

    public var autoMatchImageCache: Bool?

    public var containerGroupName: String?

    public var containers: [ModifyEciScalingConfigurationRequest.Containers]?

    public var containersUpdateType: String?

    public var costOptimization: Bool?

    public var cpu: Double?

    public var cpuOptionsCore: Int32?

    public var cpuOptionsThreadsPerCore: Int32?

    public var dataCacheBucket: String?

    public var dataCacheBurstingEnabled: Bool?

    public var dataCachePL: String?

    public var dataCacheProvisionedIops: Int32?

    public var description_: String?

    public var dnsConfigNameServers: [String]?

    public var dnsConfigOptions: [ModifyEciScalingConfigurationRequest.DnsConfigOptions]?

    public var dnsConfigSearchs: [String]?

    public var dnsPolicy: String?

    public var egressBandwidth: Int64?

    public var eipBandwidth: Int32?

    public var enableSls: Bool?

    public var ephemeralStorage: Int32?

    public var gpuDriverVersion: String?

    public var hostAliases: [ModifyEciScalingConfigurationRequest.HostAliases]?

    public var hostName: String?

    public var imageRegistryCredentials: [ModifyEciScalingConfigurationRequest.ImageRegistryCredentials]?

    public var imageSnapshotId: String?

    public var ingressBandwidth: Int64?

    public var initContainers: [ModifyEciScalingConfigurationRequest.InitContainers]?

    public var instanceFamilyLevel: String?

    public var instanceTypes: [String]?

    public var ipv6AddressCount: Int32?

    public var loadBalancerWeight: Int32?

    public var memory: Double?

    public var ntpServers: [String]?

    public var ownerId: Int64?

    public var ramRoleName: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var restartPolicy: String?

    public var scalingConfigurationId: String?

    public var scalingConfigurationName: String?

    public var securityContextSysCtls: [ModifyEciScalingConfigurationRequest.SecurityContextSysCtls]?

    public var securityGroupId: String?

    public var spotPriceLimit: Double?

    public var spotStrategy: String?

    public var tags: [ModifyEciScalingConfigurationRequest.Tags]?

    public var terminationGracePeriodSeconds: Int64?

    public var volumes: [ModifyEciScalingConfigurationRequest.Volumes]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acrRegistryInfos != nil {
            var tmp : [Any] = []
            for k in self.acrRegistryInfos! {
                tmp.append(k.toMap())
            }
            map["AcrRegistryInfos"] = tmp
        }
        if self.activeDeadlineSeconds != nil {
            map["ActiveDeadlineSeconds"] = self.activeDeadlineSeconds!
        }
        if self.autoCreateEip != nil {
            map["AutoCreateEip"] = self.autoCreateEip!
        }
        if self.autoMatchImageCache != nil {
            map["AutoMatchImageCache"] = self.autoMatchImageCache!
        }
        if self.containerGroupName != nil {
            map["ContainerGroupName"] = self.containerGroupName!
        }
        if self.containers != nil {
            var tmp : [Any] = []
            for k in self.containers! {
                tmp.append(k.toMap())
            }
            map["Containers"] = tmp
        }
        if self.containersUpdateType != nil {
            map["ContainersUpdateType"] = self.containersUpdateType!
        }
        if self.costOptimization != nil {
            map["CostOptimization"] = self.costOptimization!
        }
        if self.cpu != nil {
            map["Cpu"] = self.cpu!
        }
        if self.cpuOptionsCore != nil {
            map["CpuOptionsCore"] = self.cpuOptionsCore!
        }
        if self.cpuOptionsThreadsPerCore != nil {
            map["CpuOptionsThreadsPerCore"] = self.cpuOptionsThreadsPerCore!
        }
        if self.dataCacheBucket != nil {
            map["DataCacheBucket"] = self.dataCacheBucket!
        }
        if self.dataCacheBurstingEnabled != nil {
            map["DataCacheBurstingEnabled"] = self.dataCacheBurstingEnabled!
        }
        if self.dataCachePL != nil {
            map["DataCachePL"] = self.dataCachePL!
        }
        if self.dataCacheProvisionedIops != nil {
            map["DataCacheProvisionedIops"] = self.dataCacheProvisionedIops!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.dnsConfigNameServers != nil {
            map["DnsConfigNameServers"] = self.dnsConfigNameServers!
        }
        if self.dnsConfigOptions != nil {
            var tmp : [Any] = []
            for k in self.dnsConfigOptions! {
                tmp.append(k.toMap())
            }
            map["DnsConfigOptions"] = tmp
        }
        if self.dnsConfigSearchs != nil {
            map["DnsConfigSearchs"] = self.dnsConfigSearchs!
        }
        if self.dnsPolicy != nil {
            map["DnsPolicy"] = self.dnsPolicy!
        }
        if self.egressBandwidth != nil {
            map["EgressBandwidth"] = self.egressBandwidth!
        }
        if self.eipBandwidth != nil {
            map["EipBandwidth"] = self.eipBandwidth!
        }
        if self.enableSls != nil {
            map["EnableSls"] = self.enableSls!
        }
        if self.ephemeralStorage != nil {
            map["EphemeralStorage"] = self.ephemeralStorage!
        }
        if self.gpuDriverVersion != nil {
            map["GpuDriverVersion"] = self.gpuDriverVersion!
        }
        if self.hostAliases != nil {
            var tmp : [Any] = []
            for k in self.hostAliases! {
                tmp.append(k.toMap())
            }
            map["HostAliases"] = tmp
        }
        if self.hostName != nil {
            map["HostName"] = self.hostName!
        }
        if self.imageRegistryCredentials != nil {
            var tmp : [Any] = []
            for k in self.imageRegistryCredentials! {
                tmp.append(k.toMap())
            }
            map["ImageRegistryCredentials"] = tmp
        }
        if self.imageSnapshotId != nil {
            map["ImageSnapshotId"] = self.imageSnapshotId!
        }
        if self.ingressBandwidth != nil {
            map["IngressBandwidth"] = self.ingressBandwidth!
        }
        if self.initContainers != nil {
            var tmp : [Any] = []
            for k in self.initContainers! {
                tmp.append(k.toMap())
            }
            map["InitContainers"] = tmp
        }
        if self.instanceFamilyLevel != nil {
            map["InstanceFamilyLevel"] = self.instanceFamilyLevel!
        }
        if self.instanceTypes != nil {
            map["InstanceTypes"] = self.instanceTypes!
        }
        if self.ipv6AddressCount != nil {
            map["Ipv6AddressCount"] = self.ipv6AddressCount!
        }
        if self.loadBalancerWeight != nil {
            map["LoadBalancerWeight"] = self.loadBalancerWeight!
        }
        if self.memory != nil {
            map["Memory"] = self.memory!
        }
        if self.ntpServers != nil {
            map["NtpServers"] = self.ntpServers!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.ramRoleName != nil {
            map["RamRoleName"] = self.ramRoleName!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.restartPolicy != nil {
            map["RestartPolicy"] = self.restartPolicy!
        }
        if self.scalingConfigurationId != nil {
            map["ScalingConfigurationId"] = self.scalingConfigurationId!
        }
        if self.scalingConfigurationName != nil {
            map["ScalingConfigurationName"] = self.scalingConfigurationName!
        }
        if self.securityContextSysCtls != nil {
            var tmp : [Any] = []
            for k in self.securityContextSysCtls! {
                tmp.append(k.toMap())
            }
            map["SecurityContextSysCtls"] = tmp
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.spotPriceLimit != nil {
            map["SpotPriceLimit"] = self.spotPriceLimit!
        }
        if self.spotStrategy != nil {
            map["SpotStrategy"] = self.spotStrategy!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        if self.terminationGracePeriodSeconds != nil {
            map["TerminationGracePeriodSeconds"] = self.terminationGracePeriodSeconds!
        }
        if self.volumes != nil {
            var tmp : [Any] = []
            for k in self.volumes! {
                tmp.append(k.toMap())
            }
            map["Volumes"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AcrRegistryInfos"] as? [Any?] {
            var tmp : [ModifyEciScalingConfigurationRequest.AcrRegistryInfos] = []
            for v in value {
                if v != nil {
                    var model = ModifyEciScalingConfigurationRequest.AcrRegistryInfos()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.acrRegistryInfos = tmp
        }
        if let value = dict["ActiveDeadlineSeconds"] as? Int64 {
            self.activeDeadlineSeconds = value
        }
        if let value = dict["AutoCreateEip"] as? Bool {
            self.autoCreateEip = value
        }
        if let value = dict["AutoMatchImageCache"] as? Bool {
            self.autoMatchImageCache = value
        }
        if let value = dict["ContainerGroupName"] as? String {
            self.containerGroupName = value
        }
        if let value = dict["Containers"] as? [Any?] {
            var tmp : [ModifyEciScalingConfigurationRequest.Containers] = []
            for v in value {
                if v != nil {
                    var model = ModifyEciScalingConfigurationRequest.Containers()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.containers = tmp
        }
        if let value = dict["ContainersUpdateType"] as? String {
            self.containersUpdateType = value
        }
        if let value = dict["CostOptimization"] as? Bool {
            self.costOptimization = value
        }
        if let value = dict["Cpu"] as? Double {
            self.cpu = value
        }
        if let value = dict["CpuOptionsCore"] as? Int32 {
            self.cpuOptionsCore = value
        }
        if let value = dict["CpuOptionsThreadsPerCore"] as? Int32 {
            self.cpuOptionsThreadsPerCore = value
        }
        if let value = dict["DataCacheBucket"] as? String {
            self.dataCacheBucket = value
        }
        if let value = dict["DataCacheBurstingEnabled"] as? Bool {
            self.dataCacheBurstingEnabled = value
        }
        if let value = dict["DataCachePL"] as? String {
            self.dataCachePL = value
        }
        if let value = dict["DataCacheProvisionedIops"] as? Int32 {
            self.dataCacheProvisionedIops = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["DnsConfigNameServers"] as? [String] {
            self.dnsConfigNameServers = value
        }
        if let value = dict["DnsConfigOptions"] as? [Any?] {
            var tmp : [ModifyEciScalingConfigurationRequest.DnsConfigOptions] = []
            for v in value {
                if v != nil {
                    var model = ModifyEciScalingConfigurationRequest.DnsConfigOptions()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.dnsConfigOptions = tmp
        }
        if let value = dict["DnsConfigSearchs"] as? [String] {
            self.dnsConfigSearchs = value
        }
        if let value = dict["DnsPolicy"] as? String {
            self.dnsPolicy = value
        }
        if let value = dict["EgressBandwidth"] as? Int64 {
            self.egressBandwidth = value
        }
        if let value = dict["EipBandwidth"] as? Int32 {
            self.eipBandwidth = value
        }
        if let value = dict["EnableSls"] as? Bool {
            self.enableSls = value
        }
        if let value = dict["EphemeralStorage"] as? Int32 {
            self.ephemeralStorage = value
        }
        if let value = dict["GpuDriverVersion"] as? String {
            self.gpuDriverVersion = value
        }
        if let value = dict["HostAliases"] as? [Any?] {
            var tmp : [ModifyEciScalingConfigurationRequest.HostAliases] = []
            for v in value {
                if v != nil {
                    var model = ModifyEciScalingConfigurationRequest.HostAliases()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.hostAliases = tmp
        }
        if let value = dict["HostName"] as? String {
            self.hostName = value
        }
        if let value = dict["ImageRegistryCredentials"] as? [Any?] {
            var tmp : [ModifyEciScalingConfigurationRequest.ImageRegistryCredentials] = []
            for v in value {
                if v != nil {
                    var model = ModifyEciScalingConfigurationRequest.ImageRegistryCredentials()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.imageRegistryCredentials = tmp
        }
        if let value = dict["ImageSnapshotId"] as? String {
            self.imageSnapshotId = value
        }
        if let value = dict["IngressBandwidth"] as? Int64 {
            self.ingressBandwidth = value
        }
        if let value = dict["InitContainers"] as? [Any?] {
            var tmp : [ModifyEciScalingConfigurationRequest.InitContainers] = []
            for v in value {
                if v != nil {
                    var model = ModifyEciScalingConfigurationRequest.InitContainers()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.initContainers = tmp
        }
        if let value = dict["InstanceFamilyLevel"] as? String {
            self.instanceFamilyLevel = value
        }
        if let value = dict["InstanceTypes"] as? [String] {
            self.instanceTypes = value
        }
        if let value = dict["Ipv6AddressCount"] as? Int32 {
            self.ipv6AddressCount = value
        }
        if let value = dict["LoadBalancerWeight"] as? Int32 {
            self.loadBalancerWeight = value
        }
        if let value = dict["Memory"] as? Double {
            self.memory = value
        }
        if let value = dict["NtpServers"] as? [String] {
            self.ntpServers = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RamRoleName"] as? String {
            self.ramRoleName = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["RestartPolicy"] as? String {
            self.restartPolicy = value
        }
        if let value = dict["ScalingConfigurationId"] as? String {
            self.scalingConfigurationId = value
        }
        if let value = dict["ScalingConfigurationName"] as? String {
            self.scalingConfigurationName = value
        }
        if let value = dict["SecurityContextSysCtls"] as? [Any?] {
            var tmp : [ModifyEciScalingConfigurationRequest.SecurityContextSysCtls] = []
            for v in value {
                if v != nil {
                    var model = ModifyEciScalingConfigurationRequest.SecurityContextSysCtls()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.securityContextSysCtls = tmp
        }
        if let value = dict["SecurityGroupId"] as? String {
            self.securityGroupId = value
        }
        if let value = dict["SpotPriceLimit"] as? Double {
            self.spotPriceLimit = value
        }
        if let value = dict["SpotStrategy"] as? String {
            self.spotStrategy = value
        }
        if let value = dict["Tags"] as? [Any?] {
            var tmp : [ModifyEciScalingConfigurationRequest.Tags] = []
            for v in value {
                if v != nil {
                    var model = ModifyEciScalingConfigurationRequest.Tags()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tags = tmp
        }
        if let value = dict["TerminationGracePeriodSeconds"] as? Int64 {
            self.terminationGracePeriodSeconds = value
        }
        if let value = dict["Volumes"] as? [Any?] {
            var tmp : [ModifyEciScalingConfigurationRequest.Volumes] = []
            for v in value {
                if v != nil {
                    var model = ModifyEciScalingConfigurationRequest.Volumes()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.volumes = tmp
        }
    }
}

public class ModifyEciScalingConfigurationResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyEciScalingConfigurationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyEciScalingConfigurationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyEciScalingConfigurationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyInstanceAttributeRequest : Tea.TeaModel {
    public var entrusted: Bool?

    public var instanceId: String?

    public var instanceIds: [String]?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.entrusted != nil {
            map["Entrusted"] = self.entrusted!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Entrusted"] as? Bool {
            self.entrusted = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["InstanceIds"] as? [String] {
            self.instanceIds = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ScalingGroupId"] as? String {
            self.scalingGroupId = value
        }
    }
}

public class ModifyInstanceAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyInstanceAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyInstanceAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyInstanceAttributeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyLifecycleHookRequest : Tea.TeaModel {
    public var defaultResult: String?

    public var heartbeatTimeout: Int32?

    public var lifecycleHookId: String?

    public var lifecycleHookName: String?

    public var lifecycleHookStatus: String?

    public var lifecycleTransition: String?

    public var notificationArn: String?

    public var notificationMetadata: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.defaultResult != nil {
            map["DefaultResult"] = self.defaultResult!
        }
        if self.heartbeatTimeout != nil {
            map["HeartbeatTimeout"] = self.heartbeatTimeout!
        }
        if self.lifecycleHookId != nil {
            map["LifecycleHookId"] = self.lifecycleHookId!
        }
        if self.lifecycleHookName != nil {
            map["LifecycleHookName"] = self.lifecycleHookName!
        }
        if self.lifecycleHookStatus != nil {
            map["LifecycleHookStatus"] = self.lifecycleHookStatus!
        }
        if self.lifecycleTransition != nil {
            map["LifecycleTransition"] = self.lifecycleTransition!
        }
        if self.notificationArn != nil {
            map["NotificationArn"] = self.notificationArn!
        }
        if self.notificationMetadata != nil {
            map["NotificationMetadata"] = self.notificationMetadata!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DefaultResult"] as? String {
            self.defaultResult = value
        }
        if let value = dict["HeartbeatTimeout"] as? Int32 {
            self.heartbeatTimeout = value
        }
        if let value = dict["LifecycleHookId"] as? String {
            self.lifecycleHookId = value
        }
        if let value = dict["LifecycleHookName"] as? String {
            self.lifecycleHookName = value
        }
        if let value = dict["LifecycleHookStatus"] as? String {
            self.lifecycleHookStatus = value
        }
        if let value = dict["LifecycleTransition"] as? String {
            self.lifecycleTransition = value
        }
        if let value = dict["NotificationArn"] as? String {
            self.notificationArn = value
        }
        if let value = dict["NotificationMetadata"] as? String {
            self.notificationMetadata = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ScalingGroupId"] as? String {
            self.scalingGroupId = value
        }
    }
}

public class ModifyLifecycleHookResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyLifecycleHookResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyLifecycleHookResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyLifecycleHookResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyNotificationConfigurationRequest : Tea.TeaModel {
    public var notificationArn: String?

    public var notificationTypes: [String]?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public var timeZone: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.notificationArn != nil {
            map["NotificationArn"] = self.notificationArn!
        }
        if self.notificationTypes != nil {
            map["NotificationTypes"] = self.notificationTypes!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        if self.timeZone != nil {
            map["TimeZone"] = self.timeZone!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NotificationArn"] as? String {
            self.notificationArn = value
        }
        if let value = dict["NotificationTypes"] as? [String] {
            self.notificationTypes = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ScalingGroupId"] as? String {
            self.scalingGroupId = value
        }
        if let value = dict["TimeZone"] as? String {
            self.timeZone = value
        }
    }
}

public class ModifyNotificationConfigurationResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyNotificationConfigurationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyNotificationConfigurationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyNotificationConfigurationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyScalingConfigurationRequest : Tea.TeaModel {
    public class ImageOptions : Tea.TeaModel {
        public var loginAsNonRoot: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.loginAsNonRoot != nil {
                map["LoginAsNonRoot"] = self.loginAsNonRoot!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["LoginAsNonRoot"] as? Bool {
                self.loginAsNonRoot = value
            }
        }
    }
    public class PrivatePoolOptions : Tea.TeaModel {
        public var id: String?

        public var matchCriteria: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.matchCriteria != nil {
                map["MatchCriteria"] = self.matchCriteria!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Id"] as? String {
                self.id = value
            }
            if let value = dict["MatchCriteria"] as? String {
                self.matchCriteria = value
            }
        }
    }
    public class SystemDisk : Tea.TeaModel {
        public var autoSnapshotPolicyId: String?

        public var burstingEnabled: Bool?

        public var category: String?

        public var description_: String?

        public var diskName: String?

        public var encryptAlgorithm: String?

        public var encrypted: Bool?

        public var KMSKeyId: String?

        public var performanceLevel: String?

        public var provisionedIops: Int64?

        public var size: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.autoSnapshotPolicyId != nil {
                map["AutoSnapshotPolicyId"] = self.autoSnapshotPolicyId!
            }
            if self.burstingEnabled != nil {
                map["BurstingEnabled"] = self.burstingEnabled!
            }
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.diskName != nil {
                map["DiskName"] = self.diskName!
            }
            if self.encryptAlgorithm != nil {
                map["EncryptAlgorithm"] = self.encryptAlgorithm!
            }
            if self.encrypted != nil {
                map["Encrypted"] = self.encrypted!
            }
            if self.KMSKeyId != nil {
                map["KMSKeyId"] = self.KMSKeyId!
            }
            if self.performanceLevel != nil {
                map["PerformanceLevel"] = self.performanceLevel!
            }
            if self.provisionedIops != nil {
                map["ProvisionedIops"] = self.provisionedIops!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AutoSnapshotPolicyId"] as? String {
                self.autoSnapshotPolicyId = value
            }
            if let value = dict["BurstingEnabled"] as? Bool {
                self.burstingEnabled = value
            }
            if let value = dict["Category"] as? String {
                self.category = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["DiskName"] as? String {
                self.diskName = value
            }
            if let value = dict["EncryptAlgorithm"] as? String {
                self.encryptAlgorithm = value
            }
            if let value = dict["Encrypted"] as? Bool {
                self.encrypted = value
            }
            if let value = dict["KMSKeyId"] as? String {
                self.KMSKeyId = value
            }
            if let value = dict["PerformanceLevel"] as? String {
                self.performanceLevel = value
            }
            if let value = dict["ProvisionedIops"] as? Int64 {
                self.provisionedIops = value
            }
            if let value = dict["Size"] as? Int32 {
                self.size = value
            }
        }
    }
    public class CustomPriorities : Tea.TeaModel {
        public var instanceType: String?

        public var vswitchId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.vswitchId != nil {
                map["VswitchId"] = self.vswitchId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["InstanceType"] as? String {
                self.instanceType = value
            }
            if let value = dict["VswitchId"] as? String {
                self.vswitchId = value
            }
        }
    }
    public class DataDisks : Tea.TeaModel {
        public var autoSnapshotPolicyId: String?

        public var burstingEnabled: Bool?

        public var categories: [String]?

        public var category: String?

        public var deleteWithInstance: Bool?

        public var description_: String?

        public var device: String?

        public var diskName: String?

        public var encrypted: String?

        public var KMSKeyId: String?

        public var performanceLevel: String?

        public var provisionedIops: Int64?

        public var size: Int32?

        public var snapshotId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.autoSnapshotPolicyId != nil {
                map["AutoSnapshotPolicyId"] = self.autoSnapshotPolicyId!
            }
            if self.burstingEnabled != nil {
                map["BurstingEnabled"] = self.burstingEnabled!
            }
            if self.categories != nil {
                map["Categories"] = self.categories!
            }
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.deleteWithInstance != nil {
                map["DeleteWithInstance"] = self.deleteWithInstance!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.device != nil {
                map["Device"] = self.device!
            }
            if self.diskName != nil {
                map["DiskName"] = self.diskName!
            }
            if self.encrypted != nil {
                map["Encrypted"] = self.encrypted!
            }
            if self.KMSKeyId != nil {
                map["KMSKeyId"] = self.KMSKeyId!
            }
            if self.performanceLevel != nil {
                map["PerformanceLevel"] = self.performanceLevel!
            }
            if self.provisionedIops != nil {
                map["ProvisionedIops"] = self.provisionedIops!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.snapshotId != nil {
                map["SnapshotId"] = self.snapshotId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AutoSnapshotPolicyId"] as? String {
                self.autoSnapshotPolicyId = value
            }
            if let value = dict["BurstingEnabled"] as? Bool {
                self.burstingEnabled = value
            }
            if let value = dict["Categories"] as? [String] {
                self.categories = value
            }
            if let value = dict["Category"] as? String {
                self.category = value
            }
            if let value = dict["DeleteWithInstance"] as? Bool {
                self.deleteWithInstance = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["Device"] as? String {
                self.device = value
            }
            if let value = dict["DiskName"] as? String {
                self.diskName = value
            }
            if let value = dict["Encrypted"] as? String {
                self.encrypted = value
            }
            if let value = dict["KMSKeyId"] as? String {
                self.KMSKeyId = value
            }
            if let value = dict["PerformanceLevel"] as? String {
                self.performanceLevel = value
            }
            if let value = dict["ProvisionedIops"] as? Int64 {
                self.provisionedIops = value
            }
            if let value = dict["Size"] as? Int32 {
                self.size = value
            }
            if let value = dict["SnapshotId"] as? String {
                self.snapshotId = value
            }
        }
    }
    public class InstancePatternInfos : Tea.TeaModel {
        public var architectures: [String]?

        public var burstablePerformance: String?

        public var cores: Int32?

        public var cpuArchitectures: [String]?

        public var excludedInstanceTypes: [String]?

        public var gpuSpecs: [String]?

        public var instanceCategories: [String]?

        public var instanceFamilyLevel: String?

        public var instanceTypeFamilies: [String]?

        public var maxPrice: Double?

        public var maximumCpuCoreCount: Int32?

        public var maximumGpuAmount: Int32?

        public var maximumMemorySize: Double?

        public var memory: Double?

        public var minimumBaselineCredit: Int32?

        public var minimumCpuCoreCount: Int32?

        public var minimumEniIpv6AddressQuantity: Int32?

        public var minimumEniPrivateIpAddressQuantity: Int32?

        public var minimumEniQuantity: Int32?

        public var minimumGpuAmount: Int32?

        public var minimumInitialCredit: Int32?

        public var minimumMemorySize: Double?

        public var physicalProcessorModels: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.architectures != nil {
                map["Architectures"] = self.architectures!
            }
            if self.burstablePerformance != nil {
                map["BurstablePerformance"] = self.burstablePerformance!
            }
            if self.cores != nil {
                map["Cores"] = self.cores!
            }
            if self.cpuArchitectures != nil {
                map["CpuArchitectures"] = self.cpuArchitectures!
            }
            if self.excludedInstanceTypes != nil {
                map["ExcludedInstanceTypes"] = self.excludedInstanceTypes!
            }
            if self.gpuSpecs != nil {
                map["GpuSpecs"] = self.gpuSpecs!
            }
            if self.instanceCategories != nil {
                map["InstanceCategories"] = self.instanceCategories!
            }
            if self.instanceFamilyLevel != nil {
                map["InstanceFamilyLevel"] = self.instanceFamilyLevel!
            }
            if self.instanceTypeFamilies != nil {
                map["InstanceTypeFamilies"] = self.instanceTypeFamilies!
            }
            if self.maxPrice != nil {
                map["MaxPrice"] = self.maxPrice!
            }
            if self.maximumCpuCoreCount != nil {
                map["MaximumCpuCoreCount"] = self.maximumCpuCoreCount!
            }
            if self.maximumGpuAmount != nil {
                map["MaximumGpuAmount"] = self.maximumGpuAmount!
            }
            if self.maximumMemorySize != nil {
                map["MaximumMemorySize"] = self.maximumMemorySize!
            }
            if self.memory != nil {
                map["Memory"] = self.memory!
            }
            if self.minimumBaselineCredit != nil {
                map["MinimumBaselineCredit"] = self.minimumBaselineCredit!
            }
            if self.minimumCpuCoreCount != nil {
                map["MinimumCpuCoreCount"] = self.minimumCpuCoreCount!
            }
            if self.minimumEniIpv6AddressQuantity != nil {
                map["MinimumEniIpv6AddressQuantity"] = self.minimumEniIpv6AddressQuantity!
            }
            if self.minimumEniPrivateIpAddressQuantity != nil {
                map["MinimumEniPrivateIpAddressQuantity"] = self.minimumEniPrivateIpAddressQuantity!
            }
            if self.minimumEniQuantity != nil {
                map["MinimumEniQuantity"] = self.minimumEniQuantity!
            }
            if self.minimumGpuAmount != nil {
                map["MinimumGpuAmount"] = self.minimumGpuAmount!
            }
            if self.minimumInitialCredit != nil {
                map["MinimumInitialCredit"] = self.minimumInitialCredit!
            }
            if self.minimumMemorySize != nil {
                map["MinimumMemorySize"] = self.minimumMemorySize!
            }
            if self.physicalProcessorModels != nil {
                map["PhysicalProcessorModels"] = self.physicalProcessorModels!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Architectures"] as? [String] {
                self.architectures = value
            }
            if let value = dict["BurstablePerformance"] as? String {
                self.burstablePerformance = value
            }
            if let value = dict["Cores"] as? Int32 {
                self.cores = value
            }
            if let value = dict["CpuArchitectures"] as? [String] {
                self.cpuArchitectures = value
            }
            if let value = dict["ExcludedInstanceTypes"] as? [String] {
                self.excludedInstanceTypes = value
            }
            if let value = dict["GpuSpecs"] as? [String] {
                self.gpuSpecs = value
            }
            if let value = dict["InstanceCategories"] as? [String] {
                self.instanceCategories = value
            }
            if let value = dict["InstanceFamilyLevel"] as? String {
                self.instanceFamilyLevel = value
            }
            if let value = dict["InstanceTypeFamilies"] as? [String] {
                self.instanceTypeFamilies = value
            }
            if let value = dict["MaxPrice"] as? Double {
                self.maxPrice = value
            }
            if let value = dict["MaximumCpuCoreCount"] as? Int32 {
                self.maximumCpuCoreCount = value
            }
            if let value = dict["MaximumGpuAmount"] as? Int32 {
                self.maximumGpuAmount = value
            }
            if let value = dict["MaximumMemorySize"] as? Double {
                self.maximumMemorySize = value
            }
            if let value = dict["Memory"] as? Double {
                self.memory = value
            }
            if let value = dict["MinimumBaselineCredit"] as? Int32 {
                self.minimumBaselineCredit = value
            }
            if let value = dict["MinimumCpuCoreCount"] as? Int32 {
                self.minimumCpuCoreCount = value
            }
            if let value = dict["MinimumEniIpv6AddressQuantity"] as? Int32 {
                self.minimumEniIpv6AddressQuantity = value
            }
            if let value = dict["MinimumEniPrivateIpAddressQuantity"] as? Int32 {
                self.minimumEniPrivateIpAddressQuantity = value
            }
            if let value = dict["MinimumEniQuantity"] as? Int32 {
                self.minimumEniQuantity = value
            }
            if let value = dict["MinimumGpuAmount"] as? Int32 {
                self.minimumGpuAmount = value
            }
            if let value = dict["MinimumInitialCredit"] as? Int32 {
                self.minimumInitialCredit = value
            }
            if let value = dict["MinimumMemorySize"] as? Double {
                self.minimumMemorySize = value
            }
            if let value = dict["PhysicalProcessorModels"] as? [String] {
                self.physicalProcessorModels = value
            }
        }
    }
    public class InstanceTypeOverrides : Tea.TeaModel {
        public var instanceType: String?

        public var weightedCapacity: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.weightedCapacity != nil {
                map["WeightedCapacity"] = self.weightedCapacity!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["InstanceType"] as? String {
                self.instanceType = value
            }
            if let value = dict["WeightedCapacity"] as? Int32 {
                self.weightedCapacity = value
            }
        }
    }
    public class NetworkInterfaces : Tea.TeaModel {
        public var instanceType: String?

        public var ipv6AddressCount: Int32?

        public var networkInterfaceTrafficMode: String?

        public var securityGroupIds: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.ipv6AddressCount != nil {
                map["Ipv6AddressCount"] = self.ipv6AddressCount!
            }
            if self.networkInterfaceTrafficMode != nil {
                map["NetworkInterfaceTrafficMode"] = self.networkInterfaceTrafficMode!
            }
            if self.securityGroupIds != nil {
                map["SecurityGroupIds"] = self.securityGroupIds!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["InstanceType"] as? String {
                self.instanceType = value
            }
            if let value = dict["Ipv6AddressCount"] as? Int32 {
                self.ipv6AddressCount = value
            }
            if let value = dict["NetworkInterfaceTrafficMode"] as? String {
                self.networkInterfaceTrafficMode = value
            }
            if let value = dict["SecurityGroupIds"] as? [String] {
                self.securityGroupIds = value
            }
        }
    }
    public class ResourcePoolOptions : Tea.TeaModel {
        public var privatePoolIds: [String]?

        public var strategy: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.privatePoolIds != nil {
                map["PrivatePoolIds"] = self.privatePoolIds!
            }
            if self.strategy != nil {
                map["Strategy"] = self.strategy!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["PrivatePoolIds"] as? [String] {
                self.privatePoolIds = value
            }
            if let value = dict["Strategy"] as? String {
                self.strategy = value
            }
        }
    }
    public class SecurityOptions : Tea.TeaModel {
        public var confidentialComputingMode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.confidentialComputingMode != nil {
                map["ConfidentialComputingMode"] = self.confidentialComputingMode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ConfidentialComputingMode"] as? String {
                self.confidentialComputingMode = value
            }
        }
    }
    public class SpotPriceLimits : Tea.TeaModel {
        public var instanceType: String?

        public var priceLimit: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.priceLimit != nil {
                map["PriceLimit"] = self.priceLimit!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["InstanceType"] as? String {
                self.instanceType = value
            }
            if let value = dict["PriceLimit"] as? Double {
                self.priceLimit = value
            }
        }
    }
    public var imageOptions: ModifyScalingConfigurationRequest.ImageOptions?

    public var privatePoolOptions: ModifyScalingConfigurationRequest.PrivatePoolOptions?

    public var systemDisk: ModifyScalingConfigurationRequest.SystemDisk?

    public var affinity: String?

    public var cpu: Int32?

    public var creditSpecification: String?

    public var customPriorities: [ModifyScalingConfigurationRequest.CustomPriorities]?

    public var dataDisks: [ModifyScalingConfigurationRequest.DataDisks]?

    public var dedicatedHostClusterId: String?

    public var dedicatedHostId: String?

    public var deletionProtection: Bool?

    public var deploymentSetId: String?

    public var hostName: String?

    public var hpcClusterId: String?

    public var httpEndpoint: String?

    public var httpTokens: String?

    public var imageFamily: String?

    public var imageId: String?

    public var imageName: String?

    public var instanceDescription: String?

    public var instanceName: String?

    public var instancePatternInfos: [ModifyScalingConfigurationRequest.InstancePatternInfos]?

    public var instanceTypeOverrides: [ModifyScalingConfigurationRequest.InstanceTypeOverrides]?

    public var instanceTypes: [String]?

    public var internetChargeType: String?

    public var internetMaxBandwidthIn: Int32?

    public var internetMaxBandwidthOut: Int32?

    public var ioOptimized: String?

    public var ipv6AddressCount: Int32?

    public var keyPairName: String?

    public var loadBalancerWeight: Int32?

    public var memory: Int32?

    public var networkInterfaces: [ModifyScalingConfigurationRequest.NetworkInterfaces]?

    public var override_: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var password: String?

    public var passwordInherit: Bool?

    public var ramRoleName: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourcePoolOptions: ModifyScalingConfigurationRequest.ResourcePoolOptions?

    public var scalingConfigurationId: String?

    public var scalingConfigurationName: String?

    public var schedulerOptions: [String: Any]?

    public var securityGroupId: String?

    public var securityGroupIds: [String]?

    public var securityOptions: ModifyScalingConfigurationRequest.SecurityOptions?

    public var spotDuration: Int32?

    public var spotInterruptionBehavior: String?

    public var spotPriceLimits: [ModifyScalingConfigurationRequest.SpotPriceLimits]?

    public var spotStrategy: String?

    public var storageSetId: String?

    public var storageSetPartitionNumber: Int32?

    public var systemDiskCategories: [String]?

    public var tags: String?

    public var tenancy: String?

    public var userData: String?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.imageOptions?.validate()
        try self.privatePoolOptions?.validate()
        try self.systemDisk?.validate()
        try self.resourcePoolOptions?.validate()
        try self.securityOptions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imageOptions != nil {
            map["ImageOptions"] = self.imageOptions?.toMap()
        }
        if self.privatePoolOptions != nil {
            map["PrivatePoolOptions"] = self.privatePoolOptions?.toMap()
        }
        if self.systemDisk != nil {
            map["SystemDisk"] = self.systemDisk?.toMap()
        }
        if self.affinity != nil {
            map["Affinity"] = self.affinity!
        }
        if self.cpu != nil {
            map["Cpu"] = self.cpu!
        }
        if self.creditSpecification != nil {
            map["CreditSpecification"] = self.creditSpecification!
        }
        if self.customPriorities != nil {
            var tmp : [Any] = []
            for k in self.customPriorities! {
                tmp.append(k.toMap())
            }
            map["CustomPriorities"] = tmp
        }
        if self.dataDisks != nil {
            var tmp : [Any] = []
            for k in self.dataDisks! {
                tmp.append(k.toMap())
            }
            map["DataDisks"] = tmp
        }
        if self.dedicatedHostClusterId != nil {
            map["DedicatedHostClusterId"] = self.dedicatedHostClusterId!
        }
        if self.dedicatedHostId != nil {
            map["DedicatedHostId"] = self.dedicatedHostId!
        }
        if self.deletionProtection != nil {
            map["DeletionProtection"] = self.deletionProtection!
        }
        if self.deploymentSetId != nil {
            map["DeploymentSetId"] = self.deploymentSetId!
        }
        if self.hostName != nil {
            map["HostName"] = self.hostName!
        }
        if self.hpcClusterId != nil {
            map["HpcClusterId"] = self.hpcClusterId!
        }
        if self.httpEndpoint != nil {
            map["HttpEndpoint"] = self.httpEndpoint!
        }
        if self.httpTokens != nil {
            map["HttpTokens"] = self.httpTokens!
        }
        if self.imageFamily != nil {
            map["ImageFamily"] = self.imageFamily!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.imageName != nil {
            map["ImageName"] = self.imageName!
        }
        if self.instanceDescription != nil {
            map["InstanceDescription"] = self.instanceDescription!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.instancePatternInfos != nil {
            var tmp : [Any] = []
            for k in self.instancePatternInfos! {
                tmp.append(k.toMap())
            }
            map["InstancePatternInfos"] = tmp
        }
        if self.instanceTypeOverrides != nil {
            var tmp : [Any] = []
            for k in self.instanceTypeOverrides! {
                tmp.append(k.toMap())
            }
            map["InstanceTypeOverrides"] = tmp
        }
        if self.instanceTypes != nil {
            map["InstanceTypes"] = self.instanceTypes!
        }
        if self.internetChargeType != nil {
            map["InternetChargeType"] = self.internetChargeType!
        }
        if self.internetMaxBandwidthIn != nil {
            map["InternetMaxBandwidthIn"] = self.internetMaxBandwidthIn!
        }
        if self.internetMaxBandwidthOut != nil {
            map["InternetMaxBandwidthOut"] = self.internetMaxBandwidthOut!
        }
        if self.ioOptimized != nil {
            map["IoOptimized"] = self.ioOptimized!
        }
        if self.ipv6AddressCount != nil {
            map["Ipv6AddressCount"] = self.ipv6AddressCount!
        }
        if self.keyPairName != nil {
            map["KeyPairName"] = self.keyPairName!
        }
        if self.loadBalancerWeight != nil {
            map["LoadBalancerWeight"] = self.loadBalancerWeight!
        }
        if self.memory != nil {
            map["Memory"] = self.memory!
        }
        if self.networkInterfaces != nil {
            var tmp : [Any] = []
            for k in self.networkInterfaces! {
                tmp.append(k.toMap())
            }
            map["NetworkInterfaces"] = tmp
        }
        if self.override_ != nil {
            map["Override"] = self.override_!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        if self.passwordInherit != nil {
            map["PasswordInherit"] = self.passwordInherit!
        }
        if self.ramRoleName != nil {
            map["RamRoleName"] = self.ramRoleName!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourcePoolOptions != nil {
            map["ResourcePoolOptions"] = self.resourcePoolOptions?.toMap()
        }
        if self.scalingConfigurationId != nil {
            map["ScalingConfigurationId"] = self.scalingConfigurationId!
        }
        if self.scalingConfigurationName != nil {
            map["ScalingConfigurationName"] = self.scalingConfigurationName!
        }
        if self.schedulerOptions != nil {
            map["SchedulerOptions"] = self.schedulerOptions!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.securityGroupIds != nil {
            map["SecurityGroupIds"] = self.securityGroupIds!
        }
        if self.securityOptions != nil {
            map["SecurityOptions"] = self.securityOptions?.toMap()
        }
        if self.spotDuration != nil {
            map["SpotDuration"] = self.spotDuration!
        }
        if self.spotInterruptionBehavior != nil {
            map["SpotInterruptionBehavior"] = self.spotInterruptionBehavior!
        }
        if self.spotPriceLimits != nil {
            var tmp : [Any] = []
            for k in self.spotPriceLimits! {
                tmp.append(k.toMap())
            }
            map["SpotPriceLimits"] = tmp
        }
        if self.spotStrategy != nil {
            map["SpotStrategy"] = self.spotStrategy!
        }
        if self.storageSetId != nil {
            map["StorageSetId"] = self.storageSetId!
        }
        if self.storageSetPartitionNumber != nil {
            map["StorageSetPartitionNumber"] = self.storageSetPartitionNumber!
        }
        if self.systemDiskCategories != nil {
            map["SystemDiskCategories"] = self.systemDiskCategories!
        }
        if self.tags != nil {
            map["Tags"] = self.tags!
        }
        if self.tenancy != nil {
            map["Tenancy"] = self.tenancy!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ImageOptions"] as? [String: Any?] {
            var model = ModifyScalingConfigurationRequest.ImageOptions()
            model.fromMap(value)
            self.imageOptions = model
        }
        if let value = dict["PrivatePoolOptions"] as? [String: Any?] {
            var model = ModifyScalingConfigurationRequest.PrivatePoolOptions()
            model.fromMap(value)
            self.privatePoolOptions = model
        }
        if let value = dict["SystemDisk"] as? [String: Any?] {
            var model = ModifyScalingConfigurationRequest.SystemDisk()
            model.fromMap(value)
            self.systemDisk = model
        }
        if let value = dict["Affinity"] as? String {
            self.affinity = value
        }
        if let value = dict["Cpu"] as? Int32 {
            self.cpu = value
        }
        if let value = dict["CreditSpecification"] as? String {
            self.creditSpecification = value
        }
        if let value = dict["CustomPriorities"] as? [Any?] {
            var tmp : [ModifyScalingConfigurationRequest.CustomPriorities] = []
            for v in value {
                if v != nil {
                    var model = ModifyScalingConfigurationRequest.CustomPriorities()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.customPriorities = tmp
        }
        if let value = dict["DataDisks"] as? [Any?] {
            var tmp : [ModifyScalingConfigurationRequest.DataDisks] = []
            for v in value {
                if v != nil {
                    var model = ModifyScalingConfigurationRequest.DataDisks()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.dataDisks = tmp
        }
        if let value = dict["DedicatedHostClusterId"] as? String {
            self.dedicatedHostClusterId = value
        }
        if let value = dict["DedicatedHostId"] as? String {
            self.dedicatedHostId = value
        }
        if let value = dict["DeletionProtection"] as? Bool {
            self.deletionProtection = value
        }
        if let value = dict["DeploymentSetId"] as? String {
            self.deploymentSetId = value
        }
        if let value = dict["HostName"] as? String {
            self.hostName = value
        }
        if let value = dict["HpcClusterId"] as? String {
            self.hpcClusterId = value
        }
        if let value = dict["HttpEndpoint"] as? String {
            self.httpEndpoint = value
        }
        if let value = dict["HttpTokens"] as? String {
            self.httpTokens = value
        }
        if let value = dict["ImageFamily"] as? String {
            self.imageFamily = value
        }
        if let value = dict["ImageId"] as? String {
            self.imageId = value
        }
        if let value = dict["ImageName"] as? String {
            self.imageName = value
        }
        if let value = dict["InstanceDescription"] as? String {
            self.instanceDescription = value
        }
        if let value = dict["InstanceName"] as? String {
            self.instanceName = value
        }
        if let value = dict["InstancePatternInfos"] as? [Any?] {
            var tmp : [ModifyScalingConfigurationRequest.InstancePatternInfos] = []
            for v in value {
                if v != nil {
                    var model = ModifyScalingConfigurationRequest.InstancePatternInfos()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.instancePatternInfos = tmp
        }
        if let value = dict["InstanceTypeOverrides"] as? [Any?] {
            var tmp : [ModifyScalingConfigurationRequest.InstanceTypeOverrides] = []
            for v in value {
                if v != nil {
                    var model = ModifyScalingConfigurationRequest.InstanceTypeOverrides()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.instanceTypeOverrides = tmp
        }
        if let value = dict["InstanceTypes"] as? [String] {
            self.instanceTypes = value
        }
        if let value = dict["InternetChargeType"] as? String {
            self.internetChargeType = value
        }
        if let value = dict["InternetMaxBandwidthIn"] as? Int32 {
            self.internetMaxBandwidthIn = value
        }
        if let value = dict["InternetMaxBandwidthOut"] as? Int32 {
            self.internetMaxBandwidthOut = value
        }
        if let value = dict["IoOptimized"] as? String {
            self.ioOptimized = value
        }
        if let value = dict["Ipv6AddressCount"] as? Int32 {
            self.ipv6AddressCount = value
        }
        if let value = dict["KeyPairName"] as? String {
            self.keyPairName = value
        }
        if let value = dict["LoadBalancerWeight"] as? Int32 {
            self.loadBalancerWeight = value
        }
        if let value = dict["Memory"] as? Int32 {
            self.memory = value
        }
        if let value = dict["NetworkInterfaces"] as? [Any?] {
            var tmp : [ModifyScalingConfigurationRequest.NetworkInterfaces] = []
            for v in value {
                if v != nil {
                    var model = ModifyScalingConfigurationRequest.NetworkInterfaces()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.networkInterfaces = tmp
        }
        if let value = dict["Override"] as? Bool {
            self.override_ = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Password"] as? String {
            self.password = value
        }
        if let value = dict["PasswordInherit"] as? Bool {
            self.passwordInherit = value
        }
        if let value = dict["RamRoleName"] as? String {
            self.ramRoleName = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourcePoolOptions"] as? [String: Any?] {
            var model = ModifyScalingConfigurationRequest.ResourcePoolOptions()
            model.fromMap(value)
            self.resourcePoolOptions = model
        }
        if let value = dict["ScalingConfigurationId"] as? String {
            self.scalingConfigurationId = value
        }
        if let value = dict["ScalingConfigurationName"] as? String {
            self.scalingConfigurationName = value
        }
        if let value = dict["SchedulerOptions"] as? [String: Any] {
            self.schedulerOptions = value
        }
        if let value = dict["SecurityGroupId"] as? String {
            self.securityGroupId = value
        }
        if let value = dict["SecurityGroupIds"] as? [String] {
            self.securityGroupIds = value
        }
        if let value = dict["SecurityOptions"] as? [String: Any?] {
            var model = ModifyScalingConfigurationRequest.SecurityOptions()
            model.fromMap(value)
            self.securityOptions = model
        }
        if let value = dict["SpotDuration"] as? Int32 {
            self.spotDuration = value
        }
        if let value = dict["SpotInterruptionBehavior"] as? String {
            self.spotInterruptionBehavior = value
        }
        if let value = dict["SpotPriceLimits"] as? [Any?] {
            var tmp : [ModifyScalingConfigurationRequest.SpotPriceLimits] = []
            for v in value {
                if v != nil {
                    var model = ModifyScalingConfigurationRequest.SpotPriceLimits()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.spotPriceLimits = tmp
        }
        if let value = dict["SpotStrategy"] as? String {
            self.spotStrategy = value
        }
        if let value = dict["StorageSetId"] as? String {
            self.storageSetId = value
        }
        if let value = dict["StorageSetPartitionNumber"] as? Int32 {
            self.storageSetPartitionNumber = value
        }
        if let value = dict["SystemDiskCategories"] as? [String] {
            self.systemDiskCategories = value
        }
        if let value = dict["Tags"] as? String {
            self.tags = value
        }
        if let value = dict["Tenancy"] as? String {
            self.tenancy = value
        }
        if let value = dict["UserData"] as? String {
            self.userData = value
        }
        if let value = dict["ZoneId"] as? String {
            self.zoneId = value
        }
    }
}

public class ModifyScalingConfigurationShrinkRequest : Tea.TeaModel {
    public class ImageOptions : Tea.TeaModel {
        public var loginAsNonRoot: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.loginAsNonRoot != nil {
                map["LoginAsNonRoot"] = self.loginAsNonRoot!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["LoginAsNonRoot"] as? Bool {
                self.loginAsNonRoot = value
            }
        }
    }
    public class PrivatePoolOptions : Tea.TeaModel {
        public var id: String?

        public var matchCriteria: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.matchCriteria != nil {
                map["MatchCriteria"] = self.matchCriteria!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Id"] as? String {
                self.id = value
            }
            if let value = dict["MatchCriteria"] as? String {
                self.matchCriteria = value
            }
        }
    }
    public class SystemDisk : Tea.TeaModel {
        public var autoSnapshotPolicyId: String?

        public var burstingEnabled: Bool?

        public var category: String?

        public var description_: String?

        public var diskName: String?

        public var encryptAlgorithm: String?

        public var encrypted: Bool?

        public var KMSKeyId: String?

        public var performanceLevel: String?

        public var provisionedIops: Int64?

        public var size: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.autoSnapshotPolicyId != nil {
                map["AutoSnapshotPolicyId"] = self.autoSnapshotPolicyId!
            }
            if self.burstingEnabled != nil {
                map["BurstingEnabled"] = self.burstingEnabled!
            }
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.diskName != nil {
                map["DiskName"] = self.diskName!
            }
            if self.encryptAlgorithm != nil {
                map["EncryptAlgorithm"] = self.encryptAlgorithm!
            }
            if self.encrypted != nil {
                map["Encrypted"] = self.encrypted!
            }
            if self.KMSKeyId != nil {
                map["KMSKeyId"] = self.KMSKeyId!
            }
            if self.performanceLevel != nil {
                map["PerformanceLevel"] = self.performanceLevel!
            }
            if self.provisionedIops != nil {
                map["ProvisionedIops"] = self.provisionedIops!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AutoSnapshotPolicyId"] as? String {
                self.autoSnapshotPolicyId = value
            }
            if let value = dict["BurstingEnabled"] as? Bool {
                self.burstingEnabled = value
            }
            if let value = dict["Category"] as? String {
                self.category = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["DiskName"] as? String {
                self.diskName = value
            }
            if let value = dict["EncryptAlgorithm"] as? String {
                self.encryptAlgorithm = value
            }
            if let value = dict["Encrypted"] as? Bool {
                self.encrypted = value
            }
            if let value = dict["KMSKeyId"] as? String {
                self.KMSKeyId = value
            }
            if let value = dict["PerformanceLevel"] as? String {
                self.performanceLevel = value
            }
            if let value = dict["ProvisionedIops"] as? Int64 {
                self.provisionedIops = value
            }
            if let value = dict["Size"] as? Int32 {
                self.size = value
            }
        }
    }
    public class CustomPriorities : Tea.TeaModel {
        public var instanceType: String?

        public var vswitchId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.vswitchId != nil {
                map["VswitchId"] = self.vswitchId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["InstanceType"] as? String {
                self.instanceType = value
            }
            if let value = dict["VswitchId"] as? String {
                self.vswitchId = value
            }
        }
    }
    public class DataDisks : Tea.TeaModel {
        public var autoSnapshotPolicyId: String?

        public var burstingEnabled: Bool?

        public var categories: [String]?

        public var category: String?

        public var deleteWithInstance: Bool?

        public var description_: String?

        public var device: String?

        public var diskName: String?

        public var encrypted: String?

        public var KMSKeyId: String?

        public var performanceLevel: String?

        public var provisionedIops: Int64?

        public var size: Int32?

        public var snapshotId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.autoSnapshotPolicyId != nil {
                map["AutoSnapshotPolicyId"] = self.autoSnapshotPolicyId!
            }
            if self.burstingEnabled != nil {
                map["BurstingEnabled"] = self.burstingEnabled!
            }
            if self.categories != nil {
                map["Categories"] = self.categories!
            }
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.deleteWithInstance != nil {
                map["DeleteWithInstance"] = self.deleteWithInstance!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.device != nil {
                map["Device"] = self.device!
            }
            if self.diskName != nil {
                map["DiskName"] = self.diskName!
            }
            if self.encrypted != nil {
                map["Encrypted"] = self.encrypted!
            }
            if self.KMSKeyId != nil {
                map["KMSKeyId"] = self.KMSKeyId!
            }
            if self.performanceLevel != nil {
                map["PerformanceLevel"] = self.performanceLevel!
            }
            if self.provisionedIops != nil {
                map["ProvisionedIops"] = self.provisionedIops!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.snapshotId != nil {
                map["SnapshotId"] = self.snapshotId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AutoSnapshotPolicyId"] as? String {
                self.autoSnapshotPolicyId = value
            }
            if let value = dict["BurstingEnabled"] as? Bool {
                self.burstingEnabled = value
            }
            if let value = dict["Categories"] as? [String] {
                self.categories = value
            }
            if let value = dict["Category"] as? String {
                self.category = value
            }
            if let value = dict["DeleteWithInstance"] as? Bool {
                self.deleteWithInstance = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["Device"] as? String {
                self.device = value
            }
            if let value = dict["DiskName"] as? String {
                self.diskName = value
            }
            if let value = dict["Encrypted"] as? String {
                self.encrypted = value
            }
            if let value = dict["KMSKeyId"] as? String {
                self.KMSKeyId = value
            }
            if let value = dict["PerformanceLevel"] as? String {
                self.performanceLevel = value
            }
            if let value = dict["ProvisionedIops"] as? Int64 {
                self.provisionedIops = value
            }
            if let value = dict["Size"] as? Int32 {
                self.size = value
            }
            if let value = dict["SnapshotId"] as? String {
                self.snapshotId = value
            }
        }
    }
    public class InstancePatternInfos : Tea.TeaModel {
        public var architectures: [String]?

        public var burstablePerformance: String?

        public var cores: Int32?

        public var cpuArchitectures: [String]?

        public var excludedInstanceTypes: [String]?

        public var gpuSpecs: [String]?

        public var instanceCategories: [String]?

        public var instanceFamilyLevel: String?

        public var instanceTypeFamilies: [String]?

        public var maxPrice: Double?

        public var maximumCpuCoreCount: Int32?

        public var maximumGpuAmount: Int32?

        public var maximumMemorySize: Double?

        public var memory: Double?

        public var minimumBaselineCredit: Int32?

        public var minimumCpuCoreCount: Int32?

        public var minimumEniIpv6AddressQuantity: Int32?

        public var minimumEniPrivateIpAddressQuantity: Int32?

        public var minimumEniQuantity: Int32?

        public var minimumGpuAmount: Int32?

        public var minimumInitialCredit: Int32?

        public var minimumMemorySize: Double?

        public var physicalProcessorModels: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.architectures != nil {
                map["Architectures"] = self.architectures!
            }
            if self.burstablePerformance != nil {
                map["BurstablePerformance"] = self.burstablePerformance!
            }
            if self.cores != nil {
                map["Cores"] = self.cores!
            }
            if self.cpuArchitectures != nil {
                map["CpuArchitectures"] = self.cpuArchitectures!
            }
            if self.excludedInstanceTypes != nil {
                map["ExcludedInstanceTypes"] = self.excludedInstanceTypes!
            }
            if self.gpuSpecs != nil {
                map["GpuSpecs"] = self.gpuSpecs!
            }
            if self.instanceCategories != nil {
                map["InstanceCategories"] = self.instanceCategories!
            }
            if self.instanceFamilyLevel != nil {
                map["InstanceFamilyLevel"] = self.instanceFamilyLevel!
            }
            if self.instanceTypeFamilies != nil {
                map["InstanceTypeFamilies"] = self.instanceTypeFamilies!
            }
            if self.maxPrice != nil {
                map["MaxPrice"] = self.maxPrice!
            }
            if self.maximumCpuCoreCount != nil {
                map["MaximumCpuCoreCount"] = self.maximumCpuCoreCount!
            }
            if self.maximumGpuAmount != nil {
                map["MaximumGpuAmount"] = self.maximumGpuAmount!
            }
            if self.maximumMemorySize != nil {
                map["MaximumMemorySize"] = self.maximumMemorySize!
            }
            if self.memory != nil {
                map["Memory"] = self.memory!
            }
            if self.minimumBaselineCredit != nil {
                map["MinimumBaselineCredit"] = self.minimumBaselineCredit!
            }
            if self.minimumCpuCoreCount != nil {
                map["MinimumCpuCoreCount"] = self.minimumCpuCoreCount!
            }
            if self.minimumEniIpv6AddressQuantity != nil {
                map["MinimumEniIpv6AddressQuantity"] = self.minimumEniIpv6AddressQuantity!
            }
            if self.minimumEniPrivateIpAddressQuantity != nil {
                map["MinimumEniPrivateIpAddressQuantity"] = self.minimumEniPrivateIpAddressQuantity!
            }
            if self.minimumEniQuantity != nil {
                map["MinimumEniQuantity"] = self.minimumEniQuantity!
            }
            if self.minimumGpuAmount != nil {
                map["MinimumGpuAmount"] = self.minimumGpuAmount!
            }
            if self.minimumInitialCredit != nil {
                map["MinimumInitialCredit"] = self.minimumInitialCredit!
            }
            if self.minimumMemorySize != nil {
                map["MinimumMemorySize"] = self.minimumMemorySize!
            }
            if self.physicalProcessorModels != nil {
                map["PhysicalProcessorModels"] = self.physicalProcessorModels!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Architectures"] as? [String] {
                self.architectures = value
            }
            if let value = dict["BurstablePerformance"] as? String {
                self.burstablePerformance = value
            }
            if let value = dict["Cores"] as? Int32 {
                self.cores = value
            }
            if let value = dict["CpuArchitectures"] as? [String] {
                self.cpuArchitectures = value
            }
            if let value = dict["ExcludedInstanceTypes"] as? [String] {
                self.excludedInstanceTypes = value
            }
            if let value = dict["GpuSpecs"] as? [String] {
                self.gpuSpecs = value
            }
            if let value = dict["InstanceCategories"] as? [String] {
                self.instanceCategories = value
            }
            if let value = dict["InstanceFamilyLevel"] as? String {
                self.instanceFamilyLevel = value
            }
            if let value = dict["InstanceTypeFamilies"] as? [String] {
                self.instanceTypeFamilies = value
            }
            if let value = dict["MaxPrice"] as? Double {
                self.maxPrice = value
            }
            if let value = dict["MaximumCpuCoreCount"] as? Int32 {
                self.maximumCpuCoreCount = value
            }
            if let value = dict["MaximumGpuAmount"] as? Int32 {
                self.maximumGpuAmount = value
            }
            if let value = dict["MaximumMemorySize"] as? Double {
                self.maximumMemorySize = value
            }
            if let value = dict["Memory"] as? Double {
                self.memory = value
            }
            if let value = dict["MinimumBaselineCredit"] as? Int32 {
                self.minimumBaselineCredit = value
            }
            if let value = dict["MinimumCpuCoreCount"] as? Int32 {
                self.minimumCpuCoreCount = value
            }
            if let value = dict["MinimumEniIpv6AddressQuantity"] as? Int32 {
                self.minimumEniIpv6AddressQuantity = value
            }
            if let value = dict["MinimumEniPrivateIpAddressQuantity"] as? Int32 {
                self.minimumEniPrivateIpAddressQuantity = value
            }
            if let value = dict["MinimumEniQuantity"] as? Int32 {
                self.minimumEniQuantity = value
            }
            if let value = dict["MinimumGpuAmount"] as? Int32 {
                self.minimumGpuAmount = value
            }
            if let value = dict["MinimumInitialCredit"] as? Int32 {
                self.minimumInitialCredit = value
            }
            if let value = dict["MinimumMemorySize"] as? Double {
                self.minimumMemorySize = value
            }
            if let value = dict["PhysicalProcessorModels"] as? [String] {
                self.physicalProcessorModels = value
            }
        }
    }
    public class InstanceTypeOverrides : Tea.TeaModel {
        public var instanceType: String?

        public var weightedCapacity: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.weightedCapacity != nil {
                map["WeightedCapacity"] = self.weightedCapacity!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["InstanceType"] as? String {
                self.instanceType = value
            }
            if let value = dict["WeightedCapacity"] as? Int32 {
                self.weightedCapacity = value
            }
        }
    }
    public class NetworkInterfaces : Tea.TeaModel {
        public var instanceType: String?

        public var ipv6AddressCount: Int32?

        public var networkInterfaceTrafficMode: String?

        public var securityGroupIds: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.ipv6AddressCount != nil {
                map["Ipv6AddressCount"] = self.ipv6AddressCount!
            }
            if self.networkInterfaceTrafficMode != nil {
                map["NetworkInterfaceTrafficMode"] = self.networkInterfaceTrafficMode!
            }
            if self.securityGroupIds != nil {
                map["SecurityGroupIds"] = self.securityGroupIds!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["InstanceType"] as? String {
                self.instanceType = value
            }
            if let value = dict["Ipv6AddressCount"] as? Int32 {
                self.ipv6AddressCount = value
            }
            if let value = dict["NetworkInterfaceTrafficMode"] as? String {
                self.networkInterfaceTrafficMode = value
            }
            if let value = dict["SecurityGroupIds"] as? [String] {
                self.securityGroupIds = value
            }
        }
    }
    public class ResourcePoolOptions : Tea.TeaModel {
        public var privatePoolIds: [String]?

        public var strategy: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.privatePoolIds != nil {
                map["PrivatePoolIds"] = self.privatePoolIds!
            }
            if self.strategy != nil {
                map["Strategy"] = self.strategy!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["PrivatePoolIds"] as? [String] {
                self.privatePoolIds = value
            }
            if let value = dict["Strategy"] as? String {
                self.strategy = value
            }
        }
    }
    public class SecurityOptions : Tea.TeaModel {
        public var confidentialComputingMode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.confidentialComputingMode != nil {
                map["ConfidentialComputingMode"] = self.confidentialComputingMode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ConfidentialComputingMode"] as? String {
                self.confidentialComputingMode = value
            }
        }
    }
    public class SpotPriceLimits : Tea.TeaModel {
        public var instanceType: String?

        public var priceLimit: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.priceLimit != nil {
                map["PriceLimit"] = self.priceLimit!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["InstanceType"] as? String {
                self.instanceType = value
            }
            if let value = dict["PriceLimit"] as? Double {
                self.priceLimit = value
            }
        }
    }
    public var imageOptions: ModifyScalingConfigurationShrinkRequest.ImageOptions?

    public var privatePoolOptions: ModifyScalingConfigurationShrinkRequest.PrivatePoolOptions?

    public var systemDisk: ModifyScalingConfigurationShrinkRequest.SystemDisk?

    public var affinity: String?

    public var cpu: Int32?

    public var creditSpecification: String?

    public var customPriorities: [ModifyScalingConfigurationShrinkRequest.CustomPriorities]?

    public var dataDisks: [ModifyScalingConfigurationShrinkRequest.DataDisks]?

    public var dedicatedHostClusterId: String?

    public var dedicatedHostId: String?

    public var deletionProtection: Bool?

    public var deploymentSetId: String?

    public var hostName: String?

    public var hpcClusterId: String?

    public var httpEndpoint: String?

    public var httpTokens: String?

    public var imageFamily: String?

    public var imageId: String?

    public var imageName: String?

    public var instanceDescription: String?

    public var instanceName: String?

    public var instancePatternInfos: [ModifyScalingConfigurationShrinkRequest.InstancePatternInfos]?

    public var instanceTypeOverrides: [ModifyScalingConfigurationShrinkRequest.InstanceTypeOverrides]?

    public var instanceTypes: [String]?

    public var internetChargeType: String?

    public var internetMaxBandwidthIn: Int32?

    public var internetMaxBandwidthOut: Int32?

    public var ioOptimized: String?

    public var ipv6AddressCount: Int32?

    public var keyPairName: String?

    public var loadBalancerWeight: Int32?

    public var memory: Int32?

    public var networkInterfaces: [ModifyScalingConfigurationShrinkRequest.NetworkInterfaces]?

    public var override_: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var password: String?

    public var passwordInherit: Bool?

    public var ramRoleName: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourcePoolOptions: ModifyScalingConfigurationShrinkRequest.ResourcePoolOptions?

    public var scalingConfigurationId: String?

    public var scalingConfigurationName: String?

    public var schedulerOptionsShrink: String?

    public var securityGroupId: String?

    public var securityGroupIds: [String]?

    public var securityOptions: ModifyScalingConfigurationShrinkRequest.SecurityOptions?

    public var spotDuration: Int32?

    public var spotInterruptionBehavior: String?

    public var spotPriceLimits: [ModifyScalingConfigurationShrinkRequest.SpotPriceLimits]?

    public var spotStrategy: String?

    public var storageSetId: String?

    public var storageSetPartitionNumber: Int32?

    public var systemDiskCategories: [String]?

    public var tags: String?

    public var tenancy: String?

    public var userData: String?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.imageOptions?.validate()
        try self.privatePoolOptions?.validate()
        try self.systemDisk?.validate()
        try self.resourcePoolOptions?.validate()
        try self.securityOptions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imageOptions != nil {
            map["ImageOptions"] = self.imageOptions?.toMap()
        }
        if self.privatePoolOptions != nil {
            map["PrivatePoolOptions"] = self.privatePoolOptions?.toMap()
        }
        if self.systemDisk != nil {
            map["SystemDisk"] = self.systemDisk?.toMap()
        }
        if self.affinity != nil {
            map["Affinity"] = self.affinity!
        }
        if self.cpu != nil {
            map["Cpu"] = self.cpu!
        }
        if self.creditSpecification != nil {
            map["CreditSpecification"] = self.creditSpecification!
        }
        if self.customPriorities != nil {
            var tmp : [Any] = []
            for k in self.customPriorities! {
                tmp.append(k.toMap())
            }
            map["CustomPriorities"] = tmp
        }
        if self.dataDisks != nil {
            var tmp : [Any] = []
            for k in self.dataDisks! {
                tmp.append(k.toMap())
            }
            map["DataDisks"] = tmp
        }
        if self.dedicatedHostClusterId != nil {
            map["DedicatedHostClusterId"] = self.dedicatedHostClusterId!
        }
        if self.dedicatedHostId != nil {
            map["DedicatedHostId"] = self.dedicatedHostId!
        }
        if self.deletionProtection != nil {
            map["DeletionProtection"] = self.deletionProtection!
        }
        if self.deploymentSetId != nil {
            map["DeploymentSetId"] = self.deploymentSetId!
        }
        if self.hostName != nil {
            map["HostName"] = self.hostName!
        }
        if self.hpcClusterId != nil {
            map["HpcClusterId"] = self.hpcClusterId!
        }
        if self.httpEndpoint != nil {
            map["HttpEndpoint"] = self.httpEndpoint!
        }
        if self.httpTokens != nil {
            map["HttpTokens"] = self.httpTokens!
        }
        if self.imageFamily != nil {
            map["ImageFamily"] = self.imageFamily!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.imageName != nil {
            map["ImageName"] = self.imageName!
        }
        if self.instanceDescription != nil {
            map["InstanceDescription"] = self.instanceDescription!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.instancePatternInfos != nil {
            var tmp : [Any] = []
            for k in self.instancePatternInfos! {
                tmp.append(k.toMap())
            }
            map["InstancePatternInfos"] = tmp
        }
        if self.instanceTypeOverrides != nil {
            var tmp : [Any] = []
            for k in self.instanceTypeOverrides! {
                tmp.append(k.toMap())
            }
            map["InstanceTypeOverrides"] = tmp
        }
        if self.instanceTypes != nil {
            map["InstanceTypes"] = self.instanceTypes!
        }
        if self.internetChargeType != nil {
            map["InternetChargeType"] = self.internetChargeType!
        }
        if self.internetMaxBandwidthIn != nil {
            map["InternetMaxBandwidthIn"] = self.internetMaxBandwidthIn!
        }
        if self.internetMaxBandwidthOut != nil {
            map["InternetMaxBandwidthOut"] = self.internetMaxBandwidthOut!
        }
        if self.ioOptimized != nil {
            map["IoOptimized"] = self.ioOptimized!
        }
        if self.ipv6AddressCount != nil {
            map["Ipv6AddressCount"] = self.ipv6AddressCount!
        }
        if self.keyPairName != nil {
            map["KeyPairName"] = self.keyPairName!
        }
        if self.loadBalancerWeight != nil {
            map["LoadBalancerWeight"] = self.loadBalancerWeight!
        }
        if self.memory != nil {
            map["Memory"] = self.memory!
        }
        if self.networkInterfaces != nil {
            var tmp : [Any] = []
            for k in self.networkInterfaces! {
                tmp.append(k.toMap())
            }
            map["NetworkInterfaces"] = tmp
        }
        if self.override_ != nil {
            map["Override"] = self.override_!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        if self.passwordInherit != nil {
            map["PasswordInherit"] = self.passwordInherit!
        }
        if self.ramRoleName != nil {
            map["RamRoleName"] = self.ramRoleName!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourcePoolOptions != nil {
            map["ResourcePoolOptions"] = self.resourcePoolOptions?.toMap()
        }
        if self.scalingConfigurationId != nil {
            map["ScalingConfigurationId"] = self.scalingConfigurationId!
        }
        if self.scalingConfigurationName != nil {
            map["ScalingConfigurationName"] = self.scalingConfigurationName!
        }
        if self.schedulerOptionsShrink != nil {
            map["SchedulerOptions"] = self.schedulerOptionsShrink!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.securityGroupIds != nil {
            map["SecurityGroupIds"] = self.securityGroupIds!
        }
        if self.securityOptions != nil {
            map["SecurityOptions"] = self.securityOptions?.toMap()
        }
        if self.spotDuration != nil {
            map["SpotDuration"] = self.spotDuration!
        }
        if self.spotInterruptionBehavior != nil {
            map["SpotInterruptionBehavior"] = self.spotInterruptionBehavior!
        }
        if self.spotPriceLimits != nil {
            var tmp : [Any] = []
            for k in self.spotPriceLimits! {
                tmp.append(k.toMap())
            }
            map["SpotPriceLimits"] = tmp
        }
        if self.spotStrategy != nil {
            map["SpotStrategy"] = self.spotStrategy!
        }
        if self.storageSetId != nil {
            map["StorageSetId"] = self.storageSetId!
        }
        if self.storageSetPartitionNumber != nil {
            map["StorageSetPartitionNumber"] = self.storageSetPartitionNumber!
        }
        if self.systemDiskCategories != nil {
            map["SystemDiskCategories"] = self.systemDiskCategories!
        }
        if self.tags != nil {
            map["Tags"] = self.tags!
        }
        if self.tenancy != nil {
            map["Tenancy"] = self.tenancy!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ImageOptions"] as? [String: Any?] {
            var model = ModifyScalingConfigurationShrinkRequest.ImageOptions()
            model.fromMap(value)
            self.imageOptions = model
        }
        if let value = dict["PrivatePoolOptions"] as? [String: Any?] {
            var model = ModifyScalingConfigurationShrinkRequest.PrivatePoolOptions()
            model.fromMap(value)
            self.privatePoolOptions = model
        }
        if let value = dict["SystemDisk"] as? [String: Any?] {
            var model = ModifyScalingConfigurationShrinkRequest.SystemDisk()
            model.fromMap(value)
            self.systemDisk = model
        }
        if let value = dict["Affinity"] as? String {
            self.affinity = value
        }
        if let value = dict["Cpu"] as? Int32 {
            self.cpu = value
        }
        if let value = dict["CreditSpecification"] as? String {
            self.creditSpecification = value
        }
        if let value = dict["CustomPriorities"] as? [Any?] {
            var tmp : [ModifyScalingConfigurationShrinkRequest.CustomPriorities] = []
            for v in value {
                if v != nil {
                    var model = ModifyScalingConfigurationShrinkRequest.CustomPriorities()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.customPriorities = tmp
        }
        if let value = dict["DataDisks"] as? [Any?] {
            var tmp : [ModifyScalingConfigurationShrinkRequest.DataDisks] = []
            for v in value {
                if v != nil {
                    var model = ModifyScalingConfigurationShrinkRequest.DataDisks()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.dataDisks = tmp
        }
        if let value = dict["DedicatedHostClusterId"] as? String {
            self.dedicatedHostClusterId = value
        }
        if let value = dict["DedicatedHostId"] as? String {
            self.dedicatedHostId = value
        }
        if let value = dict["DeletionProtection"] as? Bool {
            self.deletionProtection = value
        }
        if let value = dict["DeploymentSetId"] as? String {
            self.deploymentSetId = value
        }
        if let value = dict["HostName"] as? String {
            self.hostName = value
        }
        if let value = dict["HpcClusterId"] as? String {
            self.hpcClusterId = value
        }
        if let value = dict["HttpEndpoint"] as? String {
            self.httpEndpoint = value
        }
        if let value = dict["HttpTokens"] as? String {
            self.httpTokens = value
        }
        if let value = dict["ImageFamily"] as? String {
            self.imageFamily = value
        }
        if let value = dict["ImageId"] as? String {
            self.imageId = value
        }
        if let value = dict["ImageName"] as? String {
            self.imageName = value
        }
        if let value = dict["InstanceDescription"] as? String {
            self.instanceDescription = value
        }
        if let value = dict["InstanceName"] as? String {
            self.instanceName = value
        }
        if let value = dict["InstancePatternInfos"] as? [Any?] {
            var tmp : [ModifyScalingConfigurationShrinkRequest.InstancePatternInfos] = []
            for v in value {
                if v != nil {
                    var model = ModifyScalingConfigurationShrinkRequest.InstancePatternInfos()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.instancePatternInfos = tmp
        }
        if let value = dict["InstanceTypeOverrides"] as? [Any?] {
            var tmp : [ModifyScalingConfigurationShrinkRequest.InstanceTypeOverrides] = []
            for v in value {
                if v != nil {
                    var model = ModifyScalingConfigurationShrinkRequest.InstanceTypeOverrides()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.instanceTypeOverrides = tmp
        }
        if let value = dict["InstanceTypes"] as? [String] {
            self.instanceTypes = value
        }
        if let value = dict["InternetChargeType"] as? String {
            self.internetChargeType = value
        }
        if let value = dict["InternetMaxBandwidthIn"] as? Int32 {
            self.internetMaxBandwidthIn = value
        }
        if let value = dict["InternetMaxBandwidthOut"] as? Int32 {
            self.internetMaxBandwidthOut = value
        }
        if let value = dict["IoOptimized"] as? String {
            self.ioOptimized = value
        }
        if let value = dict["Ipv6AddressCount"] as? Int32 {
            self.ipv6AddressCount = value
        }
        if let value = dict["KeyPairName"] as? String {
            self.keyPairName = value
        }
        if let value = dict["LoadBalancerWeight"] as? Int32 {
            self.loadBalancerWeight = value
        }
        if let value = dict["Memory"] as? Int32 {
            self.memory = value
        }
        if let value = dict["NetworkInterfaces"] as? [Any?] {
            var tmp : [ModifyScalingConfigurationShrinkRequest.NetworkInterfaces] = []
            for v in value {
                if v != nil {
                    var model = ModifyScalingConfigurationShrinkRequest.NetworkInterfaces()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.networkInterfaces = tmp
        }
        if let value = dict["Override"] as? Bool {
            self.override_ = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Password"] as? String {
            self.password = value
        }
        if let value = dict["PasswordInherit"] as? Bool {
            self.passwordInherit = value
        }
        if let value = dict["RamRoleName"] as? String {
            self.ramRoleName = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourcePoolOptions"] as? [String: Any?] {
            var model = ModifyScalingConfigurationShrinkRequest.ResourcePoolOptions()
            model.fromMap(value)
            self.resourcePoolOptions = model
        }
        if let value = dict["ScalingConfigurationId"] as? String {
            self.scalingConfigurationId = value
        }
        if let value = dict["ScalingConfigurationName"] as? String {
            self.scalingConfigurationName = value
        }
        if let value = dict["SchedulerOptions"] as? String {
            self.schedulerOptionsShrink = value
        }
        if let value = dict["SecurityGroupId"] as? String {
            self.securityGroupId = value
        }
        if let value = dict["SecurityGroupIds"] as? [String] {
            self.securityGroupIds = value
        }
        if let value = dict["SecurityOptions"] as? [String: Any?] {
            var model = ModifyScalingConfigurationShrinkRequest.SecurityOptions()
            model.fromMap(value)
            self.securityOptions = model
        }
        if let value = dict["SpotDuration"] as? Int32 {
            self.spotDuration = value
        }
        if let value = dict["SpotInterruptionBehavior"] as? String {
            self.spotInterruptionBehavior = value
        }
        if let value = dict["SpotPriceLimits"] as? [Any?] {
            var tmp : [ModifyScalingConfigurationShrinkRequest.SpotPriceLimits] = []
            for v in value {
                if v != nil {
                    var model = ModifyScalingConfigurationShrinkRequest.SpotPriceLimits()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.spotPriceLimits = tmp
        }
        if let value = dict["SpotStrategy"] as? String {
            self.spotStrategy = value
        }
        if let value = dict["StorageSetId"] as? String {
            self.storageSetId = value
        }
        if let value = dict["StorageSetPartitionNumber"] as? Int32 {
            self.storageSetPartitionNumber = value
        }
        if let value = dict["SystemDiskCategories"] as? [String] {
            self.systemDiskCategories = value
        }
        if let value = dict["Tags"] as? String {
            self.tags = value
        }
        if let value = dict["Tenancy"] as? String {
            self.tenancy = value
        }
        if let value = dict["UserData"] as? String {
            self.userData = value
        }
        if let value = dict["ZoneId"] as? String {
            self.zoneId = value
        }
    }
}

public class ModifyScalingConfigurationResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyScalingConfigurationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyScalingConfigurationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyScalingConfigurationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyScalingGroupRequest : Tea.TeaModel {
    public class CapacityOptions : Tea.TeaModel {
        public var compensateWithOnDemand: Bool?

        public var onDemandBaseCapacity: Int32?

        public var onDemandPercentageAboveBaseCapacity: Int32?

        public var priceComparisonMode: String?

        public var spotAutoReplaceOnDemand: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.compensateWithOnDemand != nil {
                map["CompensateWithOnDemand"] = self.compensateWithOnDemand!
            }
            if self.onDemandBaseCapacity != nil {
                map["OnDemandBaseCapacity"] = self.onDemandBaseCapacity!
            }
            if self.onDemandPercentageAboveBaseCapacity != nil {
                map["OnDemandPercentageAboveBaseCapacity"] = self.onDemandPercentageAboveBaseCapacity!
            }
            if self.priceComparisonMode != nil {
                map["PriceComparisonMode"] = self.priceComparisonMode!
            }
            if self.spotAutoReplaceOnDemand != nil {
                map["SpotAutoReplaceOnDemand"] = self.spotAutoReplaceOnDemand!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CompensateWithOnDemand"] as? Bool {
                self.compensateWithOnDemand = value
            }
            if let value = dict["OnDemandBaseCapacity"] as? Int32 {
                self.onDemandBaseCapacity = value
            }
            if let value = dict["OnDemandPercentageAboveBaseCapacity"] as? Int32 {
                self.onDemandPercentageAboveBaseCapacity = value
            }
            if let value = dict["PriceComparisonMode"] as? String {
                self.priceComparisonMode = value
            }
            if let value = dict["SpotAutoReplaceOnDemand"] as? Bool {
                self.spotAutoReplaceOnDemand = value
            }
        }
    }
    public class LaunchTemplateOverrides : Tea.TeaModel {
        public var instanceType: String?

        public var spotPriceLimit: Double?

        public var weightedCapacity: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.spotPriceLimit != nil {
                map["SpotPriceLimit"] = self.spotPriceLimit!
            }
            if self.weightedCapacity != nil {
                map["WeightedCapacity"] = self.weightedCapacity!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["InstanceType"] as? String {
                self.instanceType = value
            }
            if let value = dict["SpotPriceLimit"] as? Double {
                self.spotPriceLimit = value
            }
            if let value = dict["WeightedCapacity"] as? Int32 {
                self.weightedCapacity = value
            }
        }
    }
    public var activeScalingConfigurationId: String?

    public var allocationStrategy: String?

    public var azBalance: Bool?

    public var capacityOptions: ModifyScalingGroupRequest.CapacityOptions?

    public var compensateWithOnDemand: Bool?

    public var customPolicyARN: String?

    public var defaultCooldown: Int32?

    public var desiredCapacity: Int32?

    public var disableDesiredCapacity: Bool?

    public var groupDeletionProtection: Bool?

    public var healthCheckType: String?

    public var healthCheckTypes: [String]?

    public var launchTemplateId: String?

    public var launchTemplateOverrides: [ModifyScalingGroupRequest.LaunchTemplateOverrides]?

    public var launchTemplateVersion: String?

    public var maxInstanceLifetime: Int32?

    public var maxSize: Int32?

    public var minSize: Int32?

    public var multiAZPolicy: String?

    public var onDemandBaseCapacity: Int32?

    public var onDemandPercentageAboveBaseCapacity: Int32?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var removalPolicies: [String]?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var scalingGroupId: String?

    public var scalingGroupName: String?

    public var scalingPolicy: String?

    public var spotAllocationStrategy: String?

    public var spotInstancePools: Int32?

    public var spotInstanceRemedy: Bool?

    public var stopInstanceTimeout: Int32?

    public var vSwitchIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.capacityOptions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.activeScalingConfigurationId != nil {
            map["ActiveScalingConfigurationId"] = self.activeScalingConfigurationId!
        }
        if self.allocationStrategy != nil {
            map["AllocationStrategy"] = self.allocationStrategy!
        }
        if self.azBalance != nil {
            map["AzBalance"] = self.azBalance!
        }
        if self.capacityOptions != nil {
            map["CapacityOptions"] = self.capacityOptions?.toMap()
        }
        if self.compensateWithOnDemand != nil {
            map["CompensateWithOnDemand"] = self.compensateWithOnDemand!
        }
        if self.customPolicyARN != nil {
            map["CustomPolicyARN"] = self.customPolicyARN!
        }
        if self.defaultCooldown != nil {
            map["DefaultCooldown"] = self.defaultCooldown!
        }
        if self.desiredCapacity != nil {
            map["DesiredCapacity"] = self.desiredCapacity!
        }
        if self.disableDesiredCapacity != nil {
            map["DisableDesiredCapacity"] = self.disableDesiredCapacity!
        }
        if self.groupDeletionProtection != nil {
            map["GroupDeletionProtection"] = self.groupDeletionProtection!
        }
        if self.healthCheckType != nil {
            map["HealthCheckType"] = self.healthCheckType!
        }
        if self.healthCheckTypes != nil {
            map["HealthCheckTypes"] = self.healthCheckTypes!
        }
        if self.launchTemplateId != nil {
            map["LaunchTemplateId"] = self.launchTemplateId!
        }
        if self.launchTemplateOverrides != nil {
            var tmp : [Any] = []
            for k in self.launchTemplateOverrides! {
                tmp.append(k.toMap())
            }
            map["LaunchTemplateOverrides"] = tmp
        }
        if self.launchTemplateVersion != nil {
            map["LaunchTemplateVersion"] = self.launchTemplateVersion!
        }
        if self.maxInstanceLifetime != nil {
            map["MaxInstanceLifetime"] = self.maxInstanceLifetime!
        }
        if self.maxSize != nil {
            map["MaxSize"] = self.maxSize!
        }
        if self.minSize != nil {
            map["MinSize"] = self.minSize!
        }
        if self.multiAZPolicy != nil {
            map["MultiAZPolicy"] = self.multiAZPolicy!
        }
        if self.onDemandBaseCapacity != nil {
            map["OnDemandBaseCapacity"] = self.onDemandBaseCapacity!
        }
        if self.onDemandPercentageAboveBaseCapacity != nil {
            map["OnDemandPercentageAboveBaseCapacity"] = self.onDemandPercentageAboveBaseCapacity!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.removalPolicies != nil {
            map["RemovalPolicies"] = self.removalPolicies!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        if self.scalingGroupName != nil {
            map["ScalingGroupName"] = self.scalingGroupName!
        }
        if self.scalingPolicy != nil {
            map["ScalingPolicy"] = self.scalingPolicy!
        }
        if self.spotAllocationStrategy != nil {
            map["SpotAllocationStrategy"] = self.spotAllocationStrategy!
        }
        if self.spotInstancePools != nil {
            map["SpotInstancePools"] = self.spotInstancePools!
        }
        if self.spotInstanceRemedy != nil {
            map["SpotInstanceRemedy"] = self.spotInstanceRemedy!
        }
        if self.stopInstanceTimeout != nil {
            map["StopInstanceTimeout"] = self.stopInstanceTimeout!
        }
        if self.vSwitchIds != nil {
            map["VSwitchIds"] = self.vSwitchIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ActiveScalingConfigurationId"] as? String {
            self.activeScalingConfigurationId = value
        }
        if let value = dict["AllocationStrategy"] as? String {
            self.allocationStrategy = value
        }
        if let value = dict["AzBalance"] as? Bool {
            self.azBalance = value
        }
        if let value = dict["CapacityOptions"] as? [String: Any?] {
            var model = ModifyScalingGroupRequest.CapacityOptions()
            model.fromMap(value)
            self.capacityOptions = model
        }
        if let value = dict["CompensateWithOnDemand"] as? Bool {
            self.compensateWithOnDemand = value
        }
        if let value = dict["CustomPolicyARN"] as? String {
            self.customPolicyARN = value
        }
        if let value = dict["DefaultCooldown"] as? Int32 {
            self.defaultCooldown = value
        }
        if let value = dict["DesiredCapacity"] as? Int32 {
            self.desiredCapacity = value
        }
        if let value = dict["DisableDesiredCapacity"] as? Bool {
            self.disableDesiredCapacity = value
        }
        if let value = dict["GroupDeletionProtection"] as? Bool {
            self.groupDeletionProtection = value
        }
        if let value = dict["HealthCheckType"] as? String {
            self.healthCheckType = value
        }
        if let value = dict["HealthCheckTypes"] as? [String] {
            self.healthCheckTypes = value
        }
        if let value = dict["LaunchTemplateId"] as? String {
            self.launchTemplateId = value
        }
        if let value = dict["LaunchTemplateOverrides"] as? [Any?] {
            var tmp : [ModifyScalingGroupRequest.LaunchTemplateOverrides] = []
            for v in value {
                if v != nil {
                    var model = ModifyScalingGroupRequest.LaunchTemplateOverrides()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.launchTemplateOverrides = tmp
        }
        if let value = dict["LaunchTemplateVersion"] as? String {
            self.launchTemplateVersion = value
        }
        if let value = dict["MaxInstanceLifetime"] as? Int32 {
            self.maxInstanceLifetime = value
        }
        if let value = dict["MaxSize"] as? Int32 {
            self.maxSize = value
        }
        if let value = dict["MinSize"] as? Int32 {
            self.minSize = value
        }
        if let value = dict["MultiAZPolicy"] as? String {
            self.multiAZPolicy = value
        }
        if let value = dict["OnDemandBaseCapacity"] as? Int32 {
            self.onDemandBaseCapacity = value
        }
        if let value = dict["OnDemandPercentageAboveBaseCapacity"] as? Int32 {
            self.onDemandPercentageAboveBaseCapacity = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RemovalPolicies"] as? [String] {
            self.removalPolicies = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ScalingGroupId"] as? String {
            self.scalingGroupId = value
        }
        if let value = dict["ScalingGroupName"] as? String {
            self.scalingGroupName = value
        }
        if let value = dict["ScalingPolicy"] as? String {
            self.scalingPolicy = value
        }
        if let value = dict["SpotAllocationStrategy"] as? String {
            self.spotAllocationStrategy = value
        }
        if let value = dict["SpotInstancePools"] as? Int32 {
            self.spotInstancePools = value
        }
        if let value = dict["SpotInstanceRemedy"] as? Bool {
            self.spotInstanceRemedy = value
        }
        if let value = dict["StopInstanceTimeout"] as? Int32 {
            self.stopInstanceTimeout = value
        }
        if let value = dict["VSwitchIds"] as? [String] {
            self.vSwitchIds = value
        }
    }
}

public class ModifyScalingGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyScalingGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyScalingGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyScalingGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyScalingRuleRequest : Tea.TeaModel {
    public class AlarmDimensions : Tea.TeaModel {
        public var dimensionKey: String?

        public var dimensionValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dimensionKey != nil {
                map["DimensionKey"] = self.dimensionKey!
            }
            if self.dimensionValue != nil {
                map["DimensionValue"] = self.dimensionValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DimensionKey"] as? String {
                self.dimensionKey = value
            }
            if let value = dict["DimensionValue"] as? String {
                self.dimensionValue = value
            }
        }
    }
    public class AlarmOptions : Tea.TeaModel {
        public var period: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.period != nil {
                map["Period"] = self.period!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Period"] as? Int32 {
                self.period = value
            }
        }
    }
    public class HybridMetrics : Tea.TeaModel {
        public class Dimensions : Tea.TeaModel {
            public var dimensionKey: String?

            public var dimensionValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dimensionKey != nil {
                    map["DimensionKey"] = self.dimensionKey!
                }
                if self.dimensionValue != nil {
                    map["DimensionValue"] = self.dimensionValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DimensionKey"] as? String {
                    self.dimensionKey = value
                }
                if let value = dict["DimensionValue"] as? String {
                    self.dimensionValue = value
                }
            }
        }
        public var dimensions: [ModifyScalingRuleRequest.HybridMetrics.Dimensions]?

        public var expression: String?

        public var id: String?

        public var metricName: String?

        public var statistic: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dimensions != nil {
                var tmp : [Any] = []
                for k in self.dimensions! {
                    tmp.append(k.toMap())
                }
                map["Dimensions"] = tmp
            }
            if self.expression != nil {
                map["Expression"] = self.expression!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.metricName != nil {
                map["MetricName"] = self.metricName!
            }
            if self.statistic != nil {
                map["Statistic"] = self.statistic!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Dimensions"] as? [Any?] {
                var tmp : [ModifyScalingRuleRequest.HybridMetrics.Dimensions] = []
                for v in value {
                    if v != nil {
                        var model = ModifyScalingRuleRequest.HybridMetrics.Dimensions()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.dimensions = tmp
            }
            if let value = dict["Expression"] as? String {
                self.expression = value
            }
            if let value = dict["Id"] as? String {
                self.id = value
            }
            if let value = dict["MetricName"] as? String {
                self.metricName = value
            }
            if let value = dict["Statistic"] as? String {
                self.statistic = value
            }
        }
    }
    public class StepAdjustments : Tea.TeaModel {
        public var metricIntervalLowerBound: Double?

        public var metricIntervalUpperBound: Double?

        public var scalingAdjustment: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.metricIntervalLowerBound != nil {
                map["MetricIntervalLowerBound"] = self.metricIntervalLowerBound!
            }
            if self.metricIntervalUpperBound != nil {
                map["MetricIntervalUpperBound"] = self.metricIntervalUpperBound!
            }
            if self.scalingAdjustment != nil {
                map["ScalingAdjustment"] = self.scalingAdjustment!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["MetricIntervalLowerBound"] as? Double {
                self.metricIntervalLowerBound = value
            }
            if let value = dict["MetricIntervalUpperBound"] as? Double {
                self.metricIntervalUpperBound = value
            }
            if let value = dict["ScalingAdjustment"] as? Int32 {
                self.scalingAdjustment = value
            }
        }
    }
    public var adjustmentType: String?

    public var adjustmentValue: Int32?

    public var alarmDimensions: [ModifyScalingRuleRequest.AlarmDimensions]?

    public var alarmOptions: ModifyScalingRuleRequest.AlarmOptions?

    public var cooldown: Int32?

    public var disableScaleIn: Bool?

    public var estimatedInstanceWarmup: Int32?

    public var hybridMetrics: [ModifyScalingRuleRequest.HybridMetrics]?

    public var hybridMonitorNamespace: String?

    public var initialMaxSize: Int32?

    public var metricName: String?

    public var metricType: String?

    public var minAdjustmentMagnitude: Int32?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var predictiveScalingMode: String?

    public var predictiveTaskBufferTime: Int32?

    public var predictiveValueBehavior: String?

    public var predictiveValueBuffer: Int32?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var scaleInEvaluationCount: Int32?

    public var scaleOutEvaluationCount: Int32?

    public var scalingRuleId: String?

    public var scalingRuleName: String?

    public var stepAdjustments: [ModifyScalingRuleRequest.StepAdjustments]?

    public var targetValue: Double?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.alarmOptions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.adjustmentType != nil {
            map["AdjustmentType"] = self.adjustmentType!
        }
        if self.adjustmentValue != nil {
            map["AdjustmentValue"] = self.adjustmentValue!
        }
        if self.alarmDimensions != nil {
            var tmp : [Any] = []
            for k in self.alarmDimensions! {
                tmp.append(k.toMap())
            }
            map["AlarmDimensions"] = tmp
        }
        if self.alarmOptions != nil {
            map["AlarmOptions"] = self.alarmOptions?.toMap()
        }
        if self.cooldown != nil {
            map["Cooldown"] = self.cooldown!
        }
        if self.disableScaleIn != nil {
            map["DisableScaleIn"] = self.disableScaleIn!
        }
        if self.estimatedInstanceWarmup != nil {
            map["EstimatedInstanceWarmup"] = self.estimatedInstanceWarmup!
        }
        if self.hybridMetrics != nil {
            var tmp : [Any] = []
            for k in self.hybridMetrics! {
                tmp.append(k.toMap())
            }
            map["HybridMetrics"] = tmp
        }
        if self.hybridMonitorNamespace != nil {
            map["HybridMonitorNamespace"] = self.hybridMonitorNamespace!
        }
        if self.initialMaxSize != nil {
            map["InitialMaxSize"] = self.initialMaxSize!
        }
        if self.metricName != nil {
            map["MetricName"] = self.metricName!
        }
        if self.metricType != nil {
            map["MetricType"] = self.metricType!
        }
        if self.minAdjustmentMagnitude != nil {
            map["MinAdjustmentMagnitude"] = self.minAdjustmentMagnitude!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.predictiveScalingMode != nil {
            map["PredictiveScalingMode"] = self.predictiveScalingMode!
        }
        if self.predictiveTaskBufferTime != nil {
            map["PredictiveTaskBufferTime"] = self.predictiveTaskBufferTime!
        }
        if self.predictiveValueBehavior != nil {
            map["PredictiveValueBehavior"] = self.predictiveValueBehavior!
        }
        if self.predictiveValueBuffer != nil {
            map["PredictiveValueBuffer"] = self.predictiveValueBuffer!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.scaleInEvaluationCount != nil {
            map["ScaleInEvaluationCount"] = self.scaleInEvaluationCount!
        }
        if self.scaleOutEvaluationCount != nil {
            map["ScaleOutEvaluationCount"] = self.scaleOutEvaluationCount!
        }
        if self.scalingRuleId != nil {
            map["ScalingRuleId"] = self.scalingRuleId!
        }
        if self.scalingRuleName != nil {
            map["ScalingRuleName"] = self.scalingRuleName!
        }
        if self.stepAdjustments != nil {
            var tmp : [Any] = []
            for k in self.stepAdjustments! {
                tmp.append(k.toMap())
            }
            map["StepAdjustments"] = tmp
        }
        if self.targetValue != nil {
            map["TargetValue"] = self.targetValue!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AdjustmentType"] as? String {
            self.adjustmentType = value
        }
        if let value = dict["AdjustmentValue"] as? Int32 {
            self.adjustmentValue = value
        }
        if let value = dict["AlarmDimensions"] as? [Any?] {
            var tmp : [ModifyScalingRuleRequest.AlarmDimensions] = []
            for v in value {
                if v != nil {
                    var model = ModifyScalingRuleRequest.AlarmDimensions()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.alarmDimensions = tmp
        }
        if let value = dict["AlarmOptions"] as? [String: Any?] {
            var model = ModifyScalingRuleRequest.AlarmOptions()
            model.fromMap(value)
            self.alarmOptions = model
        }
        if let value = dict["Cooldown"] as? Int32 {
            self.cooldown = value
        }
        if let value = dict["DisableScaleIn"] as? Bool {
            self.disableScaleIn = value
        }
        if let value = dict["EstimatedInstanceWarmup"] as? Int32 {
            self.estimatedInstanceWarmup = value
        }
        if let value = dict["HybridMetrics"] as? [Any?] {
            var tmp : [ModifyScalingRuleRequest.HybridMetrics] = []
            for v in value {
                if v != nil {
                    var model = ModifyScalingRuleRequest.HybridMetrics()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.hybridMetrics = tmp
        }
        if let value = dict["HybridMonitorNamespace"] as? String {
            self.hybridMonitorNamespace = value
        }
        if let value = dict["InitialMaxSize"] as? Int32 {
            self.initialMaxSize = value
        }
        if let value = dict["MetricName"] as? String {
            self.metricName = value
        }
        if let value = dict["MetricType"] as? String {
            self.metricType = value
        }
        if let value = dict["MinAdjustmentMagnitude"] as? Int32 {
            self.minAdjustmentMagnitude = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PredictiveScalingMode"] as? String {
            self.predictiveScalingMode = value
        }
        if let value = dict["PredictiveTaskBufferTime"] as? Int32 {
            self.predictiveTaskBufferTime = value
        }
        if let value = dict["PredictiveValueBehavior"] as? String {
            self.predictiveValueBehavior = value
        }
        if let value = dict["PredictiveValueBuffer"] as? Int32 {
            self.predictiveValueBuffer = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ScaleInEvaluationCount"] as? Int32 {
            self.scaleInEvaluationCount = value
        }
        if let value = dict["ScaleOutEvaluationCount"] as? Int32 {
            self.scaleOutEvaluationCount = value
        }
        if let value = dict["ScalingRuleId"] as? String {
            self.scalingRuleId = value
        }
        if let value = dict["ScalingRuleName"] as? String {
            self.scalingRuleName = value
        }
        if let value = dict["StepAdjustments"] as? [Any?] {
            var tmp : [ModifyScalingRuleRequest.StepAdjustments] = []
            for v in value {
                if v != nil {
                    var model = ModifyScalingRuleRequest.StepAdjustments()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.stepAdjustments = tmp
        }
        if let value = dict["TargetValue"] as? Double {
            self.targetValue = value
        }
    }
}

public class ModifyScalingRuleResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyScalingRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyScalingRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyScalingRuleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyScheduledTaskRequest : Tea.TeaModel {
    public var description_: String?

    public var desiredCapacity: Int32?

    public var launchExpirationTime: Int32?

    public var launchTime: String?

    public var maxValue: Int32?

    public var minValue: Int32?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var recurrenceEndTime: String?

    public var recurrenceType: String?

    public var recurrenceValue: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var scalingGroupId: String?

    public var scheduledAction: String?

    public var scheduledTaskId: String?

    public var scheduledTaskName: String?

    public var taskEnabled: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.desiredCapacity != nil {
            map["DesiredCapacity"] = self.desiredCapacity!
        }
        if self.launchExpirationTime != nil {
            map["LaunchExpirationTime"] = self.launchExpirationTime!
        }
        if self.launchTime != nil {
            map["LaunchTime"] = self.launchTime!
        }
        if self.maxValue != nil {
            map["MaxValue"] = self.maxValue!
        }
        if self.minValue != nil {
            map["MinValue"] = self.minValue!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.recurrenceEndTime != nil {
            map["RecurrenceEndTime"] = self.recurrenceEndTime!
        }
        if self.recurrenceType != nil {
            map["RecurrenceType"] = self.recurrenceType!
        }
        if self.recurrenceValue != nil {
            map["RecurrenceValue"] = self.recurrenceValue!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        if self.scheduledAction != nil {
            map["ScheduledAction"] = self.scheduledAction!
        }
        if self.scheduledTaskId != nil {
            map["ScheduledTaskId"] = self.scheduledTaskId!
        }
        if self.scheduledTaskName != nil {
            map["ScheduledTaskName"] = self.scheduledTaskName!
        }
        if self.taskEnabled != nil {
            map["TaskEnabled"] = self.taskEnabled!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["DesiredCapacity"] as? Int32 {
            self.desiredCapacity = value
        }
        if let value = dict["LaunchExpirationTime"] as? Int32 {
            self.launchExpirationTime = value
        }
        if let value = dict["LaunchTime"] as? String {
            self.launchTime = value
        }
        if let value = dict["MaxValue"] as? Int32 {
            self.maxValue = value
        }
        if let value = dict["MinValue"] as? Int32 {
            self.minValue = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RecurrenceEndTime"] as? String {
            self.recurrenceEndTime = value
        }
        if let value = dict["RecurrenceType"] as? String {
            self.recurrenceType = value
        }
        if let value = dict["RecurrenceValue"] as? String {
            self.recurrenceValue = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ScalingGroupId"] as? String {
            self.scalingGroupId = value
        }
        if let value = dict["ScheduledAction"] as? String {
            self.scheduledAction = value
        }
        if let value = dict["ScheduledTaskId"] as? String {
            self.scheduledTaskId = value
        }
        if let value = dict["ScheduledTaskName"] as? String {
            self.scheduledTaskName = value
        }
        if let value = dict["TaskEnabled"] as? Bool {
            self.taskEnabled = value
        }
    }
}

public class ModifyScheduledTaskResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyScheduledTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyScheduledTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyScheduledTaskResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RebalanceInstancesRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ScalingGroupId"] as? String {
            self.scalingGroupId = value
        }
    }
}

public class RebalanceInstancesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var scalingActivityId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingActivityId != nil {
            map["ScalingActivityId"] = self.scalingActivityId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ScalingActivityId"] as? String {
            self.scalingActivityId = value
        }
    }
}

public class RebalanceInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RebalanceInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RebalanceInstancesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RecordLifecycleActionHeartbeatRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var heartbeatTimeout: Int32?

    public var lifecycleActionToken: String?

    public var lifecycleHookId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.heartbeatTimeout != nil {
            map["heartbeatTimeout"] = self.heartbeatTimeout!
        }
        if self.lifecycleActionToken != nil {
            map["lifecycleActionToken"] = self.lifecycleActionToken!
        }
        if self.lifecycleHookId != nil {
            map["lifecycleHookId"] = self.lifecycleHookId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["heartbeatTimeout"] as? Int32 {
            self.heartbeatTimeout = value
        }
        if let value = dict["lifecycleActionToken"] as? String {
            self.lifecycleActionToken = value
        }
        if let value = dict["lifecycleHookId"] as? String {
            self.lifecycleHookId = value
        }
    }
}

public class RecordLifecycleActionHeartbeatResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class RecordLifecycleActionHeartbeatResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RecordLifecycleActionHeartbeatResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RecordLifecycleActionHeartbeatResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RemoveInstancesRequest : Tea.TeaModel {
    public class LifecycleHookContext : Tea.TeaModel {
        public var disableLifecycleHook: Bool?

        public var ignoredLifecycleHookIds: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.disableLifecycleHook != nil {
                map["DisableLifecycleHook"] = self.disableLifecycleHook!
            }
            if self.ignoredLifecycleHookIds != nil {
                map["IgnoredLifecycleHookIds"] = self.ignoredLifecycleHookIds!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DisableLifecycleHook"] as? Bool {
                self.disableLifecycleHook = value
            }
            if let value = dict["IgnoredLifecycleHookIds"] as? [String] {
                self.ignoredLifecycleHookIds = value
            }
        }
    }
    public var clientToken: String?

    public var decreaseDesiredCapacity: Bool?

    public var ignoreInvalidInstance: Bool?

    public var instanceIds: [String]?

    public var lifecycleHookContext: RemoveInstancesRequest.LifecycleHookContext?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var removePolicy: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var scalingGroupId: String?

    public var stopInstanceTimeout: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.lifecycleHookContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.decreaseDesiredCapacity != nil {
            map["DecreaseDesiredCapacity"] = self.decreaseDesiredCapacity!
        }
        if self.ignoreInvalidInstance != nil {
            map["IgnoreInvalidInstance"] = self.ignoreInvalidInstance!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.lifecycleHookContext != nil {
            map["LifecycleHookContext"] = self.lifecycleHookContext?.toMap()
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.removePolicy != nil {
            map["RemovePolicy"] = self.removePolicy!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        if self.stopInstanceTimeout != nil {
            map["StopInstanceTimeout"] = self.stopInstanceTimeout!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DecreaseDesiredCapacity"] as? Bool {
            self.decreaseDesiredCapacity = value
        }
        if let value = dict["IgnoreInvalidInstance"] as? Bool {
            self.ignoreInvalidInstance = value
        }
        if let value = dict["InstanceIds"] as? [String] {
            self.instanceIds = value
        }
        if let value = dict["LifecycleHookContext"] as? [String: Any?] {
            var model = RemoveInstancesRequest.LifecycleHookContext()
            model.fromMap(value)
            self.lifecycleHookContext = model
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RemovePolicy"] as? String {
            self.removePolicy = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ScalingGroupId"] as? String {
            self.scalingGroupId = value
        }
        if let value = dict["StopInstanceTimeout"] as? Int32 {
            self.stopInstanceTimeout = value
        }
    }
}

public class RemoveInstancesShrinkRequest : Tea.TeaModel {
    public var clientToken: String?

    public var decreaseDesiredCapacity: Bool?

    public var ignoreInvalidInstance: Bool?

    public var instanceIds: [String]?

    public var lifecycleHookContextShrink: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var removePolicy: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var scalingGroupId: String?

    public var stopInstanceTimeout: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.decreaseDesiredCapacity != nil {
            map["DecreaseDesiredCapacity"] = self.decreaseDesiredCapacity!
        }
        if self.ignoreInvalidInstance != nil {
            map["IgnoreInvalidInstance"] = self.ignoreInvalidInstance!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.lifecycleHookContextShrink != nil {
            map["LifecycleHookContext"] = self.lifecycleHookContextShrink!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.removePolicy != nil {
            map["RemovePolicy"] = self.removePolicy!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        if self.stopInstanceTimeout != nil {
            map["StopInstanceTimeout"] = self.stopInstanceTimeout!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DecreaseDesiredCapacity"] as? Bool {
            self.decreaseDesiredCapacity = value
        }
        if let value = dict["IgnoreInvalidInstance"] as? Bool {
            self.ignoreInvalidInstance = value
        }
        if let value = dict["InstanceIds"] as? [String] {
            self.instanceIds = value
        }
        if let value = dict["LifecycleHookContext"] as? String {
            self.lifecycleHookContextShrink = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RemovePolicy"] as? String {
            self.removePolicy = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ScalingGroupId"] as? String {
            self.scalingGroupId = value
        }
        if let value = dict["StopInstanceTimeout"] as? Int32 {
            self.stopInstanceTimeout = value
        }
    }
}

public class RemoveInstancesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var scalingActivityId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingActivityId != nil {
            map["ScalingActivityId"] = self.scalingActivityId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ScalingActivityId"] as? String {
            self.scalingActivityId = value
        }
    }
}

public class RemoveInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RemoveInstancesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ResumeInstanceRefreshRequest : Tea.TeaModel {
    public var instanceRefreshTaskId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceRefreshTaskId != nil {
            map["InstanceRefreshTaskId"] = self.instanceRefreshTaskId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceRefreshTaskId"] as? String {
            self.instanceRefreshTaskId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ScalingGroupId"] as? String {
            self.scalingGroupId = value
        }
    }
}

public class ResumeInstanceRefreshResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ResumeInstanceRefreshResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ResumeInstanceRefreshResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ResumeInstanceRefreshResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ResumeProcessesRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerId: Int64?

    public var processes: [String]?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.processes != nil {
            map["Processes"] = self.processes!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Processes"] as? [String] {
            self.processes = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ScalingGroupId"] as? String {
            self.scalingGroupId = value
        }
    }
}

public class ResumeProcessesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ResumeProcessesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ResumeProcessesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ResumeProcessesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RollbackInstanceRefreshRequest : Tea.TeaModel {
    public var instanceRefreshTaskId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceRefreshTaskId != nil {
            map["InstanceRefreshTaskId"] = self.instanceRefreshTaskId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceRefreshTaskId"] as? String {
            self.instanceRefreshTaskId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ScalingGroupId"] as? String {
            self.scalingGroupId = value
        }
    }
}

public class RollbackInstanceRefreshResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class RollbackInstanceRefreshResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RollbackInstanceRefreshResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RollbackInstanceRefreshResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ScaleWithAdjustmentRequest : Tea.TeaModel {
    public class LifecycleHookContext : Tea.TeaModel {
        public var disableLifecycleHook: Bool?

        public var ignoredLifecycleHookIds: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.disableLifecycleHook != nil {
                map["DisableLifecycleHook"] = self.disableLifecycleHook!
            }
            if self.ignoredLifecycleHookIds != nil {
                map["IgnoredLifecycleHookIds"] = self.ignoredLifecycleHookIds!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DisableLifecycleHook"] as? Bool {
                self.disableLifecycleHook = value
            }
            if let value = dict["IgnoredLifecycleHookIds"] as? [String] {
                self.ignoredLifecycleHookIds = value
            }
        }
    }
    public class Overrides : Tea.TeaModel {
        public class ContainerOverrides : Tea.TeaModel {
            public class EnvironmentVars : Tea.TeaModel {
                public var key: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Key"] as? String {
                        self.key = value
                    }
                    if let value = dict["Value"] as? String {
                        self.value = value
                    }
                }
            }
            public var args: [String]?

            public var commands: [String]?

            public var cpu: Double?

            public var environmentVars: [ScaleWithAdjustmentRequest.Overrides.ContainerOverrides.EnvironmentVars]?

            public var memory: Double?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.args != nil {
                    map["Args"] = self.args!
                }
                if self.commands != nil {
                    map["Commands"] = self.commands!
                }
                if self.cpu != nil {
                    map["Cpu"] = self.cpu!
                }
                if self.environmentVars != nil {
                    var tmp : [Any] = []
                    for k in self.environmentVars! {
                        tmp.append(k.toMap())
                    }
                    map["EnvironmentVars"] = tmp
                }
                if self.memory != nil {
                    map["Memory"] = self.memory!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Args"] as? [String] {
                    self.args = value
                }
                if let value = dict["Commands"] as? [String] {
                    self.commands = value
                }
                if let value = dict["Cpu"] as? Double {
                    self.cpu = value
                }
                if let value = dict["EnvironmentVars"] as? [Any?] {
                    var tmp : [ScaleWithAdjustmentRequest.Overrides.ContainerOverrides.EnvironmentVars] = []
                    for v in value {
                        if v != nil {
                            var model = ScaleWithAdjustmentRequest.Overrides.ContainerOverrides.EnvironmentVars()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.environmentVars = tmp
                }
                if let value = dict["Memory"] as? Double {
                    self.memory = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
            }
        }
        public var containerOverrides: [ScaleWithAdjustmentRequest.Overrides.ContainerOverrides]?

        public var cpu: Double?

        public var memory: Double?

        public var userData: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.containerOverrides != nil {
                var tmp : [Any] = []
                for k in self.containerOverrides! {
                    tmp.append(k.toMap())
                }
                map["ContainerOverrides"] = tmp
            }
            if self.cpu != nil {
                map["Cpu"] = self.cpu!
            }
            if self.memory != nil {
                map["Memory"] = self.memory!
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ContainerOverrides"] as? [Any?] {
                var tmp : [ScaleWithAdjustmentRequest.Overrides.ContainerOverrides] = []
                for v in value {
                    if v != nil {
                        var model = ScaleWithAdjustmentRequest.Overrides.ContainerOverrides()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.containerOverrides = tmp
            }
            if let value = dict["Cpu"] as? Double {
                self.cpu = value
            }
            if let value = dict["Memory"] as? Double {
                self.memory = value
            }
            if let value = dict["UserData"] as? String {
                self.userData = value
            }
        }
    }
    public var activityMetadata: String?

    public var adjustmentType: String?

    public var adjustmentValue: Int32?

    public var clientToken: String?

    public var executionMode: String?

    public var lifecycleHookContext: ScaleWithAdjustmentRequest.LifecycleHookContext?

    public var minAdjustmentMagnitude: Int32?

    public var overrides: ScaleWithAdjustmentRequest.Overrides?

    public var ownerId: Int64?

    public var parallelTask: Bool?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public var syncActivity: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.lifecycleHookContext?.validate()
        try self.overrides?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.activityMetadata != nil {
            map["ActivityMetadata"] = self.activityMetadata!
        }
        if self.adjustmentType != nil {
            map["AdjustmentType"] = self.adjustmentType!
        }
        if self.adjustmentValue != nil {
            map["AdjustmentValue"] = self.adjustmentValue!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.executionMode != nil {
            map["ExecutionMode"] = self.executionMode!
        }
        if self.lifecycleHookContext != nil {
            map["LifecycleHookContext"] = self.lifecycleHookContext?.toMap()
        }
        if self.minAdjustmentMagnitude != nil {
            map["MinAdjustmentMagnitude"] = self.minAdjustmentMagnitude!
        }
        if self.overrides != nil {
            map["Overrides"] = self.overrides?.toMap()
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.parallelTask != nil {
            map["ParallelTask"] = self.parallelTask!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        if self.syncActivity != nil {
            map["SyncActivity"] = self.syncActivity!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ActivityMetadata"] as? String {
            self.activityMetadata = value
        }
        if let value = dict["AdjustmentType"] as? String {
            self.adjustmentType = value
        }
        if let value = dict["AdjustmentValue"] as? Int32 {
            self.adjustmentValue = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["ExecutionMode"] as? String {
            self.executionMode = value
        }
        if let value = dict["LifecycleHookContext"] as? [String: Any?] {
            var model = ScaleWithAdjustmentRequest.LifecycleHookContext()
            model.fromMap(value)
            self.lifecycleHookContext = model
        }
        if let value = dict["MinAdjustmentMagnitude"] as? Int32 {
            self.minAdjustmentMagnitude = value
        }
        if let value = dict["Overrides"] as? [String: Any?] {
            var model = ScaleWithAdjustmentRequest.Overrides()
            model.fromMap(value)
            self.overrides = model
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ParallelTask"] as? Bool {
            self.parallelTask = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ScalingGroupId"] as? String {
            self.scalingGroupId = value
        }
        if let value = dict["SyncActivity"] as? Bool {
            self.syncActivity = value
        }
    }
}

public class ScaleWithAdjustmentShrinkRequest : Tea.TeaModel {
    public var activityMetadata: String?

    public var adjustmentType: String?

    public var adjustmentValue: Int32?

    public var clientToken: String?

    public var executionMode: String?

    public var lifecycleHookContextShrink: String?

    public var minAdjustmentMagnitude: Int32?

    public var overridesShrink: String?

    public var ownerId: Int64?

    public var parallelTask: Bool?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public var syncActivity: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.activityMetadata != nil {
            map["ActivityMetadata"] = self.activityMetadata!
        }
        if self.adjustmentType != nil {
            map["AdjustmentType"] = self.adjustmentType!
        }
        if self.adjustmentValue != nil {
            map["AdjustmentValue"] = self.adjustmentValue!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.executionMode != nil {
            map["ExecutionMode"] = self.executionMode!
        }
        if self.lifecycleHookContextShrink != nil {
            map["LifecycleHookContext"] = self.lifecycleHookContextShrink!
        }
        if self.minAdjustmentMagnitude != nil {
            map["MinAdjustmentMagnitude"] = self.minAdjustmentMagnitude!
        }
        if self.overridesShrink != nil {
            map["Overrides"] = self.overridesShrink!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.parallelTask != nil {
            map["ParallelTask"] = self.parallelTask!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        if self.syncActivity != nil {
            map["SyncActivity"] = self.syncActivity!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ActivityMetadata"] as? String {
            self.activityMetadata = value
        }
        if let value = dict["AdjustmentType"] as? String {
            self.adjustmentType = value
        }
        if let value = dict["AdjustmentValue"] as? Int32 {
            self.adjustmentValue = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["ExecutionMode"] as? String {
            self.executionMode = value
        }
        if let value = dict["LifecycleHookContext"] as? String {
            self.lifecycleHookContextShrink = value
        }
        if let value = dict["MinAdjustmentMagnitude"] as? Int32 {
            self.minAdjustmentMagnitude = value
        }
        if let value = dict["Overrides"] as? String {
            self.overridesShrink = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ParallelTask"] as? Bool {
            self.parallelTask = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ScalingGroupId"] as? String {
            self.scalingGroupId = value
        }
        if let value = dict["SyncActivity"] as? Bool {
            self.syncActivity = value
        }
    }
}

public class ScaleWithAdjustmentResponseBody : Tea.TeaModel {
    public class PlanResult : Tea.TeaModel {
        public class ResourceAllocations : Tea.TeaModel {
            public var amount: Int32?

            public var instanceChargeType: String?

            public var instanceType: String?

            public var spotStrategy: String?

            public var zoneId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.amount != nil {
                    map["Amount"] = self.amount!
                }
                if self.instanceChargeType != nil {
                    map["InstanceChargeType"] = self.instanceChargeType!
                }
                if self.instanceType != nil {
                    map["InstanceType"] = self.instanceType!
                }
                if self.spotStrategy != nil {
                    map["SpotStrategy"] = self.spotStrategy!
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Amount"] as? Int32 {
                    self.amount = value
                }
                if let value = dict["InstanceChargeType"] as? String {
                    self.instanceChargeType = value
                }
                if let value = dict["InstanceType"] as? String {
                    self.instanceType = value
                }
                if let value = dict["SpotStrategy"] as? String {
                    self.spotStrategy = value
                }
                if let value = dict["ZoneId"] as? String {
                    self.zoneId = value
                }
            }
        }
        public var resourceAllocations: [ScaleWithAdjustmentResponseBody.PlanResult.ResourceAllocations]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.resourceAllocations != nil {
                var tmp : [Any] = []
                for k in self.resourceAllocations! {
                    tmp.append(k.toMap())
                }
                map["ResourceAllocations"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ResourceAllocations"] as? [Any?] {
                var tmp : [ScaleWithAdjustmentResponseBody.PlanResult.ResourceAllocations] = []
                for v in value {
                    if v != nil {
                        var model = ScaleWithAdjustmentResponseBody.PlanResult.ResourceAllocations()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.resourceAllocations = tmp
            }
        }
    }
    public var activityType: String?

    public var planResult: ScaleWithAdjustmentResponseBody.PlanResult?

    public var requestId: String?

    public var scalingActivityId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.planResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.activityType != nil {
            map["ActivityType"] = self.activityType!
        }
        if self.planResult != nil {
            map["PlanResult"] = self.planResult?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingActivityId != nil {
            map["ScalingActivityId"] = self.scalingActivityId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ActivityType"] as? String {
            self.activityType = value
        }
        if let value = dict["PlanResult"] as? [String: Any?] {
            var model = ScaleWithAdjustmentResponseBody.PlanResult()
            model.fromMap(value)
            self.planResult = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ScalingActivityId"] as? String {
            self.scalingActivityId = value
        }
    }
}

public class ScaleWithAdjustmentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ScaleWithAdjustmentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ScaleWithAdjustmentResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class SetGroupDeletionProtectionRequest : Tea.TeaModel {
    public var groupDeletionProtection: Bool?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupDeletionProtection != nil {
            map["GroupDeletionProtection"] = self.groupDeletionProtection!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["GroupDeletionProtection"] as? Bool {
            self.groupDeletionProtection = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ScalingGroupId"] as? String {
            self.scalingGroupId = value
        }
    }
}

public class SetGroupDeletionProtectionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class SetGroupDeletionProtectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetGroupDeletionProtectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = SetGroupDeletionProtectionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class SetInstanceHealthRequest : Tea.TeaModel {
    public var healthStatus: String?

    public var instanceId: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.healthStatus != nil {
            map["HealthStatus"] = self.healthStatus!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["HealthStatus"] as? String {
            self.healthStatus = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
    }
}

public class SetInstanceHealthResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class SetInstanceHealthResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetInstanceHealthResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = SetInstanceHealthResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class SetInstancesProtectionRequest : Tea.TeaModel {
    public var instanceIds: [String]?

    public var ownerId: Int64?

    public var protectedFromScaleIn: Bool?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.protectedFromScaleIn != nil {
            map["ProtectedFromScaleIn"] = self.protectedFromScaleIn!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceIds"] as? [String] {
            self.instanceIds = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ProtectedFromScaleIn"] as? Bool {
            self.protectedFromScaleIn = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ScalingGroupId"] as? String {
            self.scalingGroupId = value
        }
    }
}

public class SetInstancesProtectionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class SetInstancesProtectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetInstancesProtectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = SetInstancesProtectionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class StartInstanceRefreshRequest : Tea.TeaModel {
    public class DesiredConfiguration : Tea.TeaModel {
        public var imageId: String?

        public var scalingConfigurationId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.imageId != nil {
                map["ImageId"] = self.imageId!
            }
            if self.scalingConfigurationId != nil {
                map["ScalingConfigurationId"] = self.scalingConfigurationId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ImageId"] as? String {
                self.imageId = value
            }
            if let value = dict["ScalingConfigurationId"] as? String {
                self.scalingConfigurationId = value
            }
        }
    }
    public var clientToken: String?

    public var desiredConfiguration: StartInstanceRefreshRequest.DesiredConfiguration?

    public var maxHealthyPercentage: Int32?

    public var minHealthyPercentage: Int32?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public var skipMatching: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.desiredConfiguration?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.desiredConfiguration != nil {
            map["DesiredConfiguration"] = self.desiredConfiguration?.toMap()
        }
        if self.maxHealthyPercentage != nil {
            map["MaxHealthyPercentage"] = self.maxHealthyPercentage!
        }
        if self.minHealthyPercentage != nil {
            map["MinHealthyPercentage"] = self.minHealthyPercentage!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        if self.skipMatching != nil {
            map["SkipMatching"] = self.skipMatching!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DesiredConfiguration"] as? [String: Any?] {
            var model = StartInstanceRefreshRequest.DesiredConfiguration()
            model.fromMap(value)
            self.desiredConfiguration = model
        }
        if let value = dict["MaxHealthyPercentage"] as? Int32 {
            self.maxHealthyPercentage = value
        }
        if let value = dict["MinHealthyPercentage"] as? Int32 {
            self.minHealthyPercentage = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ScalingGroupId"] as? String {
            self.scalingGroupId = value
        }
        if let value = dict["SkipMatching"] as? Bool {
            self.skipMatching = value
        }
    }
}

public class StartInstanceRefreshResponseBody : Tea.TeaModel {
    public var instanceRefreshTaskId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceRefreshTaskId != nil {
            map["InstanceRefreshTaskId"] = self.instanceRefreshTaskId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceRefreshTaskId"] as? String {
            self.instanceRefreshTaskId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class StartInstanceRefreshResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartInstanceRefreshResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = StartInstanceRefreshResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class SuspendInstanceRefreshRequest : Tea.TeaModel {
    public var instanceRefreshTaskId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceRefreshTaskId != nil {
            map["InstanceRefreshTaskId"] = self.instanceRefreshTaskId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceRefreshTaskId"] as? String {
            self.instanceRefreshTaskId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ScalingGroupId"] as? String {
            self.scalingGroupId = value
        }
    }
}

public class SuspendInstanceRefreshResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class SuspendInstanceRefreshResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SuspendInstanceRefreshResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = SuspendInstanceRefreshResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class SuspendProcessesRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerId: Int64?

    public var processes: [String]?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.processes != nil {
            map["Processes"] = self.processes!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Processes"] as? [String] {
            self.processes = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ScalingGroupId"] as? String {
            self.scalingGroupId = value
        }
    }
}

public class SuspendProcessesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class SuspendProcessesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SuspendProcessesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = SuspendProcessesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class TagResourcesRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var propagate: Bool?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.propagate != nil {
                map["Propagate"] = self.propagate!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Propagate"] as? Bool {
                self.propagate = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var ownerId: Int64?

    public var regionId: String?

    public var resourceIds: [String]?

    public var resourceOwnerAccount: String?

    public var resourceType: String?

    public var tags: [TagResourcesRequest.Tags]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceIds != nil {
            map["ResourceIds"] = self.resourceIds!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceIds"] as? [String] {
            self.resourceIds = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
        if let value = dict["Tags"] as? [Any?] {
            var tmp : [TagResourcesRequest.Tags] = []
            for v in value {
                if v != nil {
                    var model = TagResourcesRequest.Tags()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tags = tmp
        }
    }
}

public class TagResourcesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class TagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: TagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = TagResourcesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UntagResourcesRequest : Tea.TeaModel {
    public var all: Bool?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceIds: [String]?

    public var resourceOwnerAccount: String?

    public var resourceType: String?

    public var tagKeys: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.all != nil {
            map["All"] = self.all!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceIds != nil {
            map["ResourceIds"] = self.resourceIds!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tagKeys != nil {
            map["TagKeys"] = self.tagKeys!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["All"] as? Bool {
            self.all = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceIds"] as? [String] {
            self.resourceIds = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
        if let value = dict["TagKeys"] as? [String] {
            self.tagKeys = value
        }
    }
}

public class UntagResourcesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UntagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UntagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UntagResourcesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class VerifyAuthenticationRequest : Tea.TeaModel {
    public var onlyCheck: Bool?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var uid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.onlyCheck != nil {
            map["OnlyCheck"] = self.onlyCheck!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.uid != nil {
            map["Uid"] = self.uid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OnlyCheck"] as? Bool {
            self.onlyCheck = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Uid"] as? Int64 {
            self.uid = value
        }
    }
}

public class VerifyAuthenticationResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class VerifyAuthenticationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: VerifyAuthenticationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = VerifyAuthenticationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class VerifyUserRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class VerifyUserResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class VerifyUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: VerifyUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = VerifyUserResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}
