import Foundation
import Tea
import TeaUtils
import AlibabacloudOpenApi
import AlibabaCloudOpenApiUtil
import AlibabacloudEndpointUtil

public class ApplyEciScalingConfigurationRequest : Tea.TeaModel {
    public var content: String?

    public var format: String?

    public var regionId: String?

    public var scalingConfigurationId: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.format != nil {
            map["Format"] = self.format!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.scalingConfigurationId != nil {
            map["ScalingConfigurationId"] = self.scalingConfigurationId!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Content") && dict["Content"] != nil {
            self.content = dict["Content"] as! String
        }
        if dict.keys.contains("Format") && dict["Format"] != nil {
            self.format = dict["Format"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ScalingConfigurationId") && dict["ScalingConfigurationId"] != nil {
            self.scalingConfigurationId = dict["ScalingConfigurationId"] as! String
        }
        if dict.keys.contains("ScalingGroupId") && dict["ScalingGroupId"] != nil {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
    }
}

public class ApplyEciScalingConfigurationResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var scalingConfigurationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingConfigurationId != nil {
            map["ScalingConfigurationId"] = self.scalingConfigurationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScalingConfigurationId") && dict["ScalingConfigurationId"] != nil {
            self.scalingConfigurationId = dict["ScalingConfigurationId"] as! String
        }
    }
}

public class ApplyEciScalingConfigurationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ApplyEciScalingConfigurationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ApplyEciScalingConfigurationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ApplyScalingGroupRequest : Tea.TeaModel {
    public var content: String?

    public var format: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.format != nil {
            map["Format"] = self.format!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Content") && dict["Content"] != nil {
            self.content = dict["Content"] as! String
        }
        if dict.keys.contains("Format") && dict["Format"] != nil {
            self.format = dict["Format"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ApplyScalingGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScalingGroupId") && dict["ScalingGroupId"] != nil {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
    }
}

public class ApplyScalingGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ApplyScalingGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ApplyScalingGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AttachAlbServerGroupsRequest : Tea.TeaModel {
    public class AlbServerGroups : Tea.TeaModel {
        public var albServerGroupId: String?

        public var port: Int32?

        public var weight: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.albServerGroupId != nil {
                map["AlbServerGroupId"] = self.albServerGroupId!
            }
            if self.port != nil {
                map["Port"] = self.port!
            }
            if self.weight != nil {
                map["Weight"] = self.weight!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AlbServerGroupId") && dict["AlbServerGroupId"] != nil {
                self.albServerGroupId = dict["AlbServerGroupId"] as! String
            }
            if dict.keys.contains("Port") && dict["Port"] != nil {
                self.port = dict["Port"] as! Int32
            }
            if dict.keys.contains("Weight") && dict["Weight"] != nil {
                self.weight = dict["Weight"] as! Int32
            }
        }
    }
    public var albServerGroups: [AttachAlbServerGroupsRequest.AlbServerGroups]?

    public var clientToken: String?

    public var forceAttach: Bool?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.albServerGroups != nil {
            var tmp : [Any] = []
            for k in self.albServerGroups! {
                tmp.append(k.toMap())
            }
            map["AlbServerGroups"] = tmp
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.forceAttach != nil {
            map["ForceAttach"] = self.forceAttach!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlbServerGroups") && dict["AlbServerGroups"] != nil {
            var tmp : [AttachAlbServerGroupsRequest.AlbServerGroups] = []
            for v in dict["AlbServerGroups"] as! [Any] {
                var model = AttachAlbServerGroupsRequest.AlbServerGroups()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.albServerGroups = tmp
        }
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("ForceAttach") && dict["ForceAttach"] != nil {
            self.forceAttach = dict["ForceAttach"] as! Bool
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScalingGroupId") && dict["ScalingGroupId"] != nil {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
    }
}

public class AttachAlbServerGroupsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var scalingActivityId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingActivityId != nil {
            map["ScalingActivityId"] = self.scalingActivityId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScalingActivityId") && dict["ScalingActivityId"] != nil {
            self.scalingActivityId = dict["ScalingActivityId"] as! String
        }
    }
}

public class AttachAlbServerGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AttachAlbServerGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AttachAlbServerGroupsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AttachDBInstancesRequest : Tea.TeaModel {
    public var clientToken: String?

    public var DBInstances: [String]?

    public var forceAttach: Bool?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.DBInstances != nil {
            map["DBInstances"] = self.DBInstances!
        }
        if self.forceAttach != nil {
            map["ForceAttach"] = self.forceAttach!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DBInstances") && dict["DBInstances"] != nil {
            self.DBInstances = dict["DBInstances"] as! [String]
        }
        if dict.keys.contains("ForceAttach") && dict["ForceAttach"] != nil {
            self.forceAttach = dict["ForceAttach"] as! Bool
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScalingGroupId") && dict["ScalingGroupId"] != nil {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
    }
}

public class AttachDBInstancesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AttachDBInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AttachDBInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AttachDBInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AttachInstancesRequest : Tea.TeaModel {
    public var clientToken: String?

    public var entrusted: Bool?

    public var instanceIds: [String]?

    public var lifecycleHook: Bool?

    public var loadBalancerWeights: [Int32]?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.entrusted != nil {
            map["Entrusted"] = self.entrusted!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.lifecycleHook != nil {
            map["LifecycleHook"] = self.lifecycleHook!
        }
        if self.loadBalancerWeights != nil {
            map["LoadBalancerWeights"] = self.loadBalancerWeights!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Entrusted") && dict["Entrusted"] != nil {
            self.entrusted = dict["Entrusted"] as! Bool
        }
        if dict.keys.contains("InstanceIds") && dict["InstanceIds"] != nil {
            self.instanceIds = dict["InstanceIds"] as! [String]
        }
        if dict.keys.contains("LifecycleHook") && dict["LifecycleHook"] != nil {
            self.lifecycleHook = dict["LifecycleHook"] as! Bool
        }
        if dict.keys.contains("LoadBalancerWeights") && dict["LoadBalancerWeights"] != nil {
            self.loadBalancerWeights = dict["LoadBalancerWeights"] as! [Int32]
        }
        if dict.keys.contains("OwnerAccount") && dict["OwnerAccount"] != nil {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ScalingGroupId") && dict["ScalingGroupId"] != nil {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
    }
}

public class AttachInstancesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var scalingActivityId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingActivityId != nil {
            map["ScalingActivityId"] = self.scalingActivityId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScalingActivityId") && dict["ScalingActivityId"] != nil {
            self.scalingActivityId = dict["ScalingActivityId"] as! String
        }
    }
}

public class AttachInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AttachInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AttachInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AttachLoadBalancersRequest : Tea.TeaModel {
    public class LoadBalancerConfigs : Tea.TeaModel {
        public var loadBalancerId: String?

        public var weight: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.loadBalancerId != nil {
                map["LoadBalancerId"] = self.loadBalancerId!
            }
            if self.weight != nil {
                map["Weight"] = self.weight!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LoadBalancerId") && dict["LoadBalancerId"] != nil {
                self.loadBalancerId = dict["LoadBalancerId"] as! String
            }
            if dict.keys.contains("Weight") && dict["Weight"] != nil {
                self.weight = dict["Weight"] as! Int32
            }
        }
    }
    public var async: Bool?

    public var clientToken: String?

    public var forceAttach: Bool?

    public var loadBalancerConfigs: [AttachLoadBalancersRequest.LoadBalancerConfigs]?

    public var loadBalancers: [String]?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.async != nil {
            map["Async"] = self.async!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.forceAttach != nil {
            map["ForceAttach"] = self.forceAttach!
        }
        if self.loadBalancerConfigs != nil {
            var tmp : [Any] = []
            for k in self.loadBalancerConfigs! {
                tmp.append(k.toMap())
            }
            map["LoadBalancerConfigs"] = tmp
        }
        if self.loadBalancers != nil {
            map["LoadBalancers"] = self.loadBalancers!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Async") && dict["Async"] != nil {
            self.async = dict["Async"] as! Bool
        }
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("ForceAttach") && dict["ForceAttach"] != nil {
            self.forceAttach = dict["ForceAttach"] as! Bool
        }
        if dict.keys.contains("LoadBalancerConfigs") && dict["LoadBalancerConfigs"] != nil {
            var tmp : [AttachLoadBalancersRequest.LoadBalancerConfigs] = []
            for v in dict["LoadBalancerConfigs"] as! [Any] {
                var model = AttachLoadBalancersRequest.LoadBalancerConfigs()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.loadBalancerConfigs = tmp
        }
        if dict.keys.contains("LoadBalancers") && dict["LoadBalancers"] != nil {
            self.loadBalancers = dict["LoadBalancers"] as! [String]
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScalingGroupId") && dict["ScalingGroupId"] != nil {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
    }
}

public class AttachLoadBalancersResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var scalingActivityId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingActivityId != nil {
            map["ScalingActivityId"] = self.scalingActivityId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScalingActivityId") && dict["ScalingActivityId"] != nil {
            self.scalingActivityId = dict["ScalingActivityId"] as! String
        }
    }
}

public class AttachLoadBalancersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AttachLoadBalancersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AttachLoadBalancersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AttachServerGroupsRequest : Tea.TeaModel {
    public class ServerGroups : Tea.TeaModel {
        public var port: Int32?

        public var serverGroupId: String?

        public var type: String?

        public var weight: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.port != nil {
                map["Port"] = self.port!
            }
            if self.serverGroupId != nil {
                map["ServerGroupId"] = self.serverGroupId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.weight != nil {
                map["Weight"] = self.weight!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Port") && dict["Port"] != nil {
                self.port = dict["Port"] as! Int32
            }
            if dict.keys.contains("ServerGroupId") && dict["ServerGroupId"] != nil {
                self.serverGroupId = dict["ServerGroupId"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Weight") && dict["Weight"] != nil {
                self.weight = dict["Weight"] as! Int32
            }
        }
    }
    public var clientToken: String?

    public var forceAttach: Bool?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public var serverGroups: [AttachServerGroupsRequest.ServerGroups]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.forceAttach != nil {
            map["ForceAttach"] = self.forceAttach!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        if self.serverGroups != nil {
            var tmp : [Any] = []
            for k in self.serverGroups! {
                tmp.append(k.toMap())
            }
            map["ServerGroups"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("ForceAttach") && dict["ForceAttach"] != nil {
            self.forceAttach = dict["ForceAttach"] as! Bool
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScalingGroupId") && dict["ScalingGroupId"] != nil {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
        if dict.keys.contains("ServerGroups") && dict["ServerGroups"] != nil {
            var tmp : [AttachServerGroupsRequest.ServerGroups] = []
            for v in dict["ServerGroups"] as! [Any] {
                var model = AttachServerGroupsRequest.ServerGroups()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.serverGroups = tmp
        }
    }
}

public class AttachServerGroupsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var scalingActivityId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingActivityId != nil {
            map["ScalingActivityId"] = self.scalingActivityId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScalingActivityId") && dict["ScalingActivityId"] != nil {
            self.scalingActivityId = dict["ScalingActivityId"] as! String
        }
    }
}

public class AttachServerGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AttachServerGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AttachServerGroupsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AttachVServerGroupsRequest : Tea.TeaModel {
    public class VServerGroups : Tea.TeaModel {
        public class VServerGroupAttributes : Tea.TeaModel {
            public var port: Int32?

            public var VServerGroupId: String?

            public var weight: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.VServerGroupId != nil {
                    map["VServerGroupId"] = self.VServerGroupId!
                }
                if self.weight != nil {
                    map["Weight"] = self.weight!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Port") && dict["Port"] != nil {
                    self.port = dict["Port"] as! Int32
                }
                if dict.keys.contains("VServerGroupId") && dict["VServerGroupId"] != nil {
                    self.VServerGroupId = dict["VServerGroupId"] as! String
                }
                if dict.keys.contains("Weight") && dict["Weight"] != nil {
                    self.weight = dict["Weight"] as! Int32
                }
            }
        }
        public var loadBalancerId: String?

        public var VServerGroupAttributes: [AttachVServerGroupsRequest.VServerGroups.VServerGroupAttributes]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.loadBalancerId != nil {
                map["LoadBalancerId"] = self.loadBalancerId!
            }
            if self.VServerGroupAttributes != nil {
                var tmp : [Any] = []
                for k in self.VServerGroupAttributes! {
                    tmp.append(k.toMap())
                }
                map["VServerGroupAttributes"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LoadBalancerId") && dict["LoadBalancerId"] != nil {
                self.loadBalancerId = dict["LoadBalancerId"] as! String
            }
            if dict.keys.contains("VServerGroupAttributes") && dict["VServerGroupAttributes"] != nil {
                var tmp : [AttachVServerGroupsRequest.VServerGroups.VServerGroupAttributes] = []
                for v in dict["VServerGroupAttributes"] as! [Any] {
                    var model = AttachVServerGroupsRequest.VServerGroups.VServerGroupAttributes()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.VServerGroupAttributes = tmp
            }
        }
    }
    public var clientToken: String?

    public var forceAttach: Bool?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public var VServerGroups: [AttachVServerGroupsRequest.VServerGroups]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.forceAttach != nil {
            map["ForceAttach"] = self.forceAttach!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        if self.VServerGroups != nil {
            var tmp : [Any] = []
            for k in self.VServerGroups! {
                tmp.append(k.toMap())
            }
            map["VServerGroups"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("ForceAttach") && dict["ForceAttach"] != nil {
            self.forceAttach = dict["ForceAttach"] as! Bool
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScalingGroupId") && dict["ScalingGroupId"] != nil {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
        if dict.keys.contains("VServerGroups") && dict["VServerGroups"] != nil {
            var tmp : [AttachVServerGroupsRequest.VServerGroups] = []
            for v in dict["VServerGroups"] as! [Any] {
                var model = AttachVServerGroupsRequest.VServerGroups()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.VServerGroups = tmp
        }
    }
}

public class AttachVServerGroupsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AttachVServerGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AttachVServerGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AttachVServerGroupsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ChangeResourceGroupRequest : Tea.TeaModel {
    public var newResourceGroupId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceId: String?

    public var resourceOwnerAccount: String?

    public var resourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.newResourceGroupId != nil {
            map["NewResourceGroupId"] = self.newResourceGroupId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NewResourceGroupId") && dict["NewResourceGroupId"] != nil {
            self.newResourceGroupId = dict["NewResourceGroupId"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceId") && dict["ResourceId"] != nil {
            self.resourceId = dict["ResourceId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceType") && dict["ResourceType"] != nil {
            self.resourceType = dict["ResourceType"] as! String
        }
    }
}

public class ChangeResourceGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ChangeResourceGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ChangeResourceGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ChangeResourceGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CompleteLifecycleActionRequest : Tea.TeaModel {
    public var clientToken: String?

    public var lifecycleActionResult: String?

    public var lifecycleActionToken: String?

    public var lifecycleHookId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.lifecycleActionResult != nil {
            map["LifecycleActionResult"] = self.lifecycleActionResult!
        }
        if self.lifecycleActionToken != nil {
            map["LifecycleActionToken"] = self.lifecycleActionToken!
        }
        if self.lifecycleHookId != nil {
            map["LifecycleHookId"] = self.lifecycleHookId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("LifecycleActionResult") && dict["LifecycleActionResult"] != nil {
            self.lifecycleActionResult = dict["LifecycleActionResult"] as! String
        }
        if dict.keys.contains("LifecycleActionToken") && dict["LifecycleActionToken"] != nil {
            self.lifecycleActionToken = dict["LifecycleActionToken"] as! String
        }
        if dict.keys.contains("LifecycleHookId") && dict["LifecycleHookId"] != nil {
            self.lifecycleHookId = dict["LifecycleHookId"] as! String
        }
        if dict.keys.contains("OwnerAccount") && dict["OwnerAccount"] != nil {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
    }
}

public class CompleteLifecycleActionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CompleteLifecycleActionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CompleteLifecycleActionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CompleteLifecycleActionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateAlarmRequest : Tea.TeaModel {
    public class Dimensions : Tea.TeaModel {
        public var dimensionKey: String?

        public var dimensionValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dimensionKey != nil {
                map["DimensionKey"] = self.dimensionKey!
            }
            if self.dimensionValue != nil {
                map["DimensionValue"] = self.dimensionValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DimensionKey") && dict["DimensionKey"] != nil {
                self.dimensionKey = dict["DimensionKey"] as! String
            }
            if dict.keys.contains("DimensionValue") && dict["DimensionValue"] != nil {
                self.dimensionValue = dict["DimensionValue"] as! String
            }
        }
    }
    public class Expressions : Tea.TeaModel {
        public var comparisonOperator: String?

        public var metricName: String?

        public var period: Int32?

        public var statistics: String?

        public var threshold: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.comparisonOperator != nil {
                map["ComparisonOperator"] = self.comparisonOperator!
            }
            if self.metricName != nil {
                map["MetricName"] = self.metricName!
            }
            if self.period != nil {
                map["Period"] = self.period!
            }
            if self.statistics != nil {
                map["Statistics"] = self.statistics!
            }
            if self.threshold != nil {
                map["Threshold"] = self.threshold!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ComparisonOperator") && dict["ComparisonOperator"] != nil {
                self.comparisonOperator = dict["ComparisonOperator"] as! String
            }
            if dict.keys.contains("MetricName") && dict["MetricName"] != nil {
                self.metricName = dict["MetricName"] as! String
            }
            if dict.keys.contains("Period") && dict["Period"] != nil {
                self.period = dict["Period"] as! Int32
            }
            if dict.keys.contains("Statistics") && dict["Statistics"] != nil {
                self.statistics = dict["Statistics"] as! String
            }
            if dict.keys.contains("Threshold") && dict["Threshold"] != nil {
                self.threshold = dict["Threshold"] as! Double
            }
        }
    }
    public var alarmActions: [String]?

    public var comparisonOperator: String?

    public var description_: String?

    public var dimensions: [CreateAlarmRequest.Dimensions]?

    public var effective: String?

    public var evaluationCount: Int32?

    public var expressions: [CreateAlarmRequest.Expressions]?

    public var expressionsLogicOperator: String?

    public var groupId: Int32?

    public var metricName: String?

    public var metricType: String?

    public var name: String?

    public var ownerId: Int64?

    public var period: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public var statistics: String?

    public var threshold: Double?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alarmActions != nil {
            map["AlarmActions"] = self.alarmActions!
        }
        if self.comparisonOperator != nil {
            map["ComparisonOperator"] = self.comparisonOperator!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.dimensions != nil {
            var tmp : [Any] = []
            for k in self.dimensions! {
                tmp.append(k.toMap())
            }
            map["Dimensions"] = tmp
        }
        if self.effective != nil {
            map["Effective"] = self.effective!
        }
        if self.evaluationCount != nil {
            map["EvaluationCount"] = self.evaluationCount!
        }
        if self.expressions != nil {
            var tmp : [Any] = []
            for k in self.expressions! {
                tmp.append(k.toMap())
            }
            map["Expressions"] = tmp
        }
        if self.expressionsLogicOperator != nil {
            map["ExpressionsLogicOperator"] = self.expressionsLogicOperator!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.metricName != nil {
            map["MetricName"] = self.metricName!
        }
        if self.metricType != nil {
            map["MetricType"] = self.metricType!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        if self.statistics != nil {
            map["Statistics"] = self.statistics!
        }
        if self.threshold != nil {
            map["Threshold"] = self.threshold!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlarmActions") && dict["AlarmActions"] != nil {
            self.alarmActions = dict["AlarmActions"] as! [String]
        }
        if dict.keys.contains("ComparisonOperator") && dict["ComparisonOperator"] != nil {
            self.comparisonOperator = dict["ComparisonOperator"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Dimensions") && dict["Dimensions"] != nil {
            var tmp : [CreateAlarmRequest.Dimensions] = []
            for v in dict["Dimensions"] as! [Any] {
                var model = CreateAlarmRequest.Dimensions()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.dimensions = tmp
        }
        if dict.keys.contains("Effective") && dict["Effective"] != nil {
            self.effective = dict["Effective"] as! String
        }
        if dict.keys.contains("EvaluationCount") && dict["EvaluationCount"] != nil {
            self.evaluationCount = dict["EvaluationCount"] as! Int32
        }
        if dict.keys.contains("Expressions") && dict["Expressions"] != nil {
            var tmp : [CreateAlarmRequest.Expressions] = []
            for v in dict["Expressions"] as! [Any] {
                var model = CreateAlarmRequest.Expressions()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.expressions = tmp
        }
        if dict.keys.contains("ExpressionsLogicOperator") && dict["ExpressionsLogicOperator"] != nil {
            self.expressionsLogicOperator = dict["ExpressionsLogicOperator"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! Int32
        }
        if dict.keys.contains("MetricName") && dict["MetricName"] != nil {
            self.metricName = dict["MetricName"] as! String
        }
        if dict.keys.contains("MetricType") && dict["MetricType"] != nil {
            self.metricType = dict["MetricType"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Period") && dict["Period"] != nil {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScalingGroupId") && dict["ScalingGroupId"] != nil {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
        if dict.keys.contains("Statistics") && dict["Statistics"] != nil {
            self.statistics = dict["Statistics"] as! String
        }
        if dict.keys.contains("Threshold") && dict["Threshold"] != nil {
            self.threshold = dict["Threshold"] as! Double
        }
    }
}

public class CreateAlarmResponseBody : Tea.TeaModel {
    public var alarmTaskId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alarmTaskId != nil {
            map["AlarmTaskId"] = self.alarmTaskId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlarmTaskId") && dict["AlarmTaskId"] != nil {
            self.alarmTaskId = dict["AlarmTaskId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateAlarmResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateAlarmResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateAlarmResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateEciScalingConfigurationRequest : Tea.TeaModel {
    public class AcrRegistryInfos : Tea.TeaModel {
        public var domains: [String]?

        public var instanceId: String?

        public var instanceName: String?

        public var regionId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.domains != nil {
                map["Domains"] = self.domains!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Domains") && dict["Domains"] != nil {
                self.domains = dict["Domains"] as! [String]
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
                self.instanceName = dict["InstanceName"] as! String
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
        }
    }
    public class Containers : Tea.TeaModel {
        public class LivenessProbe : Tea.TeaModel {
            public class Exec : Tea.TeaModel {
                public var commands: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.commands != nil {
                        map["Commands"] = self.commands!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Commands") && dict["Commands"] != nil {
                        self.commands = dict["Commands"] as! [String]
                    }
                }
            }
            public class HttpGet : Tea.TeaModel {
                public var path: String?

                public var port: Int32?

                public var scheme: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.path != nil {
                        map["Path"] = self.path!
                    }
                    if self.port != nil {
                        map["Port"] = self.port!
                    }
                    if self.scheme != nil {
                        map["Scheme"] = self.scheme!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Path") && dict["Path"] != nil {
                        self.path = dict["Path"] as! String
                    }
                    if dict.keys.contains("Port") && dict["Port"] != nil {
                        self.port = dict["Port"] as! Int32
                    }
                    if dict.keys.contains("Scheme") && dict["Scheme"] != nil {
                        self.scheme = dict["Scheme"] as! String
                    }
                }
            }
            public class TcpSocket : Tea.TeaModel {
                public var port: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.port != nil {
                        map["Port"] = self.port!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Port") && dict["Port"] != nil {
                        self.port = dict["Port"] as! Int32
                    }
                }
            }
            public var exec: CreateEciScalingConfigurationRequest.Containers.LivenessProbe.Exec?

            public var failureThreshold: Int32?

            public var httpGet: CreateEciScalingConfigurationRequest.Containers.LivenessProbe.HttpGet?

            public var initialDelaySeconds: Int32?

            public var periodSeconds: Int32?

            public var successThreshold: Int32?

            public var tcpSocket: CreateEciScalingConfigurationRequest.Containers.LivenessProbe.TcpSocket?

            public var timeoutSeconds: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.exec?.validate()
                try self.httpGet?.validate()
                try self.tcpSocket?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.exec != nil {
                    map["Exec"] = self.exec?.toMap()
                }
                if self.failureThreshold != nil {
                    map["FailureThreshold"] = self.failureThreshold!
                }
                if self.httpGet != nil {
                    map["HttpGet"] = self.httpGet?.toMap()
                }
                if self.initialDelaySeconds != nil {
                    map["InitialDelaySeconds"] = self.initialDelaySeconds!
                }
                if self.periodSeconds != nil {
                    map["PeriodSeconds"] = self.periodSeconds!
                }
                if self.successThreshold != nil {
                    map["SuccessThreshold"] = self.successThreshold!
                }
                if self.tcpSocket != nil {
                    map["TcpSocket"] = self.tcpSocket?.toMap()
                }
                if self.timeoutSeconds != nil {
                    map["TimeoutSeconds"] = self.timeoutSeconds!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Exec") && dict["Exec"] != nil {
                    var model = CreateEciScalingConfigurationRequest.Containers.LivenessProbe.Exec()
                    model.fromMap(dict["Exec"] as! [String: Any])
                    self.exec = model
                }
                if dict.keys.contains("FailureThreshold") && dict["FailureThreshold"] != nil {
                    self.failureThreshold = dict["FailureThreshold"] as! Int32
                }
                if dict.keys.contains("HttpGet") && dict["HttpGet"] != nil {
                    var model = CreateEciScalingConfigurationRequest.Containers.LivenessProbe.HttpGet()
                    model.fromMap(dict["HttpGet"] as! [String: Any])
                    self.httpGet = model
                }
                if dict.keys.contains("InitialDelaySeconds") && dict["InitialDelaySeconds"] != nil {
                    self.initialDelaySeconds = dict["InitialDelaySeconds"] as! Int32
                }
                if dict.keys.contains("PeriodSeconds") && dict["PeriodSeconds"] != nil {
                    self.periodSeconds = dict["PeriodSeconds"] as! Int32
                }
                if dict.keys.contains("SuccessThreshold") && dict["SuccessThreshold"] != nil {
                    self.successThreshold = dict["SuccessThreshold"] as! Int32
                }
                if dict.keys.contains("TcpSocket") && dict["TcpSocket"] != nil {
                    var model = CreateEciScalingConfigurationRequest.Containers.LivenessProbe.TcpSocket()
                    model.fromMap(dict["TcpSocket"] as! [String: Any])
                    self.tcpSocket = model
                }
                if dict.keys.contains("TimeoutSeconds") && dict["TimeoutSeconds"] != nil {
                    self.timeoutSeconds = dict["TimeoutSeconds"] as! Int32
                }
            }
        }
        public class ReadinessProbe : Tea.TeaModel {
            public class Exec : Tea.TeaModel {
                public var commands: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.commands != nil {
                        map["Commands"] = self.commands!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Commands") && dict["Commands"] != nil {
                        self.commands = dict["Commands"] as! [String]
                    }
                }
            }
            public class HttpGet : Tea.TeaModel {
                public var path: String?

                public var port: Int32?

                public var scheme: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.path != nil {
                        map["Path"] = self.path!
                    }
                    if self.port != nil {
                        map["Port"] = self.port!
                    }
                    if self.scheme != nil {
                        map["Scheme"] = self.scheme!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Path") && dict["Path"] != nil {
                        self.path = dict["Path"] as! String
                    }
                    if dict.keys.contains("Port") && dict["Port"] != nil {
                        self.port = dict["Port"] as! Int32
                    }
                    if dict.keys.contains("Scheme") && dict["Scheme"] != nil {
                        self.scheme = dict["Scheme"] as! String
                    }
                }
            }
            public class TcpSocket : Tea.TeaModel {
                public var port: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.port != nil {
                        map["Port"] = self.port!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Port") && dict["Port"] != nil {
                        self.port = dict["Port"] as! Int32
                    }
                }
            }
            public var exec: CreateEciScalingConfigurationRequest.Containers.ReadinessProbe.Exec?

            public var failureThreshold: Int32?

            public var httpGet: CreateEciScalingConfigurationRequest.Containers.ReadinessProbe.HttpGet?

            public var initialDelaySeconds: Int32?

            public var periodSeconds: Int32?

            public var successThreshold: Int32?

            public var tcpSocket: CreateEciScalingConfigurationRequest.Containers.ReadinessProbe.TcpSocket?

            public var timeoutSeconds: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.exec?.validate()
                try self.httpGet?.validate()
                try self.tcpSocket?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.exec != nil {
                    map["Exec"] = self.exec?.toMap()
                }
                if self.failureThreshold != nil {
                    map["FailureThreshold"] = self.failureThreshold!
                }
                if self.httpGet != nil {
                    map["HttpGet"] = self.httpGet?.toMap()
                }
                if self.initialDelaySeconds != nil {
                    map["InitialDelaySeconds"] = self.initialDelaySeconds!
                }
                if self.periodSeconds != nil {
                    map["PeriodSeconds"] = self.periodSeconds!
                }
                if self.successThreshold != nil {
                    map["SuccessThreshold"] = self.successThreshold!
                }
                if self.tcpSocket != nil {
                    map["TcpSocket"] = self.tcpSocket?.toMap()
                }
                if self.timeoutSeconds != nil {
                    map["TimeoutSeconds"] = self.timeoutSeconds!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Exec") && dict["Exec"] != nil {
                    var model = CreateEciScalingConfigurationRequest.Containers.ReadinessProbe.Exec()
                    model.fromMap(dict["Exec"] as! [String: Any])
                    self.exec = model
                }
                if dict.keys.contains("FailureThreshold") && dict["FailureThreshold"] != nil {
                    self.failureThreshold = dict["FailureThreshold"] as! Int32
                }
                if dict.keys.contains("HttpGet") && dict["HttpGet"] != nil {
                    var model = CreateEciScalingConfigurationRequest.Containers.ReadinessProbe.HttpGet()
                    model.fromMap(dict["HttpGet"] as! [String: Any])
                    self.httpGet = model
                }
                if dict.keys.contains("InitialDelaySeconds") && dict["InitialDelaySeconds"] != nil {
                    self.initialDelaySeconds = dict["InitialDelaySeconds"] as! Int32
                }
                if dict.keys.contains("PeriodSeconds") && dict["PeriodSeconds"] != nil {
                    self.periodSeconds = dict["PeriodSeconds"] as! Int32
                }
                if dict.keys.contains("SuccessThreshold") && dict["SuccessThreshold"] != nil {
                    self.successThreshold = dict["SuccessThreshold"] as! Int32
                }
                if dict.keys.contains("TcpSocket") && dict["TcpSocket"] != nil {
                    var model = CreateEciScalingConfigurationRequest.Containers.ReadinessProbe.TcpSocket()
                    model.fromMap(dict["TcpSocket"] as! [String: Any])
                    self.tcpSocket = model
                }
                if dict.keys.contains("TimeoutSeconds") && dict["TimeoutSeconds"] != nil {
                    self.timeoutSeconds = dict["TimeoutSeconds"] as! Int32
                }
            }
        }
        public class SecurityContext : Tea.TeaModel {
            public class Capability : Tea.TeaModel {
                public var add: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.add != nil {
                        map["Add"] = self.add!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Add") && dict["Add"] != nil {
                        self.add = dict["Add"] as! [String]
                    }
                }
            }
            public var capability: CreateEciScalingConfigurationRequest.Containers.SecurityContext.Capability?

            public var readOnlyRootFilesystem: Bool?

            public var runAsUser: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.capability?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.capability != nil {
                    map["Capability"] = self.capability?.toMap()
                }
                if self.readOnlyRootFilesystem != nil {
                    map["ReadOnlyRootFilesystem"] = self.readOnlyRootFilesystem!
                }
                if self.runAsUser != nil {
                    map["RunAsUser"] = self.runAsUser!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Capability") && dict["Capability"] != nil {
                    var model = CreateEciScalingConfigurationRequest.Containers.SecurityContext.Capability()
                    model.fromMap(dict["Capability"] as! [String: Any])
                    self.capability = model
                }
                if dict.keys.contains("ReadOnlyRootFilesystem") && dict["ReadOnlyRootFilesystem"] != nil {
                    self.readOnlyRootFilesystem = dict["ReadOnlyRootFilesystem"] as! Bool
                }
                if dict.keys.contains("RunAsUser") && dict["RunAsUser"] != nil {
                    self.runAsUser = dict["RunAsUser"] as! Int64
                }
            }
        }
        public class EnvironmentVars : Tea.TeaModel {
            public var fieldRefFieldPath: String?

            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fieldRefFieldPath != nil {
                    map["FieldRefFieldPath"] = self.fieldRefFieldPath!
                }
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FieldRefFieldPath") && dict["FieldRefFieldPath"] != nil {
                    self.fieldRefFieldPath = dict["FieldRefFieldPath"] as! String
                }
                if dict.keys.contains("Key") && dict["Key"] != nil {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public class Ports : Tea.TeaModel {
            public var port: Int32?

            public var protocol_: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.protocol_ != nil {
                    map["Protocol"] = self.protocol_!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Port") && dict["Port"] != nil {
                    self.port = dict["Port"] as! Int32
                }
                if dict.keys.contains("Protocol") && dict["Protocol"] != nil {
                    self.protocol_ = dict["Protocol"] as! String
                }
            }
        }
        public class VolumeMounts : Tea.TeaModel {
            public var mountPath: String?

            public var mountPropagation: String?

            public var name: String?

            public var readOnly: Bool?

            public var subPath: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.mountPath != nil {
                    map["MountPath"] = self.mountPath!
                }
                if self.mountPropagation != nil {
                    map["MountPropagation"] = self.mountPropagation!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.readOnly != nil {
                    map["ReadOnly"] = self.readOnly!
                }
                if self.subPath != nil {
                    map["SubPath"] = self.subPath!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("MountPath") && dict["MountPath"] != nil {
                    self.mountPath = dict["MountPath"] as! String
                }
                if dict.keys.contains("MountPropagation") && dict["MountPropagation"] != nil {
                    self.mountPropagation = dict["MountPropagation"] as! String
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("ReadOnly") && dict["ReadOnly"] != nil {
                    self.readOnly = dict["ReadOnly"] as! Bool
                }
                if dict.keys.contains("SubPath") && dict["SubPath"] != nil {
                    self.subPath = dict["SubPath"] as! String
                }
            }
        }
        public var livenessProbe: CreateEciScalingConfigurationRequest.Containers.LivenessProbe?

        public var readinessProbe: CreateEciScalingConfigurationRequest.Containers.ReadinessProbe?

        public var securityContext: CreateEciScalingConfigurationRequest.Containers.SecurityContext?

        public var args: [String]?

        public var commands: [String]?

        public var cpu: Double?

        public var environmentVars: [CreateEciScalingConfigurationRequest.Containers.EnvironmentVars]?

        public var gpu: Int32?

        public var image: String?

        public var imagePullPolicy: String?

        public var lifecyclePostStartHandlerExecs: [String]?

        public var lifecyclePostStartHandlerHttpGetHost: String?

        public var lifecyclePostStartHandlerHttpGetPath: String?

        public var lifecyclePostStartHandlerHttpGetPort: Int32?

        public var lifecyclePostStartHandlerHttpGetScheme: String?

        public var lifecyclePostStartHandlerTcpSocketHost: String?

        public var lifecyclePostStartHandlerTcpSocketPort: Int32?

        public var lifecyclePreStopHandlerExecs: [String]?

        public var lifecyclePreStopHandlerHttpGetHost: String?

        public var lifecyclePreStopHandlerHttpGetPath: String?

        public var lifecyclePreStopHandlerHttpGetPort: Int32?

        public var lifecyclePreStopHandlerHttpGetScheme: String?

        public var lifecyclePreStopHandlerTcpSocketHost: String?

        public var lifecyclePreStopHandlerTcpSocketPort: Int32?

        public var memory: Double?

        public var name: String?

        public var ports: [CreateEciScalingConfigurationRequest.Containers.Ports]?

        public var stdin: Bool?

        public var stdinOnce: Bool?

        public var tty: Bool?

        public var volumeMounts: [CreateEciScalingConfigurationRequest.Containers.VolumeMounts]?

        public var workingDir: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.livenessProbe?.validate()
            try self.readinessProbe?.validate()
            try self.securityContext?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.livenessProbe != nil {
                map["LivenessProbe"] = self.livenessProbe?.toMap()
            }
            if self.readinessProbe != nil {
                map["ReadinessProbe"] = self.readinessProbe?.toMap()
            }
            if self.securityContext != nil {
                map["SecurityContext"] = self.securityContext?.toMap()
            }
            if self.args != nil {
                map["Args"] = self.args!
            }
            if self.commands != nil {
                map["Commands"] = self.commands!
            }
            if self.cpu != nil {
                map["Cpu"] = self.cpu!
            }
            if self.environmentVars != nil {
                var tmp : [Any] = []
                for k in self.environmentVars! {
                    tmp.append(k.toMap())
                }
                map["EnvironmentVars"] = tmp
            }
            if self.gpu != nil {
                map["Gpu"] = self.gpu!
            }
            if self.image != nil {
                map["Image"] = self.image!
            }
            if self.imagePullPolicy != nil {
                map["ImagePullPolicy"] = self.imagePullPolicy!
            }
            if self.lifecyclePostStartHandlerExecs != nil {
                map["LifecyclePostStartHandlerExecs"] = self.lifecyclePostStartHandlerExecs!
            }
            if self.lifecyclePostStartHandlerHttpGetHost != nil {
                map["LifecyclePostStartHandlerHttpGetHost"] = self.lifecyclePostStartHandlerHttpGetHost!
            }
            if self.lifecyclePostStartHandlerHttpGetPath != nil {
                map["LifecyclePostStartHandlerHttpGetPath"] = self.lifecyclePostStartHandlerHttpGetPath!
            }
            if self.lifecyclePostStartHandlerHttpGetPort != nil {
                map["LifecyclePostStartHandlerHttpGetPort"] = self.lifecyclePostStartHandlerHttpGetPort!
            }
            if self.lifecyclePostStartHandlerHttpGetScheme != nil {
                map["LifecyclePostStartHandlerHttpGetScheme"] = self.lifecyclePostStartHandlerHttpGetScheme!
            }
            if self.lifecyclePostStartHandlerTcpSocketHost != nil {
                map["LifecyclePostStartHandlerTcpSocketHost"] = self.lifecyclePostStartHandlerTcpSocketHost!
            }
            if self.lifecyclePostStartHandlerTcpSocketPort != nil {
                map["LifecyclePostStartHandlerTcpSocketPort"] = self.lifecyclePostStartHandlerTcpSocketPort!
            }
            if self.lifecyclePreStopHandlerExecs != nil {
                map["LifecyclePreStopHandlerExecs"] = self.lifecyclePreStopHandlerExecs!
            }
            if self.lifecyclePreStopHandlerHttpGetHost != nil {
                map["LifecyclePreStopHandlerHttpGetHost"] = self.lifecyclePreStopHandlerHttpGetHost!
            }
            if self.lifecyclePreStopHandlerHttpGetPath != nil {
                map["LifecyclePreStopHandlerHttpGetPath"] = self.lifecyclePreStopHandlerHttpGetPath!
            }
            if self.lifecyclePreStopHandlerHttpGetPort != nil {
                map["LifecyclePreStopHandlerHttpGetPort"] = self.lifecyclePreStopHandlerHttpGetPort!
            }
            if self.lifecyclePreStopHandlerHttpGetScheme != nil {
                map["LifecyclePreStopHandlerHttpGetScheme"] = self.lifecyclePreStopHandlerHttpGetScheme!
            }
            if self.lifecyclePreStopHandlerTcpSocketHost != nil {
                map["LifecyclePreStopHandlerTcpSocketHost"] = self.lifecyclePreStopHandlerTcpSocketHost!
            }
            if self.lifecyclePreStopHandlerTcpSocketPort != nil {
                map["LifecyclePreStopHandlerTcpSocketPort"] = self.lifecyclePreStopHandlerTcpSocketPort!
            }
            if self.memory != nil {
                map["Memory"] = self.memory!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.ports != nil {
                var tmp : [Any] = []
                for k in self.ports! {
                    tmp.append(k.toMap())
                }
                map["Ports"] = tmp
            }
            if self.stdin != nil {
                map["Stdin"] = self.stdin!
            }
            if self.stdinOnce != nil {
                map["StdinOnce"] = self.stdinOnce!
            }
            if self.tty != nil {
                map["Tty"] = self.tty!
            }
            if self.volumeMounts != nil {
                var tmp : [Any] = []
                for k in self.volumeMounts! {
                    tmp.append(k.toMap())
                }
                map["VolumeMounts"] = tmp
            }
            if self.workingDir != nil {
                map["WorkingDir"] = self.workingDir!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LivenessProbe") && dict["LivenessProbe"] != nil {
                var model = CreateEciScalingConfigurationRequest.Containers.LivenessProbe()
                model.fromMap(dict["LivenessProbe"] as! [String: Any])
                self.livenessProbe = model
            }
            if dict.keys.contains("ReadinessProbe") && dict["ReadinessProbe"] != nil {
                var model = CreateEciScalingConfigurationRequest.Containers.ReadinessProbe()
                model.fromMap(dict["ReadinessProbe"] as! [String: Any])
                self.readinessProbe = model
            }
            if dict.keys.contains("SecurityContext") && dict["SecurityContext"] != nil {
                var model = CreateEciScalingConfigurationRequest.Containers.SecurityContext()
                model.fromMap(dict["SecurityContext"] as! [String: Any])
                self.securityContext = model
            }
            if dict.keys.contains("Args") && dict["Args"] != nil {
                self.args = dict["Args"] as! [String]
            }
            if dict.keys.contains("Commands") && dict["Commands"] != nil {
                self.commands = dict["Commands"] as! [String]
            }
            if dict.keys.contains("Cpu") && dict["Cpu"] != nil {
                self.cpu = dict["Cpu"] as! Double
            }
            if dict.keys.contains("EnvironmentVars") && dict["EnvironmentVars"] != nil {
                var tmp : [CreateEciScalingConfigurationRequest.Containers.EnvironmentVars] = []
                for v in dict["EnvironmentVars"] as! [Any] {
                    var model = CreateEciScalingConfigurationRequest.Containers.EnvironmentVars()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.environmentVars = tmp
            }
            if dict.keys.contains("Gpu") && dict["Gpu"] != nil {
                self.gpu = dict["Gpu"] as! Int32
            }
            if dict.keys.contains("Image") && dict["Image"] != nil {
                self.image = dict["Image"] as! String
            }
            if dict.keys.contains("ImagePullPolicy") && dict["ImagePullPolicy"] != nil {
                self.imagePullPolicy = dict["ImagePullPolicy"] as! String
            }
            if dict.keys.contains("LifecyclePostStartHandlerExecs") && dict["LifecyclePostStartHandlerExecs"] != nil {
                self.lifecyclePostStartHandlerExecs = dict["LifecyclePostStartHandlerExecs"] as! [String]
            }
            if dict.keys.contains("LifecyclePostStartHandlerHttpGetHost") && dict["LifecyclePostStartHandlerHttpGetHost"] != nil {
                self.lifecyclePostStartHandlerHttpGetHost = dict["LifecyclePostStartHandlerHttpGetHost"] as! String
            }
            if dict.keys.contains("LifecyclePostStartHandlerHttpGetPath") && dict["LifecyclePostStartHandlerHttpGetPath"] != nil {
                self.lifecyclePostStartHandlerHttpGetPath = dict["LifecyclePostStartHandlerHttpGetPath"] as! String
            }
            if dict.keys.contains("LifecyclePostStartHandlerHttpGetPort") && dict["LifecyclePostStartHandlerHttpGetPort"] != nil {
                self.lifecyclePostStartHandlerHttpGetPort = dict["LifecyclePostStartHandlerHttpGetPort"] as! Int32
            }
            if dict.keys.contains("LifecyclePostStartHandlerHttpGetScheme") && dict["LifecyclePostStartHandlerHttpGetScheme"] != nil {
                self.lifecyclePostStartHandlerHttpGetScheme = dict["LifecyclePostStartHandlerHttpGetScheme"] as! String
            }
            if dict.keys.contains("LifecyclePostStartHandlerTcpSocketHost") && dict["LifecyclePostStartHandlerTcpSocketHost"] != nil {
                self.lifecyclePostStartHandlerTcpSocketHost = dict["LifecyclePostStartHandlerTcpSocketHost"] as! String
            }
            if dict.keys.contains("LifecyclePostStartHandlerTcpSocketPort") && dict["LifecyclePostStartHandlerTcpSocketPort"] != nil {
                self.lifecyclePostStartHandlerTcpSocketPort = dict["LifecyclePostStartHandlerTcpSocketPort"] as! Int32
            }
            if dict.keys.contains("LifecyclePreStopHandlerExecs") && dict["LifecyclePreStopHandlerExecs"] != nil {
                self.lifecyclePreStopHandlerExecs = dict["LifecyclePreStopHandlerExecs"] as! [String]
            }
            if dict.keys.contains("LifecyclePreStopHandlerHttpGetHost") && dict["LifecyclePreStopHandlerHttpGetHost"] != nil {
                self.lifecyclePreStopHandlerHttpGetHost = dict["LifecyclePreStopHandlerHttpGetHost"] as! String
            }
            if dict.keys.contains("LifecyclePreStopHandlerHttpGetPath") && dict["LifecyclePreStopHandlerHttpGetPath"] != nil {
                self.lifecyclePreStopHandlerHttpGetPath = dict["LifecyclePreStopHandlerHttpGetPath"] as! String
            }
            if dict.keys.contains("LifecyclePreStopHandlerHttpGetPort") && dict["LifecyclePreStopHandlerHttpGetPort"] != nil {
                self.lifecyclePreStopHandlerHttpGetPort = dict["LifecyclePreStopHandlerHttpGetPort"] as! Int32
            }
            if dict.keys.contains("LifecyclePreStopHandlerHttpGetScheme") && dict["LifecyclePreStopHandlerHttpGetScheme"] != nil {
                self.lifecyclePreStopHandlerHttpGetScheme = dict["LifecyclePreStopHandlerHttpGetScheme"] as! String
            }
            if dict.keys.contains("LifecyclePreStopHandlerTcpSocketHost") && dict["LifecyclePreStopHandlerTcpSocketHost"] != nil {
                self.lifecyclePreStopHandlerTcpSocketHost = dict["LifecyclePreStopHandlerTcpSocketHost"] as! String
            }
            if dict.keys.contains("LifecyclePreStopHandlerTcpSocketPort") && dict["LifecyclePreStopHandlerTcpSocketPort"] != nil {
                self.lifecyclePreStopHandlerTcpSocketPort = dict["LifecyclePreStopHandlerTcpSocketPort"] as! Int32
            }
            if dict.keys.contains("Memory") && dict["Memory"] != nil {
                self.memory = dict["Memory"] as! Double
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Ports") && dict["Ports"] != nil {
                var tmp : [CreateEciScalingConfigurationRequest.Containers.Ports] = []
                for v in dict["Ports"] as! [Any] {
                    var model = CreateEciScalingConfigurationRequest.Containers.Ports()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ports = tmp
            }
            if dict.keys.contains("Stdin") && dict["Stdin"] != nil {
                self.stdin = dict["Stdin"] as! Bool
            }
            if dict.keys.contains("StdinOnce") && dict["StdinOnce"] != nil {
                self.stdinOnce = dict["StdinOnce"] as! Bool
            }
            if dict.keys.contains("Tty") && dict["Tty"] != nil {
                self.tty = dict["Tty"] as! Bool
            }
            if dict.keys.contains("VolumeMounts") && dict["VolumeMounts"] != nil {
                var tmp : [CreateEciScalingConfigurationRequest.Containers.VolumeMounts] = []
                for v in dict["VolumeMounts"] as! [Any] {
                    var model = CreateEciScalingConfigurationRequest.Containers.VolumeMounts()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.volumeMounts = tmp
            }
            if dict.keys.contains("WorkingDir") && dict["WorkingDir"] != nil {
                self.workingDir = dict["WorkingDir"] as! String
            }
        }
    }
    public class DnsConfigOptions : Tea.TeaModel {
        public var name: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public class HostAliases : Tea.TeaModel {
        public var hostnames: [String]?

        public var ip: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.hostnames != nil {
                map["Hostnames"] = self.hostnames!
            }
            if self.ip != nil {
                map["Ip"] = self.ip!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Hostnames") && dict["Hostnames"] != nil {
                self.hostnames = dict["Hostnames"] as! [String]
            }
            if dict.keys.contains("Ip") && dict["Ip"] != nil {
                self.ip = dict["Ip"] as! String
            }
        }
    }
    public class ImageRegistryCredentials : Tea.TeaModel {
        public var password: String?

        public var server: String?

        public var userName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.password != nil {
                map["Password"] = self.password!
            }
            if self.server != nil {
                map["Server"] = self.server!
            }
            if self.userName != nil {
                map["UserName"] = self.userName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Password") && dict["Password"] != nil {
                self.password = dict["Password"] as! String
            }
            if dict.keys.contains("Server") && dict["Server"] != nil {
                self.server = dict["Server"] as! String
            }
            if dict.keys.contains("UserName") && dict["UserName"] != nil {
                self.userName = dict["UserName"] as! String
            }
        }
    }
    public class InitContainers : Tea.TeaModel {
        public class SecurityContext : Tea.TeaModel {
            public class Capability : Tea.TeaModel {
                public var adds: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.adds != nil {
                        map["Adds"] = self.adds!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Adds") && dict["Adds"] != nil {
                        self.adds = dict["Adds"] as! [String]
                    }
                }
            }
            public var capability: CreateEciScalingConfigurationRequest.InitContainers.SecurityContext.Capability?

            public var readOnlyRootFilesystem: Bool?

            public var runAsUser: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.capability?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.capability != nil {
                    map["Capability"] = self.capability?.toMap()
                }
                if self.readOnlyRootFilesystem != nil {
                    map["ReadOnlyRootFilesystem"] = self.readOnlyRootFilesystem!
                }
                if self.runAsUser != nil {
                    map["RunAsUser"] = self.runAsUser!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Capability") && dict["Capability"] != nil {
                    var model = CreateEciScalingConfigurationRequest.InitContainers.SecurityContext.Capability()
                    model.fromMap(dict["Capability"] as! [String: Any])
                    self.capability = model
                }
                if dict.keys.contains("ReadOnlyRootFilesystem") && dict["ReadOnlyRootFilesystem"] != nil {
                    self.readOnlyRootFilesystem = dict["ReadOnlyRootFilesystem"] as! Bool
                }
                if dict.keys.contains("RunAsUser") && dict["RunAsUser"] != nil {
                    self.runAsUser = dict["RunAsUser"] as! Int64
                }
            }
        }
        public class InitContainerEnvironmentVars : Tea.TeaModel {
            public var fieldRefFieldPath: String?

            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fieldRefFieldPath != nil {
                    map["FieldRefFieldPath"] = self.fieldRefFieldPath!
                }
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FieldRefFieldPath") && dict["FieldRefFieldPath"] != nil {
                    self.fieldRefFieldPath = dict["FieldRefFieldPath"] as! String
                }
                if dict.keys.contains("Key") && dict["Key"] != nil {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public class InitContainerPorts : Tea.TeaModel {
            public var port: Int32?

            public var protocol_: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.protocol_ != nil {
                    map["Protocol"] = self.protocol_!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Port") && dict["Port"] != nil {
                    self.port = dict["Port"] as! Int32
                }
                if dict.keys.contains("Protocol") && dict["Protocol"] != nil {
                    self.protocol_ = dict["Protocol"] as! String
                }
            }
        }
        public class InitContainerVolumeMounts : Tea.TeaModel {
            public var mountPath: String?

            public var mountPropagation: String?

            public var name: String?

            public var readOnly: Bool?

            public var subPath: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.mountPath != nil {
                    map["MountPath"] = self.mountPath!
                }
                if self.mountPropagation != nil {
                    map["MountPropagation"] = self.mountPropagation!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.readOnly != nil {
                    map["ReadOnly"] = self.readOnly!
                }
                if self.subPath != nil {
                    map["SubPath"] = self.subPath!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("MountPath") && dict["MountPath"] != nil {
                    self.mountPath = dict["MountPath"] as! String
                }
                if dict.keys.contains("MountPropagation") && dict["MountPropagation"] != nil {
                    self.mountPropagation = dict["MountPropagation"] as! String
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("ReadOnly") && dict["ReadOnly"] != nil {
                    self.readOnly = dict["ReadOnly"] as! Bool
                }
                if dict.keys.contains("SubPath") && dict["SubPath"] != nil {
                    self.subPath = dict["SubPath"] as! String
                }
            }
        }
        public var securityContext: CreateEciScalingConfigurationRequest.InitContainers.SecurityContext?

        public var args: [String]?

        public var commands: [String]?

        public var cpu: Double?

        public var gpu: Int32?

        public var image: String?

        public var imagePullPolicy: String?

        public var initContainerEnvironmentVars: [CreateEciScalingConfigurationRequest.InitContainers.InitContainerEnvironmentVars]?

        public var initContainerPorts: [CreateEciScalingConfigurationRequest.InitContainers.InitContainerPorts]?

        public var initContainerVolumeMounts: [CreateEciScalingConfigurationRequest.InitContainers.InitContainerVolumeMounts]?

        public var memory: Double?

        public var name: String?

        public var workingDir: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.securityContext?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.securityContext != nil {
                map["SecurityContext"] = self.securityContext?.toMap()
            }
            if self.args != nil {
                map["Args"] = self.args!
            }
            if self.commands != nil {
                map["Commands"] = self.commands!
            }
            if self.cpu != nil {
                map["Cpu"] = self.cpu!
            }
            if self.gpu != nil {
                map["Gpu"] = self.gpu!
            }
            if self.image != nil {
                map["Image"] = self.image!
            }
            if self.imagePullPolicy != nil {
                map["ImagePullPolicy"] = self.imagePullPolicy!
            }
            if self.initContainerEnvironmentVars != nil {
                var tmp : [Any] = []
                for k in self.initContainerEnvironmentVars! {
                    tmp.append(k.toMap())
                }
                map["InitContainerEnvironmentVars"] = tmp
            }
            if self.initContainerPorts != nil {
                var tmp : [Any] = []
                for k in self.initContainerPorts! {
                    tmp.append(k.toMap())
                }
                map["InitContainerPorts"] = tmp
            }
            if self.initContainerVolumeMounts != nil {
                var tmp : [Any] = []
                for k in self.initContainerVolumeMounts! {
                    tmp.append(k.toMap())
                }
                map["InitContainerVolumeMounts"] = tmp
            }
            if self.memory != nil {
                map["Memory"] = self.memory!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.workingDir != nil {
                map["WorkingDir"] = self.workingDir!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SecurityContext") && dict["SecurityContext"] != nil {
                var model = CreateEciScalingConfigurationRequest.InitContainers.SecurityContext()
                model.fromMap(dict["SecurityContext"] as! [String: Any])
                self.securityContext = model
            }
            if dict.keys.contains("Args") && dict["Args"] != nil {
                self.args = dict["Args"] as! [String]
            }
            if dict.keys.contains("Commands") && dict["Commands"] != nil {
                self.commands = dict["Commands"] as! [String]
            }
            if dict.keys.contains("Cpu") && dict["Cpu"] != nil {
                self.cpu = dict["Cpu"] as! Double
            }
            if dict.keys.contains("Gpu") && dict["Gpu"] != nil {
                self.gpu = dict["Gpu"] as! Int32
            }
            if dict.keys.contains("Image") && dict["Image"] != nil {
                self.image = dict["Image"] as! String
            }
            if dict.keys.contains("ImagePullPolicy") && dict["ImagePullPolicy"] != nil {
                self.imagePullPolicy = dict["ImagePullPolicy"] as! String
            }
            if dict.keys.contains("InitContainerEnvironmentVars") && dict["InitContainerEnvironmentVars"] != nil {
                var tmp : [CreateEciScalingConfigurationRequest.InitContainers.InitContainerEnvironmentVars] = []
                for v in dict["InitContainerEnvironmentVars"] as! [Any] {
                    var model = CreateEciScalingConfigurationRequest.InitContainers.InitContainerEnvironmentVars()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.initContainerEnvironmentVars = tmp
            }
            if dict.keys.contains("InitContainerPorts") && dict["InitContainerPorts"] != nil {
                var tmp : [CreateEciScalingConfigurationRequest.InitContainers.InitContainerPorts] = []
                for v in dict["InitContainerPorts"] as! [Any] {
                    var model = CreateEciScalingConfigurationRequest.InitContainers.InitContainerPorts()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.initContainerPorts = tmp
            }
            if dict.keys.contains("InitContainerVolumeMounts") && dict["InitContainerVolumeMounts"] != nil {
                var tmp : [CreateEciScalingConfigurationRequest.InitContainers.InitContainerVolumeMounts] = []
                for v in dict["InitContainerVolumeMounts"] as! [Any] {
                    var model = CreateEciScalingConfigurationRequest.InitContainers.InitContainerVolumeMounts()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.initContainerVolumeMounts = tmp
            }
            if dict.keys.contains("Memory") && dict["Memory"] != nil {
                self.memory = dict["Memory"] as! Double
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("WorkingDir") && dict["WorkingDir"] != nil {
                self.workingDir = dict["WorkingDir"] as! String
            }
        }
    }
    public class SecurityContextSysctls : Tea.TeaModel {
        public var name: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public class Volumes : Tea.TeaModel {
        public class DiskVolume : Tea.TeaModel {
            public var diskId: String?

            public var diskSize: Int32?

            public var fsType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.diskId != nil {
                    map["DiskId"] = self.diskId!
                }
                if self.diskSize != nil {
                    map["DiskSize"] = self.diskSize!
                }
                if self.fsType != nil {
                    map["FsType"] = self.fsType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DiskId") && dict["DiskId"] != nil {
                    self.diskId = dict["DiskId"] as! String
                }
                if dict.keys.contains("DiskSize") && dict["DiskSize"] != nil {
                    self.diskSize = dict["DiskSize"] as! Int32
                }
                if dict.keys.contains("FsType") && dict["FsType"] != nil {
                    self.fsType = dict["FsType"] as! String
                }
            }
        }
        public class EmptyDirVolume : Tea.TeaModel {
            public var medium: String?

            public var sizeLimit: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.medium != nil {
                    map["Medium"] = self.medium!
                }
                if self.sizeLimit != nil {
                    map["SizeLimit"] = self.sizeLimit!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Medium") && dict["Medium"] != nil {
                    self.medium = dict["Medium"] as! String
                }
                if dict.keys.contains("SizeLimit") && dict["SizeLimit"] != nil {
                    self.sizeLimit = dict["SizeLimit"] as! String
                }
            }
        }
        public class FlexVolume : Tea.TeaModel {
            public var driver: String?

            public var fsType: String?

            public var options: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.driver != nil {
                    map["Driver"] = self.driver!
                }
                if self.fsType != nil {
                    map["FsType"] = self.fsType!
                }
                if self.options != nil {
                    map["Options"] = self.options!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Driver") && dict["Driver"] != nil {
                    self.driver = dict["Driver"] as! String
                }
                if dict.keys.contains("FsType") && dict["FsType"] != nil {
                    self.fsType = dict["FsType"] as! String
                }
                if dict.keys.contains("Options") && dict["Options"] != nil {
                    self.options = dict["Options"] as! String
                }
            }
        }
        public class HostPathVolume : Tea.TeaModel {
            public var path: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.path != nil {
                    map["Path"] = self.path!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Path") && dict["Path"] != nil {
                    self.path = dict["Path"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class NFSVolume : Tea.TeaModel {
            public var path: String?

            public var readOnly: Bool?

            public var server: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.path != nil {
                    map["Path"] = self.path!
                }
                if self.readOnly != nil {
                    map["ReadOnly"] = self.readOnly!
                }
                if self.server != nil {
                    map["Server"] = self.server!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Path") && dict["Path"] != nil {
                    self.path = dict["Path"] as! String
                }
                if dict.keys.contains("ReadOnly") && dict["ReadOnly"] != nil {
                    self.readOnly = dict["ReadOnly"] as! Bool
                }
                if dict.keys.contains("Server") && dict["Server"] != nil {
                    self.server = dict["Server"] as! String
                }
            }
        }
        public class ConfigFileVolumeConfigFileToPaths : Tea.TeaModel {
            public var content: String?

            public var mode: Int32?

            public var path: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.content != nil {
                    map["Content"] = self.content!
                }
                if self.mode != nil {
                    map["Mode"] = self.mode!
                }
                if self.path != nil {
                    map["Path"] = self.path!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Content") && dict["Content"] != nil {
                    self.content = dict["Content"] as! String
                }
                if dict.keys.contains("Mode") && dict["Mode"] != nil {
                    self.mode = dict["Mode"] as! Int32
                }
                if dict.keys.contains("Path") && dict["Path"] != nil {
                    self.path = dict["Path"] as! String
                }
            }
        }
        public var diskVolume: CreateEciScalingConfigurationRequest.Volumes.DiskVolume?

        public var emptyDirVolume: CreateEciScalingConfigurationRequest.Volumes.EmptyDirVolume?

        public var flexVolume: CreateEciScalingConfigurationRequest.Volumes.FlexVolume?

        public var hostPathVolume: CreateEciScalingConfigurationRequest.Volumes.HostPathVolume?

        public var NFSVolume: CreateEciScalingConfigurationRequest.Volumes.NFSVolume?

        public var configFileVolumeConfigFileToPaths: [CreateEciScalingConfigurationRequest.Volumes.ConfigFileVolumeConfigFileToPaths]?

        public var configFileVolumeDefaultMode: Int32?

        public var name: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.diskVolume?.validate()
            try self.emptyDirVolume?.validate()
            try self.flexVolume?.validate()
            try self.hostPathVolume?.validate()
            try self.NFSVolume?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.diskVolume != nil {
                map["DiskVolume"] = self.diskVolume?.toMap()
            }
            if self.emptyDirVolume != nil {
                map["EmptyDirVolume"] = self.emptyDirVolume?.toMap()
            }
            if self.flexVolume != nil {
                map["FlexVolume"] = self.flexVolume?.toMap()
            }
            if self.hostPathVolume != nil {
                map["HostPathVolume"] = self.hostPathVolume?.toMap()
            }
            if self.NFSVolume != nil {
                map["NFSVolume"] = self.NFSVolume?.toMap()
            }
            if self.configFileVolumeConfigFileToPaths != nil {
                var tmp : [Any] = []
                for k in self.configFileVolumeConfigFileToPaths! {
                    tmp.append(k.toMap())
                }
                map["ConfigFileVolumeConfigFileToPaths"] = tmp
            }
            if self.configFileVolumeDefaultMode != nil {
                map["ConfigFileVolumeDefaultMode"] = self.configFileVolumeDefaultMode!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DiskVolume") && dict["DiskVolume"] != nil {
                var model = CreateEciScalingConfigurationRequest.Volumes.DiskVolume()
                model.fromMap(dict["DiskVolume"] as! [String: Any])
                self.diskVolume = model
            }
            if dict.keys.contains("EmptyDirVolume") && dict["EmptyDirVolume"] != nil {
                var model = CreateEciScalingConfigurationRequest.Volumes.EmptyDirVolume()
                model.fromMap(dict["EmptyDirVolume"] as! [String: Any])
                self.emptyDirVolume = model
            }
            if dict.keys.contains("FlexVolume") && dict["FlexVolume"] != nil {
                var model = CreateEciScalingConfigurationRequest.Volumes.FlexVolume()
                model.fromMap(dict["FlexVolume"] as! [String: Any])
                self.flexVolume = model
            }
            if dict.keys.contains("HostPathVolume") && dict["HostPathVolume"] != nil {
                var model = CreateEciScalingConfigurationRequest.Volumes.HostPathVolume()
                model.fromMap(dict["HostPathVolume"] as! [String: Any])
                self.hostPathVolume = model
            }
            if dict.keys.contains("NFSVolume") && dict["NFSVolume"] != nil {
                var model = CreateEciScalingConfigurationRequest.Volumes.NFSVolume()
                model.fromMap(dict["NFSVolume"] as! [String: Any])
                self.NFSVolume = model
            }
            if dict.keys.contains("ConfigFileVolumeConfigFileToPaths") && dict["ConfigFileVolumeConfigFileToPaths"] != nil {
                var tmp : [CreateEciScalingConfigurationRequest.Volumes.ConfigFileVolumeConfigFileToPaths] = []
                for v in dict["ConfigFileVolumeConfigFileToPaths"] as! [Any] {
                    var model = CreateEciScalingConfigurationRequest.Volumes.ConfigFileVolumeConfigFileToPaths()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.configFileVolumeConfigFileToPaths = tmp
            }
            if dict.keys.contains("ConfigFileVolumeDefaultMode") && dict["ConfigFileVolumeDefaultMode"] != nil {
                self.configFileVolumeDefaultMode = dict["ConfigFileVolumeDefaultMode"] as! Int32
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var acrRegistryInfos: [CreateEciScalingConfigurationRequest.AcrRegistryInfos]?

    public var activeDeadlineSeconds: Int64?

    public var autoCreateEip: Bool?

    public var autoMatchImageCache: Bool?

    public var containerGroupName: String?

    public var containers: [CreateEciScalingConfigurationRequest.Containers]?

    public var costOptimization: Bool?

    public var cpu: Double?

    public var cpuOptionsCore: Int32?

    public var cpuOptionsThreadsPerCore: Int32?

    public var dataCacheBucket: String?

    public var dataCacheBurstingEnabled: Bool?

    public var dataCachePL: String?

    public var dataCacheProvisionedIops: Int32?

    public var description_: String?

    public var dnsConfigNameServers: [String]?

    public var dnsConfigOptions: [CreateEciScalingConfigurationRequest.DnsConfigOptions]?

    public var dnsConfigSearchs: [String]?

    public var dnsPolicy: String?

    public var egressBandwidth: Int64?

    public var eipBandwidth: Int32?

    public var enableSls: Bool?

    public var ephemeralStorage: Int32?

    public var hostAliases: [CreateEciScalingConfigurationRequest.HostAliases]?

    public var hostName: String?

    public var imageRegistryCredentials: [CreateEciScalingConfigurationRequest.ImageRegistryCredentials]?

    public var imageSnapshotId: String?

    public var ingressBandwidth: Int64?

    public var initContainers: [CreateEciScalingConfigurationRequest.InitContainers]?

    public var instanceFamilyLevel: String?

    public var instanceTypes: [String]?

    public var ipv6AddressCount: Int32?

    public var loadBalancerWeight: Int32?

    public var memory: Double?

    public var ntpServers: [String]?

    public var ownerId: Int64?

    public var ramRoleName: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var restartPolicy: String?

    public var scalingConfigurationName: String?

    public var scalingGroupId: String?

    public var securityContextSysctls: [CreateEciScalingConfigurationRequest.SecurityContextSysctls]?

    public var securityGroupId: String?

    public var spotPriceLimit: Double?

    public var spotStrategy: String?

    public var tags: [CreateEciScalingConfigurationRequest.Tags]?

    public var terminationGracePeriodSeconds: Int64?

    public var volumes: [CreateEciScalingConfigurationRequest.Volumes]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acrRegistryInfos != nil {
            var tmp : [Any] = []
            for k in self.acrRegistryInfos! {
                tmp.append(k.toMap())
            }
            map["AcrRegistryInfos"] = tmp
        }
        if self.activeDeadlineSeconds != nil {
            map["ActiveDeadlineSeconds"] = self.activeDeadlineSeconds!
        }
        if self.autoCreateEip != nil {
            map["AutoCreateEip"] = self.autoCreateEip!
        }
        if self.autoMatchImageCache != nil {
            map["AutoMatchImageCache"] = self.autoMatchImageCache!
        }
        if self.containerGroupName != nil {
            map["ContainerGroupName"] = self.containerGroupName!
        }
        if self.containers != nil {
            var tmp : [Any] = []
            for k in self.containers! {
                tmp.append(k.toMap())
            }
            map["Containers"] = tmp
        }
        if self.costOptimization != nil {
            map["CostOptimization"] = self.costOptimization!
        }
        if self.cpu != nil {
            map["Cpu"] = self.cpu!
        }
        if self.cpuOptionsCore != nil {
            map["CpuOptionsCore"] = self.cpuOptionsCore!
        }
        if self.cpuOptionsThreadsPerCore != nil {
            map["CpuOptionsThreadsPerCore"] = self.cpuOptionsThreadsPerCore!
        }
        if self.dataCacheBucket != nil {
            map["DataCacheBucket"] = self.dataCacheBucket!
        }
        if self.dataCacheBurstingEnabled != nil {
            map["DataCacheBurstingEnabled"] = self.dataCacheBurstingEnabled!
        }
        if self.dataCachePL != nil {
            map["DataCachePL"] = self.dataCachePL!
        }
        if self.dataCacheProvisionedIops != nil {
            map["DataCacheProvisionedIops"] = self.dataCacheProvisionedIops!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.dnsConfigNameServers != nil {
            map["DnsConfigNameServers"] = self.dnsConfigNameServers!
        }
        if self.dnsConfigOptions != nil {
            var tmp : [Any] = []
            for k in self.dnsConfigOptions! {
                tmp.append(k.toMap())
            }
            map["DnsConfigOptions"] = tmp
        }
        if self.dnsConfigSearchs != nil {
            map["DnsConfigSearchs"] = self.dnsConfigSearchs!
        }
        if self.dnsPolicy != nil {
            map["DnsPolicy"] = self.dnsPolicy!
        }
        if self.egressBandwidth != nil {
            map["EgressBandwidth"] = self.egressBandwidth!
        }
        if self.eipBandwidth != nil {
            map["EipBandwidth"] = self.eipBandwidth!
        }
        if self.enableSls != nil {
            map["EnableSls"] = self.enableSls!
        }
        if self.ephemeralStorage != nil {
            map["EphemeralStorage"] = self.ephemeralStorage!
        }
        if self.hostAliases != nil {
            var tmp : [Any] = []
            for k in self.hostAliases! {
                tmp.append(k.toMap())
            }
            map["HostAliases"] = tmp
        }
        if self.hostName != nil {
            map["HostName"] = self.hostName!
        }
        if self.imageRegistryCredentials != nil {
            var tmp : [Any] = []
            for k in self.imageRegistryCredentials! {
                tmp.append(k.toMap())
            }
            map["ImageRegistryCredentials"] = tmp
        }
        if self.imageSnapshotId != nil {
            map["ImageSnapshotId"] = self.imageSnapshotId!
        }
        if self.ingressBandwidth != nil {
            map["IngressBandwidth"] = self.ingressBandwidth!
        }
        if self.initContainers != nil {
            var tmp : [Any] = []
            for k in self.initContainers! {
                tmp.append(k.toMap())
            }
            map["InitContainers"] = tmp
        }
        if self.instanceFamilyLevel != nil {
            map["InstanceFamilyLevel"] = self.instanceFamilyLevel!
        }
        if self.instanceTypes != nil {
            map["InstanceTypes"] = self.instanceTypes!
        }
        if self.ipv6AddressCount != nil {
            map["Ipv6AddressCount"] = self.ipv6AddressCount!
        }
        if self.loadBalancerWeight != nil {
            map["LoadBalancerWeight"] = self.loadBalancerWeight!
        }
        if self.memory != nil {
            map["Memory"] = self.memory!
        }
        if self.ntpServers != nil {
            map["NtpServers"] = self.ntpServers!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.ramRoleName != nil {
            map["RamRoleName"] = self.ramRoleName!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.restartPolicy != nil {
            map["RestartPolicy"] = self.restartPolicy!
        }
        if self.scalingConfigurationName != nil {
            map["ScalingConfigurationName"] = self.scalingConfigurationName!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        if self.securityContextSysctls != nil {
            var tmp : [Any] = []
            for k in self.securityContextSysctls! {
                tmp.append(k.toMap())
            }
            map["SecurityContextSysctls"] = tmp
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.spotPriceLimit != nil {
            map["SpotPriceLimit"] = self.spotPriceLimit!
        }
        if self.spotStrategy != nil {
            map["SpotStrategy"] = self.spotStrategy!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        if self.terminationGracePeriodSeconds != nil {
            map["TerminationGracePeriodSeconds"] = self.terminationGracePeriodSeconds!
        }
        if self.volumes != nil {
            var tmp : [Any] = []
            for k in self.volumes! {
                tmp.append(k.toMap())
            }
            map["Volumes"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcrRegistryInfos") && dict["AcrRegistryInfos"] != nil {
            var tmp : [CreateEciScalingConfigurationRequest.AcrRegistryInfos] = []
            for v in dict["AcrRegistryInfos"] as! [Any] {
                var model = CreateEciScalingConfigurationRequest.AcrRegistryInfos()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.acrRegistryInfos = tmp
        }
        if dict.keys.contains("ActiveDeadlineSeconds") && dict["ActiveDeadlineSeconds"] != nil {
            self.activeDeadlineSeconds = dict["ActiveDeadlineSeconds"] as! Int64
        }
        if dict.keys.contains("AutoCreateEip") && dict["AutoCreateEip"] != nil {
            self.autoCreateEip = dict["AutoCreateEip"] as! Bool
        }
        if dict.keys.contains("AutoMatchImageCache") && dict["AutoMatchImageCache"] != nil {
            self.autoMatchImageCache = dict["AutoMatchImageCache"] as! Bool
        }
        if dict.keys.contains("ContainerGroupName") && dict["ContainerGroupName"] != nil {
            self.containerGroupName = dict["ContainerGroupName"] as! String
        }
        if dict.keys.contains("Containers") && dict["Containers"] != nil {
            var tmp : [CreateEciScalingConfigurationRequest.Containers] = []
            for v in dict["Containers"] as! [Any] {
                var model = CreateEciScalingConfigurationRequest.Containers()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.containers = tmp
        }
        if dict.keys.contains("CostOptimization") && dict["CostOptimization"] != nil {
            self.costOptimization = dict["CostOptimization"] as! Bool
        }
        if dict.keys.contains("Cpu") && dict["Cpu"] != nil {
            self.cpu = dict["Cpu"] as! Double
        }
        if dict.keys.contains("CpuOptionsCore") && dict["CpuOptionsCore"] != nil {
            self.cpuOptionsCore = dict["CpuOptionsCore"] as! Int32
        }
        if dict.keys.contains("CpuOptionsThreadsPerCore") && dict["CpuOptionsThreadsPerCore"] != nil {
            self.cpuOptionsThreadsPerCore = dict["CpuOptionsThreadsPerCore"] as! Int32
        }
        if dict.keys.contains("DataCacheBucket") && dict["DataCacheBucket"] != nil {
            self.dataCacheBucket = dict["DataCacheBucket"] as! String
        }
        if dict.keys.contains("DataCacheBurstingEnabled") && dict["DataCacheBurstingEnabled"] != nil {
            self.dataCacheBurstingEnabled = dict["DataCacheBurstingEnabled"] as! Bool
        }
        if dict.keys.contains("DataCachePL") && dict["DataCachePL"] != nil {
            self.dataCachePL = dict["DataCachePL"] as! String
        }
        if dict.keys.contains("DataCacheProvisionedIops") && dict["DataCacheProvisionedIops"] != nil {
            self.dataCacheProvisionedIops = dict["DataCacheProvisionedIops"] as! Int32
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DnsConfigNameServers") && dict["DnsConfigNameServers"] != nil {
            self.dnsConfigNameServers = dict["DnsConfigNameServers"] as! [String]
        }
        if dict.keys.contains("DnsConfigOptions") && dict["DnsConfigOptions"] != nil {
            var tmp : [CreateEciScalingConfigurationRequest.DnsConfigOptions] = []
            for v in dict["DnsConfigOptions"] as! [Any] {
                var model = CreateEciScalingConfigurationRequest.DnsConfigOptions()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.dnsConfigOptions = tmp
        }
        if dict.keys.contains("DnsConfigSearchs") && dict["DnsConfigSearchs"] != nil {
            self.dnsConfigSearchs = dict["DnsConfigSearchs"] as! [String]
        }
        if dict.keys.contains("DnsPolicy") && dict["DnsPolicy"] != nil {
            self.dnsPolicy = dict["DnsPolicy"] as! String
        }
        if dict.keys.contains("EgressBandwidth") && dict["EgressBandwidth"] != nil {
            self.egressBandwidth = dict["EgressBandwidth"] as! Int64
        }
        if dict.keys.contains("EipBandwidth") && dict["EipBandwidth"] != nil {
            self.eipBandwidth = dict["EipBandwidth"] as! Int32
        }
        if dict.keys.contains("EnableSls") && dict["EnableSls"] != nil {
            self.enableSls = dict["EnableSls"] as! Bool
        }
        if dict.keys.contains("EphemeralStorage") && dict["EphemeralStorage"] != nil {
            self.ephemeralStorage = dict["EphemeralStorage"] as! Int32
        }
        if dict.keys.contains("HostAliases") && dict["HostAliases"] != nil {
            var tmp : [CreateEciScalingConfigurationRequest.HostAliases] = []
            for v in dict["HostAliases"] as! [Any] {
                var model = CreateEciScalingConfigurationRequest.HostAliases()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.hostAliases = tmp
        }
        if dict.keys.contains("HostName") && dict["HostName"] != nil {
            self.hostName = dict["HostName"] as! String
        }
        if dict.keys.contains("ImageRegistryCredentials") && dict["ImageRegistryCredentials"] != nil {
            var tmp : [CreateEciScalingConfigurationRequest.ImageRegistryCredentials] = []
            for v in dict["ImageRegistryCredentials"] as! [Any] {
                var model = CreateEciScalingConfigurationRequest.ImageRegistryCredentials()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.imageRegistryCredentials = tmp
        }
        if dict.keys.contains("ImageSnapshotId") && dict["ImageSnapshotId"] != nil {
            self.imageSnapshotId = dict["ImageSnapshotId"] as! String
        }
        if dict.keys.contains("IngressBandwidth") && dict["IngressBandwidth"] != nil {
            self.ingressBandwidth = dict["IngressBandwidth"] as! Int64
        }
        if dict.keys.contains("InitContainers") && dict["InitContainers"] != nil {
            var tmp : [CreateEciScalingConfigurationRequest.InitContainers] = []
            for v in dict["InitContainers"] as! [Any] {
                var model = CreateEciScalingConfigurationRequest.InitContainers()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.initContainers = tmp
        }
        if dict.keys.contains("InstanceFamilyLevel") && dict["InstanceFamilyLevel"] != nil {
            self.instanceFamilyLevel = dict["InstanceFamilyLevel"] as! String
        }
        if dict.keys.contains("InstanceTypes") && dict["InstanceTypes"] != nil {
            self.instanceTypes = dict["InstanceTypes"] as! [String]
        }
        if dict.keys.contains("Ipv6AddressCount") && dict["Ipv6AddressCount"] != nil {
            self.ipv6AddressCount = dict["Ipv6AddressCount"] as! Int32
        }
        if dict.keys.contains("LoadBalancerWeight") && dict["LoadBalancerWeight"] != nil {
            self.loadBalancerWeight = dict["LoadBalancerWeight"] as! Int32
        }
        if dict.keys.contains("Memory") && dict["Memory"] != nil {
            self.memory = dict["Memory"] as! Double
        }
        if dict.keys.contains("NtpServers") && dict["NtpServers"] != nil {
            self.ntpServers = dict["NtpServers"] as! [String]
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RamRoleName") && dict["RamRoleName"] != nil {
            self.ramRoleName = dict["RamRoleName"] as! String
        }
        if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("RestartPolicy") && dict["RestartPolicy"] != nil {
            self.restartPolicy = dict["RestartPolicy"] as! String
        }
        if dict.keys.contains("ScalingConfigurationName") && dict["ScalingConfigurationName"] != nil {
            self.scalingConfigurationName = dict["ScalingConfigurationName"] as! String
        }
        if dict.keys.contains("ScalingGroupId") && dict["ScalingGroupId"] != nil {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
        if dict.keys.contains("SecurityContextSysctls") && dict["SecurityContextSysctls"] != nil {
            var tmp : [CreateEciScalingConfigurationRequest.SecurityContextSysctls] = []
            for v in dict["SecurityContextSysctls"] as! [Any] {
                var model = CreateEciScalingConfigurationRequest.SecurityContextSysctls()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.securityContextSysctls = tmp
        }
        if dict.keys.contains("SecurityGroupId") && dict["SecurityGroupId"] != nil {
            self.securityGroupId = dict["SecurityGroupId"] as! String
        }
        if dict.keys.contains("SpotPriceLimit") && dict["SpotPriceLimit"] != nil {
            self.spotPriceLimit = dict["SpotPriceLimit"] as! Double
        }
        if dict.keys.contains("SpotStrategy") && dict["SpotStrategy"] != nil {
            self.spotStrategy = dict["SpotStrategy"] as! String
        }
        if dict.keys.contains("Tags") && dict["Tags"] != nil {
            var tmp : [CreateEciScalingConfigurationRequest.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = CreateEciScalingConfigurationRequest.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
        if dict.keys.contains("TerminationGracePeriodSeconds") && dict["TerminationGracePeriodSeconds"] != nil {
            self.terminationGracePeriodSeconds = dict["TerminationGracePeriodSeconds"] as! Int64
        }
        if dict.keys.contains("Volumes") && dict["Volumes"] != nil {
            var tmp : [CreateEciScalingConfigurationRequest.Volumes] = []
            for v in dict["Volumes"] as! [Any] {
                var model = CreateEciScalingConfigurationRequest.Volumes()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.volumes = tmp
        }
    }
}

public class CreateEciScalingConfigurationResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var scalingConfigurationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingConfigurationId != nil {
            map["ScalingConfigurationId"] = self.scalingConfigurationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScalingConfigurationId") && dict["ScalingConfigurationId"] != nil {
            self.scalingConfigurationId = dict["ScalingConfigurationId"] as! String
        }
    }
}

public class CreateEciScalingConfigurationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateEciScalingConfigurationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateEciScalingConfigurationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateLifecycleHookRequest : Tea.TeaModel {
    public var defaultResult: String?

    public var heartbeatTimeout: Int32?

    public var lifecycleHookName: String?

    public var lifecycleTransition: String?

    public var notificationArn: String?

    public var notificationMetadata: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.defaultResult != nil {
            map["DefaultResult"] = self.defaultResult!
        }
        if self.heartbeatTimeout != nil {
            map["HeartbeatTimeout"] = self.heartbeatTimeout!
        }
        if self.lifecycleHookName != nil {
            map["LifecycleHookName"] = self.lifecycleHookName!
        }
        if self.lifecycleTransition != nil {
            map["LifecycleTransition"] = self.lifecycleTransition!
        }
        if self.notificationArn != nil {
            map["NotificationArn"] = self.notificationArn!
        }
        if self.notificationMetadata != nil {
            map["NotificationMetadata"] = self.notificationMetadata!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DefaultResult") && dict["DefaultResult"] != nil {
            self.defaultResult = dict["DefaultResult"] as! String
        }
        if dict.keys.contains("HeartbeatTimeout") && dict["HeartbeatTimeout"] != nil {
            self.heartbeatTimeout = dict["HeartbeatTimeout"] as! Int32
        }
        if dict.keys.contains("LifecycleHookName") && dict["LifecycleHookName"] != nil {
            self.lifecycleHookName = dict["LifecycleHookName"] as! String
        }
        if dict.keys.contains("LifecycleTransition") && dict["LifecycleTransition"] != nil {
            self.lifecycleTransition = dict["LifecycleTransition"] as! String
        }
        if dict.keys.contains("NotificationArn") && dict["NotificationArn"] != nil {
            self.notificationArn = dict["NotificationArn"] as! String
        }
        if dict.keys.contains("NotificationMetadata") && dict["NotificationMetadata"] != nil {
            self.notificationMetadata = dict["NotificationMetadata"] as! String
        }
        if dict.keys.contains("OwnerAccount") && dict["OwnerAccount"] != nil {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScalingGroupId") && dict["ScalingGroupId"] != nil {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
    }
}

public class CreateLifecycleHookResponseBody : Tea.TeaModel {
    public var lifecycleHookId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lifecycleHookId != nil {
            map["LifecycleHookId"] = self.lifecycleHookId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LifecycleHookId") && dict["LifecycleHookId"] != nil {
            self.lifecycleHookId = dict["LifecycleHookId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateLifecycleHookResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateLifecycleHookResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateLifecycleHookResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateNotificationConfigurationRequest : Tea.TeaModel {
    public var notificationArn: String?

    public var notificationTypes: [String]?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.notificationArn != nil {
            map["NotificationArn"] = self.notificationArn!
        }
        if self.notificationTypes != nil {
            map["NotificationTypes"] = self.notificationTypes!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NotificationArn") && dict["NotificationArn"] != nil {
            self.notificationArn = dict["NotificationArn"] as! String
        }
        if dict.keys.contains("NotificationTypes") && dict["NotificationTypes"] != nil {
            self.notificationTypes = dict["NotificationTypes"] as! [String]
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScalingGroupId") && dict["ScalingGroupId"] != nil {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
    }
}

public class CreateNotificationConfigurationResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateNotificationConfigurationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateNotificationConfigurationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateNotificationConfigurationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateScalingConfigurationRequest : Tea.TeaModel {
    public class ImageOptions : Tea.TeaModel {
        public var loginAsNonRoot: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.loginAsNonRoot != nil {
                map["LoginAsNonRoot"] = self.loginAsNonRoot!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LoginAsNonRoot") && dict["LoginAsNonRoot"] != nil {
                self.loginAsNonRoot = dict["LoginAsNonRoot"] as! Bool
            }
        }
    }
    public class PrivatePoolOptions : Tea.TeaModel {
        public var id: String?

        public var matchCriteria: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.matchCriteria != nil {
                map["MatchCriteria"] = self.matchCriteria!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("MatchCriteria") && dict["MatchCriteria"] != nil {
                self.matchCriteria = dict["MatchCriteria"] as! String
            }
        }
    }
    public class SystemDisk : Tea.TeaModel {
        public var autoSnapshotPolicyId: String?

        public var burstingEnabled: Bool?

        public var category: String?

        public var description_: String?

        public var diskName: String?

        public var encryptAlgorithm: String?

        public var encrypted: Bool?

        public var KMSKeyId: String?

        public var performanceLevel: String?

        public var provisionedIops: Int64?

        public var size: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.autoSnapshotPolicyId != nil {
                map["AutoSnapshotPolicyId"] = self.autoSnapshotPolicyId!
            }
            if self.burstingEnabled != nil {
                map["BurstingEnabled"] = self.burstingEnabled!
            }
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.diskName != nil {
                map["DiskName"] = self.diskName!
            }
            if self.encryptAlgorithm != nil {
                map["EncryptAlgorithm"] = self.encryptAlgorithm!
            }
            if self.encrypted != nil {
                map["Encrypted"] = self.encrypted!
            }
            if self.KMSKeyId != nil {
                map["KMSKeyId"] = self.KMSKeyId!
            }
            if self.performanceLevel != nil {
                map["PerformanceLevel"] = self.performanceLevel!
            }
            if self.provisionedIops != nil {
                map["ProvisionedIops"] = self.provisionedIops!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AutoSnapshotPolicyId") && dict["AutoSnapshotPolicyId"] != nil {
                self.autoSnapshotPolicyId = dict["AutoSnapshotPolicyId"] as! String
            }
            if dict.keys.contains("BurstingEnabled") && dict["BurstingEnabled"] != nil {
                self.burstingEnabled = dict["BurstingEnabled"] as! Bool
            }
            if dict.keys.contains("Category") && dict["Category"] != nil {
                self.category = dict["Category"] as! String
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("DiskName") && dict["DiskName"] != nil {
                self.diskName = dict["DiskName"] as! String
            }
            if dict.keys.contains("EncryptAlgorithm") && dict["EncryptAlgorithm"] != nil {
                self.encryptAlgorithm = dict["EncryptAlgorithm"] as! String
            }
            if dict.keys.contains("Encrypted") && dict["Encrypted"] != nil {
                self.encrypted = dict["Encrypted"] as! Bool
            }
            if dict.keys.contains("KMSKeyId") && dict["KMSKeyId"] != nil {
                self.KMSKeyId = dict["KMSKeyId"] as! String
            }
            if dict.keys.contains("PerformanceLevel") && dict["PerformanceLevel"] != nil {
                self.performanceLevel = dict["PerformanceLevel"] as! String
            }
            if dict.keys.contains("ProvisionedIops") && dict["ProvisionedIops"] != nil {
                self.provisionedIops = dict["ProvisionedIops"] as! Int64
            }
            if dict.keys.contains("Size") && dict["Size"] != nil {
                self.size = dict["Size"] as! Int32
            }
        }
    }
    public class CustomPriorities : Tea.TeaModel {
        public var instanceType: String?

        public var vswitchId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.vswitchId != nil {
                map["VswitchId"] = self.vswitchId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceType") && dict["InstanceType"] != nil {
                self.instanceType = dict["InstanceType"] as! String
            }
            if dict.keys.contains("VswitchId") && dict["VswitchId"] != nil {
                self.vswitchId = dict["VswitchId"] as! String
            }
        }
    }
    public class DataDisks : Tea.TeaModel {
        public var autoSnapshotPolicyId: String?

        public var burstingEnabled: Bool?

        public var categories: [String]?

        public var category: String?

        public var deleteWithInstance: Bool?

        public var description_: String?

        public var device: String?

        public var diskName: String?

        public var encrypted: String?

        public var KMSKeyId: String?

        public var performanceLevel: String?

        public var provisionedIops: Int64?

        public var size: Int32?

        public var snapshotId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.autoSnapshotPolicyId != nil {
                map["AutoSnapshotPolicyId"] = self.autoSnapshotPolicyId!
            }
            if self.burstingEnabled != nil {
                map["BurstingEnabled"] = self.burstingEnabled!
            }
            if self.categories != nil {
                map["Categories"] = self.categories!
            }
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.deleteWithInstance != nil {
                map["DeleteWithInstance"] = self.deleteWithInstance!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.device != nil {
                map["Device"] = self.device!
            }
            if self.diskName != nil {
                map["DiskName"] = self.diskName!
            }
            if self.encrypted != nil {
                map["Encrypted"] = self.encrypted!
            }
            if self.KMSKeyId != nil {
                map["KMSKeyId"] = self.KMSKeyId!
            }
            if self.performanceLevel != nil {
                map["PerformanceLevel"] = self.performanceLevel!
            }
            if self.provisionedIops != nil {
                map["ProvisionedIops"] = self.provisionedIops!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.snapshotId != nil {
                map["SnapshotId"] = self.snapshotId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AutoSnapshotPolicyId") && dict["AutoSnapshotPolicyId"] != nil {
                self.autoSnapshotPolicyId = dict["AutoSnapshotPolicyId"] as! String
            }
            if dict.keys.contains("BurstingEnabled") && dict["BurstingEnabled"] != nil {
                self.burstingEnabled = dict["BurstingEnabled"] as! Bool
            }
            if dict.keys.contains("Categories") && dict["Categories"] != nil {
                self.categories = dict["Categories"] as! [String]
            }
            if dict.keys.contains("Category") && dict["Category"] != nil {
                self.category = dict["Category"] as! String
            }
            if dict.keys.contains("DeleteWithInstance") && dict["DeleteWithInstance"] != nil {
                self.deleteWithInstance = dict["DeleteWithInstance"] as! Bool
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Device") && dict["Device"] != nil {
                self.device = dict["Device"] as! String
            }
            if dict.keys.contains("DiskName") && dict["DiskName"] != nil {
                self.diskName = dict["DiskName"] as! String
            }
            if dict.keys.contains("Encrypted") && dict["Encrypted"] != nil {
                self.encrypted = dict["Encrypted"] as! String
            }
            if dict.keys.contains("KMSKeyId") && dict["KMSKeyId"] != nil {
                self.KMSKeyId = dict["KMSKeyId"] as! String
            }
            if dict.keys.contains("PerformanceLevel") && dict["PerformanceLevel"] != nil {
                self.performanceLevel = dict["PerformanceLevel"] as! String
            }
            if dict.keys.contains("ProvisionedIops") && dict["ProvisionedIops"] != nil {
                self.provisionedIops = dict["ProvisionedIops"] as! Int64
            }
            if dict.keys.contains("Size") && dict["Size"] != nil {
                self.size = dict["Size"] as! Int32
            }
            if dict.keys.contains("SnapshotId") && dict["SnapshotId"] != nil {
                self.snapshotId = dict["SnapshotId"] as! String
            }
        }
    }
    public class InstancePatternInfos : Tea.TeaModel {
        public var architectures: [String]?

        public var burstablePerformance: String?

        public var cores: Int32?

        public var excludedInstanceTypes: [String]?

        public var instanceFamilyLevel: String?

        public var maxPrice: Double?

        public var memory: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.architectures != nil {
                map["Architectures"] = self.architectures!
            }
            if self.burstablePerformance != nil {
                map["BurstablePerformance"] = self.burstablePerformance!
            }
            if self.cores != nil {
                map["Cores"] = self.cores!
            }
            if self.excludedInstanceTypes != nil {
                map["ExcludedInstanceTypes"] = self.excludedInstanceTypes!
            }
            if self.instanceFamilyLevel != nil {
                map["InstanceFamilyLevel"] = self.instanceFamilyLevel!
            }
            if self.maxPrice != nil {
                map["MaxPrice"] = self.maxPrice!
            }
            if self.memory != nil {
                map["Memory"] = self.memory!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Architectures") && dict["Architectures"] != nil {
                self.architectures = dict["Architectures"] as! [String]
            }
            if dict.keys.contains("BurstablePerformance") && dict["BurstablePerformance"] != nil {
                self.burstablePerformance = dict["BurstablePerformance"] as! String
            }
            if dict.keys.contains("Cores") && dict["Cores"] != nil {
                self.cores = dict["Cores"] as! Int32
            }
            if dict.keys.contains("ExcludedInstanceTypes") && dict["ExcludedInstanceTypes"] != nil {
                self.excludedInstanceTypes = dict["ExcludedInstanceTypes"] as! [String]
            }
            if dict.keys.contains("InstanceFamilyLevel") && dict["InstanceFamilyLevel"] != nil {
                self.instanceFamilyLevel = dict["InstanceFamilyLevel"] as! String
            }
            if dict.keys.contains("MaxPrice") && dict["MaxPrice"] != nil {
                self.maxPrice = dict["MaxPrice"] as! Double
            }
            if dict.keys.contains("Memory") && dict["Memory"] != nil {
                self.memory = dict["Memory"] as! Double
            }
        }
    }
    public class InstanceTypeOverrides : Tea.TeaModel {
        public var instanceType: String?

        public var weightedCapacity: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.weightedCapacity != nil {
                map["WeightedCapacity"] = self.weightedCapacity!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceType") && dict["InstanceType"] != nil {
                self.instanceType = dict["InstanceType"] as! String
            }
            if dict.keys.contains("WeightedCapacity") && dict["WeightedCapacity"] != nil {
                self.weightedCapacity = dict["WeightedCapacity"] as! Int32
            }
        }
    }
    public class SpotPriceLimits : Tea.TeaModel {
        public var instanceType: String?

        public var priceLimit: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.priceLimit != nil {
                map["PriceLimit"] = self.priceLimit!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceType") && dict["InstanceType"] != nil {
                self.instanceType = dict["InstanceType"] as! String
            }
            if dict.keys.contains("PriceLimit") && dict["PriceLimit"] != nil {
                self.priceLimit = dict["PriceLimit"] as! Double
            }
        }
    }
    public var imageOptions: CreateScalingConfigurationRequest.ImageOptions?

    public var privatePoolOptions: CreateScalingConfigurationRequest.PrivatePoolOptions?

    public var systemDisk: CreateScalingConfigurationRequest.SystemDisk?

    public var affinity: String?

    public var clientToken: String?

    public var cpu: Int32?

    public var creditSpecification: String?

    public var customPriorities: [CreateScalingConfigurationRequest.CustomPriorities]?

    public var dataDisks: [CreateScalingConfigurationRequest.DataDisks]?

    public var dedicatedHostId: String?

    public var deletionProtection: Bool?

    public var deploymentSetId: String?

    public var hostName: String?

    public var hpcClusterId: String?

    public var imageFamily: String?

    public var imageId: String?

    public var imageName: String?

    public var instanceDescription: String?

    public var instanceName: String?

    public var instancePatternInfos: [CreateScalingConfigurationRequest.InstancePatternInfos]?

    public var instanceType: String?

    public var instanceTypeOverrides: [CreateScalingConfigurationRequest.InstanceTypeOverrides]?

    public var instanceTypes: [String]?

    public var internetChargeType: String?

    public var internetMaxBandwidthIn: Int32?

    public var internetMaxBandwidthOut: Int32?

    public var ioOptimized: String?

    public var ipv6AddressCount: Int32?

    public var keyPairName: String?

    public var loadBalancerWeight: Int32?

    public var memory: Int32?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var password: String?

    public var passwordInherit: Bool?

    public var ramRoleName: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var scalingConfigurationName: String?

    public var scalingGroupId: String?

    public var schedulerOptions: [String: Any]?

    public var securityEnhancementStrategy: String?

    public var securityGroupId: String?

    public var securityGroupIds: [String]?

    public var spotDuration: Int32?

    public var spotInterruptionBehavior: String?

    public var spotPriceLimits: [CreateScalingConfigurationRequest.SpotPriceLimits]?

    public var spotStrategy: String?

    public var storageSetId: String?

    public var storageSetPartitionNumber: Int32?

    public var systemDiskCategories: [String]?

    public var tags: String?

    public var tenancy: String?

    public var userData: String?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.imageOptions?.validate()
        try self.privatePoolOptions?.validate()
        try self.systemDisk?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imageOptions != nil {
            map["ImageOptions"] = self.imageOptions?.toMap()
        }
        if self.privatePoolOptions != nil {
            map["PrivatePoolOptions"] = self.privatePoolOptions?.toMap()
        }
        if self.systemDisk != nil {
            map["SystemDisk"] = self.systemDisk?.toMap()
        }
        if self.affinity != nil {
            map["Affinity"] = self.affinity!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.cpu != nil {
            map["Cpu"] = self.cpu!
        }
        if self.creditSpecification != nil {
            map["CreditSpecification"] = self.creditSpecification!
        }
        if self.customPriorities != nil {
            var tmp : [Any] = []
            for k in self.customPriorities! {
                tmp.append(k.toMap())
            }
            map["CustomPriorities"] = tmp
        }
        if self.dataDisks != nil {
            var tmp : [Any] = []
            for k in self.dataDisks! {
                tmp.append(k.toMap())
            }
            map["DataDisks"] = tmp
        }
        if self.dedicatedHostId != nil {
            map["DedicatedHostId"] = self.dedicatedHostId!
        }
        if self.deletionProtection != nil {
            map["DeletionProtection"] = self.deletionProtection!
        }
        if self.deploymentSetId != nil {
            map["DeploymentSetId"] = self.deploymentSetId!
        }
        if self.hostName != nil {
            map["HostName"] = self.hostName!
        }
        if self.hpcClusterId != nil {
            map["HpcClusterId"] = self.hpcClusterId!
        }
        if self.imageFamily != nil {
            map["ImageFamily"] = self.imageFamily!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.imageName != nil {
            map["ImageName"] = self.imageName!
        }
        if self.instanceDescription != nil {
            map["InstanceDescription"] = self.instanceDescription!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.instancePatternInfos != nil {
            var tmp : [Any] = []
            for k in self.instancePatternInfos! {
                tmp.append(k.toMap())
            }
            map["InstancePatternInfos"] = tmp
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.instanceTypeOverrides != nil {
            var tmp : [Any] = []
            for k in self.instanceTypeOverrides! {
                tmp.append(k.toMap())
            }
            map["InstanceTypeOverrides"] = tmp
        }
        if self.instanceTypes != nil {
            map["InstanceTypes"] = self.instanceTypes!
        }
        if self.internetChargeType != nil {
            map["InternetChargeType"] = self.internetChargeType!
        }
        if self.internetMaxBandwidthIn != nil {
            map["InternetMaxBandwidthIn"] = self.internetMaxBandwidthIn!
        }
        if self.internetMaxBandwidthOut != nil {
            map["InternetMaxBandwidthOut"] = self.internetMaxBandwidthOut!
        }
        if self.ioOptimized != nil {
            map["IoOptimized"] = self.ioOptimized!
        }
        if self.ipv6AddressCount != nil {
            map["Ipv6AddressCount"] = self.ipv6AddressCount!
        }
        if self.keyPairName != nil {
            map["KeyPairName"] = self.keyPairName!
        }
        if self.loadBalancerWeight != nil {
            map["LoadBalancerWeight"] = self.loadBalancerWeight!
        }
        if self.memory != nil {
            map["Memory"] = self.memory!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        if self.passwordInherit != nil {
            map["PasswordInherit"] = self.passwordInherit!
        }
        if self.ramRoleName != nil {
            map["RamRoleName"] = self.ramRoleName!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingConfigurationName != nil {
            map["ScalingConfigurationName"] = self.scalingConfigurationName!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        if self.schedulerOptions != nil {
            map["SchedulerOptions"] = self.schedulerOptions!
        }
        if self.securityEnhancementStrategy != nil {
            map["SecurityEnhancementStrategy"] = self.securityEnhancementStrategy!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.securityGroupIds != nil {
            map["SecurityGroupIds"] = self.securityGroupIds!
        }
        if self.spotDuration != nil {
            map["SpotDuration"] = self.spotDuration!
        }
        if self.spotInterruptionBehavior != nil {
            map["SpotInterruptionBehavior"] = self.spotInterruptionBehavior!
        }
        if self.spotPriceLimits != nil {
            var tmp : [Any] = []
            for k in self.spotPriceLimits! {
                tmp.append(k.toMap())
            }
            map["SpotPriceLimits"] = tmp
        }
        if self.spotStrategy != nil {
            map["SpotStrategy"] = self.spotStrategy!
        }
        if self.storageSetId != nil {
            map["StorageSetId"] = self.storageSetId!
        }
        if self.storageSetPartitionNumber != nil {
            map["StorageSetPartitionNumber"] = self.storageSetPartitionNumber!
        }
        if self.systemDiskCategories != nil {
            map["SystemDiskCategories"] = self.systemDiskCategories!
        }
        if self.tags != nil {
            map["Tags"] = self.tags!
        }
        if self.tenancy != nil {
            map["Tenancy"] = self.tenancy!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ImageOptions") && dict["ImageOptions"] != nil {
            var model = CreateScalingConfigurationRequest.ImageOptions()
            model.fromMap(dict["ImageOptions"] as! [String: Any])
            self.imageOptions = model
        }
        if dict.keys.contains("PrivatePoolOptions") && dict["PrivatePoolOptions"] != nil {
            var model = CreateScalingConfigurationRequest.PrivatePoolOptions()
            model.fromMap(dict["PrivatePoolOptions"] as! [String: Any])
            self.privatePoolOptions = model
        }
        if dict.keys.contains("SystemDisk") && dict["SystemDisk"] != nil {
            var model = CreateScalingConfigurationRequest.SystemDisk()
            model.fromMap(dict["SystemDisk"] as! [String: Any])
            self.systemDisk = model
        }
        if dict.keys.contains("Affinity") && dict["Affinity"] != nil {
            self.affinity = dict["Affinity"] as! String
        }
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Cpu") && dict["Cpu"] != nil {
            self.cpu = dict["Cpu"] as! Int32
        }
        if dict.keys.contains("CreditSpecification") && dict["CreditSpecification"] != nil {
            self.creditSpecification = dict["CreditSpecification"] as! String
        }
        if dict.keys.contains("CustomPriorities") && dict["CustomPriorities"] != nil {
            var tmp : [CreateScalingConfigurationRequest.CustomPriorities] = []
            for v in dict["CustomPriorities"] as! [Any] {
                var model = CreateScalingConfigurationRequest.CustomPriorities()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.customPriorities = tmp
        }
        if dict.keys.contains("DataDisks") && dict["DataDisks"] != nil {
            var tmp : [CreateScalingConfigurationRequest.DataDisks] = []
            for v in dict["DataDisks"] as! [Any] {
                var model = CreateScalingConfigurationRequest.DataDisks()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.dataDisks = tmp
        }
        if dict.keys.contains("DedicatedHostId") && dict["DedicatedHostId"] != nil {
            self.dedicatedHostId = dict["DedicatedHostId"] as! String
        }
        if dict.keys.contains("DeletionProtection") && dict["DeletionProtection"] != nil {
            self.deletionProtection = dict["DeletionProtection"] as! Bool
        }
        if dict.keys.contains("DeploymentSetId") && dict["DeploymentSetId"] != nil {
            self.deploymentSetId = dict["DeploymentSetId"] as! String
        }
        if dict.keys.contains("HostName") && dict["HostName"] != nil {
            self.hostName = dict["HostName"] as! String
        }
        if dict.keys.contains("HpcClusterId") && dict["HpcClusterId"] != nil {
            self.hpcClusterId = dict["HpcClusterId"] as! String
        }
        if dict.keys.contains("ImageFamily") && dict["ImageFamily"] != nil {
            self.imageFamily = dict["ImageFamily"] as! String
        }
        if dict.keys.contains("ImageId") && dict["ImageId"] != nil {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("ImageName") && dict["ImageName"] != nil {
            self.imageName = dict["ImageName"] as! String
        }
        if dict.keys.contains("InstanceDescription") && dict["InstanceDescription"] != nil {
            self.instanceDescription = dict["InstanceDescription"] as! String
        }
        if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
            self.instanceName = dict["InstanceName"] as! String
        }
        if dict.keys.contains("InstancePatternInfos") && dict["InstancePatternInfos"] != nil {
            var tmp : [CreateScalingConfigurationRequest.InstancePatternInfos] = []
            for v in dict["InstancePatternInfos"] as! [Any] {
                var model = CreateScalingConfigurationRequest.InstancePatternInfos()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.instancePatternInfos = tmp
        }
        if dict.keys.contains("InstanceType") && dict["InstanceType"] != nil {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("InstanceTypeOverrides") && dict["InstanceTypeOverrides"] != nil {
            var tmp : [CreateScalingConfigurationRequest.InstanceTypeOverrides] = []
            for v in dict["InstanceTypeOverrides"] as! [Any] {
                var model = CreateScalingConfigurationRequest.InstanceTypeOverrides()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.instanceTypeOverrides = tmp
        }
        if dict.keys.contains("InstanceTypes") && dict["InstanceTypes"] != nil {
            self.instanceTypes = dict["InstanceTypes"] as! [String]
        }
        if dict.keys.contains("InternetChargeType") && dict["InternetChargeType"] != nil {
            self.internetChargeType = dict["InternetChargeType"] as! String
        }
        if dict.keys.contains("InternetMaxBandwidthIn") && dict["InternetMaxBandwidthIn"] != nil {
            self.internetMaxBandwidthIn = dict["InternetMaxBandwidthIn"] as! Int32
        }
        if dict.keys.contains("InternetMaxBandwidthOut") && dict["InternetMaxBandwidthOut"] != nil {
            self.internetMaxBandwidthOut = dict["InternetMaxBandwidthOut"] as! Int32
        }
        if dict.keys.contains("IoOptimized") && dict["IoOptimized"] != nil {
            self.ioOptimized = dict["IoOptimized"] as! String
        }
        if dict.keys.contains("Ipv6AddressCount") && dict["Ipv6AddressCount"] != nil {
            self.ipv6AddressCount = dict["Ipv6AddressCount"] as! Int32
        }
        if dict.keys.contains("KeyPairName") && dict["KeyPairName"] != nil {
            self.keyPairName = dict["KeyPairName"] as! String
        }
        if dict.keys.contains("LoadBalancerWeight") && dict["LoadBalancerWeight"] != nil {
            self.loadBalancerWeight = dict["LoadBalancerWeight"] as! Int32
        }
        if dict.keys.contains("Memory") && dict["Memory"] != nil {
            self.memory = dict["Memory"] as! Int32
        }
        if dict.keys.contains("OwnerAccount") && dict["OwnerAccount"] != nil {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Password") && dict["Password"] != nil {
            self.password = dict["Password"] as! String
        }
        if dict.keys.contains("PasswordInherit") && dict["PasswordInherit"] != nil {
            self.passwordInherit = dict["PasswordInherit"] as! Bool
        }
        if dict.keys.contains("RamRoleName") && dict["RamRoleName"] != nil {
            self.ramRoleName = dict["RamRoleName"] as! String
        }
        if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScalingConfigurationName") && dict["ScalingConfigurationName"] != nil {
            self.scalingConfigurationName = dict["ScalingConfigurationName"] as! String
        }
        if dict.keys.contains("ScalingGroupId") && dict["ScalingGroupId"] != nil {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
        if dict.keys.contains("SchedulerOptions") && dict["SchedulerOptions"] != nil {
            self.schedulerOptions = dict["SchedulerOptions"] as! [String: Any]
        }
        if dict.keys.contains("SecurityEnhancementStrategy") && dict["SecurityEnhancementStrategy"] != nil {
            self.securityEnhancementStrategy = dict["SecurityEnhancementStrategy"] as! String
        }
        if dict.keys.contains("SecurityGroupId") && dict["SecurityGroupId"] != nil {
            self.securityGroupId = dict["SecurityGroupId"] as! String
        }
        if dict.keys.contains("SecurityGroupIds") && dict["SecurityGroupIds"] != nil {
            self.securityGroupIds = dict["SecurityGroupIds"] as! [String]
        }
        if dict.keys.contains("SpotDuration") && dict["SpotDuration"] != nil {
            self.spotDuration = dict["SpotDuration"] as! Int32
        }
        if dict.keys.contains("SpotInterruptionBehavior") && dict["SpotInterruptionBehavior"] != nil {
            self.spotInterruptionBehavior = dict["SpotInterruptionBehavior"] as! String
        }
        if dict.keys.contains("SpotPriceLimits") && dict["SpotPriceLimits"] != nil {
            var tmp : [CreateScalingConfigurationRequest.SpotPriceLimits] = []
            for v in dict["SpotPriceLimits"] as! [Any] {
                var model = CreateScalingConfigurationRequest.SpotPriceLimits()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.spotPriceLimits = tmp
        }
        if dict.keys.contains("SpotStrategy") && dict["SpotStrategy"] != nil {
            self.spotStrategy = dict["SpotStrategy"] as! String
        }
        if dict.keys.contains("StorageSetId") && dict["StorageSetId"] != nil {
            self.storageSetId = dict["StorageSetId"] as! String
        }
        if dict.keys.contains("StorageSetPartitionNumber") && dict["StorageSetPartitionNumber"] != nil {
            self.storageSetPartitionNumber = dict["StorageSetPartitionNumber"] as! Int32
        }
        if dict.keys.contains("SystemDiskCategories") && dict["SystemDiskCategories"] != nil {
            self.systemDiskCategories = dict["SystemDiskCategories"] as! [String]
        }
        if dict.keys.contains("Tags") && dict["Tags"] != nil {
            self.tags = dict["Tags"] as! String
        }
        if dict.keys.contains("Tenancy") && dict["Tenancy"] != nil {
            self.tenancy = dict["Tenancy"] as! String
        }
        if dict.keys.contains("UserData") && dict["UserData"] != nil {
            self.userData = dict["UserData"] as! String
        }
        if dict.keys.contains("ZoneId") && dict["ZoneId"] != nil {
            self.zoneId = dict["ZoneId"] as! String
        }
    }
}

public class CreateScalingConfigurationShrinkRequest : Tea.TeaModel {
    public class ImageOptions : Tea.TeaModel {
        public var loginAsNonRoot: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.loginAsNonRoot != nil {
                map["LoginAsNonRoot"] = self.loginAsNonRoot!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LoginAsNonRoot") && dict["LoginAsNonRoot"] != nil {
                self.loginAsNonRoot = dict["LoginAsNonRoot"] as! Bool
            }
        }
    }
    public class PrivatePoolOptions : Tea.TeaModel {
        public var id: String?

        public var matchCriteria: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.matchCriteria != nil {
                map["MatchCriteria"] = self.matchCriteria!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("MatchCriteria") && dict["MatchCriteria"] != nil {
                self.matchCriteria = dict["MatchCriteria"] as! String
            }
        }
    }
    public class SystemDisk : Tea.TeaModel {
        public var autoSnapshotPolicyId: String?

        public var burstingEnabled: Bool?

        public var category: String?

        public var description_: String?

        public var diskName: String?

        public var encryptAlgorithm: String?

        public var encrypted: Bool?

        public var KMSKeyId: String?

        public var performanceLevel: String?

        public var provisionedIops: Int64?

        public var size: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.autoSnapshotPolicyId != nil {
                map["AutoSnapshotPolicyId"] = self.autoSnapshotPolicyId!
            }
            if self.burstingEnabled != nil {
                map["BurstingEnabled"] = self.burstingEnabled!
            }
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.diskName != nil {
                map["DiskName"] = self.diskName!
            }
            if self.encryptAlgorithm != nil {
                map["EncryptAlgorithm"] = self.encryptAlgorithm!
            }
            if self.encrypted != nil {
                map["Encrypted"] = self.encrypted!
            }
            if self.KMSKeyId != nil {
                map["KMSKeyId"] = self.KMSKeyId!
            }
            if self.performanceLevel != nil {
                map["PerformanceLevel"] = self.performanceLevel!
            }
            if self.provisionedIops != nil {
                map["ProvisionedIops"] = self.provisionedIops!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AutoSnapshotPolicyId") && dict["AutoSnapshotPolicyId"] != nil {
                self.autoSnapshotPolicyId = dict["AutoSnapshotPolicyId"] as! String
            }
            if dict.keys.contains("BurstingEnabled") && dict["BurstingEnabled"] != nil {
                self.burstingEnabled = dict["BurstingEnabled"] as! Bool
            }
            if dict.keys.contains("Category") && dict["Category"] != nil {
                self.category = dict["Category"] as! String
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("DiskName") && dict["DiskName"] != nil {
                self.diskName = dict["DiskName"] as! String
            }
            if dict.keys.contains("EncryptAlgorithm") && dict["EncryptAlgorithm"] != nil {
                self.encryptAlgorithm = dict["EncryptAlgorithm"] as! String
            }
            if dict.keys.contains("Encrypted") && dict["Encrypted"] != nil {
                self.encrypted = dict["Encrypted"] as! Bool
            }
            if dict.keys.contains("KMSKeyId") && dict["KMSKeyId"] != nil {
                self.KMSKeyId = dict["KMSKeyId"] as! String
            }
            if dict.keys.contains("PerformanceLevel") && dict["PerformanceLevel"] != nil {
                self.performanceLevel = dict["PerformanceLevel"] as! String
            }
            if dict.keys.contains("ProvisionedIops") && dict["ProvisionedIops"] != nil {
                self.provisionedIops = dict["ProvisionedIops"] as! Int64
            }
            if dict.keys.contains("Size") && dict["Size"] != nil {
                self.size = dict["Size"] as! Int32
            }
        }
    }
    public class CustomPriorities : Tea.TeaModel {
        public var instanceType: String?

        public var vswitchId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.vswitchId != nil {
                map["VswitchId"] = self.vswitchId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceType") && dict["InstanceType"] != nil {
                self.instanceType = dict["InstanceType"] as! String
            }
            if dict.keys.contains("VswitchId") && dict["VswitchId"] != nil {
                self.vswitchId = dict["VswitchId"] as! String
            }
        }
    }
    public class DataDisks : Tea.TeaModel {
        public var autoSnapshotPolicyId: String?

        public var burstingEnabled: Bool?

        public var categories: [String]?

        public var category: String?

        public var deleteWithInstance: Bool?

        public var description_: String?

        public var device: String?

        public var diskName: String?

        public var encrypted: String?

        public var KMSKeyId: String?

        public var performanceLevel: String?

        public var provisionedIops: Int64?

        public var size: Int32?

        public var snapshotId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.autoSnapshotPolicyId != nil {
                map["AutoSnapshotPolicyId"] = self.autoSnapshotPolicyId!
            }
            if self.burstingEnabled != nil {
                map["BurstingEnabled"] = self.burstingEnabled!
            }
            if self.categories != nil {
                map["Categories"] = self.categories!
            }
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.deleteWithInstance != nil {
                map["DeleteWithInstance"] = self.deleteWithInstance!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.device != nil {
                map["Device"] = self.device!
            }
            if self.diskName != nil {
                map["DiskName"] = self.diskName!
            }
            if self.encrypted != nil {
                map["Encrypted"] = self.encrypted!
            }
            if self.KMSKeyId != nil {
                map["KMSKeyId"] = self.KMSKeyId!
            }
            if self.performanceLevel != nil {
                map["PerformanceLevel"] = self.performanceLevel!
            }
            if self.provisionedIops != nil {
                map["ProvisionedIops"] = self.provisionedIops!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.snapshotId != nil {
                map["SnapshotId"] = self.snapshotId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AutoSnapshotPolicyId") && dict["AutoSnapshotPolicyId"] != nil {
                self.autoSnapshotPolicyId = dict["AutoSnapshotPolicyId"] as! String
            }
            if dict.keys.contains("BurstingEnabled") && dict["BurstingEnabled"] != nil {
                self.burstingEnabled = dict["BurstingEnabled"] as! Bool
            }
            if dict.keys.contains("Categories") && dict["Categories"] != nil {
                self.categories = dict["Categories"] as! [String]
            }
            if dict.keys.contains("Category") && dict["Category"] != nil {
                self.category = dict["Category"] as! String
            }
            if dict.keys.contains("DeleteWithInstance") && dict["DeleteWithInstance"] != nil {
                self.deleteWithInstance = dict["DeleteWithInstance"] as! Bool
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Device") && dict["Device"] != nil {
                self.device = dict["Device"] as! String
            }
            if dict.keys.contains("DiskName") && dict["DiskName"] != nil {
                self.diskName = dict["DiskName"] as! String
            }
            if dict.keys.contains("Encrypted") && dict["Encrypted"] != nil {
                self.encrypted = dict["Encrypted"] as! String
            }
            if dict.keys.contains("KMSKeyId") && dict["KMSKeyId"] != nil {
                self.KMSKeyId = dict["KMSKeyId"] as! String
            }
            if dict.keys.contains("PerformanceLevel") && dict["PerformanceLevel"] != nil {
                self.performanceLevel = dict["PerformanceLevel"] as! String
            }
            if dict.keys.contains("ProvisionedIops") && dict["ProvisionedIops"] != nil {
                self.provisionedIops = dict["ProvisionedIops"] as! Int64
            }
            if dict.keys.contains("Size") && dict["Size"] != nil {
                self.size = dict["Size"] as! Int32
            }
            if dict.keys.contains("SnapshotId") && dict["SnapshotId"] != nil {
                self.snapshotId = dict["SnapshotId"] as! String
            }
        }
    }
    public class InstancePatternInfos : Tea.TeaModel {
        public var architectures: [String]?

        public var burstablePerformance: String?

        public var cores: Int32?

        public var excludedInstanceTypes: [String]?

        public var instanceFamilyLevel: String?

        public var maxPrice: Double?

        public var memory: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.architectures != nil {
                map["Architectures"] = self.architectures!
            }
            if self.burstablePerformance != nil {
                map["BurstablePerformance"] = self.burstablePerformance!
            }
            if self.cores != nil {
                map["Cores"] = self.cores!
            }
            if self.excludedInstanceTypes != nil {
                map["ExcludedInstanceTypes"] = self.excludedInstanceTypes!
            }
            if self.instanceFamilyLevel != nil {
                map["InstanceFamilyLevel"] = self.instanceFamilyLevel!
            }
            if self.maxPrice != nil {
                map["MaxPrice"] = self.maxPrice!
            }
            if self.memory != nil {
                map["Memory"] = self.memory!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Architectures") && dict["Architectures"] != nil {
                self.architectures = dict["Architectures"] as! [String]
            }
            if dict.keys.contains("BurstablePerformance") && dict["BurstablePerformance"] != nil {
                self.burstablePerformance = dict["BurstablePerformance"] as! String
            }
            if dict.keys.contains("Cores") && dict["Cores"] != nil {
                self.cores = dict["Cores"] as! Int32
            }
            if dict.keys.contains("ExcludedInstanceTypes") && dict["ExcludedInstanceTypes"] != nil {
                self.excludedInstanceTypes = dict["ExcludedInstanceTypes"] as! [String]
            }
            if dict.keys.contains("InstanceFamilyLevel") && dict["InstanceFamilyLevel"] != nil {
                self.instanceFamilyLevel = dict["InstanceFamilyLevel"] as! String
            }
            if dict.keys.contains("MaxPrice") && dict["MaxPrice"] != nil {
                self.maxPrice = dict["MaxPrice"] as! Double
            }
            if dict.keys.contains("Memory") && dict["Memory"] != nil {
                self.memory = dict["Memory"] as! Double
            }
        }
    }
    public class InstanceTypeOverrides : Tea.TeaModel {
        public var instanceType: String?

        public var weightedCapacity: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.weightedCapacity != nil {
                map["WeightedCapacity"] = self.weightedCapacity!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceType") && dict["InstanceType"] != nil {
                self.instanceType = dict["InstanceType"] as! String
            }
            if dict.keys.contains("WeightedCapacity") && dict["WeightedCapacity"] != nil {
                self.weightedCapacity = dict["WeightedCapacity"] as! Int32
            }
        }
    }
    public class SpotPriceLimits : Tea.TeaModel {
        public var instanceType: String?

        public var priceLimit: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.priceLimit != nil {
                map["PriceLimit"] = self.priceLimit!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceType") && dict["InstanceType"] != nil {
                self.instanceType = dict["InstanceType"] as! String
            }
            if dict.keys.contains("PriceLimit") && dict["PriceLimit"] != nil {
                self.priceLimit = dict["PriceLimit"] as! Double
            }
        }
    }
    public var imageOptions: CreateScalingConfigurationShrinkRequest.ImageOptions?

    public var privatePoolOptions: CreateScalingConfigurationShrinkRequest.PrivatePoolOptions?

    public var systemDisk: CreateScalingConfigurationShrinkRequest.SystemDisk?

    public var affinity: String?

    public var clientToken: String?

    public var cpu: Int32?

    public var creditSpecification: String?

    public var customPriorities: [CreateScalingConfigurationShrinkRequest.CustomPriorities]?

    public var dataDisks: [CreateScalingConfigurationShrinkRequest.DataDisks]?

    public var dedicatedHostId: String?

    public var deletionProtection: Bool?

    public var deploymentSetId: String?

    public var hostName: String?

    public var hpcClusterId: String?

    public var imageFamily: String?

    public var imageId: String?

    public var imageName: String?

    public var instanceDescription: String?

    public var instanceName: String?

    public var instancePatternInfos: [CreateScalingConfigurationShrinkRequest.InstancePatternInfos]?

    public var instanceType: String?

    public var instanceTypeOverrides: [CreateScalingConfigurationShrinkRequest.InstanceTypeOverrides]?

    public var instanceTypes: [String]?

    public var internetChargeType: String?

    public var internetMaxBandwidthIn: Int32?

    public var internetMaxBandwidthOut: Int32?

    public var ioOptimized: String?

    public var ipv6AddressCount: Int32?

    public var keyPairName: String?

    public var loadBalancerWeight: Int32?

    public var memory: Int32?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var password: String?

    public var passwordInherit: Bool?

    public var ramRoleName: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var scalingConfigurationName: String?

    public var scalingGroupId: String?

    public var schedulerOptionsShrink: String?

    public var securityEnhancementStrategy: String?

    public var securityGroupId: String?

    public var securityGroupIds: [String]?

    public var spotDuration: Int32?

    public var spotInterruptionBehavior: String?

    public var spotPriceLimits: [CreateScalingConfigurationShrinkRequest.SpotPriceLimits]?

    public var spotStrategy: String?

    public var storageSetId: String?

    public var storageSetPartitionNumber: Int32?

    public var systemDiskCategories: [String]?

    public var tags: String?

    public var tenancy: String?

    public var userData: String?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.imageOptions?.validate()
        try self.privatePoolOptions?.validate()
        try self.systemDisk?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imageOptions != nil {
            map["ImageOptions"] = self.imageOptions?.toMap()
        }
        if self.privatePoolOptions != nil {
            map["PrivatePoolOptions"] = self.privatePoolOptions?.toMap()
        }
        if self.systemDisk != nil {
            map["SystemDisk"] = self.systemDisk?.toMap()
        }
        if self.affinity != nil {
            map["Affinity"] = self.affinity!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.cpu != nil {
            map["Cpu"] = self.cpu!
        }
        if self.creditSpecification != nil {
            map["CreditSpecification"] = self.creditSpecification!
        }
        if self.customPriorities != nil {
            var tmp : [Any] = []
            for k in self.customPriorities! {
                tmp.append(k.toMap())
            }
            map["CustomPriorities"] = tmp
        }
        if self.dataDisks != nil {
            var tmp : [Any] = []
            for k in self.dataDisks! {
                tmp.append(k.toMap())
            }
            map["DataDisks"] = tmp
        }
        if self.dedicatedHostId != nil {
            map["DedicatedHostId"] = self.dedicatedHostId!
        }
        if self.deletionProtection != nil {
            map["DeletionProtection"] = self.deletionProtection!
        }
        if self.deploymentSetId != nil {
            map["DeploymentSetId"] = self.deploymentSetId!
        }
        if self.hostName != nil {
            map["HostName"] = self.hostName!
        }
        if self.hpcClusterId != nil {
            map["HpcClusterId"] = self.hpcClusterId!
        }
        if self.imageFamily != nil {
            map["ImageFamily"] = self.imageFamily!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.imageName != nil {
            map["ImageName"] = self.imageName!
        }
        if self.instanceDescription != nil {
            map["InstanceDescription"] = self.instanceDescription!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.instancePatternInfos != nil {
            var tmp : [Any] = []
            for k in self.instancePatternInfos! {
                tmp.append(k.toMap())
            }
            map["InstancePatternInfos"] = tmp
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.instanceTypeOverrides != nil {
            var tmp : [Any] = []
            for k in self.instanceTypeOverrides! {
                tmp.append(k.toMap())
            }
            map["InstanceTypeOverrides"] = tmp
        }
        if self.instanceTypes != nil {
            map["InstanceTypes"] = self.instanceTypes!
        }
        if self.internetChargeType != nil {
            map["InternetChargeType"] = self.internetChargeType!
        }
        if self.internetMaxBandwidthIn != nil {
            map["InternetMaxBandwidthIn"] = self.internetMaxBandwidthIn!
        }
        if self.internetMaxBandwidthOut != nil {
            map["InternetMaxBandwidthOut"] = self.internetMaxBandwidthOut!
        }
        if self.ioOptimized != nil {
            map["IoOptimized"] = self.ioOptimized!
        }
        if self.ipv6AddressCount != nil {
            map["Ipv6AddressCount"] = self.ipv6AddressCount!
        }
        if self.keyPairName != nil {
            map["KeyPairName"] = self.keyPairName!
        }
        if self.loadBalancerWeight != nil {
            map["LoadBalancerWeight"] = self.loadBalancerWeight!
        }
        if self.memory != nil {
            map["Memory"] = self.memory!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        if self.passwordInherit != nil {
            map["PasswordInherit"] = self.passwordInherit!
        }
        if self.ramRoleName != nil {
            map["RamRoleName"] = self.ramRoleName!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingConfigurationName != nil {
            map["ScalingConfigurationName"] = self.scalingConfigurationName!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        if self.schedulerOptionsShrink != nil {
            map["SchedulerOptions"] = self.schedulerOptionsShrink!
        }
        if self.securityEnhancementStrategy != nil {
            map["SecurityEnhancementStrategy"] = self.securityEnhancementStrategy!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.securityGroupIds != nil {
            map["SecurityGroupIds"] = self.securityGroupIds!
        }
        if self.spotDuration != nil {
            map["SpotDuration"] = self.spotDuration!
        }
        if self.spotInterruptionBehavior != nil {
            map["SpotInterruptionBehavior"] = self.spotInterruptionBehavior!
        }
        if self.spotPriceLimits != nil {
            var tmp : [Any] = []
            for k in self.spotPriceLimits! {
                tmp.append(k.toMap())
            }
            map["SpotPriceLimits"] = tmp
        }
        if self.spotStrategy != nil {
            map["SpotStrategy"] = self.spotStrategy!
        }
        if self.storageSetId != nil {
            map["StorageSetId"] = self.storageSetId!
        }
        if self.storageSetPartitionNumber != nil {
            map["StorageSetPartitionNumber"] = self.storageSetPartitionNumber!
        }
        if self.systemDiskCategories != nil {
            map["SystemDiskCategories"] = self.systemDiskCategories!
        }
        if self.tags != nil {
            map["Tags"] = self.tags!
        }
        if self.tenancy != nil {
            map["Tenancy"] = self.tenancy!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ImageOptions") && dict["ImageOptions"] != nil {
            var model = CreateScalingConfigurationShrinkRequest.ImageOptions()
            model.fromMap(dict["ImageOptions"] as! [String: Any])
            self.imageOptions = model
        }
        if dict.keys.contains("PrivatePoolOptions") && dict["PrivatePoolOptions"] != nil {
            var model = CreateScalingConfigurationShrinkRequest.PrivatePoolOptions()
            model.fromMap(dict["PrivatePoolOptions"] as! [String: Any])
            self.privatePoolOptions = model
        }
        if dict.keys.contains("SystemDisk") && dict["SystemDisk"] != nil {
            var model = CreateScalingConfigurationShrinkRequest.SystemDisk()
            model.fromMap(dict["SystemDisk"] as! [String: Any])
            self.systemDisk = model
        }
        if dict.keys.contains("Affinity") && dict["Affinity"] != nil {
            self.affinity = dict["Affinity"] as! String
        }
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Cpu") && dict["Cpu"] != nil {
            self.cpu = dict["Cpu"] as! Int32
        }
        if dict.keys.contains("CreditSpecification") && dict["CreditSpecification"] != nil {
            self.creditSpecification = dict["CreditSpecification"] as! String
        }
        if dict.keys.contains("CustomPriorities") && dict["CustomPriorities"] != nil {
            var tmp : [CreateScalingConfigurationShrinkRequest.CustomPriorities] = []
            for v in dict["CustomPriorities"] as! [Any] {
                var model = CreateScalingConfigurationShrinkRequest.CustomPriorities()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.customPriorities = tmp
        }
        if dict.keys.contains("DataDisks") && dict["DataDisks"] != nil {
            var tmp : [CreateScalingConfigurationShrinkRequest.DataDisks] = []
            for v in dict["DataDisks"] as! [Any] {
                var model = CreateScalingConfigurationShrinkRequest.DataDisks()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.dataDisks = tmp
        }
        if dict.keys.contains("DedicatedHostId") && dict["DedicatedHostId"] != nil {
            self.dedicatedHostId = dict["DedicatedHostId"] as! String
        }
        if dict.keys.contains("DeletionProtection") && dict["DeletionProtection"] != nil {
            self.deletionProtection = dict["DeletionProtection"] as! Bool
        }
        if dict.keys.contains("DeploymentSetId") && dict["DeploymentSetId"] != nil {
            self.deploymentSetId = dict["DeploymentSetId"] as! String
        }
        if dict.keys.contains("HostName") && dict["HostName"] != nil {
            self.hostName = dict["HostName"] as! String
        }
        if dict.keys.contains("HpcClusterId") && dict["HpcClusterId"] != nil {
            self.hpcClusterId = dict["HpcClusterId"] as! String
        }
        if dict.keys.contains("ImageFamily") && dict["ImageFamily"] != nil {
            self.imageFamily = dict["ImageFamily"] as! String
        }
        if dict.keys.contains("ImageId") && dict["ImageId"] != nil {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("ImageName") && dict["ImageName"] != nil {
            self.imageName = dict["ImageName"] as! String
        }
        if dict.keys.contains("InstanceDescription") && dict["InstanceDescription"] != nil {
            self.instanceDescription = dict["InstanceDescription"] as! String
        }
        if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
            self.instanceName = dict["InstanceName"] as! String
        }
        if dict.keys.contains("InstancePatternInfos") && dict["InstancePatternInfos"] != nil {
            var tmp : [CreateScalingConfigurationShrinkRequest.InstancePatternInfos] = []
            for v in dict["InstancePatternInfos"] as! [Any] {
                var model = CreateScalingConfigurationShrinkRequest.InstancePatternInfos()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.instancePatternInfos = tmp
        }
        if dict.keys.contains("InstanceType") && dict["InstanceType"] != nil {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("InstanceTypeOverrides") && dict["InstanceTypeOverrides"] != nil {
            var tmp : [CreateScalingConfigurationShrinkRequest.InstanceTypeOverrides] = []
            for v in dict["InstanceTypeOverrides"] as! [Any] {
                var model = CreateScalingConfigurationShrinkRequest.InstanceTypeOverrides()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.instanceTypeOverrides = tmp
        }
        if dict.keys.contains("InstanceTypes") && dict["InstanceTypes"] != nil {
            self.instanceTypes = dict["InstanceTypes"] as! [String]
        }
        if dict.keys.contains("InternetChargeType") && dict["InternetChargeType"] != nil {
            self.internetChargeType = dict["InternetChargeType"] as! String
        }
        if dict.keys.contains("InternetMaxBandwidthIn") && dict["InternetMaxBandwidthIn"] != nil {
            self.internetMaxBandwidthIn = dict["InternetMaxBandwidthIn"] as! Int32
        }
        if dict.keys.contains("InternetMaxBandwidthOut") && dict["InternetMaxBandwidthOut"] != nil {
            self.internetMaxBandwidthOut = dict["InternetMaxBandwidthOut"] as! Int32
        }
        if dict.keys.contains("IoOptimized") && dict["IoOptimized"] != nil {
            self.ioOptimized = dict["IoOptimized"] as! String
        }
        if dict.keys.contains("Ipv6AddressCount") && dict["Ipv6AddressCount"] != nil {
            self.ipv6AddressCount = dict["Ipv6AddressCount"] as! Int32
        }
        if dict.keys.contains("KeyPairName") && dict["KeyPairName"] != nil {
            self.keyPairName = dict["KeyPairName"] as! String
        }
        if dict.keys.contains("LoadBalancerWeight") && dict["LoadBalancerWeight"] != nil {
            self.loadBalancerWeight = dict["LoadBalancerWeight"] as! Int32
        }
        if dict.keys.contains("Memory") && dict["Memory"] != nil {
            self.memory = dict["Memory"] as! Int32
        }
        if dict.keys.contains("OwnerAccount") && dict["OwnerAccount"] != nil {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Password") && dict["Password"] != nil {
            self.password = dict["Password"] as! String
        }
        if dict.keys.contains("PasswordInherit") && dict["PasswordInherit"] != nil {
            self.passwordInherit = dict["PasswordInherit"] as! Bool
        }
        if dict.keys.contains("RamRoleName") && dict["RamRoleName"] != nil {
            self.ramRoleName = dict["RamRoleName"] as! String
        }
        if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScalingConfigurationName") && dict["ScalingConfigurationName"] != nil {
            self.scalingConfigurationName = dict["ScalingConfigurationName"] as! String
        }
        if dict.keys.contains("ScalingGroupId") && dict["ScalingGroupId"] != nil {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
        if dict.keys.contains("SchedulerOptions") && dict["SchedulerOptions"] != nil {
            self.schedulerOptionsShrink = dict["SchedulerOptions"] as! String
        }
        if dict.keys.contains("SecurityEnhancementStrategy") && dict["SecurityEnhancementStrategy"] != nil {
            self.securityEnhancementStrategy = dict["SecurityEnhancementStrategy"] as! String
        }
        if dict.keys.contains("SecurityGroupId") && dict["SecurityGroupId"] != nil {
            self.securityGroupId = dict["SecurityGroupId"] as! String
        }
        if dict.keys.contains("SecurityGroupIds") && dict["SecurityGroupIds"] != nil {
            self.securityGroupIds = dict["SecurityGroupIds"] as! [String]
        }
        if dict.keys.contains("SpotDuration") && dict["SpotDuration"] != nil {
            self.spotDuration = dict["SpotDuration"] as! Int32
        }
        if dict.keys.contains("SpotInterruptionBehavior") && dict["SpotInterruptionBehavior"] != nil {
            self.spotInterruptionBehavior = dict["SpotInterruptionBehavior"] as! String
        }
        if dict.keys.contains("SpotPriceLimits") && dict["SpotPriceLimits"] != nil {
            var tmp : [CreateScalingConfigurationShrinkRequest.SpotPriceLimits] = []
            for v in dict["SpotPriceLimits"] as! [Any] {
                var model = CreateScalingConfigurationShrinkRequest.SpotPriceLimits()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.spotPriceLimits = tmp
        }
        if dict.keys.contains("SpotStrategy") && dict["SpotStrategy"] != nil {
            self.spotStrategy = dict["SpotStrategy"] as! String
        }
        if dict.keys.contains("StorageSetId") && dict["StorageSetId"] != nil {
            self.storageSetId = dict["StorageSetId"] as! String
        }
        if dict.keys.contains("StorageSetPartitionNumber") && dict["StorageSetPartitionNumber"] != nil {
            self.storageSetPartitionNumber = dict["StorageSetPartitionNumber"] as! Int32
        }
        if dict.keys.contains("SystemDiskCategories") && dict["SystemDiskCategories"] != nil {
            self.systemDiskCategories = dict["SystemDiskCategories"] as! [String]
        }
        if dict.keys.contains("Tags") && dict["Tags"] != nil {
            self.tags = dict["Tags"] as! String
        }
        if dict.keys.contains("Tenancy") && dict["Tenancy"] != nil {
            self.tenancy = dict["Tenancy"] as! String
        }
        if dict.keys.contains("UserData") && dict["UserData"] != nil {
            self.userData = dict["UserData"] as! String
        }
        if dict.keys.contains("ZoneId") && dict["ZoneId"] != nil {
            self.zoneId = dict["ZoneId"] as! String
        }
    }
}

public class CreateScalingConfigurationResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var scalingConfigurationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingConfigurationId != nil {
            map["ScalingConfigurationId"] = self.scalingConfigurationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScalingConfigurationId") && dict["ScalingConfigurationId"] != nil {
            self.scalingConfigurationId = dict["ScalingConfigurationId"] as! String
        }
    }
}

public class CreateScalingConfigurationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateScalingConfigurationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateScalingConfigurationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateScalingGroupRequest : Tea.TeaModel {
    public class AlbServerGroups : Tea.TeaModel {
        public var albServerGroupId: String?

        public var port: Int32?

        public var weight: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.albServerGroupId != nil {
                map["AlbServerGroupId"] = self.albServerGroupId!
            }
            if self.port != nil {
                map["Port"] = self.port!
            }
            if self.weight != nil {
                map["Weight"] = self.weight!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AlbServerGroupId") && dict["AlbServerGroupId"] != nil {
                self.albServerGroupId = dict["AlbServerGroupId"] as! String
            }
            if dict.keys.contains("Port") && dict["Port"] != nil {
                self.port = dict["Port"] as! Int32
            }
            if dict.keys.contains("Weight") && dict["Weight"] != nil {
                self.weight = dict["Weight"] as! Int32
            }
        }
    }
    public class LaunchTemplateOverrides : Tea.TeaModel {
        public var instanceType: String?

        public var spotPriceLimit: Double?

        public var weightedCapacity: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.spotPriceLimit != nil {
                map["SpotPriceLimit"] = self.spotPriceLimit!
            }
            if self.weightedCapacity != nil {
                map["WeightedCapacity"] = self.weightedCapacity!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceType") && dict["InstanceType"] != nil {
                self.instanceType = dict["InstanceType"] as! String
            }
            if dict.keys.contains("SpotPriceLimit") && dict["SpotPriceLimit"] != nil {
                self.spotPriceLimit = dict["SpotPriceLimit"] as! Double
            }
            if dict.keys.contains("WeightedCapacity") && dict["WeightedCapacity"] != nil {
                self.weightedCapacity = dict["WeightedCapacity"] as! Int32
            }
        }
    }
    public class LifecycleHooks : Tea.TeaModel {
        public var defaultResult: String?

        public var heartbeatTimeout: Int32?

        public var lifecycleHookName: String?

        public var lifecycleTransition: String?

        public var notificationArn: String?

        public var notificationMetadata: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.defaultResult != nil {
                map["DefaultResult"] = self.defaultResult!
            }
            if self.heartbeatTimeout != nil {
                map["HeartbeatTimeout"] = self.heartbeatTimeout!
            }
            if self.lifecycleHookName != nil {
                map["LifecycleHookName"] = self.lifecycleHookName!
            }
            if self.lifecycleTransition != nil {
                map["LifecycleTransition"] = self.lifecycleTransition!
            }
            if self.notificationArn != nil {
                map["NotificationArn"] = self.notificationArn!
            }
            if self.notificationMetadata != nil {
                map["NotificationMetadata"] = self.notificationMetadata!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DefaultResult") && dict["DefaultResult"] != nil {
                self.defaultResult = dict["DefaultResult"] as! String
            }
            if dict.keys.contains("HeartbeatTimeout") && dict["HeartbeatTimeout"] != nil {
                self.heartbeatTimeout = dict["HeartbeatTimeout"] as! Int32
            }
            if dict.keys.contains("LifecycleHookName") && dict["LifecycleHookName"] != nil {
                self.lifecycleHookName = dict["LifecycleHookName"] as! String
            }
            if dict.keys.contains("LifecycleTransition") && dict["LifecycleTransition"] != nil {
                self.lifecycleTransition = dict["LifecycleTransition"] as! String
            }
            if dict.keys.contains("NotificationArn") && dict["NotificationArn"] != nil {
                self.notificationArn = dict["NotificationArn"] as! String
            }
            if dict.keys.contains("NotificationMetadata") && dict["NotificationMetadata"] != nil {
                self.notificationMetadata = dict["NotificationMetadata"] as! String
            }
        }
    }
    public class LoadBalancerConfigs : Tea.TeaModel {
        public var loadBalancerId: String?

        public var weight: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.loadBalancerId != nil {
                map["LoadBalancerId"] = self.loadBalancerId!
            }
            if self.weight != nil {
                map["Weight"] = self.weight!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LoadBalancerId") && dict["LoadBalancerId"] != nil {
                self.loadBalancerId = dict["LoadBalancerId"] as! String
            }
            if dict.keys.contains("Weight") && dict["Weight"] != nil {
                self.weight = dict["Weight"] as! Int32
            }
        }
    }
    public class ServerGroups : Tea.TeaModel {
        public var port: Int32?

        public var serverGroupId: String?

        public var type: String?

        public var weight: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.port != nil {
                map["Port"] = self.port!
            }
            if self.serverGroupId != nil {
                map["ServerGroupId"] = self.serverGroupId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.weight != nil {
                map["Weight"] = self.weight!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Port") && dict["Port"] != nil {
                self.port = dict["Port"] as! Int32
            }
            if dict.keys.contains("ServerGroupId") && dict["ServerGroupId"] != nil {
                self.serverGroupId = dict["ServerGroupId"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Weight") && dict["Weight"] != nil {
                self.weight = dict["Weight"] as! Int32
            }
        }
    }
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var propagate: Bool?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.propagate != nil {
                map["Propagate"] = self.propagate!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Propagate") && dict["Propagate"] != nil {
                self.propagate = dict["Propagate"] as! Bool
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public class VServerGroups : Tea.TeaModel {
        public class VServerGroupAttributes : Tea.TeaModel {
            public var port: Int32?

            public var VServerGroupId: String?

            public var weight: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.VServerGroupId != nil {
                    map["VServerGroupId"] = self.VServerGroupId!
                }
                if self.weight != nil {
                    map["Weight"] = self.weight!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Port") && dict["Port"] != nil {
                    self.port = dict["Port"] as! Int32
                }
                if dict.keys.contains("VServerGroupId") && dict["VServerGroupId"] != nil {
                    self.VServerGroupId = dict["VServerGroupId"] as! String
                }
                if dict.keys.contains("Weight") && dict["Weight"] != nil {
                    self.weight = dict["Weight"] as! Int32
                }
            }
        }
        public var loadBalancerId: String?

        public var VServerGroupAttributes: [CreateScalingGroupRequest.VServerGroups.VServerGroupAttributes]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.loadBalancerId != nil {
                map["LoadBalancerId"] = self.loadBalancerId!
            }
            if self.VServerGroupAttributes != nil {
                var tmp : [Any] = []
                for k in self.VServerGroupAttributes! {
                    tmp.append(k.toMap())
                }
                map["VServerGroupAttributes"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LoadBalancerId") && dict["LoadBalancerId"] != nil {
                self.loadBalancerId = dict["LoadBalancerId"] as! String
            }
            if dict.keys.contains("VServerGroupAttributes") && dict["VServerGroupAttributes"] != nil {
                var tmp : [CreateScalingGroupRequest.VServerGroups.VServerGroupAttributes] = []
                for v in dict["VServerGroupAttributes"] as! [Any] {
                    var model = CreateScalingGroupRequest.VServerGroups.VServerGroupAttributes()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.VServerGroupAttributes = tmp
            }
        }
    }
    public var albServerGroups: [CreateScalingGroupRequest.AlbServerGroups]?

    public var allocationStrategy: String?

    public var azBalance: Bool?

    public var clientToken: String?

    public var compensateWithOnDemand: Bool?

    public var containerGroupId: String?

    public var customPolicyARN: String?

    public var DBInstanceIds: String?

    public var defaultCooldown: Int32?

    public var desiredCapacity: Int32?

    public var groupDeletionProtection: Bool?

    public var groupType: String?

    public var healthCheckType: String?

    public var healthCheckTypes: [String]?

    public var instanceId: String?

    public var launchTemplateId: String?

    public var launchTemplateOverrides: [CreateScalingGroupRequest.LaunchTemplateOverrides]?

    public var launchTemplateVersion: String?

    public var lifecycleHooks: [CreateScalingGroupRequest.LifecycleHooks]?

    public var loadBalancerConfigs: [CreateScalingGroupRequest.LoadBalancerConfigs]?

    public var loadBalancerIds: String?

    public var maxInstanceLifetime: Int32?

    public var maxSize: Int32?

    public var minSize: Int32?

    public var multiAZPolicy: String?

    public var onDemandBaseCapacity: Int32?

    public var onDemandPercentageAboveBaseCapacity: Int32?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var removalPolicies: [String]?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var scalingGroupName: String?

    public var scalingPolicy: String?

    public var serverGroups: [CreateScalingGroupRequest.ServerGroups]?

    public var spotAllocationStrategy: String?

    public var spotInstancePools: Int32?

    public var spotInstanceRemedy: Bool?

    public var syncAlarmRuleToCms: Bool?

    public var tags: [CreateScalingGroupRequest.Tags]?

    public var VServerGroups: [CreateScalingGroupRequest.VServerGroups]?

    public var vSwitchId: String?

    public var vSwitchIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.albServerGroups != nil {
            var tmp : [Any] = []
            for k in self.albServerGroups! {
                tmp.append(k.toMap())
            }
            map["AlbServerGroups"] = tmp
        }
        if self.allocationStrategy != nil {
            map["AllocationStrategy"] = self.allocationStrategy!
        }
        if self.azBalance != nil {
            map["AzBalance"] = self.azBalance!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.compensateWithOnDemand != nil {
            map["CompensateWithOnDemand"] = self.compensateWithOnDemand!
        }
        if self.containerGroupId != nil {
            map["ContainerGroupId"] = self.containerGroupId!
        }
        if self.customPolicyARN != nil {
            map["CustomPolicyARN"] = self.customPolicyARN!
        }
        if self.DBInstanceIds != nil {
            map["DBInstanceIds"] = self.DBInstanceIds!
        }
        if self.defaultCooldown != nil {
            map["DefaultCooldown"] = self.defaultCooldown!
        }
        if self.desiredCapacity != nil {
            map["DesiredCapacity"] = self.desiredCapacity!
        }
        if self.groupDeletionProtection != nil {
            map["GroupDeletionProtection"] = self.groupDeletionProtection!
        }
        if self.groupType != nil {
            map["GroupType"] = self.groupType!
        }
        if self.healthCheckType != nil {
            map["HealthCheckType"] = self.healthCheckType!
        }
        if self.healthCheckTypes != nil {
            map["HealthCheckTypes"] = self.healthCheckTypes!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.launchTemplateId != nil {
            map["LaunchTemplateId"] = self.launchTemplateId!
        }
        if self.launchTemplateOverrides != nil {
            var tmp : [Any] = []
            for k in self.launchTemplateOverrides! {
                tmp.append(k.toMap())
            }
            map["LaunchTemplateOverrides"] = tmp
        }
        if self.launchTemplateVersion != nil {
            map["LaunchTemplateVersion"] = self.launchTemplateVersion!
        }
        if self.lifecycleHooks != nil {
            var tmp : [Any] = []
            for k in self.lifecycleHooks! {
                tmp.append(k.toMap())
            }
            map["LifecycleHooks"] = tmp
        }
        if self.loadBalancerConfigs != nil {
            var tmp : [Any] = []
            for k in self.loadBalancerConfigs! {
                tmp.append(k.toMap())
            }
            map["LoadBalancerConfigs"] = tmp
        }
        if self.loadBalancerIds != nil {
            map["LoadBalancerIds"] = self.loadBalancerIds!
        }
        if self.maxInstanceLifetime != nil {
            map["MaxInstanceLifetime"] = self.maxInstanceLifetime!
        }
        if self.maxSize != nil {
            map["MaxSize"] = self.maxSize!
        }
        if self.minSize != nil {
            map["MinSize"] = self.minSize!
        }
        if self.multiAZPolicy != nil {
            map["MultiAZPolicy"] = self.multiAZPolicy!
        }
        if self.onDemandBaseCapacity != nil {
            map["OnDemandBaseCapacity"] = self.onDemandBaseCapacity!
        }
        if self.onDemandPercentageAboveBaseCapacity != nil {
            map["OnDemandPercentageAboveBaseCapacity"] = self.onDemandPercentageAboveBaseCapacity!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.removalPolicies != nil {
            map["RemovalPolicies"] = self.removalPolicies!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupName != nil {
            map["ScalingGroupName"] = self.scalingGroupName!
        }
        if self.scalingPolicy != nil {
            map["ScalingPolicy"] = self.scalingPolicy!
        }
        if self.serverGroups != nil {
            var tmp : [Any] = []
            for k in self.serverGroups! {
                tmp.append(k.toMap())
            }
            map["ServerGroups"] = tmp
        }
        if self.spotAllocationStrategy != nil {
            map["SpotAllocationStrategy"] = self.spotAllocationStrategy!
        }
        if self.spotInstancePools != nil {
            map["SpotInstancePools"] = self.spotInstancePools!
        }
        if self.spotInstanceRemedy != nil {
            map["SpotInstanceRemedy"] = self.spotInstanceRemedy!
        }
        if self.syncAlarmRuleToCms != nil {
            map["SyncAlarmRuleToCms"] = self.syncAlarmRuleToCms!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        if self.VServerGroups != nil {
            var tmp : [Any] = []
            for k in self.VServerGroups! {
                tmp.append(k.toMap())
            }
            map["VServerGroups"] = tmp
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.vSwitchIds != nil {
            map["VSwitchIds"] = self.vSwitchIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlbServerGroups") && dict["AlbServerGroups"] != nil {
            var tmp : [CreateScalingGroupRequest.AlbServerGroups] = []
            for v in dict["AlbServerGroups"] as! [Any] {
                var model = CreateScalingGroupRequest.AlbServerGroups()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.albServerGroups = tmp
        }
        if dict.keys.contains("AllocationStrategy") && dict["AllocationStrategy"] != nil {
            self.allocationStrategy = dict["AllocationStrategy"] as! String
        }
        if dict.keys.contains("AzBalance") && dict["AzBalance"] != nil {
            self.azBalance = dict["AzBalance"] as! Bool
        }
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("CompensateWithOnDemand") && dict["CompensateWithOnDemand"] != nil {
            self.compensateWithOnDemand = dict["CompensateWithOnDemand"] as! Bool
        }
        if dict.keys.contains("ContainerGroupId") && dict["ContainerGroupId"] != nil {
            self.containerGroupId = dict["ContainerGroupId"] as! String
        }
        if dict.keys.contains("CustomPolicyARN") && dict["CustomPolicyARN"] != nil {
            self.customPolicyARN = dict["CustomPolicyARN"] as! String
        }
        if dict.keys.contains("DBInstanceIds") && dict["DBInstanceIds"] != nil {
            self.DBInstanceIds = dict["DBInstanceIds"] as! String
        }
        if dict.keys.contains("DefaultCooldown") && dict["DefaultCooldown"] != nil {
            self.defaultCooldown = dict["DefaultCooldown"] as! Int32
        }
        if dict.keys.contains("DesiredCapacity") && dict["DesiredCapacity"] != nil {
            self.desiredCapacity = dict["DesiredCapacity"] as! Int32
        }
        if dict.keys.contains("GroupDeletionProtection") && dict["GroupDeletionProtection"] != nil {
            self.groupDeletionProtection = dict["GroupDeletionProtection"] as! Bool
        }
        if dict.keys.contains("GroupType") && dict["GroupType"] != nil {
            self.groupType = dict["GroupType"] as! String
        }
        if dict.keys.contains("HealthCheckType") && dict["HealthCheckType"] != nil {
            self.healthCheckType = dict["HealthCheckType"] as! String
        }
        if dict.keys.contains("HealthCheckTypes") && dict["HealthCheckTypes"] != nil {
            self.healthCheckTypes = dict["HealthCheckTypes"] as! [String]
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("LaunchTemplateId") && dict["LaunchTemplateId"] != nil {
            self.launchTemplateId = dict["LaunchTemplateId"] as! String
        }
        if dict.keys.contains("LaunchTemplateOverrides") && dict["LaunchTemplateOverrides"] != nil {
            var tmp : [CreateScalingGroupRequest.LaunchTemplateOverrides] = []
            for v in dict["LaunchTemplateOverrides"] as! [Any] {
                var model = CreateScalingGroupRequest.LaunchTemplateOverrides()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.launchTemplateOverrides = tmp
        }
        if dict.keys.contains("LaunchTemplateVersion") && dict["LaunchTemplateVersion"] != nil {
            self.launchTemplateVersion = dict["LaunchTemplateVersion"] as! String
        }
        if dict.keys.contains("LifecycleHooks") && dict["LifecycleHooks"] != nil {
            var tmp : [CreateScalingGroupRequest.LifecycleHooks] = []
            for v in dict["LifecycleHooks"] as! [Any] {
                var model = CreateScalingGroupRequest.LifecycleHooks()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.lifecycleHooks = tmp
        }
        if dict.keys.contains("LoadBalancerConfigs") && dict["LoadBalancerConfigs"] != nil {
            var tmp : [CreateScalingGroupRequest.LoadBalancerConfigs] = []
            for v in dict["LoadBalancerConfigs"] as! [Any] {
                var model = CreateScalingGroupRequest.LoadBalancerConfigs()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.loadBalancerConfigs = tmp
        }
        if dict.keys.contains("LoadBalancerIds") && dict["LoadBalancerIds"] != nil {
            self.loadBalancerIds = dict["LoadBalancerIds"] as! String
        }
        if dict.keys.contains("MaxInstanceLifetime") && dict["MaxInstanceLifetime"] != nil {
            self.maxInstanceLifetime = dict["MaxInstanceLifetime"] as! Int32
        }
        if dict.keys.contains("MaxSize") && dict["MaxSize"] != nil {
            self.maxSize = dict["MaxSize"] as! Int32
        }
        if dict.keys.contains("MinSize") && dict["MinSize"] != nil {
            self.minSize = dict["MinSize"] as! Int32
        }
        if dict.keys.contains("MultiAZPolicy") && dict["MultiAZPolicy"] != nil {
            self.multiAZPolicy = dict["MultiAZPolicy"] as! String
        }
        if dict.keys.contains("OnDemandBaseCapacity") && dict["OnDemandBaseCapacity"] != nil {
            self.onDemandBaseCapacity = dict["OnDemandBaseCapacity"] as! Int32
        }
        if dict.keys.contains("OnDemandPercentageAboveBaseCapacity") && dict["OnDemandPercentageAboveBaseCapacity"] != nil {
            self.onDemandPercentageAboveBaseCapacity = dict["OnDemandPercentageAboveBaseCapacity"] as! Int32
        }
        if dict.keys.contains("OwnerAccount") && dict["OwnerAccount"] != nil {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RemovalPolicies") && dict["RemovalPolicies"] != nil {
            self.removalPolicies = dict["RemovalPolicies"] as! [String]
        }
        if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScalingGroupName") && dict["ScalingGroupName"] != nil {
            self.scalingGroupName = dict["ScalingGroupName"] as! String
        }
        if dict.keys.contains("ScalingPolicy") && dict["ScalingPolicy"] != nil {
            self.scalingPolicy = dict["ScalingPolicy"] as! String
        }
        if dict.keys.contains("ServerGroups") && dict["ServerGroups"] != nil {
            var tmp : [CreateScalingGroupRequest.ServerGroups] = []
            for v in dict["ServerGroups"] as! [Any] {
                var model = CreateScalingGroupRequest.ServerGroups()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.serverGroups = tmp
        }
        if dict.keys.contains("SpotAllocationStrategy") && dict["SpotAllocationStrategy"] != nil {
            self.spotAllocationStrategy = dict["SpotAllocationStrategy"] as! String
        }
        if dict.keys.contains("SpotInstancePools") && dict["SpotInstancePools"] != nil {
            self.spotInstancePools = dict["SpotInstancePools"] as! Int32
        }
        if dict.keys.contains("SpotInstanceRemedy") && dict["SpotInstanceRemedy"] != nil {
            self.spotInstanceRemedy = dict["SpotInstanceRemedy"] as! Bool
        }
        if dict.keys.contains("SyncAlarmRuleToCms") && dict["SyncAlarmRuleToCms"] != nil {
            self.syncAlarmRuleToCms = dict["SyncAlarmRuleToCms"] as! Bool
        }
        if dict.keys.contains("Tags") && dict["Tags"] != nil {
            var tmp : [CreateScalingGroupRequest.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = CreateScalingGroupRequest.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
        if dict.keys.contains("VServerGroups") && dict["VServerGroups"] != nil {
            var tmp : [CreateScalingGroupRequest.VServerGroups] = []
            for v in dict["VServerGroups"] as! [Any] {
                var model = CreateScalingGroupRequest.VServerGroups()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.VServerGroups = tmp
        }
        if dict.keys.contains("VSwitchId") && dict["VSwitchId"] != nil {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
        if dict.keys.contains("VSwitchIds") && dict["VSwitchIds"] != nil {
            self.vSwitchIds = dict["VSwitchIds"] as! [String]
        }
    }
}

public class CreateScalingGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScalingGroupId") && dict["ScalingGroupId"] != nil {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
    }
}

public class CreateScalingGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateScalingGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateScalingGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateScalingRuleRequest : Tea.TeaModel {
    public class AlarmDimensions : Tea.TeaModel {
        public var dimensionKey: String?

        public var dimensionValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dimensionKey != nil {
                map["DimensionKey"] = self.dimensionKey!
            }
            if self.dimensionValue != nil {
                map["DimensionValue"] = self.dimensionValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DimensionKey") && dict["DimensionKey"] != nil {
                self.dimensionKey = dict["DimensionKey"] as! String
            }
            if dict.keys.contains("DimensionValue") && dict["DimensionValue"] != nil {
                self.dimensionValue = dict["DimensionValue"] as! String
            }
        }
    }
    public class StepAdjustments : Tea.TeaModel {
        public var metricIntervalLowerBound: Double?

        public var metricIntervalUpperBound: Double?

        public var scalingAdjustment: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.metricIntervalLowerBound != nil {
                map["MetricIntervalLowerBound"] = self.metricIntervalLowerBound!
            }
            if self.metricIntervalUpperBound != nil {
                map["MetricIntervalUpperBound"] = self.metricIntervalUpperBound!
            }
            if self.scalingAdjustment != nil {
                map["ScalingAdjustment"] = self.scalingAdjustment!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MetricIntervalLowerBound") && dict["MetricIntervalLowerBound"] != nil {
                self.metricIntervalLowerBound = dict["MetricIntervalLowerBound"] as! Double
            }
            if dict.keys.contains("MetricIntervalUpperBound") && dict["MetricIntervalUpperBound"] != nil {
                self.metricIntervalUpperBound = dict["MetricIntervalUpperBound"] as! Double
            }
            if dict.keys.contains("ScalingAdjustment") && dict["ScalingAdjustment"] != nil {
                self.scalingAdjustment = dict["ScalingAdjustment"] as! Int32
            }
        }
    }
    public var adjustmentType: String?

    public var adjustmentValue: Int32?

    public var alarmDimensions: [CreateScalingRuleRequest.AlarmDimensions]?

    public var cooldown: Int32?

    public var disableScaleIn: Bool?

    public var estimatedInstanceWarmup: Int32?

    public var initialMaxSize: Int32?

    public var metricName: String?

    public var minAdjustmentMagnitude: Int32?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var predictiveScalingMode: String?

    public var predictiveTaskBufferTime: Int32?

    public var predictiveValueBehavior: String?

    public var predictiveValueBuffer: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scaleInEvaluationCount: Int32?

    public var scaleOutEvaluationCount: Int32?

    public var scalingGroupId: String?

    public var scalingRuleName: String?

    public var scalingRuleType: String?

    public var stepAdjustments: [CreateScalingRuleRequest.StepAdjustments]?

    public var targetValue: Double?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.adjustmentType != nil {
            map["AdjustmentType"] = self.adjustmentType!
        }
        if self.adjustmentValue != nil {
            map["AdjustmentValue"] = self.adjustmentValue!
        }
        if self.alarmDimensions != nil {
            var tmp : [Any] = []
            for k in self.alarmDimensions! {
                tmp.append(k.toMap())
            }
            map["AlarmDimensions"] = tmp
        }
        if self.cooldown != nil {
            map["Cooldown"] = self.cooldown!
        }
        if self.disableScaleIn != nil {
            map["DisableScaleIn"] = self.disableScaleIn!
        }
        if self.estimatedInstanceWarmup != nil {
            map["EstimatedInstanceWarmup"] = self.estimatedInstanceWarmup!
        }
        if self.initialMaxSize != nil {
            map["InitialMaxSize"] = self.initialMaxSize!
        }
        if self.metricName != nil {
            map["MetricName"] = self.metricName!
        }
        if self.minAdjustmentMagnitude != nil {
            map["MinAdjustmentMagnitude"] = self.minAdjustmentMagnitude!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.predictiveScalingMode != nil {
            map["PredictiveScalingMode"] = self.predictiveScalingMode!
        }
        if self.predictiveTaskBufferTime != nil {
            map["PredictiveTaskBufferTime"] = self.predictiveTaskBufferTime!
        }
        if self.predictiveValueBehavior != nil {
            map["PredictiveValueBehavior"] = self.predictiveValueBehavior!
        }
        if self.predictiveValueBuffer != nil {
            map["PredictiveValueBuffer"] = self.predictiveValueBuffer!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scaleInEvaluationCount != nil {
            map["ScaleInEvaluationCount"] = self.scaleInEvaluationCount!
        }
        if self.scaleOutEvaluationCount != nil {
            map["ScaleOutEvaluationCount"] = self.scaleOutEvaluationCount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        if self.scalingRuleName != nil {
            map["ScalingRuleName"] = self.scalingRuleName!
        }
        if self.scalingRuleType != nil {
            map["ScalingRuleType"] = self.scalingRuleType!
        }
        if self.stepAdjustments != nil {
            var tmp : [Any] = []
            for k in self.stepAdjustments! {
                tmp.append(k.toMap())
            }
            map["StepAdjustments"] = tmp
        }
        if self.targetValue != nil {
            map["TargetValue"] = self.targetValue!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AdjustmentType") && dict["AdjustmentType"] != nil {
            self.adjustmentType = dict["AdjustmentType"] as! String
        }
        if dict.keys.contains("AdjustmentValue") && dict["AdjustmentValue"] != nil {
            self.adjustmentValue = dict["AdjustmentValue"] as! Int32
        }
        if dict.keys.contains("AlarmDimensions") && dict["AlarmDimensions"] != nil {
            var tmp : [CreateScalingRuleRequest.AlarmDimensions] = []
            for v in dict["AlarmDimensions"] as! [Any] {
                var model = CreateScalingRuleRequest.AlarmDimensions()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.alarmDimensions = tmp
        }
        if dict.keys.contains("Cooldown") && dict["Cooldown"] != nil {
            self.cooldown = dict["Cooldown"] as! Int32
        }
        if dict.keys.contains("DisableScaleIn") && dict["DisableScaleIn"] != nil {
            self.disableScaleIn = dict["DisableScaleIn"] as! Bool
        }
        if dict.keys.contains("EstimatedInstanceWarmup") && dict["EstimatedInstanceWarmup"] != nil {
            self.estimatedInstanceWarmup = dict["EstimatedInstanceWarmup"] as! Int32
        }
        if dict.keys.contains("InitialMaxSize") && dict["InitialMaxSize"] != nil {
            self.initialMaxSize = dict["InitialMaxSize"] as! Int32
        }
        if dict.keys.contains("MetricName") && dict["MetricName"] != nil {
            self.metricName = dict["MetricName"] as! String
        }
        if dict.keys.contains("MinAdjustmentMagnitude") && dict["MinAdjustmentMagnitude"] != nil {
            self.minAdjustmentMagnitude = dict["MinAdjustmentMagnitude"] as! Int32
        }
        if dict.keys.contains("OwnerAccount") && dict["OwnerAccount"] != nil {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PredictiveScalingMode") && dict["PredictiveScalingMode"] != nil {
            self.predictiveScalingMode = dict["PredictiveScalingMode"] as! String
        }
        if dict.keys.contains("PredictiveTaskBufferTime") && dict["PredictiveTaskBufferTime"] != nil {
            self.predictiveTaskBufferTime = dict["PredictiveTaskBufferTime"] as! Int32
        }
        if dict.keys.contains("PredictiveValueBehavior") && dict["PredictiveValueBehavior"] != nil {
            self.predictiveValueBehavior = dict["PredictiveValueBehavior"] as! String
        }
        if dict.keys.contains("PredictiveValueBuffer") && dict["PredictiveValueBuffer"] != nil {
            self.predictiveValueBuffer = dict["PredictiveValueBuffer"] as! Int32
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScaleInEvaluationCount") && dict["ScaleInEvaluationCount"] != nil {
            self.scaleInEvaluationCount = dict["ScaleInEvaluationCount"] as! Int32
        }
        if dict.keys.contains("ScaleOutEvaluationCount") && dict["ScaleOutEvaluationCount"] != nil {
            self.scaleOutEvaluationCount = dict["ScaleOutEvaluationCount"] as! Int32
        }
        if dict.keys.contains("ScalingGroupId") && dict["ScalingGroupId"] != nil {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
        if dict.keys.contains("ScalingRuleName") && dict["ScalingRuleName"] != nil {
            self.scalingRuleName = dict["ScalingRuleName"] as! String
        }
        if dict.keys.contains("ScalingRuleType") && dict["ScalingRuleType"] != nil {
            self.scalingRuleType = dict["ScalingRuleType"] as! String
        }
        if dict.keys.contains("StepAdjustments") && dict["StepAdjustments"] != nil {
            var tmp : [CreateScalingRuleRequest.StepAdjustments] = []
            for v in dict["StepAdjustments"] as! [Any] {
                var model = CreateScalingRuleRequest.StepAdjustments()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.stepAdjustments = tmp
        }
        if dict.keys.contains("TargetValue") && dict["TargetValue"] != nil {
            self.targetValue = dict["TargetValue"] as! Double
        }
    }
}

public class CreateScalingRuleResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var scalingRuleAri: String?

    public var scalingRuleId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingRuleAri != nil {
            map["ScalingRuleAri"] = self.scalingRuleAri!
        }
        if self.scalingRuleId != nil {
            map["ScalingRuleId"] = self.scalingRuleId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScalingRuleAri") && dict["ScalingRuleAri"] != nil {
            self.scalingRuleAri = dict["ScalingRuleAri"] as! String
        }
        if dict.keys.contains("ScalingRuleId") && dict["ScalingRuleId"] != nil {
            self.scalingRuleId = dict["ScalingRuleId"] as! String
        }
    }
}

public class CreateScalingRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateScalingRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateScalingRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateScheduledTaskRequest : Tea.TeaModel {
    public var description_: String?

    public var desiredCapacity: Int32?

    public var launchExpirationTime: Int32?

    public var launchTime: String?

    public var maxValue: Int32?

    public var minValue: Int32?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var recurrenceEndTime: String?

    public var recurrenceType: String?

    public var recurrenceValue: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public var scheduledAction: String?

    public var scheduledTaskName: String?

    public var taskEnabled: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.desiredCapacity != nil {
            map["DesiredCapacity"] = self.desiredCapacity!
        }
        if self.launchExpirationTime != nil {
            map["LaunchExpirationTime"] = self.launchExpirationTime!
        }
        if self.launchTime != nil {
            map["LaunchTime"] = self.launchTime!
        }
        if self.maxValue != nil {
            map["MaxValue"] = self.maxValue!
        }
        if self.minValue != nil {
            map["MinValue"] = self.minValue!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.recurrenceEndTime != nil {
            map["RecurrenceEndTime"] = self.recurrenceEndTime!
        }
        if self.recurrenceType != nil {
            map["RecurrenceType"] = self.recurrenceType!
        }
        if self.recurrenceValue != nil {
            map["RecurrenceValue"] = self.recurrenceValue!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        if self.scheduledAction != nil {
            map["ScheduledAction"] = self.scheduledAction!
        }
        if self.scheduledTaskName != nil {
            map["ScheduledTaskName"] = self.scheduledTaskName!
        }
        if self.taskEnabled != nil {
            map["TaskEnabled"] = self.taskEnabled!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DesiredCapacity") && dict["DesiredCapacity"] != nil {
            self.desiredCapacity = dict["DesiredCapacity"] as! Int32
        }
        if dict.keys.contains("LaunchExpirationTime") && dict["LaunchExpirationTime"] != nil {
            self.launchExpirationTime = dict["LaunchExpirationTime"] as! Int32
        }
        if dict.keys.contains("LaunchTime") && dict["LaunchTime"] != nil {
            self.launchTime = dict["LaunchTime"] as! String
        }
        if dict.keys.contains("MaxValue") && dict["MaxValue"] != nil {
            self.maxValue = dict["MaxValue"] as! Int32
        }
        if dict.keys.contains("MinValue") && dict["MinValue"] != nil {
            self.minValue = dict["MinValue"] as! Int32
        }
        if dict.keys.contains("OwnerAccount") && dict["OwnerAccount"] != nil {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RecurrenceEndTime") && dict["RecurrenceEndTime"] != nil {
            self.recurrenceEndTime = dict["RecurrenceEndTime"] as! String
        }
        if dict.keys.contains("RecurrenceType") && dict["RecurrenceType"] != nil {
            self.recurrenceType = dict["RecurrenceType"] as! String
        }
        if dict.keys.contains("RecurrenceValue") && dict["RecurrenceValue"] != nil {
            self.recurrenceValue = dict["RecurrenceValue"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScalingGroupId") && dict["ScalingGroupId"] != nil {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
        if dict.keys.contains("ScheduledAction") && dict["ScheduledAction"] != nil {
            self.scheduledAction = dict["ScheduledAction"] as! String
        }
        if dict.keys.contains("ScheduledTaskName") && dict["ScheduledTaskName"] != nil {
            self.scheduledTaskName = dict["ScheduledTaskName"] as! String
        }
        if dict.keys.contains("TaskEnabled") && dict["TaskEnabled"] != nil {
            self.taskEnabled = dict["TaskEnabled"] as! Bool
        }
    }
}

public class CreateScheduledTaskResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var scheduledTaskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scheduledTaskId != nil {
            map["ScheduledTaskId"] = self.scheduledTaskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScheduledTaskId") && dict["ScheduledTaskId"] != nil {
            self.scheduledTaskId = dict["ScheduledTaskId"] as! String
        }
    }
}

public class CreateScheduledTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateScheduledTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateScheduledTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeactivateScalingConfigurationRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var scalingConfigurationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingConfigurationId != nil {
            map["ScalingConfigurationId"] = self.scalingConfigurationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") && dict["OwnerAccount"] != nil {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScalingConfigurationId") && dict["ScalingConfigurationId"] != nil {
            self.scalingConfigurationId = dict["ScalingConfigurationId"] as! String
        }
    }
}

public class DeactivateScalingConfigurationResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeactivateScalingConfigurationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeactivateScalingConfigurationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeactivateScalingConfigurationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteAlarmRequest : Tea.TeaModel {
    public var alarmTaskId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alarmTaskId != nil {
            map["AlarmTaskId"] = self.alarmTaskId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlarmTaskId") && dict["AlarmTaskId"] != nil {
            self.alarmTaskId = dict["AlarmTaskId"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
    }
}

public class DeleteAlarmResponseBody : Tea.TeaModel {
    public var alarmTaskId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alarmTaskId != nil {
            map["AlarmTaskId"] = self.alarmTaskId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlarmTaskId") && dict["AlarmTaskId"] != nil {
            self.alarmTaskId = dict["AlarmTaskId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteAlarmResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteAlarmResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteAlarmResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteEciScalingConfigurationRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingConfigurationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingConfigurationId != nil {
            map["ScalingConfigurationId"] = self.scalingConfigurationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") && dict["OwnerAccount"] != nil {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScalingConfigurationId") && dict["ScalingConfigurationId"] != nil {
            self.scalingConfigurationId = dict["ScalingConfigurationId"] as! String
        }
    }
}

public class DeleteEciScalingConfigurationResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteEciScalingConfigurationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteEciScalingConfigurationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteEciScalingConfigurationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteLifecycleHookRequest : Tea.TeaModel {
    public var lifecycleHookId: String?

    public var lifecycleHookName: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lifecycleHookId != nil {
            map["LifecycleHookId"] = self.lifecycleHookId!
        }
        if self.lifecycleHookName != nil {
            map["LifecycleHookName"] = self.lifecycleHookName!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LifecycleHookId") && dict["LifecycleHookId"] != nil {
            self.lifecycleHookId = dict["LifecycleHookId"] as! String
        }
        if dict.keys.contains("LifecycleHookName") && dict["LifecycleHookName"] != nil {
            self.lifecycleHookName = dict["LifecycleHookName"] as! String
        }
        if dict.keys.contains("OwnerAccount") && dict["OwnerAccount"] != nil {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScalingGroupId") && dict["ScalingGroupId"] != nil {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
    }
}

public class DeleteLifecycleHookResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteLifecycleHookResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLifecycleHookResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteLifecycleHookResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteNotificationConfigurationRequest : Tea.TeaModel {
    public var notificationArn: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.notificationArn != nil {
            map["NotificationArn"] = self.notificationArn!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NotificationArn") && dict["NotificationArn"] != nil {
            self.notificationArn = dict["NotificationArn"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScalingGroupId") && dict["ScalingGroupId"] != nil {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
    }
}

public class DeleteNotificationConfigurationResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteNotificationConfigurationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteNotificationConfigurationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteNotificationConfigurationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteScalingConfigurationRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var scalingConfigurationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingConfigurationId != nil {
            map["ScalingConfigurationId"] = self.scalingConfigurationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") && dict["OwnerAccount"] != nil {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScalingConfigurationId") && dict["ScalingConfigurationId"] != nil {
            self.scalingConfigurationId = dict["ScalingConfigurationId"] as! String
        }
    }
}

public class DeleteScalingConfigurationResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteScalingConfigurationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteScalingConfigurationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteScalingConfigurationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteScalingGroupRequest : Tea.TeaModel {
    public var forceDelete: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.forceDelete != nil {
            map["ForceDelete"] = self.forceDelete!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ForceDelete") && dict["ForceDelete"] != nil {
            self.forceDelete = dict["ForceDelete"] as! Bool
        }
        if dict.keys.contains("OwnerAccount") && dict["OwnerAccount"] != nil {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScalingGroupId") && dict["ScalingGroupId"] != nil {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
    }
}

public class DeleteScalingGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteScalingGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteScalingGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteScalingGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteScalingRuleRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingRuleId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingRuleId != nil {
            map["ScalingRuleId"] = self.scalingRuleId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") && dict["OwnerAccount"] != nil {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScalingRuleId") && dict["ScalingRuleId"] != nil {
            self.scalingRuleId = dict["ScalingRuleId"] as! String
        }
    }
}

public class DeleteScalingRuleResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteScalingRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteScalingRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteScalingRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteScheduledTaskRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scheduledTaskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scheduledTaskId != nil {
            map["ScheduledTaskId"] = self.scheduledTaskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") && dict["OwnerAccount"] != nil {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScheduledTaskId") && dict["ScheduledTaskId"] != nil {
            self.scheduledTaskId = dict["ScheduledTaskId"] as! String
        }
    }
}

public class DeleteScheduledTaskResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteScheduledTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteScheduledTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteScheduledTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAlarmsRequest : Tea.TeaModel {
    public var alarmTaskId: String?

    public var isEnable: Bool?

    public var metricName: String?

    public var metricType: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public var state: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alarmTaskId != nil {
            map["AlarmTaskId"] = self.alarmTaskId!
        }
        if self.isEnable != nil {
            map["IsEnable"] = self.isEnable!
        }
        if self.metricName != nil {
            map["MetricName"] = self.metricName!
        }
        if self.metricType != nil {
            map["MetricType"] = self.metricType!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlarmTaskId") && dict["AlarmTaskId"] != nil {
            self.alarmTaskId = dict["AlarmTaskId"] as! String
        }
        if dict.keys.contains("IsEnable") && dict["IsEnable"] != nil {
            self.isEnable = dict["IsEnable"] as! Bool
        }
        if dict.keys.contains("MetricName") && dict["MetricName"] != nil {
            self.metricName = dict["MetricName"] as! String
        }
        if dict.keys.contains("MetricType") && dict["MetricType"] != nil {
            self.metricType = dict["MetricType"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScalingGroupId") && dict["ScalingGroupId"] != nil {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
        if dict.keys.contains("State") && dict["State"] != nil {
            self.state = dict["State"] as! String
        }
    }
}

public class DescribeAlarmsResponseBody : Tea.TeaModel {
    public class AlarmList : Tea.TeaModel {
        public class Dimensions : Tea.TeaModel {
            public var dimensionKey: String?

            public var dimensionValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dimensionKey != nil {
                    map["DimensionKey"] = self.dimensionKey!
                }
                if self.dimensionValue != nil {
                    map["DimensionValue"] = self.dimensionValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DimensionKey") && dict["DimensionKey"] != nil {
                    self.dimensionKey = dict["DimensionKey"] as! String
                }
                if dict.keys.contains("DimensionValue") && dict["DimensionValue"] != nil {
                    self.dimensionValue = dict["DimensionValue"] as! String
                }
            }
        }
        public class Expressions : Tea.TeaModel {
            public var comparisonOperator: String?

            public var metricName: String?

            public var period: Int32?

            public var statistics: String?

            public var threshold: Double?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.comparisonOperator != nil {
                    map["ComparisonOperator"] = self.comparisonOperator!
                }
                if self.metricName != nil {
                    map["MetricName"] = self.metricName!
                }
                if self.period != nil {
                    map["Period"] = self.period!
                }
                if self.statistics != nil {
                    map["Statistics"] = self.statistics!
                }
                if self.threshold != nil {
                    map["Threshold"] = self.threshold!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ComparisonOperator") && dict["ComparisonOperator"] != nil {
                    self.comparisonOperator = dict["ComparisonOperator"] as! String
                }
                if dict.keys.contains("MetricName") && dict["MetricName"] != nil {
                    self.metricName = dict["MetricName"] as! String
                }
                if dict.keys.contains("Period") && dict["Period"] != nil {
                    self.period = dict["Period"] as! Int32
                }
                if dict.keys.contains("Statistics") && dict["Statistics"] != nil {
                    self.statistics = dict["Statistics"] as! String
                }
                if dict.keys.contains("Threshold") && dict["Threshold"] != nil {
                    self.threshold = dict["Threshold"] as! Double
                }
            }
        }
        public var alarmActions: [String]?

        public var alarmTaskId: String?

        public var comparisonOperator: String?

        public var description_: String?

        public var dimensions: [DescribeAlarmsResponseBody.AlarmList.Dimensions]?

        public var effective: String?

        public var enable: Bool?

        public var evaluationCount: Int32?

        public var expressions: [DescribeAlarmsResponseBody.AlarmList.Expressions]?

        public var expressionsLogicOperator: String?

        public var metricName: String?

        public var metricType: String?

        public var name: String?

        public var period: Int32?

        public var scalingGroupId: String?

        public var state: String?

        public var statistics: String?

        public var threshold: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alarmActions != nil {
                map["AlarmActions"] = self.alarmActions!
            }
            if self.alarmTaskId != nil {
                map["AlarmTaskId"] = self.alarmTaskId!
            }
            if self.comparisonOperator != nil {
                map["ComparisonOperator"] = self.comparisonOperator!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.dimensions != nil {
                var tmp : [Any] = []
                for k in self.dimensions! {
                    tmp.append(k.toMap())
                }
                map["Dimensions"] = tmp
            }
            if self.effective != nil {
                map["Effective"] = self.effective!
            }
            if self.enable != nil {
                map["Enable"] = self.enable!
            }
            if self.evaluationCount != nil {
                map["EvaluationCount"] = self.evaluationCount!
            }
            if self.expressions != nil {
                var tmp : [Any] = []
                for k in self.expressions! {
                    tmp.append(k.toMap())
                }
                map["Expressions"] = tmp
            }
            if self.expressionsLogicOperator != nil {
                map["ExpressionsLogicOperator"] = self.expressionsLogicOperator!
            }
            if self.metricName != nil {
                map["MetricName"] = self.metricName!
            }
            if self.metricType != nil {
                map["MetricType"] = self.metricType!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.period != nil {
                map["Period"] = self.period!
            }
            if self.scalingGroupId != nil {
                map["ScalingGroupId"] = self.scalingGroupId!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.statistics != nil {
                map["Statistics"] = self.statistics!
            }
            if self.threshold != nil {
                map["Threshold"] = self.threshold!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AlarmActions") && dict["AlarmActions"] != nil {
                self.alarmActions = dict["AlarmActions"] as! [String]
            }
            if dict.keys.contains("AlarmTaskId") && dict["AlarmTaskId"] != nil {
                self.alarmTaskId = dict["AlarmTaskId"] as! String
            }
            if dict.keys.contains("ComparisonOperator") && dict["ComparisonOperator"] != nil {
                self.comparisonOperator = dict["ComparisonOperator"] as! String
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Dimensions") && dict["Dimensions"] != nil {
                var tmp : [DescribeAlarmsResponseBody.AlarmList.Dimensions] = []
                for v in dict["Dimensions"] as! [Any] {
                    var model = DescribeAlarmsResponseBody.AlarmList.Dimensions()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.dimensions = tmp
            }
            if dict.keys.contains("Effective") && dict["Effective"] != nil {
                self.effective = dict["Effective"] as! String
            }
            if dict.keys.contains("Enable") && dict["Enable"] != nil {
                self.enable = dict["Enable"] as! Bool
            }
            if dict.keys.contains("EvaluationCount") && dict["EvaluationCount"] != nil {
                self.evaluationCount = dict["EvaluationCount"] as! Int32
            }
            if dict.keys.contains("Expressions") && dict["Expressions"] != nil {
                var tmp : [DescribeAlarmsResponseBody.AlarmList.Expressions] = []
                for v in dict["Expressions"] as! [Any] {
                    var model = DescribeAlarmsResponseBody.AlarmList.Expressions()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.expressions = tmp
            }
            if dict.keys.contains("ExpressionsLogicOperator") && dict["ExpressionsLogicOperator"] != nil {
                self.expressionsLogicOperator = dict["ExpressionsLogicOperator"] as! String
            }
            if dict.keys.contains("MetricName") && dict["MetricName"] != nil {
                self.metricName = dict["MetricName"] as! String
            }
            if dict.keys.contains("MetricType") && dict["MetricType"] != nil {
                self.metricType = dict["MetricType"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Period") && dict["Period"] != nil {
                self.period = dict["Period"] as! Int32
            }
            if dict.keys.contains("ScalingGroupId") && dict["ScalingGroupId"] != nil {
                self.scalingGroupId = dict["ScalingGroupId"] as! String
            }
            if dict.keys.contains("State") && dict["State"] != nil {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("Statistics") && dict["Statistics"] != nil {
                self.statistics = dict["Statistics"] as! String
            }
            if dict.keys.contains("Threshold") && dict["Threshold"] != nil {
                self.threshold = dict["Threshold"] as! Double
            }
        }
    }
    public var alarmList: [DescribeAlarmsResponseBody.AlarmList]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alarmList != nil {
            var tmp : [Any] = []
            for k in self.alarmList! {
                tmp.append(k.toMap())
            }
            map["AlarmList"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlarmList") && dict["AlarmList"] != nil {
            var tmp : [DescribeAlarmsResponseBody.AlarmList] = []
            for v in dict["AlarmList"] as! [Any] {
                var model = DescribeAlarmsResponseBody.AlarmList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.alarmList = tmp
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeAlarmsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAlarmsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeAlarmsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEciScalingConfigurationDetailRequest : Tea.TeaModel {
    public var outputFormat: String?

    public var regionId: String?

    public var scalingConfigurationId: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.outputFormat != nil {
            map["OutputFormat"] = self.outputFormat!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.scalingConfigurationId != nil {
            map["ScalingConfigurationId"] = self.scalingConfigurationId!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OutputFormat") && dict["OutputFormat"] != nil {
            self.outputFormat = dict["OutputFormat"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ScalingConfigurationId") && dict["ScalingConfigurationId"] != nil {
            self.scalingConfigurationId = dict["ScalingConfigurationId"] as! String
        }
        if dict.keys.contains("ScalingGroupId") && dict["ScalingGroupId"] != nil {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
    }
}

public class DescribeEciScalingConfigurationDetailResponseBody : Tea.TeaModel {
    public class ScalingConfiguration : Tea.TeaModel {
        public class AcrRegistryInfos : Tea.TeaModel {
            public var domains: [String]?

            public var instanceId: String?

            public var instanceName: String?

            public var regionId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.domains != nil {
                    map["Domains"] = self.domains!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.instanceName != nil {
                    map["InstanceName"] = self.instanceName!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Domains") && dict["Domains"] != nil {
                    self.domains = dict["Domains"] as! [String]
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
                    self.instanceName = dict["InstanceName"] as! String
                }
                if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                    self.regionId = dict["RegionId"] as! String
                }
            }
        }
        public class Containers : Tea.TeaModel {
            public class EnvironmentVars : Tea.TeaModel {
                public var fieldRefFieldPath: String?

                public var key: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.fieldRefFieldPath != nil {
                        map["FieldRefFieldPath"] = self.fieldRefFieldPath!
                    }
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("FieldRefFieldPath") && dict["FieldRefFieldPath"] != nil {
                        self.fieldRefFieldPath = dict["FieldRefFieldPath"] as! String
                    }
                    if dict.keys.contains("Key") && dict["Key"] != nil {
                        self.key = dict["Key"] as! String
                    }
                    if dict.keys.contains("Value") && dict["Value"] != nil {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class Ports : Tea.TeaModel {
                public var port: Int32?

                public var protocol_: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.port != nil {
                        map["Port"] = self.port!
                    }
                    if self.protocol_ != nil {
                        map["Protocol"] = self.protocol_!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Port") && dict["Port"] != nil {
                        self.port = dict["Port"] as! Int32
                    }
                    if dict.keys.contains("Protocol") && dict["Protocol"] != nil {
                        self.protocol_ = dict["Protocol"] as! String
                    }
                }
            }
            public class VolumeMounts : Tea.TeaModel {
                public var mountPath: String?

                public var mountPropagation: String?

                public var name: String?

                public var readOnly: Bool?

                public var subPath: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.mountPath != nil {
                        map["MountPath"] = self.mountPath!
                    }
                    if self.mountPropagation != nil {
                        map["MountPropagation"] = self.mountPropagation!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.readOnly != nil {
                        map["ReadOnly"] = self.readOnly!
                    }
                    if self.subPath != nil {
                        map["SubPath"] = self.subPath!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("MountPath") && dict["MountPath"] != nil {
                        self.mountPath = dict["MountPath"] as! String
                    }
                    if dict.keys.contains("MountPropagation") && dict["MountPropagation"] != nil {
                        self.mountPropagation = dict["MountPropagation"] as! String
                    }
                    if dict.keys.contains("Name") && dict["Name"] != nil {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("ReadOnly") && dict["ReadOnly"] != nil {
                        self.readOnly = dict["ReadOnly"] as! Bool
                    }
                    if dict.keys.contains("SubPath") && dict["SubPath"] != nil {
                        self.subPath = dict["SubPath"] as! String
                    }
                }
            }
            public var args: [String]?

            public var commands: [String]?

            public var cpu: Double?

            public var environmentVars: [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.Containers.EnvironmentVars]?

            public var gpu: Int32?

            public var image: String?

            public var imagePullPolicy: String?

            public var lifecyclePostStartHandlerExecs: [String]?

            public var lifecyclePostStartHandlerHttpGetHost: String?

            public var lifecyclePostStartHandlerHttpGetPath: String?

            public var lifecyclePostStartHandlerHttpGetPort: Int32?

            public var lifecyclePostStartHandlerHttpGetScheme: String?

            public var lifecyclePostStartHandlerTcpSocketHost: String?

            public var lifecyclePostStartHandlerTcpSocketPort: Int32?

            public var lifecyclePreStopHandlerExecs: [String]?

            public var lifecyclePreStopHandlerHttpGetHost: String?

            public var lifecyclePreStopHandlerHttpGetPath: String?

            public var lifecyclePreStopHandlerHttpGetPort: Int32?

            public var lifecyclePreStopHandlerHttpGetScheme: String?

            public var lifecyclePreStopHandlerTcpSocketHost: String?

            public var lifecyclePreStopHandlerTcpSocketPort: Int32?

            public var livenessProbeExecCommands: [String]?

            public var livenessProbeFailureThreshold: Int32?

            public var livenessProbeHttpGetPath: String?

            public var livenessProbeHttpGetPort: Int32?

            public var livenessProbeHttpGetScheme: String?

            public var livenessProbeInitialDelaySeconds: Int32?

            public var livenessProbePeriodSeconds: Int32?

            public var livenessProbeSuccessThreshold: Int32?

            public var livenessProbeTcpSocketPort: Int32?

            public var livenessProbeTimeoutSeconds: Int32?

            public var memory: Double?

            public var name: String?

            public var ports: [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.Containers.Ports]?

            public var readinessProbeExecCommands: [String]?

            public var readinessProbeFailureThreshold: Int32?

            public var readinessProbeHttpGetPath: String?

            public var readinessProbeHttpGetPort: Int32?

            public var readinessProbeHttpGetScheme: String?

            public var readinessProbeInitialDelaySeconds: Int32?

            public var readinessProbePeriodSeconds: Int32?

            public var readinessProbeSuccessThreshold: Int32?

            public var readinessProbeTcpSocketPort: Int32?

            public var readinessProbeTimeoutSeconds: Int32?

            public var securityContextCapabilityAdds: [String]?

            public var securityContextReadOnlyRootFilesystem: Bool?

            public var securityContextRunAsUser: Int64?

            public var stdin: Bool?

            public var stdinOnce: Bool?

            public var tty: Bool?

            public var volumeMounts: [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.Containers.VolumeMounts]?

            public var workingDir: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.args != nil {
                    map["Args"] = self.args!
                }
                if self.commands != nil {
                    map["Commands"] = self.commands!
                }
                if self.cpu != nil {
                    map["Cpu"] = self.cpu!
                }
                if self.environmentVars != nil {
                    var tmp : [Any] = []
                    for k in self.environmentVars! {
                        tmp.append(k.toMap())
                    }
                    map["EnvironmentVars"] = tmp
                }
                if self.gpu != nil {
                    map["Gpu"] = self.gpu!
                }
                if self.image != nil {
                    map["Image"] = self.image!
                }
                if self.imagePullPolicy != nil {
                    map["ImagePullPolicy"] = self.imagePullPolicy!
                }
                if self.lifecyclePostStartHandlerExecs != nil {
                    map["LifecyclePostStartHandlerExecs"] = self.lifecyclePostStartHandlerExecs!
                }
                if self.lifecyclePostStartHandlerHttpGetHost != nil {
                    map["LifecyclePostStartHandlerHttpGetHost"] = self.lifecyclePostStartHandlerHttpGetHost!
                }
                if self.lifecyclePostStartHandlerHttpGetPath != nil {
                    map["LifecyclePostStartHandlerHttpGetPath"] = self.lifecyclePostStartHandlerHttpGetPath!
                }
                if self.lifecyclePostStartHandlerHttpGetPort != nil {
                    map["LifecyclePostStartHandlerHttpGetPort"] = self.lifecyclePostStartHandlerHttpGetPort!
                }
                if self.lifecyclePostStartHandlerHttpGetScheme != nil {
                    map["LifecyclePostStartHandlerHttpGetScheme"] = self.lifecyclePostStartHandlerHttpGetScheme!
                }
                if self.lifecyclePostStartHandlerTcpSocketHost != nil {
                    map["LifecyclePostStartHandlerTcpSocketHost"] = self.lifecyclePostStartHandlerTcpSocketHost!
                }
                if self.lifecyclePostStartHandlerTcpSocketPort != nil {
                    map["LifecyclePostStartHandlerTcpSocketPort"] = self.lifecyclePostStartHandlerTcpSocketPort!
                }
                if self.lifecyclePreStopHandlerExecs != nil {
                    map["LifecyclePreStopHandlerExecs"] = self.lifecyclePreStopHandlerExecs!
                }
                if self.lifecyclePreStopHandlerHttpGetHost != nil {
                    map["LifecyclePreStopHandlerHttpGetHost"] = self.lifecyclePreStopHandlerHttpGetHost!
                }
                if self.lifecyclePreStopHandlerHttpGetPath != nil {
                    map["LifecyclePreStopHandlerHttpGetPath"] = self.lifecyclePreStopHandlerHttpGetPath!
                }
                if self.lifecyclePreStopHandlerHttpGetPort != nil {
                    map["LifecyclePreStopHandlerHttpGetPort"] = self.lifecyclePreStopHandlerHttpGetPort!
                }
                if self.lifecyclePreStopHandlerHttpGetScheme != nil {
                    map["LifecyclePreStopHandlerHttpGetScheme"] = self.lifecyclePreStopHandlerHttpGetScheme!
                }
                if self.lifecyclePreStopHandlerTcpSocketHost != nil {
                    map["LifecyclePreStopHandlerTcpSocketHost"] = self.lifecyclePreStopHandlerTcpSocketHost!
                }
                if self.lifecyclePreStopHandlerTcpSocketPort != nil {
                    map["LifecyclePreStopHandlerTcpSocketPort"] = self.lifecyclePreStopHandlerTcpSocketPort!
                }
                if self.livenessProbeExecCommands != nil {
                    map["LivenessProbeExecCommands"] = self.livenessProbeExecCommands!
                }
                if self.livenessProbeFailureThreshold != nil {
                    map["LivenessProbeFailureThreshold"] = self.livenessProbeFailureThreshold!
                }
                if self.livenessProbeHttpGetPath != nil {
                    map["LivenessProbeHttpGetPath"] = self.livenessProbeHttpGetPath!
                }
                if self.livenessProbeHttpGetPort != nil {
                    map["LivenessProbeHttpGetPort"] = self.livenessProbeHttpGetPort!
                }
                if self.livenessProbeHttpGetScheme != nil {
                    map["LivenessProbeHttpGetScheme"] = self.livenessProbeHttpGetScheme!
                }
                if self.livenessProbeInitialDelaySeconds != nil {
                    map["LivenessProbeInitialDelaySeconds"] = self.livenessProbeInitialDelaySeconds!
                }
                if self.livenessProbePeriodSeconds != nil {
                    map["LivenessProbePeriodSeconds"] = self.livenessProbePeriodSeconds!
                }
                if self.livenessProbeSuccessThreshold != nil {
                    map["LivenessProbeSuccessThreshold"] = self.livenessProbeSuccessThreshold!
                }
                if self.livenessProbeTcpSocketPort != nil {
                    map["LivenessProbeTcpSocketPort"] = self.livenessProbeTcpSocketPort!
                }
                if self.livenessProbeTimeoutSeconds != nil {
                    map["LivenessProbeTimeoutSeconds"] = self.livenessProbeTimeoutSeconds!
                }
                if self.memory != nil {
                    map["Memory"] = self.memory!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.ports != nil {
                    var tmp : [Any] = []
                    for k in self.ports! {
                        tmp.append(k.toMap())
                    }
                    map["Ports"] = tmp
                }
                if self.readinessProbeExecCommands != nil {
                    map["ReadinessProbeExecCommands"] = self.readinessProbeExecCommands!
                }
                if self.readinessProbeFailureThreshold != nil {
                    map["ReadinessProbeFailureThreshold"] = self.readinessProbeFailureThreshold!
                }
                if self.readinessProbeHttpGetPath != nil {
                    map["ReadinessProbeHttpGetPath"] = self.readinessProbeHttpGetPath!
                }
                if self.readinessProbeHttpGetPort != nil {
                    map["ReadinessProbeHttpGetPort"] = self.readinessProbeHttpGetPort!
                }
                if self.readinessProbeHttpGetScheme != nil {
                    map["ReadinessProbeHttpGetScheme"] = self.readinessProbeHttpGetScheme!
                }
                if self.readinessProbeInitialDelaySeconds != nil {
                    map["ReadinessProbeInitialDelaySeconds"] = self.readinessProbeInitialDelaySeconds!
                }
                if self.readinessProbePeriodSeconds != nil {
                    map["ReadinessProbePeriodSeconds"] = self.readinessProbePeriodSeconds!
                }
                if self.readinessProbeSuccessThreshold != nil {
                    map["ReadinessProbeSuccessThreshold"] = self.readinessProbeSuccessThreshold!
                }
                if self.readinessProbeTcpSocketPort != nil {
                    map["ReadinessProbeTcpSocketPort"] = self.readinessProbeTcpSocketPort!
                }
                if self.readinessProbeTimeoutSeconds != nil {
                    map["ReadinessProbeTimeoutSeconds"] = self.readinessProbeTimeoutSeconds!
                }
                if self.securityContextCapabilityAdds != nil {
                    map["SecurityContextCapabilityAdds"] = self.securityContextCapabilityAdds!
                }
                if self.securityContextReadOnlyRootFilesystem != nil {
                    map["SecurityContextReadOnlyRootFilesystem"] = self.securityContextReadOnlyRootFilesystem!
                }
                if self.securityContextRunAsUser != nil {
                    map["SecurityContextRunAsUser"] = self.securityContextRunAsUser!
                }
                if self.stdin != nil {
                    map["Stdin"] = self.stdin!
                }
                if self.stdinOnce != nil {
                    map["StdinOnce"] = self.stdinOnce!
                }
                if self.tty != nil {
                    map["Tty"] = self.tty!
                }
                if self.volumeMounts != nil {
                    var tmp : [Any] = []
                    for k in self.volumeMounts! {
                        tmp.append(k.toMap())
                    }
                    map["VolumeMounts"] = tmp
                }
                if self.workingDir != nil {
                    map["WorkingDir"] = self.workingDir!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Args") && dict["Args"] != nil {
                    self.args = dict["Args"] as! [String]
                }
                if dict.keys.contains("Commands") && dict["Commands"] != nil {
                    self.commands = dict["Commands"] as! [String]
                }
                if dict.keys.contains("Cpu") && dict["Cpu"] != nil {
                    self.cpu = dict["Cpu"] as! Double
                }
                if dict.keys.contains("EnvironmentVars") && dict["EnvironmentVars"] != nil {
                    var tmp : [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.Containers.EnvironmentVars] = []
                    for v in dict["EnvironmentVars"] as! [Any] {
                        var model = DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.Containers.EnvironmentVars()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.environmentVars = tmp
                }
                if dict.keys.contains("Gpu") && dict["Gpu"] != nil {
                    self.gpu = dict["Gpu"] as! Int32
                }
                if dict.keys.contains("Image") && dict["Image"] != nil {
                    self.image = dict["Image"] as! String
                }
                if dict.keys.contains("ImagePullPolicy") && dict["ImagePullPolicy"] != nil {
                    self.imagePullPolicy = dict["ImagePullPolicy"] as! String
                }
                if dict.keys.contains("LifecyclePostStartHandlerExecs") && dict["LifecyclePostStartHandlerExecs"] != nil {
                    self.lifecyclePostStartHandlerExecs = dict["LifecyclePostStartHandlerExecs"] as! [String]
                }
                if dict.keys.contains("LifecyclePostStartHandlerHttpGetHost") && dict["LifecyclePostStartHandlerHttpGetHost"] != nil {
                    self.lifecyclePostStartHandlerHttpGetHost = dict["LifecyclePostStartHandlerHttpGetHost"] as! String
                }
                if dict.keys.contains("LifecyclePostStartHandlerHttpGetPath") && dict["LifecyclePostStartHandlerHttpGetPath"] != nil {
                    self.lifecyclePostStartHandlerHttpGetPath = dict["LifecyclePostStartHandlerHttpGetPath"] as! String
                }
                if dict.keys.contains("LifecyclePostStartHandlerHttpGetPort") && dict["LifecyclePostStartHandlerHttpGetPort"] != nil {
                    self.lifecyclePostStartHandlerHttpGetPort = dict["LifecyclePostStartHandlerHttpGetPort"] as! Int32
                }
                if dict.keys.contains("LifecyclePostStartHandlerHttpGetScheme") && dict["LifecyclePostStartHandlerHttpGetScheme"] != nil {
                    self.lifecyclePostStartHandlerHttpGetScheme = dict["LifecyclePostStartHandlerHttpGetScheme"] as! String
                }
                if dict.keys.contains("LifecyclePostStartHandlerTcpSocketHost") && dict["LifecyclePostStartHandlerTcpSocketHost"] != nil {
                    self.lifecyclePostStartHandlerTcpSocketHost = dict["LifecyclePostStartHandlerTcpSocketHost"] as! String
                }
                if dict.keys.contains("LifecyclePostStartHandlerTcpSocketPort") && dict["LifecyclePostStartHandlerTcpSocketPort"] != nil {
                    self.lifecyclePostStartHandlerTcpSocketPort = dict["LifecyclePostStartHandlerTcpSocketPort"] as! Int32
                }
                if dict.keys.contains("LifecyclePreStopHandlerExecs") && dict["LifecyclePreStopHandlerExecs"] != nil {
                    self.lifecyclePreStopHandlerExecs = dict["LifecyclePreStopHandlerExecs"] as! [String]
                }
                if dict.keys.contains("LifecyclePreStopHandlerHttpGetHost") && dict["LifecyclePreStopHandlerHttpGetHost"] != nil {
                    self.lifecyclePreStopHandlerHttpGetHost = dict["LifecyclePreStopHandlerHttpGetHost"] as! String
                }
                if dict.keys.contains("LifecyclePreStopHandlerHttpGetPath") && dict["LifecyclePreStopHandlerHttpGetPath"] != nil {
                    self.lifecyclePreStopHandlerHttpGetPath = dict["LifecyclePreStopHandlerHttpGetPath"] as! String
                }
                if dict.keys.contains("LifecyclePreStopHandlerHttpGetPort") && dict["LifecyclePreStopHandlerHttpGetPort"] != nil {
                    self.lifecyclePreStopHandlerHttpGetPort = dict["LifecyclePreStopHandlerHttpGetPort"] as! Int32
                }
                if dict.keys.contains("LifecyclePreStopHandlerHttpGetScheme") && dict["LifecyclePreStopHandlerHttpGetScheme"] != nil {
                    self.lifecyclePreStopHandlerHttpGetScheme = dict["LifecyclePreStopHandlerHttpGetScheme"] as! String
                }
                if dict.keys.contains("LifecyclePreStopHandlerTcpSocketHost") && dict["LifecyclePreStopHandlerTcpSocketHost"] != nil {
                    self.lifecyclePreStopHandlerTcpSocketHost = dict["LifecyclePreStopHandlerTcpSocketHost"] as! String
                }
                if dict.keys.contains("LifecyclePreStopHandlerTcpSocketPort") && dict["LifecyclePreStopHandlerTcpSocketPort"] != nil {
                    self.lifecyclePreStopHandlerTcpSocketPort = dict["LifecyclePreStopHandlerTcpSocketPort"] as! Int32
                }
                if dict.keys.contains("LivenessProbeExecCommands") && dict["LivenessProbeExecCommands"] != nil {
                    self.livenessProbeExecCommands = dict["LivenessProbeExecCommands"] as! [String]
                }
                if dict.keys.contains("LivenessProbeFailureThreshold") && dict["LivenessProbeFailureThreshold"] != nil {
                    self.livenessProbeFailureThreshold = dict["LivenessProbeFailureThreshold"] as! Int32
                }
                if dict.keys.contains("LivenessProbeHttpGetPath") && dict["LivenessProbeHttpGetPath"] != nil {
                    self.livenessProbeHttpGetPath = dict["LivenessProbeHttpGetPath"] as! String
                }
                if dict.keys.contains("LivenessProbeHttpGetPort") && dict["LivenessProbeHttpGetPort"] != nil {
                    self.livenessProbeHttpGetPort = dict["LivenessProbeHttpGetPort"] as! Int32
                }
                if dict.keys.contains("LivenessProbeHttpGetScheme") && dict["LivenessProbeHttpGetScheme"] != nil {
                    self.livenessProbeHttpGetScheme = dict["LivenessProbeHttpGetScheme"] as! String
                }
                if dict.keys.contains("LivenessProbeInitialDelaySeconds") && dict["LivenessProbeInitialDelaySeconds"] != nil {
                    self.livenessProbeInitialDelaySeconds = dict["LivenessProbeInitialDelaySeconds"] as! Int32
                }
                if dict.keys.contains("LivenessProbePeriodSeconds") && dict["LivenessProbePeriodSeconds"] != nil {
                    self.livenessProbePeriodSeconds = dict["LivenessProbePeriodSeconds"] as! Int32
                }
                if dict.keys.contains("LivenessProbeSuccessThreshold") && dict["LivenessProbeSuccessThreshold"] != nil {
                    self.livenessProbeSuccessThreshold = dict["LivenessProbeSuccessThreshold"] as! Int32
                }
                if dict.keys.contains("LivenessProbeTcpSocketPort") && dict["LivenessProbeTcpSocketPort"] != nil {
                    self.livenessProbeTcpSocketPort = dict["LivenessProbeTcpSocketPort"] as! Int32
                }
                if dict.keys.contains("LivenessProbeTimeoutSeconds") && dict["LivenessProbeTimeoutSeconds"] != nil {
                    self.livenessProbeTimeoutSeconds = dict["LivenessProbeTimeoutSeconds"] as! Int32
                }
                if dict.keys.contains("Memory") && dict["Memory"] != nil {
                    self.memory = dict["Memory"] as! Double
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Ports") && dict["Ports"] != nil {
                    var tmp : [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.Containers.Ports] = []
                    for v in dict["Ports"] as! [Any] {
                        var model = DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.Containers.Ports()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.ports = tmp
                }
                if dict.keys.contains("ReadinessProbeExecCommands") && dict["ReadinessProbeExecCommands"] != nil {
                    self.readinessProbeExecCommands = dict["ReadinessProbeExecCommands"] as! [String]
                }
                if dict.keys.contains("ReadinessProbeFailureThreshold") && dict["ReadinessProbeFailureThreshold"] != nil {
                    self.readinessProbeFailureThreshold = dict["ReadinessProbeFailureThreshold"] as! Int32
                }
                if dict.keys.contains("ReadinessProbeHttpGetPath") && dict["ReadinessProbeHttpGetPath"] != nil {
                    self.readinessProbeHttpGetPath = dict["ReadinessProbeHttpGetPath"] as! String
                }
                if dict.keys.contains("ReadinessProbeHttpGetPort") && dict["ReadinessProbeHttpGetPort"] != nil {
                    self.readinessProbeHttpGetPort = dict["ReadinessProbeHttpGetPort"] as! Int32
                }
                if dict.keys.contains("ReadinessProbeHttpGetScheme") && dict["ReadinessProbeHttpGetScheme"] != nil {
                    self.readinessProbeHttpGetScheme = dict["ReadinessProbeHttpGetScheme"] as! String
                }
                if dict.keys.contains("ReadinessProbeInitialDelaySeconds") && dict["ReadinessProbeInitialDelaySeconds"] != nil {
                    self.readinessProbeInitialDelaySeconds = dict["ReadinessProbeInitialDelaySeconds"] as! Int32
                }
                if dict.keys.contains("ReadinessProbePeriodSeconds") && dict["ReadinessProbePeriodSeconds"] != nil {
                    self.readinessProbePeriodSeconds = dict["ReadinessProbePeriodSeconds"] as! Int32
                }
                if dict.keys.contains("ReadinessProbeSuccessThreshold") && dict["ReadinessProbeSuccessThreshold"] != nil {
                    self.readinessProbeSuccessThreshold = dict["ReadinessProbeSuccessThreshold"] as! Int32
                }
                if dict.keys.contains("ReadinessProbeTcpSocketPort") && dict["ReadinessProbeTcpSocketPort"] != nil {
                    self.readinessProbeTcpSocketPort = dict["ReadinessProbeTcpSocketPort"] as! Int32
                }
                if dict.keys.contains("ReadinessProbeTimeoutSeconds") && dict["ReadinessProbeTimeoutSeconds"] != nil {
                    self.readinessProbeTimeoutSeconds = dict["ReadinessProbeTimeoutSeconds"] as! Int32
                }
                if dict.keys.contains("SecurityContextCapabilityAdds") && dict["SecurityContextCapabilityAdds"] != nil {
                    self.securityContextCapabilityAdds = dict["SecurityContextCapabilityAdds"] as! [String]
                }
                if dict.keys.contains("SecurityContextReadOnlyRootFilesystem") && dict["SecurityContextReadOnlyRootFilesystem"] != nil {
                    self.securityContextReadOnlyRootFilesystem = dict["SecurityContextReadOnlyRootFilesystem"] as! Bool
                }
                if dict.keys.contains("SecurityContextRunAsUser") && dict["SecurityContextRunAsUser"] != nil {
                    self.securityContextRunAsUser = dict["SecurityContextRunAsUser"] as! Int64
                }
                if dict.keys.contains("Stdin") && dict["Stdin"] != nil {
                    self.stdin = dict["Stdin"] as! Bool
                }
                if dict.keys.contains("StdinOnce") && dict["StdinOnce"] != nil {
                    self.stdinOnce = dict["StdinOnce"] as! Bool
                }
                if dict.keys.contains("Tty") && dict["Tty"] != nil {
                    self.tty = dict["Tty"] as! Bool
                }
                if dict.keys.contains("VolumeMounts") && dict["VolumeMounts"] != nil {
                    var tmp : [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.Containers.VolumeMounts] = []
                    for v in dict["VolumeMounts"] as! [Any] {
                        var model = DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.Containers.VolumeMounts()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.volumeMounts = tmp
                }
                if dict.keys.contains("WorkingDir") && dict["WorkingDir"] != nil {
                    self.workingDir = dict["WorkingDir"] as! String
                }
            }
        }
        public class DnsConfigOptions : Tea.TeaModel {
            public var name: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public class HostAliases : Tea.TeaModel {
            public var hostnames: [String]?

            public var ip: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.hostnames != nil {
                    map["Hostnames"] = self.hostnames!
                }
                if self.ip != nil {
                    map["Ip"] = self.ip!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Hostnames") && dict["Hostnames"] != nil {
                    self.hostnames = dict["Hostnames"] as! [String]
                }
                if dict.keys.contains("Ip") && dict["Ip"] != nil {
                    self.ip = dict["Ip"] as! String
                }
            }
        }
        public class ImageRegistryCredentials : Tea.TeaModel {
            public var password: String?

            public var server: String?

            public var userName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.password != nil {
                    map["Password"] = self.password!
                }
                if self.server != nil {
                    map["Server"] = self.server!
                }
                if self.userName != nil {
                    map["UserName"] = self.userName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Password") && dict["Password"] != nil {
                    self.password = dict["Password"] as! String
                }
                if dict.keys.contains("Server") && dict["Server"] != nil {
                    self.server = dict["Server"] as! String
                }
                if dict.keys.contains("UserName") && dict["UserName"] != nil {
                    self.userName = dict["UserName"] as! String
                }
            }
        }
        public class InitContainers : Tea.TeaModel {
            public class InitContainerEnvironmentVars : Tea.TeaModel {
                public var fieldRefFieldPath: String?

                public var key: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.fieldRefFieldPath != nil {
                        map["FieldRefFieldPath"] = self.fieldRefFieldPath!
                    }
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("FieldRefFieldPath") && dict["FieldRefFieldPath"] != nil {
                        self.fieldRefFieldPath = dict["FieldRefFieldPath"] as! String
                    }
                    if dict.keys.contains("Key") && dict["Key"] != nil {
                        self.key = dict["Key"] as! String
                    }
                    if dict.keys.contains("Value") && dict["Value"] != nil {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class InitContainerPorts : Tea.TeaModel {
                public var port: Int32?

                public var protocol_: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.port != nil {
                        map["Port"] = self.port!
                    }
                    if self.protocol_ != nil {
                        map["Protocol"] = self.protocol_!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Port") && dict["Port"] != nil {
                        self.port = dict["Port"] as! Int32
                    }
                    if dict.keys.contains("Protocol") && dict["Protocol"] != nil {
                        self.protocol_ = dict["Protocol"] as! String
                    }
                }
            }
            public class InitContainerVolumeMounts : Tea.TeaModel {
                public var mountPath: String?

                public var mountPropagation: String?

                public var name: String?

                public var readOnly: Bool?

                public var subPath: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.mountPath != nil {
                        map["MountPath"] = self.mountPath!
                    }
                    if self.mountPropagation != nil {
                        map["MountPropagation"] = self.mountPropagation!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.readOnly != nil {
                        map["ReadOnly"] = self.readOnly!
                    }
                    if self.subPath != nil {
                        map["SubPath"] = self.subPath!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("MountPath") && dict["MountPath"] != nil {
                        self.mountPath = dict["MountPath"] as! String
                    }
                    if dict.keys.contains("MountPropagation") && dict["MountPropagation"] != nil {
                        self.mountPropagation = dict["MountPropagation"] as! String
                    }
                    if dict.keys.contains("Name") && dict["Name"] != nil {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("ReadOnly") && dict["ReadOnly"] != nil {
                        self.readOnly = dict["ReadOnly"] as! Bool
                    }
                    if dict.keys.contains("SubPath") && dict["SubPath"] != nil {
                        self.subPath = dict["SubPath"] as! String
                    }
                }
            }
            public var cpu: Double?

            public var gpu: Int32?

            public var image: String?

            public var imagePullPolicy: String?

            public var initContainerArgs: [String]?

            public var initContainerCommands: [String]?

            public var initContainerEnvironmentVars: [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.InitContainers.InitContainerEnvironmentVars]?

            public var initContainerPorts: [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.InitContainers.InitContainerPorts]?

            public var initContainerVolumeMounts: [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.InitContainers.InitContainerVolumeMounts]?

            public var memory: Double?

            public var name: String?

            public var securityContextCapabilityAdds: [String]?

            public var securityContextReadOnlyRootFilesystem: Bool?

            public var securityContextRunAsUser: String?

            public var workingDir: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cpu != nil {
                    map["Cpu"] = self.cpu!
                }
                if self.gpu != nil {
                    map["Gpu"] = self.gpu!
                }
                if self.image != nil {
                    map["Image"] = self.image!
                }
                if self.imagePullPolicy != nil {
                    map["ImagePullPolicy"] = self.imagePullPolicy!
                }
                if self.initContainerArgs != nil {
                    map["InitContainerArgs"] = self.initContainerArgs!
                }
                if self.initContainerCommands != nil {
                    map["InitContainerCommands"] = self.initContainerCommands!
                }
                if self.initContainerEnvironmentVars != nil {
                    var tmp : [Any] = []
                    for k in self.initContainerEnvironmentVars! {
                        tmp.append(k.toMap())
                    }
                    map["InitContainerEnvironmentVars"] = tmp
                }
                if self.initContainerPorts != nil {
                    var tmp : [Any] = []
                    for k in self.initContainerPorts! {
                        tmp.append(k.toMap())
                    }
                    map["InitContainerPorts"] = tmp
                }
                if self.initContainerVolumeMounts != nil {
                    var tmp : [Any] = []
                    for k in self.initContainerVolumeMounts! {
                        tmp.append(k.toMap())
                    }
                    map["InitContainerVolumeMounts"] = tmp
                }
                if self.memory != nil {
                    map["Memory"] = self.memory!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.securityContextCapabilityAdds != nil {
                    map["SecurityContextCapabilityAdds"] = self.securityContextCapabilityAdds!
                }
                if self.securityContextReadOnlyRootFilesystem != nil {
                    map["SecurityContextReadOnlyRootFilesystem"] = self.securityContextReadOnlyRootFilesystem!
                }
                if self.securityContextRunAsUser != nil {
                    map["SecurityContextRunAsUser"] = self.securityContextRunAsUser!
                }
                if self.workingDir != nil {
                    map["WorkingDir"] = self.workingDir!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Cpu") && dict["Cpu"] != nil {
                    self.cpu = dict["Cpu"] as! Double
                }
                if dict.keys.contains("Gpu") && dict["Gpu"] != nil {
                    self.gpu = dict["Gpu"] as! Int32
                }
                if dict.keys.contains("Image") && dict["Image"] != nil {
                    self.image = dict["Image"] as! String
                }
                if dict.keys.contains("ImagePullPolicy") && dict["ImagePullPolicy"] != nil {
                    self.imagePullPolicy = dict["ImagePullPolicy"] as! String
                }
                if dict.keys.contains("InitContainerArgs") && dict["InitContainerArgs"] != nil {
                    self.initContainerArgs = dict["InitContainerArgs"] as! [String]
                }
                if dict.keys.contains("InitContainerCommands") && dict["InitContainerCommands"] != nil {
                    self.initContainerCommands = dict["InitContainerCommands"] as! [String]
                }
                if dict.keys.contains("InitContainerEnvironmentVars") && dict["InitContainerEnvironmentVars"] != nil {
                    var tmp : [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.InitContainers.InitContainerEnvironmentVars] = []
                    for v in dict["InitContainerEnvironmentVars"] as! [Any] {
                        var model = DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.InitContainers.InitContainerEnvironmentVars()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.initContainerEnvironmentVars = tmp
                }
                if dict.keys.contains("InitContainerPorts") && dict["InitContainerPorts"] != nil {
                    var tmp : [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.InitContainers.InitContainerPorts] = []
                    for v in dict["InitContainerPorts"] as! [Any] {
                        var model = DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.InitContainers.InitContainerPorts()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.initContainerPorts = tmp
                }
                if dict.keys.contains("InitContainerVolumeMounts") && dict["InitContainerVolumeMounts"] != nil {
                    var tmp : [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.InitContainers.InitContainerVolumeMounts] = []
                    for v in dict["InitContainerVolumeMounts"] as! [Any] {
                        var model = DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.InitContainers.InitContainerVolumeMounts()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.initContainerVolumeMounts = tmp
                }
                if dict.keys.contains("Memory") && dict["Memory"] != nil {
                    self.memory = dict["Memory"] as! Double
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("SecurityContextCapabilityAdds") && dict["SecurityContextCapabilityAdds"] != nil {
                    self.securityContextCapabilityAdds = dict["SecurityContextCapabilityAdds"] as! [String]
                }
                if dict.keys.contains("SecurityContextReadOnlyRootFilesystem") && dict["SecurityContextReadOnlyRootFilesystem"] != nil {
                    self.securityContextReadOnlyRootFilesystem = dict["SecurityContextReadOnlyRootFilesystem"] as! Bool
                }
                if dict.keys.contains("SecurityContextRunAsUser") && dict["SecurityContextRunAsUser"] != nil {
                    self.securityContextRunAsUser = dict["SecurityContextRunAsUser"] as! String
                }
                if dict.keys.contains("WorkingDir") && dict["WorkingDir"] != nil {
                    self.workingDir = dict["WorkingDir"] as! String
                }
            }
        }
        public class SecurityContextSysCtls : Tea.TeaModel {
            public var name: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public class Tags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") && dict["Key"] != nil {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public class Volumes : Tea.TeaModel {
            public class ConfigFileVolumeConfigFileToPaths : Tea.TeaModel {
                public var content: String?

                public var mode: Int32?

                public var path: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.content != nil {
                        map["Content"] = self.content!
                    }
                    if self.mode != nil {
                        map["Mode"] = self.mode!
                    }
                    if self.path != nil {
                        map["Path"] = self.path!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Content") && dict["Content"] != nil {
                        self.content = dict["Content"] as! String
                    }
                    if dict.keys.contains("Mode") && dict["Mode"] != nil {
                        self.mode = dict["Mode"] as! Int32
                    }
                    if dict.keys.contains("Path") && dict["Path"] != nil {
                        self.path = dict["Path"] as! String
                    }
                }
            }
            public var configFileVolumeConfigFileToPaths: [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.Volumes.ConfigFileVolumeConfigFileToPaths]?

            public var configFileVolumeDefaultMode: Int32?

            public var diskVolumeDiskId: String?

            public var diskVolumeDiskSize: Int32?

            public var diskVolumeFsType: String?

            public var emptyDirVolumeMedium: String?

            public var emptyDirVolumeSizeLimit: String?

            public var flexVolumeDriver: String?

            public var flexVolumeFsType: String?

            public var flexVolumeOptions: String?

            public var hostPathVolumePath: String?

            public var hostPathVolumeType: String?

            public var NFSVolumePath: String?

            public var NFSVolumeReadOnly: Bool?

            public var NFSVolumeServer: String?

            public var name: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.configFileVolumeConfigFileToPaths != nil {
                    var tmp : [Any] = []
                    for k in self.configFileVolumeConfigFileToPaths! {
                        tmp.append(k.toMap())
                    }
                    map["ConfigFileVolumeConfigFileToPaths"] = tmp
                }
                if self.configFileVolumeDefaultMode != nil {
                    map["ConfigFileVolumeDefaultMode"] = self.configFileVolumeDefaultMode!
                }
                if self.diskVolumeDiskId != nil {
                    map["DiskVolumeDiskId"] = self.diskVolumeDiskId!
                }
                if self.diskVolumeDiskSize != nil {
                    map["DiskVolumeDiskSize"] = self.diskVolumeDiskSize!
                }
                if self.diskVolumeFsType != nil {
                    map["DiskVolumeFsType"] = self.diskVolumeFsType!
                }
                if self.emptyDirVolumeMedium != nil {
                    map["EmptyDirVolumeMedium"] = self.emptyDirVolumeMedium!
                }
                if self.emptyDirVolumeSizeLimit != nil {
                    map["EmptyDirVolumeSizeLimit"] = self.emptyDirVolumeSizeLimit!
                }
                if self.flexVolumeDriver != nil {
                    map["FlexVolumeDriver"] = self.flexVolumeDriver!
                }
                if self.flexVolumeFsType != nil {
                    map["FlexVolumeFsType"] = self.flexVolumeFsType!
                }
                if self.flexVolumeOptions != nil {
                    map["FlexVolumeOptions"] = self.flexVolumeOptions!
                }
                if self.hostPathVolumePath != nil {
                    map["HostPathVolumePath"] = self.hostPathVolumePath!
                }
                if self.hostPathVolumeType != nil {
                    map["HostPathVolumeType"] = self.hostPathVolumeType!
                }
                if self.NFSVolumePath != nil {
                    map["NFSVolumePath"] = self.NFSVolumePath!
                }
                if self.NFSVolumeReadOnly != nil {
                    map["NFSVolumeReadOnly"] = self.NFSVolumeReadOnly!
                }
                if self.NFSVolumeServer != nil {
                    map["NFSVolumeServer"] = self.NFSVolumeServer!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ConfigFileVolumeConfigFileToPaths") && dict["ConfigFileVolumeConfigFileToPaths"] != nil {
                    var tmp : [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.Volumes.ConfigFileVolumeConfigFileToPaths] = []
                    for v in dict["ConfigFileVolumeConfigFileToPaths"] as! [Any] {
                        var model = DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.Volumes.ConfigFileVolumeConfigFileToPaths()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.configFileVolumeConfigFileToPaths = tmp
                }
                if dict.keys.contains("ConfigFileVolumeDefaultMode") && dict["ConfigFileVolumeDefaultMode"] != nil {
                    self.configFileVolumeDefaultMode = dict["ConfigFileVolumeDefaultMode"] as! Int32
                }
                if dict.keys.contains("DiskVolumeDiskId") && dict["DiskVolumeDiskId"] != nil {
                    self.diskVolumeDiskId = dict["DiskVolumeDiskId"] as! String
                }
                if dict.keys.contains("DiskVolumeDiskSize") && dict["DiskVolumeDiskSize"] != nil {
                    self.diskVolumeDiskSize = dict["DiskVolumeDiskSize"] as! Int32
                }
                if dict.keys.contains("DiskVolumeFsType") && dict["DiskVolumeFsType"] != nil {
                    self.diskVolumeFsType = dict["DiskVolumeFsType"] as! String
                }
                if dict.keys.contains("EmptyDirVolumeMedium") && dict["EmptyDirVolumeMedium"] != nil {
                    self.emptyDirVolumeMedium = dict["EmptyDirVolumeMedium"] as! String
                }
                if dict.keys.contains("EmptyDirVolumeSizeLimit") && dict["EmptyDirVolumeSizeLimit"] != nil {
                    self.emptyDirVolumeSizeLimit = dict["EmptyDirVolumeSizeLimit"] as! String
                }
                if dict.keys.contains("FlexVolumeDriver") && dict["FlexVolumeDriver"] != nil {
                    self.flexVolumeDriver = dict["FlexVolumeDriver"] as! String
                }
                if dict.keys.contains("FlexVolumeFsType") && dict["FlexVolumeFsType"] != nil {
                    self.flexVolumeFsType = dict["FlexVolumeFsType"] as! String
                }
                if dict.keys.contains("FlexVolumeOptions") && dict["FlexVolumeOptions"] != nil {
                    self.flexVolumeOptions = dict["FlexVolumeOptions"] as! String
                }
                if dict.keys.contains("HostPathVolumePath") && dict["HostPathVolumePath"] != nil {
                    self.hostPathVolumePath = dict["HostPathVolumePath"] as! String
                }
                if dict.keys.contains("HostPathVolumeType") && dict["HostPathVolumeType"] != nil {
                    self.hostPathVolumeType = dict["HostPathVolumeType"] as! String
                }
                if dict.keys.contains("NFSVolumePath") && dict["NFSVolumePath"] != nil {
                    self.NFSVolumePath = dict["NFSVolumePath"] as! String
                }
                if dict.keys.contains("NFSVolumeReadOnly") && dict["NFSVolumeReadOnly"] != nil {
                    self.NFSVolumeReadOnly = dict["NFSVolumeReadOnly"] as! Bool
                }
                if dict.keys.contains("NFSVolumeServer") && dict["NFSVolumeServer"] != nil {
                    self.NFSVolumeServer = dict["NFSVolumeServer"] as! String
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var acrRegistryInfos: [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.AcrRegistryInfos]?

        public var activeDeadlineSeconds: Int32?

        public var autoCreateEip: Bool?

        public var autoMatchImageCache: Bool?

        public var computeCategory: [String]?

        public var containerGroupName: String?

        public var containers: [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.Containers]?

        public var costOptimization: Bool?

        public var cpu: Double?

        public var cpuOptionsCore: Int32?

        public var cpuOptionsThreadsPerCore: Int32?

        public var creationTime: String?

        public var dataCacheBucket: String?

        public var dataCacheBurstingEnabled: Bool?

        public var dataCachePL: String?

        public var dataCacheProvisionedIops: Int32?

        public var description_: String?

        public var dnsConfigNameServers: [String]?

        public var dnsConfigOptions: [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.DnsConfigOptions]?

        public var dnsConfigSearches: [String]?

        public var dnsPolicy: String?

        public var egressBandwidth: Int64?

        public var eipBandwidth: Int32?

        public var eipCommonBandwidthPackage: String?

        public var eipISP: String?

        public var eipPublicIpAddressPoolId: String?

        public var ephemeralStorage: Int32?

        public var hostAliases: [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.HostAliases]?

        public var hostName: String?

        public var imageRegistryCredentials: [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.ImageRegistryCredentials]?

        public var imageSnapshotId: String?

        public var ingressBandwidth: Int64?

        public var initContainers: [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.InitContainers]?

        public var instanceFamilyLevel: String?

        public var instanceTypes: [String]?

        public var ipv6AddressCount: Int32?

        public var lifecycleState: String?

        public var loadBalancerWeight: Int32?

        public var memory: Double?

        public var ntpServers: [String]?

        public var ramRoleName: String?

        public var regionId: String?

        public var resourceGroupId: String?

        public var restartPolicy: String?

        public var scalingConfigurationId: String?

        public var scalingConfigurationName: String?

        public var scalingGroupId: String?

        public var securityContextSysCtls: [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.SecurityContextSysCtls]?

        public var securityGroupId: String?

        public var slsEnable: Bool?

        public var spotPriceLimit: Double?

        public var spotStrategy: String?

        public var tags: [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.Tags]?

        public var terminationGracePeriodSeconds: Int32?

        public var volumes: [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.Volumes]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.acrRegistryInfos != nil {
                var tmp : [Any] = []
                for k in self.acrRegistryInfos! {
                    tmp.append(k.toMap())
                }
                map["AcrRegistryInfos"] = tmp
            }
            if self.activeDeadlineSeconds != nil {
                map["ActiveDeadlineSeconds"] = self.activeDeadlineSeconds!
            }
            if self.autoCreateEip != nil {
                map["AutoCreateEip"] = self.autoCreateEip!
            }
            if self.autoMatchImageCache != nil {
                map["AutoMatchImageCache"] = self.autoMatchImageCache!
            }
            if self.computeCategory != nil {
                map["ComputeCategory"] = self.computeCategory!
            }
            if self.containerGroupName != nil {
                map["ContainerGroupName"] = self.containerGroupName!
            }
            if self.containers != nil {
                var tmp : [Any] = []
                for k in self.containers! {
                    tmp.append(k.toMap())
                }
                map["Containers"] = tmp
            }
            if self.costOptimization != nil {
                map["CostOptimization"] = self.costOptimization!
            }
            if self.cpu != nil {
                map["Cpu"] = self.cpu!
            }
            if self.cpuOptionsCore != nil {
                map["CpuOptionsCore"] = self.cpuOptionsCore!
            }
            if self.cpuOptionsThreadsPerCore != nil {
                map["CpuOptionsThreadsPerCore"] = self.cpuOptionsThreadsPerCore!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.dataCacheBucket != nil {
                map["DataCacheBucket"] = self.dataCacheBucket!
            }
            if self.dataCacheBurstingEnabled != nil {
                map["DataCacheBurstingEnabled"] = self.dataCacheBurstingEnabled!
            }
            if self.dataCachePL != nil {
                map["DataCachePL"] = self.dataCachePL!
            }
            if self.dataCacheProvisionedIops != nil {
                map["DataCacheProvisionedIops"] = self.dataCacheProvisionedIops!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.dnsConfigNameServers != nil {
                map["DnsConfigNameServers"] = self.dnsConfigNameServers!
            }
            if self.dnsConfigOptions != nil {
                var tmp : [Any] = []
                for k in self.dnsConfigOptions! {
                    tmp.append(k.toMap())
                }
                map["DnsConfigOptions"] = tmp
            }
            if self.dnsConfigSearches != nil {
                map["DnsConfigSearches"] = self.dnsConfigSearches!
            }
            if self.dnsPolicy != nil {
                map["DnsPolicy"] = self.dnsPolicy!
            }
            if self.egressBandwidth != nil {
                map["EgressBandwidth"] = self.egressBandwidth!
            }
            if self.eipBandwidth != nil {
                map["EipBandwidth"] = self.eipBandwidth!
            }
            if self.eipCommonBandwidthPackage != nil {
                map["EipCommonBandwidthPackage"] = self.eipCommonBandwidthPackage!
            }
            if self.eipISP != nil {
                map["EipISP"] = self.eipISP!
            }
            if self.eipPublicIpAddressPoolId != nil {
                map["EipPublicIpAddressPoolId"] = self.eipPublicIpAddressPoolId!
            }
            if self.ephemeralStorage != nil {
                map["EphemeralStorage"] = self.ephemeralStorage!
            }
            if self.hostAliases != nil {
                var tmp : [Any] = []
                for k in self.hostAliases! {
                    tmp.append(k.toMap())
                }
                map["HostAliases"] = tmp
            }
            if self.hostName != nil {
                map["HostName"] = self.hostName!
            }
            if self.imageRegistryCredentials != nil {
                var tmp : [Any] = []
                for k in self.imageRegistryCredentials! {
                    tmp.append(k.toMap())
                }
                map["ImageRegistryCredentials"] = tmp
            }
            if self.imageSnapshotId != nil {
                map["ImageSnapshotId"] = self.imageSnapshotId!
            }
            if self.ingressBandwidth != nil {
                map["IngressBandwidth"] = self.ingressBandwidth!
            }
            if self.initContainers != nil {
                var tmp : [Any] = []
                for k in self.initContainers! {
                    tmp.append(k.toMap())
                }
                map["InitContainers"] = tmp
            }
            if self.instanceFamilyLevel != nil {
                map["InstanceFamilyLevel"] = self.instanceFamilyLevel!
            }
            if self.instanceTypes != nil {
                map["InstanceTypes"] = self.instanceTypes!
            }
            if self.ipv6AddressCount != nil {
                map["Ipv6AddressCount"] = self.ipv6AddressCount!
            }
            if self.lifecycleState != nil {
                map["LifecycleState"] = self.lifecycleState!
            }
            if self.loadBalancerWeight != nil {
                map["LoadBalancerWeight"] = self.loadBalancerWeight!
            }
            if self.memory != nil {
                map["Memory"] = self.memory!
            }
            if self.ntpServers != nil {
                map["NtpServers"] = self.ntpServers!
            }
            if self.ramRoleName != nil {
                map["RamRoleName"] = self.ramRoleName!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.restartPolicy != nil {
                map["RestartPolicy"] = self.restartPolicy!
            }
            if self.scalingConfigurationId != nil {
                map["ScalingConfigurationId"] = self.scalingConfigurationId!
            }
            if self.scalingConfigurationName != nil {
                map["ScalingConfigurationName"] = self.scalingConfigurationName!
            }
            if self.scalingGroupId != nil {
                map["ScalingGroupId"] = self.scalingGroupId!
            }
            if self.securityContextSysCtls != nil {
                var tmp : [Any] = []
                for k in self.securityContextSysCtls! {
                    tmp.append(k.toMap())
                }
                map["SecurityContextSysCtls"] = tmp
            }
            if self.securityGroupId != nil {
                map["SecurityGroupId"] = self.securityGroupId!
            }
            if self.slsEnable != nil {
                map["SlsEnable"] = self.slsEnable!
            }
            if self.spotPriceLimit != nil {
                map["SpotPriceLimit"] = self.spotPriceLimit!
            }
            if self.spotStrategy != nil {
                map["SpotStrategy"] = self.spotStrategy!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            if self.terminationGracePeriodSeconds != nil {
                map["TerminationGracePeriodSeconds"] = self.terminationGracePeriodSeconds!
            }
            if self.volumes != nil {
                var tmp : [Any] = []
                for k in self.volumes! {
                    tmp.append(k.toMap())
                }
                map["Volumes"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AcrRegistryInfos") && dict["AcrRegistryInfos"] != nil {
                var tmp : [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.AcrRegistryInfos] = []
                for v in dict["AcrRegistryInfos"] as! [Any] {
                    var model = DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.AcrRegistryInfos()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.acrRegistryInfos = tmp
            }
            if dict.keys.contains("ActiveDeadlineSeconds") && dict["ActiveDeadlineSeconds"] != nil {
                self.activeDeadlineSeconds = dict["ActiveDeadlineSeconds"] as! Int32
            }
            if dict.keys.contains("AutoCreateEip") && dict["AutoCreateEip"] != nil {
                self.autoCreateEip = dict["AutoCreateEip"] as! Bool
            }
            if dict.keys.contains("AutoMatchImageCache") && dict["AutoMatchImageCache"] != nil {
                self.autoMatchImageCache = dict["AutoMatchImageCache"] as! Bool
            }
            if dict.keys.contains("ComputeCategory") && dict["ComputeCategory"] != nil {
                self.computeCategory = dict["ComputeCategory"] as! [String]
            }
            if dict.keys.contains("ContainerGroupName") && dict["ContainerGroupName"] != nil {
                self.containerGroupName = dict["ContainerGroupName"] as! String
            }
            if dict.keys.contains("Containers") && dict["Containers"] != nil {
                var tmp : [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.Containers] = []
                for v in dict["Containers"] as! [Any] {
                    var model = DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.Containers()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.containers = tmp
            }
            if dict.keys.contains("CostOptimization") && dict["CostOptimization"] != nil {
                self.costOptimization = dict["CostOptimization"] as! Bool
            }
            if dict.keys.contains("Cpu") && dict["Cpu"] != nil {
                self.cpu = dict["Cpu"] as! Double
            }
            if dict.keys.contains("CpuOptionsCore") && dict["CpuOptionsCore"] != nil {
                self.cpuOptionsCore = dict["CpuOptionsCore"] as! Int32
            }
            if dict.keys.contains("CpuOptionsThreadsPerCore") && dict["CpuOptionsThreadsPerCore"] != nil {
                self.cpuOptionsThreadsPerCore = dict["CpuOptionsThreadsPerCore"] as! Int32
            }
            if dict.keys.contains("CreationTime") && dict["CreationTime"] != nil {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("DataCacheBucket") && dict["DataCacheBucket"] != nil {
                self.dataCacheBucket = dict["DataCacheBucket"] as! String
            }
            if dict.keys.contains("DataCacheBurstingEnabled") && dict["DataCacheBurstingEnabled"] != nil {
                self.dataCacheBurstingEnabled = dict["DataCacheBurstingEnabled"] as! Bool
            }
            if dict.keys.contains("DataCachePL") && dict["DataCachePL"] != nil {
                self.dataCachePL = dict["DataCachePL"] as! String
            }
            if dict.keys.contains("DataCacheProvisionedIops") && dict["DataCacheProvisionedIops"] != nil {
                self.dataCacheProvisionedIops = dict["DataCacheProvisionedIops"] as! Int32
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("DnsConfigNameServers") && dict["DnsConfigNameServers"] != nil {
                self.dnsConfigNameServers = dict["DnsConfigNameServers"] as! [String]
            }
            if dict.keys.contains("DnsConfigOptions") && dict["DnsConfigOptions"] != nil {
                var tmp : [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.DnsConfigOptions] = []
                for v in dict["DnsConfigOptions"] as! [Any] {
                    var model = DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.DnsConfigOptions()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.dnsConfigOptions = tmp
            }
            if dict.keys.contains("DnsConfigSearches") && dict["DnsConfigSearches"] != nil {
                self.dnsConfigSearches = dict["DnsConfigSearches"] as! [String]
            }
            if dict.keys.contains("DnsPolicy") && dict["DnsPolicy"] != nil {
                self.dnsPolicy = dict["DnsPolicy"] as! String
            }
            if dict.keys.contains("EgressBandwidth") && dict["EgressBandwidth"] != nil {
                self.egressBandwidth = dict["EgressBandwidth"] as! Int64
            }
            if dict.keys.contains("EipBandwidth") && dict["EipBandwidth"] != nil {
                self.eipBandwidth = dict["EipBandwidth"] as! Int32
            }
            if dict.keys.contains("EipCommonBandwidthPackage") && dict["EipCommonBandwidthPackage"] != nil {
                self.eipCommonBandwidthPackage = dict["EipCommonBandwidthPackage"] as! String
            }
            if dict.keys.contains("EipISP") && dict["EipISP"] != nil {
                self.eipISP = dict["EipISP"] as! String
            }
            if dict.keys.contains("EipPublicIpAddressPoolId") && dict["EipPublicIpAddressPoolId"] != nil {
                self.eipPublicIpAddressPoolId = dict["EipPublicIpAddressPoolId"] as! String
            }
            if dict.keys.contains("EphemeralStorage") && dict["EphemeralStorage"] != nil {
                self.ephemeralStorage = dict["EphemeralStorage"] as! Int32
            }
            if dict.keys.contains("HostAliases") && dict["HostAliases"] != nil {
                var tmp : [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.HostAliases] = []
                for v in dict["HostAliases"] as! [Any] {
                    var model = DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.HostAliases()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.hostAliases = tmp
            }
            if dict.keys.contains("HostName") && dict["HostName"] != nil {
                self.hostName = dict["HostName"] as! String
            }
            if dict.keys.contains("ImageRegistryCredentials") && dict["ImageRegistryCredentials"] != nil {
                var tmp : [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.ImageRegistryCredentials] = []
                for v in dict["ImageRegistryCredentials"] as! [Any] {
                    var model = DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.ImageRegistryCredentials()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.imageRegistryCredentials = tmp
            }
            if dict.keys.contains("ImageSnapshotId") && dict["ImageSnapshotId"] != nil {
                self.imageSnapshotId = dict["ImageSnapshotId"] as! String
            }
            if dict.keys.contains("IngressBandwidth") && dict["IngressBandwidth"] != nil {
                self.ingressBandwidth = dict["IngressBandwidth"] as! Int64
            }
            if dict.keys.contains("InitContainers") && dict["InitContainers"] != nil {
                var tmp : [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.InitContainers] = []
                for v in dict["InitContainers"] as! [Any] {
                    var model = DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.InitContainers()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.initContainers = tmp
            }
            if dict.keys.contains("InstanceFamilyLevel") && dict["InstanceFamilyLevel"] != nil {
                self.instanceFamilyLevel = dict["InstanceFamilyLevel"] as! String
            }
            if dict.keys.contains("InstanceTypes") && dict["InstanceTypes"] != nil {
                self.instanceTypes = dict["InstanceTypes"] as! [String]
            }
            if dict.keys.contains("Ipv6AddressCount") && dict["Ipv6AddressCount"] != nil {
                self.ipv6AddressCount = dict["Ipv6AddressCount"] as! Int32
            }
            if dict.keys.contains("LifecycleState") && dict["LifecycleState"] != nil {
                self.lifecycleState = dict["LifecycleState"] as! String
            }
            if dict.keys.contains("LoadBalancerWeight") && dict["LoadBalancerWeight"] != nil {
                self.loadBalancerWeight = dict["LoadBalancerWeight"] as! Int32
            }
            if dict.keys.contains("Memory") && dict["Memory"] != nil {
                self.memory = dict["Memory"] as! Double
            }
            if dict.keys.contains("NtpServers") && dict["NtpServers"] != nil {
                self.ntpServers = dict["NtpServers"] as! [String]
            }
            if dict.keys.contains("RamRoleName") && dict["RamRoleName"] != nil {
                self.ramRoleName = dict["RamRoleName"] as! String
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
                self.resourceGroupId = dict["ResourceGroupId"] as! String
            }
            if dict.keys.contains("RestartPolicy") && dict["RestartPolicy"] != nil {
                self.restartPolicy = dict["RestartPolicy"] as! String
            }
            if dict.keys.contains("ScalingConfigurationId") && dict["ScalingConfigurationId"] != nil {
                self.scalingConfigurationId = dict["ScalingConfigurationId"] as! String
            }
            if dict.keys.contains("ScalingConfigurationName") && dict["ScalingConfigurationName"] != nil {
                self.scalingConfigurationName = dict["ScalingConfigurationName"] as! String
            }
            if dict.keys.contains("ScalingGroupId") && dict["ScalingGroupId"] != nil {
                self.scalingGroupId = dict["ScalingGroupId"] as! String
            }
            if dict.keys.contains("SecurityContextSysCtls") && dict["SecurityContextSysCtls"] != nil {
                var tmp : [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.SecurityContextSysCtls] = []
                for v in dict["SecurityContextSysCtls"] as! [Any] {
                    var model = DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.SecurityContextSysCtls()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.securityContextSysCtls = tmp
            }
            if dict.keys.contains("SecurityGroupId") && dict["SecurityGroupId"] != nil {
                self.securityGroupId = dict["SecurityGroupId"] as! String
            }
            if dict.keys.contains("SlsEnable") && dict["SlsEnable"] != nil {
                self.slsEnable = dict["SlsEnable"] as! Bool
            }
            if dict.keys.contains("SpotPriceLimit") && dict["SpotPriceLimit"] != nil {
                self.spotPriceLimit = dict["SpotPriceLimit"] as! Double
            }
            if dict.keys.contains("SpotStrategy") && dict["SpotStrategy"] != nil {
                self.spotStrategy = dict["SpotStrategy"] as! String
            }
            if dict.keys.contains("Tags") && dict["Tags"] != nil {
                var tmp : [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.Tags] = []
                for v in dict["Tags"] as! [Any] {
                    var model = DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.Tags()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tags = tmp
            }
            if dict.keys.contains("TerminationGracePeriodSeconds") && dict["TerminationGracePeriodSeconds"] != nil {
                self.terminationGracePeriodSeconds = dict["TerminationGracePeriodSeconds"] as! Int32
            }
            if dict.keys.contains("Volumes") && dict["Volumes"] != nil {
                var tmp : [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.Volumes] = []
                for v in dict["Volumes"] as! [Any] {
                    var model = DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.Volumes()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.volumes = tmp
            }
        }
    }
    public var output: String?

    public var requestId: String?

    public var scalingConfiguration: DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.scalingConfiguration?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.output != nil {
            map["Output"] = self.output!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingConfiguration != nil {
            map["ScalingConfiguration"] = self.scalingConfiguration?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Output") && dict["Output"] != nil {
            self.output = dict["Output"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScalingConfiguration") && dict["ScalingConfiguration"] != nil {
            var model = DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration()
            model.fromMap(dict["ScalingConfiguration"] as! [String: Any])
            self.scalingConfiguration = model
        }
    }
}

public class DescribeEciScalingConfigurationDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEciScalingConfigurationDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeEciScalingConfigurationDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEciScalingConfigurationsRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var scalingConfigurationIds: [String]?

    public var scalingConfigurationNames: [String]?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.scalingConfigurationIds != nil {
            map["ScalingConfigurationIds"] = self.scalingConfigurationIds!
        }
        if self.scalingConfigurationNames != nil {
            map["ScalingConfigurationNames"] = self.scalingConfigurationNames!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") && dict["OwnerAccount"] != nil {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ScalingConfigurationIds") && dict["ScalingConfigurationIds"] != nil {
            self.scalingConfigurationIds = dict["ScalingConfigurationIds"] as! [String]
        }
        if dict.keys.contains("ScalingConfigurationNames") && dict["ScalingConfigurationNames"] != nil {
            self.scalingConfigurationNames = dict["ScalingConfigurationNames"] as! [String]
        }
        if dict.keys.contains("ScalingGroupId") && dict["ScalingGroupId"] != nil {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
    }
}

public class DescribeEciScalingConfigurationsResponseBody : Tea.TeaModel {
    public class ScalingConfigurations : Tea.TeaModel {
        public class AcrRegistryInfos : Tea.TeaModel {
            public var domains: [String]?

            public var instanceId: String?

            public var instanceName: String?

            public var regionId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.domains != nil {
                    map["Domains"] = self.domains!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.instanceName != nil {
                    map["InstanceName"] = self.instanceName!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Domains") && dict["Domains"] != nil {
                    self.domains = dict["Domains"] as! [String]
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
                    self.instanceName = dict["InstanceName"] as! String
                }
                if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                    self.regionId = dict["RegionId"] as! String
                }
            }
        }
        public class Containers : Tea.TeaModel {
            public class EnvironmentVars : Tea.TeaModel {
                public var fieldRefFieldPath: String?

                public var key: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.fieldRefFieldPath != nil {
                        map["FieldRefFieldPath"] = self.fieldRefFieldPath!
                    }
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("FieldRefFieldPath") && dict["FieldRefFieldPath"] != nil {
                        self.fieldRefFieldPath = dict["FieldRefFieldPath"] as! String
                    }
                    if dict.keys.contains("Key") && dict["Key"] != nil {
                        self.key = dict["Key"] as! String
                    }
                    if dict.keys.contains("Value") && dict["Value"] != nil {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class Ports : Tea.TeaModel {
                public var port: Int32?

                public var protocol_: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.port != nil {
                        map["Port"] = self.port!
                    }
                    if self.protocol_ != nil {
                        map["Protocol"] = self.protocol_!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Port") && dict["Port"] != nil {
                        self.port = dict["Port"] as! Int32
                    }
                    if dict.keys.contains("Protocol") && dict["Protocol"] != nil {
                        self.protocol_ = dict["Protocol"] as! String
                    }
                }
            }
            public class VolumeMounts : Tea.TeaModel {
                public var mountPath: String?

                public var mountPropagation: String?

                public var name: String?

                public var readOnly: Bool?

                public var subPath: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.mountPath != nil {
                        map["MountPath"] = self.mountPath!
                    }
                    if self.mountPropagation != nil {
                        map["MountPropagation"] = self.mountPropagation!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.readOnly != nil {
                        map["ReadOnly"] = self.readOnly!
                    }
                    if self.subPath != nil {
                        map["SubPath"] = self.subPath!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("MountPath") && dict["MountPath"] != nil {
                        self.mountPath = dict["MountPath"] as! String
                    }
                    if dict.keys.contains("MountPropagation") && dict["MountPropagation"] != nil {
                        self.mountPropagation = dict["MountPropagation"] as! String
                    }
                    if dict.keys.contains("Name") && dict["Name"] != nil {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("ReadOnly") && dict["ReadOnly"] != nil {
                        self.readOnly = dict["ReadOnly"] as! Bool
                    }
                    if dict.keys.contains("SubPath") && dict["SubPath"] != nil {
                        self.subPath = dict["SubPath"] as! String
                    }
                }
            }
            public var args: [String]?

            public var commands: [String]?

            public var cpu: Double?

            public var environmentVars: [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.Containers.EnvironmentVars]?

            public var gpu: Int32?

            public var image: String?

            public var imagePullPolicy: String?

            public var lifecyclePostStartHandlerExecs: [String]?

            public var lifecyclePostStartHandlerHttpGetHost: String?

            public var lifecyclePostStartHandlerHttpGetPath: String?

            public var lifecyclePostStartHandlerHttpGetPort: Int32?

            public var lifecyclePostStartHandlerHttpGetScheme: String?

            public var lifecyclePostStartHandlerTcpSocketHost: String?

            public var lifecyclePostStartHandlerTcpSocketPort: Int32?

            public var lifecyclePreStopHandlerExecs: [String]?

            public var lifecyclePreStopHandlerHttpGetHost: String?

            public var lifecyclePreStopHandlerHttpGetPath: String?

            public var lifecyclePreStopHandlerHttpGetPort: Int32?

            public var lifecyclePreStopHandlerHttpGetScheme: String?

            public var lifecyclePreStopHandlerTcpSocketHost: String?

            public var lifecyclePreStopHandlerTcpSocketPort: Int32?

            public var livenessProbeExecCommands: [String]?

            public var livenessProbeFailureThreshold: Int32?

            public var livenessProbeHttpGetPath: String?

            public var livenessProbeHttpGetPort: Int32?

            public var livenessProbeHttpGetScheme: String?

            public var livenessProbeInitialDelaySeconds: Int32?

            public var livenessProbePeriodSeconds: Int32?

            public var livenessProbeSuccessThreshold: Int32?

            public var livenessProbeTcpSocketPort: Int32?

            public var livenessProbeTimeoutSeconds: Int32?

            public var memory: Double?

            public var name: String?

            public var ports: [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.Containers.Ports]?

            public var readinessProbeExecCommands: [String]?

            public var readinessProbeFailureThreshold: Int32?

            public var readinessProbeHttpGetPath: String?

            public var readinessProbeHttpGetPort: Int32?

            public var readinessProbeHttpGetScheme: String?

            public var readinessProbeInitialDelaySeconds: Int32?

            public var readinessProbePeriodSeconds: Int32?

            public var readinessProbeSuccessThreshold: Int32?

            public var readinessProbeTcpSocketPort: Int32?

            public var readinessProbeTimeoutSeconds: Int32?

            public var securityContextCapabilityAdds: [String]?

            public var securityContextReadOnlyRootFilesystem: Bool?

            public var securityContextRunAsUser: Int64?

            public var stdin: Bool?

            public var stdinOnce: Bool?

            public var tty: Bool?

            public var volumeMounts: [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.Containers.VolumeMounts]?

            public var workingDir: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.args != nil {
                    map["Args"] = self.args!
                }
                if self.commands != nil {
                    map["Commands"] = self.commands!
                }
                if self.cpu != nil {
                    map["Cpu"] = self.cpu!
                }
                if self.environmentVars != nil {
                    var tmp : [Any] = []
                    for k in self.environmentVars! {
                        tmp.append(k.toMap())
                    }
                    map["EnvironmentVars"] = tmp
                }
                if self.gpu != nil {
                    map["Gpu"] = self.gpu!
                }
                if self.image != nil {
                    map["Image"] = self.image!
                }
                if self.imagePullPolicy != nil {
                    map["ImagePullPolicy"] = self.imagePullPolicy!
                }
                if self.lifecyclePostStartHandlerExecs != nil {
                    map["LifecyclePostStartHandlerExecs"] = self.lifecyclePostStartHandlerExecs!
                }
                if self.lifecyclePostStartHandlerHttpGetHost != nil {
                    map["LifecyclePostStartHandlerHttpGetHost"] = self.lifecyclePostStartHandlerHttpGetHost!
                }
                if self.lifecyclePostStartHandlerHttpGetPath != nil {
                    map["LifecyclePostStartHandlerHttpGetPath"] = self.lifecyclePostStartHandlerHttpGetPath!
                }
                if self.lifecyclePostStartHandlerHttpGetPort != nil {
                    map["LifecyclePostStartHandlerHttpGetPort"] = self.lifecyclePostStartHandlerHttpGetPort!
                }
                if self.lifecyclePostStartHandlerHttpGetScheme != nil {
                    map["LifecyclePostStartHandlerHttpGetScheme"] = self.lifecyclePostStartHandlerHttpGetScheme!
                }
                if self.lifecyclePostStartHandlerTcpSocketHost != nil {
                    map["LifecyclePostStartHandlerTcpSocketHost"] = self.lifecyclePostStartHandlerTcpSocketHost!
                }
                if self.lifecyclePostStartHandlerTcpSocketPort != nil {
                    map["LifecyclePostStartHandlerTcpSocketPort"] = self.lifecyclePostStartHandlerTcpSocketPort!
                }
                if self.lifecyclePreStopHandlerExecs != nil {
                    map["LifecyclePreStopHandlerExecs"] = self.lifecyclePreStopHandlerExecs!
                }
                if self.lifecyclePreStopHandlerHttpGetHost != nil {
                    map["LifecyclePreStopHandlerHttpGetHost"] = self.lifecyclePreStopHandlerHttpGetHost!
                }
                if self.lifecyclePreStopHandlerHttpGetPath != nil {
                    map["LifecyclePreStopHandlerHttpGetPath"] = self.lifecyclePreStopHandlerHttpGetPath!
                }
                if self.lifecyclePreStopHandlerHttpGetPort != nil {
                    map["LifecyclePreStopHandlerHttpGetPort"] = self.lifecyclePreStopHandlerHttpGetPort!
                }
                if self.lifecyclePreStopHandlerHttpGetScheme != nil {
                    map["LifecyclePreStopHandlerHttpGetScheme"] = self.lifecyclePreStopHandlerHttpGetScheme!
                }
                if self.lifecyclePreStopHandlerTcpSocketHost != nil {
                    map["LifecyclePreStopHandlerTcpSocketHost"] = self.lifecyclePreStopHandlerTcpSocketHost!
                }
                if self.lifecyclePreStopHandlerTcpSocketPort != nil {
                    map["LifecyclePreStopHandlerTcpSocketPort"] = self.lifecyclePreStopHandlerTcpSocketPort!
                }
                if self.livenessProbeExecCommands != nil {
                    map["LivenessProbeExecCommands"] = self.livenessProbeExecCommands!
                }
                if self.livenessProbeFailureThreshold != nil {
                    map["LivenessProbeFailureThreshold"] = self.livenessProbeFailureThreshold!
                }
                if self.livenessProbeHttpGetPath != nil {
                    map["LivenessProbeHttpGetPath"] = self.livenessProbeHttpGetPath!
                }
                if self.livenessProbeHttpGetPort != nil {
                    map["LivenessProbeHttpGetPort"] = self.livenessProbeHttpGetPort!
                }
                if self.livenessProbeHttpGetScheme != nil {
                    map["LivenessProbeHttpGetScheme"] = self.livenessProbeHttpGetScheme!
                }
                if self.livenessProbeInitialDelaySeconds != nil {
                    map["LivenessProbeInitialDelaySeconds"] = self.livenessProbeInitialDelaySeconds!
                }
                if self.livenessProbePeriodSeconds != nil {
                    map["LivenessProbePeriodSeconds"] = self.livenessProbePeriodSeconds!
                }
                if self.livenessProbeSuccessThreshold != nil {
                    map["LivenessProbeSuccessThreshold"] = self.livenessProbeSuccessThreshold!
                }
                if self.livenessProbeTcpSocketPort != nil {
                    map["LivenessProbeTcpSocketPort"] = self.livenessProbeTcpSocketPort!
                }
                if self.livenessProbeTimeoutSeconds != nil {
                    map["LivenessProbeTimeoutSeconds"] = self.livenessProbeTimeoutSeconds!
                }
                if self.memory != nil {
                    map["Memory"] = self.memory!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.ports != nil {
                    var tmp : [Any] = []
                    for k in self.ports! {
                        tmp.append(k.toMap())
                    }
                    map["Ports"] = tmp
                }
                if self.readinessProbeExecCommands != nil {
                    map["ReadinessProbeExecCommands"] = self.readinessProbeExecCommands!
                }
                if self.readinessProbeFailureThreshold != nil {
                    map["ReadinessProbeFailureThreshold"] = self.readinessProbeFailureThreshold!
                }
                if self.readinessProbeHttpGetPath != nil {
                    map["ReadinessProbeHttpGetPath"] = self.readinessProbeHttpGetPath!
                }
                if self.readinessProbeHttpGetPort != nil {
                    map["ReadinessProbeHttpGetPort"] = self.readinessProbeHttpGetPort!
                }
                if self.readinessProbeHttpGetScheme != nil {
                    map["ReadinessProbeHttpGetScheme"] = self.readinessProbeHttpGetScheme!
                }
                if self.readinessProbeInitialDelaySeconds != nil {
                    map["ReadinessProbeInitialDelaySeconds"] = self.readinessProbeInitialDelaySeconds!
                }
                if self.readinessProbePeriodSeconds != nil {
                    map["ReadinessProbePeriodSeconds"] = self.readinessProbePeriodSeconds!
                }
                if self.readinessProbeSuccessThreshold != nil {
                    map["ReadinessProbeSuccessThreshold"] = self.readinessProbeSuccessThreshold!
                }
                if self.readinessProbeTcpSocketPort != nil {
                    map["ReadinessProbeTcpSocketPort"] = self.readinessProbeTcpSocketPort!
                }
                if self.readinessProbeTimeoutSeconds != nil {
                    map["ReadinessProbeTimeoutSeconds"] = self.readinessProbeTimeoutSeconds!
                }
                if self.securityContextCapabilityAdds != nil {
                    map["SecurityContextCapabilityAdds"] = self.securityContextCapabilityAdds!
                }
                if self.securityContextReadOnlyRootFilesystem != nil {
                    map["SecurityContextReadOnlyRootFilesystem"] = self.securityContextReadOnlyRootFilesystem!
                }
                if self.securityContextRunAsUser != nil {
                    map["SecurityContextRunAsUser"] = self.securityContextRunAsUser!
                }
                if self.stdin != nil {
                    map["Stdin"] = self.stdin!
                }
                if self.stdinOnce != nil {
                    map["StdinOnce"] = self.stdinOnce!
                }
                if self.tty != nil {
                    map["Tty"] = self.tty!
                }
                if self.volumeMounts != nil {
                    var tmp : [Any] = []
                    for k in self.volumeMounts! {
                        tmp.append(k.toMap())
                    }
                    map["VolumeMounts"] = tmp
                }
                if self.workingDir != nil {
                    map["WorkingDir"] = self.workingDir!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Args") && dict["Args"] != nil {
                    self.args = dict["Args"] as! [String]
                }
                if dict.keys.contains("Commands") && dict["Commands"] != nil {
                    self.commands = dict["Commands"] as! [String]
                }
                if dict.keys.contains("Cpu") && dict["Cpu"] != nil {
                    self.cpu = dict["Cpu"] as! Double
                }
                if dict.keys.contains("EnvironmentVars") && dict["EnvironmentVars"] != nil {
                    var tmp : [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.Containers.EnvironmentVars] = []
                    for v in dict["EnvironmentVars"] as! [Any] {
                        var model = DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.Containers.EnvironmentVars()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.environmentVars = tmp
                }
                if dict.keys.contains("Gpu") && dict["Gpu"] != nil {
                    self.gpu = dict["Gpu"] as! Int32
                }
                if dict.keys.contains("Image") && dict["Image"] != nil {
                    self.image = dict["Image"] as! String
                }
                if dict.keys.contains("ImagePullPolicy") && dict["ImagePullPolicy"] != nil {
                    self.imagePullPolicy = dict["ImagePullPolicy"] as! String
                }
                if dict.keys.contains("LifecyclePostStartHandlerExecs") && dict["LifecyclePostStartHandlerExecs"] != nil {
                    self.lifecyclePostStartHandlerExecs = dict["LifecyclePostStartHandlerExecs"] as! [String]
                }
                if dict.keys.contains("LifecyclePostStartHandlerHttpGetHost") && dict["LifecyclePostStartHandlerHttpGetHost"] != nil {
                    self.lifecyclePostStartHandlerHttpGetHost = dict["LifecyclePostStartHandlerHttpGetHost"] as! String
                }
                if dict.keys.contains("LifecyclePostStartHandlerHttpGetPath") && dict["LifecyclePostStartHandlerHttpGetPath"] != nil {
                    self.lifecyclePostStartHandlerHttpGetPath = dict["LifecyclePostStartHandlerHttpGetPath"] as! String
                }
                if dict.keys.contains("LifecyclePostStartHandlerHttpGetPort") && dict["LifecyclePostStartHandlerHttpGetPort"] != nil {
                    self.lifecyclePostStartHandlerHttpGetPort = dict["LifecyclePostStartHandlerHttpGetPort"] as! Int32
                }
                if dict.keys.contains("LifecyclePostStartHandlerHttpGetScheme") && dict["LifecyclePostStartHandlerHttpGetScheme"] != nil {
                    self.lifecyclePostStartHandlerHttpGetScheme = dict["LifecyclePostStartHandlerHttpGetScheme"] as! String
                }
                if dict.keys.contains("LifecyclePostStartHandlerTcpSocketHost") && dict["LifecyclePostStartHandlerTcpSocketHost"] != nil {
                    self.lifecyclePostStartHandlerTcpSocketHost = dict["LifecyclePostStartHandlerTcpSocketHost"] as! String
                }
                if dict.keys.contains("LifecyclePostStartHandlerTcpSocketPort") && dict["LifecyclePostStartHandlerTcpSocketPort"] != nil {
                    self.lifecyclePostStartHandlerTcpSocketPort = dict["LifecyclePostStartHandlerTcpSocketPort"] as! Int32
                }
                if dict.keys.contains("LifecyclePreStopHandlerExecs") && dict["LifecyclePreStopHandlerExecs"] != nil {
                    self.lifecyclePreStopHandlerExecs = dict["LifecyclePreStopHandlerExecs"] as! [String]
                }
                if dict.keys.contains("LifecyclePreStopHandlerHttpGetHost") && dict["LifecyclePreStopHandlerHttpGetHost"] != nil {
                    self.lifecyclePreStopHandlerHttpGetHost = dict["LifecyclePreStopHandlerHttpGetHost"] as! String
                }
                if dict.keys.contains("LifecyclePreStopHandlerHttpGetPath") && dict["LifecyclePreStopHandlerHttpGetPath"] != nil {
                    self.lifecyclePreStopHandlerHttpGetPath = dict["LifecyclePreStopHandlerHttpGetPath"] as! String
                }
                if dict.keys.contains("LifecyclePreStopHandlerHttpGetPort") && dict["LifecyclePreStopHandlerHttpGetPort"] != nil {
                    self.lifecyclePreStopHandlerHttpGetPort = dict["LifecyclePreStopHandlerHttpGetPort"] as! Int32
                }
                if dict.keys.contains("LifecyclePreStopHandlerHttpGetScheme") && dict["LifecyclePreStopHandlerHttpGetScheme"] != nil {
                    self.lifecyclePreStopHandlerHttpGetScheme = dict["LifecyclePreStopHandlerHttpGetScheme"] as! String
                }
                if dict.keys.contains("LifecyclePreStopHandlerTcpSocketHost") && dict["LifecyclePreStopHandlerTcpSocketHost"] != nil {
                    self.lifecyclePreStopHandlerTcpSocketHost = dict["LifecyclePreStopHandlerTcpSocketHost"] as! String
                }
                if dict.keys.contains("LifecyclePreStopHandlerTcpSocketPort") && dict["LifecyclePreStopHandlerTcpSocketPort"] != nil {
                    self.lifecyclePreStopHandlerTcpSocketPort = dict["LifecyclePreStopHandlerTcpSocketPort"] as! Int32
                }
                if dict.keys.contains("LivenessProbeExecCommands") && dict["LivenessProbeExecCommands"] != nil {
                    self.livenessProbeExecCommands = dict["LivenessProbeExecCommands"] as! [String]
                }
                if dict.keys.contains("LivenessProbeFailureThreshold") && dict["LivenessProbeFailureThreshold"] != nil {
                    self.livenessProbeFailureThreshold = dict["LivenessProbeFailureThreshold"] as! Int32
                }
                if dict.keys.contains("LivenessProbeHttpGetPath") && dict["LivenessProbeHttpGetPath"] != nil {
                    self.livenessProbeHttpGetPath = dict["LivenessProbeHttpGetPath"] as! String
                }
                if dict.keys.contains("LivenessProbeHttpGetPort") && dict["LivenessProbeHttpGetPort"] != nil {
                    self.livenessProbeHttpGetPort = dict["LivenessProbeHttpGetPort"] as! Int32
                }
                if dict.keys.contains("LivenessProbeHttpGetScheme") && dict["LivenessProbeHttpGetScheme"] != nil {
                    self.livenessProbeHttpGetScheme = dict["LivenessProbeHttpGetScheme"] as! String
                }
                if dict.keys.contains("LivenessProbeInitialDelaySeconds") && dict["LivenessProbeInitialDelaySeconds"] != nil {
                    self.livenessProbeInitialDelaySeconds = dict["LivenessProbeInitialDelaySeconds"] as! Int32
                }
                if dict.keys.contains("LivenessProbePeriodSeconds") && dict["LivenessProbePeriodSeconds"] != nil {
                    self.livenessProbePeriodSeconds = dict["LivenessProbePeriodSeconds"] as! Int32
                }
                if dict.keys.contains("LivenessProbeSuccessThreshold") && dict["LivenessProbeSuccessThreshold"] != nil {
                    self.livenessProbeSuccessThreshold = dict["LivenessProbeSuccessThreshold"] as! Int32
                }
                if dict.keys.contains("LivenessProbeTcpSocketPort") && dict["LivenessProbeTcpSocketPort"] != nil {
                    self.livenessProbeTcpSocketPort = dict["LivenessProbeTcpSocketPort"] as! Int32
                }
                if dict.keys.contains("LivenessProbeTimeoutSeconds") && dict["LivenessProbeTimeoutSeconds"] != nil {
                    self.livenessProbeTimeoutSeconds = dict["LivenessProbeTimeoutSeconds"] as! Int32
                }
                if dict.keys.contains("Memory") && dict["Memory"] != nil {
                    self.memory = dict["Memory"] as! Double
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Ports") && dict["Ports"] != nil {
                    var tmp : [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.Containers.Ports] = []
                    for v in dict["Ports"] as! [Any] {
                        var model = DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.Containers.Ports()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.ports = tmp
                }
                if dict.keys.contains("ReadinessProbeExecCommands") && dict["ReadinessProbeExecCommands"] != nil {
                    self.readinessProbeExecCommands = dict["ReadinessProbeExecCommands"] as! [String]
                }
                if dict.keys.contains("ReadinessProbeFailureThreshold") && dict["ReadinessProbeFailureThreshold"] != nil {
                    self.readinessProbeFailureThreshold = dict["ReadinessProbeFailureThreshold"] as! Int32
                }
                if dict.keys.contains("ReadinessProbeHttpGetPath") && dict["ReadinessProbeHttpGetPath"] != nil {
                    self.readinessProbeHttpGetPath = dict["ReadinessProbeHttpGetPath"] as! String
                }
                if dict.keys.contains("ReadinessProbeHttpGetPort") && dict["ReadinessProbeHttpGetPort"] != nil {
                    self.readinessProbeHttpGetPort = dict["ReadinessProbeHttpGetPort"] as! Int32
                }
                if dict.keys.contains("ReadinessProbeHttpGetScheme") && dict["ReadinessProbeHttpGetScheme"] != nil {
                    self.readinessProbeHttpGetScheme = dict["ReadinessProbeHttpGetScheme"] as! String
                }
                if dict.keys.contains("ReadinessProbeInitialDelaySeconds") && dict["ReadinessProbeInitialDelaySeconds"] != nil {
                    self.readinessProbeInitialDelaySeconds = dict["ReadinessProbeInitialDelaySeconds"] as! Int32
                }
                if dict.keys.contains("ReadinessProbePeriodSeconds") && dict["ReadinessProbePeriodSeconds"] != nil {
                    self.readinessProbePeriodSeconds = dict["ReadinessProbePeriodSeconds"] as! Int32
                }
                if dict.keys.contains("ReadinessProbeSuccessThreshold") && dict["ReadinessProbeSuccessThreshold"] != nil {
                    self.readinessProbeSuccessThreshold = dict["ReadinessProbeSuccessThreshold"] as! Int32
                }
                if dict.keys.contains("ReadinessProbeTcpSocketPort") && dict["ReadinessProbeTcpSocketPort"] != nil {
                    self.readinessProbeTcpSocketPort = dict["ReadinessProbeTcpSocketPort"] as! Int32
                }
                if dict.keys.contains("ReadinessProbeTimeoutSeconds") && dict["ReadinessProbeTimeoutSeconds"] != nil {
                    self.readinessProbeTimeoutSeconds = dict["ReadinessProbeTimeoutSeconds"] as! Int32
                }
                if dict.keys.contains("SecurityContextCapabilityAdds") && dict["SecurityContextCapabilityAdds"] != nil {
                    self.securityContextCapabilityAdds = dict["SecurityContextCapabilityAdds"] as! [String]
                }
                if dict.keys.contains("SecurityContextReadOnlyRootFilesystem") && dict["SecurityContextReadOnlyRootFilesystem"] != nil {
                    self.securityContextReadOnlyRootFilesystem = dict["SecurityContextReadOnlyRootFilesystem"] as! Bool
                }
                if dict.keys.contains("SecurityContextRunAsUser") && dict["SecurityContextRunAsUser"] != nil {
                    self.securityContextRunAsUser = dict["SecurityContextRunAsUser"] as! Int64
                }
                if dict.keys.contains("Stdin") && dict["Stdin"] != nil {
                    self.stdin = dict["Stdin"] as! Bool
                }
                if dict.keys.contains("StdinOnce") && dict["StdinOnce"] != nil {
                    self.stdinOnce = dict["StdinOnce"] as! Bool
                }
                if dict.keys.contains("Tty") && dict["Tty"] != nil {
                    self.tty = dict["Tty"] as! Bool
                }
                if dict.keys.contains("VolumeMounts") && dict["VolumeMounts"] != nil {
                    var tmp : [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.Containers.VolumeMounts] = []
                    for v in dict["VolumeMounts"] as! [Any] {
                        var model = DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.Containers.VolumeMounts()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.volumeMounts = tmp
                }
                if dict.keys.contains("WorkingDir") && dict["WorkingDir"] != nil {
                    self.workingDir = dict["WorkingDir"] as! String
                }
            }
        }
        public class DnsConfigOptions : Tea.TeaModel {
            public var name: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public class HostAliases : Tea.TeaModel {
            public var hostnames: [String]?

            public var ip: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.hostnames != nil {
                    map["Hostnames"] = self.hostnames!
                }
                if self.ip != nil {
                    map["Ip"] = self.ip!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Hostnames") && dict["Hostnames"] != nil {
                    self.hostnames = dict["Hostnames"] as! [String]
                }
                if dict.keys.contains("Ip") && dict["Ip"] != nil {
                    self.ip = dict["Ip"] as! String
                }
            }
        }
        public class ImageRegistryCredentials : Tea.TeaModel {
            public var password: String?

            public var server: String?

            public var userName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.password != nil {
                    map["Password"] = self.password!
                }
                if self.server != nil {
                    map["Server"] = self.server!
                }
                if self.userName != nil {
                    map["UserName"] = self.userName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Password") && dict["Password"] != nil {
                    self.password = dict["Password"] as! String
                }
                if dict.keys.contains("Server") && dict["Server"] != nil {
                    self.server = dict["Server"] as! String
                }
                if dict.keys.contains("UserName") && dict["UserName"] != nil {
                    self.userName = dict["UserName"] as! String
                }
            }
        }
        public class InitContainers : Tea.TeaModel {
            public class InitContainerEnvironmentVars : Tea.TeaModel {
                public var fieldRefFieldPath: String?

                public var key: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.fieldRefFieldPath != nil {
                        map["FieldRefFieldPath"] = self.fieldRefFieldPath!
                    }
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("FieldRefFieldPath") && dict["FieldRefFieldPath"] != nil {
                        self.fieldRefFieldPath = dict["FieldRefFieldPath"] as! String
                    }
                    if dict.keys.contains("Key") && dict["Key"] != nil {
                        self.key = dict["Key"] as! String
                    }
                    if dict.keys.contains("Value") && dict["Value"] != nil {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class InitContainerPorts : Tea.TeaModel {
                public var port: Int32?

                public var protocol_: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.port != nil {
                        map["Port"] = self.port!
                    }
                    if self.protocol_ != nil {
                        map["Protocol"] = self.protocol_!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Port") && dict["Port"] != nil {
                        self.port = dict["Port"] as! Int32
                    }
                    if dict.keys.contains("Protocol") && dict["Protocol"] != nil {
                        self.protocol_ = dict["Protocol"] as! String
                    }
                }
            }
            public class InitContainerVolumeMounts : Tea.TeaModel {
                public var mountPath: String?

                public var mountPropagation: String?

                public var name: String?

                public var readOnly: Bool?

                public var subPath: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.mountPath != nil {
                        map["MountPath"] = self.mountPath!
                    }
                    if self.mountPropagation != nil {
                        map["MountPropagation"] = self.mountPropagation!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.readOnly != nil {
                        map["ReadOnly"] = self.readOnly!
                    }
                    if self.subPath != nil {
                        map["SubPath"] = self.subPath!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("MountPath") && dict["MountPath"] != nil {
                        self.mountPath = dict["MountPath"] as! String
                    }
                    if dict.keys.contains("MountPropagation") && dict["MountPropagation"] != nil {
                        self.mountPropagation = dict["MountPropagation"] as! String
                    }
                    if dict.keys.contains("Name") && dict["Name"] != nil {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("ReadOnly") && dict["ReadOnly"] != nil {
                        self.readOnly = dict["ReadOnly"] as! Bool
                    }
                    if dict.keys.contains("SubPath") && dict["SubPath"] != nil {
                        self.subPath = dict["SubPath"] as! String
                    }
                }
            }
            public var cpu: Double?

            public var gpu: Int32?

            public var image: String?

            public var imagePullPolicy: String?

            public var initContainerArgs: [String]?

            public var initContainerCommands: [String]?

            public var initContainerEnvironmentVars: [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.InitContainers.InitContainerEnvironmentVars]?

            public var initContainerPorts: [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.InitContainers.InitContainerPorts]?

            public var initContainerVolumeMounts: [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.InitContainers.InitContainerVolumeMounts]?

            public var memory: Double?

            public var name: String?

            public var securityContextCapabilityAdds: [String]?

            public var securityContextReadOnlyRootFilesystem: Bool?

            public var securityContextRunAsUser: String?

            public var workingDir: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cpu != nil {
                    map["Cpu"] = self.cpu!
                }
                if self.gpu != nil {
                    map["Gpu"] = self.gpu!
                }
                if self.image != nil {
                    map["Image"] = self.image!
                }
                if self.imagePullPolicy != nil {
                    map["ImagePullPolicy"] = self.imagePullPolicy!
                }
                if self.initContainerArgs != nil {
                    map["InitContainerArgs"] = self.initContainerArgs!
                }
                if self.initContainerCommands != nil {
                    map["InitContainerCommands"] = self.initContainerCommands!
                }
                if self.initContainerEnvironmentVars != nil {
                    var tmp : [Any] = []
                    for k in self.initContainerEnvironmentVars! {
                        tmp.append(k.toMap())
                    }
                    map["InitContainerEnvironmentVars"] = tmp
                }
                if self.initContainerPorts != nil {
                    var tmp : [Any] = []
                    for k in self.initContainerPorts! {
                        tmp.append(k.toMap())
                    }
                    map["InitContainerPorts"] = tmp
                }
                if self.initContainerVolumeMounts != nil {
                    var tmp : [Any] = []
                    for k in self.initContainerVolumeMounts! {
                        tmp.append(k.toMap())
                    }
                    map["InitContainerVolumeMounts"] = tmp
                }
                if self.memory != nil {
                    map["Memory"] = self.memory!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.securityContextCapabilityAdds != nil {
                    map["SecurityContextCapabilityAdds"] = self.securityContextCapabilityAdds!
                }
                if self.securityContextReadOnlyRootFilesystem != nil {
                    map["SecurityContextReadOnlyRootFilesystem"] = self.securityContextReadOnlyRootFilesystem!
                }
                if self.securityContextRunAsUser != nil {
                    map["SecurityContextRunAsUser"] = self.securityContextRunAsUser!
                }
                if self.workingDir != nil {
                    map["WorkingDir"] = self.workingDir!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Cpu") && dict["Cpu"] != nil {
                    self.cpu = dict["Cpu"] as! Double
                }
                if dict.keys.contains("Gpu") && dict["Gpu"] != nil {
                    self.gpu = dict["Gpu"] as! Int32
                }
                if dict.keys.contains("Image") && dict["Image"] != nil {
                    self.image = dict["Image"] as! String
                }
                if dict.keys.contains("ImagePullPolicy") && dict["ImagePullPolicy"] != nil {
                    self.imagePullPolicy = dict["ImagePullPolicy"] as! String
                }
                if dict.keys.contains("InitContainerArgs") && dict["InitContainerArgs"] != nil {
                    self.initContainerArgs = dict["InitContainerArgs"] as! [String]
                }
                if dict.keys.contains("InitContainerCommands") && dict["InitContainerCommands"] != nil {
                    self.initContainerCommands = dict["InitContainerCommands"] as! [String]
                }
                if dict.keys.contains("InitContainerEnvironmentVars") && dict["InitContainerEnvironmentVars"] != nil {
                    var tmp : [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.InitContainers.InitContainerEnvironmentVars] = []
                    for v in dict["InitContainerEnvironmentVars"] as! [Any] {
                        var model = DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.InitContainers.InitContainerEnvironmentVars()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.initContainerEnvironmentVars = tmp
                }
                if dict.keys.contains("InitContainerPorts") && dict["InitContainerPorts"] != nil {
                    var tmp : [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.InitContainers.InitContainerPorts] = []
                    for v in dict["InitContainerPorts"] as! [Any] {
                        var model = DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.InitContainers.InitContainerPorts()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.initContainerPorts = tmp
                }
                if dict.keys.contains("InitContainerVolumeMounts") && dict["InitContainerVolumeMounts"] != nil {
                    var tmp : [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.InitContainers.InitContainerVolumeMounts] = []
                    for v in dict["InitContainerVolumeMounts"] as! [Any] {
                        var model = DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.InitContainers.InitContainerVolumeMounts()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.initContainerVolumeMounts = tmp
                }
                if dict.keys.contains("Memory") && dict["Memory"] != nil {
                    self.memory = dict["Memory"] as! Double
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("SecurityContextCapabilityAdds") && dict["SecurityContextCapabilityAdds"] != nil {
                    self.securityContextCapabilityAdds = dict["SecurityContextCapabilityAdds"] as! [String]
                }
                if dict.keys.contains("SecurityContextReadOnlyRootFilesystem") && dict["SecurityContextReadOnlyRootFilesystem"] != nil {
                    self.securityContextReadOnlyRootFilesystem = dict["SecurityContextReadOnlyRootFilesystem"] as! Bool
                }
                if dict.keys.contains("SecurityContextRunAsUser") && dict["SecurityContextRunAsUser"] != nil {
                    self.securityContextRunAsUser = dict["SecurityContextRunAsUser"] as! String
                }
                if dict.keys.contains("WorkingDir") && dict["WorkingDir"] != nil {
                    self.workingDir = dict["WorkingDir"] as! String
                }
            }
        }
        public class SecurityContextSysCtls : Tea.TeaModel {
            public var name: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public class Tags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") && dict["Key"] != nil {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public class Volumes : Tea.TeaModel {
            public class ConfigFileVolumeConfigFileToPaths : Tea.TeaModel {
                public var content: String?

                public var mode: Int32?

                public var path: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.content != nil {
                        map["Content"] = self.content!
                    }
                    if self.mode != nil {
                        map["Mode"] = self.mode!
                    }
                    if self.path != nil {
                        map["Path"] = self.path!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Content") && dict["Content"] != nil {
                        self.content = dict["Content"] as! String
                    }
                    if dict.keys.contains("Mode") && dict["Mode"] != nil {
                        self.mode = dict["Mode"] as! Int32
                    }
                    if dict.keys.contains("Path") && dict["Path"] != nil {
                        self.path = dict["Path"] as! String
                    }
                }
            }
            public var configFileVolumeConfigFileToPaths: [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.Volumes.ConfigFileVolumeConfigFileToPaths]?

            public var configFileVolumeDefaultMode: Int32?

            public var diskVolumeDiskId: String?

            public var diskVolumeDiskSize: Int32?

            public var diskVolumeFsType: String?

            public var emptyDirVolumeMedium: String?

            public var emptyDirVolumeSizeLimit: String?

            public var flexVolumeDriver: String?

            public var flexVolumeFsType: String?

            public var flexVolumeOptions: String?

            public var hostPathVolumePath: String?

            public var hostPathVolumeType: String?

            public var NFSVolumePath: String?

            public var NFSVolumeReadOnly: Bool?

            public var NFSVolumeServer: String?

            public var name: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.configFileVolumeConfigFileToPaths != nil {
                    var tmp : [Any] = []
                    for k in self.configFileVolumeConfigFileToPaths! {
                        tmp.append(k.toMap())
                    }
                    map["ConfigFileVolumeConfigFileToPaths"] = tmp
                }
                if self.configFileVolumeDefaultMode != nil {
                    map["ConfigFileVolumeDefaultMode"] = self.configFileVolumeDefaultMode!
                }
                if self.diskVolumeDiskId != nil {
                    map["DiskVolumeDiskId"] = self.diskVolumeDiskId!
                }
                if self.diskVolumeDiskSize != nil {
                    map["DiskVolumeDiskSize"] = self.diskVolumeDiskSize!
                }
                if self.diskVolumeFsType != nil {
                    map["DiskVolumeFsType"] = self.diskVolumeFsType!
                }
                if self.emptyDirVolumeMedium != nil {
                    map["EmptyDirVolumeMedium"] = self.emptyDirVolumeMedium!
                }
                if self.emptyDirVolumeSizeLimit != nil {
                    map["EmptyDirVolumeSizeLimit"] = self.emptyDirVolumeSizeLimit!
                }
                if self.flexVolumeDriver != nil {
                    map["FlexVolumeDriver"] = self.flexVolumeDriver!
                }
                if self.flexVolumeFsType != nil {
                    map["FlexVolumeFsType"] = self.flexVolumeFsType!
                }
                if self.flexVolumeOptions != nil {
                    map["FlexVolumeOptions"] = self.flexVolumeOptions!
                }
                if self.hostPathVolumePath != nil {
                    map["HostPathVolumePath"] = self.hostPathVolumePath!
                }
                if self.hostPathVolumeType != nil {
                    map["HostPathVolumeType"] = self.hostPathVolumeType!
                }
                if self.NFSVolumePath != nil {
                    map["NFSVolumePath"] = self.NFSVolumePath!
                }
                if self.NFSVolumeReadOnly != nil {
                    map["NFSVolumeReadOnly"] = self.NFSVolumeReadOnly!
                }
                if self.NFSVolumeServer != nil {
                    map["NFSVolumeServer"] = self.NFSVolumeServer!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ConfigFileVolumeConfigFileToPaths") && dict["ConfigFileVolumeConfigFileToPaths"] != nil {
                    var tmp : [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.Volumes.ConfigFileVolumeConfigFileToPaths] = []
                    for v in dict["ConfigFileVolumeConfigFileToPaths"] as! [Any] {
                        var model = DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.Volumes.ConfigFileVolumeConfigFileToPaths()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.configFileVolumeConfigFileToPaths = tmp
                }
                if dict.keys.contains("ConfigFileVolumeDefaultMode") && dict["ConfigFileVolumeDefaultMode"] != nil {
                    self.configFileVolumeDefaultMode = dict["ConfigFileVolumeDefaultMode"] as! Int32
                }
                if dict.keys.contains("DiskVolumeDiskId") && dict["DiskVolumeDiskId"] != nil {
                    self.diskVolumeDiskId = dict["DiskVolumeDiskId"] as! String
                }
                if dict.keys.contains("DiskVolumeDiskSize") && dict["DiskVolumeDiskSize"] != nil {
                    self.diskVolumeDiskSize = dict["DiskVolumeDiskSize"] as! Int32
                }
                if dict.keys.contains("DiskVolumeFsType") && dict["DiskVolumeFsType"] != nil {
                    self.diskVolumeFsType = dict["DiskVolumeFsType"] as! String
                }
                if dict.keys.contains("EmptyDirVolumeMedium") && dict["EmptyDirVolumeMedium"] != nil {
                    self.emptyDirVolumeMedium = dict["EmptyDirVolumeMedium"] as! String
                }
                if dict.keys.contains("EmptyDirVolumeSizeLimit") && dict["EmptyDirVolumeSizeLimit"] != nil {
                    self.emptyDirVolumeSizeLimit = dict["EmptyDirVolumeSizeLimit"] as! String
                }
                if dict.keys.contains("FlexVolumeDriver") && dict["FlexVolumeDriver"] != nil {
                    self.flexVolumeDriver = dict["FlexVolumeDriver"] as! String
                }
                if dict.keys.contains("FlexVolumeFsType") && dict["FlexVolumeFsType"] != nil {
                    self.flexVolumeFsType = dict["FlexVolumeFsType"] as! String
                }
                if dict.keys.contains("FlexVolumeOptions") && dict["FlexVolumeOptions"] != nil {
                    self.flexVolumeOptions = dict["FlexVolumeOptions"] as! String
                }
                if dict.keys.contains("HostPathVolumePath") && dict["HostPathVolumePath"] != nil {
                    self.hostPathVolumePath = dict["HostPathVolumePath"] as! String
                }
                if dict.keys.contains("HostPathVolumeType") && dict["HostPathVolumeType"] != nil {
                    self.hostPathVolumeType = dict["HostPathVolumeType"] as! String
                }
                if dict.keys.contains("NFSVolumePath") && dict["NFSVolumePath"] != nil {
                    self.NFSVolumePath = dict["NFSVolumePath"] as! String
                }
                if dict.keys.contains("NFSVolumeReadOnly") && dict["NFSVolumeReadOnly"] != nil {
                    self.NFSVolumeReadOnly = dict["NFSVolumeReadOnly"] as! Bool
                }
                if dict.keys.contains("NFSVolumeServer") && dict["NFSVolumeServer"] != nil {
                    self.NFSVolumeServer = dict["NFSVolumeServer"] as! String
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var acrRegistryInfos: [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.AcrRegistryInfos]?

        public var activeDeadlineSeconds: Int32?

        public var autoCreateEip: Bool?

        public var autoMatchImageCache: Bool?

        public var containerGroupName: String?

        public var containers: [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.Containers]?

        public var costOptimization: Bool?

        public var cpu: Double?

        public var cpuOptionsCore: Int32?

        public var cpuOptionsThreadsPerCore: Int32?

        public var creationTime: String?

        public var dataCacheBucket: String?

        public var dataCacheBurstingEnabled: Bool?

        public var dataCachePL: String?

        public var dataCacheProvisionedIops: Int32?

        public var description_: String?

        public var dnsConfigNameServers: [String]?

        public var dnsConfigOptions: [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.DnsConfigOptions]?

        public var dnsConfigSearches: [String]?

        public var dnsPolicy: String?

        public var egressBandwidth: Int64?

        public var eipBandwidth: Int32?

        public var ephemeralStorage: Int32?

        public var hostAliases: [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.HostAliases]?

        public var hostName: String?

        public var imageRegistryCredentials: [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.ImageRegistryCredentials]?

        public var imageSnapshotId: String?

        public var ingressBandwidth: Int64?

        public var initContainers: [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.InitContainers]?

        public var instanceFamilyLevel: String?

        public var instanceTypes: [String]?

        public var ipv6AddressCount: Int32?

        public var lifecycleState: String?

        public var loadBalancerWeight: Int32?

        public var memory: Double?

        public var ntpServers: [String]?

        public var ramRoleName: String?

        public var regionId: String?

        public var resourceGroupId: String?

        public var restartPolicy: String?

        public var scalingConfigurationId: String?

        public var scalingConfigurationName: String?

        public var scalingGroupId: String?

        public var securityContextSysCtls: [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.SecurityContextSysCtls]?

        public var securityGroupId: String?

        public var slsEnable: Bool?

        public var spotPriceLimit: Double?

        public var spotStrategy: String?

        public var tags: [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.Tags]?

        public var terminationGracePeriodSeconds: Int32?

        public var volumes: [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.Volumes]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.acrRegistryInfos != nil {
                var tmp : [Any] = []
                for k in self.acrRegistryInfos! {
                    tmp.append(k.toMap())
                }
                map["AcrRegistryInfos"] = tmp
            }
            if self.activeDeadlineSeconds != nil {
                map["ActiveDeadlineSeconds"] = self.activeDeadlineSeconds!
            }
            if self.autoCreateEip != nil {
                map["AutoCreateEip"] = self.autoCreateEip!
            }
            if self.autoMatchImageCache != nil {
                map["AutoMatchImageCache"] = self.autoMatchImageCache!
            }
            if self.containerGroupName != nil {
                map["ContainerGroupName"] = self.containerGroupName!
            }
            if self.containers != nil {
                var tmp : [Any] = []
                for k in self.containers! {
                    tmp.append(k.toMap())
                }
                map["Containers"] = tmp
            }
            if self.costOptimization != nil {
                map["CostOptimization"] = self.costOptimization!
            }
            if self.cpu != nil {
                map["Cpu"] = self.cpu!
            }
            if self.cpuOptionsCore != nil {
                map["CpuOptionsCore"] = self.cpuOptionsCore!
            }
            if self.cpuOptionsThreadsPerCore != nil {
                map["CpuOptionsThreadsPerCore"] = self.cpuOptionsThreadsPerCore!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.dataCacheBucket != nil {
                map["DataCacheBucket"] = self.dataCacheBucket!
            }
            if self.dataCacheBurstingEnabled != nil {
                map["DataCacheBurstingEnabled"] = self.dataCacheBurstingEnabled!
            }
            if self.dataCachePL != nil {
                map["DataCachePL"] = self.dataCachePL!
            }
            if self.dataCacheProvisionedIops != nil {
                map["DataCacheProvisionedIops"] = self.dataCacheProvisionedIops!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.dnsConfigNameServers != nil {
                map["DnsConfigNameServers"] = self.dnsConfigNameServers!
            }
            if self.dnsConfigOptions != nil {
                var tmp : [Any] = []
                for k in self.dnsConfigOptions! {
                    tmp.append(k.toMap())
                }
                map["DnsConfigOptions"] = tmp
            }
            if self.dnsConfigSearches != nil {
                map["DnsConfigSearches"] = self.dnsConfigSearches!
            }
            if self.dnsPolicy != nil {
                map["DnsPolicy"] = self.dnsPolicy!
            }
            if self.egressBandwidth != nil {
                map["EgressBandwidth"] = self.egressBandwidth!
            }
            if self.eipBandwidth != nil {
                map["EipBandwidth"] = self.eipBandwidth!
            }
            if self.ephemeralStorage != nil {
                map["EphemeralStorage"] = self.ephemeralStorage!
            }
            if self.hostAliases != nil {
                var tmp : [Any] = []
                for k in self.hostAliases! {
                    tmp.append(k.toMap())
                }
                map["HostAliases"] = tmp
            }
            if self.hostName != nil {
                map["HostName"] = self.hostName!
            }
            if self.imageRegistryCredentials != nil {
                var tmp : [Any] = []
                for k in self.imageRegistryCredentials! {
                    tmp.append(k.toMap())
                }
                map["ImageRegistryCredentials"] = tmp
            }
            if self.imageSnapshotId != nil {
                map["ImageSnapshotId"] = self.imageSnapshotId!
            }
            if self.ingressBandwidth != nil {
                map["IngressBandwidth"] = self.ingressBandwidth!
            }
            if self.initContainers != nil {
                var tmp : [Any] = []
                for k in self.initContainers! {
                    tmp.append(k.toMap())
                }
                map["InitContainers"] = tmp
            }
            if self.instanceFamilyLevel != nil {
                map["InstanceFamilyLevel"] = self.instanceFamilyLevel!
            }
            if self.instanceTypes != nil {
                map["InstanceTypes"] = self.instanceTypes!
            }
            if self.ipv6AddressCount != nil {
                map["Ipv6AddressCount"] = self.ipv6AddressCount!
            }
            if self.lifecycleState != nil {
                map["LifecycleState"] = self.lifecycleState!
            }
            if self.loadBalancerWeight != nil {
                map["LoadBalancerWeight"] = self.loadBalancerWeight!
            }
            if self.memory != nil {
                map["Memory"] = self.memory!
            }
            if self.ntpServers != nil {
                map["NtpServers"] = self.ntpServers!
            }
            if self.ramRoleName != nil {
                map["RamRoleName"] = self.ramRoleName!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.restartPolicy != nil {
                map["RestartPolicy"] = self.restartPolicy!
            }
            if self.scalingConfigurationId != nil {
                map["ScalingConfigurationId"] = self.scalingConfigurationId!
            }
            if self.scalingConfigurationName != nil {
                map["ScalingConfigurationName"] = self.scalingConfigurationName!
            }
            if self.scalingGroupId != nil {
                map["ScalingGroupId"] = self.scalingGroupId!
            }
            if self.securityContextSysCtls != nil {
                var tmp : [Any] = []
                for k in self.securityContextSysCtls! {
                    tmp.append(k.toMap())
                }
                map["SecurityContextSysCtls"] = tmp
            }
            if self.securityGroupId != nil {
                map["SecurityGroupId"] = self.securityGroupId!
            }
            if self.slsEnable != nil {
                map["SlsEnable"] = self.slsEnable!
            }
            if self.spotPriceLimit != nil {
                map["SpotPriceLimit"] = self.spotPriceLimit!
            }
            if self.spotStrategy != nil {
                map["SpotStrategy"] = self.spotStrategy!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            if self.terminationGracePeriodSeconds != nil {
                map["TerminationGracePeriodSeconds"] = self.terminationGracePeriodSeconds!
            }
            if self.volumes != nil {
                var tmp : [Any] = []
                for k in self.volumes! {
                    tmp.append(k.toMap())
                }
                map["Volumes"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AcrRegistryInfos") && dict["AcrRegistryInfos"] != nil {
                var tmp : [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.AcrRegistryInfos] = []
                for v in dict["AcrRegistryInfos"] as! [Any] {
                    var model = DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.AcrRegistryInfos()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.acrRegistryInfos = tmp
            }
            if dict.keys.contains("ActiveDeadlineSeconds") && dict["ActiveDeadlineSeconds"] != nil {
                self.activeDeadlineSeconds = dict["ActiveDeadlineSeconds"] as! Int32
            }
            if dict.keys.contains("AutoCreateEip") && dict["AutoCreateEip"] != nil {
                self.autoCreateEip = dict["AutoCreateEip"] as! Bool
            }
            if dict.keys.contains("AutoMatchImageCache") && dict["AutoMatchImageCache"] != nil {
                self.autoMatchImageCache = dict["AutoMatchImageCache"] as! Bool
            }
            if dict.keys.contains("ContainerGroupName") && dict["ContainerGroupName"] != nil {
                self.containerGroupName = dict["ContainerGroupName"] as! String
            }
            if dict.keys.contains("Containers") && dict["Containers"] != nil {
                var tmp : [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.Containers] = []
                for v in dict["Containers"] as! [Any] {
                    var model = DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.Containers()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.containers = tmp
            }
            if dict.keys.contains("CostOptimization") && dict["CostOptimization"] != nil {
                self.costOptimization = dict["CostOptimization"] as! Bool
            }
            if dict.keys.contains("Cpu") && dict["Cpu"] != nil {
                self.cpu = dict["Cpu"] as! Double
            }
            if dict.keys.contains("CpuOptionsCore") && dict["CpuOptionsCore"] != nil {
                self.cpuOptionsCore = dict["CpuOptionsCore"] as! Int32
            }
            if dict.keys.contains("CpuOptionsThreadsPerCore") && dict["CpuOptionsThreadsPerCore"] != nil {
                self.cpuOptionsThreadsPerCore = dict["CpuOptionsThreadsPerCore"] as! Int32
            }
            if dict.keys.contains("CreationTime") && dict["CreationTime"] != nil {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("DataCacheBucket") && dict["DataCacheBucket"] != nil {
                self.dataCacheBucket = dict["DataCacheBucket"] as! String
            }
            if dict.keys.contains("DataCacheBurstingEnabled") && dict["DataCacheBurstingEnabled"] != nil {
                self.dataCacheBurstingEnabled = dict["DataCacheBurstingEnabled"] as! Bool
            }
            if dict.keys.contains("DataCachePL") && dict["DataCachePL"] != nil {
                self.dataCachePL = dict["DataCachePL"] as! String
            }
            if dict.keys.contains("DataCacheProvisionedIops") && dict["DataCacheProvisionedIops"] != nil {
                self.dataCacheProvisionedIops = dict["DataCacheProvisionedIops"] as! Int32
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("DnsConfigNameServers") && dict["DnsConfigNameServers"] != nil {
                self.dnsConfigNameServers = dict["DnsConfigNameServers"] as! [String]
            }
            if dict.keys.contains("DnsConfigOptions") && dict["DnsConfigOptions"] != nil {
                var tmp : [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.DnsConfigOptions] = []
                for v in dict["DnsConfigOptions"] as! [Any] {
                    var model = DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.DnsConfigOptions()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.dnsConfigOptions = tmp
            }
            if dict.keys.contains("DnsConfigSearches") && dict["DnsConfigSearches"] != nil {
                self.dnsConfigSearches = dict["DnsConfigSearches"] as! [String]
            }
            if dict.keys.contains("DnsPolicy") && dict["DnsPolicy"] != nil {
                self.dnsPolicy = dict["DnsPolicy"] as! String
            }
            if dict.keys.contains("EgressBandwidth") && dict["EgressBandwidth"] != nil {
                self.egressBandwidth = dict["EgressBandwidth"] as! Int64
            }
            if dict.keys.contains("EipBandwidth") && dict["EipBandwidth"] != nil {
                self.eipBandwidth = dict["EipBandwidth"] as! Int32
            }
            if dict.keys.contains("EphemeralStorage") && dict["EphemeralStorage"] != nil {
                self.ephemeralStorage = dict["EphemeralStorage"] as! Int32
            }
            if dict.keys.contains("HostAliases") && dict["HostAliases"] != nil {
                var tmp : [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.HostAliases] = []
                for v in dict["HostAliases"] as! [Any] {
                    var model = DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.HostAliases()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.hostAliases = tmp
            }
            if dict.keys.contains("HostName") && dict["HostName"] != nil {
                self.hostName = dict["HostName"] as! String
            }
            if dict.keys.contains("ImageRegistryCredentials") && dict["ImageRegistryCredentials"] != nil {
                var tmp : [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.ImageRegistryCredentials] = []
                for v in dict["ImageRegistryCredentials"] as! [Any] {
                    var model = DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.ImageRegistryCredentials()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.imageRegistryCredentials = tmp
            }
            if dict.keys.contains("ImageSnapshotId") && dict["ImageSnapshotId"] != nil {
                self.imageSnapshotId = dict["ImageSnapshotId"] as! String
            }
            if dict.keys.contains("IngressBandwidth") && dict["IngressBandwidth"] != nil {
                self.ingressBandwidth = dict["IngressBandwidth"] as! Int64
            }
            if dict.keys.contains("InitContainers") && dict["InitContainers"] != nil {
                var tmp : [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.InitContainers] = []
                for v in dict["InitContainers"] as! [Any] {
                    var model = DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.InitContainers()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.initContainers = tmp
            }
            if dict.keys.contains("InstanceFamilyLevel") && dict["InstanceFamilyLevel"] != nil {
                self.instanceFamilyLevel = dict["InstanceFamilyLevel"] as! String
            }
            if dict.keys.contains("InstanceTypes") && dict["InstanceTypes"] != nil {
                self.instanceTypes = dict["InstanceTypes"] as! [String]
            }
            if dict.keys.contains("Ipv6AddressCount") && dict["Ipv6AddressCount"] != nil {
                self.ipv6AddressCount = dict["Ipv6AddressCount"] as! Int32
            }
            if dict.keys.contains("LifecycleState") && dict["LifecycleState"] != nil {
                self.lifecycleState = dict["LifecycleState"] as! String
            }
            if dict.keys.contains("LoadBalancerWeight") && dict["LoadBalancerWeight"] != nil {
                self.loadBalancerWeight = dict["LoadBalancerWeight"] as! Int32
            }
            if dict.keys.contains("Memory") && dict["Memory"] != nil {
                self.memory = dict["Memory"] as! Double
            }
            if dict.keys.contains("NtpServers") && dict["NtpServers"] != nil {
                self.ntpServers = dict["NtpServers"] as! [String]
            }
            if dict.keys.contains("RamRoleName") && dict["RamRoleName"] != nil {
                self.ramRoleName = dict["RamRoleName"] as! String
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
                self.resourceGroupId = dict["ResourceGroupId"] as! String
            }
            if dict.keys.contains("RestartPolicy") && dict["RestartPolicy"] != nil {
                self.restartPolicy = dict["RestartPolicy"] as! String
            }
            if dict.keys.contains("ScalingConfigurationId") && dict["ScalingConfigurationId"] != nil {
                self.scalingConfigurationId = dict["ScalingConfigurationId"] as! String
            }
            if dict.keys.contains("ScalingConfigurationName") && dict["ScalingConfigurationName"] != nil {
                self.scalingConfigurationName = dict["ScalingConfigurationName"] as! String
            }
            if dict.keys.contains("ScalingGroupId") && dict["ScalingGroupId"] != nil {
                self.scalingGroupId = dict["ScalingGroupId"] as! String
            }
            if dict.keys.contains("SecurityContextSysCtls") && dict["SecurityContextSysCtls"] != nil {
                var tmp : [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.SecurityContextSysCtls] = []
                for v in dict["SecurityContextSysCtls"] as! [Any] {
                    var model = DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.SecurityContextSysCtls()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.securityContextSysCtls = tmp
            }
            if dict.keys.contains("SecurityGroupId") && dict["SecurityGroupId"] != nil {
                self.securityGroupId = dict["SecurityGroupId"] as! String
            }
            if dict.keys.contains("SlsEnable") && dict["SlsEnable"] != nil {
                self.slsEnable = dict["SlsEnable"] as! Bool
            }
            if dict.keys.contains("SpotPriceLimit") && dict["SpotPriceLimit"] != nil {
                self.spotPriceLimit = dict["SpotPriceLimit"] as! Double
            }
            if dict.keys.contains("SpotStrategy") && dict["SpotStrategy"] != nil {
                self.spotStrategy = dict["SpotStrategy"] as! String
            }
            if dict.keys.contains("Tags") && dict["Tags"] != nil {
                var tmp : [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.Tags] = []
                for v in dict["Tags"] as! [Any] {
                    var model = DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.Tags()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tags = tmp
            }
            if dict.keys.contains("TerminationGracePeriodSeconds") && dict["TerminationGracePeriodSeconds"] != nil {
                self.terminationGracePeriodSeconds = dict["TerminationGracePeriodSeconds"] as! Int32
            }
            if dict.keys.contains("Volumes") && dict["Volumes"] != nil {
                var tmp : [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.Volumes] = []
                for v in dict["Volumes"] as! [Any] {
                    var model = DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.Volumes()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.volumes = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var scalingConfigurations: [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations]?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingConfigurations != nil {
            var tmp : [Any] = []
            for k in self.scalingConfigurations! {
                tmp.append(k.toMap())
            }
            map["ScalingConfigurations"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScalingConfigurations") && dict["ScalingConfigurations"] != nil {
            var tmp : [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations] = []
            for v in dict["ScalingConfigurations"] as! [Any] {
                var model = DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.scalingConfigurations = tmp
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeEciScalingConfigurationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEciScalingConfigurationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeEciScalingConfigurationsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLifecycleActionsRequest : Tea.TeaModel {
    public var lifecycleActionStatus: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingActivityId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lifecycleActionStatus != nil {
            map["LifecycleActionStatus"] = self.lifecycleActionStatus!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingActivityId != nil {
            map["ScalingActivityId"] = self.scalingActivityId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LifecycleActionStatus") && dict["LifecycleActionStatus"] != nil {
            self.lifecycleActionStatus = dict["LifecycleActionStatus"] as! String
        }
        if dict.keys.contains("MaxResults") && dict["MaxResults"] != nil {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") && dict["NextToken"] != nil {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScalingActivityId") && dict["ScalingActivityId"] != nil {
            self.scalingActivityId = dict["ScalingActivityId"] as! String
        }
    }
}

public class DescribeLifecycleActionsResponseBody : Tea.TeaModel {
    public class LifecycleActions : Tea.TeaModel {
        public var instanceIds: [String]?

        public var lifecycleActionResult: String?

        public var lifecycleActionStatus: String?

        public var lifecycleActionToken: String?

        public var lifecycleHookId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceIds != nil {
                map["InstanceIds"] = self.instanceIds!
            }
            if self.lifecycleActionResult != nil {
                map["LifecycleActionResult"] = self.lifecycleActionResult!
            }
            if self.lifecycleActionStatus != nil {
                map["LifecycleActionStatus"] = self.lifecycleActionStatus!
            }
            if self.lifecycleActionToken != nil {
                map["LifecycleActionToken"] = self.lifecycleActionToken!
            }
            if self.lifecycleHookId != nil {
                map["LifecycleHookId"] = self.lifecycleHookId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceIds") && dict["InstanceIds"] != nil {
                self.instanceIds = dict["InstanceIds"] as! [String]
            }
            if dict.keys.contains("LifecycleActionResult") && dict["LifecycleActionResult"] != nil {
                self.lifecycleActionResult = dict["LifecycleActionResult"] as! String
            }
            if dict.keys.contains("LifecycleActionStatus") && dict["LifecycleActionStatus"] != nil {
                self.lifecycleActionStatus = dict["LifecycleActionStatus"] as! String
            }
            if dict.keys.contains("LifecycleActionToken") && dict["LifecycleActionToken"] != nil {
                self.lifecycleActionToken = dict["LifecycleActionToken"] as! String
            }
            if dict.keys.contains("LifecycleHookId") && dict["LifecycleHookId"] != nil {
                self.lifecycleHookId = dict["LifecycleHookId"] as! String
            }
        }
    }
    public var lifecycleActions: [DescribeLifecycleActionsResponseBody.LifecycleActions]?

    public var maxResults: Int32?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lifecycleActions != nil {
            var tmp : [Any] = []
            for k in self.lifecycleActions! {
                tmp.append(k.toMap())
            }
            map["LifecycleActions"] = tmp
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LifecycleActions") && dict["LifecycleActions"] != nil {
            var tmp : [DescribeLifecycleActionsResponseBody.LifecycleActions] = []
            for v in dict["LifecycleActions"] as! [Any] {
                var model = DescribeLifecycleActionsResponseBody.LifecycleActions()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.lifecycleActions = tmp
        }
        if dict.keys.contains("MaxResults") && dict["MaxResults"] != nil {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") && dict["NextToken"] != nil {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeLifecycleActionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLifecycleActionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeLifecycleActionsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLifecycleHooksRequest : Tea.TeaModel {
    public var lifecycleHookIds: [String]?

    public var lifecycleHookName: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lifecycleHookIds != nil {
            map["LifecycleHookIds"] = self.lifecycleHookIds!
        }
        if self.lifecycleHookName != nil {
            map["LifecycleHookName"] = self.lifecycleHookName!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LifecycleHookIds") && dict["LifecycleHookIds"] != nil {
            self.lifecycleHookIds = dict["LifecycleHookIds"] as! [String]
        }
        if dict.keys.contains("LifecycleHookName") && dict["LifecycleHookName"] != nil {
            self.lifecycleHookName = dict["LifecycleHookName"] as! String
        }
        if dict.keys.contains("OwnerAccount") && dict["OwnerAccount"] != nil {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScalingGroupId") && dict["ScalingGroupId"] != nil {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
    }
}

public class DescribeLifecycleHooksResponseBody : Tea.TeaModel {
    public class LifecycleHooks : Tea.TeaModel {
        public var defaultResult: String?

        public var heartbeatTimeout: Int32?

        public var lifecycleHookId: String?

        public var lifecycleHookName: String?

        public var lifecycleHookStatus: String?

        public var lifecycleTransition: String?

        public var notificationArn: String?

        public var notificationMetadata: String?

        public var scalingGroupId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.defaultResult != nil {
                map["DefaultResult"] = self.defaultResult!
            }
            if self.heartbeatTimeout != nil {
                map["HeartbeatTimeout"] = self.heartbeatTimeout!
            }
            if self.lifecycleHookId != nil {
                map["LifecycleHookId"] = self.lifecycleHookId!
            }
            if self.lifecycleHookName != nil {
                map["LifecycleHookName"] = self.lifecycleHookName!
            }
            if self.lifecycleHookStatus != nil {
                map["LifecycleHookStatus"] = self.lifecycleHookStatus!
            }
            if self.lifecycleTransition != nil {
                map["LifecycleTransition"] = self.lifecycleTransition!
            }
            if self.notificationArn != nil {
                map["NotificationArn"] = self.notificationArn!
            }
            if self.notificationMetadata != nil {
                map["NotificationMetadata"] = self.notificationMetadata!
            }
            if self.scalingGroupId != nil {
                map["ScalingGroupId"] = self.scalingGroupId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DefaultResult") && dict["DefaultResult"] != nil {
                self.defaultResult = dict["DefaultResult"] as! String
            }
            if dict.keys.contains("HeartbeatTimeout") && dict["HeartbeatTimeout"] != nil {
                self.heartbeatTimeout = dict["HeartbeatTimeout"] as! Int32
            }
            if dict.keys.contains("LifecycleHookId") && dict["LifecycleHookId"] != nil {
                self.lifecycleHookId = dict["LifecycleHookId"] as! String
            }
            if dict.keys.contains("LifecycleHookName") && dict["LifecycleHookName"] != nil {
                self.lifecycleHookName = dict["LifecycleHookName"] as! String
            }
            if dict.keys.contains("LifecycleHookStatus") && dict["LifecycleHookStatus"] != nil {
                self.lifecycleHookStatus = dict["LifecycleHookStatus"] as! String
            }
            if dict.keys.contains("LifecycleTransition") && dict["LifecycleTransition"] != nil {
                self.lifecycleTransition = dict["LifecycleTransition"] as! String
            }
            if dict.keys.contains("NotificationArn") && dict["NotificationArn"] != nil {
                self.notificationArn = dict["NotificationArn"] as! String
            }
            if dict.keys.contains("NotificationMetadata") && dict["NotificationMetadata"] != nil {
                self.notificationMetadata = dict["NotificationMetadata"] as! String
            }
            if dict.keys.contains("ScalingGroupId") && dict["ScalingGroupId"] != nil {
                self.scalingGroupId = dict["ScalingGroupId"] as! String
            }
        }
    }
    public var lifecycleHooks: [DescribeLifecycleHooksResponseBody.LifecycleHooks]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lifecycleHooks != nil {
            var tmp : [Any] = []
            for k in self.lifecycleHooks! {
                tmp.append(k.toMap())
            }
            map["LifecycleHooks"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LifecycleHooks") && dict["LifecycleHooks"] != nil {
            var tmp : [DescribeLifecycleHooksResponseBody.LifecycleHooks] = []
            for v in dict["LifecycleHooks"] as! [Any] {
                var model = DescribeLifecycleHooksResponseBody.LifecycleHooks()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.lifecycleHooks = tmp
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeLifecycleHooksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLifecycleHooksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeLifecycleHooksResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLimitationRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
    }
}

public class DescribeLimitationResponseBody : Tea.TeaModel {
    public var maxNumberOfAlbServerGroup: Int32?

    public var maxNumberOfDBInstances: Int32?

    public var maxNumberOfLifecycleHooks: Int32?

    public var maxNumberOfLoadBalancers: Int32?

    public var maxNumberOfMaxSize: Int32?

    public var maxNumberOfMinSize: Int32?

    public var maxNumberOfNlbServerGroup: Int32?

    public var maxNumberOfNotificationConfigurations: Int32?

    public var maxNumberOfScalingConfigurations: Int32?

    public var maxNumberOfScalingGroups: Int32?

    public var maxNumberOfScalingInstances: Int32?

    public var maxNumberOfScalingRules: Int32?

    public var maxNumberOfScheduledTasks: Int32?

    public var maxNumberOfVServerGroups: Int32?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxNumberOfAlbServerGroup != nil {
            map["MaxNumberOfAlbServerGroup"] = self.maxNumberOfAlbServerGroup!
        }
        if self.maxNumberOfDBInstances != nil {
            map["MaxNumberOfDBInstances"] = self.maxNumberOfDBInstances!
        }
        if self.maxNumberOfLifecycleHooks != nil {
            map["MaxNumberOfLifecycleHooks"] = self.maxNumberOfLifecycleHooks!
        }
        if self.maxNumberOfLoadBalancers != nil {
            map["MaxNumberOfLoadBalancers"] = self.maxNumberOfLoadBalancers!
        }
        if self.maxNumberOfMaxSize != nil {
            map["MaxNumberOfMaxSize"] = self.maxNumberOfMaxSize!
        }
        if self.maxNumberOfMinSize != nil {
            map["MaxNumberOfMinSize"] = self.maxNumberOfMinSize!
        }
        if self.maxNumberOfNlbServerGroup != nil {
            map["MaxNumberOfNlbServerGroup"] = self.maxNumberOfNlbServerGroup!
        }
        if self.maxNumberOfNotificationConfigurations != nil {
            map["MaxNumberOfNotificationConfigurations"] = self.maxNumberOfNotificationConfigurations!
        }
        if self.maxNumberOfScalingConfigurations != nil {
            map["MaxNumberOfScalingConfigurations"] = self.maxNumberOfScalingConfigurations!
        }
        if self.maxNumberOfScalingGroups != nil {
            map["MaxNumberOfScalingGroups"] = self.maxNumberOfScalingGroups!
        }
        if self.maxNumberOfScalingInstances != nil {
            map["MaxNumberOfScalingInstances"] = self.maxNumberOfScalingInstances!
        }
        if self.maxNumberOfScalingRules != nil {
            map["MaxNumberOfScalingRules"] = self.maxNumberOfScalingRules!
        }
        if self.maxNumberOfScheduledTasks != nil {
            map["MaxNumberOfScheduledTasks"] = self.maxNumberOfScheduledTasks!
        }
        if self.maxNumberOfVServerGroups != nil {
            map["MaxNumberOfVServerGroups"] = self.maxNumberOfVServerGroups!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxNumberOfAlbServerGroup") && dict["MaxNumberOfAlbServerGroup"] != nil {
            self.maxNumberOfAlbServerGroup = dict["MaxNumberOfAlbServerGroup"] as! Int32
        }
        if dict.keys.contains("MaxNumberOfDBInstances") && dict["MaxNumberOfDBInstances"] != nil {
            self.maxNumberOfDBInstances = dict["MaxNumberOfDBInstances"] as! Int32
        }
        if dict.keys.contains("MaxNumberOfLifecycleHooks") && dict["MaxNumberOfLifecycleHooks"] != nil {
            self.maxNumberOfLifecycleHooks = dict["MaxNumberOfLifecycleHooks"] as! Int32
        }
        if dict.keys.contains("MaxNumberOfLoadBalancers") && dict["MaxNumberOfLoadBalancers"] != nil {
            self.maxNumberOfLoadBalancers = dict["MaxNumberOfLoadBalancers"] as! Int32
        }
        if dict.keys.contains("MaxNumberOfMaxSize") && dict["MaxNumberOfMaxSize"] != nil {
            self.maxNumberOfMaxSize = dict["MaxNumberOfMaxSize"] as! Int32
        }
        if dict.keys.contains("MaxNumberOfMinSize") && dict["MaxNumberOfMinSize"] != nil {
            self.maxNumberOfMinSize = dict["MaxNumberOfMinSize"] as! Int32
        }
        if dict.keys.contains("MaxNumberOfNlbServerGroup") && dict["MaxNumberOfNlbServerGroup"] != nil {
            self.maxNumberOfNlbServerGroup = dict["MaxNumberOfNlbServerGroup"] as! Int32
        }
        if dict.keys.contains("MaxNumberOfNotificationConfigurations") && dict["MaxNumberOfNotificationConfigurations"] != nil {
            self.maxNumberOfNotificationConfigurations = dict["MaxNumberOfNotificationConfigurations"] as! Int32
        }
        if dict.keys.contains("MaxNumberOfScalingConfigurations") && dict["MaxNumberOfScalingConfigurations"] != nil {
            self.maxNumberOfScalingConfigurations = dict["MaxNumberOfScalingConfigurations"] as! Int32
        }
        if dict.keys.contains("MaxNumberOfScalingGroups") && dict["MaxNumberOfScalingGroups"] != nil {
            self.maxNumberOfScalingGroups = dict["MaxNumberOfScalingGroups"] as! Int32
        }
        if dict.keys.contains("MaxNumberOfScalingInstances") && dict["MaxNumberOfScalingInstances"] != nil {
            self.maxNumberOfScalingInstances = dict["MaxNumberOfScalingInstances"] as! Int32
        }
        if dict.keys.contains("MaxNumberOfScalingRules") && dict["MaxNumberOfScalingRules"] != nil {
            self.maxNumberOfScalingRules = dict["MaxNumberOfScalingRules"] as! Int32
        }
        if dict.keys.contains("MaxNumberOfScheduledTasks") && dict["MaxNumberOfScheduledTasks"] != nil {
            self.maxNumberOfScheduledTasks = dict["MaxNumberOfScheduledTasks"] as! Int32
        }
        if dict.keys.contains("MaxNumberOfVServerGroups") && dict["MaxNumberOfVServerGroups"] != nil {
            self.maxNumberOfVServerGroups = dict["MaxNumberOfVServerGroups"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeLimitationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLimitationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeLimitationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeNotificationConfigurationsRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScalingGroupId") && dict["ScalingGroupId"] != nil {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
    }
}

public class DescribeNotificationConfigurationsResponseBody : Tea.TeaModel {
    public class NotificationConfigurationModels : Tea.TeaModel {
        public var notificationArn: String?

        public var notificationTypes: [String]?

        public var scalingGroupId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.notificationArn != nil {
                map["NotificationArn"] = self.notificationArn!
            }
            if self.notificationTypes != nil {
                map["NotificationTypes"] = self.notificationTypes!
            }
            if self.scalingGroupId != nil {
                map["ScalingGroupId"] = self.scalingGroupId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("NotificationArn") && dict["NotificationArn"] != nil {
                self.notificationArn = dict["NotificationArn"] as! String
            }
            if dict.keys.contains("NotificationTypes") && dict["NotificationTypes"] != nil {
                self.notificationTypes = dict["NotificationTypes"] as! [String]
            }
            if dict.keys.contains("ScalingGroupId") && dict["ScalingGroupId"] != nil {
                self.scalingGroupId = dict["ScalingGroupId"] as! String
            }
        }
    }
    public var notificationConfigurationModels: [DescribeNotificationConfigurationsResponseBody.NotificationConfigurationModels]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.notificationConfigurationModels != nil {
            var tmp : [Any] = []
            for k in self.notificationConfigurationModels! {
                tmp.append(k.toMap())
            }
            map["NotificationConfigurationModels"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NotificationConfigurationModels") && dict["NotificationConfigurationModels"] != nil {
            var tmp : [DescribeNotificationConfigurationsResponseBody.NotificationConfigurationModels] = []
            for v in dict["NotificationConfigurationModels"] as! [Any] {
                var model = DescribeNotificationConfigurationsResponseBody.NotificationConfigurationModels()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.notificationConfigurationModels = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeNotificationConfigurationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeNotificationConfigurationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeNotificationConfigurationsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeNotificationTypesRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
    }
}

public class DescribeNotificationTypesResponseBody : Tea.TeaModel {
    public var notificationTypes: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.notificationTypes != nil {
            map["NotificationTypes"] = self.notificationTypes!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NotificationTypes") && dict["NotificationTypes"] != nil {
            self.notificationTypes = dict["NotificationTypes"] as! [String]
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeNotificationTypesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeNotificationTypesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeNotificationTypesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeRegionsRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DescribeRegionsResponseBody : Tea.TeaModel {
    public class Regions : Tea.TeaModel {
        public var classicUnavailable: Bool?

        public var localName: String?

        public var regionEndpoint: String?

        public var regionId: String?

        public var vpcUnavailable: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.classicUnavailable != nil {
                map["ClassicUnavailable"] = self.classicUnavailable!
            }
            if self.localName != nil {
                map["LocalName"] = self.localName!
            }
            if self.regionEndpoint != nil {
                map["RegionEndpoint"] = self.regionEndpoint!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.vpcUnavailable != nil {
                map["VpcUnavailable"] = self.vpcUnavailable!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClassicUnavailable") && dict["ClassicUnavailable"] != nil {
                self.classicUnavailable = dict["ClassicUnavailable"] as! Bool
            }
            if dict.keys.contains("LocalName") && dict["LocalName"] != nil {
                self.localName = dict["LocalName"] as! String
            }
            if dict.keys.contains("RegionEndpoint") && dict["RegionEndpoint"] != nil {
                self.regionEndpoint = dict["RegionEndpoint"] as! String
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("VpcUnavailable") && dict["VpcUnavailable"] != nil {
                self.vpcUnavailable = dict["VpcUnavailable"] as! Bool
            }
        }
    }
    public var regions: [DescribeRegionsResponseBody.Regions]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regions != nil {
            var tmp : [Any] = []
            for k in self.regions! {
                tmp.append(k.toMap())
            }
            map["Regions"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Regions") && dict["Regions"] != nil {
            var tmp : [DescribeRegionsResponseBody.Regions] = []
            for v in dict["Regions"] as! [Any] {
                var model = DescribeRegionsResponseBody.Regions()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.regions = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeRegionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRegionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeRegionsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeScalingActivitiesRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var scalingActivityIds: [String]?

    public var scalingGroupId: String?

    public var statusCode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.scalingActivityIds != nil {
            map["ScalingActivityIds"] = self.scalingActivityIds!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        if self.statusCode != nil {
            map["StatusCode"] = self.statusCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") && dict["OwnerAccount"] != nil {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ScalingActivityIds") && dict["ScalingActivityIds"] != nil {
            self.scalingActivityIds = dict["ScalingActivityIds"] as! [String]
        }
        if dict.keys.contains("ScalingGroupId") && dict["ScalingGroupId"] != nil {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
        if dict.keys.contains("StatusCode") && dict["StatusCode"] != nil {
            self.statusCode = dict["StatusCode"] as! String
        }
    }
}

public class DescribeScalingActivitiesResponseBody : Tea.TeaModel {
    public class ScalingActivities : Tea.TeaModel {
        public var attachedCapacity: String?

        public var autoCreatedCapacity: String?

        public var cause: String?

        public var createdCapacity: Int32?

        public var createdInstances: [String]?

        public var description_: String?

        public var destroyedCapacity: Int32?

        public var destroyedInstances: [String]?

        public var detail: String?

        public var endTime: String?

        public var errorCode: String?

        public var errorMessage: String?

        public var progress: Int32?

        public var scalingActivityId: String?

        public var scalingGroupId: String?

        public var scalingInstanceNumber: Int32?

        public var startTime: String?

        public var startedCapacity: Int32?

        public var startedInstances: [String]?

        public var statusCode: String?

        public var statusMessage: String?

        public var stoppedCapacity: Int32?

        public var stoppedInstances: [String]?

        public var totalCapacity: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.attachedCapacity != nil {
                map["AttachedCapacity"] = self.attachedCapacity!
            }
            if self.autoCreatedCapacity != nil {
                map["AutoCreatedCapacity"] = self.autoCreatedCapacity!
            }
            if self.cause != nil {
                map["Cause"] = self.cause!
            }
            if self.createdCapacity != nil {
                map["CreatedCapacity"] = self.createdCapacity!
            }
            if self.createdInstances != nil {
                map["CreatedInstances"] = self.createdInstances!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.destroyedCapacity != nil {
                map["DestroyedCapacity"] = self.destroyedCapacity!
            }
            if self.destroyedInstances != nil {
                map["DestroyedInstances"] = self.destroyedInstances!
            }
            if self.detail != nil {
                map["Detail"] = self.detail!
            }
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.errorCode != nil {
                map["ErrorCode"] = self.errorCode!
            }
            if self.errorMessage != nil {
                map["ErrorMessage"] = self.errorMessage!
            }
            if self.progress != nil {
                map["Progress"] = self.progress!
            }
            if self.scalingActivityId != nil {
                map["ScalingActivityId"] = self.scalingActivityId!
            }
            if self.scalingGroupId != nil {
                map["ScalingGroupId"] = self.scalingGroupId!
            }
            if self.scalingInstanceNumber != nil {
                map["ScalingInstanceNumber"] = self.scalingInstanceNumber!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.startedCapacity != nil {
                map["StartedCapacity"] = self.startedCapacity!
            }
            if self.startedInstances != nil {
                map["StartedInstances"] = self.startedInstances!
            }
            if self.statusCode != nil {
                map["StatusCode"] = self.statusCode!
            }
            if self.statusMessage != nil {
                map["StatusMessage"] = self.statusMessage!
            }
            if self.stoppedCapacity != nil {
                map["StoppedCapacity"] = self.stoppedCapacity!
            }
            if self.stoppedInstances != nil {
                map["StoppedInstances"] = self.stoppedInstances!
            }
            if self.totalCapacity != nil {
                map["TotalCapacity"] = self.totalCapacity!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AttachedCapacity") && dict["AttachedCapacity"] != nil {
                self.attachedCapacity = dict["AttachedCapacity"] as! String
            }
            if dict.keys.contains("AutoCreatedCapacity") && dict["AutoCreatedCapacity"] != nil {
                self.autoCreatedCapacity = dict["AutoCreatedCapacity"] as! String
            }
            if dict.keys.contains("Cause") && dict["Cause"] != nil {
                self.cause = dict["Cause"] as! String
            }
            if dict.keys.contains("CreatedCapacity") && dict["CreatedCapacity"] != nil {
                self.createdCapacity = dict["CreatedCapacity"] as! Int32
            }
            if dict.keys.contains("CreatedInstances") && dict["CreatedInstances"] != nil {
                self.createdInstances = dict["CreatedInstances"] as! [String]
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("DestroyedCapacity") && dict["DestroyedCapacity"] != nil {
                self.destroyedCapacity = dict["DestroyedCapacity"] as! Int32
            }
            if dict.keys.contains("DestroyedInstances") && dict["DestroyedInstances"] != nil {
                self.destroyedInstances = dict["DestroyedInstances"] as! [String]
            }
            if dict.keys.contains("Detail") && dict["Detail"] != nil {
                self.detail = dict["Detail"] as! String
            }
            if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
                self.endTime = dict["EndTime"] as! String
            }
            if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
                self.errorCode = dict["ErrorCode"] as! String
            }
            if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
                self.errorMessage = dict["ErrorMessage"] as! String
            }
            if dict.keys.contains("Progress") && dict["Progress"] != nil {
                self.progress = dict["Progress"] as! Int32
            }
            if dict.keys.contains("ScalingActivityId") && dict["ScalingActivityId"] != nil {
                self.scalingActivityId = dict["ScalingActivityId"] as! String
            }
            if dict.keys.contains("ScalingGroupId") && dict["ScalingGroupId"] != nil {
                self.scalingGroupId = dict["ScalingGroupId"] as! String
            }
            if dict.keys.contains("ScalingInstanceNumber") && dict["ScalingInstanceNumber"] != nil {
                self.scalingInstanceNumber = dict["ScalingInstanceNumber"] as! Int32
            }
            if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
                self.startTime = dict["StartTime"] as! String
            }
            if dict.keys.contains("StartedCapacity") && dict["StartedCapacity"] != nil {
                self.startedCapacity = dict["StartedCapacity"] as! Int32
            }
            if dict.keys.contains("StartedInstances") && dict["StartedInstances"] != nil {
                self.startedInstances = dict["StartedInstances"] as! [String]
            }
            if dict.keys.contains("StatusCode") && dict["StatusCode"] != nil {
                self.statusCode = dict["StatusCode"] as! String
            }
            if dict.keys.contains("StatusMessage") && dict["StatusMessage"] != nil {
                self.statusMessage = dict["StatusMessage"] as! String
            }
            if dict.keys.contains("StoppedCapacity") && dict["StoppedCapacity"] != nil {
                self.stoppedCapacity = dict["StoppedCapacity"] as! Int32
            }
            if dict.keys.contains("StoppedInstances") && dict["StoppedInstances"] != nil {
                self.stoppedInstances = dict["StoppedInstances"] as! [String]
            }
            if dict.keys.contains("TotalCapacity") && dict["TotalCapacity"] != nil {
                self.totalCapacity = dict["TotalCapacity"] as! String
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var scalingActivities: [DescribeScalingActivitiesResponseBody.ScalingActivities]?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingActivities != nil {
            var tmp : [Any] = []
            for k in self.scalingActivities! {
                tmp.append(k.toMap())
            }
            map["ScalingActivities"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScalingActivities") && dict["ScalingActivities"] != nil {
            var tmp : [DescribeScalingActivitiesResponseBody.ScalingActivities] = []
            for v in dict["ScalingActivities"] as! [Any] {
                var model = DescribeScalingActivitiesResponseBody.ScalingActivities()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.scalingActivities = tmp
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeScalingActivitiesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeScalingActivitiesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeScalingActivitiesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeScalingActivityDetailRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var scalingActivityId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.scalingActivityId != nil {
            map["ScalingActivityId"] = self.scalingActivityId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ScalingActivityId") && dict["ScalingActivityId"] != nil {
            self.scalingActivityId = dict["ScalingActivityId"] as! String
        }
    }
}

public class DescribeScalingActivityDetailResponseBody : Tea.TeaModel {
    public var detail: String?

    public var requestId: String?

    public var scalingActivityId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.detail != nil {
            map["Detail"] = self.detail!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingActivityId != nil {
            map["ScalingActivityId"] = self.scalingActivityId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Detail") && dict["Detail"] != nil {
            self.detail = dict["Detail"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScalingActivityId") && dict["ScalingActivityId"] != nil {
            self.scalingActivityId = dict["ScalingActivityId"] as! String
        }
    }
}

public class DescribeScalingActivityDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeScalingActivityDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeScalingActivityDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeScalingConfigurationsRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var scalingConfigurationIds: [String]?

    public var scalingConfigurationNames: [String]?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.scalingConfigurationIds != nil {
            map["ScalingConfigurationIds"] = self.scalingConfigurationIds!
        }
        if self.scalingConfigurationNames != nil {
            map["ScalingConfigurationNames"] = self.scalingConfigurationNames!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") && dict["OwnerAccount"] != nil {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ScalingConfigurationIds") && dict["ScalingConfigurationIds"] != nil {
            self.scalingConfigurationIds = dict["ScalingConfigurationIds"] as! [String]
        }
        if dict.keys.contains("ScalingConfigurationNames") && dict["ScalingConfigurationNames"] != nil {
            self.scalingConfigurationNames = dict["ScalingConfigurationNames"] as! [String]
        }
        if dict.keys.contains("ScalingGroupId") && dict["ScalingGroupId"] != nil {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
    }
}

public class DescribeScalingConfigurationsResponseBody : Tea.TeaModel {
    public class ScalingConfigurations : Tea.TeaModel {
        public class CustomPriorities : Tea.TeaModel {
            public var instanceType: String?

            public var vswitchId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.instanceType != nil {
                    map["InstanceType"] = self.instanceType!
                }
                if self.vswitchId != nil {
                    map["VswitchId"] = self.vswitchId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("InstanceType") && dict["InstanceType"] != nil {
                    self.instanceType = dict["InstanceType"] as! String
                }
                if dict.keys.contains("VswitchId") && dict["VswitchId"] != nil {
                    self.vswitchId = dict["VswitchId"] as! String
                }
            }
        }
        public class DataDisks : Tea.TeaModel {
            public var autoSnapshotPolicyId: String?

            public var burstingEnabled: Bool?

            public var categories: [String]?

            public var category: String?

            public var deleteWithInstance: Bool?

            public var description_: String?

            public var device: String?

            public var diskName: String?

            public var encrypted: String?

            public var KMSKeyId: String?

            public var performanceLevel: String?

            public var provisionedIops: Int64?

            public var size: Int32?

            public var snapshotId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.autoSnapshotPolicyId != nil {
                    map["AutoSnapshotPolicyId"] = self.autoSnapshotPolicyId!
                }
                if self.burstingEnabled != nil {
                    map["BurstingEnabled"] = self.burstingEnabled!
                }
                if self.categories != nil {
                    map["Categories"] = self.categories!
                }
                if self.category != nil {
                    map["Category"] = self.category!
                }
                if self.deleteWithInstance != nil {
                    map["DeleteWithInstance"] = self.deleteWithInstance!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.device != nil {
                    map["Device"] = self.device!
                }
                if self.diskName != nil {
                    map["DiskName"] = self.diskName!
                }
                if self.encrypted != nil {
                    map["Encrypted"] = self.encrypted!
                }
                if self.KMSKeyId != nil {
                    map["KMSKeyId"] = self.KMSKeyId!
                }
                if self.performanceLevel != nil {
                    map["PerformanceLevel"] = self.performanceLevel!
                }
                if self.provisionedIops != nil {
                    map["ProvisionedIops"] = self.provisionedIops!
                }
                if self.size != nil {
                    map["Size"] = self.size!
                }
                if self.snapshotId != nil {
                    map["SnapshotId"] = self.snapshotId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AutoSnapshotPolicyId") && dict["AutoSnapshotPolicyId"] != nil {
                    self.autoSnapshotPolicyId = dict["AutoSnapshotPolicyId"] as! String
                }
                if dict.keys.contains("BurstingEnabled") && dict["BurstingEnabled"] != nil {
                    self.burstingEnabled = dict["BurstingEnabled"] as! Bool
                }
                if dict.keys.contains("Categories") && dict["Categories"] != nil {
                    self.categories = dict["Categories"] as! [String]
                }
                if dict.keys.contains("Category") && dict["Category"] != nil {
                    self.category = dict["Category"] as! String
                }
                if dict.keys.contains("DeleteWithInstance") && dict["DeleteWithInstance"] != nil {
                    self.deleteWithInstance = dict["DeleteWithInstance"] as! Bool
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Device") && dict["Device"] != nil {
                    self.device = dict["Device"] as! String
                }
                if dict.keys.contains("DiskName") && dict["DiskName"] != nil {
                    self.diskName = dict["DiskName"] as! String
                }
                if dict.keys.contains("Encrypted") && dict["Encrypted"] != nil {
                    self.encrypted = dict["Encrypted"] as! String
                }
                if dict.keys.contains("KMSKeyId") && dict["KMSKeyId"] != nil {
                    self.KMSKeyId = dict["KMSKeyId"] as! String
                }
                if dict.keys.contains("PerformanceLevel") && dict["PerformanceLevel"] != nil {
                    self.performanceLevel = dict["PerformanceLevel"] as! String
                }
                if dict.keys.contains("ProvisionedIops") && dict["ProvisionedIops"] != nil {
                    self.provisionedIops = dict["ProvisionedIops"] as! Int64
                }
                if dict.keys.contains("Size") && dict["Size"] != nil {
                    self.size = dict["Size"] as! Int32
                }
                if dict.keys.contains("SnapshotId") && dict["SnapshotId"] != nil {
                    self.snapshotId = dict["SnapshotId"] as! String
                }
            }
        }
        public class InstancePatternInfos : Tea.TeaModel {
            public var architectures: [String]?

            public var burstablePerformance: String?

            public var cores: Int32?

            public var excludedInstanceTypes: [String]?

            public var instanceFamilyLevel: String?

            public var maxPrice: Double?

            public var memory: Double?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.architectures != nil {
                    map["Architectures"] = self.architectures!
                }
                if self.burstablePerformance != nil {
                    map["BurstablePerformance"] = self.burstablePerformance!
                }
                if self.cores != nil {
                    map["Cores"] = self.cores!
                }
                if self.excludedInstanceTypes != nil {
                    map["ExcludedInstanceTypes"] = self.excludedInstanceTypes!
                }
                if self.instanceFamilyLevel != nil {
                    map["InstanceFamilyLevel"] = self.instanceFamilyLevel!
                }
                if self.maxPrice != nil {
                    map["MaxPrice"] = self.maxPrice!
                }
                if self.memory != nil {
                    map["Memory"] = self.memory!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Architectures") && dict["Architectures"] != nil {
                    self.architectures = dict["Architectures"] as! [String]
                }
                if dict.keys.contains("BurstablePerformance") && dict["BurstablePerformance"] != nil {
                    self.burstablePerformance = dict["BurstablePerformance"] as! String
                }
                if dict.keys.contains("Cores") && dict["Cores"] != nil {
                    self.cores = dict["Cores"] as! Int32
                }
                if dict.keys.contains("ExcludedInstanceTypes") && dict["ExcludedInstanceTypes"] != nil {
                    self.excludedInstanceTypes = dict["ExcludedInstanceTypes"] as! [String]
                }
                if dict.keys.contains("InstanceFamilyLevel") && dict["InstanceFamilyLevel"] != nil {
                    self.instanceFamilyLevel = dict["InstanceFamilyLevel"] as! String
                }
                if dict.keys.contains("MaxPrice") && dict["MaxPrice"] != nil {
                    self.maxPrice = dict["MaxPrice"] as! Double
                }
                if dict.keys.contains("Memory") && dict["Memory"] != nil {
                    self.memory = dict["Memory"] as! Double
                }
            }
        }
        public class SchedulerOptions : Tea.TeaModel {
            public var managedPrivateSpaceId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.managedPrivateSpaceId != nil {
                    map["ManagedPrivateSpaceId"] = self.managedPrivateSpaceId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ManagedPrivateSpaceId") && dict["ManagedPrivateSpaceId"] != nil {
                    self.managedPrivateSpaceId = dict["ManagedPrivateSpaceId"] as! String
                }
            }
        }
        public class SpotPriceLimits : Tea.TeaModel {
            public var instanceType: String?

            public var priceLimit: Double?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.instanceType != nil {
                    map["InstanceType"] = self.instanceType!
                }
                if self.priceLimit != nil {
                    map["PriceLimit"] = self.priceLimit!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("InstanceType") && dict["InstanceType"] != nil {
                    self.instanceType = dict["InstanceType"] as! String
                }
                if dict.keys.contains("PriceLimit") && dict["PriceLimit"] != nil {
                    self.priceLimit = dict["PriceLimit"] as! Double
                }
            }
        }
        public class Tags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") && dict["Key"] != nil {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var affinity: String?

        public var cpu: Int32?

        public var creationTime: String?

        public var creditSpecification: String?

        public var customPriorities: [DescribeScalingConfigurationsResponseBody.ScalingConfigurations.CustomPriorities]?

        public var dataDisks: [DescribeScalingConfigurationsResponseBody.ScalingConfigurations.DataDisks]?

        public var dedicatedHostId: String?

        public var deletionProtection: Bool?

        public var deploymentSetId: String?

        public var hostName: String?

        public var hpcClusterId: String?

        public var imageFamily: String?

        public var imageId: String?

        public var imageName: String?

        public var imageOptionsLoginAsNonRoot: Bool?

        public var imageOwnerAlias: String?

        public var instanceDescription: String?

        public var instanceGeneration: String?

        public var instanceName: String?

        public var instancePatternInfos: [DescribeScalingConfigurationsResponseBody.ScalingConfigurations.InstancePatternInfos]?

        public var instanceType: String?

        public var instanceTypes: [String]?

        public var internetChargeType: String?

        public var internetMaxBandwidthIn: Int32?

        public var internetMaxBandwidthOut: Int32?

        public var ioOptimized: String?

        public var ipv6AddressCount: Int32?

        public var keyPairName: String?

        public var lifecycleState: String?

        public var loadBalancerWeight: Int32?

        public var memory: Int32?

        public var passwordInherit: Bool?

        public var privatePoolOptions_id: String?

        public var privatePoolOptions_matchCriteria: String?

        public var ramRoleName: String?

        public var resourceGroupId: String?

        public var scalingConfigurationId: String?

        public var scalingConfigurationName: String?

        public var scalingGroupId: String?

        public var schedulerOptions: DescribeScalingConfigurationsResponseBody.ScalingConfigurations.SchedulerOptions?

        public var securityEnhancementStrategy: String?

        public var securityGroupId: String?

        public var securityGroupIds: [String]?

        public var spotDuration: Int32?

        public var spotInterruptionBehavior: String?

        public var spotPriceLimits: [DescribeScalingConfigurationsResponseBody.ScalingConfigurations.SpotPriceLimits]?

        public var spotStrategy: String?

        public var storageSetId: String?

        public var storageSetPartitionNumber: Int32?

        public var systemDiskAutoSnapshotPolicyId: String?

        public var systemDiskBurstingEnabled: Bool?

        public var systemDiskCategories: [String]?

        public var systemDiskCategory: String?

        public var systemDiskDescription: String?

        public var systemDiskEncryptAlgorithm: String?

        public var systemDiskEncrypted: Bool?

        public var systemDiskKMSKeyId: String?

        public var systemDiskName: String?

        public var systemDiskPerformanceLevel: String?

        public var systemDiskProvisionedIops: Int64?

        public var systemDiskSize: Int32?

        public var tags: [DescribeScalingConfigurationsResponseBody.ScalingConfigurations.Tags]?

        public var tenancy: String?

        public var userData: String?

        public var weightedCapacities: [Int32]?

        public var zoneId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.schedulerOptions?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.affinity != nil {
                map["Affinity"] = self.affinity!
            }
            if self.cpu != nil {
                map["Cpu"] = self.cpu!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.creditSpecification != nil {
                map["CreditSpecification"] = self.creditSpecification!
            }
            if self.customPriorities != nil {
                var tmp : [Any] = []
                for k in self.customPriorities! {
                    tmp.append(k.toMap())
                }
                map["CustomPriorities"] = tmp
            }
            if self.dataDisks != nil {
                var tmp : [Any] = []
                for k in self.dataDisks! {
                    tmp.append(k.toMap())
                }
                map["DataDisks"] = tmp
            }
            if self.dedicatedHostId != nil {
                map["DedicatedHostId"] = self.dedicatedHostId!
            }
            if self.deletionProtection != nil {
                map["DeletionProtection"] = self.deletionProtection!
            }
            if self.deploymentSetId != nil {
                map["DeploymentSetId"] = self.deploymentSetId!
            }
            if self.hostName != nil {
                map["HostName"] = self.hostName!
            }
            if self.hpcClusterId != nil {
                map["HpcClusterId"] = self.hpcClusterId!
            }
            if self.imageFamily != nil {
                map["ImageFamily"] = self.imageFamily!
            }
            if self.imageId != nil {
                map["ImageId"] = self.imageId!
            }
            if self.imageName != nil {
                map["ImageName"] = self.imageName!
            }
            if self.imageOptionsLoginAsNonRoot != nil {
                map["ImageOptionsLoginAsNonRoot"] = self.imageOptionsLoginAsNonRoot!
            }
            if self.imageOwnerAlias != nil {
                map["ImageOwnerAlias"] = self.imageOwnerAlias!
            }
            if self.instanceDescription != nil {
                map["InstanceDescription"] = self.instanceDescription!
            }
            if self.instanceGeneration != nil {
                map["InstanceGeneration"] = self.instanceGeneration!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.instancePatternInfos != nil {
                var tmp : [Any] = []
                for k in self.instancePatternInfos! {
                    tmp.append(k.toMap())
                }
                map["InstancePatternInfos"] = tmp
            }
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.instanceTypes != nil {
                map["InstanceTypes"] = self.instanceTypes!
            }
            if self.internetChargeType != nil {
                map["InternetChargeType"] = self.internetChargeType!
            }
            if self.internetMaxBandwidthIn != nil {
                map["InternetMaxBandwidthIn"] = self.internetMaxBandwidthIn!
            }
            if self.internetMaxBandwidthOut != nil {
                map["InternetMaxBandwidthOut"] = self.internetMaxBandwidthOut!
            }
            if self.ioOptimized != nil {
                map["IoOptimized"] = self.ioOptimized!
            }
            if self.ipv6AddressCount != nil {
                map["Ipv6AddressCount"] = self.ipv6AddressCount!
            }
            if self.keyPairName != nil {
                map["KeyPairName"] = self.keyPairName!
            }
            if self.lifecycleState != nil {
                map["LifecycleState"] = self.lifecycleState!
            }
            if self.loadBalancerWeight != nil {
                map["LoadBalancerWeight"] = self.loadBalancerWeight!
            }
            if self.memory != nil {
                map["Memory"] = self.memory!
            }
            if self.passwordInherit != nil {
                map["PasswordInherit"] = self.passwordInherit!
            }
            if self.privatePoolOptions_id != nil {
                map["PrivatePoolOptions.Id"] = self.privatePoolOptions_id!
            }
            if self.privatePoolOptions_matchCriteria != nil {
                map["PrivatePoolOptions.MatchCriteria"] = self.privatePoolOptions_matchCriteria!
            }
            if self.ramRoleName != nil {
                map["RamRoleName"] = self.ramRoleName!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.scalingConfigurationId != nil {
                map["ScalingConfigurationId"] = self.scalingConfigurationId!
            }
            if self.scalingConfigurationName != nil {
                map["ScalingConfigurationName"] = self.scalingConfigurationName!
            }
            if self.scalingGroupId != nil {
                map["ScalingGroupId"] = self.scalingGroupId!
            }
            if self.schedulerOptions != nil {
                map["SchedulerOptions"] = self.schedulerOptions?.toMap()
            }
            if self.securityEnhancementStrategy != nil {
                map["SecurityEnhancementStrategy"] = self.securityEnhancementStrategy!
            }
            if self.securityGroupId != nil {
                map["SecurityGroupId"] = self.securityGroupId!
            }
            if self.securityGroupIds != nil {
                map["SecurityGroupIds"] = self.securityGroupIds!
            }
            if self.spotDuration != nil {
                map["SpotDuration"] = self.spotDuration!
            }
            if self.spotInterruptionBehavior != nil {
                map["SpotInterruptionBehavior"] = self.spotInterruptionBehavior!
            }
            if self.spotPriceLimits != nil {
                var tmp : [Any] = []
                for k in self.spotPriceLimits! {
                    tmp.append(k.toMap())
                }
                map["SpotPriceLimits"] = tmp
            }
            if self.spotStrategy != nil {
                map["SpotStrategy"] = self.spotStrategy!
            }
            if self.storageSetId != nil {
                map["StorageSetId"] = self.storageSetId!
            }
            if self.storageSetPartitionNumber != nil {
                map["StorageSetPartitionNumber"] = self.storageSetPartitionNumber!
            }
            if self.systemDiskAutoSnapshotPolicyId != nil {
                map["SystemDiskAutoSnapshotPolicyId"] = self.systemDiskAutoSnapshotPolicyId!
            }
            if self.systemDiskBurstingEnabled != nil {
                map["SystemDiskBurstingEnabled"] = self.systemDiskBurstingEnabled!
            }
            if self.systemDiskCategories != nil {
                map["SystemDiskCategories"] = self.systemDiskCategories!
            }
            if self.systemDiskCategory != nil {
                map["SystemDiskCategory"] = self.systemDiskCategory!
            }
            if self.systemDiskDescription != nil {
                map["SystemDiskDescription"] = self.systemDiskDescription!
            }
            if self.systemDiskEncryptAlgorithm != nil {
                map["SystemDiskEncryptAlgorithm"] = self.systemDiskEncryptAlgorithm!
            }
            if self.systemDiskEncrypted != nil {
                map["SystemDiskEncrypted"] = self.systemDiskEncrypted!
            }
            if self.systemDiskKMSKeyId != nil {
                map["SystemDiskKMSKeyId"] = self.systemDiskKMSKeyId!
            }
            if self.systemDiskName != nil {
                map["SystemDiskName"] = self.systemDiskName!
            }
            if self.systemDiskPerformanceLevel != nil {
                map["SystemDiskPerformanceLevel"] = self.systemDiskPerformanceLevel!
            }
            if self.systemDiskProvisionedIops != nil {
                map["SystemDiskProvisionedIops"] = self.systemDiskProvisionedIops!
            }
            if self.systemDiskSize != nil {
                map["SystemDiskSize"] = self.systemDiskSize!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            if self.tenancy != nil {
                map["Tenancy"] = self.tenancy!
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            if self.weightedCapacities != nil {
                map["WeightedCapacities"] = self.weightedCapacities!
            }
            if self.zoneId != nil {
                map["ZoneId"] = self.zoneId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Affinity") && dict["Affinity"] != nil {
                self.affinity = dict["Affinity"] as! String
            }
            if dict.keys.contains("Cpu") && dict["Cpu"] != nil {
                self.cpu = dict["Cpu"] as! Int32
            }
            if dict.keys.contains("CreationTime") && dict["CreationTime"] != nil {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("CreditSpecification") && dict["CreditSpecification"] != nil {
                self.creditSpecification = dict["CreditSpecification"] as! String
            }
            if dict.keys.contains("CustomPriorities") && dict["CustomPriorities"] != nil {
                var tmp : [DescribeScalingConfigurationsResponseBody.ScalingConfigurations.CustomPriorities] = []
                for v in dict["CustomPriorities"] as! [Any] {
                    var model = DescribeScalingConfigurationsResponseBody.ScalingConfigurations.CustomPriorities()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.customPriorities = tmp
            }
            if dict.keys.contains("DataDisks") && dict["DataDisks"] != nil {
                var tmp : [DescribeScalingConfigurationsResponseBody.ScalingConfigurations.DataDisks] = []
                for v in dict["DataDisks"] as! [Any] {
                    var model = DescribeScalingConfigurationsResponseBody.ScalingConfigurations.DataDisks()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.dataDisks = tmp
            }
            if dict.keys.contains("DedicatedHostId") && dict["DedicatedHostId"] != nil {
                self.dedicatedHostId = dict["DedicatedHostId"] as! String
            }
            if dict.keys.contains("DeletionProtection") && dict["DeletionProtection"] != nil {
                self.deletionProtection = dict["DeletionProtection"] as! Bool
            }
            if dict.keys.contains("DeploymentSetId") && dict["DeploymentSetId"] != nil {
                self.deploymentSetId = dict["DeploymentSetId"] as! String
            }
            if dict.keys.contains("HostName") && dict["HostName"] != nil {
                self.hostName = dict["HostName"] as! String
            }
            if dict.keys.contains("HpcClusterId") && dict["HpcClusterId"] != nil {
                self.hpcClusterId = dict["HpcClusterId"] as! String
            }
            if dict.keys.contains("ImageFamily") && dict["ImageFamily"] != nil {
                self.imageFamily = dict["ImageFamily"] as! String
            }
            if dict.keys.contains("ImageId") && dict["ImageId"] != nil {
                self.imageId = dict["ImageId"] as! String
            }
            if dict.keys.contains("ImageName") && dict["ImageName"] != nil {
                self.imageName = dict["ImageName"] as! String
            }
            if dict.keys.contains("ImageOptionsLoginAsNonRoot") && dict["ImageOptionsLoginAsNonRoot"] != nil {
                self.imageOptionsLoginAsNonRoot = dict["ImageOptionsLoginAsNonRoot"] as! Bool
            }
            if dict.keys.contains("ImageOwnerAlias") && dict["ImageOwnerAlias"] != nil {
                self.imageOwnerAlias = dict["ImageOwnerAlias"] as! String
            }
            if dict.keys.contains("InstanceDescription") && dict["InstanceDescription"] != nil {
                self.instanceDescription = dict["InstanceDescription"] as! String
            }
            if dict.keys.contains("InstanceGeneration") && dict["InstanceGeneration"] != nil {
                self.instanceGeneration = dict["InstanceGeneration"] as! String
            }
            if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
                self.instanceName = dict["InstanceName"] as! String
            }
            if dict.keys.contains("InstancePatternInfos") && dict["InstancePatternInfos"] != nil {
                var tmp : [DescribeScalingConfigurationsResponseBody.ScalingConfigurations.InstancePatternInfos] = []
                for v in dict["InstancePatternInfos"] as! [Any] {
                    var model = DescribeScalingConfigurationsResponseBody.ScalingConfigurations.InstancePatternInfos()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.instancePatternInfos = tmp
            }
            if dict.keys.contains("InstanceType") && dict["InstanceType"] != nil {
                self.instanceType = dict["InstanceType"] as! String
            }
            if dict.keys.contains("InstanceTypes") && dict["InstanceTypes"] != nil {
                self.instanceTypes = dict["InstanceTypes"] as! [String]
            }
            if dict.keys.contains("InternetChargeType") && dict["InternetChargeType"] != nil {
                self.internetChargeType = dict["InternetChargeType"] as! String
            }
            if dict.keys.contains("InternetMaxBandwidthIn") && dict["InternetMaxBandwidthIn"] != nil {
                self.internetMaxBandwidthIn = dict["InternetMaxBandwidthIn"] as! Int32
            }
            if dict.keys.contains("InternetMaxBandwidthOut") && dict["InternetMaxBandwidthOut"] != nil {
                self.internetMaxBandwidthOut = dict["InternetMaxBandwidthOut"] as! Int32
            }
            if dict.keys.contains("IoOptimized") && dict["IoOptimized"] != nil {
                self.ioOptimized = dict["IoOptimized"] as! String
            }
            if dict.keys.contains("Ipv6AddressCount") && dict["Ipv6AddressCount"] != nil {
                self.ipv6AddressCount = dict["Ipv6AddressCount"] as! Int32
            }
            if dict.keys.contains("KeyPairName") && dict["KeyPairName"] != nil {
                self.keyPairName = dict["KeyPairName"] as! String
            }
            if dict.keys.contains("LifecycleState") && dict["LifecycleState"] != nil {
                self.lifecycleState = dict["LifecycleState"] as! String
            }
            if dict.keys.contains("LoadBalancerWeight") && dict["LoadBalancerWeight"] != nil {
                self.loadBalancerWeight = dict["LoadBalancerWeight"] as! Int32
            }
            if dict.keys.contains("Memory") && dict["Memory"] != nil {
                self.memory = dict["Memory"] as! Int32
            }
            if dict.keys.contains("PasswordInherit") && dict["PasswordInherit"] != nil {
                self.passwordInherit = dict["PasswordInherit"] as! Bool
            }
            if dict.keys.contains("PrivatePoolOptions.Id") && dict["PrivatePoolOptions.Id"] != nil {
                self.privatePoolOptions_id = dict["PrivatePoolOptions.Id"] as! String
            }
            if dict.keys.contains("PrivatePoolOptions.MatchCriteria") && dict["PrivatePoolOptions.MatchCriteria"] != nil {
                self.privatePoolOptions_matchCriteria = dict["PrivatePoolOptions.MatchCriteria"] as! String
            }
            if dict.keys.contains("RamRoleName") && dict["RamRoleName"] != nil {
                self.ramRoleName = dict["RamRoleName"] as! String
            }
            if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
                self.resourceGroupId = dict["ResourceGroupId"] as! String
            }
            if dict.keys.contains("ScalingConfigurationId") && dict["ScalingConfigurationId"] != nil {
                self.scalingConfigurationId = dict["ScalingConfigurationId"] as! String
            }
            if dict.keys.contains("ScalingConfigurationName") && dict["ScalingConfigurationName"] != nil {
                self.scalingConfigurationName = dict["ScalingConfigurationName"] as! String
            }
            if dict.keys.contains("ScalingGroupId") && dict["ScalingGroupId"] != nil {
                self.scalingGroupId = dict["ScalingGroupId"] as! String
            }
            if dict.keys.contains("SchedulerOptions") && dict["SchedulerOptions"] != nil {
                var model = DescribeScalingConfigurationsResponseBody.ScalingConfigurations.SchedulerOptions()
                model.fromMap(dict["SchedulerOptions"] as! [String: Any])
                self.schedulerOptions = model
            }
            if dict.keys.contains("SecurityEnhancementStrategy") && dict["SecurityEnhancementStrategy"] != nil {
                self.securityEnhancementStrategy = dict["SecurityEnhancementStrategy"] as! String
            }
            if dict.keys.contains("SecurityGroupId") && dict["SecurityGroupId"] != nil {
                self.securityGroupId = dict["SecurityGroupId"] as! String
            }
            if dict.keys.contains("SecurityGroupIds") && dict["SecurityGroupIds"] != nil {
                self.securityGroupIds = dict["SecurityGroupIds"] as! [String]
            }
            if dict.keys.contains("SpotDuration") && dict["SpotDuration"] != nil {
                self.spotDuration = dict["SpotDuration"] as! Int32
            }
            if dict.keys.contains("SpotInterruptionBehavior") && dict["SpotInterruptionBehavior"] != nil {
                self.spotInterruptionBehavior = dict["SpotInterruptionBehavior"] as! String
            }
            if dict.keys.contains("SpotPriceLimits") && dict["SpotPriceLimits"] != nil {
                var tmp : [DescribeScalingConfigurationsResponseBody.ScalingConfigurations.SpotPriceLimits] = []
                for v in dict["SpotPriceLimits"] as! [Any] {
                    var model = DescribeScalingConfigurationsResponseBody.ScalingConfigurations.SpotPriceLimits()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.spotPriceLimits = tmp
            }
            if dict.keys.contains("SpotStrategy") && dict["SpotStrategy"] != nil {
                self.spotStrategy = dict["SpotStrategy"] as! String
            }
            if dict.keys.contains("StorageSetId") && dict["StorageSetId"] != nil {
                self.storageSetId = dict["StorageSetId"] as! String
            }
            if dict.keys.contains("StorageSetPartitionNumber") && dict["StorageSetPartitionNumber"] != nil {
                self.storageSetPartitionNumber = dict["StorageSetPartitionNumber"] as! Int32
            }
            if dict.keys.contains("SystemDiskAutoSnapshotPolicyId") && dict["SystemDiskAutoSnapshotPolicyId"] != nil {
                self.systemDiskAutoSnapshotPolicyId = dict["SystemDiskAutoSnapshotPolicyId"] as! String
            }
            if dict.keys.contains("SystemDiskBurstingEnabled") && dict["SystemDiskBurstingEnabled"] != nil {
                self.systemDiskBurstingEnabled = dict["SystemDiskBurstingEnabled"] as! Bool
            }
            if dict.keys.contains("SystemDiskCategories") && dict["SystemDiskCategories"] != nil {
                self.systemDiskCategories = dict["SystemDiskCategories"] as! [String]
            }
            if dict.keys.contains("SystemDiskCategory") && dict["SystemDiskCategory"] != nil {
                self.systemDiskCategory = dict["SystemDiskCategory"] as! String
            }
            if dict.keys.contains("SystemDiskDescription") && dict["SystemDiskDescription"] != nil {
                self.systemDiskDescription = dict["SystemDiskDescription"] as! String
            }
            if dict.keys.contains("SystemDiskEncryptAlgorithm") && dict["SystemDiskEncryptAlgorithm"] != nil {
                self.systemDiskEncryptAlgorithm = dict["SystemDiskEncryptAlgorithm"] as! String
            }
            if dict.keys.contains("SystemDiskEncrypted") && dict["SystemDiskEncrypted"] != nil {
                self.systemDiskEncrypted = dict["SystemDiskEncrypted"] as! Bool
            }
            if dict.keys.contains("SystemDiskKMSKeyId") && dict["SystemDiskKMSKeyId"] != nil {
                self.systemDiskKMSKeyId = dict["SystemDiskKMSKeyId"] as! String
            }
            if dict.keys.contains("SystemDiskName") && dict["SystemDiskName"] != nil {
                self.systemDiskName = dict["SystemDiskName"] as! String
            }
            if dict.keys.contains("SystemDiskPerformanceLevel") && dict["SystemDiskPerformanceLevel"] != nil {
                self.systemDiskPerformanceLevel = dict["SystemDiskPerformanceLevel"] as! String
            }
            if dict.keys.contains("SystemDiskProvisionedIops") && dict["SystemDiskProvisionedIops"] != nil {
                self.systemDiskProvisionedIops = dict["SystemDiskProvisionedIops"] as! Int64
            }
            if dict.keys.contains("SystemDiskSize") && dict["SystemDiskSize"] != nil {
                self.systemDiskSize = dict["SystemDiskSize"] as! Int32
            }
            if dict.keys.contains("Tags") && dict["Tags"] != nil {
                var tmp : [DescribeScalingConfigurationsResponseBody.ScalingConfigurations.Tags] = []
                for v in dict["Tags"] as! [Any] {
                    var model = DescribeScalingConfigurationsResponseBody.ScalingConfigurations.Tags()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tags = tmp
            }
            if dict.keys.contains("Tenancy") && dict["Tenancy"] != nil {
                self.tenancy = dict["Tenancy"] as! String
            }
            if dict.keys.contains("UserData") && dict["UserData"] != nil {
                self.userData = dict["UserData"] as! String
            }
            if dict.keys.contains("WeightedCapacities") && dict["WeightedCapacities"] != nil {
                self.weightedCapacities = dict["WeightedCapacities"] as! [Int32]
            }
            if dict.keys.contains("ZoneId") && dict["ZoneId"] != nil {
                self.zoneId = dict["ZoneId"] as! String
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var scalingConfigurations: [DescribeScalingConfigurationsResponseBody.ScalingConfigurations]?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingConfigurations != nil {
            var tmp : [Any] = []
            for k in self.scalingConfigurations! {
                tmp.append(k.toMap())
            }
            map["ScalingConfigurations"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScalingConfigurations") && dict["ScalingConfigurations"] != nil {
            var tmp : [DescribeScalingConfigurationsResponseBody.ScalingConfigurations] = []
            for v in dict["ScalingConfigurations"] as! [Any] {
                var model = DescribeScalingConfigurationsResponseBody.ScalingConfigurations()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.scalingConfigurations = tmp
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeScalingConfigurationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeScalingConfigurationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeScalingConfigurationsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeScalingGroupDetailRequest : Tea.TeaModel {
    public var outputFormat: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.outputFormat != nil {
            map["OutputFormat"] = self.outputFormat!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OutputFormat") && dict["OutputFormat"] != nil {
            self.outputFormat = dict["OutputFormat"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ScalingGroupId") && dict["ScalingGroupId"] != nil {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
    }
}

public class DescribeScalingGroupDetailResponseBody : Tea.TeaModel {
    public class ScalingGroup : Tea.TeaModel {
        public class AlbServerGroups : Tea.TeaModel {
            public var albServerGroupId: String?

            public var port: Int32?

            public var weight: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.albServerGroupId != nil {
                    map["AlbServerGroupId"] = self.albServerGroupId!
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.weight != nil {
                    map["Weight"] = self.weight!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AlbServerGroupId") && dict["AlbServerGroupId"] != nil {
                    self.albServerGroupId = dict["AlbServerGroupId"] as! String
                }
                if dict.keys.contains("Port") && dict["Port"] != nil {
                    self.port = dict["Port"] as! Int32
                }
                if dict.keys.contains("Weight") && dict["Weight"] != nil {
                    self.weight = dict["Weight"] as! Int32
                }
            }
        }
        public class LaunchTemplateOverrides : Tea.TeaModel {
            public var instanceType: String?

            public var spotPriceLimit: Double?

            public var weightedCapacity: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.instanceType != nil {
                    map["InstanceType"] = self.instanceType!
                }
                if self.spotPriceLimit != nil {
                    map["SpotPriceLimit"] = self.spotPriceLimit!
                }
                if self.weightedCapacity != nil {
                    map["WeightedCapacity"] = self.weightedCapacity!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("InstanceType") && dict["InstanceType"] != nil {
                    self.instanceType = dict["InstanceType"] as! String
                }
                if dict.keys.contains("SpotPriceLimit") && dict["SpotPriceLimit"] != nil {
                    self.spotPriceLimit = dict["SpotPriceLimit"] as! Double
                }
                if dict.keys.contains("WeightedCapacity") && dict["WeightedCapacity"] != nil {
                    self.weightedCapacity = dict["WeightedCapacity"] as! Int32
                }
            }
        }
        public class LoadBalancerConfigs : Tea.TeaModel {
            public var loadBalancerId: String?

            public var weight: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.loadBalancerId != nil {
                    map["LoadBalancerId"] = self.loadBalancerId!
                }
                if self.weight != nil {
                    map["Weight"] = self.weight!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("LoadBalancerId") && dict["LoadBalancerId"] != nil {
                    self.loadBalancerId = dict["LoadBalancerId"] as! String
                }
                if dict.keys.contains("Weight") && dict["Weight"] != nil {
                    self.weight = dict["Weight"] as! Int32
                }
            }
        }
        public class ServerGroups : Tea.TeaModel {
            public var port: Int32?

            public var serverGroupId: String?

            public var type: String?

            public var weight: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.serverGroupId != nil {
                    map["ServerGroupId"] = self.serverGroupId!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.weight != nil {
                    map["Weight"] = self.weight!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Port") && dict["Port"] != nil {
                    self.port = dict["Port"] as! Int32
                }
                if dict.keys.contains("ServerGroupId") && dict["ServerGroupId"] != nil {
                    self.serverGroupId = dict["ServerGroupId"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Weight") && dict["Weight"] != nil {
                    self.weight = dict["Weight"] as! Int32
                }
            }
        }
        public class Tags : Tea.TeaModel {
            public var propagate: Bool?

            public var tagKey: String?

            public var tagValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.propagate != nil {
                    map["Propagate"] = self.propagate!
                }
                if self.tagKey != nil {
                    map["TagKey"] = self.tagKey!
                }
                if self.tagValue != nil {
                    map["TagValue"] = self.tagValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Propagate") && dict["Propagate"] != nil {
                    self.propagate = dict["Propagate"] as! Bool
                }
                if dict.keys.contains("TagKey") && dict["TagKey"] != nil {
                    self.tagKey = dict["TagKey"] as! String
                }
                if dict.keys.contains("TagValue") && dict["TagValue"] != nil {
                    self.tagValue = dict["TagValue"] as! String
                }
            }
        }
        public class VServerGroups : Tea.TeaModel {
            public class VServerGroupAttributes : Tea.TeaModel {
                public var port: Int32?

                public var VServerGroupId: String?

                public var weight: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.port != nil {
                        map["Port"] = self.port!
                    }
                    if self.VServerGroupId != nil {
                        map["VServerGroupId"] = self.VServerGroupId!
                    }
                    if self.weight != nil {
                        map["Weight"] = self.weight!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Port") && dict["Port"] != nil {
                        self.port = dict["Port"] as! Int32
                    }
                    if dict.keys.contains("VServerGroupId") && dict["VServerGroupId"] != nil {
                        self.VServerGroupId = dict["VServerGroupId"] as! String
                    }
                    if dict.keys.contains("Weight") && dict["Weight"] != nil {
                        self.weight = dict["Weight"] as! Int32
                    }
                }
            }
            public var loadBalancerId: String?

            public var VServerGroupAttributes: [DescribeScalingGroupDetailResponseBody.ScalingGroup.VServerGroups.VServerGroupAttributes]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.loadBalancerId != nil {
                    map["LoadBalancerId"] = self.loadBalancerId!
                }
                if self.VServerGroupAttributes != nil {
                    var tmp : [Any] = []
                    for k in self.VServerGroupAttributes! {
                        tmp.append(k.toMap())
                    }
                    map["VServerGroupAttributes"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("LoadBalancerId") && dict["LoadBalancerId"] != nil {
                    self.loadBalancerId = dict["LoadBalancerId"] as! String
                }
                if dict.keys.contains("VServerGroupAttributes") && dict["VServerGroupAttributes"] != nil {
                    var tmp : [DescribeScalingGroupDetailResponseBody.ScalingGroup.VServerGroups.VServerGroupAttributes] = []
                    for v in dict["VServerGroupAttributes"] as! [Any] {
                        var model = DescribeScalingGroupDetailResponseBody.ScalingGroup.VServerGroups.VServerGroupAttributes()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.VServerGroupAttributes = tmp
                }
            }
        }
        public var activeCapacity: Int32?

        public var activeScalingConfigurationId: String?

        public var albServerGroups: [DescribeScalingGroupDetailResponseBody.ScalingGroup.AlbServerGroups]?

        public var allocationStrategy: String?

        public var azBalance: Bool?

        public var compensateWithOnDemand: Bool?

        public var creationTime: String?

        public var currentHostName: String?

        public var customPolicyARN: String?

        public var DBInstanceIds: [String]?

        public var defaultCooldown: Int32?

        public var desiredCapacity: Int32?

        public var enableDesiredCapacity: Bool?

        public var groupDeletionProtection: Bool?

        public var groupType: String?

        public var healthCheckType: String?

        public var healthCheckTypes: [String]?

        public var initCapacity: Int32?

        public var isElasticStrengthInAlarm: Bool?

        public var launchTemplateId: String?

        public var launchTemplateOverrides: [DescribeScalingGroupDetailResponseBody.ScalingGroup.LaunchTemplateOverrides]?

        public var launchTemplateVersion: String?

        public var lifecycleState: String?

        public var loadBalancerConfigs: [DescribeScalingGroupDetailResponseBody.ScalingGroup.LoadBalancerConfigs]?

        public var loadBalancerIds: [String]?

        public var maxInstanceLifetime: Int32?

        public var maxSize: Int32?

        public var minSize: Int32?

        public var modificationTime: String?

        public var monitorGroupId: String?

        public var multiAZPolicy: String?

        public var onDemandBaseCapacity: Int32?

        public var onDemandPercentageAboveBaseCapacity: Int32?

        public var pendingCapacity: Int32?

        public var pendingWaitCapacity: Int32?

        public var protectedCapacity: Int32?

        public var regionId: String?

        public var removalPolicies: [String]?

        public var removingCapacity: Int32?

        public var removingWaitCapacity: Int32?

        public var resourceGroupId: String?

        public var scalingGroupId: String?

        public var scalingGroupName: String?

        public var scalingPolicy: String?

        public var serverGroups: [DescribeScalingGroupDetailResponseBody.ScalingGroup.ServerGroups]?

        public var spotAllocationStrategy: String?

        public var spotInstancePools: Int32?

        public var spotInstanceRemedy: Bool?

        public var standbyCapacity: Int32?

        public var stoppedCapacity: Int32?

        public var suspendedProcesses: [String]?

        public var systemSuspended: Bool?

        public var tags: [DescribeScalingGroupDetailResponseBody.ScalingGroup.Tags]?

        public var totalCapacity: Int32?

        public var totalInstanceCount: Int32?

        public var VServerGroups: [DescribeScalingGroupDetailResponseBody.ScalingGroup.VServerGroups]?

        public var vSwitchId: String?

        public var vSwitchIds: [String]?

        public var vpcId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.activeCapacity != nil {
                map["ActiveCapacity"] = self.activeCapacity!
            }
            if self.activeScalingConfigurationId != nil {
                map["ActiveScalingConfigurationId"] = self.activeScalingConfigurationId!
            }
            if self.albServerGroups != nil {
                var tmp : [Any] = []
                for k in self.albServerGroups! {
                    tmp.append(k.toMap())
                }
                map["AlbServerGroups"] = tmp
            }
            if self.allocationStrategy != nil {
                map["AllocationStrategy"] = self.allocationStrategy!
            }
            if self.azBalance != nil {
                map["AzBalance"] = self.azBalance!
            }
            if self.compensateWithOnDemand != nil {
                map["CompensateWithOnDemand"] = self.compensateWithOnDemand!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.currentHostName != nil {
                map["CurrentHostName"] = self.currentHostName!
            }
            if self.customPolicyARN != nil {
                map["CustomPolicyARN"] = self.customPolicyARN!
            }
            if self.DBInstanceIds != nil {
                map["DBInstanceIds"] = self.DBInstanceIds!
            }
            if self.defaultCooldown != nil {
                map["DefaultCooldown"] = self.defaultCooldown!
            }
            if self.desiredCapacity != nil {
                map["DesiredCapacity"] = self.desiredCapacity!
            }
            if self.enableDesiredCapacity != nil {
                map["EnableDesiredCapacity"] = self.enableDesiredCapacity!
            }
            if self.groupDeletionProtection != nil {
                map["GroupDeletionProtection"] = self.groupDeletionProtection!
            }
            if self.groupType != nil {
                map["GroupType"] = self.groupType!
            }
            if self.healthCheckType != nil {
                map["HealthCheckType"] = self.healthCheckType!
            }
            if self.healthCheckTypes != nil {
                map["HealthCheckTypes"] = self.healthCheckTypes!
            }
            if self.initCapacity != nil {
                map["InitCapacity"] = self.initCapacity!
            }
            if self.isElasticStrengthInAlarm != nil {
                map["IsElasticStrengthInAlarm"] = self.isElasticStrengthInAlarm!
            }
            if self.launchTemplateId != nil {
                map["LaunchTemplateId"] = self.launchTemplateId!
            }
            if self.launchTemplateOverrides != nil {
                var tmp : [Any] = []
                for k in self.launchTemplateOverrides! {
                    tmp.append(k.toMap())
                }
                map["LaunchTemplateOverrides"] = tmp
            }
            if self.launchTemplateVersion != nil {
                map["LaunchTemplateVersion"] = self.launchTemplateVersion!
            }
            if self.lifecycleState != nil {
                map["LifecycleState"] = self.lifecycleState!
            }
            if self.loadBalancerConfigs != nil {
                var tmp : [Any] = []
                for k in self.loadBalancerConfigs! {
                    tmp.append(k.toMap())
                }
                map["LoadBalancerConfigs"] = tmp
            }
            if self.loadBalancerIds != nil {
                map["LoadBalancerIds"] = self.loadBalancerIds!
            }
            if self.maxInstanceLifetime != nil {
                map["MaxInstanceLifetime"] = self.maxInstanceLifetime!
            }
            if self.maxSize != nil {
                map["MaxSize"] = self.maxSize!
            }
            if self.minSize != nil {
                map["MinSize"] = self.minSize!
            }
            if self.modificationTime != nil {
                map["ModificationTime"] = self.modificationTime!
            }
            if self.monitorGroupId != nil {
                map["MonitorGroupId"] = self.monitorGroupId!
            }
            if self.multiAZPolicy != nil {
                map["MultiAZPolicy"] = self.multiAZPolicy!
            }
            if self.onDemandBaseCapacity != nil {
                map["OnDemandBaseCapacity"] = self.onDemandBaseCapacity!
            }
            if self.onDemandPercentageAboveBaseCapacity != nil {
                map["OnDemandPercentageAboveBaseCapacity"] = self.onDemandPercentageAboveBaseCapacity!
            }
            if self.pendingCapacity != nil {
                map["PendingCapacity"] = self.pendingCapacity!
            }
            if self.pendingWaitCapacity != nil {
                map["PendingWaitCapacity"] = self.pendingWaitCapacity!
            }
            if self.protectedCapacity != nil {
                map["ProtectedCapacity"] = self.protectedCapacity!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.removalPolicies != nil {
                map["RemovalPolicies"] = self.removalPolicies!
            }
            if self.removingCapacity != nil {
                map["RemovingCapacity"] = self.removingCapacity!
            }
            if self.removingWaitCapacity != nil {
                map["RemovingWaitCapacity"] = self.removingWaitCapacity!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.scalingGroupId != nil {
                map["ScalingGroupId"] = self.scalingGroupId!
            }
            if self.scalingGroupName != nil {
                map["ScalingGroupName"] = self.scalingGroupName!
            }
            if self.scalingPolicy != nil {
                map["ScalingPolicy"] = self.scalingPolicy!
            }
            if self.serverGroups != nil {
                var tmp : [Any] = []
                for k in self.serverGroups! {
                    tmp.append(k.toMap())
                }
                map["ServerGroups"] = tmp
            }
            if self.spotAllocationStrategy != nil {
                map["SpotAllocationStrategy"] = self.spotAllocationStrategy!
            }
            if self.spotInstancePools != nil {
                map["SpotInstancePools"] = self.spotInstancePools!
            }
            if self.spotInstanceRemedy != nil {
                map["SpotInstanceRemedy"] = self.spotInstanceRemedy!
            }
            if self.standbyCapacity != nil {
                map["StandbyCapacity"] = self.standbyCapacity!
            }
            if self.stoppedCapacity != nil {
                map["StoppedCapacity"] = self.stoppedCapacity!
            }
            if self.suspendedProcesses != nil {
                map["SuspendedProcesses"] = self.suspendedProcesses!
            }
            if self.systemSuspended != nil {
                map["SystemSuspended"] = self.systemSuspended!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            if self.totalCapacity != nil {
                map["TotalCapacity"] = self.totalCapacity!
            }
            if self.totalInstanceCount != nil {
                map["TotalInstanceCount"] = self.totalInstanceCount!
            }
            if self.VServerGroups != nil {
                var tmp : [Any] = []
                for k in self.VServerGroups! {
                    tmp.append(k.toMap())
                }
                map["VServerGroups"] = tmp
            }
            if self.vSwitchId != nil {
                map["VSwitchId"] = self.vSwitchId!
            }
            if self.vSwitchIds != nil {
                map["VSwitchIds"] = self.vSwitchIds!
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ActiveCapacity") && dict["ActiveCapacity"] != nil {
                self.activeCapacity = dict["ActiveCapacity"] as! Int32
            }
            if dict.keys.contains("ActiveScalingConfigurationId") && dict["ActiveScalingConfigurationId"] != nil {
                self.activeScalingConfigurationId = dict["ActiveScalingConfigurationId"] as! String
            }
            if dict.keys.contains("AlbServerGroups") && dict["AlbServerGroups"] != nil {
                var tmp : [DescribeScalingGroupDetailResponseBody.ScalingGroup.AlbServerGroups] = []
                for v in dict["AlbServerGroups"] as! [Any] {
                    var model = DescribeScalingGroupDetailResponseBody.ScalingGroup.AlbServerGroups()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.albServerGroups = tmp
            }
            if dict.keys.contains("AllocationStrategy") && dict["AllocationStrategy"] != nil {
                self.allocationStrategy = dict["AllocationStrategy"] as! String
            }
            if dict.keys.contains("AzBalance") && dict["AzBalance"] != nil {
                self.azBalance = dict["AzBalance"] as! Bool
            }
            if dict.keys.contains("CompensateWithOnDemand") && dict["CompensateWithOnDemand"] != nil {
                self.compensateWithOnDemand = dict["CompensateWithOnDemand"] as! Bool
            }
            if dict.keys.contains("CreationTime") && dict["CreationTime"] != nil {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("CurrentHostName") && dict["CurrentHostName"] != nil {
                self.currentHostName = dict["CurrentHostName"] as! String
            }
            if dict.keys.contains("CustomPolicyARN") && dict["CustomPolicyARN"] != nil {
                self.customPolicyARN = dict["CustomPolicyARN"] as! String
            }
            if dict.keys.contains("DBInstanceIds") && dict["DBInstanceIds"] != nil {
                self.DBInstanceIds = dict["DBInstanceIds"] as! [String]
            }
            if dict.keys.contains("DefaultCooldown") && dict["DefaultCooldown"] != nil {
                self.defaultCooldown = dict["DefaultCooldown"] as! Int32
            }
            if dict.keys.contains("DesiredCapacity") && dict["DesiredCapacity"] != nil {
                self.desiredCapacity = dict["DesiredCapacity"] as! Int32
            }
            if dict.keys.contains("EnableDesiredCapacity") && dict["EnableDesiredCapacity"] != nil {
                self.enableDesiredCapacity = dict["EnableDesiredCapacity"] as! Bool
            }
            if dict.keys.contains("GroupDeletionProtection") && dict["GroupDeletionProtection"] != nil {
                self.groupDeletionProtection = dict["GroupDeletionProtection"] as! Bool
            }
            if dict.keys.contains("GroupType") && dict["GroupType"] != nil {
                self.groupType = dict["GroupType"] as! String
            }
            if dict.keys.contains("HealthCheckType") && dict["HealthCheckType"] != nil {
                self.healthCheckType = dict["HealthCheckType"] as! String
            }
            if dict.keys.contains("HealthCheckTypes") && dict["HealthCheckTypes"] != nil {
                self.healthCheckTypes = dict["HealthCheckTypes"] as! [String]
            }
            if dict.keys.contains("InitCapacity") && dict["InitCapacity"] != nil {
                self.initCapacity = dict["InitCapacity"] as! Int32
            }
            if dict.keys.contains("IsElasticStrengthInAlarm") && dict["IsElasticStrengthInAlarm"] != nil {
                self.isElasticStrengthInAlarm = dict["IsElasticStrengthInAlarm"] as! Bool
            }
            if dict.keys.contains("LaunchTemplateId") && dict["LaunchTemplateId"] != nil {
                self.launchTemplateId = dict["LaunchTemplateId"] as! String
            }
            if dict.keys.contains("LaunchTemplateOverrides") && dict["LaunchTemplateOverrides"] != nil {
                var tmp : [DescribeScalingGroupDetailResponseBody.ScalingGroup.LaunchTemplateOverrides] = []
                for v in dict["LaunchTemplateOverrides"] as! [Any] {
                    var model = DescribeScalingGroupDetailResponseBody.ScalingGroup.LaunchTemplateOverrides()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.launchTemplateOverrides = tmp
            }
            if dict.keys.contains("LaunchTemplateVersion") && dict["LaunchTemplateVersion"] != nil {
                self.launchTemplateVersion = dict["LaunchTemplateVersion"] as! String
            }
            if dict.keys.contains("LifecycleState") && dict["LifecycleState"] != nil {
                self.lifecycleState = dict["LifecycleState"] as! String
            }
            if dict.keys.contains("LoadBalancerConfigs") && dict["LoadBalancerConfigs"] != nil {
                var tmp : [DescribeScalingGroupDetailResponseBody.ScalingGroup.LoadBalancerConfigs] = []
                for v in dict["LoadBalancerConfigs"] as! [Any] {
                    var model = DescribeScalingGroupDetailResponseBody.ScalingGroup.LoadBalancerConfigs()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.loadBalancerConfigs = tmp
            }
            if dict.keys.contains("LoadBalancerIds") && dict["LoadBalancerIds"] != nil {
                self.loadBalancerIds = dict["LoadBalancerIds"] as! [String]
            }
            if dict.keys.contains("MaxInstanceLifetime") && dict["MaxInstanceLifetime"] != nil {
                self.maxInstanceLifetime = dict["MaxInstanceLifetime"] as! Int32
            }
            if dict.keys.contains("MaxSize") && dict["MaxSize"] != nil {
                self.maxSize = dict["MaxSize"] as! Int32
            }
            if dict.keys.contains("MinSize") && dict["MinSize"] != nil {
                self.minSize = dict["MinSize"] as! Int32
            }
            if dict.keys.contains("ModificationTime") && dict["ModificationTime"] != nil {
                self.modificationTime = dict["ModificationTime"] as! String
            }
            if dict.keys.contains("MonitorGroupId") && dict["MonitorGroupId"] != nil {
                self.monitorGroupId = dict["MonitorGroupId"] as! String
            }
            if dict.keys.contains("MultiAZPolicy") && dict["MultiAZPolicy"] != nil {
                self.multiAZPolicy = dict["MultiAZPolicy"] as! String
            }
            if dict.keys.contains("OnDemandBaseCapacity") && dict["OnDemandBaseCapacity"] != nil {
                self.onDemandBaseCapacity = dict["OnDemandBaseCapacity"] as! Int32
            }
            if dict.keys.contains("OnDemandPercentageAboveBaseCapacity") && dict["OnDemandPercentageAboveBaseCapacity"] != nil {
                self.onDemandPercentageAboveBaseCapacity = dict["OnDemandPercentageAboveBaseCapacity"] as! Int32
            }
            if dict.keys.contains("PendingCapacity") && dict["PendingCapacity"] != nil {
                self.pendingCapacity = dict["PendingCapacity"] as! Int32
            }
            if dict.keys.contains("PendingWaitCapacity") && dict["PendingWaitCapacity"] != nil {
                self.pendingWaitCapacity = dict["PendingWaitCapacity"] as! Int32
            }
            if dict.keys.contains("ProtectedCapacity") && dict["ProtectedCapacity"] != nil {
                self.protectedCapacity = dict["ProtectedCapacity"] as! Int32
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("RemovalPolicies") && dict["RemovalPolicies"] != nil {
                self.removalPolicies = dict["RemovalPolicies"] as! [String]
            }
            if dict.keys.contains("RemovingCapacity") && dict["RemovingCapacity"] != nil {
                self.removingCapacity = dict["RemovingCapacity"] as! Int32
            }
            if dict.keys.contains("RemovingWaitCapacity") && dict["RemovingWaitCapacity"] != nil {
                self.removingWaitCapacity = dict["RemovingWaitCapacity"] as! Int32
            }
            if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
                self.resourceGroupId = dict["ResourceGroupId"] as! String
            }
            if dict.keys.contains("ScalingGroupId") && dict["ScalingGroupId"] != nil {
                self.scalingGroupId = dict["ScalingGroupId"] as! String
            }
            if dict.keys.contains("ScalingGroupName") && dict["ScalingGroupName"] != nil {
                self.scalingGroupName = dict["ScalingGroupName"] as! String
            }
            if dict.keys.contains("ScalingPolicy") && dict["ScalingPolicy"] != nil {
                self.scalingPolicy = dict["ScalingPolicy"] as! String
            }
            if dict.keys.contains("ServerGroups") && dict["ServerGroups"] != nil {
                var tmp : [DescribeScalingGroupDetailResponseBody.ScalingGroup.ServerGroups] = []
                for v in dict["ServerGroups"] as! [Any] {
                    var model = DescribeScalingGroupDetailResponseBody.ScalingGroup.ServerGroups()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.serverGroups = tmp
            }
            if dict.keys.contains("SpotAllocationStrategy") && dict["SpotAllocationStrategy"] != nil {
                self.spotAllocationStrategy = dict["SpotAllocationStrategy"] as! String
            }
            if dict.keys.contains("SpotInstancePools") && dict["SpotInstancePools"] != nil {
                self.spotInstancePools = dict["SpotInstancePools"] as! Int32
            }
            if dict.keys.contains("SpotInstanceRemedy") && dict["SpotInstanceRemedy"] != nil {
                self.spotInstanceRemedy = dict["SpotInstanceRemedy"] as! Bool
            }
            if dict.keys.contains("StandbyCapacity") && dict["StandbyCapacity"] != nil {
                self.standbyCapacity = dict["StandbyCapacity"] as! Int32
            }
            if dict.keys.contains("StoppedCapacity") && dict["StoppedCapacity"] != nil {
                self.stoppedCapacity = dict["StoppedCapacity"] as! Int32
            }
            if dict.keys.contains("SuspendedProcesses") && dict["SuspendedProcesses"] != nil {
                self.suspendedProcesses = dict["SuspendedProcesses"] as! [String]
            }
            if dict.keys.contains("SystemSuspended") && dict["SystemSuspended"] != nil {
                self.systemSuspended = dict["SystemSuspended"] as! Bool
            }
            if dict.keys.contains("Tags") && dict["Tags"] != nil {
                var tmp : [DescribeScalingGroupDetailResponseBody.ScalingGroup.Tags] = []
                for v in dict["Tags"] as! [Any] {
                    var model = DescribeScalingGroupDetailResponseBody.ScalingGroup.Tags()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tags = tmp
            }
            if dict.keys.contains("TotalCapacity") && dict["TotalCapacity"] != nil {
                self.totalCapacity = dict["TotalCapacity"] as! Int32
            }
            if dict.keys.contains("TotalInstanceCount") && dict["TotalInstanceCount"] != nil {
                self.totalInstanceCount = dict["TotalInstanceCount"] as! Int32
            }
            if dict.keys.contains("VServerGroups") && dict["VServerGroups"] != nil {
                var tmp : [DescribeScalingGroupDetailResponseBody.ScalingGroup.VServerGroups] = []
                for v in dict["VServerGroups"] as! [Any] {
                    var model = DescribeScalingGroupDetailResponseBody.ScalingGroup.VServerGroups()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.VServerGroups = tmp
            }
            if dict.keys.contains("VSwitchId") && dict["VSwitchId"] != nil {
                self.vSwitchId = dict["VSwitchId"] as! String
            }
            if dict.keys.contains("VSwitchIds") && dict["VSwitchIds"] != nil {
                self.vSwitchIds = dict["VSwitchIds"] as! [String]
            }
            if dict.keys.contains("VpcId") && dict["VpcId"] != nil {
                self.vpcId = dict["VpcId"] as! String
            }
        }
    }
    public var output: String?

    public var requestId: String?

    public var scalingGroup: DescribeScalingGroupDetailResponseBody.ScalingGroup?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.scalingGroup?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.output != nil {
            map["Output"] = self.output!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingGroup != nil {
            map["ScalingGroup"] = self.scalingGroup?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Output") && dict["Output"] != nil {
            self.output = dict["Output"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScalingGroup") && dict["ScalingGroup"] != nil {
            var model = DescribeScalingGroupDetailResponseBody.ScalingGroup()
            model.fromMap(dict["ScalingGroup"] as! [String: Any])
            self.scalingGroup = model
        }
    }
}

public class DescribeScalingGroupDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeScalingGroupDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeScalingGroupDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeScalingGroupsRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var groupType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var scalingGroupIds: [String]?

    public var scalingGroupName: String?

    public var scalingGroupNames: [String]?

    public var tags: [DescribeScalingGroupsRequest.Tags]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupType != nil {
            map["GroupType"] = self.groupType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.scalingGroupIds != nil {
            map["ScalingGroupIds"] = self.scalingGroupIds!
        }
        if self.scalingGroupName != nil {
            map["ScalingGroupName"] = self.scalingGroupName!
        }
        if self.scalingGroupNames != nil {
            map["ScalingGroupNames"] = self.scalingGroupNames!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupType") && dict["GroupType"] != nil {
            self.groupType = dict["GroupType"] as! String
        }
        if dict.keys.contains("OwnerAccount") && dict["OwnerAccount"] != nil {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ScalingGroupIds") && dict["ScalingGroupIds"] != nil {
            self.scalingGroupIds = dict["ScalingGroupIds"] as! [String]
        }
        if dict.keys.contains("ScalingGroupName") && dict["ScalingGroupName"] != nil {
            self.scalingGroupName = dict["ScalingGroupName"] as! String
        }
        if dict.keys.contains("ScalingGroupNames") && dict["ScalingGroupNames"] != nil {
            self.scalingGroupNames = dict["ScalingGroupNames"] as! [String]
        }
        if dict.keys.contains("Tags") && dict["Tags"] != nil {
            var tmp : [DescribeScalingGroupsRequest.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = DescribeScalingGroupsRequest.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
    }
}

public class DescribeScalingGroupsResponseBody : Tea.TeaModel {
    public class ScalingGroups : Tea.TeaModel {
        public class AlbServerGroups : Tea.TeaModel {
            public var albServerGroupId: String?

            public var port: Int32?

            public var weight: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.albServerGroupId != nil {
                    map["AlbServerGroupId"] = self.albServerGroupId!
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.weight != nil {
                    map["Weight"] = self.weight!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AlbServerGroupId") && dict["AlbServerGroupId"] != nil {
                    self.albServerGroupId = dict["AlbServerGroupId"] as! String
                }
                if dict.keys.contains("Port") && dict["Port"] != nil {
                    self.port = dict["Port"] as! Int32
                }
                if dict.keys.contains("Weight") && dict["Weight"] != nil {
                    self.weight = dict["Weight"] as! Int32
                }
            }
        }
        public class LaunchTemplateOverrides : Tea.TeaModel {
            public var instanceType: String?

            public var spotPriceLimit: Double?

            public var weightedCapacity: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.instanceType != nil {
                    map["InstanceType"] = self.instanceType!
                }
                if self.spotPriceLimit != nil {
                    map["SpotPriceLimit"] = self.spotPriceLimit!
                }
                if self.weightedCapacity != nil {
                    map["WeightedCapacity"] = self.weightedCapacity!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("InstanceType") && dict["InstanceType"] != nil {
                    self.instanceType = dict["InstanceType"] as! String
                }
                if dict.keys.contains("SpotPriceLimit") && dict["SpotPriceLimit"] != nil {
                    self.spotPriceLimit = dict["SpotPriceLimit"] as! Double
                }
                if dict.keys.contains("WeightedCapacity") && dict["WeightedCapacity"] != nil {
                    self.weightedCapacity = dict["WeightedCapacity"] as! Int32
                }
            }
        }
        public class LoadBalancerConfigs : Tea.TeaModel {
            public var loadBalancerId: String?

            public var weight: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.loadBalancerId != nil {
                    map["LoadBalancerId"] = self.loadBalancerId!
                }
                if self.weight != nil {
                    map["Weight"] = self.weight!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("LoadBalancerId") && dict["LoadBalancerId"] != nil {
                    self.loadBalancerId = dict["LoadBalancerId"] as! String
                }
                if dict.keys.contains("Weight") && dict["Weight"] != nil {
                    self.weight = dict["Weight"] as! Int32
                }
            }
        }
        public class ServerGroups : Tea.TeaModel {
            public var port: Int32?

            public var serverGroupId: String?

            public var type: String?

            public var weight: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.serverGroupId != nil {
                    map["ServerGroupId"] = self.serverGroupId!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.weight != nil {
                    map["Weight"] = self.weight!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Port") && dict["Port"] != nil {
                    self.port = dict["Port"] as! Int32
                }
                if dict.keys.contains("ServerGroupId") && dict["ServerGroupId"] != nil {
                    self.serverGroupId = dict["ServerGroupId"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Weight") && dict["Weight"] != nil {
                    self.weight = dict["Weight"] as! Int32
                }
            }
        }
        public class Tags : Tea.TeaModel {
            public var propagate: Bool?

            public var tagKey: String?

            public var tagValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.propagate != nil {
                    map["Propagate"] = self.propagate!
                }
                if self.tagKey != nil {
                    map["TagKey"] = self.tagKey!
                }
                if self.tagValue != nil {
                    map["TagValue"] = self.tagValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Propagate") && dict["Propagate"] != nil {
                    self.propagate = dict["Propagate"] as! Bool
                }
                if dict.keys.contains("TagKey") && dict["TagKey"] != nil {
                    self.tagKey = dict["TagKey"] as! String
                }
                if dict.keys.contains("TagValue") && dict["TagValue"] != nil {
                    self.tagValue = dict["TagValue"] as! String
                }
            }
        }
        public class VServerGroups : Tea.TeaModel {
            public class VServerGroupAttributes : Tea.TeaModel {
                public var port: Int32?

                public var VServerGroupId: String?

                public var weight: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.port != nil {
                        map["Port"] = self.port!
                    }
                    if self.VServerGroupId != nil {
                        map["VServerGroupId"] = self.VServerGroupId!
                    }
                    if self.weight != nil {
                        map["Weight"] = self.weight!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Port") && dict["Port"] != nil {
                        self.port = dict["Port"] as! Int32
                    }
                    if dict.keys.contains("VServerGroupId") && dict["VServerGroupId"] != nil {
                        self.VServerGroupId = dict["VServerGroupId"] as! String
                    }
                    if dict.keys.contains("Weight") && dict["Weight"] != nil {
                        self.weight = dict["Weight"] as! Int32
                    }
                }
            }
            public var loadBalancerId: String?

            public var VServerGroupAttributes: [DescribeScalingGroupsResponseBody.ScalingGroups.VServerGroups.VServerGroupAttributes]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.loadBalancerId != nil {
                    map["LoadBalancerId"] = self.loadBalancerId!
                }
                if self.VServerGroupAttributes != nil {
                    var tmp : [Any] = []
                    for k in self.VServerGroupAttributes! {
                        tmp.append(k.toMap())
                    }
                    map["VServerGroupAttributes"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("LoadBalancerId") && dict["LoadBalancerId"] != nil {
                    self.loadBalancerId = dict["LoadBalancerId"] as! String
                }
                if dict.keys.contains("VServerGroupAttributes") && dict["VServerGroupAttributes"] != nil {
                    var tmp : [DescribeScalingGroupsResponseBody.ScalingGroups.VServerGroups.VServerGroupAttributes] = []
                    for v in dict["VServerGroupAttributes"] as! [Any] {
                        var model = DescribeScalingGroupsResponseBody.ScalingGroups.VServerGroups.VServerGroupAttributes()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.VServerGroupAttributes = tmp
                }
            }
        }
        public var activeCapacity: Int32?

        public var activeScalingConfigurationId: String?

        public var albServerGroups: [DescribeScalingGroupsResponseBody.ScalingGroups.AlbServerGroups]?

        public var allocationStrategy: String?

        public var azBalance: Bool?

        public var compensateWithOnDemand: Bool?

        public var creationTime: String?

        public var currentHostName: String?

        public var customPolicyARN: String?

        public var DBInstanceIds: [String]?

        public var defaultCooldown: Int32?

        public var desiredCapacity: Int32?

        public var enableDesiredCapacity: Bool?

        public var groupDeletionProtection: Bool?

        public var groupType: String?

        public var healthCheckType: String?

        public var healthCheckTypes: [String]?

        public var initCapacity: Int32?

        public var isElasticStrengthInAlarm: Bool?

        public var launchTemplateId: String?

        public var launchTemplateOverrides: [DescribeScalingGroupsResponseBody.ScalingGroups.LaunchTemplateOverrides]?

        public var launchTemplateVersion: String?

        public var lifecycleState: String?

        public var loadBalancerConfigs: [DescribeScalingGroupsResponseBody.ScalingGroups.LoadBalancerConfigs]?

        public var loadBalancerIds: [String]?

        public var maxInstanceLifetime: Int32?

        public var maxSize: Int32?

        public var minSize: Int32?

        public var modificationTime: String?

        public var monitorGroupId: String?

        public var multiAZPolicy: String?

        public var onDemandBaseCapacity: Int32?

        public var onDemandPercentageAboveBaseCapacity: Int32?

        public var pendingCapacity: Int32?

        public var pendingWaitCapacity: Int32?

        public var protectedCapacity: Int32?

        public var regionId: String?

        public var removalPolicies: [String]?

        public var removingCapacity: Int32?

        public var removingWaitCapacity: Int32?

        public var resourceGroupId: String?

        public var scalingGroupId: String?

        public var scalingGroupName: String?

        public var scalingPolicy: String?

        public var serverGroups: [DescribeScalingGroupsResponseBody.ScalingGroups.ServerGroups]?

        public var spotAllocationStrategy: String?

        public var spotInstancePools: Int32?

        public var spotInstanceRemedy: Bool?

        public var standbyCapacity: Int32?

        public var stoppedCapacity: Int32?

        public var suspendedProcesses: [String]?

        public var systemSuspended: Bool?

        public var tags: [DescribeScalingGroupsResponseBody.ScalingGroups.Tags]?

        public var totalCapacity: Int32?

        public var totalInstanceCount: Int32?

        public var VServerGroups: [DescribeScalingGroupsResponseBody.ScalingGroups.VServerGroups]?

        public var vSwitchId: String?

        public var vSwitchIds: [String]?

        public var vpcId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.activeCapacity != nil {
                map["ActiveCapacity"] = self.activeCapacity!
            }
            if self.activeScalingConfigurationId != nil {
                map["ActiveScalingConfigurationId"] = self.activeScalingConfigurationId!
            }
            if self.albServerGroups != nil {
                var tmp : [Any] = []
                for k in self.albServerGroups! {
                    tmp.append(k.toMap())
                }
                map["AlbServerGroups"] = tmp
            }
            if self.allocationStrategy != nil {
                map["AllocationStrategy"] = self.allocationStrategy!
            }
            if self.azBalance != nil {
                map["AzBalance"] = self.azBalance!
            }
            if self.compensateWithOnDemand != nil {
                map["CompensateWithOnDemand"] = self.compensateWithOnDemand!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.currentHostName != nil {
                map["CurrentHostName"] = self.currentHostName!
            }
            if self.customPolicyARN != nil {
                map["CustomPolicyARN"] = self.customPolicyARN!
            }
            if self.DBInstanceIds != nil {
                map["DBInstanceIds"] = self.DBInstanceIds!
            }
            if self.defaultCooldown != nil {
                map["DefaultCooldown"] = self.defaultCooldown!
            }
            if self.desiredCapacity != nil {
                map["DesiredCapacity"] = self.desiredCapacity!
            }
            if self.enableDesiredCapacity != nil {
                map["EnableDesiredCapacity"] = self.enableDesiredCapacity!
            }
            if self.groupDeletionProtection != nil {
                map["GroupDeletionProtection"] = self.groupDeletionProtection!
            }
            if self.groupType != nil {
                map["GroupType"] = self.groupType!
            }
            if self.healthCheckType != nil {
                map["HealthCheckType"] = self.healthCheckType!
            }
            if self.healthCheckTypes != nil {
                map["HealthCheckTypes"] = self.healthCheckTypes!
            }
            if self.initCapacity != nil {
                map["InitCapacity"] = self.initCapacity!
            }
            if self.isElasticStrengthInAlarm != nil {
                map["IsElasticStrengthInAlarm"] = self.isElasticStrengthInAlarm!
            }
            if self.launchTemplateId != nil {
                map["LaunchTemplateId"] = self.launchTemplateId!
            }
            if self.launchTemplateOverrides != nil {
                var tmp : [Any] = []
                for k in self.launchTemplateOverrides! {
                    tmp.append(k.toMap())
                }
                map["LaunchTemplateOverrides"] = tmp
            }
            if self.launchTemplateVersion != nil {
                map["LaunchTemplateVersion"] = self.launchTemplateVersion!
            }
            if self.lifecycleState != nil {
                map["LifecycleState"] = self.lifecycleState!
            }
            if self.loadBalancerConfigs != nil {
                var tmp : [Any] = []
                for k in self.loadBalancerConfigs! {
                    tmp.append(k.toMap())
                }
                map["LoadBalancerConfigs"] = tmp
            }
            if self.loadBalancerIds != nil {
                map["LoadBalancerIds"] = self.loadBalancerIds!
            }
            if self.maxInstanceLifetime != nil {
                map["MaxInstanceLifetime"] = self.maxInstanceLifetime!
            }
            if self.maxSize != nil {
                map["MaxSize"] = self.maxSize!
            }
            if self.minSize != nil {
                map["MinSize"] = self.minSize!
            }
            if self.modificationTime != nil {
                map["ModificationTime"] = self.modificationTime!
            }
            if self.monitorGroupId != nil {
                map["MonitorGroupId"] = self.monitorGroupId!
            }
            if self.multiAZPolicy != nil {
                map["MultiAZPolicy"] = self.multiAZPolicy!
            }
            if self.onDemandBaseCapacity != nil {
                map["OnDemandBaseCapacity"] = self.onDemandBaseCapacity!
            }
            if self.onDemandPercentageAboveBaseCapacity != nil {
                map["OnDemandPercentageAboveBaseCapacity"] = self.onDemandPercentageAboveBaseCapacity!
            }
            if self.pendingCapacity != nil {
                map["PendingCapacity"] = self.pendingCapacity!
            }
            if self.pendingWaitCapacity != nil {
                map["PendingWaitCapacity"] = self.pendingWaitCapacity!
            }
            if self.protectedCapacity != nil {
                map["ProtectedCapacity"] = self.protectedCapacity!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.removalPolicies != nil {
                map["RemovalPolicies"] = self.removalPolicies!
            }
            if self.removingCapacity != nil {
                map["RemovingCapacity"] = self.removingCapacity!
            }
            if self.removingWaitCapacity != nil {
                map["RemovingWaitCapacity"] = self.removingWaitCapacity!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.scalingGroupId != nil {
                map["ScalingGroupId"] = self.scalingGroupId!
            }
            if self.scalingGroupName != nil {
                map["ScalingGroupName"] = self.scalingGroupName!
            }
            if self.scalingPolicy != nil {
                map["ScalingPolicy"] = self.scalingPolicy!
            }
            if self.serverGroups != nil {
                var tmp : [Any] = []
                for k in self.serverGroups! {
                    tmp.append(k.toMap())
                }
                map["ServerGroups"] = tmp
            }
            if self.spotAllocationStrategy != nil {
                map["SpotAllocationStrategy"] = self.spotAllocationStrategy!
            }
            if self.spotInstancePools != nil {
                map["SpotInstancePools"] = self.spotInstancePools!
            }
            if self.spotInstanceRemedy != nil {
                map["SpotInstanceRemedy"] = self.spotInstanceRemedy!
            }
            if self.standbyCapacity != nil {
                map["StandbyCapacity"] = self.standbyCapacity!
            }
            if self.stoppedCapacity != nil {
                map["StoppedCapacity"] = self.stoppedCapacity!
            }
            if self.suspendedProcesses != nil {
                map["SuspendedProcesses"] = self.suspendedProcesses!
            }
            if self.systemSuspended != nil {
                map["SystemSuspended"] = self.systemSuspended!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            if self.totalCapacity != nil {
                map["TotalCapacity"] = self.totalCapacity!
            }
            if self.totalInstanceCount != nil {
                map["TotalInstanceCount"] = self.totalInstanceCount!
            }
            if self.VServerGroups != nil {
                var tmp : [Any] = []
                for k in self.VServerGroups! {
                    tmp.append(k.toMap())
                }
                map["VServerGroups"] = tmp
            }
            if self.vSwitchId != nil {
                map["VSwitchId"] = self.vSwitchId!
            }
            if self.vSwitchIds != nil {
                map["VSwitchIds"] = self.vSwitchIds!
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ActiveCapacity") && dict["ActiveCapacity"] != nil {
                self.activeCapacity = dict["ActiveCapacity"] as! Int32
            }
            if dict.keys.contains("ActiveScalingConfigurationId") && dict["ActiveScalingConfigurationId"] != nil {
                self.activeScalingConfigurationId = dict["ActiveScalingConfigurationId"] as! String
            }
            if dict.keys.contains("AlbServerGroups") && dict["AlbServerGroups"] != nil {
                var tmp : [DescribeScalingGroupsResponseBody.ScalingGroups.AlbServerGroups] = []
                for v in dict["AlbServerGroups"] as! [Any] {
                    var model = DescribeScalingGroupsResponseBody.ScalingGroups.AlbServerGroups()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.albServerGroups = tmp
            }
            if dict.keys.contains("AllocationStrategy") && dict["AllocationStrategy"] != nil {
                self.allocationStrategy = dict["AllocationStrategy"] as! String
            }
            if dict.keys.contains("AzBalance") && dict["AzBalance"] != nil {
                self.azBalance = dict["AzBalance"] as! Bool
            }
            if dict.keys.contains("CompensateWithOnDemand") && dict["CompensateWithOnDemand"] != nil {
                self.compensateWithOnDemand = dict["CompensateWithOnDemand"] as! Bool
            }
            if dict.keys.contains("CreationTime") && dict["CreationTime"] != nil {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("CurrentHostName") && dict["CurrentHostName"] != nil {
                self.currentHostName = dict["CurrentHostName"] as! String
            }
            if dict.keys.contains("CustomPolicyARN") && dict["CustomPolicyARN"] != nil {
                self.customPolicyARN = dict["CustomPolicyARN"] as! String
            }
            if dict.keys.contains("DBInstanceIds") && dict["DBInstanceIds"] != nil {
                self.DBInstanceIds = dict["DBInstanceIds"] as! [String]
            }
            if dict.keys.contains("DefaultCooldown") && dict["DefaultCooldown"] != nil {
                self.defaultCooldown = dict["DefaultCooldown"] as! Int32
            }
            if dict.keys.contains("DesiredCapacity") && dict["DesiredCapacity"] != nil {
                self.desiredCapacity = dict["DesiredCapacity"] as! Int32
            }
            if dict.keys.contains("EnableDesiredCapacity") && dict["EnableDesiredCapacity"] != nil {
                self.enableDesiredCapacity = dict["EnableDesiredCapacity"] as! Bool
            }
            if dict.keys.contains("GroupDeletionProtection") && dict["GroupDeletionProtection"] != nil {
                self.groupDeletionProtection = dict["GroupDeletionProtection"] as! Bool
            }
            if dict.keys.contains("GroupType") && dict["GroupType"] != nil {
                self.groupType = dict["GroupType"] as! String
            }
            if dict.keys.contains("HealthCheckType") && dict["HealthCheckType"] != nil {
                self.healthCheckType = dict["HealthCheckType"] as! String
            }
            if dict.keys.contains("HealthCheckTypes") && dict["HealthCheckTypes"] != nil {
                self.healthCheckTypes = dict["HealthCheckTypes"] as! [String]
            }
            if dict.keys.contains("InitCapacity") && dict["InitCapacity"] != nil {
                self.initCapacity = dict["InitCapacity"] as! Int32
            }
            if dict.keys.contains("IsElasticStrengthInAlarm") && dict["IsElasticStrengthInAlarm"] != nil {
                self.isElasticStrengthInAlarm = dict["IsElasticStrengthInAlarm"] as! Bool
            }
            if dict.keys.contains("LaunchTemplateId") && dict["LaunchTemplateId"] != nil {
                self.launchTemplateId = dict["LaunchTemplateId"] as! String
            }
            if dict.keys.contains("LaunchTemplateOverrides") && dict["LaunchTemplateOverrides"] != nil {
                var tmp : [DescribeScalingGroupsResponseBody.ScalingGroups.LaunchTemplateOverrides] = []
                for v in dict["LaunchTemplateOverrides"] as! [Any] {
                    var model = DescribeScalingGroupsResponseBody.ScalingGroups.LaunchTemplateOverrides()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.launchTemplateOverrides = tmp
            }
            if dict.keys.contains("LaunchTemplateVersion") && dict["LaunchTemplateVersion"] != nil {
                self.launchTemplateVersion = dict["LaunchTemplateVersion"] as! String
            }
            if dict.keys.contains("LifecycleState") && dict["LifecycleState"] != nil {
                self.lifecycleState = dict["LifecycleState"] as! String
            }
            if dict.keys.contains("LoadBalancerConfigs") && dict["LoadBalancerConfigs"] != nil {
                var tmp : [DescribeScalingGroupsResponseBody.ScalingGroups.LoadBalancerConfigs] = []
                for v in dict["LoadBalancerConfigs"] as! [Any] {
                    var model = DescribeScalingGroupsResponseBody.ScalingGroups.LoadBalancerConfigs()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.loadBalancerConfigs = tmp
            }
            if dict.keys.contains("LoadBalancerIds") && dict["LoadBalancerIds"] != nil {
                self.loadBalancerIds = dict["LoadBalancerIds"] as! [String]
            }
            if dict.keys.contains("MaxInstanceLifetime") && dict["MaxInstanceLifetime"] != nil {
                self.maxInstanceLifetime = dict["MaxInstanceLifetime"] as! Int32
            }
            if dict.keys.contains("MaxSize") && dict["MaxSize"] != nil {
                self.maxSize = dict["MaxSize"] as! Int32
            }
            if dict.keys.contains("MinSize") && dict["MinSize"] != nil {
                self.minSize = dict["MinSize"] as! Int32
            }
            if dict.keys.contains("ModificationTime") && dict["ModificationTime"] != nil {
                self.modificationTime = dict["ModificationTime"] as! String
            }
            if dict.keys.contains("MonitorGroupId") && dict["MonitorGroupId"] != nil {
                self.monitorGroupId = dict["MonitorGroupId"] as! String
            }
            if dict.keys.contains("MultiAZPolicy") && dict["MultiAZPolicy"] != nil {
                self.multiAZPolicy = dict["MultiAZPolicy"] as! String
            }
            if dict.keys.contains("OnDemandBaseCapacity") && dict["OnDemandBaseCapacity"] != nil {
                self.onDemandBaseCapacity = dict["OnDemandBaseCapacity"] as! Int32
            }
            if dict.keys.contains("OnDemandPercentageAboveBaseCapacity") && dict["OnDemandPercentageAboveBaseCapacity"] != nil {
                self.onDemandPercentageAboveBaseCapacity = dict["OnDemandPercentageAboveBaseCapacity"] as! Int32
            }
            if dict.keys.contains("PendingCapacity") && dict["PendingCapacity"] != nil {
                self.pendingCapacity = dict["PendingCapacity"] as! Int32
            }
            if dict.keys.contains("PendingWaitCapacity") && dict["PendingWaitCapacity"] != nil {
                self.pendingWaitCapacity = dict["PendingWaitCapacity"] as! Int32
            }
            if dict.keys.contains("ProtectedCapacity") && dict["ProtectedCapacity"] != nil {
                self.protectedCapacity = dict["ProtectedCapacity"] as! Int32
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("RemovalPolicies") && dict["RemovalPolicies"] != nil {
                self.removalPolicies = dict["RemovalPolicies"] as! [String]
            }
            if dict.keys.contains("RemovingCapacity") && dict["RemovingCapacity"] != nil {
                self.removingCapacity = dict["RemovingCapacity"] as! Int32
            }
            if dict.keys.contains("RemovingWaitCapacity") && dict["RemovingWaitCapacity"] != nil {
                self.removingWaitCapacity = dict["RemovingWaitCapacity"] as! Int32
            }
            if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
                self.resourceGroupId = dict["ResourceGroupId"] as! String
            }
            if dict.keys.contains("ScalingGroupId") && dict["ScalingGroupId"] != nil {
                self.scalingGroupId = dict["ScalingGroupId"] as! String
            }
            if dict.keys.contains("ScalingGroupName") && dict["ScalingGroupName"] != nil {
                self.scalingGroupName = dict["ScalingGroupName"] as! String
            }
            if dict.keys.contains("ScalingPolicy") && dict["ScalingPolicy"] != nil {
                self.scalingPolicy = dict["ScalingPolicy"] as! String
            }
            if dict.keys.contains("ServerGroups") && dict["ServerGroups"] != nil {
                var tmp : [DescribeScalingGroupsResponseBody.ScalingGroups.ServerGroups] = []
                for v in dict["ServerGroups"] as! [Any] {
                    var model = DescribeScalingGroupsResponseBody.ScalingGroups.ServerGroups()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.serverGroups = tmp
            }
            if dict.keys.contains("SpotAllocationStrategy") && dict["SpotAllocationStrategy"] != nil {
                self.spotAllocationStrategy = dict["SpotAllocationStrategy"] as! String
            }
            if dict.keys.contains("SpotInstancePools") && dict["SpotInstancePools"] != nil {
                self.spotInstancePools = dict["SpotInstancePools"] as! Int32
            }
            if dict.keys.contains("SpotInstanceRemedy") && dict["SpotInstanceRemedy"] != nil {
                self.spotInstanceRemedy = dict["SpotInstanceRemedy"] as! Bool
            }
            if dict.keys.contains("StandbyCapacity") && dict["StandbyCapacity"] != nil {
                self.standbyCapacity = dict["StandbyCapacity"] as! Int32
            }
            if dict.keys.contains("StoppedCapacity") && dict["StoppedCapacity"] != nil {
                self.stoppedCapacity = dict["StoppedCapacity"] as! Int32
            }
            if dict.keys.contains("SuspendedProcesses") && dict["SuspendedProcesses"] != nil {
                self.suspendedProcesses = dict["SuspendedProcesses"] as! [String]
            }
            if dict.keys.contains("SystemSuspended") && dict["SystemSuspended"] != nil {
                self.systemSuspended = dict["SystemSuspended"] as! Bool
            }
            if dict.keys.contains("Tags") && dict["Tags"] != nil {
                var tmp : [DescribeScalingGroupsResponseBody.ScalingGroups.Tags] = []
                for v in dict["Tags"] as! [Any] {
                    var model = DescribeScalingGroupsResponseBody.ScalingGroups.Tags()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tags = tmp
            }
            if dict.keys.contains("TotalCapacity") && dict["TotalCapacity"] != nil {
                self.totalCapacity = dict["TotalCapacity"] as! Int32
            }
            if dict.keys.contains("TotalInstanceCount") && dict["TotalInstanceCount"] != nil {
                self.totalInstanceCount = dict["TotalInstanceCount"] as! Int32
            }
            if dict.keys.contains("VServerGroups") && dict["VServerGroups"] != nil {
                var tmp : [DescribeScalingGroupsResponseBody.ScalingGroups.VServerGroups] = []
                for v in dict["VServerGroups"] as! [Any] {
                    var model = DescribeScalingGroupsResponseBody.ScalingGroups.VServerGroups()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.VServerGroups = tmp
            }
            if dict.keys.contains("VSwitchId") && dict["VSwitchId"] != nil {
                self.vSwitchId = dict["VSwitchId"] as! String
            }
            if dict.keys.contains("VSwitchIds") && dict["VSwitchIds"] != nil {
                self.vSwitchIds = dict["VSwitchIds"] as! [String]
            }
            if dict.keys.contains("VpcId") && dict["VpcId"] != nil {
                self.vpcId = dict["VpcId"] as! String
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var scalingGroups: [DescribeScalingGroupsResponseBody.ScalingGroups]?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingGroups != nil {
            var tmp : [Any] = []
            for k in self.scalingGroups! {
                tmp.append(k.toMap())
            }
            map["ScalingGroups"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScalingGroups") && dict["ScalingGroups"] != nil {
            var tmp : [DescribeScalingGroupsResponseBody.ScalingGroups] = []
            for v in dict["ScalingGroups"] as! [Any] {
                var model = DescribeScalingGroupsResponseBody.ScalingGroups()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.scalingGroups = tmp
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeScalingGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeScalingGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeScalingGroupsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeScalingInstancesRequest : Tea.TeaModel {
    public var creationType: String?

    public var creationTypes: [String]?

    public var healthStatus: String?

    public var instanceIds: [String]?

    public var lifecycleState: String?

    public var lifecycleStates: [String]?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var scalingActivityId: String?

    public var scalingConfigurationId: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.creationType != nil {
            map["CreationType"] = self.creationType!
        }
        if self.creationTypes != nil {
            map["CreationTypes"] = self.creationTypes!
        }
        if self.healthStatus != nil {
            map["HealthStatus"] = self.healthStatus!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.lifecycleState != nil {
            map["LifecycleState"] = self.lifecycleState!
        }
        if self.lifecycleStates != nil {
            map["LifecycleStates"] = self.lifecycleStates!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.scalingActivityId != nil {
            map["ScalingActivityId"] = self.scalingActivityId!
        }
        if self.scalingConfigurationId != nil {
            map["ScalingConfigurationId"] = self.scalingConfigurationId!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreationType") && dict["CreationType"] != nil {
            self.creationType = dict["CreationType"] as! String
        }
        if dict.keys.contains("CreationTypes") && dict["CreationTypes"] != nil {
            self.creationTypes = dict["CreationTypes"] as! [String]
        }
        if dict.keys.contains("HealthStatus") && dict["HealthStatus"] != nil {
            self.healthStatus = dict["HealthStatus"] as! String
        }
        if dict.keys.contains("InstanceIds") && dict["InstanceIds"] != nil {
            self.instanceIds = dict["InstanceIds"] as! [String]
        }
        if dict.keys.contains("LifecycleState") && dict["LifecycleState"] != nil {
            self.lifecycleState = dict["LifecycleState"] as! String
        }
        if dict.keys.contains("LifecycleStates") && dict["LifecycleStates"] != nil {
            self.lifecycleStates = dict["LifecycleStates"] as! [String]
        }
        if dict.keys.contains("OwnerAccount") && dict["OwnerAccount"] != nil {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ScalingActivityId") && dict["ScalingActivityId"] != nil {
            self.scalingActivityId = dict["ScalingActivityId"] as! String
        }
        if dict.keys.contains("ScalingConfigurationId") && dict["ScalingConfigurationId"] != nil {
            self.scalingConfigurationId = dict["ScalingConfigurationId"] as! String
        }
        if dict.keys.contains("ScalingGroupId") && dict["ScalingGroupId"] != nil {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
    }
}

public class DescribeScalingInstancesResponseBody : Tea.TeaModel {
    public class ScalingInstances : Tea.TeaModel {
        public var createdTime: String?

        public var creationTime: String?

        public var creationType: String?

        public var entrusted: Bool?

        public var healthStatus: String?

        public var instanceId: String?

        public var launchTemplateId: String?

        public var launchTemplateVersion: String?

        public var lifecycleState: String?

        public var loadBalancerWeight: Int32?

        public var privateIpAddress: String?

        public var scalingActivityId: String?

        public var scalingConfigurationId: String?

        public var scalingGroupId: String?

        public var scalingInstanceId: String?

        public var spotStrategy: String?

        public var warmupState: String?

        public var weightedCapacity: Int32?

        public var zoneId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createdTime != nil {
                map["CreatedTime"] = self.createdTime!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.creationType != nil {
                map["CreationType"] = self.creationType!
            }
            if self.entrusted != nil {
                map["Entrusted"] = self.entrusted!
            }
            if self.healthStatus != nil {
                map["HealthStatus"] = self.healthStatus!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.launchTemplateId != nil {
                map["LaunchTemplateId"] = self.launchTemplateId!
            }
            if self.launchTemplateVersion != nil {
                map["LaunchTemplateVersion"] = self.launchTemplateVersion!
            }
            if self.lifecycleState != nil {
                map["LifecycleState"] = self.lifecycleState!
            }
            if self.loadBalancerWeight != nil {
                map["LoadBalancerWeight"] = self.loadBalancerWeight!
            }
            if self.privateIpAddress != nil {
                map["PrivateIpAddress"] = self.privateIpAddress!
            }
            if self.scalingActivityId != nil {
                map["ScalingActivityId"] = self.scalingActivityId!
            }
            if self.scalingConfigurationId != nil {
                map["ScalingConfigurationId"] = self.scalingConfigurationId!
            }
            if self.scalingGroupId != nil {
                map["ScalingGroupId"] = self.scalingGroupId!
            }
            if self.scalingInstanceId != nil {
                map["ScalingInstanceId"] = self.scalingInstanceId!
            }
            if self.spotStrategy != nil {
                map["SpotStrategy"] = self.spotStrategy!
            }
            if self.warmupState != nil {
                map["WarmupState"] = self.warmupState!
            }
            if self.weightedCapacity != nil {
                map["WeightedCapacity"] = self.weightedCapacity!
            }
            if self.zoneId != nil {
                map["ZoneId"] = self.zoneId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreatedTime") && dict["CreatedTime"] != nil {
                self.createdTime = dict["CreatedTime"] as! String
            }
            if dict.keys.contains("CreationTime") && dict["CreationTime"] != nil {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("CreationType") && dict["CreationType"] != nil {
                self.creationType = dict["CreationType"] as! String
            }
            if dict.keys.contains("Entrusted") && dict["Entrusted"] != nil {
                self.entrusted = dict["Entrusted"] as! Bool
            }
            if dict.keys.contains("HealthStatus") && dict["HealthStatus"] != nil {
                self.healthStatus = dict["HealthStatus"] as! String
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("LaunchTemplateId") && dict["LaunchTemplateId"] != nil {
                self.launchTemplateId = dict["LaunchTemplateId"] as! String
            }
            if dict.keys.contains("LaunchTemplateVersion") && dict["LaunchTemplateVersion"] != nil {
                self.launchTemplateVersion = dict["LaunchTemplateVersion"] as! String
            }
            if dict.keys.contains("LifecycleState") && dict["LifecycleState"] != nil {
                self.lifecycleState = dict["LifecycleState"] as! String
            }
            if dict.keys.contains("LoadBalancerWeight") && dict["LoadBalancerWeight"] != nil {
                self.loadBalancerWeight = dict["LoadBalancerWeight"] as! Int32
            }
            if dict.keys.contains("PrivateIpAddress") && dict["PrivateIpAddress"] != nil {
                self.privateIpAddress = dict["PrivateIpAddress"] as! String
            }
            if dict.keys.contains("ScalingActivityId") && dict["ScalingActivityId"] != nil {
                self.scalingActivityId = dict["ScalingActivityId"] as! String
            }
            if dict.keys.contains("ScalingConfigurationId") && dict["ScalingConfigurationId"] != nil {
                self.scalingConfigurationId = dict["ScalingConfigurationId"] as! String
            }
            if dict.keys.contains("ScalingGroupId") && dict["ScalingGroupId"] != nil {
                self.scalingGroupId = dict["ScalingGroupId"] as! String
            }
            if dict.keys.contains("ScalingInstanceId") && dict["ScalingInstanceId"] != nil {
                self.scalingInstanceId = dict["ScalingInstanceId"] as! String
            }
            if dict.keys.contains("SpotStrategy") && dict["SpotStrategy"] != nil {
                self.spotStrategy = dict["SpotStrategy"] as! String
            }
            if dict.keys.contains("WarmupState") && dict["WarmupState"] != nil {
                self.warmupState = dict["WarmupState"] as! String
            }
            if dict.keys.contains("WeightedCapacity") && dict["WeightedCapacity"] != nil {
                self.weightedCapacity = dict["WeightedCapacity"] as! Int32
            }
            if dict.keys.contains("ZoneId") && dict["ZoneId"] != nil {
                self.zoneId = dict["ZoneId"] as! String
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var scalingInstances: [DescribeScalingInstancesResponseBody.ScalingInstances]?

    public var totalCount: Int32?

    public var totalSpotCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingInstances != nil {
            var tmp : [Any] = []
            for k in self.scalingInstances! {
                tmp.append(k.toMap())
            }
            map["ScalingInstances"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.totalSpotCount != nil {
            map["TotalSpotCount"] = self.totalSpotCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScalingInstances") && dict["ScalingInstances"] != nil {
            var tmp : [DescribeScalingInstancesResponseBody.ScalingInstances] = []
            for v in dict["ScalingInstances"] as! [Any] {
                var model = DescribeScalingInstancesResponseBody.ScalingInstances()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.scalingInstances = tmp
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
        if dict.keys.contains("TotalSpotCount") && dict["TotalSpotCount"] != nil {
            self.totalSpotCount = dict["TotalSpotCount"] as! Int32
        }
    }
}

public class DescribeScalingInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeScalingInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeScalingInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeScalingRulesRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var scalingGroupId: String?

    public var scalingRuleAris: [String]?

    public var scalingRuleIds: [String]?

    public var scalingRuleNames: [String]?

    public var scalingRuleType: String?

    public var showAlarmRules: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        if self.scalingRuleAris != nil {
            map["ScalingRuleAris"] = self.scalingRuleAris!
        }
        if self.scalingRuleIds != nil {
            map["ScalingRuleIds"] = self.scalingRuleIds!
        }
        if self.scalingRuleNames != nil {
            map["ScalingRuleNames"] = self.scalingRuleNames!
        }
        if self.scalingRuleType != nil {
            map["ScalingRuleType"] = self.scalingRuleType!
        }
        if self.showAlarmRules != nil {
            map["ShowAlarmRules"] = self.showAlarmRules!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") && dict["OwnerAccount"] != nil {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ScalingGroupId") && dict["ScalingGroupId"] != nil {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
        if dict.keys.contains("ScalingRuleAris") && dict["ScalingRuleAris"] != nil {
            self.scalingRuleAris = dict["ScalingRuleAris"] as! [String]
        }
        if dict.keys.contains("ScalingRuleIds") && dict["ScalingRuleIds"] != nil {
            self.scalingRuleIds = dict["ScalingRuleIds"] as! [String]
        }
        if dict.keys.contains("ScalingRuleNames") && dict["ScalingRuleNames"] != nil {
            self.scalingRuleNames = dict["ScalingRuleNames"] as! [String]
        }
        if dict.keys.contains("ScalingRuleType") && dict["ScalingRuleType"] != nil {
            self.scalingRuleType = dict["ScalingRuleType"] as! String
        }
        if dict.keys.contains("ShowAlarmRules") && dict["ShowAlarmRules"] != nil {
            self.showAlarmRules = dict["ShowAlarmRules"] as! Bool
        }
    }
}

public class DescribeScalingRulesResponseBody : Tea.TeaModel {
    public class ScalingRules : Tea.TeaModel {
        public class AlarmDimensions : Tea.TeaModel {
            public var dimensionKey: String?

            public var dimensionValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dimensionKey != nil {
                    map["DimensionKey"] = self.dimensionKey!
                }
                if self.dimensionValue != nil {
                    map["DimensionValue"] = self.dimensionValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DimensionKey") && dict["DimensionKey"] != nil {
                    self.dimensionKey = dict["DimensionKey"] as! String
                }
                if dict.keys.contains("DimensionValue") && dict["DimensionValue"] != nil {
                    self.dimensionValue = dict["DimensionValue"] as! String
                }
            }
        }
        public class Alarms : Tea.TeaModel {
            public class Dimensions : Tea.TeaModel {
                public var dimensionKey: String?

                public var dimensionValue: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dimensionKey != nil {
                        map["DimensionKey"] = self.dimensionKey!
                    }
                    if self.dimensionValue != nil {
                        map["DimensionValue"] = self.dimensionValue!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DimensionKey") && dict["DimensionKey"] != nil {
                        self.dimensionKey = dict["DimensionKey"] as! String
                    }
                    if dict.keys.contains("DimensionValue") && dict["DimensionValue"] != nil {
                        self.dimensionValue = dict["DimensionValue"] as! String
                    }
                }
            }
            public var alarmTaskId: String?

            public var alarmTaskName: String?

            public var comparisonOperator: String?

            public var dimensions: [DescribeScalingRulesResponseBody.ScalingRules.Alarms.Dimensions]?

            public var evaluationCount: Int32?

            public var metricName: String?

            public var metricType: String?

            public var statistics: String?

            public var threshold: Double?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.alarmTaskId != nil {
                    map["AlarmTaskId"] = self.alarmTaskId!
                }
                if self.alarmTaskName != nil {
                    map["AlarmTaskName"] = self.alarmTaskName!
                }
                if self.comparisonOperator != nil {
                    map["ComparisonOperator"] = self.comparisonOperator!
                }
                if self.dimensions != nil {
                    var tmp : [Any] = []
                    for k in self.dimensions! {
                        tmp.append(k.toMap())
                    }
                    map["Dimensions"] = tmp
                }
                if self.evaluationCount != nil {
                    map["EvaluationCount"] = self.evaluationCount!
                }
                if self.metricName != nil {
                    map["MetricName"] = self.metricName!
                }
                if self.metricType != nil {
                    map["MetricType"] = self.metricType!
                }
                if self.statistics != nil {
                    map["Statistics"] = self.statistics!
                }
                if self.threshold != nil {
                    map["Threshold"] = self.threshold!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AlarmTaskId") && dict["AlarmTaskId"] != nil {
                    self.alarmTaskId = dict["AlarmTaskId"] as! String
                }
                if dict.keys.contains("AlarmTaskName") && dict["AlarmTaskName"] != nil {
                    self.alarmTaskName = dict["AlarmTaskName"] as! String
                }
                if dict.keys.contains("ComparisonOperator") && dict["ComparisonOperator"] != nil {
                    self.comparisonOperator = dict["ComparisonOperator"] as! String
                }
                if dict.keys.contains("Dimensions") && dict["Dimensions"] != nil {
                    var tmp : [DescribeScalingRulesResponseBody.ScalingRules.Alarms.Dimensions] = []
                    for v in dict["Dimensions"] as! [Any] {
                        var model = DescribeScalingRulesResponseBody.ScalingRules.Alarms.Dimensions()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.dimensions = tmp
                }
                if dict.keys.contains("EvaluationCount") && dict["EvaluationCount"] != nil {
                    self.evaluationCount = dict["EvaluationCount"] as! Int32
                }
                if dict.keys.contains("MetricName") && dict["MetricName"] != nil {
                    self.metricName = dict["MetricName"] as! String
                }
                if dict.keys.contains("MetricType") && dict["MetricType"] != nil {
                    self.metricType = dict["MetricType"] as! String
                }
                if dict.keys.contains("Statistics") && dict["Statistics"] != nil {
                    self.statistics = dict["Statistics"] as! String
                }
                if dict.keys.contains("Threshold") && dict["Threshold"] != nil {
                    self.threshold = dict["Threshold"] as! Double
                }
            }
        }
        public class StepAdjustments : Tea.TeaModel {
            public var metricIntervalLowerBound: Double?

            public var metricIntervalUpperBound: Double?

            public var scalingAdjustment: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.metricIntervalLowerBound != nil {
                    map["MetricIntervalLowerBound"] = self.metricIntervalLowerBound!
                }
                if self.metricIntervalUpperBound != nil {
                    map["MetricIntervalUpperBound"] = self.metricIntervalUpperBound!
                }
                if self.scalingAdjustment != nil {
                    map["ScalingAdjustment"] = self.scalingAdjustment!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("MetricIntervalLowerBound") && dict["MetricIntervalLowerBound"] != nil {
                    self.metricIntervalLowerBound = dict["MetricIntervalLowerBound"] as! Double
                }
                if dict.keys.contains("MetricIntervalUpperBound") && dict["MetricIntervalUpperBound"] != nil {
                    self.metricIntervalUpperBound = dict["MetricIntervalUpperBound"] as! Double
                }
                if dict.keys.contains("ScalingAdjustment") && dict["ScalingAdjustment"] != nil {
                    self.scalingAdjustment = dict["ScalingAdjustment"] as! Int32
                }
            }
        }
        public var adjustmentType: String?

        public var adjustmentValue: Int32?

        public var alarmDimensions: [DescribeScalingRulesResponseBody.ScalingRules.AlarmDimensions]?

        public var alarms: [DescribeScalingRulesResponseBody.ScalingRules.Alarms]?

        public var cooldown: Int32?

        public var disableScaleIn: Bool?

        public var estimatedInstanceWarmup: Int32?

        public var initialMaxSize: Int32?

        public var maxSize: Int32?

        public var metricName: String?

        public var minAdjustmentMagnitude: Int32?

        public var minSize: Int32?

        public var predictiveScalingMode: String?

        public var predictiveTaskBufferTime: Int32?

        public var predictiveValueBehavior: String?

        public var predictiveValueBuffer: Int32?

        public var scaleInEvaluationCount: Int32?

        public var scaleOutEvaluationCount: Int32?

        public var scalingGroupId: String?

        public var scalingRuleAri: String?

        public var scalingRuleId: String?

        public var scalingRuleName: String?

        public var scalingRuleType: String?

        public var stepAdjustments: [DescribeScalingRulesResponseBody.ScalingRules.StepAdjustments]?

        public var targetValue: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.adjustmentType != nil {
                map["AdjustmentType"] = self.adjustmentType!
            }
            if self.adjustmentValue != nil {
                map["AdjustmentValue"] = self.adjustmentValue!
            }
            if self.alarmDimensions != nil {
                var tmp : [Any] = []
                for k in self.alarmDimensions! {
                    tmp.append(k.toMap())
                }
                map["AlarmDimensions"] = tmp
            }
            if self.alarms != nil {
                var tmp : [Any] = []
                for k in self.alarms! {
                    tmp.append(k.toMap())
                }
                map["Alarms"] = tmp
            }
            if self.cooldown != nil {
                map["Cooldown"] = self.cooldown!
            }
            if self.disableScaleIn != nil {
                map["DisableScaleIn"] = self.disableScaleIn!
            }
            if self.estimatedInstanceWarmup != nil {
                map["EstimatedInstanceWarmup"] = self.estimatedInstanceWarmup!
            }
            if self.initialMaxSize != nil {
                map["InitialMaxSize"] = self.initialMaxSize!
            }
            if self.maxSize != nil {
                map["MaxSize"] = self.maxSize!
            }
            if self.metricName != nil {
                map["MetricName"] = self.metricName!
            }
            if self.minAdjustmentMagnitude != nil {
                map["MinAdjustmentMagnitude"] = self.minAdjustmentMagnitude!
            }
            if self.minSize != nil {
                map["MinSize"] = self.minSize!
            }
            if self.predictiveScalingMode != nil {
                map["PredictiveScalingMode"] = self.predictiveScalingMode!
            }
            if self.predictiveTaskBufferTime != nil {
                map["PredictiveTaskBufferTime"] = self.predictiveTaskBufferTime!
            }
            if self.predictiveValueBehavior != nil {
                map["PredictiveValueBehavior"] = self.predictiveValueBehavior!
            }
            if self.predictiveValueBuffer != nil {
                map["PredictiveValueBuffer"] = self.predictiveValueBuffer!
            }
            if self.scaleInEvaluationCount != nil {
                map["ScaleInEvaluationCount"] = self.scaleInEvaluationCount!
            }
            if self.scaleOutEvaluationCount != nil {
                map["ScaleOutEvaluationCount"] = self.scaleOutEvaluationCount!
            }
            if self.scalingGroupId != nil {
                map["ScalingGroupId"] = self.scalingGroupId!
            }
            if self.scalingRuleAri != nil {
                map["ScalingRuleAri"] = self.scalingRuleAri!
            }
            if self.scalingRuleId != nil {
                map["ScalingRuleId"] = self.scalingRuleId!
            }
            if self.scalingRuleName != nil {
                map["ScalingRuleName"] = self.scalingRuleName!
            }
            if self.scalingRuleType != nil {
                map["ScalingRuleType"] = self.scalingRuleType!
            }
            if self.stepAdjustments != nil {
                var tmp : [Any] = []
                for k in self.stepAdjustments! {
                    tmp.append(k.toMap())
                }
                map["StepAdjustments"] = tmp
            }
            if self.targetValue != nil {
                map["TargetValue"] = self.targetValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AdjustmentType") && dict["AdjustmentType"] != nil {
                self.adjustmentType = dict["AdjustmentType"] as! String
            }
            if dict.keys.contains("AdjustmentValue") && dict["AdjustmentValue"] != nil {
                self.adjustmentValue = dict["AdjustmentValue"] as! Int32
            }
            if dict.keys.contains("AlarmDimensions") && dict["AlarmDimensions"] != nil {
                var tmp : [DescribeScalingRulesResponseBody.ScalingRules.AlarmDimensions] = []
                for v in dict["AlarmDimensions"] as! [Any] {
                    var model = DescribeScalingRulesResponseBody.ScalingRules.AlarmDimensions()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.alarmDimensions = tmp
            }
            if dict.keys.contains("Alarms") && dict["Alarms"] != nil {
                var tmp : [DescribeScalingRulesResponseBody.ScalingRules.Alarms] = []
                for v in dict["Alarms"] as! [Any] {
                    var model = DescribeScalingRulesResponseBody.ScalingRules.Alarms()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.alarms = tmp
            }
            if dict.keys.contains("Cooldown") && dict["Cooldown"] != nil {
                self.cooldown = dict["Cooldown"] as! Int32
            }
            if dict.keys.contains("DisableScaleIn") && dict["DisableScaleIn"] != nil {
                self.disableScaleIn = dict["DisableScaleIn"] as! Bool
            }
            if dict.keys.contains("EstimatedInstanceWarmup") && dict["EstimatedInstanceWarmup"] != nil {
                self.estimatedInstanceWarmup = dict["EstimatedInstanceWarmup"] as! Int32
            }
            if dict.keys.contains("InitialMaxSize") && dict["InitialMaxSize"] != nil {
                self.initialMaxSize = dict["InitialMaxSize"] as! Int32
            }
            if dict.keys.contains("MaxSize") && dict["MaxSize"] != nil {
                self.maxSize = dict["MaxSize"] as! Int32
            }
            if dict.keys.contains("MetricName") && dict["MetricName"] != nil {
                self.metricName = dict["MetricName"] as! String
            }
            if dict.keys.contains("MinAdjustmentMagnitude") && dict["MinAdjustmentMagnitude"] != nil {
                self.minAdjustmentMagnitude = dict["MinAdjustmentMagnitude"] as! Int32
            }
            if dict.keys.contains("MinSize") && dict["MinSize"] != nil {
                self.minSize = dict["MinSize"] as! Int32
            }
            if dict.keys.contains("PredictiveScalingMode") && dict["PredictiveScalingMode"] != nil {
                self.predictiveScalingMode = dict["PredictiveScalingMode"] as! String
            }
            if dict.keys.contains("PredictiveTaskBufferTime") && dict["PredictiveTaskBufferTime"] != nil {
                self.predictiveTaskBufferTime = dict["PredictiveTaskBufferTime"] as! Int32
            }
            if dict.keys.contains("PredictiveValueBehavior") && dict["PredictiveValueBehavior"] != nil {
                self.predictiveValueBehavior = dict["PredictiveValueBehavior"] as! String
            }
            if dict.keys.contains("PredictiveValueBuffer") && dict["PredictiveValueBuffer"] != nil {
                self.predictiveValueBuffer = dict["PredictiveValueBuffer"] as! Int32
            }
            if dict.keys.contains("ScaleInEvaluationCount") && dict["ScaleInEvaluationCount"] != nil {
                self.scaleInEvaluationCount = dict["ScaleInEvaluationCount"] as! Int32
            }
            if dict.keys.contains("ScaleOutEvaluationCount") && dict["ScaleOutEvaluationCount"] != nil {
                self.scaleOutEvaluationCount = dict["ScaleOutEvaluationCount"] as! Int32
            }
            if dict.keys.contains("ScalingGroupId") && dict["ScalingGroupId"] != nil {
                self.scalingGroupId = dict["ScalingGroupId"] as! String
            }
            if dict.keys.contains("ScalingRuleAri") && dict["ScalingRuleAri"] != nil {
                self.scalingRuleAri = dict["ScalingRuleAri"] as! String
            }
            if dict.keys.contains("ScalingRuleId") && dict["ScalingRuleId"] != nil {
                self.scalingRuleId = dict["ScalingRuleId"] as! String
            }
            if dict.keys.contains("ScalingRuleName") && dict["ScalingRuleName"] != nil {
                self.scalingRuleName = dict["ScalingRuleName"] as! String
            }
            if dict.keys.contains("ScalingRuleType") && dict["ScalingRuleType"] != nil {
                self.scalingRuleType = dict["ScalingRuleType"] as! String
            }
            if dict.keys.contains("StepAdjustments") && dict["StepAdjustments"] != nil {
                var tmp : [DescribeScalingRulesResponseBody.ScalingRules.StepAdjustments] = []
                for v in dict["StepAdjustments"] as! [Any] {
                    var model = DescribeScalingRulesResponseBody.ScalingRules.StepAdjustments()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.stepAdjustments = tmp
            }
            if dict.keys.contains("TargetValue") && dict["TargetValue"] != nil {
                self.targetValue = dict["TargetValue"] as! Double
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var scalingRules: [DescribeScalingRulesResponseBody.ScalingRules]?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingRules != nil {
            var tmp : [Any] = []
            for k in self.scalingRules! {
                tmp.append(k.toMap())
            }
            map["ScalingRules"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScalingRules") && dict["ScalingRules"] != nil {
            var tmp : [DescribeScalingRulesResponseBody.ScalingRules] = []
            for v in dict["ScalingRules"] as! [Any] {
                var model = DescribeScalingRulesResponseBody.ScalingRules()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.scalingRules = tmp
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeScalingRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeScalingRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeScalingRulesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeScheduledTasksRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var scalingGroupId: String?

    public var scheduledActions: [String]?

    public var scheduledTaskIds: [String]?

    public var scheduledTaskNames: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        if self.scheduledActions != nil {
            map["ScheduledActions"] = self.scheduledActions!
        }
        if self.scheduledTaskIds != nil {
            map["ScheduledTaskIds"] = self.scheduledTaskIds!
        }
        if self.scheduledTaskNames != nil {
            map["ScheduledTaskNames"] = self.scheduledTaskNames!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") && dict["OwnerAccount"] != nil {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ScalingGroupId") && dict["ScalingGroupId"] != nil {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
        if dict.keys.contains("ScheduledActions") && dict["ScheduledActions"] != nil {
            self.scheduledActions = dict["ScheduledActions"] as! [String]
        }
        if dict.keys.contains("ScheduledTaskIds") && dict["ScheduledTaskIds"] != nil {
            self.scheduledTaskIds = dict["ScheduledTaskIds"] as! [String]
        }
        if dict.keys.contains("ScheduledTaskNames") && dict["ScheduledTaskNames"] != nil {
            self.scheduledTaskNames = dict["ScheduledTaskNames"] as! [String]
        }
    }
}

public class DescribeScheduledTasksResponseBody : Tea.TeaModel {
    public class ScheduledTasks : Tea.TeaModel {
        public var description_: String?

        public var desiredCapacity: Int32?

        public var launchExpirationTime: Int32?

        public var launchTime: String?

        public var maxValue: Int32?

        public var minValue: Int32?

        public var recurrenceEndTime: String?

        public var recurrenceType: String?

        public var recurrenceValue: String?

        public var scalingGroupId: String?

        public var scheduledAction: String?

        public var scheduledTaskId: String?

        public var scheduledTaskName: String?

        public var taskEnabled: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.desiredCapacity != nil {
                map["DesiredCapacity"] = self.desiredCapacity!
            }
            if self.launchExpirationTime != nil {
                map["LaunchExpirationTime"] = self.launchExpirationTime!
            }
            if self.launchTime != nil {
                map["LaunchTime"] = self.launchTime!
            }
            if self.maxValue != nil {
                map["MaxValue"] = self.maxValue!
            }
            if self.minValue != nil {
                map["MinValue"] = self.minValue!
            }
            if self.recurrenceEndTime != nil {
                map["RecurrenceEndTime"] = self.recurrenceEndTime!
            }
            if self.recurrenceType != nil {
                map["RecurrenceType"] = self.recurrenceType!
            }
            if self.recurrenceValue != nil {
                map["RecurrenceValue"] = self.recurrenceValue!
            }
            if self.scalingGroupId != nil {
                map["ScalingGroupId"] = self.scalingGroupId!
            }
            if self.scheduledAction != nil {
                map["ScheduledAction"] = self.scheduledAction!
            }
            if self.scheduledTaskId != nil {
                map["ScheduledTaskId"] = self.scheduledTaskId!
            }
            if self.scheduledTaskName != nil {
                map["ScheduledTaskName"] = self.scheduledTaskName!
            }
            if self.taskEnabled != nil {
                map["TaskEnabled"] = self.taskEnabled!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("DesiredCapacity") && dict["DesiredCapacity"] != nil {
                self.desiredCapacity = dict["DesiredCapacity"] as! Int32
            }
            if dict.keys.contains("LaunchExpirationTime") && dict["LaunchExpirationTime"] != nil {
                self.launchExpirationTime = dict["LaunchExpirationTime"] as! Int32
            }
            if dict.keys.contains("LaunchTime") && dict["LaunchTime"] != nil {
                self.launchTime = dict["LaunchTime"] as! String
            }
            if dict.keys.contains("MaxValue") && dict["MaxValue"] != nil {
                self.maxValue = dict["MaxValue"] as! Int32
            }
            if dict.keys.contains("MinValue") && dict["MinValue"] != nil {
                self.minValue = dict["MinValue"] as! Int32
            }
            if dict.keys.contains("RecurrenceEndTime") && dict["RecurrenceEndTime"] != nil {
                self.recurrenceEndTime = dict["RecurrenceEndTime"] as! String
            }
            if dict.keys.contains("RecurrenceType") && dict["RecurrenceType"] != nil {
                self.recurrenceType = dict["RecurrenceType"] as! String
            }
            if dict.keys.contains("RecurrenceValue") && dict["RecurrenceValue"] != nil {
                self.recurrenceValue = dict["RecurrenceValue"] as! String
            }
            if dict.keys.contains("ScalingGroupId") && dict["ScalingGroupId"] != nil {
                self.scalingGroupId = dict["ScalingGroupId"] as! String
            }
            if dict.keys.contains("ScheduledAction") && dict["ScheduledAction"] != nil {
                self.scheduledAction = dict["ScheduledAction"] as! String
            }
            if dict.keys.contains("ScheduledTaskId") && dict["ScheduledTaskId"] != nil {
                self.scheduledTaskId = dict["ScheduledTaskId"] as! String
            }
            if dict.keys.contains("ScheduledTaskName") && dict["ScheduledTaskName"] != nil {
                self.scheduledTaskName = dict["ScheduledTaskName"] as! String
            }
            if dict.keys.contains("TaskEnabled") && dict["TaskEnabled"] != nil {
                self.taskEnabled = dict["TaskEnabled"] as! Bool
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var scheduledTasks: [DescribeScheduledTasksResponseBody.ScheduledTasks]?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scheduledTasks != nil {
            var tmp : [Any] = []
            for k in self.scheduledTasks! {
                tmp.append(k.toMap())
            }
            map["ScheduledTasks"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScheduledTasks") && dict["ScheduledTasks"] != nil {
            var tmp : [DescribeScheduledTasksResponseBody.ScheduledTasks] = []
            for v in dict["ScheduledTasks"] as! [Any] {
                var model = DescribeScheduledTasksResponseBody.ScheduledTasks()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.scheduledTasks = tmp
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeScheduledTasksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeScheduledTasksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeScheduledTasksResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DetachAlbServerGroupsRequest : Tea.TeaModel {
    public class AlbServerGroups : Tea.TeaModel {
        public var albServerGroupId: String?

        public var port: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.albServerGroupId != nil {
                map["AlbServerGroupId"] = self.albServerGroupId!
            }
            if self.port != nil {
                map["Port"] = self.port!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AlbServerGroupId") && dict["AlbServerGroupId"] != nil {
                self.albServerGroupId = dict["AlbServerGroupId"] as! String
            }
            if dict.keys.contains("Port") && dict["Port"] != nil {
                self.port = dict["Port"] as! Int32
            }
        }
    }
    public var albServerGroups: [DetachAlbServerGroupsRequest.AlbServerGroups]?

    public var clientToken: String?

    public var forceDetach: Bool?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.albServerGroups != nil {
            var tmp : [Any] = []
            for k in self.albServerGroups! {
                tmp.append(k.toMap())
            }
            map["AlbServerGroups"] = tmp
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.forceDetach != nil {
            map["ForceDetach"] = self.forceDetach!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlbServerGroups") && dict["AlbServerGroups"] != nil {
            var tmp : [DetachAlbServerGroupsRequest.AlbServerGroups] = []
            for v in dict["AlbServerGroups"] as! [Any] {
                var model = DetachAlbServerGroupsRequest.AlbServerGroups()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.albServerGroups = tmp
        }
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("ForceDetach") && dict["ForceDetach"] != nil {
            self.forceDetach = dict["ForceDetach"] as! Bool
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScalingGroupId") && dict["ScalingGroupId"] != nil {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
    }
}

public class DetachAlbServerGroupsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var scalingActivityId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingActivityId != nil {
            map["ScalingActivityId"] = self.scalingActivityId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScalingActivityId") && dict["ScalingActivityId"] != nil {
            self.scalingActivityId = dict["ScalingActivityId"] as! String
        }
    }
}

public class DetachAlbServerGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DetachAlbServerGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DetachAlbServerGroupsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DetachDBInstancesRequest : Tea.TeaModel {
    public var clientToken: String?

    public var DBInstances: [String]?

    public var forceDetach: Bool?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.DBInstances != nil {
            map["DBInstances"] = self.DBInstances!
        }
        if self.forceDetach != nil {
            map["ForceDetach"] = self.forceDetach!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DBInstances") && dict["DBInstances"] != nil {
            self.DBInstances = dict["DBInstances"] as! [String]
        }
        if dict.keys.contains("ForceDetach") && dict["ForceDetach"] != nil {
            self.forceDetach = dict["ForceDetach"] as! Bool
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScalingGroupId") && dict["ScalingGroupId"] != nil {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
    }
}

public class DetachDBInstancesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DetachDBInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DetachDBInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DetachDBInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DetachInstancesRequest : Tea.TeaModel {
    public var clientToken: String?

    public var decreaseDesiredCapacity: Bool?

    public var detachOption: String?

    public var instanceIds: [String]?

    public var lifecycleHook: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.decreaseDesiredCapacity != nil {
            map["DecreaseDesiredCapacity"] = self.decreaseDesiredCapacity!
        }
        if self.detachOption != nil {
            map["DetachOption"] = self.detachOption!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.lifecycleHook != nil {
            map["LifecycleHook"] = self.lifecycleHook!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DecreaseDesiredCapacity") && dict["DecreaseDesiredCapacity"] != nil {
            self.decreaseDesiredCapacity = dict["DecreaseDesiredCapacity"] as! Bool
        }
        if dict.keys.contains("DetachOption") && dict["DetachOption"] != nil {
            self.detachOption = dict["DetachOption"] as! String
        }
        if dict.keys.contains("InstanceIds") && dict["InstanceIds"] != nil {
            self.instanceIds = dict["InstanceIds"] as! [String]
        }
        if dict.keys.contains("LifecycleHook") && dict["LifecycleHook"] != nil {
            self.lifecycleHook = dict["LifecycleHook"] as! Bool
        }
        if dict.keys.contains("OwnerAccount") && dict["OwnerAccount"] != nil {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ScalingGroupId") && dict["ScalingGroupId"] != nil {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
    }
}

public class DetachInstancesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var scalingActivityId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingActivityId != nil {
            map["ScalingActivityId"] = self.scalingActivityId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScalingActivityId") && dict["ScalingActivityId"] != nil {
            self.scalingActivityId = dict["ScalingActivityId"] as! String
        }
    }
}

public class DetachInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DetachInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DetachInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DetachLoadBalancersRequest : Tea.TeaModel {
    public var async: Bool?

    public var clientToken: String?

    public var forceDetach: Bool?

    public var loadBalancers: [String]?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.async != nil {
            map["Async"] = self.async!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.forceDetach != nil {
            map["ForceDetach"] = self.forceDetach!
        }
        if self.loadBalancers != nil {
            map["LoadBalancers"] = self.loadBalancers!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Async") && dict["Async"] != nil {
            self.async = dict["Async"] as! Bool
        }
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("ForceDetach") && dict["ForceDetach"] != nil {
            self.forceDetach = dict["ForceDetach"] as! Bool
        }
        if dict.keys.contains("LoadBalancers") && dict["LoadBalancers"] != nil {
            self.loadBalancers = dict["LoadBalancers"] as! [String]
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScalingGroupId") && dict["ScalingGroupId"] != nil {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
    }
}

public class DetachLoadBalancersResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var scalingActivityId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingActivityId != nil {
            map["ScalingActivityId"] = self.scalingActivityId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScalingActivityId") && dict["ScalingActivityId"] != nil {
            self.scalingActivityId = dict["ScalingActivityId"] as! String
        }
    }
}

public class DetachLoadBalancersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DetachLoadBalancersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DetachLoadBalancersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DetachServerGroupsRequest : Tea.TeaModel {
    public class ServerGroups : Tea.TeaModel {
        public var port: Int32?

        public var serverGroupId: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.port != nil {
                map["Port"] = self.port!
            }
            if self.serverGroupId != nil {
                map["ServerGroupId"] = self.serverGroupId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Port") && dict["Port"] != nil {
                self.port = dict["Port"] as! Int32
            }
            if dict.keys.contains("ServerGroupId") && dict["ServerGroupId"] != nil {
                self.serverGroupId = dict["ServerGroupId"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var clientToken: String?

    public var forceDetach: Bool?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public var serverGroups: [DetachServerGroupsRequest.ServerGroups]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.forceDetach != nil {
            map["ForceDetach"] = self.forceDetach!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        if self.serverGroups != nil {
            var tmp : [Any] = []
            for k in self.serverGroups! {
                tmp.append(k.toMap())
            }
            map["ServerGroups"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("ForceDetach") && dict["ForceDetach"] != nil {
            self.forceDetach = dict["ForceDetach"] as! Bool
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScalingGroupId") && dict["ScalingGroupId"] != nil {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
        if dict.keys.contains("ServerGroups") && dict["ServerGroups"] != nil {
            var tmp : [DetachServerGroupsRequest.ServerGroups] = []
            for v in dict["ServerGroups"] as! [Any] {
                var model = DetachServerGroupsRequest.ServerGroups()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.serverGroups = tmp
        }
    }
}

public class DetachServerGroupsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var scalingActivityId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingActivityId != nil {
            map["ScalingActivityId"] = self.scalingActivityId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScalingActivityId") && dict["ScalingActivityId"] != nil {
            self.scalingActivityId = dict["ScalingActivityId"] as! String
        }
    }
}

public class DetachServerGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DetachServerGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DetachServerGroupsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DetachVServerGroupsRequest : Tea.TeaModel {
    public class VServerGroups : Tea.TeaModel {
        public class VServerGroupAttributes : Tea.TeaModel {
            public var port: Int32?

            public var VServerGroupId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.VServerGroupId != nil {
                    map["VServerGroupId"] = self.VServerGroupId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Port") && dict["Port"] != nil {
                    self.port = dict["Port"] as! Int32
                }
                if dict.keys.contains("VServerGroupId") && dict["VServerGroupId"] != nil {
                    self.VServerGroupId = dict["VServerGroupId"] as! String
                }
            }
        }
        public var loadBalancerId: String?

        public var VServerGroupAttributes: [DetachVServerGroupsRequest.VServerGroups.VServerGroupAttributes]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.loadBalancerId != nil {
                map["LoadBalancerId"] = self.loadBalancerId!
            }
            if self.VServerGroupAttributes != nil {
                var tmp : [Any] = []
                for k in self.VServerGroupAttributes! {
                    tmp.append(k.toMap())
                }
                map["VServerGroupAttributes"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LoadBalancerId") && dict["LoadBalancerId"] != nil {
                self.loadBalancerId = dict["LoadBalancerId"] as! String
            }
            if dict.keys.contains("VServerGroupAttributes") && dict["VServerGroupAttributes"] != nil {
                var tmp : [DetachVServerGroupsRequest.VServerGroups.VServerGroupAttributes] = []
                for v in dict["VServerGroupAttributes"] as! [Any] {
                    var model = DetachVServerGroupsRequest.VServerGroups.VServerGroupAttributes()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.VServerGroupAttributes = tmp
            }
        }
    }
    public var clientToken: String?

    public var forceDetach: Bool?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public var VServerGroups: [DetachVServerGroupsRequest.VServerGroups]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.forceDetach != nil {
            map["ForceDetach"] = self.forceDetach!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        if self.VServerGroups != nil {
            var tmp : [Any] = []
            for k in self.VServerGroups! {
                tmp.append(k.toMap())
            }
            map["VServerGroups"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("ForceDetach") && dict["ForceDetach"] != nil {
            self.forceDetach = dict["ForceDetach"] as! Bool
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScalingGroupId") && dict["ScalingGroupId"] != nil {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
        if dict.keys.contains("VServerGroups") && dict["VServerGroups"] != nil {
            var tmp : [DetachVServerGroupsRequest.VServerGroups] = []
            for v in dict["VServerGroups"] as! [Any] {
                var model = DetachVServerGroupsRequest.VServerGroups()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.VServerGroups = tmp
        }
    }
}

public class DetachVServerGroupsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DetachVServerGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DetachVServerGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DetachVServerGroupsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DisableAlarmRequest : Tea.TeaModel {
    public var alarmTaskId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alarmTaskId != nil {
            map["AlarmTaskId"] = self.alarmTaskId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlarmTaskId") && dict["AlarmTaskId"] != nil {
            self.alarmTaskId = dict["AlarmTaskId"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
    }
}

public class DisableAlarmResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DisableAlarmResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DisableAlarmResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DisableAlarmResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DisableScalingGroupRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") && dict["OwnerAccount"] != nil {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ScalingGroupId") && dict["ScalingGroupId"] != nil {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
    }
}

public class DisableScalingGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DisableScalingGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DisableScalingGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DisableScalingGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class EnableAlarmRequest : Tea.TeaModel {
    public var alarmTaskId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alarmTaskId != nil {
            map["AlarmTaskId"] = self.alarmTaskId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlarmTaskId") && dict["AlarmTaskId"] != nil {
            self.alarmTaskId = dict["AlarmTaskId"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
    }
}

public class EnableAlarmResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class EnableAlarmResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EnableAlarmResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = EnableAlarmResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class EnableScalingGroupRequest : Tea.TeaModel {
    public class LaunchTemplateOverrides : Tea.TeaModel {
        public var instanceType: String?

        public var weightedCapacity: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.weightedCapacity != nil {
                map["WeightedCapacity"] = self.weightedCapacity!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceType") && dict["InstanceType"] != nil {
                self.instanceType = dict["InstanceType"] as! String
            }
            if dict.keys.contains("WeightedCapacity") && dict["WeightedCapacity"] != nil {
                self.weightedCapacity = dict["WeightedCapacity"] as! Int32
            }
        }
    }
    public var activeScalingConfigurationId: String?

    public var instanceIds: [String]?

    public var launchTemplateId: String?

    public var launchTemplateOverrides: [EnableScalingGroupRequest.LaunchTemplateOverrides]?

    public var launchTemplateVersion: String?

    public var loadBalancerWeights: [Int32]?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.activeScalingConfigurationId != nil {
            map["ActiveScalingConfigurationId"] = self.activeScalingConfigurationId!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.launchTemplateId != nil {
            map["LaunchTemplateId"] = self.launchTemplateId!
        }
        if self.launchTemplateOverrides != nil {
            var tmp : [Any] = []
            for k in self.launchTemplateOverrides! {
                tmp.append(k.toMap())
            }
            map["LaunchTemplateOverrides"] = tmp
        }
        if self.launchTemplateVersion != nil {
            map["LaunchTemplateVersion"] = self.launchTemplateVersion!
        }
        if self.loadBalancerWeights != nil {
            map["LoadBalancerWeights"] = self.loadBalancerWeights!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ActiveScalingConfigurationId") && dict["ActiveScalingConfigurationId"] != nil {
            self.activeScalingConfigurationId = dict["ActiveScalingConfigurationId"] as! String
        }
        if dict.keys.contains("InstanceIds") && dict["InstanceIds"] != nil {
            self.instanceIds = dict["InstanceIds"] as! [String]
        }
        if dict.keys.contains("LaunchTemplateId") && dict["LaunchTemplateId"] != nil {
            self.launchTemplateId = dict["LaunchTemplateId"] as! String
        }
        if dict.keys.contains("LaunchTemplateOverrides") && dict["LaunchTemplateOverrides"] != nil {
            var tmp : [EnableScalingGroupRequest.LaunchTemplateOverrides] = []
            for v in dict["LaunchTemplateOverrides"] as! [Any] {
                var model = EnableScalingGroupRequest.LaunchTemplateOverrides()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.launchTemplateOverrides = tmp
        }
        if dict.keys.contains("LaunchTemplateVersion") && dict["LaunchTemplateVersion"] != nil {
            self.launchTemplateVersion = dict["LaunchTemplateVersion"] as! String
        }
        if dict.keys.contains("LoadBalancerWeights") && dict["LoadBalancerWeights"] != nil {
            self.loadBalancerWeights = dict["LoadBalancerWeights"] as! [Int32]
        }
        if dict.keys.contains("OwnerAccount") && dict["OwnerAccount"] != nil {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ScalingGroupId") && dict["ScalingGroupId"] != nil {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
    }
}

public class EnableScalingGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class EnableScalingGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EnableScalingGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = EnableScalingGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class EnterStandbyRequest : Tea.TeaModel {
    public var async: Bool?

    public var clientToken: String?

    public var instanceIds: [String]?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.async != nil {
            map["Async"] = self.async!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Async") && dict["Async"] != nil {
            self.async = dict["Async"] as! Bool
        }
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("InstanceIds") && dict["InstanceIds"] != nil {
            self.instanceIds = dict["InstanceIds"] as! [String]
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScalingGroupId") && dict["ScalingGroupId"] != nil {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
    }
}

public class EnterStandbyResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var scalingActivityId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingActivityId != nil {
            map["ScalingActivityId"] = self.scalingActivityId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScalingActivityId") && dict["ScalingActivityId"] != nil {
            self.scalingActivityId = dict["ScalingActivityId"] as! String
        }
    }
}

public class EnterStandbyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EnterStandbyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = EnterStandbyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ExecuteScalingRuleRequest : Tea.TeaModel {
    public var breachThreshold: Double?

    public var clientToken: String?

    public var metricValue: Double?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var scalingRuleAri: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.breachThreshold != nil {
            map["BreachThreshold"] = self.breachThreshold!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.metricValue != nil {
            map["MetricValue"] = self.metricValue!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.scalingRuleAri != nil {
            map["ScalingRuleAri"] = self.scalingRuleAri!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BreachThreshold") && dict["BreachThreshold"] != nil {
            self.breachThreshold = dict["BreachThreshold"] as! Double
        }
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("MetricValue") && dict["MetricValue"] != nil {
            self.metricValue = dict["MetricValue"] as! Double
        }
        if dict.keys.contains("OwnerAccount") && dict["OwnerAccount"] != nil {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ScalingRuleAri") && dict["ScalingRuleAri"] != nil {
            self.scalingRuleAri = dict["ScalingRuleAri"] as! String
        }
    }
}

public class ExecuteScalingRuleResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var scalingActivityId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingActivityId != nil {
            map["ScalingActivityId"] = self.scalingActivityId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScalingActivityId") && dict["ScalingActivityId"] != nil {
            self.scalingActivityId = dict["ScalingActivityId"] as! String
        }
    }
}

public class ExecuteScalingRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ExecuteScalingRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ExecuteScalingRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ExitStandbyRequest : Tea.TeaModel {
    public var async: Bool?

    public var clientToken: String?

    public var instanceIds: [String]?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.async != nil {
            map["Async"] = self.async!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Async") && dict["Async"] != nil {
            self.async = dict["Async"] as! Bool
        }
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("InstanceIds") && dict["InstanceIds"] != nil {
            self.instanceIds = dict["InstanceIds"] as! [String]
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScalingGroupId") && dict["ScalingGroupId"] != nil {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
    }
}

public class ExitStandbyResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var scalingActivityId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingActivityId != nil {
            map["ScalingActivityId"] = self.scalingActivityId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScalingActivityId") && dict["ScalingActivityId"] != nil {
            self.scalingActivityId = dict["ScalingActivityId"] as! String
        }
    }
}

public class ExitStandbyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ExitStandbyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ExitStandbyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListTagKeysRequest : Tea.TeaModel {
    public var nextToken: String?

    public var ownerId: Int64?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NextToken") && dict["NextToken"] != nil {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceType") && dict["ResourceType"] != nil {
            self.resourceType = dict["ResourceType"] as! String
        }
    }
}

public class ListTagKeysResponseBody : Tea.TeaModel {
    public var keys: [String]?

    public var nextToken: String?

    public var pageSize: Int32?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.keys != nil {
            map["Keys"] = self.keys!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Keys") && dict["Keys"] != nil {
            self.keys = dict["Keys"] as! [String]
        }
        if dict.keys.contains("NextToken") && dict["NextToken"] != nil {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListTagKeysResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTagKeysResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListTagKeysResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListTagResourcesRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var nextToken: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceIds: [String]?

    public var resourceOwnerAccount: String?

    public var resourceType: String?

    public var tags: [ListTagResourcesRequest.Tags]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceIds != nil {
            map["ResourceIds"] = self.resourceIds!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NextToken") && dict["NextToken"] != nil {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceIds") && dict["ResourceIds"] != nil {
            self.resourceIds = dict["ResourceIds"] as! [String]
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceType") && dict["ResourceType"] != nil {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("Tags") && dict["Tags"] != nil {
            var tmp : [ListTagResourcesRequest.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = ListTagResourcesRequest.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
    }
}

public class ListTagResourcesResponseBody : Tea.TeaModel {
    public class TagResources : Tea.TeaModel {
        public var propagate: Bool?

        public var resourceId: String?

        public var resourceType: String?

        public var tagKey: String?

        public var tagValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.propagate != nil {
                map["Propagate"] = self.propagate!
            }
            if self.resourceId != nil {
                map["ResourceId"] = self.resourceId!
            }
            if self.resourceType != nil {
                map["ResourceType"] = self.resourceType!
            }
            if self.tagKey != nil {
                map["TagKey"] = self.tagKey!
            }
            if self.tagValue != nil {
                map["TagValue"] = self.tagValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Propagate") && dict["Propagate"] != nil {
                self.propagate = dict["Propagate"] as! Bool
            }
            if dict.keys.contains("ResourceId") && dict["ResourceId"] != nil {
                self.resourceId = dict["ResourceId"] as! String
            }
            if dict.keys.contains("ResourceType") && dict["ResourceType"] != nil {
                self.resourceType = dict["ResourceType"] as! String
            }
            if dict.keys.contains("TagKey") && dict["TagKey"] != nil {
                self.tagKey = dict["TagKey"] as! String
            }
            if dict.keys.contains("TagValue") && dict["TagValue"] != nil {
                self.tagValue = dict["TagValue"] as! String
            }
        }
    }
    public var nextToken: String?

    public var requestId: String?

    public var tagResources: [ListTagResourcesResponseBody.TagResources]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.tagResources != nil {
            var tmp : [Any] = []
            for k in self.tagResources! {
                tmp.append(k.toMap())
            }
            map["TagResources"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NextToken") && dict["NextToken"] != nil {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TagResources") && dict["TagResources"] != nil {
            var tmp : [ListTagResourcesResponseBody.TagResources] = []
            for v in dict["TagResources"] as! [Any] {
                var model = ListTagResourcesResponseBody.TagResources()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tagResources = tmp
        }
    }
}

public class ListTagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListTagResourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListTagValuesRequest : Tea.TeaModel {
    public var key: String?

    public var nextToken: String?

    public var ownerId: Int64?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.key != nil {
            map["Key"] = self.key!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Key") && dict["Key"] != nil {
            self.key = dict["Key"] as! String
        }
        if dict.keys.contains("NextToken") && dict["NextToken"] != nil {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceType") && dict["ResourceType"] != nil {
            self.resourceType = dict["ResourceType"] as! String
        }
    }
}

public class ListTagValuesResponseBody : Tea.TeaModel {
    public var nextToken: String?

    public var pageSize: Int32?

    public var requestId: String?

    public var values: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.values != nil {
            map["Values"] = self.values!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NextToken") && dict["NextToken"] != nil {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Values") && dict["Values"] != nil {
            self.values = dict["Values"] as! [String]
        }
    }
}

public class ListTagValuesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTagValuesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListTagValuesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyAlarmRequest : Tea.TeaModel {
    public class Dimensions : Tea.TeaModel {
        public var dimensionKey: String?

        public var dimensionValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dimensionKey != nil {
                map["DimensionKey"] = self.dimensionKey!
            }
            if self.dimensionValue != nil {
                map["DimensionValue"] = self.dimensionValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DimensionKey") && dict["DimensionKey"] != nil {
                self.dimensionKey = dict["DimensionKey"] as! String
            }
            if dict.keys.contains("DimensionValue") && dict["DimensionValue"] != nil {
                self.dimensionValue = dict["DimensionValue"] as! String
            }
        }
    }
    public class Expressions : Tea.TeaModel {
        public var comparisonOperator: String?

        public var metricName: String?

        public var period: Int32?

        public var statistics: String?

        public var threshold: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.comparisonOperator != nil {
                map["ComparisonOperator"] = self.comparisonOperator!
            }
            if self.metricName != nil {
                map["MetricName"] = self.metricName!
            }
            if self.period != nil {
                map["Period"] = self.period!
            }
            if self.statistics != nil {
                map["Statistics"] = self.statistics!
            }
            if self.threshold != nil {
                map["Threshold"] = self.threshold!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ComparisonOperator") && dict["ComparisonOperator"] != nil {
                self.comparisonOperator = dict["ComparisonOperator"] as! String
            }
            if dict.keys.contains("MetricName") && dict["MetricName"] != nil {
                self.metricName = dict["MetricName"] as! String
            }
            if dict.keys.contains("Period") && dict["Period"] != nil {
                self.period = dict["Period"] as! Int32
            }
            if dict.keys.contains("Statistics") && dict["Statistics"] != nil {
                self.statistics = dict["Statistics"] as! String
            }
            if dict.keys.contains("Threshold") && dict["Threshold"] != nil {
                self.threshold = dict["Threshold"] as! Double
            }
        }
    }
    public var alarmActions: [String]?

    public var alarmTaskId: String?

    public var comparisonOperator: String?

    public var description_: String?

    public var dimensions: [ModifyAlarmRequest.Dimensions]?

    public var effective: String?

    public var evaluationCount: Int32?

    public var expressions: [ModifyAlarmRequest.Expressions]?

    public var expressionsLogicOperator: String?

    public var groupId: Int32?

    public var metricName: String?

    public var metricType: String?

    public var name: String?

    public var ownerId: Int64?

    public var period: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var statistics: String?

    public var threshold: Double?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alarmActions != nil {
            map["AlarmActions"] = self.alarmActions!
        }
        if self.alarmTaskId != nil {
            map["AlarmTaskId"] = self.alarmTaskId!
        }
        if self.comparisonOperator != nil {
            map["ComparisonOperator"] = self.comparisonOperator!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.dimensions != nil {
            var tmp : [Any] = []
            for k in self.dimensions! {
                tmp.append(k.toMap())
            }
            map["Dimensions"] = tmp
        }
        if self.effective != nil {
            map["Effective"] = self.effective!
        }
        if self.evaluationCount != nil {
            map["EvaluationCount"] = self.evaluationCount!
        }
        if self.expressions != nil {
            var tmp : [Any] = []
            for k in self.expressions! {
                tmp.append(k.toMap())
            }
            map["Expressions"] = tmp
        }
        if self.expressionsLogicOperator != nil {
            map["ExpressionsLogicOperator"] = self.expressionsLogicOperator!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.metricName != nil {
            map["MetricName"] = self.metricName!
        }
        if self.metricType != nil {
            map["MetricType"] = self.metricType!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.statistics != nil {
            map["Statistics"] = self.statistics!
        }
        if self.threshold != nil {
            map["Threshold"] = self.threshold!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlarmActions") && dict["AlarmActions"] != nil {
            self.alarmActions = dict["AlarmActions"] as! [String]
        }
        if dict.keys.contains("AlarmTaskId") && dict["AlarmTaskId"] != nil {
            self.alarmTaskId = dict["AlarmTaskId"] as! String
        }
        if dict.keys.contains("ComparisonOperator") && dict["ComparisonOperator"] != nil {
            self.comparisonOperator = dict["ComparisonOperator"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Dimensions") && dict["Dimensions"] != nil {
            var tmp : [ModifyAlarmRequest.Dimensions] = []
            for v in dict["Dimensions"] as! [Any] {
                var model = ModifyAlarmRequest.Dimensions()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.dimensions = tmp
        }
        if dict.keys.contains("Effective") && dict["Effective"] != nil {
            self.effective = dict["Effective"] as! String
        }
        if dict.keys.contains("EvaluationCount") && dict["EvaluationCount"] != nil {
            self.evaluationCount = dict["EvaluationCount"] as! Int32
        }
        if dict.keys.contains("Expressions") && dict["Expressions"] != nil {
            var tmp : [ModifyAlarmRequest.Expressions] = []
            for v in dict["Expressions"] as! [Any] {
                var model = ModifyAlarmRequest.Expressions()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.expressions = tmp
        }
        if dict.keys.contains("ExpressionsLogicOperator") && dict["ExpressionsLogicOperator"] != nil {
            self.expressionsLogicOperator = dict["ExpressionsLogicOperator"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! Int32
        }
        if dict.keys.contains("MetricName") && dict["MetricName"] != nil {
            self.metricName = dict["MetricName"] as! String
        }
        if dict.keys.contains("MetricType") && dict["MetricType"] != nil {
            self.metricType = dict["MetricType"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Period") && dict["Period"] != nil {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("Statistics") && dict["Statistics"] != nil {
            self.statistics = dict["Statistics"] as! String
        }
        if dict.keys.contains("Threshold") && dict["Threshold"] != nil {
            self.threshold = dict["Threshold"] as! Double
        }
    }
}

public class ModifyAlarmResponseBody : Tea.TeaModel {
    public var alarmTaskId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alarmTaskId != nil {
            map["AlarmTaskId"] = self.alarmTaskId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlarmTaskId") && dict["AlarmTaskId"] != nil {
            self.alarmTaskId = dict["AlarmTaskId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyAlarmResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyAlarmResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyAlarmResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyEciScalingConfigurationRequest : Tea.TeaModel {
    public class AcrRegistryInfos : Tea.TeaModel {
        public var domains: [String]?

        public var instanceId: String?

        public var instanceName: String?

        public var regionId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.domains != nil {
                map["Domains"] = self.domains!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Domains") && dict["Domains"] != nil {
                self.domains = dict["Domains"] as! [String]
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
                self.instanceName = dict["InstanceName"] as! String
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
        }
    }
    public class Containers : Tea.TeaModel {
        public class LivenessProbe : Tea.TeaModel {
            public class Exec : Tea.TeaModel {
                public var commands: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.commands != nil {
                        map["Commands"] = self.commands!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Commands") && dict["Commands"] != nil {
                        self.commands = dict["Commands"] as! [String]
                    }
                }
            }
            public class HttpGet : Tea.TeaModel {
                public var path: String?

                public var port: Int32?

                public var scheme: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.path != nil {
                        map["Path"] = self.path!
                    }
                    if self.port != nil {
                        map["Port"] = self.port!
                    }
                    if self.scheme != nil {
                        map["Scheme"] = self.scheme!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Path") && dict["Path"] != nil {
                        self.path = dict["Path"] as! String
                    }
                    if dict.keys.contains("Port") && dict["Port"] != nil {
                        self.port = dict["Port"] as! Int32
                    }
                    if dict.keys.contains("Scheme") && dict["Scheme"] != nil {
                        self.scheme = dict["Scheme"] as! String
                    }
                }
            }
            public class TcpSocket : Tea.TeaModel {
                public var port: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.port != nil {
                        map["Port"] = self.port!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Port") && dict["Port"] != nil {
                        self.port = dict["Port"] as! Int32
                    }
                }
            }
            public var exec: ModifyEciScalingConfigurationRequest.Containers.LivenessProbe.Exec?

            public var failureThreshold: Int32?

            public var httpGet: ModifyEciScalingConfigurationRequest.Containers.LivenessProbe.HttpGet?

            public var initialDelaySeconds: Int32?

            public var periodSeconds: Int32?

            public var successThreshold: Int32?

            public var tcpSocket: ModifyEciScalingConfigurationRequest.Containers.LivenessProbe.TcpSocket?

            public var timeoutSeconds: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.exec?.validate()
                try self.httpGet?.validate()
                try self.tcpSocket?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.exec != nil {
                    map["Exec"] = self.exec?.toMap()
                }
                if self.failureThreshold != nil {
                    map["FailureThreshold"] = self.failureThreshold!
                }
                if self.httpGet != nil {
                    map["HttpGet"] = self.httpGet?.toMap()
                }
                if self.initialDelaySeconds != nil {
                    map["InitialDelaySeconds"] = self.initialDelaySeconds!
                }
                if self.periodSeconds != nil {
                    map["PeriodSeconds"] = self.periodSeconds!
                }
                if self.successThreshold != nil {
                    map["SuccessThreshold"] = self.successThreshold!
                }
                if self.tcpSocket != nil {
                    map["TcpSocket"] = self.tcpSocket?.toMap()
                }
                if self.timeoutSeconds != nil {
                    map["TimeoutSeconds"] = self.timeoutSeconds!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Exec") && dict["Exec"] != nil {
                    var model = ModifyEciScalingConfigurationRequest.Containers.LivenessProbe.Exec()
                    model.fromMap(dict["Exec"] as! [String: Any])
                    self.exec = model
                }
                if dict.keys.contains("FailureThreshold") && dict["FailureThreshold"] != nil {
                    self.failureThreshold = dict["FailureThreshold"] as! Int32
                }
                if dict.keys.contains("HttpGet") && dict["HttpGet"] != nil {
                    var model = ModifyEciScalingConfigurationRequest.Containers.LivenessProbe.HttpGet()
                    model.fromMap(dict["HttpGet"] as! [String: Any])
                    self.httpGet = model
                }
                if dict.keys.contains("InitialDelaySeconds") && dict["InitialDelaySeconds"] != nil {
                    self.initialDelaySeconds = dict["InitialDelaySeconds"] as! Int32
                }
                if dict.keys.contains("PeriodSeconds") && dict["PeriodSeconds"] != nil {
                    self.periodSeconds = dict["PeriodSeconds"] as! Int32
                }
                if dict.keys.contains("SuccessThreshold") && dict["SuccessThreshold"] != nil {
                    self.successThreshold = dict["SuccessThreshold"] as! Int32
                }
                if dict.keys.contains("TcpSocket") && dict["TcpSocket"] != nil {
                    var model = ModifyEciScalingConfigurationRequest.Containers.LivenessProbe.TcpSocket()
                    model.fromMap(dict["TcpSocket"] as! [String: Any])
                    self.tcpSocket = model
                }
                if dict.keys.contains("TimeoutSeconds") && dict["TimeoutSeconds"] != nil {
                    self.timeoutSeconds = dict["TimeoutSeconds"] as! Int32
                }
            }
        }
        public class ReadinessProbe : Tea.TeaModel {
            public class Exec : Tea.TeaModel {
                public var commands: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.commands != nil {
                        map["Commands"] = self.commands!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Commands") && dict["Commands"] != nil {
                        self.commands = dict["Commands"] as! [String]
                    }
                }
            }
            public class HttpGet : Tea.TeaModel {
                public var path: String?

                public var port: Int32?

                public var scheme: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.path != nil {
                        map["Path"] = self.path!
                    }
                    if self.port != nil {
                        map["Port"] = self.port!
                    }
                    if self.scheme != nil {
                        map["Scheme"] = self.scheme!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Path") && dict["Path"] != nil {
                        self.path = dict["Path"] as! String
                    }
                    if dict.keys.contains("Port") && dict["Port"] != nil {
                        self.port = dict["Port"] as! Int32
                    }
                    if dict.keys.contains("Scheme") && dict["Scheme"] != nil {
                        self.scheme = dict["Scheme"] as! String
                    }
                }
            }
            public class TcpSocket : Tea.TeaModel {
                public var port: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.port != nil {
                        map["Port"] = self.port!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Port") && dict["Port"] != nil {
                        self.port = dict["Port"] as! Int32
                    }
                }
            }
            public var exec: ModifyEciScalingConfigurationRequest.Containers.ReadinessProbe.Exec?

            public var failureThreshold: Int32?

            public var httpGet: ModifyEciScalingConfigurationRequest.Containers.ReadinessProbe.HttpGet?

            public var initialDelaySeconds: Int32?

            public var periodSeconds: Int32?

            public var successThreshold: Int32?

            public var tcpSocket: ModifyEciScalingConfigurationRequest.Containers.ReadinessProbe.TcpSocket?

            public var timeoutSeconds: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.exec?.validate()
                try self.httpGet?.validate()
                try self.tcpSocket?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.exec != nil {
                    map["Exec"] = self.exec?.toMap()
                }
                if self.failureThreshold != nil {
                    map["FailureThreshold"] = self.failureThreshold!
                }
                if self.httpGet != nil {
                    map["HttpGet"] = self.httpGet?.toMap()
                }
                if self.initialDelaySeconds != nil {
                    map["InitialDelaySeconds"] = self.initialDelaySeconds!
                }
                if self.periodSeconds != nil {
                    map["PeriodSeconds"] = self.periodSeconds!
                }
                if self.successThreshold != nil {
                    map["SuccessThreshold"] = self.successThreshold!
                }
                if self.tcpSocket != nil {
                    map["TcpSocket"] = self.tcpSocket?.toMap()
                }
                if self.timeoutSeconds != nil {
                    map["TimeoutSeconds"] = self.timeoutSeconds!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Exec") && dict["Exec"] != nil {
                    var model = ModifyEciScalingConfigurationRequest.Containers.ReadinessProbe.Exec()
                    model.fromMap(dict["Exec"] as! [String: Any])
                    self.exec = model
                }
                if dict.keys.contains("FailureThreshold") && dict["FailureThreshold"] != nil {
                    self.failureThreshold = dict["FailureThreshold"] as! Int32
                }
                if dict.keys.contains("HttpGet") && dict["HttpGet"] != nil {
                    var model = ModifyEciScalingConfigurationRequest.Containers.ReadinessProbe.HttpGet()
                    model.fromMap(dict["HttpGet"] as! [String: Any])
                    self.httpGet = model
                }
                if dict.keys.contains("InitialDelaySeconds") && dict["InitialDelaySeconds"] != nil {
                    self.initialDelaySeconds = dict["InitialDelaySeconds"] as! Int32
                }
                if dict.keys.contains("PeriodSeconds") && dict["PeriodSeconds"] != nil {
                    self.periodSeconds = dict["PeriodSeconds"] as! Int32
                }
                if dict.keys.contains("SuccessThreshold") && dict["SuccessThreshold"] != nil {
                    self.successThreshold = dict["SuccessThreshold"] as! Int32
                }
                if dict.keys.contains("TcpSocket") && dict["TcpSocket"] != nil {
                    var model = ModifyEciScalingConfigurationRequest.Containers.ReadinessProbe.TcpSocket()
                    model.fromMap(dict["TcpSocket"] as! [String: Any])
                    self.tcpSocket = model
                }
                if dict.keys.contains("TimeoutSeconds") && dict["TimeoutSeconds"] != nil {
                    self.timeoutSeconds = dict["TimeoutSeconds"] as! Int32
                }
            }
        }
        public class SecurityContext : Tea.TeaModel {
            public class Capability : Tea.TeaModel {
                public var adds: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.adds != nil {
                        map["Adds"] = self.adds!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Adds") && dict["Adds"] != nil {
                        self.adds = dict["Adds"] as! [String]
                    }
                }
            }
            public var capability: ModifyEciScalingConfigurationRequest.Containers.SecurityContext.Capability?

            public var readOnlyRootFilesystem: Bool?

            public var runAsUser: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.capability?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.capability != nil {
                    map["Capability"] = self.capability?.toMap()
                }
                if self.readOnlyRootFilesystem != nil {
                    map["ReadOnlyRootFilesystem"] = self.readOnlyRootFilesystem!
                }
                if self.runAsUser != nil {
                    map["RunAsUser"] = self.runAsUser!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Capability") && dict["Capability"] != nil {
                    var model = ModifyEciScalingConfigurationRequest.Containers.SecurityContext.Capability()
                    model.fromMap(dict["Capability"] as! [String: Any])
                    self.capability = model
                }
                if dict.keys.contains("ReadOnlyRootFilesystem") && dict["ReadOnlyRootFilesystem"] != nil {
                    self.readOnlyRootFilesystem = dict["ReadOnlyRootFilesystem"] as! Bool
                }
                if dict.keys.contains("RunAsUser") && dict["RunAsUser"] != nil {
                    self.runAsUser = dict["RunAsUser"] as! Int64
                }
            }
        }
        public class EnvironmentVars : Tea.TeaModel {
            public class FieldRef : Tea.TeaModel {
                public var fieldPath: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.fieldPath != nil {
                        map["FieldPath"] = self.fieldPath!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("FieldPath") && dict["FieldPath"] != nil {
                        self.fieldPath = dict["FieldPath"] as! String
                    }
                }
            }
            public var fieldRef: ModifyEciScalingConfigurationRequest.Containers.EnvironmentVars.FieldRef?

            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.fieldRef?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fieldRef != nil {
                    map["FieldRef"] = self.fieldRef?.toMap()
                }
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FieldRef") && dict["FieldRef"] != nil {
                    var model = ModifyEciScalingConfigurationRequest.Containers.EnvironmentVars.FieldRef()
                    model.fromMap(dict["FieldRef"] as! [String: Any])
                    self.fieldRef = model
                }
                if dict.keys.contains("Key") && dict["Key"] != nil {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public class Ports : Tea.TeaModel {
            public var port: Int32?

            public var protocol_: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.protocol_ != nil {
                    map["Protocol"] = self.protocol_!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Port") && dict["Port"] != nil {
                    self.port = dict["Port"] as! Int32
                }
                if dict.keys.contains("Protocol") && dict["Protocol"] != nil {
                    self.protocol_ = dict["Protocol"] as! String
                }
            }
        }
        public class VolumeMounts : Tea.TeaModel {
            public var mountPath: String?

            public var mountPropagation: String?

            public var name: String?

            public var readOnly: Bool?

            public var subPath: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.mountPath != nil {
                    map["MountPath"] = self.mountPath!
                }
                if self.mountPropagation != nil {
                    map["MountPropagation"] = self.mountPropagation!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.readOnly != nil {
                    map["ReadOnly"] = self.readOnly!
                }
                if self.subPath != nil {
                    map["SubPath"] = self.subPath!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("MountPath") && dict["MountPath"] != nil {
                    self.mountPath = dict["MountPath"] as! String
                }
                if dict.keys.contains("MountPropagation") && dict["MountPropagation"] != nil {
                    self.mountPropagation = dict["MountPropagation"] as! String
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("ReadOnly") && dict["ReadOnly"] != nil {
                    self.readOnly = dict["ReadOnly"] as! Bool
                }
                if dict.keys.contains("SubPath") && dict["SubPath"] != nil {
                    self.subPath = dict["SubPath"] as! String
                }
            }
        }
        public var livenessProbe: ModifyEciScalingConfigurationRequest.Containers.LivenessProbe?

        public var readinessProbe: ModifyEciScalingConfigurationRequest.Containers.ReadinessProbe?

        public var securityContext: ModifyEciScalingConfigurationRequest.Containers.SecurityContext?

        public var args: [String]?

        public var commands: [String]?

        public var cpu: Double?

        public var environmentVars: [ModifyEciScalingConfigurationRequest.Containers.EnvironmentVars]?

        public var gpu: Int32?

        public var image: String?

        public var imagePullPolicy: String?

        public var lifecyclePostStartHandlerExecs: [String]?

        public var lifecyclePostStartHandlerHttpGetHost: String?

        public var lifecyclePostStartHandlerHttpGetPath: String?

        public var lifecyclePostStartHandlerHttpGetPort: Int32?

        public var lifecyclePostStartHandlerHttpGetScheme: String?

        public var lifecyclePostStartHandlerTcpSocketHost: String?

        public var lifecyclePostStartHandlerTcpSocketPort: Int32?

        public var lifecyclePreStopHandlerExecs: [String]?

        public var lifecyclePreStopHandlerHttpGetHost: String?

        public var lifecyclePreStopHandlerHttpGetPath: String?

        public var lifecyclePreStopHandlerHttpGetPort: Int32?

        public var lifecyclePreStopHandlerHttpGetScheme: String?

        public var lifecyclePreStopHandlerTcpSocketHost: String?

        public var lifecyclePreStopHandlerTcpSocketPort: Int32?

        public var memory: Double?

        public var name: String?

        public var ports: [ModifyEciScalingConfigurationRequest.Containers.Ports]?

        public var stdin: Bool?

        public var stdinOnce: Bool?

        public var tty: Bool?

        public var volumeMounts: [ModifyEciScalingConfigurationRequest.Containers.VolumeMounts]?

        public var workingDir: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.livenessProbe?.validate()
            try self.readinessProbe?.validate()
            try self.securityContext?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.livenessProbe != nil {
                map["LivenessProbe"] = self.livenessProbe?.toMap()
            }
            if self.readinessProbe != nil {
                map["ReadinessProbe"] = self.readinessProbe?.toMap()
            }
            if self.securityContext != nil {
                map["SecurityContext"] = self.securityContext?.toMap()
            }
            if self.args != nil {
                map["Args"] = self.args!
            }
            if self.commands != nil {
                map["Commands"] = self.commands!
            }
            if self.cpu != nil {
                map["Cpu"] = self.cpu!
            }
            if self.environmentVars != nil {
                var tmp : [Any] = []
                for k in self.environmentVars! {
                    tmp.append(k.toMap())
                }
                map["EnvironmentVars"] = tmp
            }
            if self.gpu != nil {
                map["Gpu"] = self.gpu!
            }
            if self.image != nil {
                map["Image"] = self.image!
            }
            if self.imagePullPolicy != nil {
                map["ImagePullPolicy"] = self.imagePullPolicy!
            }
            if self.lifecyclePostStartHandlerExecs != nil {
                map["LifecyclePostStartHandlerExecs"] = self.lifecyclePostStartHandlerExecs!
            }
            if self.lifecyclePostStartHandlerHttpGetHost != nil {
                map["LifecyclePostStartHandlerHttpGetHost"] = self.lifecyclePostStartHandlerHttpGetHost!
            }
            if self.lifecyclePostStartHandlerHttpGetPath != nil {
                map["LifecyclePostStartHandlerHttpGetPath"] = self.lifecyclePostStartHandlerHttpGetPath!
            }
            if self.lifecyclePostStartHandlerHttpGetPort != nil {
                map["LifecyclePostStartHandlerHttpGetPort"] = self.lifecyclePostStartHandlerHttpGetPort!
            }
            if self.lifecyclePostStartHandlerHttpGetScheme != nil {
                map["LifecyclePostStartHandlerHttpGetScheme"] = self.lifecyclePostStartHandlerHttpGetScheme!
            }
            if self.lifecyclePostStartHandlerTcpSocketHost != nil {
                map["LifecyclePostStartHandlerTcpSocketHost"] = self.lifecyclePostStartHandlerTcpSocketHost!
            }
            if self.lifecyclePostStartHandlerTcpSocketPort != nil {
                map["LifecyclePostStartHandlerTcpSocketPort"] = self.lifecyclePostStartHandlerTcpSocketPort!
            }
            if self.lifecyclePreStopHandlerExecs != nil {
                map["LifecyclePreStopHandlerExecs"] = self.lifecyclePreStopHandlerExecs!
            }
            if self.lifecyclePreStopHandlerHttpGetHost != nil {
                map["LifecyclePreStopHandlerHttpGetHost"] = self.lifecyclePreStopHandlerHttpGetHost!
            }
            if self.lifecyclePreStopHandlerHttpGetPath != nil {
                map["LifecyclePreStopHandlerHttpGetPath"] = self.lifecyclePreStopHandlerHttpGetPath!
            }
            if self.lifecyclePreStopHandlerHttpGetPort != nil {
                map["LifecyclePreStopHandlerHttpGetPort"] = self.lifecyclePreStopHandlerHttpGetPort!
            }
            if self.lifecyclePreStopHandlerHttpGetScheme != nil {
                map["LifecyclePreStopHandlerHttpGetScheme"] = self.lifecyclePreStopHandlerHttpGetScheme!
            }
            if self.lifecyclePreStopHandlerTcpSocketHost != nil {
                map["LifecyclePreStopHandlerTcpSocketHost"] = self.lifecyclePreStopHandlerTcpSocketHost!
            }
            if self.lifecyclePreStopHandlerTcpSocketPort != nil {
                map["LifecyclePreStopHandlerTcpSocketPort"] = self.lifecyclePreStopHandlerTcpSocketPort!
            }
            if self.memory != nil {
                map["Memory"] = self.memory!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.ports != nil {
                var tmp : [Any] = []
                for k in self.ports! {
                    tmp.append(k.toMap())
                }
                map["Ports"] = tmp
            }
            if self.stdin != nil {
                map["Stdin"] = self.stdin!
            }
            if self.stdinOnce != nil {
                map["StdinOnce"] = self.stdinOnce!
            }
            if self.tty != nil {
                map["Tty"] = self.tty!
            }
            if self.volumeMounts != nil {
                var tmp : [Any] = []
                for k in self.volumeMounts! {
                    tmp.append(k.toMap())
                }
                map["VolumeMounts"] = tmp
            }
            if self.workingDir != nil {
                map["WorkingDir"] = self.workingDir!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LivenessProbe") && dict["LivenessProbe"] != nil {
                var model = ModifyEciScalingConfigurationRequest.Containers.LivenessProbe()
                model.fromMap(dict["LivenessProbe"] as! [String: Any])
                self.livenessProbe = model
            }
            if dict.keys.contains("ReadinessProbe") && dict["ReadinessProbe"] != nil {
                var model = ModifyEciScalingConfigurationRequest.Containers.ReadinessProbe()
                model.fromMap(dict["ReadinessProbe"] as! [String: Any])
                self.readinessProbe = model
            }
            if dict.keys.contains("SecurityContext") && dict["SecurityContext"] != nil {
                var model = ModifyEciScalingConfigurationRequest.Containers.SecurityContext()
                model.fromMap(dict["SecurityContext"] as! [String: Any])
                self.securityContext = model
            }
            if dict.keys.contains("Args") && dict["Args"] != nil {
                self.args = dict["Args"] as! [String]
            }
            if dict.keys.contains("Commands") && dict["Commands"] != nil {
                self.commands = dict["Commands"] as! [String]
            }
            if dict.keys.contains("Cpu") && dict["Cpu"] != nil {
                self.cpu = dict["Cpu"] as! Double
            }
            if dict.keys.contains("EnvironmentVars") && dict["EnvironmentVars"] != nil {
                var tmp : [ModifyEciScalingConfigurationRequest.Containers.EnvironmentVars] = []
                for v in dict["EnvironmentVars"] as! [Any] {
                    var model = ModifyEciScalingConfigurationRequest.Containers.EnvironmentVars()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.environmentVars = tmp
            }
            if dict.keys.contains("Gpu") && dict["Gpu"] != nil {
                self.gpu = dict["Gpu"] as! Int32
            }
            if dict.keys.contains("Image") && dict["Image"] != nil {
                self.image = dict["Image"] as! String
            }
            if dict.keys.contains("ImagePullPolicy") && dict["ImagePullPolicy"] != nil {
                self.imagePullPolicy = dict["ImagePullPolicy"] as! String
            }
            if dict.keys.contains("LifecyclePostStartHandlerExecs") && dict["LifecyclePostStartHandlerExecs"] != nil {
                self.lifecyclePostStartHandlerExecs = dict["LifecyclePostStartHandlerExecs"] as! [String]
            }
            if dict.keys.contains("LifecyclePostStartHandlerHttpGetHost") && dict["LifecyclePostStartHandlerHttpGetHost"] != nil {
                self.lifecyclePostStartHandlerHttpGetHost = dict["LifecyclePostStartHandlerHttpGetHost"] as! String
            }
            if dict.keys.contains("LifecyclePostStartHandlerHttpGetPath") && dict["LifecyclePostStartHandlerHttpGetPath"] != nil {
                self.lifecyclePostStartHandlerHttpGetPath = dict["LifecyclePostStartHandlerHttpGetPath"] as! String
            }
            if dict.keys.contains("LifecyclePostStartHandlerHttpGetPort") && dict["LifecyclePostStartHandlerHttpGetPort"] != nil {
                self.lifecyclePostStartHandlerHttpGetPort = dict["LifecyclePostStartHandlerHttpGetPort"] as! Int32
            }
            if dict.keys.contains("LifecyclePostStartHandlerHttpGetScheme") && dict["LifecyclePostStartHandlerHttpGetScheme"] != nil {
                self.lifecyclePostStartHandlerHttpGetScheme = dict["LifecyclePostStartHandlerHttpGetScheme"] as! String
            }
            if dict.keys.contains("LifecyclePostStartHandlerTcpSocketHost") && dict["LifecyclePostStartHandlerTcpSocketHost"] != nil {
                self.lifecyclePostStartHandlerTcpSocketHost = dict["LifecyclePostStartHandlerTcpSocketHost"] as! String
            }
            if dict.keys.contains("LifecyclePostStartHandlerTcpSocketPort") && dict["LifecyclePostStartHandlerTcpSocketPort"] != nil {
                self.lifecyclePostStartHandlerTcpSocketPort = dict["LifecyclePostStartHandlerTcpSocketPort"] as! Int32
            }
            if dict.keys.contains("LifecyclePreStopHandlerExecs") && dict["LifecyclePreStopHandlerExecs"] != nil {
                self.lifecyclePreStopHandlerExecs = dict["LifecyclePreStopHandlerExecs"] as! [String]
            }
            if dict.keys.contains("LifecyclePreStopHandlerHttpGetHost") && dict["LifecyclePreStopHandlerHttpGetHost"] != nil {
                self.lifecyclePreStopHandlerHttpGetHost = dict["LifecyclePreStopHandlerHttpGetHost"] as! String
            }
            if dict.keys.contains("LifecyclePreStopHandlerHttpGetPath") && dict["LifecyclePreStopHandlerHttpGetPath"] != nil {
                self.lifecyclePreStopHandlerHttpGetPath = dict["LifecyclePreStopHandlerHttpGetPath"] as! String
            }
            if dict.keys.contains("LifecyclePreStopHandlerHttpGetPort") && dict["LifecyclePreStopHandlerHttpGetPort"] != nil {
                self.lifecyclePreStopHandlerHttpGetPort = dict["LifecyclePreStopHandlerHttpGetPort"] as! Int32
            }
            if dict.keys.contains("LifecyclePreStopHandlerHttpGetScheme") && dict["LifecyclePreStopHandlerHttpGetScheme"] != nil {
                self.lifecyclePreStopHandlerHttpGetScheme = dict["LifecyclePreStopHandlerHttpGetScheme"] as! String
            }
            if dict.keys.contains("LifecyclePreStopHandlerTcpSocketHost") && dict["LifecyclePreStopHandlerTcpSocketHost"] != nil {
                self.lifecyclePreStopHandlerTcpSocketHost = dict["LifecyclePreStopHandlerTcpSocketHost"] as! String
            }
            if dict.keys.contains("LifecyclePreStopHandlerTcpSocketPort") && dict["LifecyclePreStopHandlerTcpSocketPort"] != nil {
                self.lifecyclePreStopHandlerTcpSocketPort = dict["LifecyclePreStopHandlerTcpSocketPort"] as! Int32
            }
            if dict.keys.contains("Memory") && dict["Memory"] != nil {
                self.memory = dict["Memory"] as! Double
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Ports") && dict["Ports"] != nil {
                var tmp : [ModifyEciScalingConfigurationRequest.Containers.Ports] = []
                for v in dict["Ports"] as! [Any] {
                    var model = ModifyEciScalingConfigurationRequest.Containers.Ports()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ports = tmp
            }
            if dict.keys.contains("Stdin") && dict["Stdin"] != nil {
                self.stdin = dict["Stdin"] as! Bool
            }
            if dict.keys.contains("StdinOnce") && dict["StdinOnce"] != nil {
                self.stdinOnce = dict["StdinOnce"] as! Bool
            }
            if dict.keys.contains("Tty") && dict["Tty"] != nil {
                self.tty = dict["Tty"] as! Bool
            }
            if dict.keys.contains("VolumeMounts") && dict["VolumeMounts"] != nil {
                var tmp : [ModifyEciScalingConfigurationRequest.Containers.VolumeMounts] = []
                for v in dict["VolumeMounts"] as! [Any] {
                    var model = ModifyEciScalingConfigurationRequest.Containers.VolumeMounts()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.volumeMounts = tmp
            }
            if dict.keys.contains("WorkingDir") && dict["WorkingDir"] != nil {
                self.workingDir = dict["WorkingDir"] as! String
            }
        }
    }
    public class DnsConfigOptions : Tea.TeaModel {
        public var name: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public class HostAliases : Tea.TeaModel {
        public var hostnames: [String]?

        public var ip: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.hostnames != nil {
                map["Hostnames"] = self.hostnames!
            }
            if self.ip != nil {
                map["Ip"] = self.ip!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Hostnames") && dict["Hostnames"] != nil {
                self.hostnames = dict["Hostnames"] as! [String]
            }
            if dict.keys.contains("Ip") && dict["Ip"] != nil {
                self.ip = dict["Ip"] as! String
            }
        }
    }
    public class ImageRegistryCredentials : Tea.TeaModel {
        public var password: String?

        public var server: String?

        public var userName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.password != nil {
                map["Password"] = self.password!
            }
            if self.server != nil {
                map["Server"] = self.server!
            }
            if self.userName != nil {
                map["UserName"] = self.userName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Password") && dict["Password"] != nil {
                self.password = dict["Password"] as! String
            }
            if dict.keys.contains("Server") && dict["Server"] != nil {
                self.server = dict["Server"] as! String
            }
            if dict.keys.contains("UserName") && dict["UserName"] != nil {
                self.userName = dict["UserName"] as! String
            }
        }
    }
    public class InitContainers : Tea.TeaModel {
        public class SecurityContext : Tea.TeaModel {
            public class Capability : Tea.TeaModel {
                public var adds: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.adds != nil {
                        map["Adds"] = self.adds!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Adds") && dict["Adds"] != nil {
                        self.adds = dict["Adds"] as! [String]
                    }
                }
            }
            public var capability: ModifyEciScalingConfigurationRequest.InitContainers.SecurityContext.Capability?

            public var readOnlyRootFilesystem: Bool?

            public var runAsUser: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.capability?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.capability != nil {
                    map["Capability"] = self.capability?.toMap()
                }
                if self.readOnlyRootFilesystem != nil {
                    map["ReadOnlyRootFilesystem"] = self.readOnlyRootFilesystem!
                }
                if self.runAsUser != nil {
                    map["RunAsUser"] = self.runAsUser!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Capability") && dict["Capability"] != nil {
                    var model = ModifyEciScalingConfigurationRequest.InitContainers.SecurityContext.Capability()
                    model.fromMap(dict["Capability"] as! [String: Any])
                    self.capability = model
                }
                if dict.keys.contains("ReadOnlyRootFilesystem") && dict["ReadOnlyRootFilesystem"] != nil {
                    self.readOnlyRootFilesystem = dict["ReadOnlyRootFilesystem"] as! Bool
                }
                if dict.keys.contains("RunAsUser") && dict["RunAsUser"] != nil {
                    self.runAsUser = dict["RunAsUser"] as! Int64
                }
            }
        }
        public class InitContainerEnvironmentVars : Tea.TeaModel {
            public class FieldRef : Tea.TeaModel {
                public var fieldPath: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.fieldPath != nil {
                        map["FieldPath"] = self.fieldPath!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("FieldPath") && dict["FieldPath"] != nil {
                        self.fieldPath = dict["FieldPath"] as! String
                    }
                }
            }
            public var fieldRef: ModifyEciScalingConfigurationRequest.InitContainers.InitContainerEnvironmentVars.FieldRef?

            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.fieldRef?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fieldRef != nil {
                    map["FieldRef"] = self.fieldRef?.toMap()
                }
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FieldRef") && dict["FieldRef"] != nil {
                    var model = ModifyEciScalingConfigurationRequest.InitContainers.InitContainerEnvironmentVars.FieldRef()
                    model.fromMap(dict["FieldRef"] as! [String: Any])
                    self.fieldRef = model
                }
                if dict.keys.contains("Key") && dict["Key"] != nil {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public class InitContainerPorts : Tea.TeaModel {
            public var port: Int32?

            public var protocol_: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.protocol_ != nil {
                    map["Protocol"] = self.protocol_!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Port") && dict["Port"] != nil {
                    self.port = dict["Port"] as! Int32
                }
                if dict.keys.contains("Protocol") && dict["Protocol"] != nil {
                    self.protocol_ = dict["Protocol"] as! String
                }
            }
        }
        public class InitContainerVolumeMounts : Tea.TeaModel {
            public var mountPath: String?

            public var mountPropagation: String?

            public var name: String?

            public var readOnly: Bool?

            public var subPath: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.mountPath != nil {
                    map["MountPath"] = self.mountPath!
                }
                if self.mountPropagation != nil {
                    map["MountPropagation"] = self.mountPropagation!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.readOnly != nil {
                    map["ReadOnly"] = self.readOnly!
                }
                if self.subPath != nil {
                    map["SubPath"] = self.subPath!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("MountPath") && dict["MountPath"] != nil {
                    self.mountPath = dict["MountPath"] as! String
                }
                if dict.keys.contains("MountPropagation") && dict["MountPropagation"] != nil {
                    self.mountPropagation = dict["MountPropagation"] as! String
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("ReadOnly") && dict["ReadOnly"] != nil {
                    self.readOnly = dict["ReadOnly"] as! Bool
                }
                if dict.keys.contains("SubPath") && dict["SubPath"] != nil {
                    self.subPath = dict["SubPath"] as! String
                }
            }
        }
        public var securityContext: ModifyEciScalingConfigurationRequest.InitContainers.SecurityContext?

        public var args: [String]?

        public var commands: [String]?

        public var cpu: Double?

        public var gpu: Int32?

        public var image: String?

        public var imagePullPolicy: String?

        public var initContainerEnvironmentVars: [ModifyEciScalingConfigurationRequest.InitContainers.InitContainerEnvironmentVars]?

        public var initContainerPorts: [ModifyEciScalingConfigurationRequest.InitContainers.InitContainerPorts]?

        public var initContainerVolumeMounts: [ModifyEciScalingConfigurationRequest.InitContainers.InitContainerVolumeMounts]?

        public var memory: Double?

        public var name: String?

        public var workingDir: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.securityContext?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.securityContext != nil {
                map["SecurityContext"] = self.securityContext?.toMap()
            }
            if self.args != nil {
                map["Args"] = self.args!
            }
            if self.commands != nil {
                map["Commands"] = self.commands!
            }
            if self.cpu != nil {
                map["Cpu"] = self.cpu!
            }
            if self.gpu != nil {
                map["Gpu"] = self.gpu!
            }
            if self.image != nil {
                map["Image"] = self.image!
            }
            if self.imagePullPolicy != nil {
                map["ImagePullPolicy"] = self.imagePullPolicy!
            }
            if self.initContainerEnvironmentVars != nil {
                var tmp : [Any] = []
                for k in self.initContainerEnvironmentVars! {
                    tmp.append(k.toMap())
                }
                map["InitContainerEnvironmentVars"] = tmp
            }
            if self.initContainerPorts != nil {
                var tmp : [Any] = []
                for k in self.initContainerPorts! {
                    tmp.append(k.toMap())
                }
                map["InitContainerPorts"] = tmp
            }
            if self.initContainerVolumeMounts != nil {
                var tmp : [Any] = []
                for k in self.initContainerVolumeMounts! {
                    tmp.append(k.toMap())
                }
                map["InitContainerVolumeMounts"] = tmp
            }
            if self.memory != nil {
                map["Memory"] = self.memory!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.workingDir != nil {
                map["WorkingDir"] = self.workingDir!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SecurityContext") && dict["SecurityContext"] != nil {
                var model = ModifyEciScalingConfigurationRequest.InitContainers.SecurityContext()
                model.fromMap(dict["SecurityContext"] as! [String: Any])
                self.securityContext = model
            }
            if dict.keys.contains("Args") && dict["Args"] != nil {
                self.args = dict["Args"] as! [String]
            }
            if dict.keys.contains("Commands") && dict["Commands"] != nil {
                self.commands = dict["Commands"] as! [String]
            }
            if dict.keys.contains("Cpu") && dict["Cpu"] != nil {
                self.cpu = dict["Cpu"] as! Double
            }
            if dict.keys.contains("Gpu") && dict["Gpu"] != nil {
                self.gpu = dict["Gpu"] as! Int32
            }
            if dict.keys.contains("Image") && dict["Image"] != nil {
                self.image = dict["Image"] as! String
            }
            if dict.keys.contains("ImagePullPolicy") && dict["ImagePullPolicy"] != nil {
                self.imagePullPolicy = dict["ImagePullPolicy"] as! String
            }
            if dict.keys.contains("InitContainerEnvironmentVars") && dict["InitContainerEnvironmentVars"] != nil {
                var tmp : [ModifyEciScalingConfigurationRequest.InitContainers.InitContainerEnvironmentVars] = []
                for v in dict["InitContainerEnvironmentVars"] as! [Any] {
                    var model = ModifyEciScalingConfigurationRequest.InitContainers.InitContainerEnvironmentVars()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.initContainerEnvironmentVars = tmp
            }
            if dict.keys.contains("InitContainerPorts") && dict["InitContainerPorts"] != nil {
                var tmp : [ModifyEciScalingConfigurationRequest.InitContainers.InitContainerPorts] = []
                for v in dict["InitContainerPorts"] as! [Any] {
                    var model = ModifyEciScalingConfigurationRequest.InitContainers.InitContainerPorts()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.initContainerPorts = tmp
            }
            if dict.keys.contains("InitContainerVolumeMounts") && dict["InitContainerVolumeMounts"] != nil {
                var tmp : [ModifyEciScalingConfigurationRequest.InitContainers.InitContainerVolumeMounts] = []
                for v in dict["InitContainerVolumeMounts"] as! [Any] {
                    var model = ModifyEciScalingConfigurationRequest.InitContainers.InitContainerVolumeMounts()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.initContainerVolumeMounts = tmp
            }
            if dict.keys.contains("Memory") && dict["Memory"] != nil {
                self.memory = dict["Memory"] as! Double
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("WorkingDir") && dict["WorkingDir"] != nil {
                self.workingDir = dict["WorkingDir"] as! String
            }
        }
    }
    public class SecurityContextSysCtls : Tea.TeaModel {
        public var name: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public class Volumes : Tea.TeaModel {
        public class DiskVolume : Tea.TeaModel {
            public var diskId: String?

            public var diskSize: Int32?

            public var fsType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.diskId != nil {
                    map["DiskId"] = self.diskId!
                }
                if self.diskSize != nil {
                    map["DiskSize"] = self.diskSize!
                }
                if self.fsType != nil {
                    map["FsType"] = self.fsType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DiskId") && dict["DiskId"] != nil {
                    self.diskId = dict["DiskId"] as! String
                }
                if dict.keys.contains("DiskSize") && dict["DiskSize"] != nil {
                    self.diskSize = dict["DiskSize"] as! Int32
                }
                if dict.keys.contains("FsType") && dict["FsType"] != nil {
                    self.fsType = dict["FsType"] as! String
                }
            }
        }
        public class EmptyDirVolume : Tea.TeaModel {
            public var medium: String?

            public var sizeLimit: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.medium != nil {
                    map["Medium"] = self.medium!
                }
                if self.sizeLimit != nil {
                    map["SizeLimit"] = self.sizeLimit!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Medium") && dict["Medium"] != nil {
                    self.medium = dict["Medium"] as! String
                }
                if dict.keys.contains("SizeLimit") && dict["SizeLimit"] != nil {
                    self.sizeLimit = dict["SizeLimit"] as! String
                }
            }
        }
        public class FlexVolume : Tea.TeaModel {
            public var driver: String?

            public var fsType: String?

            public var options: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.driver != nil {
                    map["Driver"] = self.driver!
                }
                if self.fsType != nil {
                    map["FsType"] = self.fsType!
                }
                if self.options != nil {
                    map["Options"] = self.options!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Driver") && dict["Driver"] != nil {
                    self.driver = dict["Driver"] as! String
                }
                if dict.keys.contains("FsType") && dict["FsType"] != nil {
                    self.fsType = dict["FsType"] as! String
                }
                if dict.keys.contains("Options") && dict["Options"] != nil {
                    self.options = dict["Options"] as! String
                }
            }
        }
        public class HostPathVolume : Tea.TeaModel {
            public var path: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.path != nil {
                    map["Path"] = self.path!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Path") && dict["Path"] != nil {
                    self.path = dict["Path"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class NFSVolume : Tea.TeaModel {
            public var path: String?

            public var readOnly: Bool?

            public var server: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.path != nil {
                    map["Path"] = self.path!
                }
                if self.readOnly != nil {
                    map["ReadOnly"] = self.readOnly!
                }
                if self.server != nil {
                    map["Server"] = self.server!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Path") && dict["Path"] != nil {
                    self.path = dict["Path"] as! String
                }
                if dict.keys.contains("ReadOnly") && dict["ReadOnly"] != nil {
                    self.readOnly = dict["ReadOnly"] as! Bool
                }
                if dict.keys.contains("Server") && dict["Server"] != nil {
                    self.server = dict["Server"] as! String
                }
            }
        }
        public class ConfigFileVolumeConfigFileToPath : Tea.TeaModel {
            public var content: String?

            public var mode: Int32?

            public var path: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.content != nil {
                    map["Content"] = self.content!
                }
                if self.mode != nil {
                    map["Mode"] = self.mode!
                }
                if self.path != nil {
                    map["Path"] = self.path!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Content") && dict["Content"] != nil {
                    self.content = dict["Content"] as! String
                }
                if dict.keys.contains("Mode") && dict["Mode"] != nil {
                    self.mode = dict["Mode"] as! Int32
                }
                if dict.keys.contains("Path") && dict["Path"] != nil {
                    self.path = dict["Path"] as! String
                }
            }
        }
        public var diskVolume: ModifyEciScalingConfigurationRequest.Volumes.DiskVolume?

        public var emptyDirVolume: ModifyEciScalingConfigurationRequest.Volumes.EmptyDirVolume?

        public var flexVolume: ModifyEciScalingConfigurationRequest.Volumes.FlexVolume?

        public var hostPathVolume: ModifyEciScalingConfigurationRequest.Volumes.HostPathVolume?

        public var NFSVolume: ModifyEciScalingConfigurationRequest.Volumes.NFSVolume?

        public var configFileVolumeConfigFileToPath: [ModifyEciScalingConfigurationRequest.Volumes.ConfigFileVolumeConfigFileToPath]?

        public var configFileVolumeDefaultMode: Int32?

        public var name: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.diskVolume?.validate()
            try self.emptyDirVolume?.validate()
            try self.flexVolume?.validate()
            try self.hostPathVolume?.validate()
            try self.NFSVolume?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.diskVolume != nil {
                map["DiskVolume"] = self.diskVolume?.toMap()
            }
            if self.emptyDirVolume != nil {
                map["EmptyDirVolume"] = self.emptyDirVolume?.toMap()
            }
            if self.flexVolume != nil {
                map["FlexVolume"] = self.flexVolume?.toMap()
            }
            if self.hostPathVolume != nil {
                map["HostPathVolume"] = self.hostPathVolume?.toMap()
            }
            if self.NFSVolume != nil {
                map["NFSVolume"] = self.NFSVolume?.toMap()
            }
            if self.configFileVolumeConfigFileToPath != nil {
                var tmp : [Any] = []
                for k in self.configFileVolumeConfigFileToPath! {
                    tmp.append(k.toMap())
                }
                map["ConfigFileVolumeConfigFileToPath"] = tmp
            }
            if self.configFileVolumeDefaultMode != nil {
                map["ConfigFileVolumeDefaultMode"] = self.configFileVolumeDefaultMode!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DiskVolume") && dict["DiskVolume"] != nil {
                var model = ModifyEciScalingConfigurationRequest.Volumes.DiskVolume()
                model.fromMap(dict["DiskVolume"] as! [String: Any])
                self.diskVolume = model
            }
            if dict.keys.contains("EmptyDirVolume") && dict["EmptyDirVolume"] != nil {
                var model = ModifyEciScalingConfigurationRequest.Volumes.EmptyDirVolume()
                model.fromMap(dict["EmptyDirVolume"] as! [String: Any])
                self.emptyDirVolume = model
            }
            if dict.keys.contains("FlexVolume") && dict["FlexVolume"] != nil {
                var model = ModifyEciScalingConfigurationRequest.Volumes.FlexVolume()
                model.fromMap(dict["FlexVolume"] as! [String: Any])
                self.flexVolume = model
            }
            if dict.keys.contains("HostPathVolume") && dict["HostPathVolume"] != nil {
                var model = ModifyEciScalingConfigurationRequest.Volumes.HostPathVolume()
                model.fromMap(dict["HostPathVolume"] as! [String: Any])
                self.hostPathVolume = model
            }
            if dict.keys.contains("NFSVolume") && dict["NFSVolume"] != nil {
                var model = ModifyEciScalingConfigurationRequest.Volumes.NFSVolume()
                model.fromMap(dict["NFSVolume"] as! [String: Any])
                self.NFSVolume = model
            }
            if dict.keys.contains("ConfigFileVolumeConfigFileToPath") && dict["ConfigFileVolumeConfigFileToPath"] != nil {
                var tmp : [ModifyEciScalingConfigurationRequest.Volumes.ConfigFileVolumeConfigFileToPath] = []
                for v in dict["ConfigFileVolumeConfigFileToPath"] as! [Any] {
                    var model = ModifyEciScalingConfigurationRequest.Volumes.ConfigFileVolumeConfigFileToPath()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.configFileVolumeConfigFileToPath = tmp
            }
            if dict.keys.contains("ConfigFileVolumeDefaultMode") && dict["ConfigFileVolumeDefaultMode"] != nil {
                self.configFileVolumeDefaultMode = dict["ConfigFileVolumeDefaultMode"] as! Int32
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var acrRegistryInfos: [ModifyEciScalingConfigurationRequest.AcrRegistryInfos]?

    public var activeDeadlineSeconds: Int64?

    public var autoCreateEip: Bool?

    public var autoMatchImageCache: Bool?

    public var containerGroupName: String?

    public var containers: [ModifyEciScalingConfigurationRequest.Containers]?

    public var containersUpdateType: String?

    public var costOptimization: Bool?

    public var cpu: Double?

    public var cpuOptionsCore: Int32?

    public var cpuOptionsThreadsPerCore: Int32?

    public var dataCacheBucket: String?

    public var dataCacheBurstingEnabled: Bool?

    public var dataCachePL: String?

    public var dataCacheProvisionedIops: Int32?

    public var description_: String?

    public var dnsConfigNameServers: [String]?

    public var dnsConfigOptions: [ModifyEciScalingConfigurationRequest.DnsConfigOptions]?

    public var dnsConfigSearchs: [String]?

    public var dnsPolicy: String?

    public var egressBandwidth: Int64?

    public var eipBandwidth: Int32?

    public var enableSls: Bool?

    public var ephemeralStorage: Int32?

    public var hostAliases: [ModifyEciScalingConfigurationRequest.HostAliases]?

    public var hostName: String?

    public var imageRegistryCredentials: [ModifyEciScalingConfigurationRequest.ImageRegistryCredentials]?

    public var imageSnapshotId: String?

    public var ingressBandwidth: Int64?

    public var initContainers: [ModifyEciScalingConfigurationRequest.InitContainers]?

    public var instanceFamilyLevel: String?

    public var instanceTypes: [String]?

    public var ipv6AddressCount: Int32?

    public var loadBalancerWeight: Int32?

    public var memory: Double?

    public var ntpServers: [String]?

    public var ownerId: Int64?

    public var ramRoleName: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var restartPolicy: String?

    public var scalingConfigurationId: String?

    public var scalingConfigurationName: String?

    public var securityContextSysCtls: [ModifyEciScalingConfigurationRequest.SecurityContextSysCtls]?

    public var securityGroupId: String?

    public var spotPriceLimit: Double?

    public var spotStrategy: String?

    public var tags: [ModifyEciScalingConfigurationRequest.Tags]?

    public var terminationGracePeriodSeconds: Int64?

    public var volumes: [ModifyEciScalingConfigurationRequest.Volumes]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acrRegistryInfos != nil {
            var tmp : [Any] = []
            for k in self.acrRegistryInfos! {
                tmp.append(k.toMap())
            }
            map["AcrRegistryInfos"] = tmp
        }
        if self.activeDeadlineSeconds != nil {
            map["ActiveDeadlineSeconds"] = self.activeDeadlineSeconds!
        }
        if self.autoCreateEip != nil {
            map["AutoCreateEip"] = self.autoCreateEip!
        }
        if self.autoMatchImageCache != nil {
            map["AutoMatchImageCache"] = self.autoMatchImageCache!
        }
        if self.containerGroupName != nil {
            map["ContainerGroupName"] = self.containerGroupName!
        }
        if self.containers != nil {
            var tmp : [Any] = []
            for k in self.containers! {
                tmp.append(k.toMap())
            }
            map["Containers"] = tmp
        }
        if self.containersUpdateType != nil {
            map["ContainersUpdateType"] = self.containersUpdateType!
        }
        if self.costOptimization != nil {
            map["CostOptimization"] = self.costOptimization!
        }
        if self.cpu != nil {
            map["Cpu"] = self.cpu!
        }
        if self.cpuOptionsCore != nil {
            map["CpuOptionsCore"] = self.cpuOptionsCore!
        }
        if self.cpuOptionsThreadsPerCore != nil {
            map["CpuOptionsThreadsPerCore"] = self.cpuOptionsThreadsPerCore!
        }
        if self.dataCacheBucket != nil {
            map["DataCacheBucket"] = self.dataCacheBucket!
        }
        if self.dataCacheBurstingEnabled != nil {
            map["DataCacheBurstingEnabled"] = self.dataCacheBurstingEnabled!
        }
        if self.dataCachePL != nil {
            map["DataCachePL"] = self.dataCachePL!
        }
        if self.dataCacheProvisionedIops != nil {
            map["DataCacheProvisionedIops"] = self.dataCacheProvisionedIops!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.dnsConfigNameServers != nil {
            map["DnsConfigNameServers"] = self.dnsConfigNameServers!
        }
        if self.dnsConfigOptions != nil {
            var tmp : [Any] = []
            for k in self.dnsConfigOptions! {
                tmp.append(k.toMap())
            }
            map["DnsConfigOptions"] = tmp
        }
        if self.dnsConfigSearchs != nil {
            map["DnsConfigSearchs"] = self.dnsConfigSearchs!
        }
        if self.dnsPolicy != nil {
            map["DnsPolicy"] = self.dnsPolicy!
        }
        if self.egressBandwidth != nil {
            map["EgressBandwidth"] = self.egressBandwidth!
        }
        if self.eipBandwidth != nil {
            map["EipBandwidth"] = self.eipBandwidth!
        }
        if self.enableSls != nil {
            map["EnableSls"] = self.enableSls!
        }
        if self.ephemeralStorage != nil {
            map["EphemeralStorage"] = self.ephemeralStorage!
        }
        if self.hostAliases != nil {
            var tmp : [Any] = []
            for k in self.hostAliases! {
                tmp.append(k.toMap())
            }
            map["HostAliases"] = tmp
        }
        if self.hostName != nil {
            map["HostName"] = self.hostName!
        }
        if self.imageRegistryCredentials != nil {
            var tmp : [Any] = []
            for k in self.imageRegistryCredentials! {
                tmp.append(k.toMap())
            }
            map["ImageRegistryCredentials"] = tmp
        }
        if self.imageSnapshotId != nil {
            map["ImageSnapshotId"] = self.imageSnapshotId!
        }
        if self.ingressBandwidth != nil {
            map["IngressBandwidth"] = self.ingressBandwidth!
        }
        if self.initContainers != nil {
            var tmp : [Any] = []
            for k in self.initContainers! {
                tmp.append(k.toMap())
            }
            map["InitContainers"] = tmp
        }
        if self.instanceFamilyLevel != nil {
            map["InstanceFamilyLevel"] = self.instanceFamilyLevel!
        }
        if self.instanceTypes != nil {
            map["InstanceTypes"] = self.instanceTypes!
        }
        if self.ipv6AddressCount != nil {
            map["Ipv6AddressCount"] = self.ipv6AddressCount!
        }
        if self.loadBalancerWeight != nil {
            map["LoadBalancerWeight"] = self.loadBalancerWeight!
        }
        if self.memory != nil {
            map["Memory"] = self.memory!
        }
        if self.ntpServers != nil {
            map["NtpServers"] = self.ntpServers!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.ramRoleName != nil {
            map["RamRoleName"] = self.ramRoleName!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.restartPolicy != nil {
            map["RestartPolicy"] = self.restartPolicy!
        }
        if self.scalingConfigurationId != nil {
            map["ScalingConfigurationId"] = self.scalingConfigurationId!
        }
        if self.scalingConfigurationName != nil {
            map["ScalingConfigurationName"] = self.scalingConfigurationName!
        }
        if self.securityContextSysCtls != nil {
            var tmp : [Any] = []
            for k in self.securityContextSysCtls! {
                tmp.append(k.toMap())
            }
            map["SecurityContextSysCtls"] = tmp
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.spotPriceLimit != nil {
            map["SpotPriceLimit"] = self.spotPriceLimit!
        }
        if self.spotStrategy != nil {
            map["SpotStrategy"] = self.spotStrategy!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        if self.terminationGracePeriodSeconds != nil {
            map["TerminationGracePeriodSeconds"] = self.terminationGracePeriodSeconds!
        }
        if self.volumes != nil {
            var tmp : [Any] = []
            for k in self.volumes! {
                tmp.append(k.toMap())
            }
            map["Volumes"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcrRegistryInfos") && dict["AcrRegistryInfos"] != nil {
            var tmp : [ModifyEciScalingConfigurationRequest.AcrRegistryInfos] = []
            for v in dict["AcrRegistryInfos"] as! [Any] {
                var model = ModifyEciScalingConfigurationRequest.AcrRegistryInfos()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.acrRegistryInfos = tmp
        }
        if dict.keys.contains("ActiveDeadlineSeconds") && dict["ActiveDeadlineSeconds"] != nil {
            self.activeDeadlineSeconds = dict["ActiveDeadlineSeconds"] as! Int64
        }
        if dict.keys.contains("AutoCreateEip") && dict["AutoCreateEip"] != nil {
            self.autoCreateEip = dict["AutoCreateEip"] as! Bool
        }
        if dict.keys.contains("AutoMatchImageCache") && dict["AutoMatchImageCache"] != nil {
            self.autoMatchImageCache = dict["AutoMatchImageCache"] as! Bool
        }
        if dict.keys.contains("ContainerGroupName") && dict["ContainerGroupName"] != nil {
            self.containerGroupName = dict["ContainerGroupName"] as! String
        }
        if dict.keys.contains("Containers") && dict["Containers"] != nil {
            var tmp : [ModifyEciScalingConfigurationRequest.Containers] = []
            for v in dict["Containers"] as! [Any] {
                var model = ModifyEciScalingConfigurationRequest.Containers()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.containers = tmp
        }
        if dict.keys.contains("ContainersUpdateType") && dict["ContainersUpdateType"] != nil {
            self.containersUpdateType = dict["ContainersUpdateType"] as! String
        }
        if dict.keys.contains("CostOptimization") && dict["CostOptimization"] != nil {
            self.costOptimization = dict["CostOptimization"] as! Bool
        }
        if dict.keys.contains("Cpu") && dict["Cpu"] != nil {
            self.cpu = dict["Cpu"] as! Double
        }
        if dict.keys.contains("CpuOptionsCore") && dict["CpuOptionsCore"] != nil {
            self.cpuOptionsCore = dict["CpuOptionsCore"] as! Int32
        }
        if dict.keys.contains("CpuOptionsThreadsPerCore") && dict["CpuOptionsThreadsPerCore"] != nil {
            self.cpuOptionsThreadsPerCore = dict["CpuOptionsThreadsPerCore"] as! Int32
        }
        if dict.keys.contains("DataCacheBucket") && dict["DataCacheBucket"] != nil {
            self.dataCacheBucket = dict["DataCacheBucket"] as! String
        }
        if dict.keys.contains("DataCacheBurstingEnabled") && dict["DataCacheBurstingEnabled"] != nil {
            self.dataCacheBurstingEnabled = dict["DataCacheBurstingEnabled"] as! Bool
        }
        if dict.keys.contains("DataCachePL") && dict["DataCachePL"] != nil {
            self.dataCachePL = dict["DataCachePL"] as! String
        }
        if dict.keys.contains("DataCacheProvisionedIops") && dict["DataCacheProvisionedIops"] != nil {
            self.dataCacheProvisionedIops = dict["DataCacheProvisionedIops"] as! Int32
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DnsConfigNameServers") && dict["DnsConfigNameServers"] != nil {
            self.dnsConfigNameServers = dict["DnsConfigNameServers"] as! [String]
        }
        if dict.keys.contains("DnsConfigOptions") && dict["DnsConfigOptions"] != nil {
            var tmp : [ModifyEciScalingConfigurationRequest.DnsConfigOptions] = []
            for v in dict["DnsConfigOptions"] as! [Any] {
                var model = ModifyEciScalingConfigurationRequest.DnsConfigOptions()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.dnsConfigOptions = tmp
        }
        if dict.keys.contains("DnsConfigSearchs") && dict["DnsConfigSearchs"] != nil {
            self.dnsConfigSearchs = dict["DnsConfigSearchs"] as! [String]
        }
        if dict.keys.contains("DnsPolicy") && dict["DnsPolicy"] != nil {
            self.dnsPolicy = dict["DnsPolicy"] as! String
        }
        if dict.keys.contains("EgressBandwidth") && dict["EgressBandwidth"] != nil {
            self.egressBandwidth = dict["EgressBandwidth"] as! Int64
        }
        if dict.keys.contains("EipBandwidth") && dict["EipBandwidth"] != nil {
            self.eipBandwidth = dict["EipBandwidth"] as! Int32
        }
        if dict.keys.contains("EnableSls") && dict["EnableSls"] != nil {
            self.enableSls = dict["EnableSls"] as! Bool
        }
        if dict.keys.contains("EphemeralStorage") && dict["EphemeralStorage"] != nil {
            self.ephemeralStorage = dict["EphemeralStorage"] as! Int32
        }
        if dict.keys.contains("HostAliases") && dict["HostAliases"] != nil {
            var tmp : [ModifyEciScalingConfigurationRequest.HostAliases] = []
            for v in dict["HostAliases"] as! [Any] {
                var model = ModifyEciScalingConfigurationRequest.HostAliases()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.hostAliases = tmp
        }
        if dict.keys.contains("HostName") && dict["HostName"] != nil {
            self.hostName = dict["HostName"] as! String
        }
        if dict.keys.contains("ImageRegistryCredentials") && dict["ImageRegistryCredentials"] != nil {
            var tmp : [ModifyEciScalingConfigurationRequest.ImageRegistryCredentials] = []
            for v in dict["ImageRegistryCredentials"] as! [Any] {
                var model = ModifyEciScalingConfigurationRequest.ImageRegistryCredentials()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.imageRegistryCredentials = tmp
        }
        if dict.keys.contains("ImageSnapshotId") && dict["ImageSnapshotId"] != nil {
            self.imageSnapshotId = dict["ImageSnapshotId"] as! String
        }
        if dict.keys.contains("IngressBandwidth") && dict["IngressBandwidth"] != nil {
            self.ingressBandwidth = dict["IngressBandwidth"] as! Int64
        }
        if dict.keys.contains("InitContainers") && dict["InitContainers"] != nil {
            var tmp : [ModifyEciScalingConfigurationRequest.InitContainers] = []
            for v in dict["InitContainers"] as! [Any] {
                var model = ModifyEciScalingConfigurationRequest.InitContainers()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.initContainers = tmp
        }
        if dict.keys.contains("InstanceFamilyLevel") && dict["InstanceFamilyLevel"] != nil {
            self.instanceFamilyLevel = dict["InstanceFamilyLevel"] as! String
        }
        if dict.keys.contains("InstanceTypes") && dict["InstanceTypes"] != nil {
            self.instanceTypes = dict["InstanceTypes"] as! [String]
        }
        if dict.keys.contains("Ipv6AddressCount") && dict["Ipv6AddressCount"] != nil {
            self.ipv6AddressCount = dict["Ipv6AddressCount"] as! Int32
        }
        if dict.keys.contains("LoadBalancerWeight") && dict["LoadBalancerWeight"] != nil {
            self.loadBalancerWeight = dict["LoadBalancerWeight"] as! Int32
        }
        if dict.keys.contains("Memory") && dict["Memory"] != nil {
            self.memory = dict["Memory"] as! Double
        }
        if dict.keys.contains("NtpServers") && dict["NtpServers"] != nil {
            self.ntpServers = dict["NtpServers"] as! [String]
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RamRoleName") && dict["RamRoleName"] != nil {
            self.ramRoleName = dict["RamRoleName"] as! String
        }
        if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("RestartPolicy") && dict["RestartPolicy"] != nil {
            self.restartPolicy = dict["RestartPolicy"] as! String
        }
        if dict.keys.contains("ScalingConfigurationId") && dict["ScalingConfigurationId"] != nil {
            self.scalingConfigurationId = dict["ScalingConfigurationId"] as! String
        }
        if dict.keys.contains("ScalingConfigurationName") && dict["ScalingConfigurationName"] != nil {
            self.scalingConfigurationName = dict["ScalingConfigurationName"] as! String
        }
        if dict.keys.contains("SecurityContextSysCtls") && dict["SecurityContextSysCtls"] != nil {
            var tmp : [ModifyEciScalingConfigurationRequest.SecurityContextSysCtls] = []
            for v in dict["SecurityContextSysCtls"] as! [Any] {
                var model = ModifyEciScalingConfigurationRequest.SecurityContextSysCtls()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.securityContextSysCtls = tmp
        }
        if dict.keys.contains("SecurityGroupId") && dict["SecurityGroupId"] != nil {
            self.securityGroupId = dict["SecurityGroupId"] as! String
        }
        if dict.keys.contains("SpotPriceLimit") && dict["SpotPriceLimit"] != nil {
            self.spotPriceLimit = dict["SpotPriceLimit"] as! Double
        }
        if dict.keys.contains("SpotStrategy") && dict["SpotStrategy"] != nil {
            self.spotStrategy = dict["SpotStrategy"] as! String
        }
        if dict.keys.contains("Tags") && dict["Tags"] != nil {
            var tmp : [ModifyEciScalingConfigurationRequest.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = ModifyEciScalingConfigurationRequest.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
        if dict.keys.contains("TerminationGracePeriodSeconds") && dict["TerminationGracePeriodSeconds"] != nil {
            self.terminationGracePeriodSeconds = dict["TerminationGracePeriodSeconds"] as! Int64
        }
        if dict.keys.contains("Volumes") && dict["Volumes"] != nil {
            var tmp : [ModifyEciScalingConfigurationRequest.Volumes] = []
            for v in dict["Volumes"] as! [Any] {
                var model = ModifyEciScalingConfigurationRequest.Volumes()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.volumes = tmp
        }
    }
}

public class ModifyEciScalingConfigurationResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyEciScalingConfigurationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyEciScalingConfigurationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyEciScalingConfigurationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyInstanceAttributeRequest : Tea.TeaModel {
    public var entrusted: Bool?

    public var instanceId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.entrusted != nil {
            map["Entrusted"] = self.entrusted!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Entrusted") && dict["Entrusted"] != nil {
            self.entrusted = dict["Entrusted"] as! Bool
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScalingGroupId") && dict["ScalingGroupId"] != nil {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
    }
}

public class ModifyInstanceAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyInstanceAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyInstanceAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyInstanceAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyLifecycleHookRequest : Tea.TeaModel {
    public var defaultResult: String?

    public var heartbeatTimeout: Int32?

    public var lifecycleHookId: String?

    public var lifecycleHookName: String?

    public var lifecycleHookStatus: String?

    public var lifecycleTransition: String?

    public var notificationArn: String?

    public var notificationMetadata: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.defaultResult != nil {
            map["DefaultResult"] = self.defaultResult!
        }
        if self.heartbeatTimeout != nil {
            map["HeartbeatTimeout"] = self.heartbeatTimeout!
        }
        if self.lifecycleHookId != nil {
            map["LifecycleHookId"] = self.lifecycleHookId!
        }
        if self.lifecycleHookName != nil {
            map["LifecycleHookName"] = self.lifecycleHookName!
        }
        if self.lifecycleHookStatus != nil {
            map["LifecycleHookStatus"] = self.lifecycleHookStatus!
        }
        if self.lifecycleTransition != nil {
            map["LifecycleTransition"] = self.lifecycleTransition!
        }
        if self.notificationArn != nil {
            map["NotificationArn"] = self.notificationArn!
        }
        if self.notificationMetadata != nil {
            map["NotificationMetadata"] = self.notificationMetadata!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DefaultResult") && dict["DefaultResult"] != nil {
            self.defaultResult = dict["DefaultResult"] as! String
        }
        if dict.keys.contains("HeartbeatTimeout") && dict["HeartbeatTimeout"] != nil {
            self.heartbeatTimeout = dict["HeartbeatTimeout"] as! Int32
        }
        if dict.keys.contains("LifecycleHookId") && dict["LifecycleHookId"] != nil {
            self.lifecycleHookId = dict["LifecycleHookId"] as! String
        }
        if dict.keys.contains("LifecycleHookName") && dict["LifecycleHookName"] != nil {
            self.lifecycleHookName = dict["LifecycleHookName"] as! String
        }
        if dict.keys.contains("LifecycleHookStatus") && dict["LifecycleHookStatus"] != nil {
            self.lifecycleHookStatus = dict["LifecycleHookStatus"] as! String
        }
        if dict.keys.contains("LifecycleTransition") && dict["LifecycleTransition"] != nil {
            self.lifecycleTransition = dict["LifecycleTransition"] as! String
        }
        if dict.keys.contains("NotificationArn") && dict["NotificationArn"] != nil {
            self.notificationArn = dict["NotificationArn"] as! String
        }
        if dict.keys.contains("NotificationMetadata") && dict["NotificationMetadata"] != nil {
            self.notificationMetadata = dict["NotificationMetadata"] as! String
        }
        if dict.keys.contains("OwnerAccount") && dict["OwnerAccount"] != nil {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScalingGroupId") && dict["ScalingGroupId"] != nil {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
    }
}

public class ModifyLifecycleHookResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyLifecycleHookResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyLifecycleHookResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyLifecycleHookResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyNotificationConfigurationRequest : Tea.TeaModel {
    public var notificationArn: String?

    public var notificationTypes: [String]?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.notificationArn != nil {
            map["NotificationArn"] = self.notificationArn!
        }
        if self.notificationTypes != nil {
            map["NotificationTypes"] = self.notificationTypes!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NotificationArn") && dict["NotificationArn"] != nil {
            self.notificationArn = dict["NotificationArn"] as! String
        }
        if dict.keys.contains("NotificationTypes") && dict["NotificationTypes"] != nil {
            self.notificationTypes = dict["NotificationTypes"] as! [String]
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScalingGroupId") && dict["ScalingGroupId"] != nil {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
    }
}

public class ModifyNotificationConfigurationResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyNotificationConfigurationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyNotificationConfigurationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyNotificationConfigurationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyScalingConfigurationRequest : Tea.TeaModel {
    public class ImageOptions : Tea.TeaModel {
        public var loginAsNonRoot: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.loginAsNonRoot != nil {
                map["LoginAsNonRoot"] = self.loginAsNonRoot!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LoginAsNonRoot") && dict["LoginAsNonRoot"] != nil {
                self.loginAsNonRoot = dict["LoginAsNonRoot"] as! Bool
            }
        }
    }
    public class PrivatePoolOptions : Tea.TeaModel {
        public var id: String?

        public var matchCriteria: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.matchCriteria != nil {
                map["MatchCriteria"] = self.matchCriteria!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("MatchCriteria") && dict["MatchCriteria"] != nil {
                self.matchCriteria = dict["MatchCriteria"] as! String
            }
        }
    }
    public class SystemDisk : Tea.TeaModel {
        public var autoSnapshotPolicyId: String?

        public var burstingEnabled: Bool?

        public var category: String?

        public var description_: String?

        public var diskName: String?

        public var encryptAlgorithm: String?

        public var encrypted: Bool?

        public var KMSKeyId: String?

        public var performanceLevel: String?

        public var provisionedIops: Int64?

        public var size: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.autoSnapshotPolicyId != nil {
                map["AutoSnapshotPolicyId"] = self.autoSnapshotPolicyId!
            }
            if self.burstingEnabled != nil {
                map["BurstingEnabled"] = self.burstingEnabled!
            }
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.diskName != nil {
                map["DiskName"] = self.diskName!
            }
            if self.encryptAlgorithm != nil {
                map["EncryptAlgorithm"] = self.encryptAlgorithm!
            }
            if self.encrypted != nil {
                map["Encrypted"] = self.encrypted!
            }
            if self.KMSKeyId != nil {
                map["KMSKeyId"] = self.KMSKeyId!
            }
            if self.performanceLevel != nil {
                map["PerformanceLevel"] = self.performanceLevel!
            }
            if self.provisionedIops != nil {
                map["ProvisionedIops"] = self.provisionedIops!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AutoSnapshotPolicyId") && dict["AutoSnapshotPolicyId"] != nil {
                self.autoSnapshotPolicyId = dict["AutoSnapshotPolicyId"] as! String
            }
            if dict.keys.contains("BurstingEnabled") && dict["BurstingEnabled"] != nil {
                self.burstingEnabled = dict["BurstingEnabled"] as! Bool
            }
            if dict.keys.contains("Category") && dict["Category"] != nil {
                self.category = dict["Category"] as! String
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("DiskName") && dict["DiskName"] != nil {
                self.diskName = dict["DiskName"] as! String
            }
            if dict.keys.contains("EncryptAlgorithm") && dict["EncryptAlgorithm"] != nil {
                self.encryptAlgorithm = dict["EncryptAlgorithm"] as! String
            }
            if dict.keys.contains("Encrypted") && dict["Encrypted"] != nil {
                self.encrypted = dict["Encrypted"] as! Bool
            }
            if dict.keys.contains("KMSKeyId") && dict["KMSKeyId"] != nil {
                self.KMSKeyId = dict["KMSKeyId"] as! String
            }
            if dict.keys.contains("PerformanceLevel") && dict["PerformanceLevel"] != nil {
                self.performanceLevel = dict["PerformanceLevel"] as! String
            }
            if dict.keys.contains("ProvisionedIops") && dict["ProvisionedIops"] != nil {
                self.provisionedIops = dict["ProvisionedIops"] as! Int64
            }
            if dict.keys.contains("Size") && dict["Size"] != nil {
                self.size = dict["Size"] as! Int32
            }
        }
    }
    public class CustomPriorities : Tea.TeaModel {
        public var instanceType: String?

        public var vswitchId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.vswitchId != nil {
                map["VswitchId"] = self.vswitchId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceType") && dict["InstanceType"] != nil {
                self.instanceType = dict["InstanceType"] as! String
            }
            if dict.keys.contains("VswitchId") && dict["VswitchId"] != nil {
                self.vswitchId = dict["VswitchId"] as! String
            }
        }
    }
    public class DataDisks : Tea.TeaModel {
        public var autoSnapshotPolicyId: String?

        public var burstingEnabled: Bool?

        public var categories: [String]?

        public var category: String?

        public var deleteWithInstance: Bool?

        public var description_: String?

        public var device: String?

        public var diskName: String?

        public var encrypted: String?

        public var KMSKeyId: String?

        public var performanceLevel: String?

        public var provisionedIops: Int64?

        public var size: Int32?

        public var snapshotId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.autoSnapshotPolicyId != nil {
                map["AutoSnapshotPolicyId"] = self.autoSnapshotPolicyId!
            }
            if self.burstingEnabled != nil {
                map["BurstingEnabled"] = self.burstingEnabled!
            }
            if self.categories != nil {
                map["Categories"] = self.categories!
            }
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.deleteWithInstance != nil {
                map["DeleteWithInstance"] = self.deleteWithInstance!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.device != nil {
                map["Device"] = self.device!
            }
            if self.diskName != nil {
                map["DiskName"] = self.diskName!
            }
            if self.encrypted != nil {
                map["Encrypted"] = self.encrypted!
            }
            if self.KMSKeyId != nil {
                map["KMSKeyId"] = self.KMSKeyId!
            }
            if self.performanceLevel != nil {
                map["PerformanceLevel"] = self.performanceLevel!
            }
            if self.provisionedIops != nil {
                map["ProvisionedIops"] = self.provisionedIops!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.snapshotId != nil {
                map["SnapshotId"] = self.snapshotId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AutoSnapshotPolicyId") && dict["AutoSnapshotPolicyId"] != nil {
                self.autoSnapshotPolicyId = dict["AutoSnapshotPolicyId"] as! String
            }
            if dict.keys.contains("BurstingEnabled") && dict["BurstingEnabled"] != nil {
                self.burstingEnabled = dict["BurstingEnabled"] as! Bool
            }
            if dict.keys.contains("Categories") && dict["Categories"] != nil {
                self.categories = dict["Categories"] as! [String]
            }
            if dict.keys.contains("Category") && dict["Category"] != nil {
                self.category = dict["Category"] as! String
            }
            if dict.keys.contains("DeleteWithInstance") && dict["DeleteWithInstance"] != nil {
                self.deleteWithInstance = dict["DeleteWithInstance"] as! Bool
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Device") && dict["Device"] != nil {
                self.device = dict["Device"] as! String
            }
            if dict.keys.contains("DiskName") && dict["DiskName"] != nil {
                self.diskName = dict["DiskName"] as! String
            }
            if dict.keys.contains("Encrypted") && dict["Encrypted"] != nil {
                self.encrypted = dict["Encrypted"] as! String
            }
            if dict.keys.contains("KMSKeyId") && dict["KMSKeyId"] != nil {
                self.KMSKeyId = dict["KMSKeyId"] as! String
            }
            if dict.keys.contains("PerformanceLevel") && dict["PerformanceLevel"] != nil {
                self.performanceLevel = dict["PerformanceLevel"] as! String
            }
            if dict.keys.contains("ProvisionedIops") && dict["ProvisionedIops"] != nil {
                self.provisionedIops = dict["ProvisionedIops"] as! Int64
            }
            if dict.keys.contains("Size") && dict["Size"] != nil {
                self.size = dict["Size"] as! Int32
            }
            if dict.keys.contains("SnapshotId") && dict["SnapshotId"] != nil {
                self.snapshotId = dict["SnapshotId"] as! String
            }
        }
    }
    public class InstancePatternInfos : Tea.TeaModel {
        public var architectures: [String]?

        public var burstablePerformance: String?

        public var cores: Int32?

        public var excludedInstanceTypes: [String]?

        public var instanceFamilyLevel: String?

        public var maxPrice: Double?

        public var memory: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.architectures != nil {
                map["Architectures"] = self.architectures!
            }
            if self.burstablePerformance != nil {
                map["BurstablePerformance"] = self.burstablePerformance!
            }
            if self.cores != nil {
                map["Cores"] = self.cores!
            }
            if self.excludedInstanceTypes != nil {
                map["ExcludedInstanceTypes"] = self.excludedInstanceTypes!
            }
            if self.instanceFamilyLevel != nil {
                map["InstanceFamilyLevel"] = self.instanceFamilyLevel!
            }
            if self.maxPrice != nil {
                map["MaxPrice"] = self.maxPrice!
            }
            if self.memory != nil {
                map["Memory"] = self.memory!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Architectures") && dict["Architectures"] != nil {
                self.architectures = dict["Architectures"] as! [String]
            }
            if dict.keys.contains("BurstablePerformance") && dict["BurstablePerformance"] != nil {
                self.burstablePerformance = dict["BurstablePerformance"] as! String
            }
            if dict.keys.contains("Cores") && dict["Cores"] != nil {
                self.cores = dict["Cores"] as! Int32
            }
            if dict.keys.contains("ExcludedInstanceTypes") && dict["ExcludedInstanceTypes"] != nil {
                self.excludedInstanceTypes = dict["ExcludedInstanceTypes"] as! [String]
            }
            if dict.keys.contains("InstanceFamilyLevel") && dict["InstanceFamilyLevel"] != nil {
                self.instanceFamilyLevel = dict["InstanceFamilyLevel"] as! String
            }
            if dict.keys.contains("MaxPrice") && dict["MaxPrice"] != nil {
                self.maxPrice = dict["MaxPrice"] as! Double
            }
            if dict.keys.contains("Memory") && dict["Memory"] != nil {
                self.memory = dict["Memory"] as! Double
            }
        }
    }
    public class InstanceTypeOverrides : Tea.TeaModel {
        public var instanceType: String?

        public var weightedCapacity: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.weightedCapacity != nil {
                map["WeightedCapacity"] = self.weightedCapacity!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceType") && dict["InstanceType"] != nil {
                self.instanceType = dict["InstanceType"] as! String
            }
            if dict.keys.contains("WeightedCapacity") && dict["WeightedCapacity"] != nil {
                self.weightedCapacity = dict["WeightedCapacity"] as! Int32
            }
        }
    }
    public class SpotPriceLimits : Tea.TeaModel {
        public var instanceType: String?

        public var priceLimit: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.priceLimit != nil {
                map["PriceLimit"] = self.priceLimit!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceType") && dict["InstanceType"] != nil {
                self.instanceType = dict["InstanceType"] as! String
            }
            if dict.keys.contains("PriceLimit") && dict["PriceLimit"] != nil {
                self.priceLimit = dict["PriceLimit"] as! Double
            }
        }
    }
    public var imageOptions: ModifyScalingConfigurationRequest.ImageOptions?

    public var privatePoolOptions: ModifyScalingConfigurationRequest.PrivatePoolOptions?

    public var systemDisk: ModifyScalingConfigurationRequest.SystemDisk?

    public var affinity: String?

    public var cpu: Int32?

    public var creditSpecification: String?

    public var customPriorities: [ModifyScalingConfigurationRequest.CustomPriorities]?

    public var dataDisks: [ModifyScalingConfigurationRequest.DataDisks]?

    public var dedicatedHostId: String?

    public var deletionProtection: Bool?

    public var deploymentSetId: String?

    public var hostName: String?

    public var hpcClusterId: String?

    public var imageFamily: String?

    public var imageId: String?

    public var imageName: String?

    public var instanceDescription: String?

    public var instanceName: String?

    public var instancePatternInfos: [ModifyScalingConfigurationRequest.InstancePatternInfos]?

    public var instanceTypeOverrides: [ModifyScalingConfigurationRequest.InstanceTypeOverrides]?

    public var instanceTypes: [String]?

    public var internetChargeType: String?

    public var internetMaxBandwidthOut: Int32?

    public var ioOptimized: String?

    public var ipv6AddressCount: Int32?

    public var keyPairName: String?

    public var loadBalancerWeight: Int32?

    public var memory: Int32?

    public var override_: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var passwordInherit: Bool?

    public var ramRoleName: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var scalingConfigurationId: String?

    public var scalingConfigurationName: String?

    public var schedulerOptions: [String: Any]?

    public var securityGroupId: String?

    public var securityGroupIds: [String]?

    public var spotDuration: Int32?

    public var spotInterruptionBehavior: String?

    public var spotPriceLimits: [ModifyScalingConfigurationRequest.SpotPriceLimits]?

    public var spotStrategy: String?

    public var storageSetId: String?

    public var storageSetPartitionNumber: Int32?

    public var systemDiskCategories: [String]?

    public var tags: String?

    public var tenancy: String?

    public var userData: String?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.imageOptions?.validate()
        try self.privatePoolOptions?.validate()
        try self.systemDisk?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imageOptions != nil {
            map["ImageOptions"] = self.imageOptions?.toMap()
        }
        if self.privatePoolOptions != nil {
            map["PrivatePoolOptions"] = self.privatePoolOptions?.toMap()
        }
        if self.systemDisk != nil {
            map["SystemDisk"] = self.systemDisk?.toMap()
        }
        if self.affinity != nil {
            map["Affinity"] = self.affinity!
        }
        if self.cpu != nil {
            map["Cpu"] = self.cpu!
        }
        if self.creditSpecification != nil {
            map["CreditSpecification"] = self.creditSpecification!
        }
        if self.customPriorities != nil {
            var tmp : [Any] = []
            for k in self.customPriorities! {
                tmp.append(k.toMap())
            }
            map["CustomPriorities"] = tmp
        }
        if self.dataDisks != nil {
            var tmp : [Any] = []
            for k in self.dataDisks! {
                tmp.append(k.toMap())
            }
            map["DataDisks"] = tmp
        }
        if self.dedicatedHostId != nil {
            map["DedicatedHostId"] = self.dedicatedHostId!
        }
        if self.deletionProtection != nil {
            map["DeletionProtection"] = self.deletionProtection!
        }
        if self.deploymentSetId != nil {
            map["DeploymentSetId"] = self.deploymentSetId!
        }
        if self.hostName != nil {
            map["HostName"] = self.hostName!
        }
        if self.hpcClusterId != nil {
            map["HpcClusterId"] = self.hpcClusterId!
        }
        if self.imageFamily != nil {
            map["ImageFamily"] = self.imageFamily!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.imageName != nil {
            map["ImageName"] = self.imageName!
        }
        if self.instanceDescription != nil {
            map["InstanceDescription"] = self.instanceDescription!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.instancePatternInfos != nil {
            var tmp : [Any] = []
            for k in self.instancePatternInfos! {
                tmp.append(k.toMap())
            }
            map["InstancePatternInfos"] = tmp
        }
        if self.instanceTypeOverrides != nil {
            var tmp : [Any] = []
            for k in self.instanceTypeOverrides! {
                tmp.append(k.toMap())
            }
            map["InstanceTypeOverrides"] = tmp
        }
        if self.instanceTypes != nil {
            map["InstanceTypes"] = self.instanceTypes!
        }
        if self.internetChargeType != nil {
            map["InternetChargeType"] = self.internetChargeType!
        }
        if self.internetMaxBandwidthOut != nil {
            map["InternetMaxBandwidthOut"] = self.internetMaxBandwidthOut!
        }
        if self.ioOptimized != nil {
            map["IoOptimized"] = self.ioOptimized!
        }
        if self.ipv6AddressCount != nil {
            map["Ipv6AddressCount"] = self.ipv6AddressCount!
        }
        if self.keyPairName != nil {
            map["KeyPairName"] = self.keyPairName!
        }
        if self.loadBalancerWeight != nil {
            map["LoadBalancerWeight"] = self.loadBalancerWeight!
        }
        if self.memory != nil {
            map["Memory"] = self.memory!
        }
        if self.override_ != nil {
            map["Override"] = self.override_!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.passwordInherit != nil {
            map["PasswordInherit"] = self.passwordInherit!
        }
        if self.ramRoleName != nil {
            map["RamRoleName"] = self.ramRoleName!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingConfigurationId != nil {
            map["ScalingConfigurationId"] = self.scalingConfigurationId!
        }
        if self.scalingConfigurationName != nil {
            map["ScalingConfigurationName"] = self.scalingConfigurationName!
        }
        if self.schedulerOptions != nil {
            map["SchedulerOptions"] = self.schedulerOptions!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.securityGroupIds != nil {
            map["SecurityGroupIds"] = self.securityGroupIds!
        }
        if self.spotDuration != nil {
            map["SpotDuration"] = self.spotDuration!
        }
        if self.spotInterruptionBehavior != nil {
            map["SpotInterruptionBehavior"] = self.spotInterruptionBehavior!
        }
        if self.spotPriceLimits != nil {
            var tmp : [Any] = []
            for k in self.spotPriceLimits! {
                tmp.append(k.toMap())
            }
            map["SpotPriceLimits"] = tmp
        }
        if self.spotStrategy != nil {
            map["SpotStrategy"] = self.spotStrategy!
        }
        if self.storageSetId != nil {
            map["StorageSetId"] = self.storageSetId!
        }
        if self.storageSetPartitionNumber != nil {
            map["StorageSetPartitionNumber"] = self.storageSetPartitionNumber!
        }
        if self.systemDiskCategories != nil {
            map["SystemDiskCategories"] = self.systemDiskCategories!
        }
        if self.tags != nil {
            map["Tags"] = self.tags!
        }
        if self.tenancy != nil {
            map["Tenancy"] = self.tenancy!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ImageOptions") && dict["ImageOptions"] != nil {
            var model = ModifyScalingConfigurationRequest.ImageOptions()
            model.fromMap(dict["ImageOptions"] as! [String: Any])
            self.imageOptions = model
        }
        if dict.keys.contains("PrivatePoolOptions") && dict["PrivatePoolOptions"] != nil {
            var model = ModifyScalingConfigurationRequest.PrivatePoolOptions()
            model.fromMap(dict["PrivatePoolOptions"] as! [String: Any])
            self.privatePoolOptions = model
        }
        if dict.keys.contains("SystemDisk") && dict["SystemDisk"] != nil {
            var model = ModifyScalingConfigurationRequest.SystemDisk()
            model.fromMap(dict["SystemDisk"] as! [String: Any])
            self.systemDisk = model
        }
        if dict.keys.contains("Affinity") && dict["Affinity"] != nil {
            self.affinity = dict["Affinity"] as! String
        }
        if dict.keys.contains("Cpu") && dict["Cpu"] != nil {
            self.cpu = dict["Cpu"] as! Int32
        }
        if dict.keys.contains("CreditSpecification") && dict["CreditSpecification"] != nil {
            self.creditSpecification = dict["CreditSpecification"] as! String
        }
        if dict.keys.contains("CustomPriorities") && dict["CustomPriorities"] != nil {
            var tmp : [ModifyScalingConfigurationRequest.CustomPriorities] = []
            for v in dict["CustomPriorities"] as! [Any] {
                var model = ModifyScalingConfigurationRequest.CustomPriorities()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.customPriorities = tmp
        }
        if dict.keys.contains("DataDisks") && dict["DataDisks"] != nil {
            var tmp : [ModifyScalingConfigurationRequest.DataDisks] = []
            for v in dict["DataDisks"] as! [Any] {
                var model = ModifyScalingConfigurationRequest.DataDisks()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.dataDisks = tmp
        }
        if dict.keys.contains("DedicatedHostId") && dict["DedicatedHostId"] != nil {
            self.dedicatedHostId = dict["DedicatedHostId"] as! String
        }
        if dict.keys.contains("DeletionProtection") && dict["DeletionProtection"] != nil {
            self.deletionProtection = dict["DeletionProtection"] as! Bool
        }
        if dict.keys.contains("DeploymentSetId") && dict["DeploymentSetId"] != nil {
            self.deploymentSetId = dict["DeploymentSetId"] as! String
        }
        if dict.keys.contains("HostName") && dict["HostName"] != nil {
            self.hostName = dict["HostName"] as! String
        }
        if dict.keys.contains("HpcClusterId") && dict["HpcClusterId"] != nil {
            self.hpcClusterId = dict["HpcClusterId"] as! String
        }
        if dict.keys.contains("ImageFamily") && dict["ImageFamily"] != nil {
            self.imageFamily = dict["ImageFamily"] as! String
        }
        if dict.keys.contains("ImageId") && dict["ImageId"] != nil {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("ImageName") && dict["ImageName"] != nil {
            self.imageName = dict["ImageName"] as! String
        }
        if dict.keys.contains("InstanceDescription") && dict["InstanceDescription"] != nil {
            self.instanceDescription = dict["InstanceDescription"] as! String
        }
        if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
            self.instanceName = dict["InstanceName"] as! String
        }
        if dict.keys.contains("InstancePatternInfos") && dict["InstancePatternInfos"] != nil {
            var tmp : [ModifyScalingConfigurationRequest.InstancePatternInfos] = []
            for v in dict["InstancePatternInfos"] as! [Any] {
                var model = ModifyScalingConfigurationRequest.InstancePatternInfos()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.instancePatternInfos = tmp
        }
        if dict.keys.contains("InstanceTypeOverrides") && dict["InstanceTypeOverrides"] != nil {
            var tmp : [ModifyScalingConfigurationRequest.InstanceTypeOverrides] = []
            for v in dict["InstanceTypeOverrides"] as! [Any] {
                var model = ModifyScalingConfigurationRequest.InstanceTypeOverrides()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.instanceTypeOverrides = tmp
        }
        if dict.keys.contains("InstanceTypes") && dict["InstanceTypes"] != nil {
            self.instanceTypes = dict["InstanceTypes"] as! [String]
        }
        if dict.keys.contains("InternetChargeType") && dict["InternetChargeType"] != nil {
            self.internetChargeType = dict["InternetChargeType"] as! String
        }
        if dict.keys.contains("InternetMaxBandwidthOut") && dict["InternetMaxBandwidthOut"] != nil {
            self.internetMaxBandwidthOut = dict["InternetMaxBandwidthOut"] as! Int32
        }
        if dict.keys.contains("IoOptimized") && dict["IoOptimized"] != nil {
            self.ioOptimized = dict["IoOptimized"] as! String
        }
        if dict.keys.contains("Ipv6AddressCount") && dict["Ipv6AddressCount"] != nil {
            self.ipv6AddressCount = dict["Ipv6AddressCount"] as! Int32
        }
        if dict.keys.contains("KeyPairName") && dict["KeyPairName"] != nil {
            self.keyPairName = dict["KeyPairName"] as! String
        }
        if dict.keys.contains("LoadBalancerWeight") && dict["LoadBalancerWeight"] != nil {
            self.loadBalancerWeight = dict["LoadBalancerWeight"] as! Int32
        }
        if dict.keys.contains("Memory") && dict["Memory"] != nil {
            self.memory = dict["Memory"] as! Int32
        }
        if dict.keys.contains("Override") && dict["Override"] != nil {
            self.override_ = dict["Override"] as! Bool
        }
        if dict.keys.contains("OwnerAccount") && dict["OwnerAccount"] != nil {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PasswordInherit") && dict["PasswordInherit"] != nil {
            self.passwordInherit = dict["PasswordInherit"] as! Bool
        }
        if dict.keys.contains("RamRoleName") && dict["RamRoleName"] != nil {
            self.ramRoleName = dict["RamRoleName"] as! String
        }
        if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScalingConfigurationId") && dict["ScalingConfigurationId"] != nil {
            self.scalingConfigurationId = dict["ScalingConfigurationId"] as! String
        }
        if dict.keys.contains("ScalingConfigurationName") && dict["ScalingConfigurationName"] != nil {
            self.scalingConfigurationName = dict["ScalingConfigurationName"] as! String
        }
        if dict.keys.contains("SchedulerOptions") && dict["SchedulerOptions"] != nil {
            self.schedulerOptions = dict["SchedulerOptions"] as! [String: Any]
        }
        if dict.keys.contains("SecurityGroupId") && dict["SecurityGroupId"] != nil {
            self.securityGroupId = dict["SecurityGroupId"] as! String
        }
        if dict.keys.contains("SecurityGroupIds") && dict["SecurityGroupIds"] != nil {
            self.securityGroupIds = dict["SecurityGroupIds"] as! [String]
        }
        if dict.keys.contains("SpotDuration") && dict["SpotDuration"] != nil {
            self.spotDuration = dict["SpotDuration"] as! Int32
        }
        if dict.keys.contains("SpotInterruptionBehavior") && dict["SpotInterruptionBehavior"] != nil {
            self.spotInterruptionBehavior = dict["SpotInterruptionBehavior"] as! String
        }
        if dict.keys.contains("SpotPriceLimits") && dict["SpotPriceLimits"] != nil {
            var tmp : [ModifyScalingConfigurationRequest.SpotPriceLimits] = []
            for v in dict["SpotPriceLimits"] as! [Any] {
                var model = ModifyScalingConfigurationRequest.SpotPriceLimits()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.spotPriceLimits = tmp
        }
        if dict.keys.contains("SpotStrategy") && dict["SpotStrategy"] != nil {
            self.spotStrategy = dict["SpotStrategy"] as! String
        }
        if dict.keys.contains("StorageSetId") && dict["StorageSetId"] != nil {
            self.storageSetId = dict["StorageSetId"] as! String
        }
        if dict.keys.contains("StorageSetPartitionNumber") && dict["StorageSetPartitionNumber"] != nil {
            self.storageSetPartitionNumber = dict["StorageSetPartitionNumber"] as! Int32
        }
        if dict.keys.contains("SystemDiskCategories") && dict["SystemDiskCategories"] != nil {
            self.systemDiskCategories = dict["SystemDiskCategories"] as! [String]
        }
        if dict.keys.contains("Tags") && dict["Tags"] != nil {
            self.tags = dict["Tags"] as! String
        }
        if dict.keys.contains("Tenancy") && dict["Tenancy"] != nil {
            self.tenancy = dict["Tenancy"] as! String
        }
        if dict.keys.contains("UserData") && dict["UserData"] != nil {
            self.userData = dict["UserData"] as! String
        }
        if dict.keys.contains("ZoneId") && dict["ZoneId"] != nil {
            self.zoneId = dict["ZoneId"] as! String
        }
    }
}

public class ModifyScalingConfigurationShrinkRequest : Tea.TeaModel {
    public class ImageOptions : Tea.TeaModel {
        public var loginAsNonRoot: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.loginAsNonRoot != nil {
                map["LoginAsNonRoot"] = self.loginAsNonRoot!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LoginAsNonRoot") && dict["LoginAsNonRoot"] != nil {
                self.loginAsNonRoot = dict["LoginAsNonRoot"] as! Bool
            }
        }
    }
    public class PrivatePoolOptions : Tea.TeaModel {
        public var id: String?

        public var matchCriteria: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.matchCriteria != nil {
                map["MatchCriteria"] = self.matchCriteria!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("MatchCriteria") && dict["MatchCriteria"] != nil {
                self.matchCriteria = dict["MatchCriteria"] as! String
            }
        }
    }
    public class SystemDisk : Tea.TeaModel {
        public var autoSnapshotPolicyId: String?

        public var burstingEnabled: Bool?

        public var category: String?

        public var description_: String?

        public var diskName: String?

        public var encryptAlgorithm: String?

        public var encrypted: Bool?

        public var KMSKeyId: String?

        public var performanceLevel: String?

        public var provisionedIops: Int64?

        public var size: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.autoSnapshotPolicyId != nil {
                map["AutoSnapshotPolicyId"] = self.autoSnapshotPolicyId!
            }
            if self.burstingEnabled != nil {
                map["BurstingEnabled"] = self.burstingEnabled!
            }
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.diskName != nil {
                map["DiskName"] = self.diskName!
            }
            if self.encryptAlgorithm != nil {
                map["EncryptAlgorithm"] = self.encryptAlgorithm!
            }
            if self.encrypted != nil {
                map["Encrypted"] = self.encrypted!
            }
            if self.KMSKeyId != nil {
                map["KMSKeyId"] = self.KMSKeyId!
            }
            if self.performanceLevel != nil {
                map["PerformanceLevel"] = self.performanceLevel!
            }
            if self.provisionedIops != nil {
                map["ProvisionedIops"] = self.provisionedIops!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AutoSnapshotPolicyId") && dict["AutoSnapshotPolicyId"] != nil {
                self.autoSnapshotPolicyId = dict["AutoSnapshotPolicyId"] as! String
            }
            if dict.keys.contains("BurstingEnabled") && dict["BurstingEnabled"] != nil {
                self.burstingEnabled = dict["BurstingEnabled"] as! Bool
            }
            if dict.keys.contains("Category") && dict["Category"] != nil {
                self.category = dict["Category"] as! String
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("DiskName") && dict["DiskName"] != nil {
                self.diskName = dict["DiskName"] as! String
            }
            if dict.keys.contains("EncryptAlgorithm") && dict["EncryptAlgorithm"] != nil {
                self.encryptAlgorithm = dict["EncryptAlgorithm"] as! String
            }
            if dict.keys.contains("Encrypted") && dict["Encrypted"] != nil {
                self.encrypted = dict["Encrypted"] as! Bool
            }
            if dict.keys.contains("KMSKeyId") && dict["KMSKeyId"] != nil {
                self.KMSKeyId = dict["KMSKeyId"] as! String
            }
            if dict.keys.contains("PerformanceLevel") && dict["PerformanceLevel"] != nil {
                self.performanceLevel = dict["PerformanceLevel"] as! String
            }
            if dict.keys.contains("ProvisionedIops") && dict["ProvisionedIops"] != nil {
                self.provisionedIops = dict["ProvisionedIops"] as! Int64
            }
            if dict.keys.contains("Size") && dict["Size"] != nil {
                self.size = dict["Size"] as! Int32
            }
        }
    }
    public class CustomPriorities : Tea.TeaModel {
        public var instanceType: String?

        public var vswitchId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.vswitchId != nil {
                map["VswitchId"] = self.vswitchId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceType") && dict["InstanceType"] != nil {
                self.instanceType = dict["InstanceType"] as! String
            }
            if dict.keys.contains("VswitchId") && dict["VswitchId"] != nil {
                self.vswitchId = dict["VswitchId"] as! String
            }
        }
    }
    public class DataDisks : Tea.TeaModel {
        public var autoSnapshotPolicyId: String?

        public var burstingEnabled: Bool?

        public var categories: [String]?

        public var category: String?

        public var deleteWithInstance: Bool?

        public var description_: String?

        public var device: String?

        public var diskName: String?

        public var encrypted: String?

        public var KMSKeyId: String?

        public var performanceLevel: String?

        public var provisionedIops: Int64?

        public var size: Int32?

        public var snapshotId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.autoSnapshotPolicyId != nil {
                map["AutoSnapshotPolicyId"] = self.autoSnapshotPolicyId!
            }
            if self.burstingEnabled != nil {
                map["BurstingEnabled"] = self.burstingEnabled!
            }
            if self.categories != nil {
                map["Categories"] = self.categories!
            }
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.deleteWithInstance != nil {
                map["DeleteWithInstance"] = self.deleteWithInstance!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.device != nil {
                map["Device"] = self.device!
            }
            if self.diskName != nil {
                map["DiskName"] = self.diskName!
            }
            if self.encrypted != nil {
                map["Encrypted"] = self.encrypted!
            }
            if self.KMSKeyId != nil {
                map["KMSKeyId"] = self.KMSKeyId!
            }
            if self.performanceLevel != nil {
                map["PerformanceLevel"] = self.performanceLevel!
            }
            if self.provisionedIops != nil {
                map["ProvisionedIops"] = self.provisionedIops!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.snapshotId != nil {
                map["SnapshotId"] = self.snapshotId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AutoSnapshotPolicyId") && dict["AutoSnapshotPolicyId"] != nil {
                self.autoSnapshotPolicyId = dict["AutoSnapshotPolicyId"] as! String
            }
            if dict.keys.contains("BurstingEnabled") && dict["BurstingEnabled"] != nil {
                self.burstingEnabled = dict["BurstingEnabled"] as! Bool
            }
            if dict.keys.contains("Categories") && dict["Categories"] != nil {
                self.categories = dict["Categories"] as! [String]
            }
            if dict.keys.contains("Category") && dict["Category"] != nil {
                self.category = dict["Category"] as! String
            }
            if dict.keys.contains("DeleteWithInstance") && dict["DeleteWithInstance"] != nil {
                self.deleteWithInstance = dict["DeleteWithInstance"] as! Bool
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Device") && dict["Device"] != nil {
                self.device = dict["Device"] as! String
            }
            if dict.keys.contains("DiskName") && dict["DiskName"] != nil {
                self.diskName = dict["DiskName"] as! String
            }
            if dict.keys.contains("Encrypted") && dict["Encrypted"] != nil {
                self.encrypted = dict["Encrypted"] as! String
            }
            if dict.keys.contains("KMSKeyId") && dict["KMSKeyId"] != nil {
                self.KMSKeyId = dict["KMSKeyId"] as! String
            }
            if dict.keys.contains("PerformanceLevel") && dict["PerformanceLevel"] != nil {
                self.performanceLevel = dict["PerformanceLevel"] as! String
            }
            if dict.keys.contains("ProvisionedIops") && dict["ProvisionedIops"] != nil {
                self.provisionedIops = dict["ProvisionedIops"] as! Int64
            }
            if dict.keys.contains("Size") && dict["Size"] != nil {
                self.size = dict["Size"] as! Int32
            }
            if dict.keys.contains("SnapshotId") && dict["SnapshotId"] != nil {
                self.snapshotId = dict["SnapshotId"] as! String
            }
        }
    }
    public class InstancePatternInfos : Tea.TeaModel {
        public var architectures: [String]?

        public var burstablePerformance: String?

        public var cores: Int32?

        public var excludedInstanceTypes: [String]?

        public var instanceFamilyLevel: String?

        public var maxPrice: Double?

        public var memory: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.architectures != nil {
                map["Architectures"] = self.architectures!
            }
            if self.burstablePerformance != nil {
                map["BurstablePerformance"] = self.burstablePerformance!
            }
            if self.cores != nil {
                map["Cores"] = self.cores!
            }
            if self.excludedInstanceTypes != nil {
                map["ExcludedInstanceTypes"] = self.excludedInstanceTypes!
            }
            if self.instanceFamilyLevel != nil {
                map["InstanceFamilyLevel"] = self.instanceFamilyLevel!
            }
            if self.maxPrice != nil {
                map["MaxPrice"] = self.maxPrice!
            }
            if self.memory != nil {
                map["Memory"] = self.memory!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Architectures") && dict["Architectures"] != nil {
                self.architectures = dict["Architectures"] as! [String]
            }
            if dict.keys.contains("BurstablePerformance") && dict["BurstablePerformance"] != nil {
                self.burstablePerformance = dict["BurstablePerformance"] as! String
            }
            if dict.keys.contains("Cores") && dict["Cores"] != nil {
                self.cores = dict["Cores"] as! Int32
            }
            if dict.keys.contains("ExcludedInstanceTypes") && dict["ExcludedInstanceTypes"] != nil {
                self.excludedInstanceTypes = dict["ExcludedInstanceTypes"] as! [String]
            }
            if dict.keys.contains("InstanceFamilyLevel") && dict["InstanceFamilyLevel"] != nil {
                self.instanceFamilyLevel = dict["InstanceFamilyLevel"] as! String
            }
            if dict.keys.contains("MaxPrice") && dict["MaxPrice"] != nil {
                self.maxPrice = dict["MaxPrice"] as! Double
            }
            if dict.keys.contains("Memory") && dict["Memory"] != nil {
                self.memory = dict["Memory"] as! Double
            }
        }
    }
    public class InstanceTypeOverrides : Tea.TeaModel {
        public var instanceType: String?

        public var weightedCapacity: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.weightedCapacity != nil {
                map["WeightedCapacity"] = self.weightedCapacity!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceType") && dict["InstanceType"] != nil {
                self.instanceType = dict["InstanceType"] as! String
            }
            if dict.keys.contains("WeightedCapacity") && dict["WeightedCapacity"] != nil {
                self.weightedCapacity = dict["WeightedCapacity"] as! Int32
            }
        }
    }
    public class SpotPriceLimits : Tea.TeaModel {
        public var instanceType: String?

        public var priceLimit: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.priceLimit != nil {
                map["PriceLimit"] = self.priceLimit!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceType") && dict["InstanceType"] != nil {
                self.instanceType = dict["InstanceType"] as! String
            }
            if dict.keys.contains("PriceLimit") && dict["PriceLimit"] != nil {
                self.priceLimit = dict["PriceLimit"] as! Double
            }
        }
    }
    public var imageOptions: ModifyScalingConfigurationShrinkRequest.ImageOptions?

    public var privatePoolOptions: ModifyScalingConfigurationShrinkRequest.PrivatePoolOptions?

    public var systemDisk: ModifyScalingConfigurationShrinkRequest.SystemDisk?

    public var affinity: String?

    public var cpu: Int32?

    public var creditSpecification: String?

    public var customPriorities: [ModifyScalingConfigurationShrinkRequest.CustomPriorities]?

    public var dataDisks: [ModifyScalingConfigurationShrinkRequest.DataDisks]?

    public var dedicatedHostId: String?

    public var deletionProtection: Bool?

    public var deploymentSetId: String?

    public var hostName: String?

    public var hpcClusterId: String?

    public var imageFamily: String?

    public var imageId: String?

    public var imageName: String?

    public var instanceDescription: String?

    public var instanceName: String?

    public var instancePatternInfos: [ModifyScalingConfigurationShrinkRequest.InstancePatternInfos]?

    public var instanceTypeOverrides: [ModifyScalingConfigurationShrinkRequest.InstanceTypeOverrides]?

    public var instanceTypes: [String]?

    public var internetChargeType: String?

    public var internetMaxBandwidthOut: Int32?

    public var ioOptimized: String?

    public var ipv6AddressCount: Int32?

    public var keyPairName: String?

    public var loadBalancerWeight: Int32?

    public var memory: Int32?

    public var override_: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var passwordInherit: Bool?

    public var ramRoleName: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var scalingConfigurationId: String?

    public var scalingConfigurationName: String?

    public var schedulerOptionsShrink: String?

    public var securityGroupId: String?

    public var securityGroupIds: [String]?

    public var spotDuration: Int32?

    public var spotInterruptionBehavior: String?

    public var spotPriceLimits: [ModifyScalingConfigurationShrinkRequest.SpotPriceLimits]?

    public var spotStrategy: String?

    public var storageSetId: String?

    public var storageSetPartitionNumber: Int32?

    public var systemDiskCategories: [String]?

    public var tags: String?

    public var tenancy: String?

    public var userData: String?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.imageOptions?.validate()
        try self.privatePoolOptions?.validate()
        try self.systemDisk?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imageOptions != nil {
            map["ImageOptions"] = self.imageOptions?.toMap()
        }
        if self.privatePoolOptions != nil {
            map["PrivatePoolOptions"] = self.privatePoolOptions?.toMap()
        }
        if self.systemDisk != nil {
            map["SystemDisk"] = self.systemDisk?.toMap()
        }
        if self.affinity != nil {
            map["Affinity"] = self.affinity!
        }
        if self.cpu != nil {
            map["Cpu"] = self.cpu!
        }
        if self.creditSpecification != nil {
            map["CreditSpecification"] = self.creditSpecification!
        }
        if self.customPriorities != nil {
            var tmp : [Any] = []
            for k in self.customPriorities! {
                tmp.append(k.toMap())
            }
            map["CustomPriorities"] = tmp
        }
        if self.dataDisks != nil {
            var tmp : [Any] = []
            for k in self.dataDisks! {
                tmp.append(k.toMap())
            }
            map["DataDisks"] = tmp
        }
        if self.dedicatedHostId != nil {
            map["DedicatedHostId"] = self.dedicatedHostId!
        }
        if self.deletionProtection != nil {
            map["DeletionProtection"] = self.deletionProtection!
        }
        if self.deploymentSetId != nil {
            map["DeploymentSetId"] = self.deploymentSetId!
        }
        if self.hostName != nil {
            map["HostName"] = self.hostName!
        }
        if self.hpcClusterId != nil {
            map["HpcClusterId"] = self.hpcClusterId!
        }
        if self.imageFamily != nil {
            map["ImageFamily"] = self.imageFamily!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.imageName != nil {
            map["ImageName"] = self.imageName!
        }
        if self.instanceDescription != nil {
            map["InstanceDescription"] = self.instanceDescription!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.instancePatternInfos != nil {
            var tmp : [Any] = []
            for k in self.instancePatternInfos! {
                tmp.append(k.toMap())
            }
            map["InstancePatternInfos"] = tmp
        }
        if self.instanceTypeOverrides != nil {
            var tmp : [Any] = []
            for k in self.instanceTypeOverrides! {
                tmp.append(k.toMap())
            }
            map["InstanceTypeOverrides"] = tmp
        }
        if self.instanceTypes != nil {
            map["InstanceTypes"] = self.instanceTypes!
        }
        if self.internetChargeType != nil {
            map["InternetChargeType"] = self.internetChargeType!
        }
        if self.internetMaxBandwidthOut != nil {
            map["InternetMaxBandwidthOut"] = self.internetMaxBandwidthOut!
        }
        if self.ioOptimized != nil {
            map["IoOptimized"] = self.ioOptimized!
        }
        if self.ipv6AddressCount != nil {
            map["Ipv6AddressCount"] = self.ipv6AddressCount!
        }
        if self.keyPairName != nil {
            map["KeyPairName"] = self.keyPairName!
        }
        if self.loadBalancerWeight != nil {
            map["LoadBalancerWeight"] = self.loadBalancerWeight!
        }
        if self.memory != nil {
            map["Memory"] = self.memory!
        }
        if self.override_ != nil {
            map["Override"] = self.override_!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.passwordInherit != nil {
            map["PasswordInherit"] = self.passwordInherit!
        }
        if self.ramRoleName != nil {
            map["RamRoleName"] = self.ramRoleName!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingConfigurationId != nil {
            map["ScalingConfigurationId"] = self.scalingConfigurationId!
        }
        if self.scalingConfigurationName != nil {
            map["ScalingConfigurationName"] = self.scalingConfigurationName!
        }
        if self.schedulerOptionsShrink != nil {
            map["SchedulerOptions"] = self.schedulerOptionsShrink!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.securityGroupIds != nil {
            map["SecurityGroupIds"] = self.securityGroupIds!
        }
        if self.spotDuration != nil {
            map["SpotDuration"] = self.spotDuration!
        }
        if self.spotInterruptionBehavior != nil {
            map["SpotInterruptionBehavior"] = self.spotInterruptionBehavior!
        }
        if self.spotPriceLimits != nil {
            var tmp : [Any] = []
            for k in self.spotPriceLimits! {
                tmp.append(k.toMap())
            }
            map["SpotPriceLimits"] = tmp
        }
        if self.spotStrategy != nil {
            map["SpotStrategy"] = self.spotStrategy!
        }
        if self.storageSetId != nil {
            map["StorageSetId"] = self.storageSetId!
        }
        if self.storageSetPartitionNumber != nil {
            map["StorageSetPartitionNumber"] = self.storageSetPartitionNumber!
        }
        if self.systemDiskCategories != nil {
            map["SystemDiskCategories"] = self.systemDiskCategories!
        }
        if self.tags != nil {
            map["Tags"] = self.tags!
        }
        if self.tenancy != nil {
            map["Tenancy"] = self.tenancy!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ImageOptions") && dict["ImageOptions"] != nil {
            var model = ModifyScalingConfigurationShrinkRequest.ImageOptions()
            model.fromMap(dict["ImageOptions"] as! [String: Any])
            self.imageOptions = model
        }
        if dict.keys.contains("PrivatePoolOptions") && dict["PrivatePoolOptions"] != nil {
            var model = ModifyScalingConfigurationShrinkRequest.PrivatePoolOptions()
            model.fromMap(dict["PrivatePoolOptions"] as! [String: Any])
            self.privatePoolOptions = model
        }
        if dict.keys.contains("SystemDisk") && dict["SystemDisk"] != nil {
            var model = ModifyScalingConfigurationShrinkRequest.SystemDisk()
            model.fromMap(dict["SystemDisk"] as! [String: Any])
            self.systemDisk = model
        }
        if dict.keys.contains("Affinity") && dict["Affinity"] != nil {
            self.affinity = dict["Affinity"] as! String
        }
        if dict.keys.contains("Cpu") && dict["Cpu"] != nil {
            self.cpu = dict["Cpu"] as! Int32
        }
        if dict.keys.contains("CreditSpecification") && dict["CreditSpecification"] != nil {
            self.creditSpecification = dict["CreditSpecification"] as! String
        }
        if dict.keys.contains("CustomPriorities") && dict["CustomPriorities"] != nil {
            var tmp : [ModifyScalingConfigurationShrinkRequest.CustomPriorities] = []
            for v in dict["CustomPriorities"] as! [Any] {
                var model = ModifyScalingConfigurationShrinkRequest.CustomPriorities()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.customPriorities = tmp
        }
        if dict.keys.contains("DataDisks") && dict["DataDisks"] != nil {
            var tmp : [ModifyScalingConfigurationShrinkRequest.DataDisks] = []
            for v in dict["DataDisks"] as! [Any] {
                var model = ModifyScalingConfigurationShrinkRequest.DataDisks()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.dataDisks = tmp
        }
        if dict.keys.contains("DedicatedHostId") && dict["DedicatedHostId"] != nil {
            self.dedicatedHostId = dict["DedicatedHostId"] as! String
        }
        if dict.keys.contains("DeletionProtection") && dict["DeletionProtection"] != nil {
            self.deletionProtection = dict["DeletionProtection"] as! Bool
        }
        if dict.keys.contains("DeploymentSetId") && dict["DeploymentSetId"] != nil {
            self.deploymentSetId = dict["DeploymentSetId"] as! String
        }
        if dict.keys.contains("HostName") && dict["HostName"] != nil {
            self.hostName = dict["HostName"] as! String
        }
        if dict.keys.contains("HpcClusterId") && dict["HpcClusterId"] != nil {
            self.hpcClusterId = dict["HpcClusterId"] as! String
        }
        if dict.keys.contains("ImageFamily") && dict["ImageFamily"] != nil {
            self.imageFamily = dict["ImageFamily"] as! String
        }
        if dict.keys.contains("ImageId") && dict["ImageId"] != nil {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("ImageName") && dict["ImageName"] != nil {
            self.imageName = dict["ImageName"] as! String
        }
        if dict.keys.contains("InstanceDescription") && dict["InstanceDescription"] != nil {
            self.instanceDescription = dict["InstanceDescription"] as! String
        }
        if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
            self.instanceName = dict["InstanceName"] as! String
        }
        if dict.keys.contains("InstancePatternInfos") && dict["InstancePatternInfos"] != nil {
            var tmp : [ModifyScalingConfigurationShrinkRequest.InstancePatternInfos] = []
            for v in dict["InstancePatternInfos"] as! [Any] {
                var model = ModifyScalingConfigurationShrinkRequest.InstancePatternInfos()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.instancePatternInfos = tmp
        }
        if dict.keys.contains("InstanceTypeOverrides") && dict["InstanceTypeOverrides"] != nil {
            var tmp : [ModifyScalingConfigurationShrinkRequest.InstanceTypeOverrides] = []
            for v in dict["InstanceTypeOverrides"] as! [Any] {
                var model = ModifyScalingConfigurationShrinkRequest.InstanceTypeOverrides()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.instanceTypeOverrides = tmp
        }
        if dict.keys.contains("InstanceTypes") && dict["InstanceTypes"] != nil {
            self.instanceTypes = dict["InstanceTypes"] as! [String]
        }
        if dict.keys.contains("InternetChargeType") && dict["InternetChargeType"] != nil {
            self.internetChargeType = dict["InternetChargeType"] as! String
        }
        if dict.keys.contains("InternetMaxBandwidthOut") && dict["InternetMaxBandwidthOut"] != nil {
            self.internetMaxBandwidthOut = dict["InternetMaxBandwidthOut"] as! Int32
        }
        if dict.keys.contains("IoOptimized") && dict["IoOptimized"] != nil {
            self.ioOptimized = dict["IoOptimized"] as! String
        }
        if dict.keys.contains("Ipv6AddressCount") && dict["Ipv6AddressCount"] != nil {
            self.ipv6AddressCount = dict["Ipv6AddressCount"] as! Int32
        }
        if dict.keys.contains("KeyPairName") && dict["KeyPairName"] != nil {
            self.keyPairName = dict["KeyPairName"] as! String
        }
        if dict.keys.contains("LoadBalancerWeight") && dict["LoadBalancerWeight"] != nil {
            self.loadBalancerWeight = dict["LoadBalancerWeight"] as! Int32
        }
        if dict.keys.contains("Memory") && dict["Memory"] != nil {
            self.memory = dict["Memory"] as! Int32
        }
        if dict.keys.contains("Override") && dict["Override"] != nil {
            self.override_ = dict["Override"] as! Bool
        }
        if dict.keys.contains("OwnerAccount") && dict["OwnerAccount"] != nil {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PasswordInherit") && dict["PasswordInherit"] != nil {
            self.passwordInherit = dict["PasswordInherit"] as! Bool
        }
        if dict.keys.contains("RamRoleName") && dict["RamRoleName"] != nil {
            self.ramRoleName = dict["RamRoleName"] as! String
        }
        if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScalingConfigurationId") && dict["ScalingConfigurationId"] != nil {
            self.scalingConfigurationId = dict["ScalingConfigurationId"] as! String
        }
        if dict.keys.contains("ScalingConfigurationName") && dict["ScalingConfigurationName"] != nil {
            self.scalingConfigurationName = dict["ScalingConfigurationName"] as! String
        }
        if dict.keys.contains("SchedulerOptions") && dict["SchedulerOptions"] != nil {
            self.schedulerOptionsShrink = dict["SchedulerOptions"] as! String
        }
        if dict.keys.contains("SecurityGroupId") && dict["SecurityGroupId"] != nil {
            self.securityGroupId = dict["SecurityGroupId"] as! String
        }
        if dict.keys.contains("SecurityGroupIds") && dict["SecurityGroupIds"] != nil {
            self.securityGroupIds = dict["SecurityGroupIds"] as! [String]
        }
        if dict.keys.contains("SpotDuration") && dict["SpotDuration"] != nil {
            self.spotDuration = dict["SpotDuration"] as! Int32
        }
        if dict.keys.contains("SpotInterruptionBehavior") && dict["SpotInterruptionBehavior"] != nil {
            self.spotInterruptionBehavior = dict["SpotInterruptionBehavior"] as! String
        }
        if dict.keys.contains("SpotPriceLimits") && dict["SpotPriceLimits"] != nil {
            var tmp : [ModifyScalingConfigurationShrinkRequest.SpotPriceLimits] = []
            for v in dict["SpotPriceLimits"] as! [Any] {
                var model = ModifyScalingConfigurationShrinkRequest.SpotPriceLimits()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.spotPriceLimits = tmp
        }
        if dict.keys.contains("SpotStrategy") && dict["SpotStrategy"] != nil {
            self.spotStrategy = dict["SpotStrategy"] as! String
        }
        if dict.keys.contains("StorageSetId") && dict["StorageSetId"] != nil {
            self.storageSetId = dict["StorageSetId"] as! String
        }
        if dict.keys.contains("StorageSetPartitionNumber") && dict["StorageSetPartitionNumber"] != nil {
            self.storageSetPartitionNumber = dict["StorageSetPartitionNumber"] as! Int32
        }
        if dict.keys.contains("SystemDiskCategories") && dict["SystemDiskCategories"] != nil {
            self.systemDiskCategories = dict["SystemDiskCategories"] as! [String]
        }
        if dict.keys.contains("Tags") && dict["Tags"] != nil {
            self.tags = dict["Tags"] as! String
        }
        if dict.keys.contains("Tenancy") && dict["Tenancy"] != nil {
            self.tenancy = dict["Tenancy"] as! String
        }
        if dict.keys.contains("UserData") && dict["UserData"] != nil {
            self.userData = dict["UserData"] as! String
        }
        if dict.keys.contains("ZoneId") && dict["ZoneId"] != nil {
            self.zoneId = dict["ZoneId"] as! String
        }
    }
}

public class ModifyScalingConfigurationResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyScalingConfigurationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyScalingConfigurationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyScalingConfigurationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyScalingGroupRequest : Tea.TeaModel {
    public class LaunchTemplateOverrides : Tea.TeaModel {
        public var instanceType: String?

        public var spotPriceLimit: Double?

        public var weightedCapacity: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.spotPriceLimit != nil {
                map["SpotPriceLimit"] = self.spotPriceLimit!
            }
            if self.weightedCapacity != nil {
                map["WeightedCapacity"] = self.weightedCapacity!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceType") && dict["InstanceType"] != nil {
                self.instanceType = dict["InstanceType"] as! String
            }
            if dict.keys.contains("SpotPriceLimit") && dict["SpotPriceLimit"] != nil {
                self.spotPriceLimit = dict["SpotPriceLimit"] as! Double
            }
            if dict.keys.contains("WeightedCapacity") && dict["WeightedCapacity"] != nil {
                self.weightedCapacity = dict["WeightedCapacity"] as! Int32
            }
        }
    }
    public var activeScalingConfigurationId: String?

    public var allocationStrategy: String?

    public var azBalance: Bool?

    public var compensateWithOnDemand: Bool?

    public var customPolicyARN: String?

    public var defaultCooldown: Int32?

    public var desiredCapacity: Int32?

    public var disableDesiredCapacity: Bool?

    public var groupDeletionProtection: Bool?

    public var healthCheckType: String?

    public var healthCheckTypes: [String]?

    public var launchTemplateId: String?

    public var launchTemplateOverrides: [ModifyScalingGroupRequest.LaunchTemplateOverrides]?

    public var launchTemplateVersion: String?

    public var maxInstanceLifetime: Int32?

    public var maxSize: Int32?

    public var minSize: Int32?

    public var multiAZPolicy: String?

    public var onDemandBaseCapacity: Int32?

    public var onDemandPercentageAboveBaseCapacity: Int32?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var removalPolicies: [String]?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var scalingGroupId: String?

    public var scalingGroupName: String?

    public var scalingPolicy: String?

    public var spotAllocationStrategy: String?

    public var spotInstancePools: Int32?

    public var spotInstanceRemedy: Bool?

    public var vSwitchIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.activeScalingConfigurationId != nil {
            map["ActiveScalingConfigurationId"] = self.activeScalingConfigurationId!
        }
        if self.allocationStrategy != nil {
            map["AllocationStrategy"] = self.allocationStrategy!
        }
        if self.azBalance != nil {
            map["AzBalance"] = self.azBalance!
        }
        if self.compensateWithOnDemand != nil {
            map["CompensateWithOnDemand"] = self.compensateWithOnDemand!
        }
        if self.customPolicyARN != nil {
            map["CustomPolicyARN"] = self.customPolicyARN!
        }
        if self.defaultCooldown != nil {
            map["DefaultCooldown"] = self.defaultCooldown!
        }
        if self.desiredCapacity != nil {
            map["DesiredCapacity"] = self.desiredCapacity!
        }
        if self.disableDesiredCapacity != nil {
            map["DisableDesiredCapacity"] = self.disableDesiredCapacity!
        }
        if self.groupDeletionProtection != nil {
            map["GroupDeletionProtection"] = self.groupDeletionProtection!
        }
        if self.healthCheckType != nil {
            map["HealthCheckType"] = self.healthCheckType!
        }
        if self.healthCheckTypes != nil {
            map["HealthCheckTypes"] = self.healthCheckTypes!
        }
        if self.launchTemplateId != nil {
            map["LaunchTemplateId"] = self.launchTemplateId!
        }
        if self.launchTemplateOverrides != nil {
            var tmp : [Any] = []
            for k in self.launchTemplateOverrides! {
                tmp.append(k.toMap())
            }
            map["LaunchTemplateOverrides"] = tmp
        }
        if self.launchTemplateVersion != nil {
            map["LaunchTemplateVersion"] = self.launchTemplateVersion!
        }
        if self.maxInstanceLifetime != nil {
            map["MaxInstanceLifetime"] = self.maxInstanceLifetime!
        }
        if self.maxSize != nil {
            map["MaxSize"] = self.maxSize!
        }
        if self.minSize != nil {
            map["MinSize"] = self.minSize!
        }
        if self.multiAZPolicy != nil {
            map["MultiAZPolicy"] = self.multiAZPolicy!
        }
        if self.onDemandBaseCapacity != nil {
            map["OnDemandBaseCapacity"] = self.onDemandBaseCapacity!
        }
        if self.onDemandPercentageAboveBaseCapacity != nil {
            map["OnDemandPercentageAboveBaseCapacity"] = self.onDemandPercentageAboveBaseCapacity!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.removalPolicies != nil {
            map["RemovalPolicies"] = self.removalPolicies!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        if self.scalingGroupName != nil {
            map["ScalingGroupName"] = self.scalingGroupName!
        }
        if self.scalingPolicy != nil {
            map["ScalingPolicy"] = self.scalingPolicy!
        }
        if self.spotAllocationStrategy != nil {
            map["SpotAllocationStrategy"] = self.spotAllocationStrategy!
        }
        if self.spotInstancePools != nil {
            map["SpotInstancePools"] = self.spotInstancePools!
        }
        if self.spotInstanceRemedy != nil {
            map["SpotInstanceRemedy"] = self.spotInstanceRemedy!
        }
        if self.vSwitchIds != nil {
            map["VSwitchIds"] = self.vSwitchIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ActiveScalingConfigurationId") && dict["ActiveScalingConfigurationId"] != nil {
            self.activeScalingConfigurationId = dict["ActiveScalingConfigurationId"] as! String
        }
        if dict.keys.contains("AllocationStrategy") && dict["AllocationStrategy"] != nil {
            self.allocationStrategy = dict["AllocationStrategy"] as! String
        }
        if dict.keys.contains("AzBalance") && dict["AzBalance"] != nil {
            self.azBalance = dict["AzBalance"] as! Bool
        }
        if dict.keys.contains("CompensateWithOnDemand") && dict["CompensateWithOnDemand"] != nil {
            self.compensateWithOnDemand = dict["CompensateWithOnDemand"] as! Bool
        }
        if dict.keys.contains("CustomPolicyARN") && dict["CustomPolicyARN"] != nil {
            self.customPolicyARN = dict["CustomPolicyARN"] as! String
        }
        if dict.keys.contains("DefaultCooldown") && dict["DefaultCooldown"] != nil {
            self.defaultCooldown = dict["DefaultCooldown"] as! Int32
        }
        if dict.keys.contains("DesiredCapacity") && dict["DesiredCapacity"] != nil {
            self.desiredCapacity = dict["DesiredCapacity"] as! Int32
        }
        if dict.keys.contains("DisableDesiredCapacity") && dict["DisableDesiredCapacity"] != nil {
            self.disableDesiredCapacity = dict["DisableDesiredCapacity"] as! Bool
        }
        if dict.keys.contains("GroupDeletionProtection") && dict["GroupDeletionProtection"] != nil {
            self.groupDeletionProtection = dict["GroupDeletionProtection"] as! Bool
        }
        if dict.keys.contains("HealthCheckType") && dict["HealthCheckType"] != nil {
            self.healthCheckType = dict["HealthCheckType"] as! String
        }
        if dict.keys.contains("HealthCheckTypes") && dict["HealthCheckTypes"] != nil {
            self.healthCheckTypes = dict["HealthCheckTypes"] as! [String]
        }
        if dict.keys.contains("LaunchTemplateId") && dict["LaunchTemplateId"] != nil {
            self.launchTemplateId = dict["LaunchTemplateId"] as! String
        }
        if dict.keys.contains("LaunchTemplateOverrides") && dict["LaunchTemplateOverrides"] != nil {
            var tmp : [ModifyScalingGroupRequest.LaunchTemplateOverrides] = []
            for v in dict["LaunchTemplateOverrides"] as! [Any] {
                var model = ModifyScalingGroupRequest.LaunchTemplateOverrides()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.launchTemplateOverrides = tmp
        }
        if dict.keys.contains("LaunchTemplateVersion") && dict["LaunchTemplateVersion"] != nil {
            self.launchTemplateVersion = dict["LaunchTemplateVersion"] as! String
        }
        if dict.keys.contains("MaxInstanceLifetime") && dict["MaxInstanceLifetime"] != nil {
            self.maxInstanceLifetime = dict["MaxInstanceLifetime"] as! Int32
        }
        if dict.keys.contains("MaxSize") && dict["MaxSize"] != nil {
            self.maxSize = dict["MaxSize"] as! Int32
        }
        if dict.keys.contains("MinSize") && dict["MinSize"] != nil {
            self.minSize = dict["MinSize"] as! Int32
        }
        if dict.keys.contains("MultiAZPolicy") && dict["MultiAZPolicy"] != nil {
            self.multiAZPolicy = dict["MultiAZPolicy"] as! String
        }
        if dict.keys.contains("OnDemandBaseCapacity") && dict["OnDemandBaseCapacity"] != nil {
            self.onDemandBaseCapacity = dict["OnDemandBaseCapacity"] as! Int32
        }
        if dict.keys.contains("OnDemandPercentageAboveBaseCapacity") && dict["OnDemandPercentageAboveBaseCapacity"] != nil {
            self.onDemandPercentageAboveBaseCapacity = dict["OnDemandPercentageAboveBaseCapacity"] as! Int32
        }
        if dict.keys.contains("OwnerAccount") && dict["OwnerAccount"] != nil {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RemovalPolicies") && dict["RemovalPolicies"] != nil {
            self.removalPolicies = dict["RemovalPolicies"] as! [String]
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ScalingGroupId") && dict["ScalingGroupId"] != nil {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
        if dict.keys.contains("ScalingGroupName") && dict["ScalingGroupName"] != nil {
            self.scalingGroupName = dict["ScalingGroupName"] as! String
        }
        if dict.keys.contains("ScalingPolicy") && dict["ScalingPolicy"] != nil {
            self.scalingPolicy = dict["ScalingPolicy"] as! String
        }
        if dict.keys.contains("SpotAllocationStrategy") && dict["SpotAllocationStrategy"] != nil {
            self.spotAllocationStrategy = dict["SpotAllocationStrategy"] as! String
        }
        if dict.keys.contains("SpotInstancePools") && dict["SpotInstancePools"] != nil {
            self.spotInstancePools = dict["SpotInstancePools"] as! Int32
        }
        if dict.keys.contains("SpotInstanceRemedy") && dict["SpotInstanceRemedy"] != nil {
            self.spotInstanceRemedy = dict["SpotInstanceRemedy"] as! Bool
        }
        if dict.keys.contains("VSwitchIds") && dict["VSwitchIds"] != nil {
            self.vSwitchIds = dict["VSwitchIds"] as! [String]
        }
    }
}

public class ModifyScalingGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyScalingGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyScalingGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyScalingGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyScalingRuleRequest : Tea.TeaModel {
    public class AlarmDimensions : Tea.TeaModel {
        public var dimensionKey: String?

        public var dimensionValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dimensionKey != nil {
                map["DimensionKey"] = self.dimensionKey!
            }
            if self.dimensionValue != nil {
                map["DimensionValue"] = self.dimensionValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DimensionKey") && dict["DimensionKey"] != nil {
                self.dimensionKey = dict["DimensionKey"] as! String
            }
            if dict.keys.contains("DimensionValue") && dict["DimensionValue"] != nil {
                self.dimensionValue = dict["DimensionValue"] as! String
            }
        }
    }
    public class StepAdjustments : Tea.TeaModel {
        public var metricIntervalLowerBound: Double?

        public var metricIntervalUpperBound: Double?

        public var scalingAdjustment: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.metricIntervalLowerBound != nil {
                map["MetricIntervalLowerBound"] = self.metricIntervalLowerBound!
            }
            if self.metricIntervalUpperBound != nil {
                map["MetricIntervalUpperBound"] = self.metricIntervalUpperBound!
            }
            if self.scalingAdjustment != nil {
                map["ScalingAdjustment"] = self.scalingAdjustment!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MetricIntervalLowerBound") && dict["MetricIntervalLowerBound"] != nil {
                self.metricIntervalLowerBound = dict["MetricIntervalLowerBound"] as! Double
            }
            if dict.keys.contains("MetricIntervalUpperBound") && dict["MetricIntervalUpperBound"] != nil {
                self.metricIntervalUpperBound = dict["MetricIntervalUpperBound"] as! Double
            }
            if dict.keys.contains("ScalingAdjustment") && dict["ScalingAdjustment"] != nil {
                self.scalingAdjustment = dict["ScalingAdjustment"] as! Int32
            }
        }
    }
    public var adjustmentType: String?

    public var adjustmentValue: Int32?

    public var alarmDimensions: [ModifyScalingRuleRequest.AlarmDimensions]?

    public var cooldown: Int32?

    public var disableScaleIn: Bool?

    public var estimatedInstanceWarmup: Int32?

    public var initialMaxSize: Int32?

    public var metricName: String?

    public var minAdjustmentMagnitude: Int32?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var predictiveScalingMode: String?

    public var predictiveTaskBufferTime: Int32?

    public var predictiveValueBehavior: String?

    public var predictiveValueBuffer: Int32?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var scaleInEvaluationCount: Int32?

    public var scaleOutEvaluationCount: Int32?

    public var scalingRuleId: String?

    public var scalingRuleName: String?

    public var stepAdjustments: [ModifyScalingRuleRequest.StepAdjustments]?

    public var targetValue: Double?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.adjustmentType != nil {
            map["AdjustmentType"] = self.adjustmentType!
        }
        if self.adjustmentValue != nil {
            map["AdjustmentValue"] = self.adjustmentValue!
        }
        if self.alarmDimensions != nil {
            var tmp : [Any] = []
            for k in self.alarmDimensions! {
                tmp.append(k.toMap())
            }
            map["AlarmDimensions"] = tmp
        }
        if self.cooldown != nil {
            map["Cooldown"] = self.cooldown!
        }
        if self.disableScaleIn != nil {
            map["DisableScaleIn"] = self.disableScaleIn!
        }
        if self.estimatedInstanceWarmup != nil {
            map["EstimatedInstanceWarmup"] = self.estimatedInstanceWarmup!
        }
        if self.initialMaxSize != nil {
            map["InitialMaxSize"] = self.initialMaxSize!
        }
        if self.metricName != nil {
            map["MetricName"] = self.metricName!
        }
        if self.minAdjustmentMagnitude != nil {
            map["MinAdjustmentMagnitude"] = self.minAdjustmentMagnitude!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.predictiveScalingMode != nil {
            map["PredictiveScalingMode"] = self.predictiveScalingMode!
        }
        if self.predictiveTaskBufferTime != nil {
            map["PredictiveTaskBufferTime"] = self.predictiveTaskBufferTime!
        }
        if self.predictiveValueBehavior != nil {
            map["PredictiveValueBehavior"] = self.predictiveValueBehavior!
        }
        if self.predictiveValueBuffer != nil {
            map["PredictiveValueBuffer"] = self.predictiveValueBuffer!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.scaleInEvaluationCount != nil {
            map["ScaleInEvaluationCount"] = self.scaleInEvaluationCount!
        }
        if self.scaleOutEvaluationCount != nil {
            map["ScaleOutEvaluationCount"] = self.scaleOutEvaluationCount!
        }
        if self.scalingRuleId != nil {
            map["ScalingRuleId"] = self.scalingRuleId!
        }
        if self.scalingRuleName != nil {
            map["ScalingRuleName"] = self.scalingRuleName!
        }
        if self.stepAdjustments != nil {
            var tmp : [Any] = []
            for k in self.stepAdjustments! {
                tmp.append(k.toMap())
            }
            map["StepAdjustments"] = tmp
        }
        if self.targetValue != nil {
            map["TargetValue"] = self.targetValue!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AdjustmentType") && dict["AdjustmentType"] != nil {
            self.adjustmentType = dict["AdjustmentType"] as! String
        }
        if dict.keys.contains("AdjustmentValue") && dict["AdjustmentValue"] != nil {
            self.adjustmentValue = dict["AdjustmentValue"] as! Int32
        }
        if dict.keys.contains("AlarmDimensions") && dict["AlarmDimensions"] != nil {
            var tmp : [ModifyScalingRuleRequest.AlarmDimensions] = []
            for v in dict["AlarmDimensions"] as! [Any] {
                var model = ModifyScalingRuleRequest.AlarmDimensions()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.alarmDimensions = tmp
        }
        if dict.keys.contains("Cooldown") && dict["Cooldown"] != nil {
            self.cooldown = dict["Cooldown"] as! Int32
        }
        if dict.keys.contains("DisableScaleIn") && dict["DisableScaleIn"] != nil {
            self.disableScaleIn = dict["DisableScaleIn"] as! Bool
        }
        if dict.keys.contains("EstimatedInstanceWarmup") && dict["EstimatedInstanceWarmup"] != nil {
            self.estimatedInstanceWarmup = dict["EstimatedInstanceWarmup"] as! Int32
        }
        if dict.keys.contains("InitialMaxSize") && dict["InitialMaxSize"] != nil {
            self.initialMaxSize = dict["InitialMaxSize"] as! Int32
        }
        if dict.keys.contains("MetricName") && dict["MetricName"] != nil {
            self.metricName = dict["MetricName"] as! String
        }
        if dict.keys.contains("MinAdjustmentMagnitude") && dict["MinAdjustmentMagnitude"] != nil {
            self.minAdjustmentMagnitude = dict["MinAdjustmentMagnitude"] as! Int32
        }
        if dict.keys.contains("OwnerAccount") && dict["OwnerAccount"] != nil {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PredictiveScalingMode") && dict["PredictiveScalingMode"] != nil {
            self.predictiveScalingMode = dict["PredictiveScalingMode"] as! String
        }
        if dict.keys.contains("PredictiveTaskBufferTime") && dict["PredictiveTaskBufferTime"] != nil {
            self.predictiveTaskBufferTime = dict["PredictiveTaskBufferTime"] as! Int32
        }
        if dict.keys.contains("PredictiveValueBehavior") && dict["PredictiveValueBehavior"] != nil {
            self.predictiveValueBehavior = dict["PredictiveValueBehavior"] as! String
        }
        if dict.keys.contains("PredictiveValueBuffer") && dict["PredictiveValueBuffer"] != nil {
            self.predictiveValueBuffer = dict["PredictiveValueBuffer"] as! Int32
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ScaleInEvaluationCount") && dict["ScaleInEvaluationCount"] != nil {
            self.scaleInEvaluationCount = dict["ScaleInEvaluationCount"] as! Int32
        }
        if dict.keys.contains("ScaleOutEvaluationCount") && dict["ScaleOutEvaluationCount"] != nil {
            self.scaleOutEvaluationCount = dict["ScaleOutEvaluationCount"] as! Int32
        }
        if dict.keys.contains("ScalingRuleId") && dict["ScalingRuleId"] != nil {
            self.scalingRuleId = dict["ScalingRuleId"] as! String
        }
        if dict.keys.contains("ScalingRuleName") && dict["ScalingRuleName"] != nil {
            self.scalingRuleName = dict["ScalingRuleName"] as! String
        }
        if dict.keys.contains("StepAdjustments") && dict["StepAdjustments"] != nil {
            var tmp : [ModifyScalingRuleRequest.StepAdjustments] = []
            for v in dict["StepAdjustments"] as! [Any] {
                var model = ModifyScalingRuleRequest.StepAdjustments()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.stepAdjustments = tmp
        }
        if dict.keys.contains("TargetValue") && dict["TargetValue"] != nil {
            self.targetValue = dict["TargetValue"] as! Double
        }
    }
}

public class ModifyScalingRuleResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyScalingRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyScalingRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyScalingRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyScheduledTaskRequest : Tea.TeaModel {
    public var description_: String?

    public var desiredCapacity: Int32?

    public var launchExpirationTime: Int32?

    public var launchTime: String?

    public var maxValue: Int32?

    public var minValue: Int32?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var recurrenceEndTime: String?

    public var recurrenceType: String?

    public var recurrenceValue: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var scalingGroupId: String?

    public var scheduledAction: String?

    public var scheduledTaskId: String?

    public var scheduledTaskName: String?

    public var taskEnabled: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.desiredCapacity != nil {
            map["DesiredCapacity"] = self.desiredCapacity!
        }
        if self.launchExpirationTime != nil {
            map["LaunchExpirationTime"] = self.launchExpirationTime!
        }
        if self.launchTime != nil {
            map["LaunchTime"] = self.launchTime!
        }
        if self.maxValue != nil {
            map["MaxValue"] = self.maxValue!
        }
        if self.minValue != nil {
            map["MinValue"] = self.minValue!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.recurrenceEndTime != nil {
            map["RecurrenceEndTime"] = self.recurrenceEndTime!
        }
        if self.recurrenceType != nil {
            map["RecurrenceType"] = self.recurrenceType!
        }
        if self.recurrenceValue != nil {
            map["RecurrenceValue"] = self.recurrenceValue!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        if self.scheduledAction != nil {
            map["ScheduledAction"] = self.scheduledAction!
        }
        if self.scheduledTaskId != nil {
            map["ScheduledTaskId"] = self.scheduledTaskId!
        }
        if self.scheduledTaskName != nil {
            map["ScheduledTaskName"] = self.scheduledTaskName!
        }
        if self.taskEnabled != nil {
            map["TaskEnabled"] = self.taskEnabled!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DesiredCapacity") && dict["DesiredCapacity"] != nil {
            self.desiredCapacity = dict["DesiredCapacity"] as! Int32
        }
        if dict.keys.contains("LaunchExpirationTime") && dict["LaunchExpirationTime"] != nil {
            self.launchExpirationTime = dict["LaunchExpirationTime"] as! Int32
        }
        if dict.keys.contains("LaunchTime") && dict["LaunchTime"] != nil {
            self.launchTime = dict["LaunchTime"] as! String
        }
        if dict.keys.contains("MaxValue") && dict["MaxValue"] != nil {
            self.maxValue = dict["MaxValue"] as! Int32
        }
        if dict.keys.contains("MinValue") && dict["MinValue"] != nil {
            self.minValue = dict["MinValue"] as! Int32
        }
        if dict.keys.contains("OwnerAccount") && dict["OwnerAccount"] != nil {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RecurrenceEndTime") && dict["RecurrenceEndTime"] != nil {
            self.recurrenceEndTime = dict["RecurrenceEndTime"] as! String
        }
        if dict.keys.contains("RecurrenceType") && dict["RecurrenceType"] != nil {
            self.recurrenceType = dict["RecurrenceType"] as! String
        }
        if dict.keys.contains("RecurrenceValue") && dict["RecurrenceValue"] != nil {
            self.recurrenceValue = dict["RecurrenceValue"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ScalingGroupId") && dict["ScalingGroupId"] != nil {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
        if dict.keys.contains("ScheduledAction") && dict["ScheduledAction"] != nil {
            self.scheduledAction = dict["ScheduledAction"] as! String
        }
        if dict.keys.contains("ScheduledTaskId") && dict["ScheduledTaskId"] != nil {
            self.scheduledTaskId = dict["ScheduledTaskId"] as! String
        }
        if dict.keys.contains("ScheduledTaskName") && dict["ScheduledTaskName"] != nil {
            self.scheduledTaskName = dict["ScheduledTaskName"] as! String
        }
        if dict.keys.contains("TaskEnabled") && dict["TaskEnabled"] != nil {
            self.taskEnabled = dict["TaskEnabled"] as! Bool
        }
    }
}

public class ModifyScheduledTaskResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyScheduledTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyScheduledTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyScheduledTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RebalanceInstancesRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") && dict["OwnerAccount"] != nil {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ScalingGroupId") && dict["ScalingGroupId"] != nil {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
    }
}

public class RebalanceInstancesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var scalingActivityId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingActivityId != nil {
            map["ScalingActivityId"] = self.scalingActivityId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScalingActivityId") && dict["ScalingActivityId"] != nil {
            self.scalingActivityId = dict["ScalingActivityId"] as! String
        }
    }
}

public class RebalanceInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RebalanceInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RebalanceInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RecordLifecycleActionHeartbeatRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var heartbeatTimeout: Int32?

    public var lifecycleActionToken: String?

    public var lifecycleHookId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.heartbeatTimeout != nil {
            map["heartbeatTimeout"] = self.heartbeatTimeout!
        }
        if self.lifecycleActionToken != nil {
            map["lifecycleActionToken"] = self.lifecycleActionToken!
        }
        if self.lifecycleHookId != nil {
            map["lifecycleHookId"] = self.lifecycleHookId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") && dict["OwnerAccount"] != nil {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("heartbeatTimeout") && dict["heartbeatTimeout"] != nil {
            self.heartbeatTimeout = dict["heartbeatTimeout"] as! Int32
        }
        if dict.keys.contains("lifecycleActionToken") && dict["lifecycleActionToken"] != nil {
            self.lifecycleActionToken = dict["lifecycleActionToken"] as! String
        }
        if dict.keys.contains("lifecycleHookId") && dict["lifecycleHookId"] != nil {
            self.lifecycleHookId = dict["lifecycleHookId"] as! String
        }
    }
}

public class RecordLifecycleActionHeartbeatResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RecordLifecycleActionHeartbeatResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RecordLifecycleActionHeartbeatResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RecordLifecycleActionHeartbeatResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemoveInstancesRequest : Tea.TeaModel {
    public var clientToken: String?

    public var decreaseDesiredCapacity: Bool?

    public var instanceIds: [String]?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var removePolicy: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.decreaseDesiredCapacity != nil {
            map["DecreaseDesiredCapacity"] = self.decreaseDesiredCapacity!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.removePolicy != nil {
            map["RemovePolicy"] = self.removePolicy!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DecreaseDesiredCapacity") && dict["DecreaseDesiredCapacity"] != nil {
            self.decreaseDesiredCapacity = dict["DecreaseDesiredCapacity"] as! Bool
        }
        if dict.keys.contains("InstanceIds") && dict["InstanceIds"] != nil {
            self.instanceIds = dict["InstanceIds"] as! [String]
        }
        if dict.keys.contains("OwnerAccount") && dict["OwnerAccount"] != nil {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RemovePolicy") && dict["RemovePolicy"] != nil {
            self.removePolicy = dict["RemovePolicy"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ScalingGroupId") && dict["ScalingGroupId"] != nil {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
    }
}

public class RemoveInstancesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var scalingActivityId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingActivityId != nil {
            map["ScalingActivityId"] = self.scalingActivityId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScalingActivityId") && dict["ScalingActivityId"] != nil {
            self.scalingActivityId = dict["ScalingActivityId"] as! String
        }
    }
}

public class RemoveInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RemoveInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ResumeProcessesRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerId: Int64?

    public var processes: [String]?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.processes != nil {
            map["Processes"] = self.processes!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Processes") && dict["Processes"] != nil {
            self.processes = dict["Processes"] as! [String]
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScalingGroupId") && dict["ScalingGroupId"] != nil {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
    }
}

public class ResumeProcessesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ResumeProcessesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ResumeProcessesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ResumeProcessesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ScaleWithAdjustmentRequest : Tea.TeaModel {
    public class Overrides : Tea.TeaModel {
        public class ContainerOverrides : Tea.TeaModel {
            public class EnvironmentVars : Tea.TeaModel {
                public var key: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Key") && dict["Key"] != nil {
                        self.key = dict["Key"] as! String
                    }
                    if dict.keys.contains("Value") && dict["Value"] != nil {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public var args: [String]?

            public var commands: [String]?

            public var cpu: Double?

            public var environmentVars: [ScaleWithAdjustmentRequest.Overrides.ContainerOverrides.EnvironmentVars]?

            public var memory: Double?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.args != nil {
                    map["Args"] = self.args!
                }
                if self.commands != nil {
                    map["Commands"] = self.commands!
                }
                if self.cpu != nil {
                    map["Cpu"] = self.cpu!
                }
                if self.environmentVars != nil {
                    var tmp : [Any] = []
                    for k in self.environmentVars! {
                        tmp.append(k.toMap())
                    }
                    map["EnvironmentVars"] = tmp
                }
                if self.memory != nil {
                    map["Memory"] = self.memory!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Args") && dict["Args"] != nil {
                    self.args = dict["Args"] as! [String]
                }
                if dict.keys.contains("Commands") && dict["Commands"] != nil {
                    self.commands = dict["Commands"] as! [String]
                }
                if dict.keys.contains("Cpu") && dict["Cpu"] != nil {
                    self.cpu = dict["Cpu"] as! Double
                }
                if dict.keys.contains("EnvironmentVars") && dict["EnvironmentVars"] != nil {
                    var tmp : [ScaleWithAdjustmentRequest.Overrides.ContainerOverrides.EnvironmentVars] = []
                    for v in dict["EnvironmentVars"] as! [Any] {
                        var model = ScaleWithAdjustmentRequest.Overrides.ContainerOverrides.EnvironmentVars()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.environmentVars = tmp
                }
                if dict.keys.contains("Memory") && dict["Memory"] != nil {
                    self.memory = dict["Memory"] as! Double
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
            }
        }
        public var containerOverrides: [ScaleWithAdjustmentRequest.Overrides.ContainerOverrides]?

        public var cpu: Double?

        public var memory: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.containerOverrides != nil {
                var tmp : [Any] = []
                for k in self.containerOverrides! {
                    tmp.append(k.toMap())
                }
                map["ContainerOverrides"] = tmp
            }
            if self.cpu != nil {
                map["Cpu"] = self.cpu!
            }
            if self.memory != nil {
                map["Memory"] = self.memory!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ContainerOverrides") && dict["ContainerOverrides"] != nil {
                var tmp : [ScaleWithAdjustmentRequest.Overrides.ContainerOverrides] = []
                for v in dict["ContainerOverrides"] as! [Any] {
                    var model = ScaleWithAdjustmentRequest.Overrides.ContainerOverrides()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.containerOverrides = tmp
            }
            if dict.keys.contains("Cpu") && dict["Cpu"] != nil {
                self.cpu = dict["Cpu"] as! Double
            }
            if dict.keys.contains("Memory") && dict["Memory"] != nil {
                self.memory = dict["Memory"] as! Double
            }
        }
    }
    public var adjustmentType: String?

    public var adjustmentValue: Int32?

    public var clientToken: String?

    public var minAdjustmentMagnitude: Int32?

    public var overrides: ScaleWithAdjustmentRequest.Overrides?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public var syncActivity: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.overrides?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.adjustmentType != nil {
            map["AdjustmentType"] = self.adjustmentType!
        }
        if self.adjustmentValue != nil {
            map["AdjustmentValue"] = self.adjustmentValue!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.minAdjustmentMagnitude != nil {
            map["MinAdjustmentMagnitude"] = self.minAdjustmentMagnitude!
        }
        if self.overrides != nil {
            map["Overrides"] = self.overrides?.toMap()
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        if self.syncActivity != nil {
            map["SyncActivity"] = self.syncActivity!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AdjustmentType") && dict["AdjustmentType"] != nil {
            self.adjustmentType = dict["AdjustmentType"] as! String
        }
        if dict.keys.contains("AdjustmentValue") && dict["AdjustmentValue"] != nil {
            self.adjustmentValue = dict["AdjustmentValue"] as! Int32
        }
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("MinAdjustmentMagnitude") && dict["MinAdjustmentMagnitude"] != nil {
            self.minAdjustmentMagnitude = dict["MinAdjustmentMagnitude"] as! Int32
        }
        if dict.keys.contains("Overrides") && dict["Overrides"] != nil {
            var model = ScaleWithAdjustmentRequest.Overrides()
            model.fromMap(dict["Overrides"] as! [String: Any])
            self.overrides = model
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScalingGroupId") && dict["ScalingGroupId"] != nil {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
        if dict.keys.contains("SyncActivity") && dict["SyncActivity"] != nil {
            self.syncActivity = dict["SyncActivity"] as! Bool
        }
    }
}

public class ScaleWithAdjustmentShrinkRequest : Tea.TeaModel {
    public var adjustmentType: String?

    public var adjustmentValue: Int32?

    public var clientToken: String?

    public var minAdjustmentMagnitude: Int32?

    public var overridesShrink: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public var syncActivity: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.adjustmentType != nil {
            map["AdjustmentType"] = self.adjustmentType!
        }
        if self.adjustmentValue != nil {
            map["AdjustmentValue"] = self.adjustmentValue!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.minAdjustmentMagnitude != nil {
            map["MinAdjustmentMagnitude"] = self.minAdjustmentMagnitude!
        }
        if self.overridesShrink != nil {
            map["Overrides"] = self.overridesShrink!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        if self.syncActivity != nil {
            map["SyncActivity"] = self.syncActivity!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AdjustmentType") && dict["AdjustmentType"] != nil {
            self.adjustmentType = dict["AdjustmentType"] as! String
        }
        if dict.keys.contains("AdjustmentValue") && dict["AdjustmentValue"] != nil {
            self.adjustmentValue = dict["AdjustmentValue"] as! Int32
        }
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("MinAdjustmentMagnitude") && dict["MinAdjustmentMagnitude"] != nil {
            self.minAdjustmentMagnitude = dict["MinAdjustmentMagnitude"] as! Int32
        }
        if dict.keys.contains("Overrides") && dict["Overrides"] != nil {
            self.overridesShrink = dict["Overrides"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScalingGroupId") && dict["ScalingGroupId"] != nil {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
        if dict.keys.contains("SyncActivity") && dict["SyncActivity"] != nil {
            self.syncActivity = dict["SyncActivity"] as! Bool
        }
    }
}

public class ScaleWithAdjustmentResponseBody : Tea.TeaModel {
    public var activityType: String?

    public var requestId: String?

    public var scalingActivityId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.activityType != nil {
            map["ActivityType"] = self.activityType!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingActivityId != nil {
            map["ScalingActivityId"] = self.scalingActivityId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ActivityType") && dict["ActivityType"] != nil {
            self.activityType = dict["ActivityType"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScalingActivityId") && dict["ScalingActivityId"] != nil {
            self.scalingActivityId = dict["ScalingActivityId"] as! String
        }
    }
}

public class ScaleWithAdjustmentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ScaleWithAdjustmentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ScaleWithAdjustmentResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetGroupDeletionProtectionRequest : Tea.TeaModel {
    public var groupDeletionProtection: Bool?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupDeletionProtection != nil {
            map["GroupDeletionProtection"] = self.groupDeletionProtection!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupDeletionProtection") && dict["GroupDeletionProtection"] != nil {
            self.groupDeletionProtection = dict["GroupDeletionProtection"] as! Bool
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScalingGroupId") && dict["ScalingGroupId"] != nil {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
    }
}

public class SetGroupDeletionProtectionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetGroupDeletionProtectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetGroupDeletionProtectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SetGroupDeletionProtectionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetInstanceHealthRequest : Tea.TeaModel {
    public var healthStatus: String?

    public var instanceId: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.healthStatus != nil {
            map["HealthStatus"] = self.healthStatus!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("HealthStatus") && dict["HealthStatus"] != nil {
            self.healthStatus = dict["HealthStatus"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
    }
}

public class SetInstanceHealthResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetInstanceHealthResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetInstanceHealthResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SetInstanceHealthResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetInstancesProtectionRequest : Tea.TeaModel {
    public var instanceIds: [String]?

    public var ownerId: Int64?

    public var protectedFromScaleIn: Bool?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.protectedFromScaleIn != nil {
            map["ProtectedFromScaleIn"] = self.protectedFromScaleIn!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceIds") && dict["InstanceIds"] != nil {
            self.instanceIds = dict["InstanceIds"] as! [String]
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ProtectedFromScaleIn") && dict["ProtectedFromScaleIn"] != nil {
            self.protectedFromScaleIn = dict["ProtectedFromScaleIn"] as! Bool
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScalingGroupId") && dict["ScalingGroupId"] != nil {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
    }
}

public class SetInstancesProtectionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetInstancesProtectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetInstancesProtectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SetInstancesProtectionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SuspendProcessesRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerId: Int64?

    public var processes: [String]?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.processes != nil {
            map["Processes"] = self.processes!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Processes") && dict["Processes"] != nil {
            self.processes = dict["Processes"] as! [String]
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScalingGroupId") && dict["ScalingGroupId"] != nil {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
    }
}

public class SuspendProcessesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SuspendProcessesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SuspendProcessesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SuspendProcessesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class TagResourcesRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var propagate: Bool?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.propagate != nil {
                map["Propagate"] = self.propagate!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Propagate") && dict["Propagate"] != nil {
                self.propagate = dict["Propagate"] as! Bool
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var ownerId: Int64?

    public var regionId: String?

    public var resourceIds: [String]?

    public var resourceOwnerAccount: String?

    public var resourceType: String?

    public var tags: [TagResourcesRequest.Tags]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceIds != nil {
            map["ResourceIds"] = self.resourceIds!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceIds") && dict["ResourceIds"] != nil {
            self.resourceIds = dict["ResourceIds"] as! [String]
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceType") && dict["ResourceType"] != nil {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("Tags") && dict["Tags"] != nil {
            var tmp : [TagResourcesRequest.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = TagResourcesRequest.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
    }
}

public class TagResourcesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class TagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: TagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = TagResourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UntagResourcesRequest : Tea.TeaModel {
    public var all: Bool?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceIds: [String]?

    public var resourceOwnerAccount: String?

    public var resourceType: String?

    public var tagKeys: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.all != nil {
            map["All"] = self.all!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceIds != nil {
            map["ResourceIds"] = self.resourceIds!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tagKeys != nil {
            map["TagKeys"] = self.tagKeys!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("All") && dict["All"] != nil {
            self.all = dict["All"] as! Bool
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceIds") && dict["ResourceIds"] != nil {
            self.resourceIds = dict["ResourceIds"] as! [String]
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceType") && dict["ResourceType"] != nil {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("TagKeys") && dict["TagKeys"] != nil {
            self.tagKeys = dict["TagKeys"] as! [String]
        }
    }
}

public class UntagResourcesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UntagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UntagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UntagResourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class VerifyAuthenticationRequest : Tea.TeaModel {
    public var onlyCheck: Bool?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var uid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.onlyCheck != nil {
            map["OnlyCheck"] = self.onlyCheck!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.uid != nil {
            map["Uid"] = self.uid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OnlyCheck") && dict["OnlyCheck"] != nil {
            self.onlyCheck = dict["OnlyCheck"] as! Bool
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Uid") && dict["Uid"] != nil {
            self.uid = dict["Uid"] as! Int64
        }
    }
}

public class VerifyAuthenticationResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class VerifyAuthenticationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: VerifyAuthenticationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = VerifyAuthenticationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class VerifyUserRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class VerifyUserResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class VerifyUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: VerifyUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = VerifyUserResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}
