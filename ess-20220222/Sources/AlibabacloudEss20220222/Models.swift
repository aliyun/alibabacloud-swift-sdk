import Foundation
import Tea
import TeaUtils
import AlibabacloudOpenApi
import AlibabaCloudOpenApiUtil
import AlibabacloudEndpointUtil

public class ApplyEciScalingConfigurationRequest : Tea.TeaModel {
    public var content: String?

    public var format: String?

    public var regionId: String?

    public var scalingConfigurationId: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.format != nil {
            map["Format"] = self.format!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.scalingConfigurationId != nil {
            map["ScalingConfigurationId"] = self.scalingConfigurationId!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Content") {
            self.content = dict["Content"] as! String
        }
        if dict.keys.contains("Format") {
            self.format = dict["Format"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ScalingConfigurationId") {
            self.scalingConfigurationId = dict["ScalingConfigurationId"] as! String
        }
        if dict.keys.contains("ScalingGroupId") {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
    }
}

public class ApplyEciScalingConfigurationResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var scalingConfigurationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingConfigurationId != nil {
            map["ScalingConfigurationId"] = self.scalingConfigurationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScalingConfigurationId") {
            self.scalingConfigurationId = dict["ScalingConfigurationId"] as! String
        }
    }
}

public class ApplyEciScalingConfigurationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ApplyEciScalingConfigurationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ApplyEciScalingConfigurationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ApplyScalingGroupRequest : Tea.TeaModel {
    public var content: String?

    public var format: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.format != nil {
            map["Format"] = self.format!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Content") {
            self.content = dict["Content"] as! String
        }
        if dict.keys.contains("Format") {
            self.format = dict["Format"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ApplyScalingGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScalingGroupId") {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
    }
}

public class ApplyScalingGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ApplyScalingGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ApplyScalingGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AttachAlbServerGroupsRequest : Tea.TeaModel {
    public class AlbServerGroups : Tea.TeaModel {
        public var albServerGroupId: String?

        public var port: Int32?

        public var weight: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.albServerGroupId != nil {
                map["AlbServerGroupId"] = self.albServerGroupId!
            }
            if self.port != nil {
                map["Port"] = self.port!
            }
            if self.weight != nil {
                map["Weight"] = self.weight!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AlbServerGroupId") {
                self.albServerGroupId = dict["AlbServerGroupId"] as! String
            }
            if dict.keys.contains("Port") {
                self.port = dict["Port"] as! Int32
            }
            if dict.keys.contains("Weight") {
                self.weight = dict["Weight"] as! Int32
            }
        }
    }
    public var albServerGroups: [AttachAlbServerGroupsRequest.AlbServerGroups]?

    public var clientToken: String?

    public var forceAttach: Bool?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.albServerGroups != nil {
            var tmp : [Any] = []
            for k in self.albServerGroups! {
                tmp.append(k.toMap())
            }
            map["AlbServerGroups"] = tmp
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.forceAttach != nil {
            map["ForceAttach"] = self.forceAttach!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlbServerGroups") {
            var tmp : [AttachAlbServerGroupsRequest.AlbServerGroups] = []
            for v in dict["AlbServerGroups"] as! [Any] {
                var model = AttachAlbServerGroupsRequest.AlbServerGroups()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.albServerGroups = tmp
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("ForceAttach") {
            self.forceAttach = dict["ForceAttach"] as! Bool
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScalingGroupId") {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
    }
}

public class AttachAlbServerGroupsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var scalingActivityId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingActivityId != nil {
            map["ScalingActivityId"] = self.scalingActivityId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScalingActivityId") {
            self.scalingActivityId = dict["ScalingActivityId"] as! String
        }
    }
}

public class AttachAlbServerGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AttachAlbServerGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AttachAlbServerGroupsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AttachDBInstancesRequest : Tea.TeaModel {
    public var attachMode: String?

    public var clientToken: String?

    public var DBInstances: [String]?

    public var forceAttach: Bool?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attachMode != nil {
            map["AttachMode"] = self.attachMode!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.DBInstances != nil {
            map["DBInstances"] = self.DBInstances!
        }
        if self.forceAttach != nil {
            map["ForceAttach"] = self.forceAttach!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AttachMode") {
            self.attachMode = dict["AttachMode"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DBInstances") {
            self.DBInstances = dict["DBInstances"] as! [String]
        }
        if dict.keys.contains("ForceAttach") {
            self.forceAttach = dict["ForceAttach"] as! Bool
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScalingGroupId") {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class AttachDBInstancesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AttachDBInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AttachDBInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AttachDBInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AttachInstancesRequest : Tea.TeaModel {
    public var clientToken: String?

    public var entrusted: Bool?

    public var ignoreInvalidInstance: Bool?

    public var instanceIds: [String]?

    public var lifecycleHook: Bool?

    public var loadBalancerWeights: [Int32]?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.entrusted != nil {
            map["Entrusted"] = self.entrusted!
        }
        if self.ignoreInvalidInstance != nil {
            map["IgnoreInvalidInstance"] = self.ignoreInvalidInstance!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.lifecycleHook != nil {
            map["LifecycleHook"] = self.lifecycleHook!
        }
        if self.loadBalancerWeights != nil {
            map["LoadBalancerWeights"] = self.loadBalancerWeights!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Entrusted") {
            self.entrusted = dict["Entrusted"] as! Bool
        }
        if dict.keys.contains("IgnoreInvalidInstance") {
            self.ignoreInvalidInstance = dict["IgnoreInvalidInstance"] as! Bool
        }
        if dict.keys.contains("InstanceIds") {
            self.instanceIds = dict["InstanceIds"] as! [String]
        }
        if dict.keys.contains("LifecycleHook") {
            self.lifecycleHook = dict["LifecycleHook"] as! Bool
        }
        if dict.keys.contains("LoadBalancerWeights") {
            self.loadBalancerWeights = dict["LoadBalancerWeights"] as! [Int32]
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ScalingGroupId") {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
    }
}

public class AttachInstancesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var scalingActivityId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingActivityId != nil {
            map["ScalingActivityId"] = self.scalingActivityId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScalingActivityId") {
            self.scalingActivityId = dict["ScalingActivityId"] as! String
        }
    }
}

public class AttachInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AttachInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AttachInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AttachLoadBalancersRequest : Tea.TeaModel {
    public class LoadBalancerConfigs : Tea.TeaModel {
        public var loadBalancerId: String?

        public var weight: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.loadBalancerId != nil {
                map["LoadBalancerId"] = self.loadBalancerId!
            }
            if self.weight != nil {
                map["Weight"] = self.weight!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LoadBalancerId") {
                self.loadBalancerId = dict["LoadBalancerId"] as! String
            }
            if dict.keys.contains("Weight") {
                self.weight = dict["Weight"] as! Int32
            }
        }
    }
    public var async: Bool?

    public var clientToken: String?

    public var forceAttach: Bool?

    public var loadBalancerConfigs: [AttachLoadBalancersRequest.LoadBalancerConfigs]?

    public var loadBalancers: [String]?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.async != nil {
            map["Async"] = self.async!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.forceAttach != nil {
            map["ForceAttach"] = self.forceAttach!
        }
        if self.loadBalancerConfigs != nil {
            var tmp : [Any] = []
            for k in self.loadBalancerConfigs! {
                tmp.append(k.toMap())
            }
            map["LoadBalancerConfigs"] = tmp
        }
        if self.loadBalancers != nil {
            map["LoadBalancers"] = self.loadBalancers!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Async") {
            self.async = dict["Async"] as! Bool
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("ForceAttach") {
            self.forceAttach = dict["ForceAttach"] as! Bool
        }
        if dict.keys.contains("LoadBalancerConfigs") {
            var tmp : [AttachLoadBalancersRequest.LoadBalancerConfigs] = []
            for v in dict["LoadBalancerConfigs"] as! [Any] {
                var model = AttachLoadBalancersRequest.LoadBalancerConfigs()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.loadBalancerConfigs = tmp
        }
        if dict.keys.contains("LoadBalancers") {
            self.loadBalancers = dict["LoadBalancers"] as! [String]
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScalingGroupId") {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
    }
}

public class AttachLoadBalancersResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var scalingActivityId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingActivityId != nil {
            map["ScalingActivityId"] = self.scalingActivityId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScalingActivityId") {
            self.scalingActivityId = dict["ScalingActivityId"] as! String
        }
    }
}

public class AttachLoadBalancersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AttachLoadBalancersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AttachLoadBalancersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AttachServerGroupsRequest : Tea.TeaModel {
    public class ServerGroups : Tea.TeaModel {
        public var port: Int32?

        public var serverGroupId: String?

        public var type: String?

        public var weight: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.port != nil {
                map["Port"] = self.port!
            }
            if self.serverGroupId != nil {
                map["ServerGroupId"] = self.serverGroupId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.weight != nil {
                map["Weight"] = self.weight!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Port") {
                self.port = dict["Port"] as! Int32
            }
            if dict.keys.contains("ServerGroupId") {
                self.serverGroupId = dict["ServerGroupId"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Weight") {
                self.weight = dict["Weight"] as! Int32
            }
        }
    }
    public var clientToken: String?

    public var forceAttach: Bool?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public var serverGroups: [AttachServerGroupsRequest.ServerGroups]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.forceAttach != nil {
            map["ForceAttach"] = self.forceAttach!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        if self.serverGroups != nil {
            var tmp : [Any] = []
            for k in self.serverGroups! {
                tmp.append(k.toMap())
            }
            map["ServerGroups"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("ForceAttach") {
            self.forceAttach = dict["ForceAttach"] as! Bool
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScalingGroupId") {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
        if dict.keys.contains("ServerGroups") {
            var tmp : [AttachServerGroupsRequest.ServerGroups] = []
            for v in dict["ServerGroups"] as! [Any] {
                var model = AttachServerGroupsRequest.ServerGroups()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.serverGroups = tmp
        }
    }
}

public class AttachServerGroupsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var scalingActivityId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingActivityId != nil {
            map["ScalingActivityId"] = self.scalingActivityId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScalingActivityId") {
            self.scalingActivityId = dict["ScalingActivityId"] as! String
        }
    }
}

public class AttachServerGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AttachServerGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AttachServerGroupsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AttachVServerGroupsRequest : Tea.TeaModel {
    public class VServerGroups : Tea.TeaModel {
        public class VServerGroupAttributes : Tea.TeaModel {
            public var port: Int32?

            public var VServerGroupId: String?

            public var weight: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.VServerGroupId != nil {
                    map["VServerGroupId"] = self.VServerGroupId!
                }
                if self.weight != nil {
                    map["Weight"] = self.weight!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Port") {
                    self.port = dict["Port"] as! Int32
                }
                if dict.keys.contains("VServerGroupId") {
                    self.VServerGroupId = dict["VServerGroupId"] as! String
                }
                if dict.keys.contains("Weight") {
                    self.weight = dict["Weight"] as! Int32
                }
            }
        }
        public var loadBalancerId: String?

        public var VServerGroupAttributes: [AttachVServerGroupsRequest.VServerGroups.VServerGroupAttributes]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.loadBalancerId != nil {
                map["LoadBalancerId"] = self.loadBalancerId!
            }
            if self.VServerGroupAttributes != nil {
                var tmp : [Any] = []
                for k in self.VServerGroupAttributes! {
                    tmp.append(k.toMap())
                }
                map["VServerGroupAttributes"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LoadBalancerId") {
                self.loadBalancerId = dict["LoadBalancerId"] as! String
            }
            if dict.keys.contains("VServerGroupAttributes") {
                var tmp : [AttachVServerGroupsRequest.VServerGroups.VServerGroupAttributes] = []
                for v in dict["VServerGroupAttributes"] as! [Any] {
                    var model = AttachVServerGroupsRequest.VServerGroups.VServerGroupAttributes()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.VServerGroupAttributes = tmp
            }
        }
    }
    public var clientToken: String?

    public var forceAttach: Bool?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public var VServerGroups: [AttachVServerGroupsRequest.VServerGroups]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.forceAttach != nil {
            map["ForceAttach"] = self.forceAttach!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        if self.VServerGroups != nil {
            var tmp : [Any] = []
            for k in self.VServerGroups! {
                tmp.append(k.toMap())
            }
            map["VServerGroups"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("ForceAttach") {
            self.forceAttach = dict["ForceAttach"] as! Bool
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScalingGroupId") {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
        if dict.keys.contains("VServerGroups") {
            var tmp : [AttachVServerGroupsRequest.VServerGroups] = []
            for v in dict["VServerGroups"] as! [Any] {
                var model = AttachVServerGroupsRequest.VServerGroups()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.VServerGroups = tmp
        }
    }
}

public class AttachVServerGroupsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AttachVServerGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AttachVServerGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AttachVServerGroupsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CancelInstanceRefreshRequest : Tea.TeaModel {
    public var instanceRefreshTaskId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceRefreshTaskId != nil {
            map["InstanceRefreshTaskId"] = self.instanceRefreshTaskId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceRefreshTaskId") {
            self.instanceRefreshTaskId = dict["InstanceRefreshTaskId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScalingGroupId") {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
    }
}

public class CancelInstanceRefreshResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CancelInstanceRefreshResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CancelInstanceRefreshResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CancelInstanceRefreshResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ChangeResourceGroupRequest : Tea.TeaModel {
    public var newResourceGroupId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceId: String?

    public var resourceOwnerAccount: String?

    public var resourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.newResourceGroupId != nil {
            map["NewResourceGroupId"] = self.newResourceGroupId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NewResourceGroupId") {
            self.newResourceGroupId = dict["NewResourceGroupId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
    }
}

public class ChangeResourceGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ChangeResourceGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ChangeResourceGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ChangeResourceGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CompleteLifecycleActionRequest : Tea.TeaModel {
    public var clientToken: String?

    public var lifecycleActionResult: String?

    public var lifecycleActionToken: String?

    public var lifecycleHookId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.lifecycleActionResult != nil {
            map["LifecycleActionResult"] = self.lifecycleActionResult!
        }
        if self.lifecycleActionToken != nil {
            map["LifecycleActionToken"] = self.lifecycleActionToken!
        }
        if self.lifecycleHookId != nil {
            map["LifecycleHookId"] = self.lifecycleHookId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("LifecycleActionResult") {
            self.lifecycleActionResult = dict["LifecycleActionResult"] as! String
        }
        if dict.keys.contains("LifecycleActionToken") {
            self.lifecycleActionToken = dict["LifecycleActionToken"] as! String
        }
        if dict.keys.contains("LifecycleHookId") {
            self.lifecycleHookId = dict["LifecycleHookId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
    }
}

public class CompleteLifecycleActionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CompleteLifecycleActionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CompleteLifecycleActionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CompleteLifecycleActionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateAlarmRequest : Tea.TeaModel {
    public class Dimensions : Tea.TeaModel {
        public var dimensionKey: String?

        public var dimensionValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dimensionKey != nil {
                map["DimensionKey"] = self.dimensionKey!
            }
            if self.dimensionValue != nil {
                map["DimensionValue"] = self.dimensionValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DimensionKey") {
                self.dimensionKey = dict["DimensionKey"] as! String
            }
            if dict.keys.contains("DimensionValue") {
                self.dimensionValue = dict["DimensionValue"] as! String
            }
        }
    }
    public class Expressions : Tea.TeaModel {
        public var comparisonOperator: String?

        public var metricName: String?

        public var period: Int32?

        public var statistics: String?

        public var threshold: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.comparisonOperator != nil {
                map["ComparisonOperator"] = self.comparisonOperator!
            }
            if self.metricName != nil {
                map["MetricName"] = self.metricName!
            }
            if self.period != nil {
                map["Period"] = self.period!
            }
            if self.statistics != nil {
                map["Statistics"] = self.statistics!
            }
            if self.threshold != nil {
                map["Threshold"] = self.threshold!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ComparisonOperator") {
                self.comparisonOperator = dict["ComparisonOperator"] as! String
            }
            if dict.keys.contains("MetricName") {
                self.metricName = dict["MetricName"] as! String
            }
            if dict.keys.contains("Period") {
                self.period = dict["Period"] as! Int32
            }
            if dict.keys.contains("Statistics") {
                self.statistics = dict["Statistics"] as! String
            }
            if dict.keys.contains("Threshold") {
                self.threshold = dict["Threshold"] as! Double
            }
        }
    }
    public var alarmActions: [String]?

    public var comparisonOperator: String?

    public var description_: String?

    public var dimensions: [CreateAlarmRequest.Dimensions]?

    public var effective: String?

    public var evaluationCount: Int32?

    public var expressions: [CreateAlarmRequest.Expressions]?

    public var expressionsLogicOperator: String?

    public var groupId: Int32?

    public var metricName: String?

    public var metricType: String?

    public var name: String?

    public var ownerId: Int64?

    public var period: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public var statistics: String?

    public var threshold: Double?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alarmActions != nil {
            map["AlarmActions"] = self.alarmActions!
        }
        if self.comparisonOperator != nil {
            map["ComparisonOperator"] = self.comparisonOperator!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.dimensions != nil {
            var tmp : [Any] = []
            for k in self.dimensions! {
                tmp.append(k.toMap())
            }
            map["Dimensions"] = tmp
        }
        if self.effective != nil {
            map["Effective"] = self.effective!
        }
        if self.evaluationCount != nil {
            map["EvaluationCount"] = self.evaluationCount!
        }
        if self.expressions != nil {
            var tmp : [Any] = []
            for k in self.expressions! {
                tmp.append(k.toMap())
            }
            map["Expressions"] = tmp
        }
        if self.expressionsLogicOperator != nil {
            map["ExpressionsLogicOperator"] = self.expressionsLogicOperator!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.metricName != nil {
            map["MetricName"] = self.metricName!
        }
        if self.metricType != nil {
            map["MetricType"] = self.metricType!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        if self.statistics != nil {
            map["Statistics"] = self.statistics!
        }
        if self.threshold != nil {
            map["Threshold"] = self.threshold!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlarmActions") {
            self.alarmActions = dict["AlarmActions"] as! [String]
        }
        if dict.keys.contains("ComparisonOperator") {
            self.comparisonOperator = dict["ComparisonOperator"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Dimensions") {
            var tmp : [CreateAlarmRequest.Dimensions] = []
            for v in dict["Dimensions"] as! [Any] {
                var model = CreateAlarmRequest.Dimensions()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.dimensions = tmp
        }
        if dict.keys.contains("Effective") {
            self.effective = dict["Effective"] as! String
        }
        if dict.keys.contains("EvaluationCount") {
            self.evaluationCount = dict["EvaluationCount"] as! Int32
        }
        if dict.keys.contains("Expressions") {
            var tmp : [CreateAlarmRequest.Expressions] = []
            for v in dict["Expressions"] as! [Any] {
                var model = CreateAlarmRequest.Expressions()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.expressions = tmp
        }
        if dict.keys.contains("ExpressionsLogicOperator") {
            self.expressionsLogicOperator = dict["ExpressionsLogicOperator"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! Int32
        }
        if dict.keys.contains("MetricName") {
            self.metricName = dict["MetricName"] as! String
        }
        if dict.keys.contains("MetricType") {
            self.metricType = dict["MetricType"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScalingGroupId") {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
        if dict.keys.contains("Statistics") {
            self.statistics = dict["Statistics"] as! String
        }
        if dict.keys.contains("Threshold") {
            self.threshold = dict["Threshold"] as! Double
        }
    }
}

public class CreateAlarmResponseBody : Tea.TeaModel {
    public var alarmTaskId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alarmTaskId != nil {
            map["AlarmTaskId"] = self.alarmTaskId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlarmTaskId") {
            self.alarmTaskId = dict["AlarmTaskId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateAlarmResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateAlarmResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateAlarmResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateDiagnoseReportRequest : Tea.TeaModel {
    public var regionId: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ScalingGroupId") {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
    }
}

public class CreateDiagnoseReportResponseBody : Tea.TeaModel {
    public var reportId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.reportId != nil {
            map["ReportId"] = self.reportId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ReportId") {
            self.reportId = dict["ReportId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateDiagnoseReportResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDiagnoseReportResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateDiagnoseReportResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateEciScalingConfigurationRequest : Tea.TeaModel {
    public class AcrRegistryInfos : Tea.TeaModel {
        public var domains: [String]?

        public var instanceId: String?

        public var instanceName: String?

        public var regionId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.domains != nil {
                map["Domains"] = self.domains!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Domains") {
                self.domains = dict["Domains"] as! [String]
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("InstanceName") {
                self.instanceName = dict["InstanceName"] as! String
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
        }
    }
    public class Containers : Tea.TeaModel {
        public class LivenessProbe : Tea.TeaModel {
            public class Exec : Tea.TeaModel {
                public var commands: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.commands != nil {
                        map["Commands"] = self.commands!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Commands") {
                        self.commands = dict["Commands"] as! [String]
                    }
                }
            }
            public class HttpGet : Tea.TeaModel {
                public var path: String?

                public var port: Int32?

                public var scheme: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.path != nil {
                        map["Path"] = self.path!
                    }
                    if self.port != nil {
                        map["Port"] = self.port!
                    }
                    if self.scheme != nil {
                        map["Scheme"] = self.scheme!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Path") {
                        self.path = dict["Path"] as! String
                    }
                    if dict.keys.contains("Port") {
                        self.port = dict["Port"] as! Int32
                    }
                    if dict.keys.contains("Scheme") {
                        self.scheme = dict["Scheme"] as! String
                    }
                }
            }
            public class TcpSocket : Tea.TeaModel {
                public var port: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.port != nil {
                        map["Port"] = self.port!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Port") {
                        self.port = dict["Port"] as! Int32
                    }
                }
            }
            public var exec: CreateEciScalingConfigurationRequest.Containers.LivenessProbe.Exec?

            public var failureThreshold: Int32?

            public var httpGet: CreateEciScalingConfigurationRequest.Containers.LivenessProbe.HttpGet?

            public var initialDelaySeconds: Int32?

            public var periodSeconds: Int32?

            public var successThreshold: Int32?

            public var tcpSocket: CreateEciScalingConfigurationRequest.Containers.LivenessProbe.TcpSocket?

            public var timeoutSeconds: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.exec?.validate()
                try self.httpGet?.validate()
                try self.tcpSocket?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.exec != nil {
                    map["Exec"] = self.exec?.toMap()
                }
                if self.failureThreshold != nil {
                    map["FailureThreshold"] = self.failureThreshold!
                }
                if self.httpGet != nil {
                    map["HttpGet"] = self.httpGet?.toMap()
                }
                if self.initialDelaySeconds != nil {
                    map["InitialDelaySeconds"] = self.initialDelaySeconds!
                }
                if self.periodSeconds != nil {
                    map["PeriodSeconds"] = self.periodSeconds!
                }
                if self.successThreshold != nil {
                    map["SuccessThreshold"] = self.successThreshold!
                }
                if self.tcpSocket != nil {
                    map["TcpSocket"] = self.tcpSocket?.toMap()
                }
                if self.timeoutSeconds != nil {
                    map["TimeoutSeconds"] = self.timeoutSeconds!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Exec") {
                    var model = CreateEciScalingConfigurationRequest.Containers.LivenessProbe.Exec()
                    model.fromMap(dict["Exec"] as! [String: Any])
                    self.exec = model
                }
                if dict.keys.contains("FailureThreshold") {
                    self.failureThreshold = dict["FailureThreshold"] as! Int32
                }
                if dict.keys.contains("HttpGet") {
                    var model = CreateEciScalingConfigurationRequest.Containers.LivenessProbe.HttpGet()
                    model.fromMap(dict["HttpGet"] as! [String: Any])
                    self.httpGet = model
                }
                if dict.keys.contains("InitialDelaySeconds") {
                    self.initialDelaySeconds = dict["InitialDelaySeconds"] as! Int32
                }
                if dict.keys.contains("PeriodSeconds") {
                    self.periodSeconds = dict["PeriodSeconds"] as! Int32
                }
                if dict.keys.contains("SuccessThreshold") {
                    self.successThreshold = dict["SuccessThreshold"] as! Int32
                }
                if dict.keys.contains("TcpSocket") {
                    var model = CreateEciScalingConfigurationRequest.Containers.LivenessProbe.TcpSocket()
                    model.fromMap(dict["TcpSocket"] as! [String: Any])
                    self.tcpSocket = model
                }
                if dict.keys.contains("TimeoutSeconds") {
                    self.timeoutSeconds = dict["TimeoutSeconds"] as! Int32
                }
            }
        }
        public class ReadinessProbe : Tea.TeaModel {
            public class Exec : Tea.TeaModel {
                public var commands: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.commands != nil {
                        map["Commands"] = self.commands!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Commands") {
                        self.commands = dict["Commands"] as! [String]
                    }
                }
            }
            public class HttpGet : Tea.TeaModel {
                public var path: String?

                public var port: Int32?

                public var scheme: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.path != nil {
                        map["Path"] = self.path!
                    }
                    if self.port != nil {
                        map["Port"] = self.port!
                    }
                    if self.scheme != nil {
                        map["Scheme"] = self.scheme!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Path") {
                        self.path = dict["Path"] as! String
                    }
                    if dict.keys.contains("Port") {
                        self.port = dict["Port"] as! Int32
                    }
                    if dict.keys.contains("Scheme") {
                        self.scheme = dict["Scheme"] as! String
                    }
                }
            }
            public class TcpSocket : Tea.TeaModel {
                public var port: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.port != nil {
                        map["Port"] = self.port!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Port") {
                        self.port = dict["Port"] as! Int32
                    }
                }
            }
            public var exec: CreateEciScalingConfigurationRequest.Containers.ReadinessProbe.Exec?

            public var failureThreshold: Int32?

            public var httpGet: CreateEciScalingConfigurationRequest.Containers.ReadinessProbe.HttpGet?

            public var initialDelaySeconds: Int32?

            public var periodSeconds: Int32?

            public var successThreshold: Int32?

            public var tcpSocket: CreateEciScalingConfigurationRequest.Containers.ReadinessProbe.TcpSocket?

            public var timeoutSeconds: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.exec?.validate()
                try self.httpGet?.validate()
                try self.tcpSocket?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.exec != nil {
                    map["Exec"] = self.exec?.toMap()
                }
                if self.failureThreshold != nil {
                    map["FailureThreshold"] = self.failureThreshold!
                }
                if self.httpGet != nil {
                    map["HttpGet"] = self.httpGet?.toMap()
                }
                if self.initialDelaySeconds != nil {
                    map["InitialDelaySeconds"] = self.initialDelaySeconds!
                }
                if self.periodSeconds != nil {
                    map["PeriodSeconds"] = self.periodSeconds!
                }
                if self.successThreshold != nil {
                    map["SuccessThreshold"] = self.successThreshold!
                }
                if self.tcpSocket != nil {
                    map["TcpSocket"] = self.tcpSocket?.toMap()
                }
                if self.timeoutSeconds != nil {
                    map["TimeoutSeconds"] = self.timeoutSeconds!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Exec") {
                    var model = CreateEciScalingConfigurationRequest.Containers.ReadinessProbe.Exec()
                    model.fromMap(dict["Exec"] as! [String: Any])
                    self.exec = model
                }
                if dict.keys.contains("FailureThreshold") {
                    self.failureThreshold = dict["FailureThreshold"] as! Int32
                }
                if dict.keys.contains("HttpGet") {
                    var model = CreateEciScalingConfigurationRequest.Containers.ReadinessProbe.HttpGet()
                    model.fromMap(dict["HttpGet"] as! [String: Any])
                    self.httpGet = model
                }
                if dict.keys.contains("InitialDelaySeconds") {
                    self.initialDelaySeconds = dict["InitialDelaySeconds"] as! Int32
                }
                if dict.keys.contains("PeriodSeconds") {
                    self.periodSeconds = dict["PeriodSeconds"] as! Int32
                }
                if dict.keys.contains("SuccessThreshold") {
                    self.successThreshold = dict["SuccessThreshold"] as! Int32
                }
                if dict.keys.contains("TcpSocket") {
                    var model = CreateEciScalingConfigurationRequest.Containers.ReadinessProbe.TcpSocket()
                    model.fromMap(dict["TcpSocket"] as! [String: Any])
                    self.tcpSocket = model
                }
                if dict.keys.contains("TimeoutSeconds") {
                    self.timeoutSeconds = dict["TimeoutSeconds"] as! Int32
                }
            }
        }
        public class SecurityContext : Tea.TeaModel {
            public class Capability : Tea.TeaModel {
                public var add: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.add != nil {
                        map["Add"] = self.add!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Add") {
                        self.add = dict["Add"] as! [String]
                    }
                }
            }
            public var capability: CreateEciScalingConfigurationRequest.Containers.SecurityContext.Capability?

            public var readOnlyRootFilesystem: Bool?

            public var runAsUser: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.capability?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.capability != nil {
                    map["Capability"] = self.capability?.toMap()
                }
                if self.readOnlyRootFilesystem != nil {
                    map["ReadOnlyRootFilesystem"] = self.readOnlyRootFilesystem!
                }
                if self.runAsUser != nil {
                    map["RunAsUser"] = self.runAsUser!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Capability") {
                    var model = CreateEciScalingConfigurationRequest.Containers.SecurityContext.Capability()
                    model.fromMap(dict["Capability"] as! [String: Any])
                    self.capability = model
                }
                if dict.keys.contains("ReadOnlyRootFilesystem") {
                    self.readOnlyRootFilesystem = dict["ReadOnlyRootFilesystem"] as! Bool
                }
                if dict.keys.contains("RunAsUser") {
                    self.runAsUser = dict["RunAsUser"] as! Int64
                }
            }
        }
        public class EnvironmentVars : Tea.TeaModel {
            public var fieldRefFieldPath: String?

            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fieldRefFieldPath != nil {
                    map["FieldRefFieldPath"] = self.fieldRefFieldPath!
                }
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FieldRefFieldPath") {
                    self.fieldRefFieldPath = dict["FieldRefFieldPath"] as! String
                }
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public class Ports : Tea.TeaModel {
            public var port: Int32?

            public var protocol_: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.protocol_ != nil {
                    map["Protocol"] = self.protocol_!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Port") {
                    self.port = dict["Port"] as! Int32
                }
                if dict.keys.contains("Protocol") {
                    self.protocol_ = dict["Protocol"] as! String
                }
            }
        }
        public class VolumeMounts : Tea.TeaModel {
            public var mountPath: String?

            public var mountPropagation: String?

            public var name: String?

            public var readOnly: Bool?

            public var subPath: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.mountPath != nil {
                    map["MountPath"] = self.mountPath!
                }
                if self.mountPropagation != nil {
                    map["MountPropagation"] = self.mountPropagation!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.readOnly != nil {
                    map["ReadOnly"] = self.readOnly!
                }
                if self.subPath != nil {
                    map["SubPath"] = self.subPath!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("MountPath") {
                    self.mountPath = dict["MountPath"] as! String
                }
                if dict.keys.contains("MountPropagation") {
                    self.mountPropagation = dict["MountPropagation"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("ReadOnly") {
                    self.readOnly = dict["ReadOnly"] as! Bool
                }
                if dict.keys.contains("SubPath") {
                    self.subPath = dict["SubPath"] as! String
                }
            }
        }
        public var livenessProbe: CreateEciScalingConfigurationRequest.Containers.LivenessProbe?

        public var readinessProbe: CreateEciScalingConfigurationRequest.Containers.ReadinessProbe?

        public var securityContext: CreateEciScalingConfigurationRequest.Containers.SecurityContext?

        public var args: [String]?

        public var commands: [String]?

        public var cpu: Double?

        public var environmentVars: [CreateEciScalingConfigurationRequest.Containers.EnvironmentVars]?

        public var gpu: Int32?

        public var image: String?

        public var imagePullPolicy: String?

        public var lifecyclePostStartHandlerExecs: [String]?

        public var lifecyclePostStartHandlerHttpGetHost: String?

        public var lifecyclePostStartHandlerHttpGetPath: String?

        public var lifecyclePostStartHandlerHttpGetPort: Int32?

        public var lifecyclePostStartHandlerHttpGetScheme: String?

        public var lifecyclePostStartHandlerTcpSocketHost: String?

        public var lifecyclePostStartHandlerTcpSocketPort: Int32?

        public var lifecyclePreStopHandlerExecs: [String]?

        public var lifecyclePreStopHandlerHttpGetHost: String?

        public var lifecyclePreStopHandlerHttpGetPath: String?

        public var lifecyclePreStopHandlerHttpGetPort: Int32?

        public var lifecyclePreStopHandlerHttpGetScheme: String?

        public var lifecyclePreStopHandlerTcpSocketHost: String?

        public var lifecyclePreStopHandlerTcpSocketPort: Int32?

        public var memory: Double?

        public var name: String?

        public var ports: [CreateEciScalingConfigurationRequest.Containers.Ports]?

        public var stdin: Bool?

        public var stdinOnce: Bool?

        public var tty: Bool?

        public var volumeMounts: [CreateEciScalingConfigurationRequest.Containers.VolumeMounts]?

        public var workingDir: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.livenessProbe?.validate()
            try self.readinessProbe?.validate()
            try self.securityContext?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.livenessProbe != nil {
                map["LivenessProbe"] = self.livenessProbe?.toMap()
            }
            if self.readinessProbe != nil {
                map["ReadinessProbe"] = self.readinessProbe?.toMap()
            }
            if self.securityContext != nil {
                map["SecurityContext"] = self.securityContext?.toMap()
            }
            if self.args != nil {
                map["Args"] = self.args!
            }
            if self.commands != nil {
                map["Commands"] = self.commands!
            }
            if self.cpu != nil {
                map["Cpu"] = self.cpu!
            }
            if self.environmentVars != nil {
                var tmp : [Any] = []
                for k in self.environmentVars! {
                    tmp.append(k.toMap())
                }
                map["EnvironmentVars"] = tmp
            }
            if self.gpu != nil {
                map["Gpu"] = self.gpu!
            }
            if self.image != nil {
                map["Image"] = self.image!
            }
            if self.imagePullPolicy != nil {
                map["ImagePullPolicy"] = self.imagePullPolicy!
            }
            if self.lifecyclePostStartHandlerExecs != nil {
                map["LifecyclePostStartHandlerExecs"] = self.lifecyclePostStartHandlerExecs!
            }
            if self.lifecyclePostStartHandlerHttpGetHost != nil {
                map["LifecyclePostStartHandlerHttpGetHost"] = self.lifecyclePostStartHandlerHttpGetHost!
            }
            if self.lifecyclePostStartHandlerHttpGetPath != nil {
                map["LifecyclePostStartHandlerHttpGetPath"] = self.lifecyclePostStartHandlerHttpGetPath!
            }
            if self.lifecyclePostStartHandlerHttpGetPort != nil {
                map["LifecyclePostStartHandlerHttpGetPort"] = self.lifecyclePostStartHandlerHttpGetPort!
            }
            if self.lifecyclePostStartHandlerHttpGetScheme != nil {
                map["LifecyclePostStartHandlerHttpGetScheme"] = self.lifecyclePostStartHandlerHttpGetScheme!
            }
            if self.lifecyclePostStartHandlerTcpSocketHost != nil {
                map["LifecyclePostStartHandlerTcpSocketHost"] = self.lifecyclePostStartHandlerTcpSocketHost!
            }
            if self.lifecyclePostStartHandlerTcpSocketPort != nil {
                map["LifecyclePostStartHandlerTcpSocketPort"] = self.lifecyclePostStartHandlerTcpSocketPort!
            }
            if self.lifecyclePreStopHandlerExecs != nil {
                map["LifecyclePreStopHandlerExecs"] = self.lifecyclePreStopHandlerExecs!
            }
            if self.lifecyclePreStopHandlerHttpGetHost != nil {
                map["LifecyclePreStopHandlerHttpGetHost"] = self.lifecyclePreStopHandlerHttpGetHost!
            }
            if self.lifecyclePreStopHandlerHttpGetPath != nil {
                map["LifecyclePreStopHandlerHttpGetPath"] = self.lifecyclePreStopHandlerHttpGetPath!
            }
            if self.lifecyclePreStopHandlerHttpGetPort != nil {
                map["LifecyclePreStopHandlerHttpGetPort"] = self.lifecyclePreStopHandlerHttpGetPort!
            }
            if self.lifecyclePreStopHandlerHttpGetScheme != nil {
                map["LifecyclePreStopHandlerHttpGetScheme"] = self.lifecyclePreStopHandlerHttpGetScheme!
            }
            if self.lifecyclePreStopHandlerTcpSocketHost != nil {
                map["LifecyclePreStopHandlerTcpSocketHost"] = self.lifecyclePreStopHandlerTcpSocketHost!
            }
            if self.lifecyclePreStopHandlerTcpSocketPort != nil {
                map["LifecyclePreStopHandlerTcpSocketPort"] = self.lifecyclePreStopHandlerTcpSocketPort!
            }
            if self.memory != nil {
                map["Memory"] = self.memory!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.ports != nil {
                var tmp : [Any] = []
                for k in self.ports! {
                    tmp.append(k.toMap())
                }
                map["Ports"] = tmp
            }
            if self.stdin != nil {
                map["Stdin"] = self.stdin!
            }
            if self.stdinOnce != nil {
                map["StdinOnce"] = self.stdinOnce!
            }
            if self.tty != nil {
                map["Tty"] = self.tty!
            }
            if self.volumeMounts != nil {
                var tmp : [Any] = []
                for k in self.volumeMounts! {
                    tmp.append(k.toMap())
                }
                map["VolumeMounts"] = tmp
            }
            if self.workingDir != nil {
                map["WorkingDir"] = self.workingDir!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LivenessProbe") {
                var model = CreateEciScalingConfigurationRequest.Containers.LivenessProbe()
                model.fromMap(dict["LivenessProbe"] as! [String: Any])
                self.livenessProbe = model
            }
            if dict.keys.contains("ReadinessProbe") {
                var model = CreateEciScalingConfigurationRequest.Containers.ReadinessProbe()
                model.fromMap(dict["ReadinessProbe"] as! [String: Any])
                self.readinessProbe = model
            }
            if dict.keys.contains("SecurityContext") {
                var model = CreateEciScalingConfigurationRequest.Containers.SecurityContext()
                model.fromMap(dict["SecurityContext"] as! [String: Any])
                self.securityContext = model
            }
            if dict.keys.contains("Args") {
                self.args = dict["Args"] as! [String]
            }
            if dict.keys.contains("Commands") {
                self.commands = dict["Commands"] as! [String]
            }
            if dict.keys.contains("Cpu") {
                self.cpu = dict["Cpu"] as! Double
            }
            if dict.keys.contains("EnvironmentVars") {
                var tmp : [CreateEciScalingConfigurationRequest.Containers.EnvironmentVars] = []
                for v in dict["EnvironmentVars"] as! [Any] {
                    var model = CreateEciScalingConfigurationRequest.Containers.EnvironmentVars()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.environmentVars = tmp
            }
            if dict.keys.contains("Gpu") {
                self.gpu = dict["Gpu"] as! Int32
            }
            if dict.keys.contains("Image") {
                self.image = dict["Image"] as! String
            }
            if dict.keys.contains("ImagePullPolicy") {
                self.imagePullPolicy = dict["ImagePullPolicy"] as! String
            }
            if dict.keys.contains("LifecyclePostStartHandlerExecs") {
                self.lifecyclePostStartHandlerExecs = dict["LifecyclePostStartHandlerExecs"] as! [String]
            }
            if dict.keys.contains("LifecyclePostStartHandlerHttpGetHost") {
                self.lifecyclePostStartHandlerHttpGetHost = dict["LifecyclePostStartHandlerHttpGetHost"] as! String
            }
            if dict.keys.contains("LifecyclePostStartHandlerHttpGetPath") {
                self.lifecyclePostStartHandlerHttpGetPath = dict["LifecyclePostStartHandlerHttpGetPath"] as! String
            }
            if dict.keys.contains("LifecyclePostStartHandlerHttpGetPort") {
                self.lifecyclePostStartHandlerHttpGetPort = dict["LifecyclePostStartHandlerHttpGetPort"] as! Int32
            }
            if dict.keys.contains("LifecyclePostStartHandlerHttpGetScheme") {
                self.lifecyclePostStartHandlerHttpGetScheme = dict["LifecyclePostStartHandlerHttpGetScheme"] as! String
            }
            if dict.keys.contains("LifecyclePostStartHandlerTcpSocketHost") {
                self.lifecyclePostStartHandlerTcpSocketHost = dict["LifecyclePostStartHandlerTcpSocketHost"] as! String
            }
            if dict.keys.contains("LifecyclePostStartHandlerTcpSocketPort") {
                self.lifecyclePostStartHandlerTcpSocketPort = dict["LifecyclePostStartHandlerTcpSocketPort"] as! Int32
            }
            if dict.keys.contains("LifecyclePreStopHandlerExecs") {
                self.lifecyclePreStopHandlerExecs = dict["LifecyclePreStopHandlerExecs"] as! [String]
            }
            if dict.keys.contains("LifecyclePreStopHandlerHttpGetHost") {
                self.lifecyclePreStopHandlerHttpGetHost = dict["LifecyclePreStopHandlerHttpGetHost"] as! String
            }
            if dict.keys.contains("LifecyclePreStopHandlerHttpGetPath") {
                self.lifecyclePreStopHandlerHttpGetPath = dict["LifecyclePreStopHandlerHttpGetPath"] as! String
            }
            if dict.keys.contains("LifecyclePreStopHandlerHttpGetPort") {
                self.lifecyclePreStopHandlerHttpGetPort = dict["LifecyclePreStopHandlerHttpGetPort"] as! Int32
            }
            if dict.keys.contains("LifecyclePreStopHandlerHttpGetScheme") {
                self.lifecyclePreStopHandlerHttpGetScheme = dict["LifecyclePreStopHandlerHttpGetScheme"] as! String
            }
            if dict.keys.contains("LifecyclePreStopHandlerTcpSocketHost") {
                self.lifecyclePreStopHandlerTcpSocketHost = dict["LifecyclePreStopHandlerTcpSocketHost"] as! String
            }
            if dict.keys.contains("LifecyclePreStopHandlerTcpSocketPort") {
                self.lifecyclePreStopHandlerTcpSocketPort = dict["LifecyclePreStopHandlerTcpSocketPort"] as! Int32
            }
            if dict.keys.contains("Memory") {
                self.memory = dict["Memory"] as! Double
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Ports") {
                var tmp : [CreateEciScalingConfigurationRequest.Containers.Ports] = []
                for v in dict["Ports"] as! [Any] {
                    var model = CreateEciScalingConfigurationRequest.Containers.Ports()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ports = tmp
            }
            if dict.keys.contains("Stdin") {
                self.stdin = dict["Stdin"] as! Bool
            }
            if dict.keys.contains("StdinOnce") {
                self.stdinOnce = dict["StdinOnce"] as! Bool
            }
            if dict.keys.contains("Tty") {
                self.tty = dict["Tty"] as! Bool
            }
            if dict.keys.contains("VolumeMounts") {
                var tmp : [CreateEciScalingConfigurationRequest.Containers.VolumeMounts] = []
                for v in dict["VolumeMounts"] as! [Any] {
                    var model = CreateEciScalingConfigurationRequest.Containers.VolumeMounts()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.volumeMounts = tmp
            }
            if dict.keys.contains("WorkingDir") {
                self.workingDir = dict["WorkingDir"] as! String
            }
        }
    }
    public class DnsConfigOptions : Tea.TeaModel {
        public var name: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public class HostAliases : Tea.TeaModel {
        public var hostnames: [String]?

        public var ip: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.hostnames != nil {
                map["Hostnames"] = self.hostnames!
            }
            if self.ip != nil {
                map["Ip"] = self.ip!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Hostnames") {
                self.hostnames = dict["Hostnames"] as! [String]
            }
            if dict.keys.contains("Ip") {
                self.ip = dict["Ip"] as! String
            }
        }
    }
    public class ImageRegistryCredentials : Tea.TeaModel {
        public var password: String?

        public var server: String?

        public var userName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.password != nil {
                map["Password"] = self.password!
            }
            if self.server != nil {
                map["Server"] = self.server!
            }
            if self.userName != nil {
                map["UserName"] = self.userName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Password") {
                self.password = dict["Password"] as! String
            }
            if dict.keys.contains("Server") {
                self.server = dict["Server"] as! String
            }
            if dict.keys.contains("UserName") {
                self.userName = dict["UserName"] as! String
            }
        }
    }
    public class InitContainers : Tea.TeaModel {
        public class SecurityContext : Tea.TeaModel {
            public class Capability : Tea.TeaModel {
                public var adds: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.adds != nil {
                        map["Adds"] = self.adds!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Adds") {
                        self.adds = dict["Adds"] as! [String]
                    }
                }
            }
            public var capability: CreateEciScalingConfigurationRequest.InitContainers.SecurityContext.Capability?

            public var readOnlyRootFilesystem: Bool?

            public var runAsUser: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.capability?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.capability != nil {
                    map["Capability"] = self.capability?.toMap()
                }
                if self.readOnlyRootFilesystem != nil {
                    map["ReadOnlyRootFilesystem"] = self.readOnlyRootFilesystem!
                }
                if self.runAsUser != nil {
                    map["RunAsUser"] = self.runAsUser!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Capability") {
                    var model = CreateEciScalingConfigurationRequest.InitContainers.SecurityContext.Capability()
                    model.fromMap(dict["Capability"] as! [String: Any])
                    self.capability = model
                }
                if dict.keys.contains("ReadOnlyRootFilesystem") {
                    self.readOnlyRootFilesystem = dict["ReadOnlyRootFilesystem"] as! Bool
                }
                if dict.keys.contains("RunAsUser") {
                    self.runAsUser = dict["RunAsUser"] as! Int64
                }
            }
        }
        public class InitContainerEnvironmentVars : Tea.TeaModel {
            public var fieldRefFieldPath: String?

            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fieldRefFieldPath != nil {
                    map["FieldRefFieldPath"] = self.fieldRefFieldPath!
                }
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FieldRefFieldPath") {
                    self.fieldRefFieldPath = dict["FieldRefFieldPath"] as! String
                }
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public class InitContainerPorts : Tea.TeaModel {
            public var port: Int32?

            public var protocol_: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.protocol_ != nil {
                    map["Protocol"] = self.protocol_!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Port") {
                    self.port = dict["Port"] as! Int32
                }
                if dict.keys.contains("Protocol") {
                    self.protocol_ = dict["Protocol"] as! String
                }
            }
        }
        public class InitContainerVolumeMounts : Tea.TeaModel {
            public var mountPath: String?

            public var mountPropagation: String?

            public var name: String?

            public var readOnly: Bool?

            public var subPath: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.mountPath != nil {
                    map["MountPath"] = self.mountPath!
                }
                if self.mountPropagation != nil {
                    map["MountPropagation"] = self.mountPropagation!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.readOnly != nil {
                    map["ReadOnly"] = self.readOnly!
                }
                if self.subPath != nil {
                    map["SubPath"] = self.subPath!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("MountPath") {
                    self.mountPath = dict["MountPath"] as! String
                }
                if dict.keys.contains("MountPropagation") {
                    self.mountPropagation = dict["MountPropagation"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("ReadOnly") {
                    self.readOnly = dict["ReadOnly"] as! Bool
                }
                if dict.keys.contains("SubPath") {
                    self.subPath = dict["SubPath"] as! String
                }
            }
        }
        public var securityContext: CreateEciScalingConfigurationRequest.InitContainers.SecurityContext?

        public var args: [String]?

        public var commands: [String]?

        public var cpu: Double?

        public var gpu: Int32?

        public var image: String?

        public var imagePullPolicy: String?

        public var initContainerEnvironmentVars: [CreateEciScalingConfigurationRequest.InitContainers.InitContainerEnvironmentVars]?

        public var initContainerPorts: [CreateEciScalingConfigurationRequest.InitContainers.InitContainerPorts]?

        public var initContainerVolumeMounts: [CreateEciScalingConfigurationRequest.InitContainers.InitContainerVolumeMounts]?

        public var memory: Double?

        public var name: String?

        public var workingDir: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.securityContext?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.securityContext != nil {
                map["SecurityContext"] = self.securityContext?.toMap()
            }
            if self.args != nil {
                map["Args"] = self.args!
            }
            if self.commands != nil {
                map["Commands"] = self.commands!
            }
            if self.cpu != nil {
                map["Cpu"] = self.cpu!
            }
            if self.gpu != nil {
                map["Gpu"] = self.gpu!
            }
            if self.image != nil {
                map["Image"] = self.image!
            }
            if self.imagePullPolicy != nil {
                map["ImagePullPolicy"] = self.imagePullPolicy!
            }
            if self.initContainerEnvironmentVars != nil {
                var tmp : [Any] = []
                for k in self.initContainerEnvironmentVars! {
                    tmp.append(k.toMap())
                }
                map["InitContainerEnvironmentVars"] = tmp
            }
            if self.initContainerPorts != nil {
                var tmp : [Any] = []
                for k in self.initContainerPorts! {
                    tmp.append(k.toMap())
                }
                map["InitContainerPorts"] = tmp
            }
            if self.initContainerVolumeMounts != nil {
                var tmp : [Any] = []
                for k in self.initContainerVolumeMounts! {
                    tmp.append(k.toMap())
                }
                map["InitContainerVolumeMounts"] = tmp
            }
            if self.memory != nil {
                map["Memory"] = self.memory!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.workingDir != nil {
                map["WorkingDir"] = self.workingDir!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SecurityContext") {
                var model = CreateEciScalingConfigurationRequest.InitContainers.SecurityContext()
                model.fromMap(dict["SecurityContext"] as! [String: Any])
                self.securityContext = model
            }
            if dict.keys.contains("Args") {
                self.args = dict["Args"] as! [String]
            }
            if dict.keys.contains("Commands") {
                self.commands = dict["Commands"] as! [String]
            }
            if dict.keys.contains("Cpu") {
                self.cpu = dict["Cpu"] as! Double
            }
            if dict.keys.contains("Gpu") {
                self.gpu = dict["Gpu"] as! Int32
            }
            if dict.keys.contains("Image") {
                self.image = dict["Image"] as! String
            }
            if dict.keys.contains("ImagePullPolicy") {
                self.imagePullPolicy = dict["ImagePullPolicy"] as! String
            }
            if dict.keys.contains("InitContainerEnvironmentVars") {
                var tmp : [CreateEciScalingConfigurationRequest.InitContainers.InitContainerEnvironmentVars] = []
                for v in dict["InitContainerEnvironmentVars"] as! [Any] {
                    var model = CreateEciScalingConfigurationRequest.InitContainers.InitContainerEnvironmentVars()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.initContainerEnvironmentVars = tmp
            }
            if dict.keys.contains("InitContainerPorts") {
                var tmp : [CreateEciScalingConfigurationRequest.InitContainers.InitContainerPorts] = []
                for v in dict["InitContainerPorts"] as! [Any] {
                    var model = CreateEciScalingConfigurationRequest.InitContainers.InitContainerPorts()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.initContainerPorts = tmp
            }
            if dict.keys.contains("InitContainerVolumeMounts") {
                var tmp : [CreateEciScalingConfigurationRequest.InitContainers.InitContainerVolumeMounts] = []
                for v in dict["InitContainerVolumeMounts"] as! [Any] {
                    var model = CreateEciScalingConfigurationRequest.InitContainers.InitContainerVolumeMounts()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.initContainerVolumeMounts = tmp
            }
            if dict.keys.contains("Memory") {
                self.memory = dict["Memory"] as! Double
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("WorkingDir") {
                self.workingDir = dict["WorkingDir"] as! String
            }
        }
    }
    public class SecurityContextSysctls : Tea.TeaModel {
        public var name: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public class Volumes : Tea.TeaModel {
        public class DiskVolume : Tea.TeaModel {
            public var diskId: String?

            public var diskSize: Int32?

            public var fsType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.diskId != nil {
                    map["DiskId"] = self.diskId!
                }
                if self.diskSize != nil {
                    map["DiskSize"] = self.diskSize!
                }
                if self.fsType != nil {
                    map["FsType"] = self.fsType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DiskId") {
                    self.diskId = dict["DiskId"] as! String
                }
                if dict.keys.contains("DiskSize") {
                    self.diskSize = dict["DiskSize"] as! Int32
                }
                if dict.keys.contains("FsType") {
                    self.fsType = dict["FsType"] as! String
                }
            }
        }
        public class EmptyDirVolume : Tea.TeaModel {
            public var medium: String?

            public var sizeLimit: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.medium != nil {
                    map["Medium"] = self.medium!
                }
                if self.sizeLimit != nil {
                    map["SizeLimit"] = self.sizeLimit!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Medium") {
                    self.medium = dict["Medium"] as! String
                }
                if dict.keys.contains("SizeLimit") {
                    self.sizeLimit = dict["SizeLimit"] as! String
                }
            }
        }
        public class FlexVolume : Tea.TeaModel {
            public var driver: String?

            public var fsType: String?

            public var options: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.driver != nil {
                    map["Driver"] = self.driver!
                }
                if self.fsType != nil {
                    map["FsType"] = self.fsType!
                }
                if self.options != nil {
                    map["Options"] = self.options!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Driver") {
                    self.driver = dict["Driver"] as! String
                }
                if dict.keys.contains("FsType") {
                    self.fsType = dict["FsType"] as! String
                }
                if dict.keys.contains("Options") {
                    self.options = dict["Options"] as! String
                }
            }
        }
        public class HostPathVolume : Tea.TeaModel {
            public var path: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.path != nil {
                    map["Path"] = self.path!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Path") {
                    self.path = dict["Path"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class NFSVolume : Tea.TeaModel {
            public var path: String?

            public var readOnly: Bool?

            public var server: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.path != nil {
                    map["Path"] = self.path!
                }
                if self.readOnly != nil {
                    map["ReadOnly"] = self.readOnly!
                }
                if self.server != nil {
                    map["Server"] = self.server!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Path") {
                    self.path = dict["Path"] as! String
                }
                if dict.keys.contains("ReadOnly") {
                    self.readOnly = dict["ReadOnly"] as! Bool
                }
                if dict.keys.contains("Server") {
                    self.server = dict["Server"] as! String
                }
            }
        }
        public class ConfigFileVolumeConfigFileToPaths : Tea.TeaModel {
            public var content: String?

            public var mode: Int32?

            public var path: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.content != nil {
                    map["Content"] = self.content!
                }
                if self.mode != nil {
                    map["Mode"] = self.mode!
                }
                if self.path != nil {
                    map["Path"] = self.path!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Content") {
                    self.content = dict["Content"] as! String
                }
                if dict.keys.contains("Mode") {
                    self.mode = dict["Mode"] as! Int32
                }
                if dict.keys.contains("Path") {
                    self.path = dict["Path"] as! String
                }
            }
        }
        public var diskVolume: CreateEciScalingConfigurationRequest.Volumes.DiskVolume?

        public var emptyDirVolume: CreateEciScalingConfigurationRequest.Volumes.EmptyDirVolume?

        public var flexVolume: CreateEciScalingConfigurationRequest.Volumes.FlexVolume?

        public var hostPathVolume: CreateEciScalingConfigurationRequest.Volumes.HostPathVolume?

        public var NFSVolume: CreateEciScalingConfigurationRequest.Volumes.NFSVolume?

        public var configFileVolumeConfigFileToPaths: [CreateEciScalingConfigurationRequest.Volumes.ConfigFileVolumeConfigFileToPaths]?

        public var configFileVolumeDefaultMode: Int32?

        public var name: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.diskVolume?.validate()
            try self.emptyDirVolume?.validate()
            try self.flexVolume?.validate()
            try self.hostPathVolume?.validate()
            try self.NFSVolume?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.diskVolume != nil {
                map["DiskVolume"] = self.diskVolume?.toMap()
            }
            if self.emptyDirVolume != nil {
                map["EmptyDirVolume"] = self.emptyDirVolume?.toMap()
            }
            if self.flexVolume != nil {
                map["FlexVolume"] = self.flexVolume?.toMap()
            }
            if self.hostPathVolume != nil {
                map["HostPathVolume"] = self.hostPathVolume?.toMap()
            }
            if self.NFSVolume != nil {
                map["NFSVolume"] = self.NFSVolume?.toMap()
            }
            if self.configFileVolumeConfigFileToPaths != nil {
                var tmp : [Any] = []
                for k in self.configFileVolumeConfigFileToPaths! {
                    tmp.append(k.toMap())
                }
                map["ConfigFileVolumeConfigFileToPaths"] = tmp
            }
            if self.configFileVolumeDefaultMode != nil {
                map["ConfigFileVolumeDefaultMode"] = self.configFileVolumeDefaultMode!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DiskVolume") {
                var model = CreateEciScalingConfigurationRequest.Volumes.DiskVolume()
                model.fromMap(dict["DiskVolume"] as! [String: Any])
                self.diskVolume = model
            }
            if dict.keys.contains("EmptyDirVolume") {
                var model = CreateEciScalingConfigurationRequest.Volumes.EmptyDirVolume()
                model.fromMap(dict["EmptyDirVolume"] as! [String: Any])
                self.emptyDirVolume = model
            }
            if dict.keys.contains("FlexVolume") {
                var model = CreateEciScalingConfigurationRequest.Volumes.FlexVolume()
                model.fromMap(dict["FlexVolume"] as! [String: Any])
                self.flexVolume = model
            }
            if dict.keys.contains("HostPathVolume") {
                var model = CreateEciScalingConfigurationRequest.Volumes.HostPathVolume()
                model.fromMap(dict["HostPathVolume"] as! [String: Any])
                self.hostPathVolume = model
            }
            if dict.keys.contains("NFSVolume") {
                var model = CreateEciScalingConfigurationRequest.Volumes.NFSVolume()
                model.fromMap(dict["NFSVolume"] as! [String: Any])
                self.NFSVolume = model
            }
            if dict.keys.contains("ConfigFileVolumeConfigFileToPaths") {
                var tmp : [CreateEciScalingConfigurationRequest.Volumes.ConfigFileVolumeConfigFileToPaths] = []
                for v in dict["ConfigFileVolumeConfigFileToPaths"] as! [Any] {
                    var model = CreateEciScalingConfigurationRequest.Volumes.ConfigFileVolumeConfigFileToPaths()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.configFileVolumeConfigFileToPaths = tmp
            }
            if dict.keys.contains("ConfigFileVolumeDefaultMode") {
                self.configFileVolumeDefaultMode = dict["ConfigFileVolumeDefaultMode"] as! Int32
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var acrRegistryInfos: [CreateEciScalingConfigurationRequest.AcrRegistryInfos]?

    public var activeDeadlineSeconds: Int64?

    public var autoCreateEip: Bool?

    public var autoMatchImageCache: Bool?

    public var containerGroupName: String?

    public var containers: [CreateEciScalingConfigurationRequest.Containers]?

    public var costOptimization: Bool?

    public var cpu: Double?

    public var cpuOptionsCore: Int32?

    public var cpuOptionsThreadsPerCore: Int32?

    public var dataCacheBucket: String?

    public var dataCacheBurstingEnabled: Bool?

    public var dataCachePL: String?

    public var dataCacheProvisionedIops: Int32?

    public var description_: String?

    public var dnsConfigNameServers: [String]?

    public var dnsConfigOptions: [CreateEciScalingConfigurationRequest.DnsConfigOptions]?

    public var dnsConfigSearchs: [String]?

    public var dnsPolicy: String?

    public var egressBandwidth: Int64?

    public var eipBandwidth: Int32?

    public var enableSls: Bool?

    public var ephemeralStorage: Int32?

    public var gpuDriverVersion: String?

    public var hostAliases: [CreateEciScalingConfigurationRequest.HostAliases]?

    public var hostName: String?

    public var imageRegistryCredentials: [CreateEciScalingConfigurationRequest.ImageRegistryCredentials]?

    public var imageSnapshotId: String?

    public var ingressBandwidth: Int64?

    public var initContainers: [CreateEciScalingConfigurationRequest.InitContainers]?

    public var instanceFamilyLevel: String?

    public var instanceTypes: [String]?

    public var ipv6AddressCount: Int32?

    public var loadBalancerWeight: Int32?

    public var memory: Double?

    public var ntpServers: [String]?

    public var ownerId: Int64?

    public var ramRoleName: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var restartPolicy: String?

    public var scalingConfigurationName: String?

    public var scalingGroupId: String?

    public var securityContextSysctls: [CreateEciScalingConfigurationRequest.SecurityContextSysctls]?

    public var securityGroupId: String?

    public var spotPriceLimit: Double?

    public var spotStrategy: String?

    public var tags: [CreateEciScalingConfigurationRequest.Tags]?

    public var terminationGracePeriodSeconds: Int64?

    public var volumes: [CreateEciScalingConfigurationRequest.Volumes]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acrRegistryInfos != nil {
            var tmp : [Any] = []
            for k in self.acrRegistryInfos! {
                tmp.append(k.toMap())
            }
            map["AcrRegistryInfos"] = tmp
        }
        if self.activeDeadlineSeconds != nil {
            map["ActiveDeadlineSeconds"] = self.activeDeadlineSeconds!
        }
        if self.autoCreateEip != nil {
            map["AutoCreateEip"] = self.autoCreateEip!
        }
        if self.autoMatchImageCache != nil {
            map["AutoMatchImageCache"] = self.autoMatchImageCache!
        }
        if self.containerGroupName != nil {
            map["ContainerGroupName"] = self.containerGroupName!
        }
        if self.containers != nil {
            var tmp : [Any] = []
            for k in self.containers! {
                tmp.append(k.toMap())
            }
            map["Containers"] = tmp
        }
        if self.costOptimization != nil {
            map["CostOptimization"] = self.costOptimization!
        }
        if self.cpu != nil {
            map["Cpu"] = self.cpu!
        }
        if self.cpuOptionsCore != nil {
            map["CpuOptionsCore"] = self.cpuOptionsCore!
        }
        if self.cpuOptionsThreadsPerCore != nil {
            map["CpuOptionsThreadsPerCore"] = self.cpuOptionsThreadsPerCore!
        }
        if self.dataCacheBucket != nil {
            map["DataCacheBucket"] = self.dataCacheBucket!
        }
        if self.dataCacheBurstingEnabled != nil {
            map["DataCacheBurstingEnabled"] = self.dataCacheBurstingEnabled!
        }
        if self.dataCachePL != nil {
            map["DataCachePL"] = self.dataCachePL!
        }
        if self.dataCacheProvisionedIops != nil {
            map["DataCacheProvisionedIops"] = self.dataCacheProvisionedIops!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.dnsConfigNameServers != nil {
            map["DnsConfigNameServers"] = self.dnsConfigNameServers!
        }
        if self.dnsConfigOptions != nil {
            var tmp : [Any] = []
            for k in self.dnsConfigOptions! {
                tmp.append(k.toMap())
            }
            map["DnsConfigOptions"] = tmp
        }
        if self.dnsConfigSearchs != nil {
            map["DnsConfigSearchs"] = self.dnsConfigSearchs!
        }
        if self.dnsPolicy != nil {
            map["DnsPolicy"] = self.dnsPolicy!
        }
        if self.egressBandwidth != nil {
            map["EgressBandwidth"] = self.egressBandwidth!
        }
        if self.eipBandwidth != nil {
            map["EipBandwidth"] = self.eipBandwidth!
        }
        if self.enableSls != nil {
            map["EnableSls"] = self.enableSls!
        }
        if self.ephemeralStorage != nil {
            map["EphemeralStorage"] = self.ephemeralStorage!
        }
        if self.gpuDriverVersion != nil {
            map["GpuDriverVersion"] = self.gpuDriverVersion!
        }
        if self.hostAliases != nil {
            var tmp : [Any] = []
            for k in self.hostAliases! {
                tmp.append(k.toMap())
            }
            map["HostAliases"] = tmp
        }
        if self.hostName != nil {
            map["HostName"] = self.hostName!
        }
        if self.imageRegistryCredentials != nil {
            var tmp : [Any] = []
            for k in self.imageRegistryCredentials! {
                tmp.append(k.toMap())
            }
            map["ImageRegistryCredentials"] = tmp
        }
        if self.imageSnapshotId != nil {
            map["ImageSnapshotId"] = self.imageSnapshotId!
        }
        if self.ingressBandwidth != nil {
            map["IngressBandwidth"] = self.ingressBandwidth!
        }
        if self.initContainers != nil {
            var tmp : [Any] = []
            for k in self.initContainers! {
                tmp.append(k.toMap())
            }
            map["InitContainers"] = tmp
        }
        if self.instanceFamilyLevel != nil {
            map["InstanceFamilyLevel"] = self.instanceFamilyLevel!
        }
        if self.instanceTypes != nil {
            map["InstanceTypes"] = self.instanceTypes!
        }
        if self.ipv6AddressCount != nil {
            map["Ipv6AddressCount"] = self.ipv6AddressCount!
        }
        if self.loadBalancerWeight != nil {
            map["LoadBalancerWeight"] = self.loadBalancerWeight!
        }
        if self.memory != nil {
            map["Memory"] = self.memory!
        }
        if self.ntpServers != nil {
            map["NtpServers"] = self.ntpServers!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.ramRoleName != nil {
            map["RamRoleName"] = self.ramRoleName!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.restartPolicy != nil {
            map["RestartPolicy"] = self.restartPolicy!
        }
        if self.scalingConfigurationName != nil {
            map["ScalingConfigurationName"] = self.scalingConfigurationName!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        if self.securityContextSysctls != nil {
            var tmp : [Any] = []
            for k in self.securityContextSysctls! {
                tmp.append(k.toMap())
            }
            map["SecurityContextSysctls"] = tmp
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.spotPriceLimit != nil {
            map["SpotPriceLimit"] = self.spotPriceLimit!
        }
        if self.spotStrategy != nil {
            map["SpotStrategy"] = self.spotStrategy!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        if self.terminationGracePeriodSeconds != nil {
            map["TerminationGracePeriodSeconds"] = self.terminationGracePeriodSeconds!
        }
        if self.volumes != nil {
            var tmp : [Any] = []
            for k in self.volumes! {
                tmp.append(k.toMap())
            }
            map["Volumes"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcrRegistryInfos") {
            var tmp : [CreateEciScalingConfigurationRequest.AcrRegistryInfos] = []
            for v in dict["AcrRegistryInfos"] as! [Any] {
                var model = CreateEciScalingConfigurationRequest.AcrRegistryInfos()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.acrRegistryInfos = tmp
        }
        if dict.keys.contains("ActiveDeadlineSeconds") {
            self.activeDeadlineSeconds = dict["ActiveDeadlineSeconds"] as! Int64
        }
        if dict.keys.contains("AutoCreateEip") {
            self.autoCreateEip = dict["AutoCreateEip"] as! Bool
        }
        if dict.keys.contains("AutoMatchImageCache") {
            self.autoMatchImageCache = dict["AutoMatchImageCache"] as! Bool
        }
        if dict.keys.contains("ContainerGroupName") {
            self.containerGroupName = dict["ContainerGroupName"] as! String
        }
        if dict.keys.contains("Containers") {
            var tmp : [CreateEciScalingConfigurationRequest.Containers] = []
            for v in dict["Containers"] as! [Any] {
                var model = CreateEciScalingConfigurationRequest.Containers()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.containers = tmp
        }
        if dict.keys.contains("CostOptimization") {
            self.costOptimization = dict["CostOptimization"] as! Bool
        }
        if dict.keys.contains("Cpu") {
            self.cpu = dict["Cpu"] as! Double
        }
        if dict.keys.contains("CpuOptionsCore") {
            self.cpuOptionsCore = dict["CpuOptionsCore"] as! Int32
        }
        if dict.keys.contains("CpuOptionsThreadsPerCore") {
            self.cpuOptionsThreadsPerCore = dict["CpuOptionsThreadsPerCore"] as! Int32
        }
        if dict.keys.contains("DataCacheBucket") {
            self.dataCacheBucket = dict["DataCacheBucket"] as! String
        }
        if dict.keys.contains("DataCacheBurstingEnabled") {
            self.dataCacheBurstingEnabled = dict["DataCacheBurstingEnabled"] as! Bool
        }
        if dict.keys.contains("DataCachePL") {
            self.dataCachePL = dict["DataCachePL"] as! String
        }
        if dict.keys.contains("DataCacheProvisionedIops") {
            self.dataCacheProvisionedIops = dict["DataCacheProvisionedIops"] as! Int32
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DnsConfigNameServers") {
            self.dnsConfigNameServers = dict["DnsConfigNameServers"] as! [String]
        }
        if dict.keys.contains("DnsConfigOptions") {
            var tmp : [CreateEciScalingConfigurationRequest.DnsConfigOptions] = []
            for v in dict["DnsConfigOptions"] as! [Any] {
                var model = CreateEciScalingConfigurationRequest.DnsConfigOptions()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.dnsConfigOptions = tmp
        }
        if dict.keys.contains("DnsConfigSearchs") {
            self.dnsConfigSearchs = dict["DnsConfigSearchs"] as! [String]
        }
        if dict.keys.contains("DnsPolicy") {
            self.dnsPolicy = dict["DnsPolicy"] as! String
        }
        if dict.keys.contains("EgressBandwidth") {
            self.egressBandwidth = dict["EgressBandwidth"] as! Int64
        }
        if dict.keys.contains("EipBandwidth") {
            self.eipBandwidth = dict["EipBandwidth"] as! Int32
        }
        if dict.keys.contains("EnableSls") {
            self.enableSls = dict["EnableSls"] as! Bool
        }
        if dict.keys.contains("EphemeralStorage") {
            self.ephemeralStorage = dict["EphemeralStorage"] as! Int32
        }
        if dict.keys.contains("GpuDriverVersion") {
            self.gpuDriverVersion = dict["GpuDriverVersion"] as! String
        }
        if dict.keys.contains("HostAliases") {
            var tmp : [CreateEciScalingConfigurationRequest.HostAliases] = []
            for v in dict["HostAliases"] as! [Any] {
                var model = CreateEciScalingConfigurationRequest.HostAliases()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.hostAliases = tmp
        }
        if dict.keys.contains("HostName") {
            self.hostName = dict["HostName"] as! String
        }
        if dict.keys.contains("ImageRegistryCredentials") {
            var tmp : [CreateEciScalingConfigurationRequest.ImageRegistryCredentials] = []
            for v in dict["ImageRegistryCredentials"] as! [Any] {
                var model = CreateEciScalingConfigurationRequest.ImageRegistryCredentials()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.imageRegistryCredentials = tmp
        }
        if dict.keys.contains("ImageSnapshotId") {
            self.imageSnapshotId = dict["ImageSnapshotId"] as! String
        }
        if dict.keys.contains("IngressBandwidth") {
            self.ingressBandwidth = dict["IngressBandwidth"] as! Int64
        }
        if dict.keys.contains("InitContainers") {
            var tmp : [CreateEciScalingConfigurationRequest.InitContainers] = []
            for v in dict["InitContainers"] as! [Any] {
                var model = CreateEciScalingConfigurationRequest.InitContainers()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.initContainers = tmp
        }
        if dict.keys.contains("InstanceFamilyLevel") {
            self.instanceFamilyLevel = dict["InstanceFamilyLevel"] as! String
        }
        if dict.keys.contains("InstanceTypes") {
            self.instanceTypes = dict["InstanceTypes"] as! [String]
        }
        if dict.keys.contains("Ipv6AddressCount") {
            self.ipv6AddressCount = dict["Ipv6AddressCount"] as! Int32
        }
        if dict.keys.contains("LoadBalancerWeight") {
            self.loadBalancerWeight = dict["LoadBalancerWeight"] as! Int32
        }
        if dict.keys.contains("Memory") {
            self.memory = dict["Memory"] as! Double
        }
        if dict.keys.contains("NtpServers") {
            self.ntpServers = dict["NtpServers"] as! [String]
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RamRoleName") {
            self.ramRoleName = dict["RamRoleName"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("RestartPolicy") {
            self.restartPolicy = dict["RestartPolicy"] as! String
        }
        if dict.keys.contains("ScalingConfigurationName") {
            self.scalingConfigurationName = dict["ScalingConfigurationName"] as! String
        }
        if dict.keys.contains("ScalingGroupId") {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
        if dict.keys.contains("SecurityContextSysctls") {
            var tmp : [CreateEciScalingConfigurationRequest.SecurityContextSysctls] = []
            for v in dict["SecurityContextSysctls"] as! [Any] {
                var model = CreateEciScalingConfigurationRequest.SecurityContextSysctls()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.securityContextSysctls = tmp
        }
        if dict.keys.contains("SecurityGroupId") {
            self.securityGroupId = dict["SecurityGroupId"] as! String
        }
        if dict.keys.contains("SpotPriceLimit") {
            self.spotPriceLimit = dict["SpotPriceLimit"] as! Double
        }
        if dict.keys.contains("SpotStrategy") {
            self.spotStrategy = dict["SpotStrategy"] as! String
        }
        if dict.keys.contains("Tags") {
            var tmp : [CreateEciScalingConfigurationRequest.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = CreateEciScalingConfigurationRequest.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
        if dict.keys.contains("TerminationGracePeriodSeconds") {
            self.terminationGracePeriodSeconds = dict["TerminationGracePeriodSeconds"] as! Int64
        }
        if dict.keys.contains("Volumes") {
            var tmp : [CreateEciScalingConfigurationRequest.Volumes] = []
            for v in dict["Volumes"] as! [Any] {
                var model = CreateEciScalingConfigurationRequest.Volumes()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.volumes = tmp
        }
    }
}

public class CreateEciScalingConfigurationResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var scalingConfigurationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingConfigurationId != nil {
            map["ScalingConfigurationId"] = self.scalingConfigurationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScalingConfigurationId") {
            self.scalingConfigurationId = dict["ScalingConfigurationId"] as! String
        }
    }
}

public class CreateEciScalingConfigurationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateEciScalingConfigurationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateEciScalingConfigurationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateLifecycleHookRequest : Tea.TeaModel {
    public var defaultResult: String?

    public var heartbeatTimeout: Int32?

    public var lifecycleHookName: String?

    public var lifecycleTransition: String?

    public var notificationArn: String?

    public var notificationMetadata: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.defaultResult != nil {
            map["DefaultResult"] = self.defaultResult!
        }
        if self.heartbeatTimeout != nil {
            map["HeartbeatTimeout"] = self.heartbeatTimeout!
        }
        if self.lifecycleHookName != nil {
            map["LifecycleHookName"] = self.lifecycleHookName!
        }
        if self.lifecycleTransition != nil {
            map["LifecycleTransition"] = self.lifecycleTransition!
        }
        if self.notificationArn != nil {
            map["NotificationArn"] = self.notificationArn!
        }
        if self.notificationMetadata != nil {
            map["NotificationMetadata"] = self.notificationMetadata!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DefaultResult") {
            self.defaultResult = dict["DefaultResult"] as! String
        }
        if dict.keys.contains("HeartbeatTimeout") {
            self.heartbeatTimeout = dict["HeartbeatTimeout"] as! Int32
        }
        if dict.keys.contains("LifecycleHookName") {
            self.lifecycleHookName = dict["LifecycleHookName"] as! String
        }
        if dict.keys.contains("LifecycleTransition") {
            self.lifecycleTransition = dict["LifecycleTransition"] as! String
        }
        if dict.keys.contains("NotificationArn") {
            self.notificationArn = dict["NotificationArn"] as! String
        }
        if dict.keys.contains("NotificationMetadata") {
            self.notificationMetadata = dict["NotificationMetadata"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScalingGroupId") {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
    }
}

public class CreateLifecycleHookResponseBody : Tea.TeaModel {
    public var lifecycleHookId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lifecycleHookId != nil {
            map["LifecycleHookId"] = self.lifecycleHookId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LifecycleHookId") {
            self.lifecycleHookId = dict["LifecycleHookId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateLifecycleHookResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateLifecycleHookResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateLifecycleHookResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateNotificationConfigurationRequest : Tea.TeaModel {
    public var notificationArn: String?

    public var notificationTypes: [String]?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public var timeZone: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.notificationArn != nil {
            map["NotificationArn"] = self.notificationArn!
        }
        if self.notificationTypes != nil {
            map["NotificationTypes"] = self.notificationTypes!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        if self.timeZone != nil {
            map["TimeZone"] = self.timeZone!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NotificationArn") {
            self.notificationArn = dict["NotificationArn"] as! String
        }
        if dict.keys.contains("NotificationTypes") {
            self.notificationTypes = dict["NotificationTypes"] as! [String]
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScalingGroupId") {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
        if dict.keys.contains("TimeZone") {
            self.timeZone = dict["TimeZone"] as! String
        }
    }
}

public class CreateNotificationConfigurationResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateNotificationConfigurationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateNotificationConfigurationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateNotificationConfigurationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateScalingConfigurationRequest : Tea.TeaModel {
    public class ImageOptions : Tea.TeaModel {
        public var loginAsNonRoot: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.loginAsNonRoot != nil {
                map["LoginAsNonRoot"] = self.loginAsNonRoot!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LoginAsNonRoot") {
                self.loginAsNonRoot = dict["LoginAsNonRoot"] as! Bool
            }
        }
    }
    public class PrivatePoolOptions : Tea.TeaModel {
        public var id: String?

        public var matchCriteria: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.matchCriteria != nil {
                map["MatchCriteria"] = self.matchCriteria!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("MatchCriteria") {
                self.matchCriteria = dict["MatchCriteria"] as! String
            }
        }
    }
    public class SystemDisk : Tea.TeaModel {
        public var autoSnapshotPolicyId: String?

        public var burstingEnabled: Bool?

        public var category: String?

        public var description_: String?

        public var diskName: String?

        public var encryptAlgorithm: String?

        public var encrypted: Bool?

        public var KMSKeyId: String?

        public var performanceLevel: String?

        public var provisionedIops: Int64?

        public var size: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.autoSnapshotPolicyId != nil {
                map["AutoSnapshotPolicyId"] = self.autoSnapshotPolicyId!
            }
            if self.burstingEnabled != nil {
                map["BurstingEnabled"] = self.burstingEnabled!
            }
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.diskName != nil {
                map["DiskName"] = self.diskName!
            }
            if self.encryptAlgorithm != nil {
                map["EncryptAlgorithm"] = self.encryptAlgorithm!
            }
            if self.encrypted != nil {
                map["Encrypted"] = self.encrypted!
            }
            if self.KMSKeyId != nil {
                map["KMSKeyId"] = self.KMSKeyId!
            }
            if self.performanceLevel != nil {
                map["PerformanceLevel"] = self.performanceLevel!
            }
            if self.provisionedIops != nil {
                map["ProvisionedIops"] = self.provisionedIops!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AutoSnapshotPolicyId") {
                self.autoSnapshotPolicyId = dict["AutoSnapshotPolicyId"] as! String
            }
            if dict.keys.contains("BurstingEnabled") {
                self.burstingEnabled = dict["BurstingEnabled"] as! Bool
            }
            if dict.keys.contains("Category") {
                self.category = dict["Category"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("DiskName") {
                self.diskName = dict["DiskName"] as! String
            }
            if dict.keys.contains("EncryptAlgorithm") {
                self.encryptAlgorithm = dict["EncryptAlgorithm"] as! String
            }
            if dict.keys.contains("Encrypted") {
                self.encrypted = dict["Encrypted"] as! Bool
            }
            if dict.keys.contains("KMSKeyId") {
                self.KMSKeyId = dict["KMSKeyId"] as! String
            }
            if dict.keys.contains("PerformanceLevel") {
                self.performanceLevel = dict["PerformanceLevel"] as! String
            }
            if dict.keys.contains("ProvisionedIops") {
                self.provisionedIops = dict["ProvisionedIops"] as! Int64
            }
            if dict.keys.contains("Size") {
                self.size = dict["Size"] as! Int32
            }
        }
    }
    public class CustomPriorities : Tea.TeaModel {
        public var instanceType: String?

        public var vswitchId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.vswitchId != nil {
                map["VswitchId"] = self.vswitchId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceType") {
                self.instanceType = dict["InstanceType"] as! String
            }
            if dict.keys.contains("VswitchId") {
                self.vswitchId = dict["VswitchId"] as! String
            }
        }
    }
    public class DataDisks : Tea.TeaModel {
        public var autoSnapshotPolicyId: String?

        public var burstingEnabled: Bool?

        public var categories: [String]?

        public var category: String?

        public var deleteWithInstance: Bool?

        public var description_: String?

        public var device: String?

        public var diskName: String?

        public var encrypted: String?

        public var KMSKeyId: String?

        public var performanceLevel: String?

        public var provisionedIops: Int64?

        public var size: Int32?

        public var snapshotId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.autoSnapshotPolicyId != nil {
                map["AutoSnapshotPolicyId"] = self.autoSnapshotPolicyId!
            }
            if self.burstingEnabled != nil {
                map["BurstingEnabled"] = self.burstingEnabled!
            }
            if self.categories != nil {
                map["Categories"] = self.categories!
            }
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.deleteWithInstance != nil {
                map["DeleteWithInstance"] = self.deleteWithInstance!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.device != nil {
                map["Device"] = self.device!
            }
            if self.diskName != nil {
                map["DiskName"] = self.diskName!
            }
            if self.encrypted != nil {
                map["Encrypted"] = self.encrypted!
            }
            if self.KMSKeyId != nil {
                map["KMSKeyId"] = self.KMSKeyId!
            }
            if self.performanceLevel != nil {
                map["PerformanceLevel"] = self.performanceLevel!
            }
            if self.provisionedIops != nil {
                map["ProvisionedIops"] = self.provisionedIops!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.snapshotId != nil {
                map["SnapshotId"] = self.snapshotId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AutoSnapshotPolicyId") {
                self.autoSnapshotPolicyId = dict["AutoSnapshotPolicyId"] as! String
            }
            if dict.keys.contains("BurstingEnabled") {
                self.burstingEnabled = dict["BurstingEnabled"] as! Bool
            }
            if dict.keys.contains("Categories") {
                self.categories = dict["Categories"] as! [String]
            }
            if dict.keys.contains("Category") {
                self.category = dict["Category"] as! String
            }
            if dict.keys.contains("DeleteWithInstance") {
                self.deleteWithInstance = dict["DeleteWithInstance"] as! Bool
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Device") {
                self.device = dict["Device"] as! String
            }
            if dict.keys.contains("DiskName") {
                self.diskName = dict["DiskName"] as! String
            }
            if dict.keys.contains("Encrypted") {
                self.encrypted = dict["Encrypted"] as! String
            }
            if dict.keys.contains("KMSKeyId") {
                self.KMSKeyId = dict["KMSKeyId"] as! String
            }
            if dict.keys.contains("PerformanceLevel") {
                self.performanceLevel = dict["PerformanceLevel"] as! String
            }
            if dict.keys.contains("ProvisionedIops") {
                self.provisionedIops = dict["ProvisionedIops"] as! Int64
            }
            if dict.keys.contains("Size") {
                self.size = dict["Size"] as! Int32
            }
            if dict.keys.contains("SnapshotId") {
                self.snapshotId = dict["SnapshotId"] as! String
            }
        }
    }
    public class InstancePatternInfos : Tea.TeaModel {
        public var architectures: [String]?

        public var burstablePerformance: String?

        public var cores: Int32?

        public var cpuArchitectures: [String]?

        public var excludedInstanceTypes: [String]?

        public var gpuSpecs: [String]?

        public var instanceCategories: [String]?

        public var instanceFamilyLevel: String?

        public var instanceTypeFamilies: [String]?

        public var maxPrice: Double?

        public var maximumCpuCoreCount: Int32?

        public var maximumGpuAmount: Int32?

        public var maximumMemorySize: Double?

        public var memory: Double?

        public var minimumBaselineCredit: Int32?

        public var minimumCpuCoreCount: Int32?

        public var minimumEniIpv6AddressQuantity: Int32?

        public var minimumEniPrivateIpAddressQuantity: Int32?

        public var minimumEniQuantity: Int32?

        public var minimumGpuAmount: Int32?

        public var minimumInitialCredit: Int32?

        public var minimumMemorySize: Double?

        public var physicalProcessorModels: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.architectures != nil {
                map["Architectures"] = self.architectures!
            }
            if self.burstablePerformance != nil {
                map["BurstablePerformance"] = self.burstablePerformance!
            }
            if self.cores != nil {
                map["Cores"] = self.cores!
            }
            if self.cpuArchitectures != nil {
                map["CpuArchitectures"] = self.cpuArchitectures!
            }
            if self.excludedInstanceTypes != nil {
                map["ExcludedInstanceTypes"] = self.excludedInstanceTypes!
            }
            if self.gpuSpecs != nil {
                map["GpuSpecs"] = self.gpuSpecs!
            }
            if self.instanceCategories != nil {
                map["InstanceCategories"] = self.instanceCategories!
            }
            if self.instanceFamilyLevel != nil {
                map["InstanceFamilyLevel"] = self.instanceFamilyLevel!
            }
            if self.instanceTypeFamilies != nil {
                map["InstanceTypeFamilies"] = self.instanceTypeFamilies!
            }
            if self.maxPrice != nil {
                map["MaxPrice"] = self.maxPrice!
            }
            if self.maximumCpuCoreCount != nil {
                map["MaximumCpuCoreCount"] = self.maximumCpuCoreCount!
            }
            if self.maximumGpuAmount != nil {
                map["MaximumGpuAmount"] = self.maximumGpuAmount!
            }
            if self.maximumMemorySize != nil {
                map["MaximumMemorySize"] = self.maximumMemorySize!
            }
            if self.memory != nil {
                map["Memory"] = self.memory!
            }
            if self.minimumBaselineCredit != nil {
                map["MinimumBaselineCredit"] = self.minimumBaselineCredit!
            }
            if self.minimumCpuCoreCount != nil {
                map["MinimumCpuCoreCount"] = self.minimumCpuCoreCount!
            }
            if self.minimumEniIpv6AddressQuantity != nil {
                map["MinimumEniIpv6AddressQuantity"] = self.minimumEniIpv6AddressQuantity!
            }
            if self.minimumEniPrivateIpAddressQuantity != nil {
                map["MinimumEniPrivateIpAddressQuantity"] = self.minimumEniPrivateIpAddressQuantity!
            }
            if self.minimumEniQuantity != nil {
                map["MinimumEniQuantity"] = self.minimumEniQuantity!
            }
            if self.minimumGpuAmount != nil {
                map["MinimumGpuAmount"] = self.minimumGpuAmount!
            }
            if self.minimumInitialCredit != nil {
                map["MinimumInitialCredit"] = self.minimumInitialCredit!
            }
            if self.minimumMemorySize != nil {
                map["MinimumMemorySize"] = self.minimumMemorySize!
            }
            if self.physicalProcessorModels != nil {
                map["PhysicalProcessorModels"] = self.physicalProcessorModels!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Architectures") {
                self.architectures = dict["Architectures"] as! [String]
            }
            if dict.keys.contains("BurstablePerformance") {
                self.burstablePerformance = dict["BurstablePerformance"] as! String
            }
            if dict.keys.contains("Cores") {
                self.cores = dict["Cores"] as! Int32
            }
            if dict.keys.contains("CpuArchitectures") {
                self.cpuArchitectures = dict["CpuArchitectures"] as! [String]
            }
            if dict.keys.contains("ExcludedInstanceTypes") {
                self.excludedInstanceTypes = dict["ExcludedInstanceTypes"] as! [String]
            }
            if dict.keys.contains("GpuSpecs") {
                self.gpuSpecs = dict["GpuSpecs"] as! [String]
            }
            if dict.keys.contains("InstanceCategories") {
                self.instanceCategories = dict["InstanceCategories"] as! [String]
            }
            if dict.keys.contains("InstanceFamilyLevel") {
                self.instanceFamilyLevel = dict["InstanceFamilyLevel"] as! String
            }
            if dict.keys.contains("InstanceTypeFamilies") {
                self.instanceTypeFamilies = dict["InstanceTypeFamilies"] as! [String]
            }
            if dict.keys.contains("MaxPrice") {
                self.maxPrice = dict["MaxPrice"] as! Double
            }
            if dict.keys.contains("MaximumCpuCoreCount") {
                self.maximumCpuCoreCount = dict["MaximumCpuCoreCount"] as! Int32
            }
            if dict.keys.contains("MaximumGpuAmount") {
                self.maximumGpuAmount = dict["MaximumGpuAmount"] as! Int32
            }
            if dict.keys.contains("MaximumMemorySize") {
                self.maximumMemorySize = dict["MaximumMemorySize"] as! Double
            }
            if dict.keys.contains("Memory") {
                self.memory = dict["Memory"] as! Double
            }
            if dict.keys.contains("MinimumBaselineCredit") {
                self.minimumBaselineCredit = dict["MinimumBaselineCredit"] as! Int32
            }
            if dict.keys.contains("MinimumCpuCoreCount") {
                self.minimumCpuCoreCount = dict["MinimumCpuCoreCount"] as! Int32
            }
            if dict.keys.contains("MinimumEniIpv6AddressQuantity") {
                self.minimumEniIpv6AddressQuantity = dict["MinimumEniIpv6AddressQuantity"] as! Int32
            }
            if dict.keys.contains("MinimumEniPrivateIpAddressQuantity") {
                self.minimumEniPrivateIpAddressQuantity = dict["MinimumEniPrivateIpAddressQuantity"] as! Int32
            }
            if dict.keys.contains("MinimumEniQuantity") {
                self.minimumEniQuantity = dict["MinimumEniQuantity"] as! Int32
            }
            if dict.keys.contains("MinimumGpuAmount") {
                self.minimumGpuAmount = dict["MinimumGpuAmount"] as! Int32
            }
            if dict.keys.contains("MinimumInitialCredit") {
                self.minimumInitialCredit = dict["MinimumInitialCredit"] as! Int32
            }
            if dict.keys.contains("MinimumMemorySize") {
                self.minimumMemorySize = dict["MinimumMemorySize"] as! Double
            }
            if dict.keys.contains("PhysicalProcessorModels") {
                self.physicalProcessorModels = dict["PhysicalProcessorModels"] as! [String]
            }
        }
    }
    public class InstanceTypeOverrides : Tea.TeaModel {
        public var instanceType: String?

        public var weightedCapacity: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.weightedCapacity != nil {
                map["WeightedCapacity"] = self.weightedCapacity!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceType") {
                self.instanceType = dict["InstanceType"] as! String
            }
            if dict.keys.contains("WeightedCapacity") {
                self.weightedCapacity = dict["WeightedCapacity"] as! Int32
            }
        }
    }
    public class NetworkInterfaces : Tea.TeaModel {
        public var instanceType: String?

        public var ipv6AddressCount: Int32?

        public var networkInterfaceTrafficMode: String?

        public var securityGroupIds: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.ipv6AddressCount != nil {
                map["Ipv6AddressCount"] = self.ipv6AddressCount!
            }
            if self.networkInterfaceTrafficMode != nil {
                map["NetworkInterfaceTrafficMode"] = self.networkInterfaceTrafficMode!
            }
            if self.securityGroupIds != nil {
                map["SecurityGroupIds"] = self.securityGroupIds!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceType") {
                self.instanceType = dict["InstanceType"] as! String
            }
            if dict.keys.contains("Ipv6AddressCount") {
                self.ipv6AddressCount = dict["Ipv6AddressCount"] as! Int32
            }
            if dict.keys.contains("NetworkInterfaceTrafficMode") {
                self.networkInterfaceTrafficMode = dict["NetworkInterfaceTrafficMode"] as! String
            }
            if dict.keys.contains("SecurityGroupIds") {
                self.securityGroupIds = dict["SecurityGroupIds"] as! [String]
            }
        }
    }
    public class SecurityOptions : Tea.TeaModel {
        public var confidentialComputingMode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.confidentialComputingMode != nil {
                map["ConfidentialComputingMode"] = self.confidentialComputingMode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConfidentialComputingMode") {
                self.confidentialComputingMode = dict["ConfidentialComputingMode"] as! String
            }
        }
    }
    public class SpotPriceLimits : Tea.TeaModel {
        public var instanceType: String?

        public var priceLimit: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.priceLimit != nil {
                map["PriceLimit"] = self.priceLimit!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceType") {
                self.instanceType = dict["InstanceType"] as! String
            }
            if dict.keys.contains("PriceLimit") {
                self.priceLimit = dict["PriceLimit"] as! Double
            }
        }
    }
    public var imageOptions: CreateScalingConfigurationRequest.ImageOptions?

    public var privatePoolOptions: CreateScalingConfigurationRequest.PrivatePoolOptions?

    public var systemDisk: CreateScalingConfigurationRequest.SystemDisk?

    public var affinity: String?

    public var clientToken: String?

    public var cpu: Int32?

    public var creditSpecification: String?

    public var customPriorities: [CreateScalingConfigurationRequest.CustomPriorities]?

    public var dataDisks: [CreateScalingConfigurationRequest.DataDisks]?

    public var dedicatedHostClusterId: String?

    public var dedicatedHostId: String?

    public var deletionProtection: Bool?

    public var deploymentSetId: String?

    public var hostName: String?

    public var hpcClusterId: String?

    public var httpEndpoint: String?

    public var httpTokens: String?

    public var imageFamily: String?

    public var imageId: String?

    public var imageName: String?

    public var instanceDescription: String?

    public var instanceName: String?

    public var instancePatternInfos: [CreateScalingConfigurationRequest.InstancePatternInfos]?

    public var instanceType: String?

    public var instanceTypeOverrides: [CreateScalingConfigurationRequest.InstanceTypeOverrides]?

    public var instanceTypes: [String]?

    public var internetChargeType: String?

    public var internetMaxBandwidthIn: Int32?

    public var internetMaxBandwidthOut: Int32?

    public var ioOptimized: String?

    public var ipv6AddressCount: Int32?

    public var keyPairName: String?

    public var loadBalancerWeight: Int32?

    public var memory: Int32?

    public var networkInterfaces: [CreateScalingConfigurationRequest.NetworkInterfaces]?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var password: String?

    public var passwordInherit: Bool?

    public var ramRoleName: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var scalingConfigurationName: String?

    public var scalingGroupId: String?

    public var schedulerOptions: [String: Any]?

    public var securityEnhancementStrategy: String?

    public var securityGroupId: String?

    public var securityGroupIds: [String]?

    public var securityOptions: CreateScalingConfigurationRequest.SecurityOptions?

    public var spotDuration: Int32?

    public var spotInterruptionBehavior: String?

    public var spotPriceLimits: [CreateScalingConfigurationRequest.SpotPriceLimits]?

    public var spotStrategy: String?

    public var storageSetId: String?

    public var storageSetPartitionNumber: Int32?

    public var systemDiskCategories: [String]?

    public var tags: String?

    public var tenancy: String?

    public var userData: String?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.imageOptions?.validate()
        try self.privatePoolOptions?.validate()
        try self.systemDisk?.validate()
        try self.securityOptions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imageOptions != nil {
            map["ImageOptions"] = self.imageOptions?.toMap()
        }
        if self.privatePoolOptions != nil {
            map["PrivatePoolOptions"] = self.privatePoolOptions?.toMap()
        }
        if self.systemDisk != nil {
            map["SystemDisk"] = self.systemDisk?.toMap()
        }
        if self.affinity != nil {
            map["Affinity"] = self.affinity!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.cpu != nil {
            map["Cpu"] = self.cpu!
        }
        if self.creditSpecification != nil {
            map["CreditSpecification"] = self.creditSpecification!
        }
        if self.customPriorities != nil {
            var tmp : [Any] = []
            for k in self.customPriorities! {
                tmp.append(k.toMap())
            }
            map["CustomPriorities"] = tmp
        }
        if self.dataDisks != nil {
            var tmp : [Any] = []
            for k in self.dataDisks! {
                tmp.append(k.toMap())
            }
            map["DataDisks"] = tmp
        }
        if self.dedicatedHostClusterId != nil {
            map["DedicatedHostClusterId"] = self.dedicatedHostClusterId!
        }
        if self.dedicatedHostId != nil {
            map["DedicatedHostId"] = self.dedicatedHostId!
        }
        if self.deletionProtection != nil {
            map["DeletionProtection"] = self.deletionProtection!
        }
        if self.deploymentSetId != nil {
            map["DeploymentSetId"] = self.deploymentSetId!
        }
        if self.hostName != nil {
            map["HostName"] = self.hostName!
        }
        if self.hpcClusterId != nil {
            map["HpcClusterId"] = self.hpcClusterId!
        }
        if self.httpEndpoint != nil {
            map["HttpEndpoint"] = self.httpEndpoint!
        }
        if self.httpTokens != nil {
            map["HttpTokens"] = self.httpTokens!
        }
        if self.imageFamily != nil {
            map["ImageFamily"] = self.imageFamily!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.imageName != nil {
            map["ImageName"] = self.imageName!
        }
        if self.instanceDescription != nil {
            map["InstanceDescription"] = self.instanceDescription!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.instancePatternInfos != nil {
            var tmp : [Any] = []
            for k in self.instancePatternInfos! {
                tmp.append(k.toMap())
            }
            map["InstancePatternInfos"] = tmp
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.instanceTypeOverrides != nil {
            var tmp : [Any] = []
            for k in self.instanceTypeOverrides! {
                tmp.append(k.toMap())
            }
            map["InstanceTypeOverrides"] = tmp
        }
        if self.instanceTypes != nil {
            map["InstanceTypes"] = self.instanceTypes!
        }
        if self.internetChargeType != nil {
            map["InternetChargeType"] = self.internetChargeType!
        }
        if self.internetMaxBandwidthIn != nil {
            map["InternetMaxBandwidthIn"] = self.internetMaxBandwidthIn!
        }
        if self.internetMaxBandwidthOut != nil {
            map["InternetMaxBandwidthOut"] = self.internetMaxBandwidthOut!
        }
        if self.ioOptimized != nil {
            map["IoOptimized"] = self.ioOptimized!
        }
        if self.ipv6AddressCount != nil {
            map["Ipv6AddressCount"] = self.ipv6AddressCount!
        }
        if self.keyPairName != nil {
            map["KeyPairName"] = self.keyPairName!
        }
        if self.loadBalancerWeight != nil {
            map["LoadBalancerWeight"] = self.loadBalancerWeight!
        }
        if self.memory != nil {
            map["Memory"] = self.memory!
        }
        if self.networkInterfaces != nil {
            var tmp : [Any] = []
            for k in self.networkInterfaces! {
                tmp.append(k.toMap())
            }
            map["NetworkInterfaces"] = tmp
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        if self.passwordInherit != nil {
            map["PasswordInherit"] = self.passwordInherit!
        }
        if self.ramRoleName != nil {
            map["RamRoleName"] = self.ramRoleName!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingConfigurationName != nil {
            map["ScalingConfigurationName"] = self.scalingConfigurationName!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        if self.schedulerOptions != nil {
            map["SchedulerOptions"] = self.schedulerOptions!
        }
        if self.securityEnhancementStrategy != nil {
            map["SecurityEnhancementStrategy"] = self.securityEnhancementStrategy!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.securityGroupIds != nil {
            map["SecurityGroupIds"] = self.securityGroupIds!
        }
        if self.securityOptions != nil {
            map["SecurityOptions"] = self.securityOptions?.toMap()
        }
        if self.spotDuration != nil {
            map["SpotDuration"] = self.spotDuration!
        }
        if self.spotInterruptionBehavior != nil {
            map["SpotInterruptionBehavior"] = self.spotInterruptionBehavior!
        }
        if self.spotPriceLimits != nil {
            var tmp : [Any] = []
            for k in self.spotPriceLimits! {
                tmp.append(k.toMap())
            }
            map["SpotPriceLimits"] = tmp
        }
        if self.spotStrategy != nil {
            map["SpotStrategy"] = self.spotStrategy!
        }
        if self.storageSetId != nil {
            map["StorageSetId"] = self.storageSetId!
        }
        if self.storageSetPartitionNumber != nil {
            map["StorageSetPartitionNumber"] = self.storageSetPartitionNumber!
        }
        if self.systemDiskCategories != nil {
            map["SystemDiskCategories"] = self.systemDiskCategories!
        }
        if self.tags != nil {
            map["Tags"] = self.tags!
        }
        if self.tenancy != nil {
            map["Tenancy"] = self.tenancy!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ImageOptions") {
            var model = CreateScalingConfigurationRequest.ImageOptions()
            model.fromMap(dict["ImageOptions"] as! [String: Any])
            self.imageOptions = model
        }
        if dict.keys.contains("PrivatePoolOptions") {
            var model = CreateScalingConfigurationRequest.PrivatePoolOptions()
            model.fromMap(dict["PrivatePoolOptions"] as! [String: Any])
            self.privatePoolOptions = model
        }
        if dict.keys.contains("SystemDisk") {
            var model = CreateScalingConfigurationRequest.SystemDisk()
            model.fromMap(dict["SystemDisk"] as! [String: Any])
            self.systemDisk = model
        }
        if dict.keys.contains("Affinity") {
            self.affinity = dict["Affinity"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Cpu") {
            self.cpu = dict["Cpu"] as! Int32
        }
        if dict.keys.contains("CreditSpecification") {
            self.creditSpecification = dict["CreditSpecification"] as! String
        }
        if dict.keys.contains("CustomPriorities") {
            var tmp : [CreateScalingConfigurationRequest.CustomPriorities] = []
            for v in dict["CustomPriorities"] as! [Any] {
                var model = CreateScalingConfigurationRequest.CustomPriorities()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.customPriorities = tmp
        }
        if dict.keys.contains("DataDisks") {
            var tmp : [CreateScalingConfigurationRequest.DataDisks] = []
            for v in dict["DataDisks"] as! [Any] {
                var model = CreateScalingConfigurationRequest.DataDisks()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.dataDisks = tmp
        }
        if dict.keys.contains("DedicatedHostClusterId") {
            self.dedicatedHostClusterId = dict["DedicatedHostClusterId"] as! String
        }
        if dict.keys.contains("DedicatedHostId") {
            self.dedicatedHostId = dict["DedicatedHostId"] as! String
        }
        if dict.keys.contains("DeletionProtection") {
            self.deletionProtection = dict["DeletionProtection"] as! Bool
        }
        if dict.keys.contains("DeploymentSetId") {
            self.deploymentSetId = dict["DeploymentSetId"] as! String
        }
        if dict.keys.contains("HostName") {
            self.hostName = dict["HostName"] as! String
        }
        if dict.keys.contains("HpcClusterId") {
            self.hpcClusterId = dict["HpcClusterId"] as! String
        }
        if dict.keys.contains("HttpEndpoint") {
            self.httpEndpoint = dict["HttpEndpoint"] as! String
        }
        if dict.keys.contains("HttpTokens") {
            self.httpTokens = dict["HttpTokens"] as! String
        }
        if dict.keys.contains("ImageFamily") {
            self.imageFamily = dict["ImageFamily"] as! String
        }
        if dict.keys.contains("ImageId") {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("ImageName") {
            self.imageName = dict["ImageName"] as! String
        }
        if dict.keys.contains("InstanceDescription") {
            self.instanceDescription = dict["InstanceDescription"] as! String
        }
        if dict.keys.contains("InstanceName") {
            self.instanceName = dict["InstanceName"] as! String
        }
        if dict.keys.contains("InstancePatternInfos") {
            var tmp : [CreateScalingConfigurationRequest.InstancePatternInfos] = []
            for v in dict["InstancePatternInfos"] as! [Any] {
                var model = CreateScalingConfigurationRequest.InstancePatternInfos()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.instancePatternInfos = tmp
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("InstanceTypeOverrides") {
            var tmp : [CreateScalingConfigurationRequest.InstanceTypeOverrides] = []
            for v in dict["InstanceTypeOverrides"] as! [Any] {
                var model = CreateScalingConfigurationRequest.InstanceTypeOverrides()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.instanceTypeOverrides = tmp
        }
        if dict.keys.contains("InstanceTypes") {
            self.instanceTypes = dict["InstanceTypes"] as! [String]
        }
        if dict.keys.contains("InternetChargeType") {
            self.internetChargeType = dict["InternetChargeType"] as! String
        }
        if dict.keys.contains("InternetMaxBandwidthIn") {
            self.internetMaxBandwidthIn = dict["InternetMaxBandwidthIn"] as! Int32
        }
        if dict.keys.contains("InternetMaxBandwidthOut") {
            self.internetMaxBandwidthOut = dict["InternetMaxBandwidthOut"] as! Int32
        }
        if dict.keys.contains("IoOptimized") {
            self.ioOptimized = dict["IoOptimized"] as! String
        }
        if dict.keys.contains("Ipv6AddressCount") {
            self.ipv6AddressCount = dict["Ipv6AddressCount"] as! Int32
        }
        if dict.keys.contains("KeyPairName") {
            self.keyPairName = dict["KeyPairName"] as! String
        }
        if dict.keys.contains("LoadBalancerWeight") {
            self.loadBalancerWeight = dict["LoadBalancerWeight"] as! Int32
        }
        if dict.keys.contains("Memory") {
            self.memory = dict["Memory"] as! Int32
        }
        if dict.keys.contains("NetworkInterfaces") {
            var tmp : [CreateScalingConfigurationRequest.NetworkInterfaces] = []
            for v in dict["NetworkInterfaces"] as! [Any] {
                var model = CreateScalingConfigurationRequest.NetworkInterfaces()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.networkInterfaces = tmp
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Password") {
            self.password = dict["Password"] as! String
        }
        if dict.keys.contains("PasswordInherit") {
            self.passwordInherit = dict["PasswordInherit"] as! Bool
        }
        if dict.keys.contains("RamRoleName") {
            self.ramRoleName = dict["RamRoleName"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScalingConfigurationName") {
            self.scalingConfigurationName = dict["ScalingConfigurationName"] as! String
        }
        if dict.keys.contains("ScalingGroupId") {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
        if dict.keys.contains("SchedulerOptions") {
            self.schedulerOptions = dict["SchedulerOptions"] as! [String: Any]
        }
        if dict.keys.contains("SecurityEnhancementStrategy") {
            self.securityEnhancementStrategy = dict["SecurityEnhancementStrategy"] as! String
        }
        if dict.keys.contains("SecurityGroupId") {
            self.securityGroupId = dict["SecurityGroupId"] as! String
        }
        if dict.keys.contains("SecurityGroupIds") {
            self.securityGroupIds = dict["SecurityGroupIds"] as! [String]
        }
        if dict.keys.contains("SecurityOptions") {
            var model = CreateScalingConfigurationRequest.SecurityOptions()
            model.fromMap(dict["SecurityOptions"] as! [String: Any])
            self.securityOptions = model
        }
        if dict.keys.contains("SpotDuration") {
            self.spotDuration = dict["SpotDuration"] as! Int32
        }
        if dict.keys.contains("SpotInterruptionBehavior") {
            self.spotInterruptionBehavior = dict["SpotInterruptionBehavior"] as! String
        }
        if dict.keys.contains("SpotPriceLimits") {
            var tmp : [CreateScalingConfigurationRequest.SpotPriceLimits] = []
            for v in dict["SpotPriceLimits"] as! [Any] {
                var model = CreateScalingConfigurationRequest.SpotPriceLimits()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.spotPriceLimits = tmp
        }
        if dict.keys.contains("SpotStrategy") {
            self.spotStrategy = dict["SpotStrategy"] as! String
        }
        if dict.keys.contains("StorageSetId") {
            self.storageSetId = dict["StorageSetId"] as! String
        }
        if dict.keys.contains("StorageSetPartitionNumber") {
            self.storageSetPartitionNumber = dict["StorageSetPartitionNumber"] as! Int32
        }
        if dict.keys.contains("SystemDiskCategories") {
            self.systemDiskCategories = dict["SystemDiskCategories"] as! [String]
        }
        if dict.keys.contains("Tags") {
            self.tags = dict["Tags"] as! String
        }
        if dict.keys.contains("Tenancy") {
            self.tenancy = dict["Tenancy"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! String
        }
    }
}

public class CreateScalingConfigurationShrinkRequest : Tea.TeaModel {
    public class ImageOptions : Tea.TeaModel {
        public var loginAsNonRoot: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.loginAsNonRoot != nil {
                map["LoginAsNonRoot"] = self.loginAsNonRoot!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LoginAsNonRoot") {
                self.loginAsNonRoot = dict["LoginAsNonRoot"] as! Bool
            }
        }
    }
    public class PrivatePoolOptions : Tea.TeaModel {
        public var id: String?

        public var matchCriteria: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.matchCriteria != nil {
                map["MatchCriteria"] = self.matchCriteria!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("MatchCriteria") {
                self.matchCriteria = dict["MatchCriteria"] as! String
            }
        }
    }
    public class SystemDisk : Tea.TeaModel {
        public var autoSnapshotPolicyId: String?

        public var burstingEnabled: Bool?

        public var category: String?

        public var description_: String?

        public var diskName: String?

        public var encryptAlgorithm: String?

        public var encrypted: Bool?

        public var KMSKeyId: String?

        public var performanceLevel: String?

        public var provisionedIops: Int64?

        public var size: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.autoSnapshotPolicyId != nil {
                map["AutoSnapshotPolicyId"] = self.autoSnapshotPolicyId!
            }
            if self.burstingEnabled != nil {
                map["BurstingEnabled"] = self.burstingEnabled!
            }
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.diskName != nil {
                map["DiskName"] = self.diskName!
            }
            if self.encryptAlgorithm != nil {
                map["EncryptAlgorithm"] = self.encryptAlgorithm!
            }
            if self.encrypted != nil {
                map["Encrypted"] = self.encrypted!
            }
            if self.KMSKeyId != nil {
                map["KMSKeyId"] = self.KMSKeyId!
            }
            if self.performanceLevel != nil {
                map["PerformanceLevel"] = self.performanceLevel!
            }
            if self.provisionedIops != nil {
                map["ProvisionedIops"] = self.provisionedIops!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AutoSnapshotPolicyId") {
                self.autoSnapshotPolicyId = dict["AutoSnapshotPolicyId"] as! String
            }
            if dict.keys.contains("BurstingEnabled") {
                self.burstingEnabled = dict["BurstingEnabled"] as! Bool
            }
            if dict.keys.contains("Category") {
                self.category = dict["Category"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("DiskName") {
                self.diskName = dict["DiskName"] as! String
            }
            if dict.keys.contains("EncryptAlgorithm") {
                self.encryptAlgorithm = dict["EncryptAlgorithm"] as! String
            }
            if dict.keys.contains("Encrypted") {
                self.encrypted = dict["Encrypted"] as! Bool
            }
            if dict.keys.contains("KMSKeyId") {
                self.KMSKeyId = dict["KMSKeyId"] as! String
            }
            if dict.keys.contains("PerformanceLevel") {
                self.performanceLevel = dict["PerformanceLevel"] as! String
            }
            if dict.keys.contains("ProvisionedIops") {
                self.provisionedIops = dict["ProvisionedIops"] as! Int64
            }
            if dict.keys.contains("Size") {
                self.size = dict["Size"] as! Int32
            }
        }
    }
    public class CustomPriorities : Tea.TeaModel {
        public var instanceType: String?

        public var vswitchId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.vswitchId != nil {
                map["VswitchId"] = self.vswitchId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceType") {
                self.instanceType = dict["InstanceType"] as! String
            }
            if dict.keys.contains("VswitchId") {
                self.vswitchId = dict["VswitchId"] as! String
            }
        }
    }
    public class DataDisks : Tea.TeaModel {
        public var autoSnapshotPolicyId: String?

        public var burstingEnabled: Bool?

        public var categories: [String]?

        public var category: String?

        public var deleteWithInstance: Bool?

        public var description_: String?

        public var device: String?

        public var diskName: String?

        public var encrypted: String?

        public var KMSKeyId: String?

        public var performanceLevel: String?

        public var provisionedIops: Int64?

        public var size: Int32?

        public var snapshotId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.autoSnapshotPolicyId != nil {
                map["AutoSnapshotPolicyId"] = self.autoSnapshotPolicyId!
            }
            if self.burstingEnabled != nil {
                map["BurstingEnabled"] = self.burstingEnabled!
            }
            if self.categories != nil {
                map["Categories"] = self.categories!
            }
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.deleteWithInstance != nil {
                map["DeleteWithInstance"] = self.deleteWithInstance!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.device != nil {
                map["Device"] = self.device!
            }
            if self.diskName != nil {
                map["DiskName"] = self.diskName!
            }
            if self.encrypted != nil {
                map["Encrypted"] = self.encrypted!
            }
            if self.KMSKeyId != nil {
                map["KMSKeyId"] = self.KMSKeyId!
            }
            if self.performanceLevel != nil {
                map["PerformanceLevel"] = self.performanceLevel!
            }
            if self.provisionedIops != nil {
                map["ProvisionedIops"] = self.provisionedIops!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.snapshotId != nil {
                map["SnapshotId"] = self.snapshotId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AutoSnapshotPolicyId") {
                self.autoSnapshotPolicyId = dict["AutoSnapshotPolicyId"] as! String
            }
            if dict.keys.contains("BurstingEnabled") {
                self.burstingEnabled = dict["BurstingEnabled"] as! Bool
            }
            if dict.keys.contains("Categories") {
                self.categories = dict["Categories"] as! [String]
            }
            if dict.keys.contains("Category") {
                self.category = dict["Category"] as! String
            }
            if dict.keys.contains("DeleteWithInstance") {
                self.deleteWithInstance = dict["DeleteWithInstance"] as! Bool
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Device") {
                self.device = dict["Device"] as! String
            }
            if dict.keys.contains("DiskName") {
                self.diskName = dict["DiskName"] as! String
            }
            if dict.keys.contains("Encrypted") {
                self.encrypted = dict["Encrypted"] as! String
            }
            if dict.keys.contains("KMSKeyId") {
                self.KMSKeyId = dict["KMSKeyId"] as! String
            }
            if dict.keys.contains("PerformanceLevel") {
                self.performanceLevel = dict["PerformanceLevel"] as! String
            }
            if dict.keys.contains("ProvisionedIops") {
                self.provisionedIops = dict["ProvisionedIops"] as! Int64
            }
            if dict.keys.contains("Size") {
                self.size = dict["Size"] as! Int32
            }
            if dict.keys.contains("SnapshotId") {
                self.snapshotId = dict["SnapshotId"] as! String
            }
        }
    }
    public class InstancePatternInfos : Tea.TeaModel {
        public var architectures: [String]?

        public var burstablePerformance: String?

        public var cores: Int32?

        public var cpuArchitectures: [String]?

        public var excludedInstanceTypes: [String]?

        public var gpuSpecs: [String]?

        public var instanceCategories: [String]?

        public var instanceFamilyLevel: String?

        public var instanceTypeFamilies: [String]?

        public var maxPrice: Double?

        public var maximumCpuCoreCount: Int32?

        public var maximumGpuAmount: Int32?

        public var maximumMemorySize: Double?

        public var memory: Double?

        public var minimumBaselineCredit: Int32?

        public var minimumCpuCoreCount: Int32?

        public var minimumEniIpv6AddressQuantity: Int32?

        public var minimumEniPrivateIpAddressQuantity: Int32?

        public var minimumEniQuantity: Int32?

        public var minimumGpuAmount: Int32?

        public var minimumInitialCredit: Int32?

        public var minimumMemorySize: Double?

        public var physicalProcessorModels: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.architectures != nil {
                map["Architectures"] = self.architectures!
            }
            if self.burstablePerformance != nil {
                map["BurstablePerformance"] = self.burstablePerformance!
            }
            if self.cores != nil {
                map["Cores"] = self.cores!
            }
            if self.cpuArchitectures != nil {
                map["CpuArchitectures"] = self.cpuArchitectures!
            }
            if self.excludedInstanceTypes != nil {
                map["ExcludedInstanceTypes"] = self.excludedInstanceTypes!
            }
            if self.gpuSpecs != nil {
                map["GpuSpecs"] = self.gpuSpecs!
            }
            if self.instanceCategories != nil {
                map["InstanceCategories"] = self.instanceCategories!
            }
            if self.instanceFamilyLevel != nil {
                map["InstanceFamilyLevel"] = self.instanceFamilyLevel!
            }
            if self.instanceTypeFamilies != nil {
                map["InstanceTypeFamilies"] = self.instanceTypeFamilies!
            }
            if self.maxPrice != nil {
                map["MaxPrice"] = self.maxPrice!
            }
            if self.maximumCpuCoreCount != nil {
                map["MaximumCpuCoreCount"] = self.maximumCpuCoreCount!
            }
            if self.maximumGpuAmount != nil {
                map["MaximumGpuAmount"] = self.maximumGpuAmount!
            }
            if self.maximumMemorySize != nil {
                map["MaximumMemorySize"] = self.maximumMemorySize!
            }
            if self.memory != nil {
                map["Memory"] = self.memory!
            }
            if self.minimumBaselineCredit != nil {
                map["MinimumBaselineCredit"] = self.minimumBaselineCredit!
            }
            if self.minimumCpuCoreCount != nil {
                map["MinimumCpuCoreCount"] = self.minimumCpuCoreCount!
            }
            if self.minimumEniIpv6AddressQuantity != nil {
                map["MinimumEniIpv6AddressQuantity"] = self.minimumEniIpv6AddressQuantity!
            }
            if self.minimumEniPrivateIpAddressQuantity != nil {
                map["MinimumEniPrivateIpAddressQuantity"] = self.minimumEniPrivateIpAddressQuantity!
            }
            if self.minimumEniQuantity != nil {
                map["MinimumEniQuantity"] = self.minimumEniQuantity!
            }
            if self.minimumGpuAmount != nil {
                map["MinimumGpuAmount"] = self.minimumGpuAmount!
            }
            if self.minimumInitialCredit != nil {
                map["MinimumInitialCredit"] = self.minimumInitialCredit!
            }
            if self.minimumMemorySize != nil {
                map["MinimumMemorySize"] = self.minimumMemorySize!
            }
            if self.physicalProcessorModels != nil {
                map["PhysicalProcessorModels"] = self.physicalProcessorModels!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Architectures") {
                self.architectures = dict["Architectures"] as! [String]
            }
            if dict.keys.contains("BurstablePerformance") {
                self.burstablePerformance = dict["BurstablePerformance"] as! String
            }
            if dict.keys.contains("Cores") {
                self.cores = dict["Cores"] as! Int32
            }
            if dict.keys.contains("CpuArchitectures") {
                self.cpuArchitectures = dict["CpuArchitectures"] as! [String]
            }
            if dict.keys.contains("ExcludedInstanceTypes") {
                self.excludedInstanceTypes = dict["ExcludedInstanceTypes"] as! [String]
            }
            if dict.keys.contains("GpuSpecs") {
                self.gpuSpecs = dict["GpuSpecs"] as! [String]
            }
            if dict.keys.contains("InstanceCategories") {
                self.instanceCategories = dict["InstanceCategories"] as! [String]
            }
            if dict.keys.contains("InstanceFamilyLevel") {
                self.instanceFamilyLevel = dict["InstanceFamilyLevel"] as! String
            }
            if dict.keys.contains("InstanceTypeFamilies") {
                self.instanceTypeFamilies = dict["InstanceTypeFamilies"] as! [String]
            }
            if dict.keys.contains("MaxPrice") {
                self.maxPrice = dict["MaxPrice"] as! Double
            }
            if dict.keys.contains("MaximumCpuCoreCount") {
                self.maximumCpuCoreCount = dict["MaximumCpuCoreCount"] as! Int32
            }
            if dict.keys.contains("MaximumGpuAmount") {
                self.maximumGpuAmount = dict["MaximumGpuAmount"] as! Int32
            }
            if dict.keys.contains("MaximumMemorySize") {
                self.maximumMemorySize = dict["MaximumMemorySize"] as! Double
            }
            if dict.keys.contains("Memory") {
                self.memory = dict["Memory"] as! Double
            }
            if dict.keys.contains("MinimumBaselineCredit") {
                self.minimumBaselineCredit = dict["MinimumBaselineCredit"] as! Int32
            }
            if dict.keys.contains("MinimumCpuCoreCount") {
                self.minimumCpuCoreCount = dict["MinimumCpuCoreCount"] as! Int32
            }
            if dict.keys.contains("MinimumEniIpv6AddressQuantity") {
                self.minimumEniIpv6AddressQuantity = dict["MinimumEniIpv6AddressQuantity"] as! Int32
            }
            if dict.keys.contains("MinimumEniPrivateIpAddressQuantity") {
                self.minimumEniPrivateIpAddressQuantity = dict["MinimumEniPrivateIpAddressQuantity"] as! Int32
            }
            if dict.keys.contains("MinimumEniQuantity") {
                self.minimumEniQuantity = dict["MinimumEniQuantity"] as! Int32
            }
            if dict.keys.contains("MinimumGpuAmount") {
                self.minimumGpuAmount = dict["MinimumGpuAmount"] as! Int32
            }
            if dict.keys.contains("MinimumInitialCredit") {
                self.minimumInitialCredit = dict["MinimumInitialCredit"] as! Int32
            }
            if dict.keys.contains("MinimumMemorySize") {
                self.minimumMemorySize = dict["MinimumMemorySize"] as! Double
            }
            if dict.keys.contains("PhysicalProcessorModels") {
                self.physicalProcessorModels = dict["PhysicalProcessorModels"] as! [String]
            }
        }
    }
    public class InstanceTypeOverrides : Tea.TeaModel {
        public var instanceType: String?

        public var weightedCapacity: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.weightedCapacity != nil {
                map["WeightedCapacity"] = self.weightedCapacity!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceType") {
                self.instanceType = dict["InstanceType"] as! String
            }
            if dict.keys.contains("WeightedCapacity") {
                self.weightedCapacity = dict["WeightedCapacity"] as! Int32
            }
        }
    }
    public class NetworkInterfaces : Tea.TeaModel {
        public var instanceType: String?

        public var ipv6AddressCount: Int32?

        public var networkInterfaceTrafficMode: String?

        public var securityGroupIds: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.ipv6AddressCount != nil {
                map["Ipv6AddressCount"] = self.ipv6AddressCount!
            }
            if self.networkInterfaceTrafficMode != nil {
                map["NetworkInterfaceTrafficMode"] = self.networkInterfaceTrafficMode!
            }
            if self.securityGroupIds != nil {
                map["SecurityGroupIds"] = self.securityGroupIds!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceType") {
                self.instanceType = dict["InstanceType"] as! String
            }
            if dict.keys.contains("Ipv6AddressCount") {
                self.ipv6AddressCount = dict["Ipv6AddressCount"] as! Int32
            }
            if dict.keys.contains("NetworkInterfaceTrafficMode") {
                self.networkInterfaceTrafficMode = dict["NetworkInterfaceTrafficMode"] as! String
            }
            if dict.keys.contains("SecurityGroupIds") {
                self.securityGroupIds = dict["SecurityGroupIds"] as! [String]
            }
        }
    }
    public class SecurityOptions : Tea.TeaModel {
        public var confidentialComputingMode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.confidentialComputingMode != nil {
                map["ConfidentialComputingMode"] = self.confidentialComputingMode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConfidentialComputingMode") {
                self.confidentialComputingMode = dict["ConfidentialComputingMode"] as! String
            }
        }
    }
    public class SpotPriceLimits : Tea.TeaModel {
        public var instanceType: String?

        public var priceLimit: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.priceLimit != nil {
                map["PriceLimit"] = self.priceLimit!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceType") {
                self.instanceType = dict["InstanceType"] as! String
            }
            if dict.keys.contains("PriceLimit") {
                self.priceLimit = dict["PriceLimit"] as! Double
            }
        }
    }
    public var imageOptions: CreateScalingConfigurationShrinkRequest.ImageOptions?

    public var privatePoolOptions: CreateScalingConfigurationShrinkRequest.PrivatePoolOptions?

    public var systemDisk: CreateScalingConfigurationShrinkRequest.SystemDisk?

    public var affinity: String?

    public var clientToken: String?

    public var cpu: Int32?

    public var creditSpecification: String?

    public var customPriorities: [CreateScalingConfigurationShrinkRequest.CustomPriorities]?

    public var dataDisks: [CreateScalingConfigurationShrinkRequest.DataDisks]?

    public var dedicatedHostClusterId: String?

    public var dedicatedHostId: String?

    public var deletionProtection: Bool?

    public var deploymentSetId: String?

    public var hostName: String?

    public var hpcClusterId: String?

    public var httpEndpoint: String?

    public var httpTokens: String?

    public var imageFamily: String?

    public var imageId: String?

    public var imageName: String?

    public var instanceDescription: String?

    public var instanceName: String?

    public var instancePatternInfos: [CreateScalingConfigurationShrinkRequest.InstancePatternInfos]?

    public var instanceType: String?

    public var instanceTypeOverrides: [CreateScalingConfigurationShrinkRequest.InstanceTypeOverrides]?

    public var instanceTypes: [String]?

    public var internetChargeType: String?

    public var internetMaxBandwidthIn: Int32?

    public var internetMaxBandwidthOut: Int32?

    public var ioOptimized: String?

    public var ipv6AddressCount: Int32?

    public var keyPairName: String?

    public var loadBalancerWeight: Int32?

    public var memory: Int32?

    public var networkInterfaces: [CreateScalingConfigurationShrinkRequest.NetworkInterfaces]?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var password: String?

    public var passwordInherit: Bool?

    public var ramRoleName: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var scalingConfigurationName: String?

    public var scalingGroupId: String?

    public var schedulerOptionsShrink: String?

    public var securityEnhancementStrategy: String?

    public var securityGroupId: String?

    public var securityGroupIds: [String]?

    public var securityOptions: CreateScalingConfigurationShrinkRequest.SecurityOptions?

    public var spotDuration: Int32?

    public var spotInterruptionBehavior: String?

    public var spotPriceLimits: [CreateScalingConfigurationShrinkRequest.SpotPriceLimits]?

    public var spotStrategy: String?

    public var storageSetId: String?

    public var storageSetPartitionNumber: Int32?

    public var systemDiskCategories: [String]?

    public var tags: String?

    public var tenancy: String?

    public var userData: String?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.imageOptions?.validate()
        try self.privatePoolOptions?.validate()
        try self.systemDisk?.validate()
        try self.securityOptions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imageOptions != nil {
            map["ImageOptions"] = self.imageOptions?.toMap()
        }
        if self.privatePoolOptions != nil {
            map["PrivatePoolOptions"] = self.privatePoolOptions?.toMap()
        }
        if self.systemDisk != nil {
            map["SystemDisk"] = self.systemDisk?.toMap()
        }
        if self.affinity != nil {
            map["Affinity"] = self.affinity!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.cpu != nil {
            map["Cpu"] = self.cpu!
        }
        if self.creditSpecification != nil {
            map["CreditSpecification"] = self.creditSpecification!
        }
        if self.customPriorities != nil {
            var tmp : [Any] = []
            for k in self.customPriorities! {
                tmp.append(k.toMap())
            }
            map["CustomPriorities"] = tmp
        }
        if self.dataDisks != nil {
            var tmp : [Any] = []
            for k in self.dataDisks! {
                tmp.append(k.toMap())
            }
            map["DataDisks"] = tmp
        }
        if self.dedicatedHostClusterId != nil {
            map["DedicatedHostClusterId"] = self.dedicatedHostClusterId!
        }
        if self.dedicatedHostId != nil {
            map["DedicatedHostId"] = self.dedicatedHostId!
        }
        if self.deletionProtection != nil {
            map["DeletionProtection"] = self.deletionProtection!
        }
        if self.deploymentSetId != nil {
            map["DeploymentSetId"] = self.deploymentSetId!
        }
        if self.hostName != nil {
            map["HostName"] = self.hostName!
        }
        if self.hpcClusterId != nil {
            map["HpcClusterId"] = self.hpcClusterId!
        }
        if self.httpEndpoint != nil {
            map["HttpEndpoint"] = self.httpEndpoint!
        }
        if self.httpTokens != nil {
            map["HttpTokens"] = self.httpTokens!
        }
        if self.imageFamily != nil {
            map["ImageFamily"] = self.imageFamily!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.imageName != nil {
            map["ImageName"] = self.imageName!
        }
        if self.instanceDescription != nil {
            map["InstanceDescription"] = self.instanceDescription!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.instancePatternInfos != nil {
            var tmp : [Any] = []
            for k in self.instancePatternInfos! {
                tmp.append(k.toMap())
            }
            map["InstancePatternInfos"] = tmp
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.instanceTypeOverrides != nil {
            var tmp : [Any] = []
            for k in self.instanceTypeOverrides! {
                tmp.append(k.toMap())
            }
            map["InstanceTypeOverrides"] = tmp
        }
        if self.instanceTypes != nil {
            map["InstanceTypes"] = self.instanceTypes!
        }
        if self.internetChargeType != nil {
            map["InternetChargeType"] = self.internetChargeType!
        }
        if self.internetMaxBandwidthIn != nil {
            map["InternetMaxBandwidthIn"] = self.internetMaxBandwidthIn!
        }
        if self.internetMaxBandwidthOut != nil {
            map["InternetMaxBandwidthOut"] = self.internetMaxBandwidthOut!
        }
        if self.ioOptimized != nil {
            map["IoOptimized"] = self.ioOptimized!
        }
        if self.ipv6AddressCount != nil {
            map["Ipv6AddressCount"] = self.ipv6AddressCount!
        }
        if self.keyPairName != nil {
            map["KeyPairName"] = self.keyPairName!
        }
        if self.loadBalancerWeight != nil {
            map["LoadBalancerWeight"] = self.loadBalancerWeight!
        }
        if self.memory != nil {
            map["Memory"] = self.memory!
        }
        if self.networkInterfaces != nil {
            var tmp : [Any] = []
            for k in self.networkInterfaces! {
                tmp.append(k.toMap())
            }
            map["NetworkInterfaces"] = tmp
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        if self.passwordInherit != nil {
            map["PasswordInherit"] = self.passwordInherit!
        }
        if self.ramRoleName != nil {
            map["RamRoleName"] = self.ramRoleName!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingConfigurationName != nil {
            map["ScalingConfigurationName"] = self.scalingConfigurationName!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        if self.schedulerOptionsShrink != nil {
            map["SchedulerOptions"] = self.schedulerOptionsShrink!
        }
        if self.securityEnhancementStrategy != nil {
            map["SecurityEnhancementStrategy"] = self.securityEnhancementStrategy!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.securityGroupIds != nil {
            map["SecurityGroupIds"] = self.securityGroupIds!
        }
        if self.securityOptions != nil {
            map["SecurityOptions"] = self.securityOptions?.toMap()
        }
        if self.spotDuration != nil {
            map["SpotDuration"] = self.spotDuration!
        }
        if self.spotInterruptionBehavior != nil {
            map["SpotInterruptionBehavior"] = self.spotInterruptionBehavior!
        }
        if self.spotPriceLimits != nil {
            var tmp : [Any] = []
            for k in self.spotPriceLimits! {
                tmp.append(k.toMap())
            }
            map["SpotPriceLimits"] = tmp
        }
        if self.spotStrategy != nil {
            map["SpotStrategy"] = self.spotStrategy!
        }
        if self.storageSetId != nil {
            map["StorageSetId"] = self.storageSetId!
        }
        if self.storageSetPartitionNumber != nil {
            map["StorageSetPartitionNumber"] = self.storageSetPartitionNumber!
        }
        if self.systemDiskCategories != nil {
            map["SystemDiskCategories"] = self.systemDiskCategories!
        }
        if self.tags != nil {
            map["Tags"] = self.tags!
        }
        if self.tenancy != nil {
            map["Tenancy"] = self.tenancy!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ImageOptions") {
            var model = CreateScalingConfigurationShrinkRequest.ImageOptions()
            model.fromMap(dict["ImageOptions"] as! [String: Any])
            self.imageOptions = model
        }
        if dict.keys.contains("PrivatePoolOptions") {
            var model = CreateScalingConfigurationShrinkRequest.PrivatePoolOptions()
            model.fromMap(dict["PrivatePoolOptions"] as! [String: Any])
            self.privatePoolOptions = model
        }
        if dict.keys.contains("SystemDisk") {
            var model = CreateScalingConfigurationShrinkRequest.SystemDisk()
            model.fromMap(dict["SystemDisk"] as! [String: Any])
            self.systemDisk = model
        }
        if dict.keys.contains("Affinity") {
            self.affinity = dict["Affinity"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Cpu") {
            self.cpu = dict["Cpu"] as! Int32
        }
        if dict.keys.contains("CreditSpecification") {
            self.creditSpecification = dict["CreditSpecification"] as! String
        }
        if dict.keys.contains("CustomPriorities") {
            var tmp : [CreateScalingConfigurationShrinkRequest.CustomPriorities] = []
            for v in dict["CustomPriorities"] as! [Any] {
                var model = CreateScalingConfigurationShrinkRequest.CustomPriorities()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.customPriorities = tmp
        }
        if dict.keys.contains("DataDisks") {
            var tmp : [CreateScalingConfigurationShrinkRequest.DataDisks] = []
            for v in dict["DataDisks"] as! [Any] {
                var model = CreateScalingConfigurationShrinkRequest.DataDisks()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.dataDisks = tmp
        }
        if dict.keys.contains("DedicatedHostClusterId") {
            self.dedicatedHostClusterId = dict["DedicatedHostClusterId"] as! String
        }
        if dict.keys.contains("DedicatedHostId") {
            self.dedicatedHostId = dict["DedicatedHostId"] as! String
        }
        if dict.keys.contains("DeletionProtection") {
            self.deletionProtection = dict["DeletionProtection"] as! Bool
        }
        if dict.keys.contains("DeploymentSetId") {
            self.deploymentSetId = dict["DeploymentSetId"] as! String
        }
        if dict.keys.contains("HostName") {
            self.hostName = dict["HostName"] as! String
        }
        if dict.keys.contains("HpcClusterId") {
            self.hpcClusterId = dict["HpcClusterId"] as! String
        }
        if dict.keys.contains("HttpEndpoint") {
            self.httpEndpoint = dict["HttpEndpoint"] as! String
        }
        if dict.keys.contains("HttpTokens") {
            self.httpTokens = dict["HttpTokens"] as! String
        }
        if dict.keys.contains("ImageFamily") {
            self.imageFamily = dict["ImageFamily"] as! String
        }
        if dict.keys.contains("ImageId") {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("ImageName") {
            self.imageName = dict["ImageName"] as! String
        }
        if dict.keys.contains("InstanceDescription") {
            self.instanceDescription = dict["InstanceDescription"] as! String
        }
        if dict.keys.contains("InstanceName") {
            self.instanceName = dict["InstanceName"] as! String
        }
        if dict.keys.contains("InstancePatternInfos") {
            var tmp : [CreateScalingConfigurationShrinkRequest.InstancePatternInfos] = []
            for v in dict["InstancePatternInfos"] as! [Any] {
                var model = CreateScalingConfigurationShrinkRequest.InstancePatternInfos()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.instancePatternInfos = tmp
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("InstanceTypeOverrides") {
            var tmp : [CreateScalingConfigurationShrinkRequest.InstanceTypeOverrides] = []
            for v in dict["InstanceTypeOverrides"] as! [Any] {
                var model = CreateScalingConfigurationShrinkRequest.InstanceTypeOverrides()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.instanceTypeOverrides = tmp
        }
        if dict.keys.contains("InstanceTypes") {
            self.instanceTypes = dict["InstanceTypes"] as! [String]
        }
        if dict.keys.contains("InternetChargeType") {
            self.internetChargeType = dict["InternetChargeType"] as! String
        }
        if dict.keys.contains("InternetMaxBandwidthIn") {
            self.internetMaxBandwidthIn = dict["InternetMaxBandwidthIn"] as! Int32
        }
        if dict.keys.contains("InternetMaxBandwidthOut") {
            self.internetMaxBandwidthOut = dict["InternetMaxBandwidthOut"] as! Int32
        }
        if dict.keys.contains("IoOptimized") {
            self.ioOptimized = dict["IoOptimized"] as! String
        }
        if dict.keys.contains("Ipv6AddressCount") {
            self.ipv6AddressCount = dict["Ipv6AddressCount"] as! Int32
        }
        if dict.keys.contains("KeyPairName") {
            self.keyPairName = dict["KeyPairName"] as! String
        }
        if dict.keys.contains("LoadBalancerWeight") {
            self.loadBalancerWeight = dict["LoadBalancerWeight"] as! Int32
        }
        if dict.keys.contains("Memory") {
            self.memory = dict["Memory"] as! Int32
        }
        if dict.keys.contains("NetworkInterfaces") {
            var tmp : [CreateScalingConfigurationShrinkRequest.NetworkInterfaces] = []
            for v in dict["NetworkInterfaces"] as! [Any] {
                var model = CreateScalingConfigurationShrinkRequest.NetworkInterfaces()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.networkInterfaces = tmp
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Password") {
            self.password = dict["Password"] as! String
        }
        if dict.keys.contains("PasswordInherit") {
            self.passwordInherit = dict["PasswordInherit"] as! Bool
        }
        if dict.keys.contains("RamRoleName") {
            self.ramRoleName = dict["RamRoleName"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScalingConfigurationName") {
            self.scalingConfigurationName = dict["ScalingConfigurationName"] as! String
        }
        if dict.keys.contains("ScalingGroupId") {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
        if dict.keys.contains("SchedulerOptions") {
            self.schedulerOptionsShrink = dict["SchedulerOptions"] as! String
        }
        if dict.keys.contains("SecurityEnhancementStrategy") {
            self.securityEnhancementStrategy = dict["SecurityEnhancementStrategy"] as! String
        }
        if dict.keys.contains("SecurityGroupId") {
            self.securityGroupId = dict["SecurityGroupId"] as! String
        }
        if dict.keys.contains("SecurityGroupIds") {
            self.securityGroupIds = dict["SecurityGroupIds"] as! [String]
        }
        if dict.keys.contains("SecurityOptions") {
            var model = CreateScalingConfigurationShrinkRequest.SecurityOptions()
            model.fromMap(dict["SecurityOptions"] as! [String: Any])
            self.securityOptions = model
        }
        if dict.keys.contains("SpotDuration") {
            self.spotDuration = dict["SpotDuration"] as! Int32
        }
        if dict.keys.contains("SpotInterruptionBehavior") {
            self.spotInterruptionBehavior = dict["SpotInterruptionBehavior"] as! String
        }
        if dict.keys.contains("SpotPriceLimits") {
            var tmp : [CreateScalingConfigurationShrinkRequest.SpotPriceLimits] = []
            for v in dict["SpotPriceLimits"] as! [Any] {
                var model = CreateScalingConfigurationShrinkRequest.SpotPriceLimits()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.spotPriceLimits = tmp
        }
        if dict.keys.contains("SpotStrategy") {
            self.spotStrategy = dict["SpotStrategy"] as! String
        }
        if dict.keys.contains("StorageSetId") {
            self.storageSetId = dict["StorageSetId"] as! String
        }
        if dict.keys.contains("StorageSetPartitionNumber") {
            self.storageSetPartitionNumber = dict["StorageSetPartitionNumber"] as! Int32
        }
        if dict.keys.contains("SystemDiskCategories") {
            self.systemDiskCategories = dict["SystemDiskCategories"] as! [String]
        }
        if dict.keys.contains("Tags") {
            self.tags = dict["Tags"] as! String
        }
        if dict.keys.contains("Tenancy") {
            self.tenancy = dict["Tenancy"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! String
        }
    }
}

public class CreateScalingConfigurationResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var scalingConfigurationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingConfigurationId != nil {
            map["ScalingConfigurationId"] = self.scalingConfigurationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScalingConfigurationId") {
            self.scalingConfigurationId = dict["ScalingConfigurationId"] as! String
        }
    }
}

public class CreateScalingConfigurationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateScalingConfigurationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateScalingConfigurationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateScalingGroupRequest : Tea.TeaModel {
    public class AlbServerGroups : Tea.TeaModel {
        public var albServerGroupId: String?

        public var port: Int32?

        public var weight: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.albServerGroupId != nil {
                map["AlbServerGroupId"] = self.albServerGroupId!
            }
            if self.port != nil {
                map["Port"] = self.port!
            }
            if self.weight != nil {
                map["Weight"] = self.weight!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AlbServerGroupId") {
                self.albServerGroupId = dict["AlbServerGroupId"] as! String
            }
            if dict.keys.contains("Port") {
                self.port = dict["Port"] as! Int32
            }
            if dict.keys.contains("Weight") {
                self.weight = dict["Weight"] as! Int32
            }
        }
    }
    public class CapacityOptions : Tea.TeaModel {
        public var compensateWithOnDemand: Bool?

        public var onDemandBaseCapacity: Int32?

        public var onDemandPercentageAboveBaseCapacity: Int32?

        public var priceComparisonMode: String?

        public var spotAutoReplaceOnDemand: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.compensateWithOnDemand != nil {
                map["CompensateWithOnDemand"] = self.compensateWithOnDemand!
            }
            if self.onDemandBaseCapacity != nil {
                map["OnDemandBaseCapacity"] = self.onDemandBaseCapacity!
            }
            if self.onDemandPercentageAboveBaseCapacity != nil {
                map["OnDemandPercentageAboveBaseCapacity"] = self.onDemandPercentageAboveBaseCapacity!
            }
            if self.priceComparisonMode != nil {
                map["PriceComparisonMode"] = self.priceComparisonMode!
            }
            if self.spotAutoReplaceOnDemand != nil {
                map["SpotAutoReplaceOnDemand"] = self.spotAutoReplaceOnDemand!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CompensateWithOnDemand") {
                self.compensateWithOnDemand = dict["CompensateWithOnDemand"] as! Bool
            }
            if dict.keys.contains("OnDemandBaseCapacity") {
                self.onDemandBaseCapacity = dict["OnDemandBaseCapacity"] as! Int32
            }
            if dict.keys.contains("OnDemandPercentageAboveBaseCapacity") {
                self.onDemandPercentageAboveBaseCapacity = dict["OnDemandPercentageAboveBaseCapacity"] as! Int32
            }
            if dict.keys.contains("PriceComparisonMode") {
                self.priceComparisonMode = dict["PriceComparisonMode"] as! String
            }
            if dict.keys.contains("SpotAutoReplaceOnDemand") {
                self.spotAutoReplaceOnDemand = dict["SpotAutoReplaceOnDemand"] as! Bool
            }
        }
    }
    public class DBInstances : Tea.TeaModel {
        public var attachMode: String?

        public var DBInstanceId: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.attachMode != nil {
                map["AttachMode"] = self.attachMode!
            }
            if self.DBInstanceId != nil {
                map["DBInstanceId"] = self.DBInstanceId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AttachMode") {
                self.attachMode = dict["AttachMode"] as! String
            }
            if dict.keys.contains("DBInstanceId") {
                self.DBInstanceId = dict["DBInstanceId"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class LaunchTemplateOverrides : Tea.TeaModel {
        public var instanceType: String?

        public var spotPriceLimit: Double?

        public var weightedCapacity: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.spotPriceLimit != nil {
                map["SpotPriceLimit"] = self.spotPriceLimit!
            }
            if self.weightedCapacity != nil {
                map["WeightedCapacity"] = self.weightedCapacity!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceType") {
                self.instanceType = dict["InstanceType"] as! String
            }
            if dict.keys.contains("SpotPriceLimit") {
                self.spotPriceLimit = dict["SpotPriceLimit"] as! Double
            }
            if dict.keys.contains("WeightedCapacity") {
                self.weightedCapacity = dict["WeightedCapacity"] as! Int32
            }
        }
    }
    public class LifecycleHooks : Tea.TeaModel {
        public var defaultResult: String?

        public var heartbeatTimeout: Int32?

        public var lifecycleHookName: String?

        public var lifecycleTransition: String?

        public var notificationArn: String?

        public var notificationMetadata: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.defaultResult != nil {
                map["DefaultResult"] = self.defaultResult!
            }
            if self.heartbeatTimeout != nil {
                map["HeartbeatTimeout"] = self.heartbeatTimeout!
            }
            if self.lifecycleHookName != nil {
                map["LifecycleHookName"] = self.lifecycleHookName!
            }
            if self.lifecycleTransition != nil {
                map["LifecycleTransition"] = self.lifecycleTransition!
            }
            if self.notificationArn != nil {
                map["NotificationArn"] = self.notificationArn!
            }
            if self.notificationMetadata != nil {
                map["NotificationMetadata"] = self.notificationMetadata!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DefaultResult") {
                self.defaultResult = dict["DefaultResult"] as! String
            }
            if dict.keys.contains("HeartbeatTimeout") {
                self.heartbeatTimeout = dict["HeartbeatTimeout"] as! Int32
            }
            if dict.keys.contains("LifecycleHookName") {
                self.lifecycleHookName = dict["LifecycleHookName"] as! String
            }
            if dict.keys.contains("LifecycleTransition") {
                self.lifecycleTransition = dict["LifecycleTransition"] as! String
            }
            if dict.keys.contains("NotificationArn") {
                self.notificationArn = dict["NotificationArn"] as! String
            }
            if dict.keys.contains("NotificationMetadata") {
                self.notificationMetadata = dict["NotificationMetadata"] as! String
            }
        }
    }
    public class LoadBalancerConfigs : Tea.TeaModel {
        public var loadBalancerId: String?

        public var weight: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.loadBalancerId != nil {
                map["LoadBalancerId"] = self.loadBalancerId!
            }
            if self.weight != nil {
                map["Weight"] = self.weight!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LoadBalancerId") {
                self.loadBalancerId = dict["LoadBalancerId"] as! String
            }
            if dict.keys.contains("Weight") {
                self.weight = dict["Weight"] as! Int32
            }
        }
    }
    public class ServerGroups : Tea.TeaModel {
        public var port: Int32?

        public var serverGroupId: String?

        public var type: String?

        public var weight: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.port != nil {
                map["Port"] = self.port!
            }
            if self.serverGroupId != nil {
                map["ServerGroupId"] = self.serverGroupId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.weight != nil {
                map["Weight"] = self.weight!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Port") {
                self.port = dict["Port"] as! Int32
            }
            if dict.keys.contains("ServerGroupId") {
                self.serverGroupId = dict["ServerGroupId"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Weight") {
                self.weight = dict["Weight"] as! Int32
            }
        }
    }
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var propagate: Bool?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.propagate != nil {
                map["Propagate"] = self.propagate!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Propagate") {
                self.propagate = dict["Propagate"] as! Bool
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public class VServerGroups : Tea.TeaModel {
        public class VServerGroupAttributes : Tea.TeaModel {
            public var port: Int32?

            public var VServerGroupId: String?

            public var weight: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.VServerGroupId != nil {
                    map["VServerGroupId"] = self.VServerGroupId!
                }
                if self.weight != nil {
                    map["Weight"] = self.weight!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Port") {
                    self.port = dict["Port"] as! Int32
                }
                if dict.keys.contains("VServerGroupId") {
                    self.VServerGroupId = dict["VServerGroupId"] as! String
                }
                if dict.keys.contains("Weight") {
                    self.weight = dict["Weight"] as! Int32
                }
            }
        }
        public var loadBalancerId: String?

        public var VServerGroupAttributes: [CreateScalingGroupRequest.VServerGroups.VServerGroupAttributes]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.loadBalancerId != nil {
                map["LoadBalancerId"] = self.loadBalancerId!
            }
            if self.VServerGroupAttributes != nil {
                var tmp : [Any] = []
                for k in self.VServerGroupAttributes! {
                    tmp.append(k.toMap())
                }
                map["VServerGroupAttributes"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LoadBalancerId") {
                self.loadBalancerId = dict["LoadBalancerId"] as! String
            }
            if dict.keys.contains("VServerGroupAttributes") {
                var tmp : [CreateScalingGroupRequest.VServerGroups.VServerGroupAttributes] = []
                for v in dict["VServerGroupAttributes"] as! [Any] {
                    var model = CreateScalingGroupRequest.VServerGroups.VServerGroupAttributes()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.VServerGroupAttributes = tmp
            }
        }
    }
    public var albServerGroups: [CreateScalingGroupRequest.AlbServerGroups]?

    public var allocationStrategy: String?

    public var azBalance: Bool?

    public var capacityOptions: CreateScalingGroupRequest.CapacityOptions?

    public var clientToken: String?

    public var compensateWithOnDemand: Bool?

    public var containerGroupId: String?

    public var customPolicyARN: String?

    public var DBInstanceIds: String?

    public var DBInstances: [CreateScalingGroupRequest.DBInstances]?

    public var defaultCooldown: Int32?

    public var desiredCapacity: Int32?

    public var groupDeletionProtection: Bool?

    public var groupType: String?

    public var healthCheckType: String?

    public var healthCheckTypes: [String]?

    public var instanceId: String?

    public var launchTemplateId: String?

    public var launchTemplateOverrides: [CreateScalingGroupRequest.LaunchTemplateOverrides]?

    public var launchTemplateVersion: String?

    public var lifecycleHooks: [CreateScalingGroupRequest.LifecycleHooks]?

    public var loadBalancerConfigs: [CreateScalingGroupRequest.LoadBalancerConfigs]?

    public var loadBalancerIds: String?

    public var maxInstanceLifetime: Int32?

    public var maxSize: Int32?

    public var minSize: Int32?

    public var multiAZPolicy: String?

    public var onDemandBaseCapacity: Int32?

    public var onDemandPercentageAboveBaseCapacity: Int32?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var removalPolicies: [String]?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var scalingGroupName: String?

    public var scalingPolicy: String?

    public var serverGroups: [CreateScalingGroupRequest.ServerGroups]?

    public var spotAllocationStrategy: String?

    public var spotInstancePools: Int32?

    public var spotInstanceRemedy: Bool?

    public var stopInstanceTimeout: Int32?

    public var syncAlarmRuleToCms: Bool?

    public var tags: [CreateScalingGroupRequest.Tags]?

    public var VServerGroups: [CreateScalingGroupRequest.VServerGroups]?

    public var vSwitchId: String?

    public var vSwitchIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.capacityOptions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.albServerGroups != nil {
            var tmp : [Any] = []
            for k in self.albServerGroups! {
                tmp.append(k.toMap())
            }
            map["AlbServerGroups"] = tmp
        }
        if self.allocationStrategy != nil {
            map["AllocationStrategy"] = self.allocationStrategy!
        }
        if self.azBalance != nil {
            map["AzBalance"] = self.azBalance!
        }
        if self.capacityOptions != nil {
            map["CapacityOptions"] = self.capacityOptions?.toMap()
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.compensateWithOnDemand != nil {
            map["CompensateWithOnDemand"] = self.compensateWithOnDemand!
        }
        if self.containerGroupId != nil {
            map["ContainerGroupId"] = self.containerGroupId!
        }
        if self.customPolicyARN != nil {
            map["CustomPolicyARN"] = self.customPolicyARN!
        }
        if self.DBInstanceIds != nil {
            map["DBInstanceIds"] = self.DBInstanceIds!
        }
        if self.DBInstances != nil {
            var tmp : [Any] = []
            for k in self.DBInstances! {
                tmp.append(k.toMap())
            }
            map["DBInstances"] = tmp
        }
        if self.defaultCooldown != nil {
            map["DefaultCooldown"] = self.defaultCooldown!
        }
        if self.desiredCapacity != nil {
            map["DesiredCapacity"] = self.desiredCapacity!
        }
        if self.groupDeletionProtection != nil {
            map["GroupDeletionProtection"] = self.groupDeletionProtection!
        }
        if self.groupType != nil {
            map["GroupType"] = self.groupType!
        }
        if self.healthCheckType != nil {
            map["HealthCheckType"] = self.healthCheckType!
        }
        if self.healthCheckTypes != nil {
            map["HealthCheckTypes"] = self.healthCheckTypes!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.launchTemplateId != nil {
            map["LaunchTemplateId"] = self.launchTemplateId!
        }
        if self.launchTemplateOverrides != nil {
            var tmp : [Any] = []
            for k in self.launchTemplateOverrides! {
                tmp.append(k.toMap())
            }
            map["LaunchTemplateOverrides"] = tmp
        }
        if self.launchTemplateVersion != nil {
            map["LaunchTemplateVersion"] = self.launchTemplateVersion!
        }
        if self.lifecycleHooks != nil {
            var tmp : [Any] = []
            for k in self.lifecycleHooks! {
                tmp.append(k.toMap())
            }
            map["LifecycleHooks"] = tmp
        }
        if self.loadBalancerConfigs != nil {
            var tmp : [Any] = []
            for k in self.loadBalancerConfigs! {
                tmp.append(k.toMap())
            }
            map["LoadBalancerConfigs"] = tmp
        }
        if self.loadBalancerIds != nil {
            map["LoadBalancerIds"] = self.loadBalancerIds!
        }
        if self.maxInstanceLifetime != nil {
            map["MaxInstanceLifetime"] = self.maxInstanceLifetime!
        }
        if self.maxSize != nil {
            map["MaxSize"] = self.maxSize!
        }
        if self.minSize != nil {
            map["MinSize"] = self.minSize!
        }
        if self.multiAZPolicy != nil {
            map["MultiAZPolicy"] = self.multiAZPolicy!
        }
        if self.onDemandBaseCapacity != nil {
            map["OnDemandBaseCapacity"] = self.onDemandBaseCapacity!
        }
        if self.onDemandPercentageAboveBaseCapacity != nil {
            map["OnDemandPercentageAboveBaseCapacity"] = self.onDemandPercentageAboveBaseCapacity!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.removalPolicies != nil {
            map["RemovalPolicies"] = self.removalPolicies!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupName != nil {
            map["ScalingGroupName"] = self.scalingGroupName!
        }
        if self.scalingPolicy != nil {
            map["ScalingPolicy"] = self.scalingPolicy!
        }
        if self.serverGroups != nil {
            var tmp : [Any] = []
            for k in self.serverGroups! {
                tmp.append(k.toMap())
            }
            map["ServerGroups"] = tmp
        }
        if self.spotAllocationStrategy != nil {
            map["SpotAllocationStrategy"] = self.spotAllocationStrategy!
        }
        if self.spotInstancePools != nil {
            map["SpotInstancePools"] = self.spotInstancePools!
        }
        if self.spotInstanceRemedy != nil {
            map["SpotInstanceRemedy"] = self.spotInstanceRemedy!
        }
        if self.stopInstanceTimeout != nil {
            map["StopInstanceTimeout"] = self.stopInstanceTimeout!
        }
        if self.syncAlarmRuleToCms != nil {
            map["SyncAlarmRuleToCms"] = self.syncAlarmRuleToCms!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        if self.VServerGroups != nil {
            var tmp : [Any] = []
            for k in self.VServerGroups! {
                tmp.append(k.toMap())
            }
            map["VServerGroups"] = tmp
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.vSwitchIds != nil {
            map["VSwitchIds"] = self.vSwitchIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlbServerGroups") {
            var tmp : [CreateScalingGroupRequest.AlbServerGroups] = []
            for v in dict["AlbServerGroups"] as! [Any] {
                var model = CreateScalingGroupRequest.AlbServerGroups()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.albServerGroups = tmp
        }
        if dict.keys.contains("AllocationStrategy") {
            self.allocationStrategy = dict["AllocationStrategy"] as! String
        }
        if dict.keys.contains("AzBalance") {
            self.azBalance = dict["AzBalance"] as! Bool
        }
        if dict.keys.contains("CapacityOptions") {
            var model = CreateScalingGroupRequest.CapacityOptions()
            model.fromMap(dict["CapacityOptions"] as! [String: Any])
            self.capacityOptions = model
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("CompensateWithOnDemand") {
            self.compensateWithOnDemand = dict["CompensateWithOnDemand"] as! Bool
        }
        if dict.keys.contains("ContainerGroupId") {
            self.containerGroupId = dict["ContainerGroupId"] as! String
        }
        if dict.keys.contains("CustomPolicyARN") {
            self.customPolicyARN = dict["CustomPolicyARN"] as! String
        }
        if dict.keys.contains("DBInstanceIds") {
            self.DBInstanceIds = dict["DBInstanceIds"] as! String
        }
        if dict.keys.contains("DBInstances") {
            var tmp : [CreateScalingGroupRequest.DBInstances] = []
            for v in dict["DBInstances"] as! [Any] {
                var model = CreateScalingGroupRequest.DBInstances()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.DBInstances = tmp
        }
        if dict.keys.contains("DefaultCooldown") {
            self.defaultCooldown = dict["DefaultCooldown"] as! Int32
        }
        if dict.keys.contains("DesiredCapacity") {
            self.desiredCapacity = dict["DesiredCapacity"] as! Int32
        }
        if dict.keys.contains("GroupDeletionProtection") {
            self.groupDeletionProtection = dict["GroupDeletionProtection"] as! Bool
        }
        if dict.keys.contains("GroupType") {
            self.groupType = dict["GroupType"] as! String
        }
        if dict.keys.contains("HealthCheckType") {
            self.healthCheckType = dict["HealthCheckType"] as! String
        }
        if dict.keys.contains("HealthCheckTypes") {
            self.healthCheckTypes = dict["HealthCheckTypes"] as! [String]
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("LaunchTemplateId") {
            self.launchTemplateId = dict["LaunchTemplateId"] as! String
        }
        if dict.keys.contains("LaunchTemplateOverrides") {
            var tmp : [CreateScalingGroupRequest.LaunchTemplateOverrides] = []
            for v in dict["LaunchTemplateOverrides"] as! [Any] {
                var model = CreateScalingGroupRequest.LaunchTemplateOverrides()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.launchTemplateOverrides = tmp
        }
        if dict.keys.contains("LaunchTemplateVersion") {
            self.launchTemplateVersion = dict["LaunchTemplateVersion"] as! String
        }
        if dict.keys.contains("LifecycleHooks") {
            var tmp : [CreateScalingGroupRequest.LifecycleHooks] = []
            for v in dict["LifecycleHooks"] as! [Any] {
                var model = CreateScalingGroupRequest.LifecycleHooks()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.lifecycleHooks = tmp
        }
        if dict.keys.contains("LoadBalancerConfigs") {
            var tmp : [CreateScalingGroupRequest.LoadBalancerConfigs] = []
            for v in dict["LoadBalancerConfigs"] as! [Any] {
                var model = CreateScalingGroupRequest.LoadBalancerConfigs()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.loadBalancerConfigs = tmp
        }
        if dict.keys.contains("LoadBalancerIds") {
            self.loadBalancerIds = dict["LoadBalancerIds"] as! String
        }
        if dict.keys.contains("MaxInstanceLifetime") {
            self.maxInstanceLifetime = dict["MaxInstanceLifetime"] as! Int32
        }
        if dict.keys.contains("MaxSize") {
            self.maxSize = dict["MaxSize"] as! Int32
        }
        if dict.keys.contains("MinSize") {
            self.minSize = dict["MinSize"] as! Int32
        }
        if dict.keys.contains("MultiAZPolicy") {
            self.multiAZPolicy = dict["MultiAZPolicy"] as! String
        }
        if dict.keys.contains("OnDemandBaseCapacity") {
            self.onDemandBaseCapacity = dict["OnDemandBaseCapacity"] as! Int32
        }
        if dict.keys.contains("OnDemandPercentageAboveBaseCapacity") {
            self.onDemandPercentageAboveBaseCapacity = dict["OnDemandPercentageAboveBaseCapacity"] as! Int32
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RemovalPolicies") {
            self.removalPolicies = dict["RemovalPolicies"] as! [String]
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScalingGroupName") {
            self.scalingGroupName = dict["ScalingGroupName"] as! String
        }
        if dict.keys.contains("ScalingPolicy") {
            self.scalingPolicy = dict["ScalingPolicy"] as! String
        }
        if dict.keys.contains("ServerGroups") {
            var tmp : [CreateScalingGroupRequest.ServerGroups] = []
            for v in dict["ServerGroups"] as! [Any] {
                var model = CreateScalingGroupRequest.ServerGroups()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.serverGroups = tmp
        }
        if dict.keys.contains("SpotAllocationStrategy") {
            self.spotAllocationStrategy = dict["SpotAllocationStrategy"] as! String
        }
        if dict.keys.contains("SpotInstancePools") {
            self.spotInstancePools = dict["SpotInstancePools"] as! Int32
        }
        if dict.keys.contains("SpotInstanceRemedy") {
            self.spotInstanceRemedy = dict["SpotInstanceRemedy"] as! Bool
        }
        if dict.keys.contains("StopInstanceTimeout") {
            self.stopInstanceTimeout = dict["StopInstanceTimeout"] as! Int32
        }
        if dict.keys.contains("SyncAlarmRuleToCms") {
            self.syncAlarmRuleToCms = dict["SyncAlarmRuleToCms"] as! Bool
        }
        if dict.keys.contains("Tags") {
            var tmp : [CreateScalingGroupRequest.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = CreateScalingGroupRequest.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
        if dict.keys.contains("VServerGroups") {
            var tmp : [CreateScalingGroupRequest.VServerGroups] = []
            for v in dict["VServerGroups"] as! [Any] {
                var model = CreateScalingGroupRequest.VServerGroups()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.VServerGroups = tmp
        }
        if dict.keys.contains("VSwitchId") {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
        if dict.keys.contains("VSwitchIds") {
            self.vSwitchIds = dict["VSwitchIds"] as! [String]
        }
    }
}

public class CreateScalingGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScalingGroupId") {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
    }
}

public class CreateScalingGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateScalingGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateScalingGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateScalingRuleRequest : Tea.TeaModel {
    public class AlarmDimensions : Tea.TeaModel {
        public var dimensionKey: String?

        public var dimensionValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dimensionKey != nil {
                map["DimensionKey"] = self.dimensionKey!
            }
            if self.dimensionValue != nil {
                map["DimensionValue"] = self.dimensionValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DimensionKey") {
                self.dimensionKey = dict["DimensionKey"] as! String
            }
            if dict.keys.contains("DimensionValue") {
                self.dimensionValue = dict["DimensionValue"] as! String
            }
        }
    }
    public class HybridMetrics : Tea.TeaModel {
        public class Dimensions : Tea.TeaModel {
            public var dimensionKey: String?

            public var dimensionValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dimensionKey != nil {
                    map["DimensionKey"] = self.dimensionKey!
                }
                if self.dimensionValue != nil {
                    map["DimensionValue"] = self.dimensionValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DimensionKey") {
                    self.dimensionKey = dict["DimensionKey"] as! String
                }
                if dict.keys.contains("DimensionValue") {
                    self.dimensionValue = dict["DimensionValue"] as! String
                }
            }
        }
        public var dimensions: [CreateScalingRuleRequest.HybridMetrics.Dimensions]?

        public var expression: String?

        public var id: String?

        public var metricName: String?

        public var statistic: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dimensions != nil {
                var tmp : [Any] = []
                for k in self.dimensions! {
                    tmp.append(k.toMap())
                }
                map["Dimensions"] = tmp
            }
            if self.expression != nil {
                map["Expression"] = self.expression!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.metricName != nil {
                map["MetricName"] = self.metricName!
            }
            if self.statistic != nil {
                map["Statistic"] = self.statistic!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Dimensions") {
                var tmp : [CreateScalingRuleRequest.HybridMetrics.Dimensions] = []
                for v in dict["Dimensions"] as! [Any] {
                    var model = CreateScalingRuleRequest.HybridMetrics.Dimensions()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.dimensions = tmp
            }
            if dict.keys.contains("Expression") {
                self.expression = dict["Expression"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("MetricName") {
                self.metricName = dict["MetricName"] as! String
            }
            if dict.keys.contains("Statistic") {
                self.statistic = dict["Statistic"] as! String
            }
        }
    }
    public class StepAdjustments : Tea.TeaModel {
        public var metricIntervalLowerBound: Double?

        public var metricIntervalUpperBound: Double?

        public var scalingAdjustment: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.metricIntervalLowerBound != nil {
                map["MetricIntervalLowerBound"] = self.metricIntervalLowerBound!
            }
            if self.metricIntervalUpperBound != nil {
                map["MetricIntervalUpperBound"] = self.metricIntervalUpperBound!
            }
            if self.scalingAdjustment != nil {
                map["ScalingAdjustment"] = self.scalingAdjustment!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MetricIntervalLowerBound") {
                self.metricIntervalLowerBound = dict["MetricIntervalLowerBound"] as! Double
            }
            if dict.keys.contains("MetricIntervalUpperBound") {
                self.metricIntervalUpperBound = dict["MetricIntervalUpperBound"] as! Double
            }
            if dict.keys.contains("ScalingAdjustment") {
                self.scalingAdjustment = dict["ScalingAdjustment"] as! Int32
            }
        }
    }
    public var adjustmentType: String?

    public var adjustmentValue: Int32?

    public var alarmDimensions: [CreateScalingRuleRequest.AlarmDimensions]?

    public var cooldown: Int32?

    public var disableScaleIn: Bool?

    public var estimatedInstanceWarmup: Int32?

    public var hybridMetrics: [CreateScalingRuleRequest.HybridMetrics]?

    public var hybridMonitorNamespace: String?

    public var initialMaxSize: Int32?

    public var metricName: String?

    public var metricType: String?

    public var minAdjustmentMagnitude: Int32?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var predictiveScalingMode: String?

    public var predictiveTaskBufferTime: Int32?

    public var predictiveValueBehavior: String?

    public var predictiveValueBuffer: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scaleInEvaluationCount: Int32?

    public var scaleOutEvaluationCount: Int32?

    public var scalingGroupId: String?

    public var scalingRuleName: String?

    public var scalingRuleType: String?

    public var stepAdjustments: [CreateScalingRuleRequest.StepAdjustments]?

    public var targetValue: Double?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.adjustmentType != nil {
            map["AdjustmentType"] = self.adjustmentType!
        }
        if self.adjustmentValue != nil {
            map["AdjustmentValue"] = self.adjustmentValue!
        }
        if self.alarmDimensions != nil {
            var tmp : [Any] = []
            for k in self.alarmDimensions! {
                tmp.append(k.toMap())
            }
            map["AlarmDimensions"] = tmp
        }
        if self.cooldown != nil {
            map["Cooldown"] = self.cooldown!
        }
        if self.disableScaleIn != nil {
            map["DisableScaleIn"] = self.disableScaleIn!
        }
        if self.estimatedInstanceWarmup != nil {
            map["EstimatedInstanceWarmup"] = self.estimatedInstanceWarmup!
        }
        if self.hybridMetrics != nil {
            var tmp : [Any] = []
            for k in self.hybridMetrics! {
                tmp.append(k.toMap())
            }
            map["HybridMetrics"] = tmp
        }
        if self.hybridMonitorNamespace != nil {
            map["HybridMonitorNamespace"] = self.hybridMonitorNamespace!
        }
        if self.initialMaxSize != nil {
            map["InitialMaxSize"] = self.initialMaxSize!
        }
        if self.metricName != nil {
            map["MetricName"] = self.metricName!
        }
        if self.metricType != nil {
            map["MetricType"] = self.metricType!
        }
        if self.minAdjustmentMagnitude != nil {
            map["MinAdjustmentMagnitude"] = self.minAdjustmentMagnitude!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.predictiveScalingMode != nil {
            map["PredictiveScalingMode"] = self.predictiveScalingMode!
        }
        if self.predictiveTaskBufferTime != nil {
            map["PredictiveTaskBufferTime"] = self.predictiveTaskBufferTime!
        }
        if self.predictiveValueBehavior != nil {
            map["PredictiveValueBehavior"] = self.predictiveValueBehavior!
        }
        if self.predictiveValueBuffer != nil {
            map["PredictiveValueBuffer"] = self.predictiveValueBuffer!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scaleInEvaluationCount != nil {
            map["ScaleInEvaluationCount"] = self.scaleInEvaluationCount!
        }
        if self.scaleOutEvaluationCount != nil {
            map["ScaleOutEvaluationCount"] = self.scaleOutEvaluationCount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        if self.scalingRuleName != nil {
            map["ScalingRuleName"] = self.scalingRuleName!
        }
        if self.scalingRuleType != nil {
            map["ScalingRuleType"] = self.scalingRuleType!
        }
        if self.stepAdjustments != nil {
            var tmp : [Any] = []
            for k in self.stepAdjustments! {
                tmp.append(k.toMap())
            }
            map["StepAdjustments"] = tmp
        }
        if self.targetValue != nil {
            map["TargetValue"] = self.targetValue!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AdjustmentType") {
            self.adjustmentType = dict["AdjustmentType"] as! String
        }
        if dict.keys.contains("AdjustmentValue") {
            self.adjustmentValue = dict["AdjustmentValue"] as! Int32
        }
        if dict.keys.contains("AlarmDimensions") {
            var tmp : [CreateScalingRuleRequest.AlarmDimensions] = []
            for v in dict["AlarmDimensions"] as! [Any] {
                var model = CreateScalingRuleRequest.AlarmDimensions()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.alarmDimensions = tmp
        }
        if dict.keys.contains("Cooldown") {
            self.cooldown = dict["Cooldown"] as! Int32
        }
        if dict.keys.contains("DisableScaleIn") {
            self.disableScaleIn = dict["DisableScaleIn"] as! Bool
        }
        if dict.keys.contains("EstimatedInstanceWarmup") {
            self.estimatedInstanceWarmup = dict["EstimatedInstanceWarmup"] as! Int32
        }
        if dict.keys.contains("HybridMetrics") {
            var tmp : [CreateScalingRuleRequest.HybridMetrics] = []
            for v in dict["HybridMetrics"] as! [Any] {
                var model = CreateScalingRuleRequest.HybridMetrics()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.hybridMetrics = tmp
        }
        if dict.keys.contains("HybridMonitorNamespace") {
            self.hybridMonitorNamespace = dict["HybridMonitorNamespace"] as! String
        }
        if dict.keys.contains("InitialMaxSize") {
            self.initialMaxSize = dict["InitialMaxSize"] as! Int32
        }
        if dict.keys.contains("MetricName") {
            self.metricName = dict["MetricName"] as! String
        }
        if dict.keys.contains("MetricType") {
            self.metricType = dict["MetricType"] as! String
        }
        if dict.keys.contains("MinAdjustmentMagnitude") {
            self.minAdjustmentMagnitude = dict["MinAdjustmentMagnitude"] as! Int32
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PredictiveScalingMode") {
            self.predictiveScalingMode = dict["PredictiveScalingMode"] as! String
        }
        if dict.keys.contains("PredictiveTaskBufferTime") {
            self.predictiveTaskBufferTime = dict["PredictiveTaskBufferTime"] as! Int32
        }
        if dict.keys.contains("PredictiveValueBehavior") {
            self.predictiveValueBehavior = dict["PredictiveValueBehavior"] as! String
        }
        if dict.keys.contains("PredictiveValueBuffer") {
            self.predictiveValueBuffer = dict["PredictiveValueBuffer"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScaleInEvaluationCount") {
            self.scaleInEvaluationCount = dict["ScaleInEvaluationCount"] as! Int32
        }
        if dict.keys.contains("ScaleOutEvaluationCount") {
            self.scaleOutEvaluationCount = dict["ScaleOutEvaluationCount"] as! Int32
        }
        if dict.keys.contains("ScalingGroupId") {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
        if dict.keys.contains("ScalingRuleName") {
            self.scalingRuleName = dict["ScalingRuleName"] as! String
        }
        if dict.keys.contains("ScalingRuleType") {
            self.scalingRuleType = dict["ScalingRuleType"] as! String
        }
        if dict.keys.contains("StepAdjustments") {
            var tmp : [CreateScalingRuleRequest.StepAdjustments] = []
            for v in dict["StepAdjustments"] as! [Any] {
                var model = CreateScalingRuleRequest.StepAdjustments()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.stepAdjustments = tmp
        }
        if dict.keys.contains("TargetValue") {
            self.targetValue = dict["TargetValue"] as! Double
        }
    }
}

public class CreateScalingRuleResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var scalingRuleAri: String?

    public var scalingRuleId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingRuleAri != nil {
            map["ScalingRuleAri"] = self.scalingRuleAri!
        }
        if self.scalingRuleId != nil {
            map["ScalingRuleId"] = self.scalingRuleId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScalingRuleAri") {
            self.scalingRuleAri = dict["ScalingRuleAri"] as! String
        }
        if dict.keys.contains("ScalingRuleId") {
            self.scalingRuleId = dict["ScalingRuleId"] as! String
        }
    }
}

public class CreateScalingRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateScalingRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateScalingRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateScheduledTaskRequest : Tea.TeaModel {
    public var description_: String?

    public var desiredCapacity: Int32?

    public var launchExpirationTime: Int32?

    public var launchTime: String?

    public var maxValue: Int32?

    public var minValue: Int32?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var recurrenceEndTime: String?

    public var recurrenceType: String?

    public var recurrenceValue: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public var scheduledAction: String?

    public var scheduledTaskName: String?

    public var taskEnabled: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.desiredCapacity != nil {
            map["DesiredCapacity"] = self.desiredCapacity!
        }
        if self.launchExpirationTime != nil {
            map["LaunchExpirationTime"] = self.launchExpirationTime!
        }
        if self.launchTime != nil {
            map["LaunchTime"] = self.launchTime!
        }
        if self.maxValue != nil {
            map["MaxValue"] = self.maxValue!
        }
        if self.minValue != nil {
            map["MinValue"] = self.minValue!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.recurrenceEndTime != nil {
            map["RecurrenceEndTime"] = self.recurrenceEndTime!
        }
        if self.recurrenceType != nil {
            map["RecurrenceType"] = self.recurrenceType!
        }
        if self.recurrenceValue != nil {
            map["RecurrenceValue"] = self.recurrenceValue!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        if self.scheduledAction != nil {
            map["ScheduledAction"] = self.scheduledAction!
        }
        if self.scheduledTaskName != nil {
            map["ScheduledTaskName"] = self.scheduledTaskName!
        }
        if self.taskEnabled != nil {
            map["TaskEnabled"] = self.taskEnabled!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DesiredCapacity") {
            self.desiredCapacity = dict["DesiredCapacity"] as! Int32
        }
        if dict.keys.contains("LaunchExpirationTime") {
            self.launchExpirationTime = dict["LaunchExpirationTime"] as! Int32
        }
        if dict.keys.contains("LaunchTime") {
            self.launchTime = dict["LaunchTime"] as! String
        }
        if dict.keys.contains("MaxValue") {
            self.maxValue = dict["MaxValue"] as! Int32
        }
        if dict.keys.contains("MinValue") {
            self.minValue = dict["MinValue"] as! Int32
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RecurrenceEndTime") {
            self.recurrenceEndTime = dict["RecurrenceEndTime"] as! String
        }
        if dict.keys.contains("RecurrenceType") {
            self.recurrenceType = dict["RecurrenceType"] as! String
        }
        if dict.keys.contains("RecurrenceValue") {
            self.recurrenceValue = dict["RecurrenceValue"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScalingGroupId") {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
        if dict.keys.contains("ScheduledAction") {
            self.scheduledAction = dict["ScheduledAction"] as! String
        }
        if dict.keys.contains("ScheduledTaskName") {
            self.scheduledTaskName = dict["ScheduledTaskName"] as! String
        }
        if dict.keys.contains("TaskEnabled") {
            self.taskEnabled = dict["TaskEnabled"] as! Bool
        }
    }
}

public class CreateScheduledTaskResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var scheduledTaskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scheduledTaskId != nil {
            map["ScheduledTaskId"] = self.scheduledTaskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScheduledTaskId") {
            self.scheduledTaskId = dict["ScheduledTaskId"] as! String
        }
    }
}

public class CreateScheduledTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateScheduledTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateScheduledTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeactivateScalingConfigurationRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var scalingConfigurationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingConfigurationId != nil {
            map["ScalingConfigurationId"] = self.scalingConfigurationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScalingConfigurationId") {
            self.scalingConfigurationId = dict["ScalingConfigurationId"] as! String
        }
    }
}

public class DeactivateScalingConfigurationResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeactivateScalingConfigurationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeactivateScalingConfigurationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeactivateScalingConfigurationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteAlarmRequest : Tea.TeaModel {
    public var alarmTaskId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alarmTaskId != nil {
            map["AlarmTaskId"] = self.alarmTaskId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlarmTaskId") {
            self.alarmTaskId = dict["AlarmTaskId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
    }
}

public class DeleteAlarmResponseBody : Tea.TeaModel {
    public var alarmTaskId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alarmTaskId != nil {
            map["AlarmTaskId"] = self.alarmTaskId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlarmTaskId") {
            self.alarmTaskId = dict["AlarmTaskId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteAlarmResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteAlarmResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteAlarmResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteEciScalingConfigurationRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingConfigurationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingConfigurationId != nil {
            map["ScalingConfigurationId"] = self.scalingConfigurationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScalingConfigurationId") {
            self.scalingConfigurationId = dict["ScalingConfigurationId"] as! String
        }
    }
}

public class DeleteEciScalingConfigurationResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteEciScalingConfigurationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteEciScalingConfigurationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteEciScalingConfigurationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteLifecycleHookRequest : Tea.TeaModel {
    public var lifecycleHookId: String?

    public var lifecycleHookName: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lifecycleHookId != nil {
            map["LifecycleHookId"] = self.lifecycleHookId!
        }
        if self.lifecycleHookName != nil {
            map["LifecycleHookName"] = self.lifecycleHookName!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LifecycleHookId") {
            self.lifecycleHookId = dict["LifecycleHookId"] as! String
        }
        if dict.keys.contains("LifecycleHookName") {
            self.lifecycleHookName = dict["LifecycleHookName"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScalingGroupId") {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
    }
}

public class DeleteLifecycleHookResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteLifecycleHookResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLifecycleHookResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteLifecycleHookResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteNotificationConfigurationRequest : Tea.TeaModel {
    public var notificationArn: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.notificationArn != nil {
            map["NotificationArn"] = self.notificationArn!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NotificationArn") {
            self.notificationArn = dict["NotificationArn"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScalingGroupId") {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
    }
}

public class DeleteNotificationConfigurationResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteNotificationConfigurationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteNotificationConfigurationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteNotificationConfigurationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteScalingConfigurationRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var scalingConfigurationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingConfigurationId != nil {
            map["ScalingConfigurationId"] = self.scalingConfigurationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScalingConfigurationId") {
            self.scalingConfigurationId = dict["ScalingConfigurationId"] as! String
        }
    }
}

public class DeleteScalingConfigurationResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteScalingConfigurationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteScalingConfigurationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteScalingConfigurationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteScalingGroupRequest : Tea.TeaModel {
    public var forceDelete: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.forceDelete != nil {
            map["ForceDelete"] = self.forceDelete!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ForceDelete") {
            self.forceDelete = dict["ForceDelete"] as! Bool
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScalingGroupId") {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
    }
}

public class DeleteScalingGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteScalingGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteScalingGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteScalingGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteScalingRuleRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingRuleId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingRuleId != nil {
            map["ScalingRuleId"] = self.scalingRuleId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScalingRuleId") {
            self.scalingRuleId = dict["ScalingRuleId"] as! String
        }
    }
}

public class DeleteScalingRuleResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteScalingRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteScalingRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteScalingRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteScheduledTaskRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scheduledTaskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scheduledTaskId != nil {
            map["ScheduledTaskId"] = self.scheduledTaskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScheduledTaskId") {
            self.scheduledTaskId = dict["ScheduledTaskId"] as! String
        }
    }
}

public class DeleteScheduledTaskResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteScheduledTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteScheduledTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteScheduledTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAlarmsRequest : Tea.TeaModel {
    public var alarmTaskId: String?

    public var isEnable: Bool?

    public var metricName: String?

    public var metricType: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public var state: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alarmTaskId != nil {
            map["AlarmTaskId"] = self.alarmTaskId!
        }
        if self.isEnable != nil {
            map["IsEnable"] = self.isEnable!
        }
        if self.metricName != nil {
            map["MetricName"] = self.metricName!
        }
        if self.metricType != nil {
            map["MetricType"] = self.metricType!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlarmTaskId") {
            self.alarmTaskId = dict["AlarmTaskId"] as! String
        }
        if dict.keys.contains("IsEnable") {
            self.isEnable = dict["IsEnable"] as! Bool
        }
        if dict.keys.contains("MetricName") {
            self.metricName = dict["MetricName"] as! String
        }
        if dict.keys.contains("MetricType") {
            self.metricType = dict["MetricType"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScalingGroupId") {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
        if dict.keys.contains("State") {
            self.state = dict["State"] as! String
        }
    }
}

public class DescribeAlarmsResponseBody : Tea.TeaModel {
    public class AlarmList : Tea.TeaModel {
        public class Dimensions : Tea.TeaModel {
            public var dimensionKey: String?

            public var dimensionValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dimensionKey != nil {
                    map["DimensionKey"] = self.dimensionKey!
                }
                if self.dimensionValue != nil {
                    map["DimensionValue"] = self.dimensionValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DimensionKey") {
                    self.dimensionKey = dict["DimensionKey"] as! String
                }
                if dict.keys.contains("DimensionValue") {
                    self.dimensionValue = dict["DimensionValue"] as! String
                }
            }
        }
        public class Expressions : Tea.TeaModel {
            public var comparisonOperator: String?

            public var metricName: String?

            public var period: Int32?

            public var statistics: String?

            public var threshold: Double?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.comparisonOperator != nil {
                    map["ComparisonOperator"] = self.comparisonOperator!
                }
                if self.metricName != nil {
                    map["MetricName"] = self.metricName!
                }
                if self.period != nil {
                    map["Period"] = self.period!
                }
                if self.statistics != nil {
                    map["Statistics"] = self.statistics!
                }
                if self.threshold != nil {
                    map["Threshold"] = self.threshold!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ComparisonOperator") {
                    self.comparisonOperator = dict["ComparisonOperator"] as! String
                }
                if dict.keys.contains("MetricName") {
                    self.metricName = dict["MetricName"] as! String
                }
                if dict.keys.contains("Period") {
                    self.period = dict["Period"] as! Int32
                }
                if dict.keys.contains("Statistics") {
                    self.statistics = dict["Statistics"] as! String
                }
                if dict.keys.contains("Threshold") {
                    self.threshold = dict["Threshold"] as! Double
                }
            }
        }
        public class HybridMetrics : Tea.TeaModel {
            public class Dimensions : Tea.TeaModel {
                public var dimensionKey: String?

                public var dimensionValue: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dimensionKey != nil {
                        map["DimensionKey"] = self.dimensionKey!
                    }
                    if self.dimensionValue != nil {
                        map["DimensionValue"] = self.dimensionValue!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DimensionKey") {
                        self.dimensionKey = dict["DimensionKey"] as! String
                    }
                    if dict.keys.contains("DimensionValue") {
                        self.dimensionValue = dict["DimensionValue"] as! String
                    }
                }
            }
            public var dimensions: [DescribeAlarmsResponseBody.AlarmList.HybridMetrics.Dimensions]?

            public var expression: String?

            public var id: String?

            public var metricName: String?

            public var statistic: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dimensions != nil {
                    var tmp : [Any] = []
                    for k in self.dimensions! {
                        tmp.append(k.toMap())
                    }
                    map["Dimensions"] = tmp
                }
                if self.expression != nil {
                    map["Expression"] = self.expression!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.metricName != nil {
                    map["MetricName"] = self.metricName!
                }
                if self.statistic != nil {
                    map["Statistic"] = self.statistic!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Dimensions") {
                    var tmp : [DescribeAlarmsResponseBody.AlarmList.HybridMetrics.Dimensions] = []
                    for v in dict["Dimensions"] as! [Any] {
                        var model = DescribeAlarmsResponseBody.AlarmList.HybridMetrics.Dimensions()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.dimensions = tmp
                }
                if dict.keys.contains("Expression") {
                    self.expression = dict["Expression"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("MetricName") {
                    self.metricName = dict["MetricName"] as! String
                }
                if dict.keys.contains("Statistic") {
                    self.statistic = dict["Statistic"] as! String
                }
            }
        }
        public var alarmActions: [String]?

        public var alarmTaskId: String?

        public var comparisonOperator: String?

        public var description_: String?

        public var dimensions: [DescribeAlarmsResponseBody.AlarmList.Dimensions]?

        public var effective: String?

        public var enable: Bool?

        public var evaluationCount: Int32?

        public var expressions: [DescribeAlarmsResponseBody.AlarmList.Expressions]?

        public var expressionsLogicOperator: String?

        public var hybridMetrics: [DescribeAlarmsResponseBody.AlarmList.HybridMetrics]?

        public var hybridMonitorNamespace: String?

        public var metricName: String?

        public var metricType: String?

        public var name: String?

        public var period: Int32?

        public var promQL: String?

        public var scalingGroupId: String?

        public var state: String?

        public var statistics: String?

        public var threshold: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alarmActions != nil {
                map["AlarmActions"] = self.alarmActions!
            }
            if self.alarmTaskId != nil {
                map["AlarmTaskId"] = self.alarmTaskId!
            }
            if self.comparisonOperator != nil {
                map["ComparisonOperator"] = self.comparisonOperator!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.dimensions != nil {
                var tmp : [Any] = []
                for k in self.dimensions! {
                    tmp.append(k.toMap())
                }
                map["Dimensions"] = tmp
            }
            if self.effective != nil {
                map["Effective"] = self.effective!
            }
            if self.enable != nil {
                map["Enable"] = self.enable!
            }
            if self.evaluationCount != nil {
                map["EvaluationCount"] = self.evaluationCount!
            }
            if self.expressions != nil {
                var tmp : [Any] = []
                for k in self.expressions! {
                    tmp.append(k.toMap())
                }
                map["Expressions"] = tmp
            }
            if self.expressionsLogicOperator != nil {
                map["ExpressionsLogicOperator"] = self.expressionsLogicOperator!
            }
            if self.hybridMetrics != nil {
                var tmp : [Any] = []
                for k in self.hybridMetrics! {
                    tmp.append(k.toMap())
                }
                map["HybridMetrics"] = tmp
            }
            if self.hybridMonitorNamespace != nil {
                map["HybridMonitorNamespace"] = self.hybridMonitorNamespace!
            }
            if self.metricName != nil {
                map["MetricName"] = self.metricName!
            }
            if self.metricType != nil {
                map["MetricType"] = self.metricType!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.period != nil {
                map["Period"] = self.period!
            }
            if self.promQL != nil {
                map["PromQL"] = self.promQL!
            }
            if self.scalingGroupId != nil {
                map["ScalingGroupId"] = self.scalingGroupId!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.statistics != nil {
                map["Statistics"] = self.statistics!
            }
            if self.threshold != nil {
                map["Threshold"] = self.threshold!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AlarmActions") {
                self.alarmActions = dict["AlarmActions"] as! [String]
            }
            if dict.keys.contains("AlarmTaskId") {
                self.alarmTaskId = dict["AlarmTaskId"] as! String
            }
            if dict.keys.contains("ComparisonOperator") {
                self.comparisonOperator = dict["ComparisonOperator"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Dimensions") {
                var tmp : [DescribeAlarmsResponseBody.AlarmList.Dimensions] = []
                for v in dict["Dimensions"] as! [Any] {
                    var model = DescribeAlarmsResponseBody.AlarmList.Dimensions()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.dimensions = tmp
            }
            if dict.keys.contains("Effective") {
                self.effective = dict["Effective"] as! String
            }
            if dict.keys.contains("Enable") {
                self.enable = dict["Enable"] as! Bool
            }
            if dict.keys.contains("EvaluationCount") {
                self.evaluationCount = dict["EvaluationCount"] as! Int32
            }
            if dict.keys.contains("Expressions") {
                var tmp : [DescribeAlarmsResponseBody.AlarmList.Expressions] = []
                for v in dict["Expressions"] as! [Any] {
                    var model = DescribeAlarmsResponseBody.AlarmList.Expressions()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.expressions = tmp
            }
            if dict.keys.contains("ExpressionsLogicOperator") {
                self.expressionsLogicOperator = dict["ExpressionsLogicOperator"] as! String
            }
            if dict.keys.contains("HybridMetrics") {
                var tmp : [DescribeAlarmsResponseBody.AlarmList.HybridMetrics] = []
                for v in dict["HybridMetrics"] as! [Any] {
                    var model = DescribeAlarmsResponseBody.AlarmList.HybridMetrics()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.hybridMetrics = tmp
            }
            if dict.keys.contains("HybridMonitorNamespace") {
                self.hybridMonitorNamespace = dict["HybridMonitorNamespace"] as! String
            }
            if dict.keys.contains("MetricName") {
                self.metricName = dict["MetricName"] as! String
            }
            if dict.keys.contains("MetricType") {
                self.metricType = dict["MetricType"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Period") {
                self.period = dict["Period"] as! Int32
            }
            if dict.keys.contains("PromQL") {
                self.promQL = dict["PromQL"] as! String
            }
            if dict.keys.contains("ScalingGroupId") {
                self.scalingGroupId = dict["ScalingGroupId"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("Statistics") {
                self.statistics = dict["Statistics"] as! String
            }
            if dict.keys.contains("Threshold") {
                self.threshold = dict["Threshold"] as! Double
            }
        }
    }
    public var alarmList: [DescribeAlarmsResponseBody.AlarmList]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alarmList != nil {
            var tmp : [Any] = []
            for k in self.alarmList! {
                tmp.append(k.toMap())
            }
            map["AlarmList"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlarmList") {
            var tmp : [DescribeAlarmsResponseBody.AlarmList] = []
            for v in dict["AlarmList"] as! [Any] {
                var model = DescribeAlarmsResponseBody.AlarmList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.alarmList = tmp
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeAlarmsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAlarmsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAlarmsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAlertConfigurationRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScalingGroupId") {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
    }
}

public class DescribeAlertConfigurationResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var scaleStatuses: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scaleStatuses != nil {
            map["ScaleStatuses"] = self.scaleStatuses!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScaleStatuses") {
            self.scaleStatuses = dict["ScaleStatuses"] as! [String]
        }
    }
}

public class DescribeAlertConfigurationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAlertConfigurationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAlertConfigurationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDiagnoseReportsRequest : Tea.TeaModel {
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var reportIds: [String]?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.reportIds != nil {
            map["ReportIds"] = self.reportIds!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ReportIds") {
            self.reportIds = dict["ReportIds"] as! [String]
        }
        if dict.keys.contains("ScalingGroupId") {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
    }
}

public class DescribeDiagnoseReportsResponseBody : Tea.TeaModel {
    public class Reports : Tea.TeaModel {
        public class Details : Tea.TeaModel {
            public var diagnoseType: String?

            public var errorCode: String?

            public var resourceId: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.diagnoseType != nil {
                    map["DiagnoseType"] = self.diagnoseType!
                }
                if self.errorCode != nil {
                    map["ErrorCode"] = self.errorCode!
                }
                if self.resourceId != nil {
                    map["ResourceId"] = self.resourceId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DiagnoseType") {
                    self.diagnoseType = dict["DiagnoseType"] as! String
                }
                if dict.keys.contains("ErrorCode") {
                    self.errorCode = dict["ErrorCode"] as! String
                }
                if dict.keys.contains("ResourceId") {
                    self.resourceId = dict["ResourceId"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var creationTime: String?

        public var details: [DescribeDiagnoseReportsResponseBody.Reports.Details]?

        public var diagnoseStatus: String?

        public var processStatus: String?

        public var regionId: String?

        public var reportId: String?

        public var scalingGroupId: String?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.details != nil {
                var tmp : [Any] = []
                for k in self.details! {
                    tmp.append(k.toMap())
                }
                map["Details"] = tmp
            }
            if self.diagnoseStatus != nil {
                map["DiagnoseStatus"] = self.diagnoseStatus!
            }
            if self.processStatus != nil {
                map["ProcessStatus"] = self.processStatus!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.reportId != nil {
                map["ReportId"] = self.reportId!
            }
            if self.scalingGroupId != nil {
                map["ScalingGroupId"] = self.scalingGroupId!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("Details") {
                var tmp : [DescribeDiagnoseReportsResponseBody.Reports.Details] = []
                for v in dict["Details"] as! [Any] {
                    var model = DescribeDiagnoseReportsResponseBody.Reports.Details()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.details = tmp
            }
            if dict.keys.contains("DiagnoseStatus") {
                self.diagnoseStatus = dict["DiagnoseStatus"] as! String
            }
            if dict.keys.contains("ProcessStatus") {
                self.processStatus = dict["ProcessStatus"] as! String
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("ReportId") {
                self.reportId = dict["ReportId"] as! String
            }
            if dict.keys.contains("ScalingGroupId") {
                self.scalingGroupId = dict["ScalingGroupId"] as! String
            }
            if dict.keys.contains("UserId") {
                self.userId = dict["UserId"] as! String
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var reports: [DescribeDiagnoseReportsResponseBody.Reports]?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.reports != nil {
            var tmp : [Any] = []
            for k in self.reports! {
                tmp.append(k.toMap())
            }
            map["Reports"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Reports") {
            var tmp : [DescribeDiagnoseReportsResponseBody.Reports] = []
            for v in dict["Reports"] as! [Any] {
                var model = DescribeDiagnoseReportsResponseBody.Reports()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.reports = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeDiagnoseReportsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDiagnoseReportsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDiagnoseReportsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEciScalingConfigurationDetailRequest : Tea.TeaModel {
    public var outputFormat: String?

    public var regionId: String?

    public var scalingConfigurationId: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.outputFormat != nil {
            map["OutputFormat"] = self.outputFormat!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.scalingConfigurationId != nil {
            map["ScalingConfigurationId"] = self.scalingConfigurationId!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OutputFormat") {
            self.outputFormat = dict["OutputFormat"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ScalingConfigurationId") {
            self.scalingConfigurationId = dict["ScalingConfigurationId"] as! String
        }
        if dict.keys.contains("ScalingGroupId") {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
    }
}

public class DescribeEciScalingConfigurationDetailResponseBody : Tea.TeaModel {
    public class ScalingConfiguration : Tea.TeaModel {
        public class AcrRegistryInfos : Tea.TeaModel {
            public var domains: [String]?

            public var instanceId: String?

            public var instanceName: String?

            public var regionId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.domains != nil {
                    map["Domains"] = self.domains!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.instanceName != nil {
                    map["InstanceName"] = self.instanceName!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Domains") {
                    self.domains = dict["Domains"] as! [String]
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("InstanceName") {
                    self.instanceName = dict["InstanceName"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
            }
        }
        public class Containers : Tea.TeaModel {
            public class EnvironmentVars : Tea.TeaModel {
                public var fieldRefFieldPath: String?

                public var key: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.fieldRefFieldPath != nil {
                        map["FieldRefFieldPath"] = self.fieldRefFieldPath!
                    }
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("FieldRefFieldPath") {
                        self.fieldRefFieldPath = dict["FieldRefFieldPath"] as! String
                    }
                    if dict.keys.contains("Key") {
                        self.key = dict["Key"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class Ports : Tea.TeaModel {
                public var port: Int32?

                public var protocol_: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.port != nil {
                        map["Port"] = self.port!
                    }
                    if self.protocol_ != nil {
                        map["Protocol"] = self.protocol_!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Port") {
                        self.port = dict["Port"] as! Int32
                    }
                    if dict.keys.contains("Protocol") {
                        self.protocol_ = dict["Protocol"] as! String
                    }
                }
            }
            public class VolumeMounts : Tea.TeaModel {
                public var mountPath: String?

                public var mountPropagation: String?

                public var name: String?

                public var readOnly: Bool?

                public var subPath: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.mountPath != nil {
                        map["MountPath"] = self.mountPath!
                    }
                    if self.mountPropagation != nil {
                        map["MountPropagation"] = self.mountPropagation!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.readOnly != nil {
                        map["ReadOnly"] = self.readOnly!
                    }
                    if self.subPath != nil {
                        map["SubPath"] = self.subPath!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("MountPath") {
                        self.mountPath = dict["MountPath"] as! String
                    }
                    if dict.keys.contains("MountPropagation") {
                        self.mountPropagation = dict["MountPropagation"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("ReadOnly") {
                        self.readOnly = dict["ReadOnly"] as! Bool
                    }
                    if dict.keys.contains("SubPath") {
                        self.subPath = dict["SubPath"] as! String
                    }
                }
            }
            public var args: [String]?

            public var commands: [String]?

            public var cpu: Double?

            public var environmentVars: [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.Containers.EnvironmentVars]?

            public var gpu: Int32?

            public var image: String?

            public var imagePullPolicy: String?

            public var lifecyclePostStartHandlerExecs: [String]?

            public var lifecyclePostStartHandlerHttpGetHost: String?

            public var lifecyclePostStartHandlerHttpGetPath: String?

            public var lifecyclePostStartHandlerHttpGetPort: Int32?

            public var lifecyclePostStartHandlerHttpGetScheme: String?

            public var lifecyclePostStartHandlerTcpSocketHost: String?

            public var lifecyclePostStartHandlerTcpSocketPort: Int32?

            public var lifecyclePreStopHandlerExecs: [String]?

            public var lifecyclePreStopHandlerHttpGetHost: String?

            public var lifecyclePreStopHandlerHttpGetPath: String?

            public var lifecyclePreStopHandlerHttpGetPort: Int32?

            public var lifecyclePreStopHandlerHttpGetScheme: String?

            public var lifecyclePreStopHandlerTcpSocketHost: String?

            public var lifecyclePreStopHandlerTcpSocketPort: Int32?

            public var livenessProbeExecCommands: [String]?

            public var livenessProbeFailureThreshold: Int32?

            public var livenessProbeHttpGetPath: String?

            public var livenessProbeHttpGetPort: Int32?

            public var livenessProbeHttpGetScheme: String?

            public var livenessProbeInitialDelaySeconds: Int32?

            public var livenessProbePeriodSeconds: Int32?

            public var livenessProbeSuccessThreshold: Int32?

            public var livenessProbeTcpSocketPort: Int32?

            public var livenessProbeTimeoutSeconds: Int32?

            public var memory: Double?

            public var name: String?

            public var ports: [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.Containers.Ports]?

            public var readinessProbeExecCommands: [String]?

            public var readinessProbeFailureThreshold: Int32?

            public var readinessProbeHttpGetPath: String?

            public var readinessProbeHttpGetPort: Int32?

            public var readinessProbeHttpGetScheme: String?

            public var readinessProbeInitialDelaySeconds: Int32?

            public var readinessProbePeriodSeconds: Int32?

            public var readinessProbeSuccessThreshold: Int32?

            public var readinessProbeTcpSocketPort: Int32?

            public var readinessProbeTimeoutSeconds: Int32?

            public var securityContextCapabilityAdds: [String]?

            public var securityContextReadOnlyRootFilesystem: Bool?

            public var securityContextRunAsUser: Int64?

            public var stdin: Bool?

            public var stdinOnce: Bool?

            public var tty: Bool?

            public var volumeMounts: [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.Containers.VolumeMounts]?

            public var workingDir: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.args != nil {
                    map["Args"] = self.args!
                }
                if self.commands != nil {
                    map["Commands"] = self.commands!
                }
                if self.cpu != nil {
                    map["Cpu"] = self.cpu!
                }
                if self.environmentVars != nil {
                    var tmp : [Any] = []
                    for k in self.environmentVars! {
                        tmp.append(k.toMap())
                    }
                    map["EnvironmentVars"] = tmp
                }
                if self.gpu != nil {
                    map["Gpu"] = self.gpu!
                }
                if self.image != nil {
                    map["Image"] = self.image!
                }
                if self.imagePullPolicy != nil {
                    map["ImagePullPolicy"] = self.imagePullPolicy!
                }
                if self.lifecyclePostStartHandlerExecs != nil {
                    map["LifecyclePostStartHandlerExecs"] = self.lifecyclePostStartHandlerExecs!
                }
                if self.lifecyclePostStartHandlerHttpGetHost != nil {
                    map["LifecyclePostStartHandlerHttpGetHost"] = self.lifecyclePostStartHandlerHttpGetHost!
                }
                if self.lifecyclePostStartHandlerHttpGetPath != nil {
                    map["LifecyclePostStartHandlerHttpGetPath"] = self.lifecyclePostStartHandlerHttpGetPath!
                }
                if self.lifecyclePostStartHandlerHttpGetPort != nil {
                    map["LifecyclePostStartHandlerHttpGetPort"] = self.lifecyclePostStartHandlerHttpGetPort!
                }
                if self.lifecyclePostStartHandlerHttpGetScheme != nil {
                    map["LifecyclePostStartHandlerHttpGetScheme"] = self.lifecyclePostStartHandlerHttpGetScheme!
                }
                if self.lifecyclePostStartHandlerTcpSocketHost != nil {
                    map["LifecyclePostStartHandlerTcpSocketHost"] = self.lifecyclePostStartHandlerTcpSocketHost!
                }
                if self.lifecyclePostStartHandlerTcpSocketPort != nil {
                    map["LifecyclePostStartHandlerTcpSocketPort"] = self.lifecyclePostStartHandlerTcpSocketPort!
                }
                if self.lifecyclePreStopHandlerExecs != nil {
                    map["LifecyclePreStopHandlerExecs"] = self.lifecyclePreStopHandlerExecs!
                }
                if self.lifecyclePreStopHandlerHttpGetHost != nil {
                    map["LifecyclePreStopHandlerHttpGetHost"] = self.lifecyclePreStopHandlerHttpGetHost!
                }
                if self.lifecyclePreStopHandlerHttpGetPath != nil {
                    map["LifecyclePreStopHandlerHttpGetPath"] = self.lifecyclePreStopHandlerHttpGetPath!
                }
                if self.lifecyclePreStopHandlerHttpGetPort != nil {
                    map["LifecyclePreStopHandlerHttpGetPort"] = self.lifecyclePreStopHandlerHttpGetPort!
                }
                if self.lifecyclePreStopHandlerHttpGetScheme != nil {
                    map["LifecyclePreStopHandlerHttpGetScheme"] = self.lifecyclePreStopHandlerHttpGetScheme!
                }
                if self.lifecyclePreStopHandlerTcpSocketHost != nil {
                    map["LifecyclePreStopHandlerTcpSocketHost"] = self.lifecyclePreStopHandlerTcpSocketHost!
                }
                if self.lifecyclePreStopHandlerTcpSocketPort != nil {
                    map["LifecyclePreStopHandlerTcpSocketPort"] = self.lifecyclePreStopHandlerTcpSocketPort!
                }
                if self.livenessProbeExecCommands != nil {
                    map["LivenessProbeExecCommands"] = self.livenessProbeExecCommands!
                }
                if self.livenessProbeFailureThreshold != nil {
                    map["LivenessProbeFailureThreshold"] = self.livenessProbeFailureThreshold!
                }
                if self.livenessProbeHttpGetPath != nil {
                    map["LivenessProbeHttpGetPath"] = self.livenessProbeHttpGetPath!
                }
                if self.livenessProbeHttpGetPort != nil {
                    map["LivenessProbeHttpGetPort"] = self.livenessProbeHttpGetPort!
                }
                if self.livenessProbeHttpGetScheme != nil {
                    map["LivenessProbeHttpGetScheme"] = self.livenessProbeHttpGetScheme!
                }
                if self.livenessProbeInitialDelaySeconds != nil {
                    map["LivenessProbeInitialDelaySeconds"] = self.livenessProbeInitialDelaySeconds!
                }
                if self.livenessProbePeriodSeconds != nil {
                    map["LivenessProbePeriodSeconds"] = self.livenessProbePeriodSeconds!
                }
                if self.livenessProbeSuccessThreshold != nil {
                    map["LivenessProbeSuccessThreshold"] = self.livenessProbeSuccessThreshold!
                }
                if self.livenessProbeTcpSocketPort != nil {
                    map["LivenessProbeTcpSocketPort"] = self.livenessProbeTcpSocketPort!
                }
                if self.livenessProbeTimeoutSeconds != nil {
                    map["LivenessProbeTimeoutSeconds"] = self.livenessProbeTimeoutSeconds!
                }
                if self.memory != nil {
                    map["Memory"] = self.memory!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.ports != nil {
                    var tmp : [Any] = []
                    for k in self.ports! {
                        tmp.append(k.toMap())
                    }
                    map["Ports"] = tmp
                }
                if self.readinessProbeExecCommands != nil {
                    map["ReadinessProbeExecCommands"] = self.readinessProbeExecCommands!
                }
                if self.readinessProbeFailureThreshold != nil {
                    map["ReadinessProbeFailureThreshold"] = self.readinessProbeFailureThreshold!
                }
                if self.readinessProbeHttpGetPath != nil {
                    map["ReadinessProbeHttpGetPath"] = self.readinessProbeHttpGetPath!
                }
                if self.readinessProbeHttpGetPort != nil {
                    map["ReadinessProbeHttpGetPort"] = self.readinessProbeHttpGetPort!
                }
                if self.readinessProbeHttpGetScheme != nil {
                    map["ReadinessProbeHttpGetScheme"] = self.readinessProbeHttpGetScheme!
                }
                if self.readinessProbeInitialDelaySeconds != nil {
                    map["ReadinessProbeInitialDelaySeconds"] = self.readinessProbeInitialDelaySeconds!
                }
                if self.readinessProbePeriodSeconds != nil {
                    map["ReadinessProbePeriodSeconds"] = self.readinessProbePeriodSeconds!
                }
                if self.readinessProbeSuccessThreshold != nil {
                    map["ReadinessProbeSuccessThreshold"] = self.readinessProbeSuccessThreshold!
                }
                if self.readinessProbeTcpSocketPort != nil {
                    map["ReadinessProbeTcpSocketPort"] = self.readinessProbeTcpSocketPort!
                }
                if self.readinessProbeTimeoutSeconds != nil {
                    map["ReadinessProbeTimeoutSeconds"] = self.readinessProbeTimeoutSeconds!
                }
                if self.securityContextCapabilityAdds != nil {
                    map["SecurityContextCapabilityAdds"] = self.securityContextCapabilityAdds!
                }
                if self.securityContextReadOnlyRootFilesystem != nil {
                    map["SecurityContextReadOnlyRootFilesystem"] = self.securityContextReadOnlyRootFilesystem!
                }
                if self.securityContextRunAsUser != nil {
                    map["SecurityContextRunAsUser"] = self.securityContextRunAsUser!
                }
                if self.stdin != nil {
                    map["Stdin"] = self.stdin!
                }
                if self.stdinOnce != nil {
                    map["StdinOnce"] = self.stdinOnce!
                }
                if self.tty != nil {
                    map["Tty"] = self.tty!
                }
                if self.volumeMounts != nil {
                    var tmp : [Any] = []
                    for k in self.volumeMounts! {
                        tmp.append(k.toMap())
                    }
                    map["VolumeMounts"] = tmp
                }
                if self.workingDir != nil {
                    map["WorkingDir"] = self.workingDir!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Args") {
                    self.args = dict["Args"] as! [String]
                }
                if dict.keys.contains("Commands") {
                    self.commands = dict["Commands"] as! [String]
                }
                if dict.keys.contains("Cpu") {
                    self.cpu = dict["Cpu"] as! Double
                }
                if dict.keys.contains("EnvironmentVars") {
                    var tmp : [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.Containers.EnvironmentVars] = []
                    for v in dict["EnvironmentVars"] as! [Any] {
                        var model = DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.Containers.EnvironmentVars()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.environmentVars = tmp
                }
                if dict.keys.contains("Gpu") {
                    self.gpu = dict["Gpu"] as! Int32
                }
                if dict.keys.contains("Image") {
                    self.image = dict["Image"] as! String
                }
                if dict.keys.contains("ImagePullPolicy") {
                    self.imagePullPolicy = dict["ImagePullPolicy"] as! String
                }
                if dict.keys.contains("LifecyclePostStartHandlerExecs") {
                    self.lifecyclePostStartHandlerExecs = dict["LifecyclePostStartHandlerExecs"] as! [String]
                }
                if dict.keys.contains("LifecyclePostStartHandlerHttpGetHost") {
                    self.lifecyclePostStartHandlerHttpGetHost = dict["LifecyclePostStartHandlerHttpGetHost"] as! String
                }
                if dict.keys.contains("LifecyclePostStartHandlerHttpGetPath") {
                    self.lifecyclePostStartHandlerHttpGetPath = dict["LifecyclePostStartHandlerHttpGetPath"] as! String
                }
                if dict.keys.contains("LifecyclePostStartHandlerHttpGetPort") {
                    self.lifecyclePostStartHandlerHttpGetPort = dict["LifecyclePostStartHandlerHttpGetPort"] as! Int32
                }
                if dict.keys.contains("LifecyclePostStartHandlerHttpGetScheme") {
                    self.lifecyclePostStartHandlerHttpGetScheme = dict["LifecyclePostStartHandlerHttpGetScheme"] as! String
                }
                if dict.keys.contains("LifecyclePostStartHandlerTcpSocketHost") {
                    self.lifecyclePostStartHandlerTcpSocketHost = dict["LifecyclePostStartHandlerTcpSocketHost"] as! String
                }
                if dict.keys.contains("LifecyclePostStartHandlerTcpSocketPort") {
                    self.lifecyclePostStartHandlerTcpSocketPort = dict["LifecyclePostStartHandlerTcpSocketPort"] as! Int32
                }
                if dict.keys.contains("LifecyclePreStopHandlerExecs") {
                    self.lifecyclePreStopHandlerExecs = dict["LifecyclePreStopHandlerExecs"] as! [String]
                }
                if dict.keys.contains("LifecyclePreStopHandlerHttpGetHost") {
                    self.lifecyclePreStopHandlerHttpGetHost = dict["LifecyclePreStopHandlerHttpGetHost"] as! String
                }
                if dict.keys.contains("LifecyclePreStopHandlerHttpGetPath") {
                    self.lifecyclePreStopHandlerHttpGetPath = dict["LifecyclePreStopHandlerHttpGetPath"] as! String
                }
                if dict.keys.contains("LifecyclePreStopHandlerHttpGetPort") {
                    self.lifecyclePreStopHandlerHttpGetPort = dict["LifecyclePreStopHandlerHttpGetPort"] as! Int32
                }
                if dict.keys.contains("LifecyclePreStopHandlerHttpGetScheme") {
                    self.lifecyclePreStopHandlerHttpGetScheme = dict["LifecyclePreStopHandlerHttpGetScheme"] as! String
                }
                if dict.keys.contains("LifecyclePreStopHandlerTcpSocketHost") {
                    self.lifecyclePreStopHandlerTcpSocketHost = dict["LifecyclePreStopHandlerTcpSocketHost"] as! String
                }
                if dict.keys.contains("LifecyclePreStopHandlerTcpSocketPort") {
                    self.lifecyclePreStopHandlerTcpSocketPort = dict["LifecyclePreStopHandlerTcpSocketPort"] as! Int32
                }
                if dict.keys.contains("LivenessProbeExecCommands") {
                    self.livenessProbeExecCommands = dict["LivenessProbeExecCommands"] as! [String]
                }
                if dict.keys.contains("LivenessProbeFailureThreshold") {
                    self.livenessProbeFailureThreshold = dict["LivenessProbeFailureThreshold"] as! Int32
                }
                if dict.keys.contains("LivenessProbeHttpGetPath") {
                    self.livenessProbeHttpGetPath = dict["LivenessProbeHttpGetPath"] as! String
                }
                if dict.keys.contains("LivenessProbeHttpGetPort") {
                    self.livenessProbeHttpGetPort = dict["LivenessProbeHttpGetPort"] as! Int32
                }
                if dict.keys.contains("LivenessProbeHttpGetScheme") {
                    self.livenessProbeHttpGetScheme = dict["LivenessProbeHttpGetScheme"] as! String
                }
                if dict.keys.contains("LivenessProbeInitialDelaySeconds") {
                    self.livenessProbeInitialDelaySeconds = dict["LivenessProbeInitialDelaySeconds"] as! Int32
                }
                if dict.keys.contains("LivenessProbePeriodSeconds") {
                    self.livenessProbePeriodSeconds = dict["LivenessProbePeriodSeconds"] as! Int32
                }
                if dict.keys.contains("LivenessProbeSuccessThreshold") {
                    self.livenessProbeSuccessThreshold = dict["LivenessProbeSuccessThreshold"] as! Int32
                }
                if dict.keys.contains("LivenessProbeTcpSocketPort") {
                    self.livenessProbeTcpSocketPort = dict["LivenessProbeTcpSocketPort"] as! Int32
                }
                if dict.keys.contains("LivenessProbeTimeoutSeconds") {
                    self.livenessProbeTimeoutSeconds = dict["LivenessProbeTimeoutSeconds"] as! Int32
                }
                if dict.keys.contains("Memory") {
                    self.memory = dict["Memory"] as! Double
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Ports") {
                    var tmp : [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.Containers.Ports] = []
                    for v in dict["Ports"] as! [Any] {
                        var model = DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.Containers.Ports()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.ports = tmp
                }
                if dict.keys.contains("ReadinessProbeExecCommands") {
                    self.readinessProbeExecCommands = dict["ReadinessProbeExecCommands"] as! [String]
                }
                if dict.keys.contains("ReadinessProbeFailureThreshold") {
                    self.readinessProbeFailureThreshold = dict["ReadinessProbeFailureThreshold"] as! Int32
                }
                if dict.keys.contains("ReadinessProbeHttpGetPath") {
                    self.readinessProbeHttpGetPath = dict["ReadinessProbeHttpGetPath"] as! String
                }
                if dict.keys.contains("ReadinessProbeHttpGetPort") {
                    self.readinessProbeHttpGetPort = dict["ReadinessProbeHttpGetPort"] as! Int32
                }
                if dict.keys.contains("ReadinessProbeHttpGetScheme") {
                    self.readinessProbeHttpGetScheme = dict["ReadinessProbeHttpGetScheme"] as! String
                }
                if dict.keys.contains("ReadinessProbeInitialDelaySeconds") {
                    self.readinessProbeInitialDelaySeconds = dict["ReadinessProbeInitialDelaySeconds"] as! Int32
                }
                if dict.keys.contains("ReadinessProbePeriodSeconds") {
                    self.readinessProbePeriodSeconds = dict["ReadinessProbePeriodSeconds"] as! Int32
                }
                if dict.keys.contains("ReadinessProbeSuccessThreshold") {
                    self.readinessProbeSuccessThreshold = dict["ReadinessProbeSuccessThreshold"] as! Int32
                }
                if dict.keys.contains("ReadinessProbeTcpSocketPort") {
                    self.readinessProbeTcpSocketPort = dict["ReadinessProbeTcpSocketPort"] as! Int32
                }
                if dict.keys.contains("ReadinessProbeTimeoutSeconds") {
                    self.readinessProbeTimeoutSeconds = dict["ReadinessProbeTimeoutSeconds"] as! Int32
                }
                if dict.keys.contains("SecurityContextCapabilityAdds") {
                    self.securityContextCapabilityAdds = dict["SecurityContextCapabilityAdds"] as! [String]
                }
                if dict.keys.contains("SecurityContextReadOnlyRootFilesystem") {
                    self.securityContextReadOnlyRootFilesystem = dict["SecurityContextReadOnlyRootFilesystem"] as! Bool
                }
                if dict.keys.contains("SecurityContextRunAsUser") {
                    self.securityContextRunAsUser = dict["SecurityContextRunAsUser"] as! Int64
                }
                if dict.keys.contains("Stdin") {
                    self.stdin = dict["Stdin"] as! Bool
                }
                if dict.keys.contains("StdinOnce") {
                    self.stdinOnce = dict["StdinOnce"] as! Bool
                }
                if dict.keys.contains("Tty") {
                    self.tty = dict["Tty"] as! Bool
                }
                if dict.keys.contains("VolumeMounts") {
                    var tmp : [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.Containers.VolumeMounts] = []
                    for v in dict["VolumeMounts"] as! [Any] {
                        var model = DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.Containers.VolumeMounts()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.volumeMounts = tmp
                }
                if dict.keys.contains("WorkingDir") {
                    self.workingDir = dict["WorkingDir"] as! String
                }
            }
        }
        public class DnsConfigOptions : Tea.TeaModel {
            public var name: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public class HostAliases : Tea.TeaModel {
            public var hostnames: [String]?

            public var ip: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.hostnames != nil {
                    map["Hostnames"] = self.hostnames!
                }
                if self.ip != nil {
                    map["Ip"] = self.ip!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Hostnames") {
                    self.hostnames = dict["Hostnames"] as! [String]
                }
                if dict.keys.contains("Ip") {
                    self.ip = dict["Ip"] as! String
                }
            }
        }
        public class ImageRegistryCredentials : Tea.TeaModel {
            public var password: String?

            public var server: String?

            public var userName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.password != nil {
                    map["Password"] = self.password!
                }
                if self.server != nil {
                    map["Server"] = self.server!
                }
                if self.userName != nil {
                    map["UserName"] = self.userName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Password") {
                    self.password = dict["Password"] as! String
                }
                if dict.keys.contains("Server") {
                    self.server = dict["Server"] as! String
                }
                if dict.keys.contains("UserName") {
                    self.userName = dict["UserName"] as! String
                }
            }
        }
        public class InitContainers : Tea.TeaModel {
            public class InitContainerEnvironmentVars : Tea.TeaModel {
                public var fieldRefFieldPath: String?

                public var key: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.fieldRefFieldPath != nil {
                        map["FieldRefFieldPath"] = self.fieldRefFieldPath!
                    }
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("FieldRefFieldPath") {
                        self.fieldRefFieldPath = dict["FieldRefFieldPath"] as! String
                    }
                    if dict.keys.contains("Key") {
                        self.key = dict["Key"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class InitContainerPorts : Tea.TeaModel {
                public var port: Int32?

                public var protocol_: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.port != nil {
                        map["Port"] = self.port!
                    }
                    if self.protocol_ != nil {
                        map["Protocol"] = self.protocol_!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Port") {
                        self.port = dict["Port"] as! Int32
                    }
                    if dict.keys.contains("Protocol") {
                        self.protocol_ = dict["Protocol"] as! String
                    }
                }
            }
            public class InitContainerVolumeMounts : Tea.TeaModel {
                public var mountPath: String?

                public var mountPropagation: String?

                public var name: String?

                public var readOnly: Bool?

                public var subPath: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.mountPath != nil {
                        map["MountPath"] = self.mountPath!
                    }
                    if self.mountPropagation != nil {
                        map["MountPropagation"] = self.mountPropagation!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.readOnly != nil {
                        map["ReadOnly"] = self.readOnly!
                    }
                    if self.subPath != nil {
                        map["SubPath"] = self.subPath!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("MountPath") {
                        self.mountPath = dict["MountPath"] as! String
                    }
                    if dict.keys.contains("MountPropagation") {
                        self.mountPropagation = dict["MountPropagation"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("ReadOnly") {
                        self.readOnly = dict["ReadOnly"] as! Bool
                    }
                    if dict.keys.contains("SubPath") {
                        self.subPath = dict["SubPath"] as! String
                    }
                }
            }
            public var cpu: Double?

            public var gpu: Int32?

            public var image: String?

            public var imagePullPolicy: String?

            public var initContainerArgs: [String]?

            public var initContainerCommands: [String]?

            public var initContainerEnvironmentVars: [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.InitContainers.InitContainerEnvironmentVars]?

            public var initContainerPorts: [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.InitContainers.InitContainerPorts]?

            public var initContainerVolumeMounts: [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.InitContainers.InitContainerVolumeMounts]?

            public var memory: Double?

            public var name: String?

            public var securityContextCapabilityAdds: [String]?

            public var securityContextReadOnlyRootFilesystem: Bool?

            public var securityContextRunAsUser: String?

            public var workingDir: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cpu != nil {
                    map["Cpu"] = self.cpu!
                }
                if self.gpu != nil {
                    map["Gpu"] = self.gpu!
                }
                if self.image != nil {
                    map["Image"] = self.image!
                }
                if self.imagePullPolicy != nil {
                    map["ImagePullPolicy"] = self.imagePullPolicy!
                }
                if self.initContainerArgs != nil {
                    map["InitContainerArgs"] = self.initContainerArgs!
                }
                if self.initContainerCommands != nil {
                    map["InitContainerCommands"] = self.initContainerCommands!
                }
                if self.initContainerEnvironmentVars != nil {
                    var tmp : [Any] = []
                    for k in self.initContainerEnvironmentVars! {
                        tmp.append(k.toMap())
                    }
                    map["InitContainerEnvironmentVars"] = tmp
                }
                if self.initContainerPorts != nil {
                    var tmp : [Any] = []
                    for k in self.initContainerPorts! {
                        tmp.append(k.toMap())
                    }
                    map["InitContainerPorts"] = tmp
                }
                if self.initContainerVolumeMounts != nil {
                    var tmp : [Any] = []
                    for k in self.initContainerVolumeMounts! {
                        tmp.append(k.toMap())
                    }
                    map["InitContainerVolumeMounts"] = tmp
                }
                if self.memory != nil {
                    map["Memory"] = self.memory!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.securityContextCapabilityAdds != nil {
                    map["SecurityContextCapabilityAdds"] = self.securityContextCapabilityAdds!
                }
                if self.securityContextReadOnlyRootFilesystem != nil {
                    map["SecurityContextReadOnlyRootFilesystem"] = self.securityContextReadOnlyRootFilesystem!
                }
                if self.securityContextRunAsUser != nil {
                    map["SecurityContextRunAsUser"] = self.securityContextRunAsUser!
                }
                if self.workingDir != nil {
                    map["WorkingDir"] = self.workingDir!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Cpu") {
                    self.cpu = dict["Cpu"] as! Double
                }
                if dict.keys.contains("Gpu") {
                    self.gpu = dict["Gpu"] as! Int32
                }
                if dict.keys.contains("Image") {
                    self.image = dict["Image"] as! String
                }
                if dict.keys.contains("ImagePullPolicy") {
                    self.imagePullPolicy = dict["ImagePullPolicy"] as! String
                }
                if dict.keys.contains("InitContainerArgs") {
                    self.initContainerArgs = dict["InitContainerArgs"] as! [String]
                }
                if dict.keys.contains("InitContainerCommands") {
                    self.initContainerCommands = dict["InitContainerCommands"] as! [String]
                }
                if dict.keys.contains("InitContainerEnvironmentVars") {
                    var tmp : [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.InitContainers.InitContainerEnvironmentVars] = []
                    for v in dict["InitContainerEnvironmentVars"] as! [Any] {
                        var model = DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.InitContainers.InitContainerEnvironmentVars()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.initContainerEnvironmentVars = tmp
                }
                if dict.keys.contains("InitContainerPorts") {
                    var tmp : [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.InitContainers.InitContainerPorts] = []
                    for v in dict["InitContainerPorts"] as! [Any] {
                        var model = DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.InitContainers.InitContainerPorts()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.initContainerPorts = tmp
                }
                if dict.keys.contains("InitContainerVolumeMounts") {
                    var tmp : [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.InitContainers.InitContainerVolumeMounts] = []
                    for v in dict["InitContainerVolumeMounts"] as! [Any] {
                        var model = DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.InitContainers.InitContainerVolumeMounts()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.initContainerVolumeMounts = tmp
                }
                if dict.keys.contains("Memory") {
                    self.memory = dict["Memory"] as! Double
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("SecurityContextCapabilityAdds") {
                    self.securityContextCapabilityAdds = dict["SecurityContextCapabilityAdds"] as! [String]
                }
                if dict.keys.contains("SecurityContextReadOnlyRootFilesystem") {
                    self.securityContextReadOnlyRootFilesystem = dict["SecurityContextReadOnlyRootFilesystem"] as! Bool
                }
                if dict.keys.contains("SecurityContextRunAsUser") {
                    self.securityContextRunAsUser = dict["SecurityContextRunAsUser"] as! String
                }
                if dict.keys.contains("WorkingDir") {
                    self.workingDir = dict["WorkingDir"] as! String
                }
            }
        }
        public class SecurityContextSysCtls : Tea.TeaModel {
            public var name: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public class Tags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public class Volumes : Tea.TeaModel {
            public class ConfigFileVolumeConfigFileToPaths : Tea.TeaModel {
                public var content: String?

                public var mode: Int32?

                public var path: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.content != nil {
                        map["Content"] = self.content!
                    }
                    if self.mode != nil {
                        map["Mode"] = self.mode!
                    }
                    if self.path != nil {
                        map["Path"] = self.path!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Content") {
                        self.content = dict["Content"] as! String
                    }
                    if dict.keys.contains("Mode") {
                        self.mode = dict["Mode"] as! Int32
                    }
                    if dict.keys.contains("Path") {
                        self.path = dict["Path"] as! String
                    }
                }
            }
            public var configFileVolumeConfigFileToPaths: [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.Volumes.ConfigFileVolumeConfigFileToPaths]?

            public var configFileVolumeDefaultMode: Int32?

            public var diskVolumeDiskId: String?

            public var diskVolumeDiskSize: Int32?

            public var diskVolumeFsType: String?

            public var emptyDirVolumeMedium: String?

            public var emptyDirVolumeSizeLimit: String?

            public var flexVolumeDriver: String?

            public var flexVolumeFsType: String?

            public var flexVolumeOptions: String?

            public var hostPathVolumePath: String?

            public var hostPathVolumeType: String?

            public var NFSVolumePath: String?

            public var NFSVolumeReadOnly: Bool?

            public var NFSVolumeServer: String?

            public var name: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.configFileVolumeConfigFileToPaths != nil {
                    var tmp : [Any] = []
                    for k in self.configFileVolumeConfigFileToPaths! {
                        tmp.append(k.toMap())
                    }
                    map["ConfigFileVolumeConfigFileToPaths"] = tmp
                }
                if self.configFileVolumeDefaultMode != nil {
                    map["ConfigFileVolumeDefaultMode"] = self.configFileVolumeDefaultMode!
                }
                if self.diskVolumeDiskId != nil {
                    map["DiskVolumeDiskId"] = self.diskVolumeDiskId!
                }
                if self.diskVolumeDiskSize != nil {
                    map["DiskVolumeDiskSize"] = self.diskVolumeDiskSize!
                }
                if self.diskVolumeFsType != nil {
                    map["DiskVolumeFsType"] = self.diskVolumeFsType!
                }
                if self.emptyDirVolumeMedium != nil {
                    map["EmptyDirVolumeMedium"] = self.emptyDirVolumeMedium!
                }
                if self.emptyDirVolumeSizeLimit != nil {
                    map["EmptyDirVolumeSizeLimit"] = self.emptyDirVolumeSizeLimit!
                }
                if self.flexVolumeDriver != nil {
                    map["FlexVolumeDriver"] = self.flexVolumeDriver!
                }
                if self.flexVolumeFsType != nil {
                    map["FlexVolumeFsType"] = self.flexVolumeFsType!
                }
                if self.flexVolumeOptions != nil {
                    map["FlexVolumeOptions"] = self.flexVolumeOptions!
                }
                if self.hostPathVolumePath != nil {
                    map["HostPathVolumePath"] = self.hostPathVolumePath!
                }
                if self.hostPathVolumeType != nil {
                    map["HostPathVolumeType"] = self.hostPathVolumeType!
                }
                if self.NFSVolumePath != nil {
                    map["NFSVolumePath"] = self.NFSVolumePath!
                }
                if self.NFSVolumeReadOnly != nil {
                    map["NFSVolumeReadOnly"] = self.NFSVolumeReadOnly!
                }
                if self.NFSVolumeServer != nil {
                    map["NFSVolumeServer"] = self.NFSVolumeServer!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ConfigFileVolumeConfigFileToPaths") {
                    var tmp : [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.Volumes.ConfigFileVolumeConfigFileToPaths] = []
                    for v in dict["ConfigFileVolumeConfigFileToPaths"] as! [Any] {
                        var model = DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.Volumes.ConfigFileVolumeConfigFileToPaths()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.configFileVolumeConfigFileToPaths = tmp
                }
                if dict.keys.contains("ConfigFileVolumeDefaultMode") {
                    self.configFileVolumeDefaultMode = dict["ConfigFileVolumeDefaultMode"] as! Int32
                }
                if dict.keys.contains("DiskVolumeDiskId") {
                    self.diskVolumeDiskId = dict["DiskVolumeDiskId"] as! String
                }
                if dict.keys.contains("DiskVolumeDiskSize") {
                    self.diskVolumeDiskSize = dict["DiskVolumeDiskSize"] as! Int32
                }
                if dict.keys.contains("DiskVolumeFsType") {
                    self.diskVolumeFsType = dict["DiskVolumeFsType"] as! String
                }
                if dict.keys.contains("EmptyDirVolumeMedium") {
                    self.emptyDirVolumeMedium = dict["EmptyDirVolumeMedium"] as! String
                }
                if dict.keys.contains("EmptyDirVolumeSizeLimit") {
                    self.emptyDirVolumeSizeLimit = dict["EmptyDirVolumeSizeLimit"] as! String
                }
                if dict.keys.contains("FlexVolumeDriver") {
                    self.flexVolumeDriver = dict["FlexVolumeDriver"] as! String
                }
                if dict.keys.contains("FlexVolumeFsType") {
                    self.flexVolumeFsType = dict["FlexVolumeFsType"] as! String
                }
                if dict.keys.contains("FlexVolumeOptions") {
                    self.flexVolumeOptions = dict["FlexVolumeOptions"] as! String
                }
                if dict.keys.contains("HostPathVolumePath") {
                    self.hostPathVolumePath = dict["HostPathVolumePath"] as! String
                }
                if dict.keys.contains("HostPathVolumeType") {
                    self.hostPathVolumeType = dict["HostPathVolumeType"] as! String
                }
                if dict.keys.contains("NFSVolumePath") {
                    self.NFSVolumePath = dict["NFSVolumePath"] as! String
                }
                if dict.keys.contains("NFSVolumeReadOnly") {
                    self.NFSVolumeReadOnly = dict["NFSVolumeReadOnly"] as! Bool
                }
                if dict.keys.contains("NFSVolumeServer") {
                    self.NFSVolumeServer = dict["NFSVolumeServer"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var acrRegistryInfos: [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.AcrRegistryInfos]?

        public var activeDeadlineSeconds: Int32?

        public var autoCreateEip: Bool?

        public var autoMatchImageCache: Bool?

        public var computeCategory: [String]?

        public var containerGroupName: String?

        public var containers: [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.Containers]?

        public var costOptimization: Bool?

        public var cpu: Double?

        public var cpuOptionsCore: Int32?

        public var cpuOptionsThreadsPerCore: Int32?

        public var creationTime: String?

        public var dataCacheBucket: String?

        public var dataCacheBurstingEnabled: Bool?

        public var dataCachePL: String?

        public var dataCacheProvisionedIops: Int32?

        public var description_: String?

        public var dnsConfigNameServers: [String]?

        public var dnsConfigOptions: [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.DnsConfigOptions]?

        public var dnsConfigSearches: [String]?

        public var dnsPolicy: String?

        public var egressBandwidth: Int64?

        public var eipBandwidth: Int32?

        public var eipCommonBandwidthPackage: String?

        public var eipISP: String?

        public var eipPublicIpAddressPoolId: String?

        public var ephemeralStorage: Int32?

        public var hostAliases: [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.HostAliases]?

        public var hostName: String?

        public var imageRegistryCredentials: [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.ImageRegistryCredentials]?

        public var imageSnapshotId: String?

        public var ingressBandwidth: Int64?

        public var initContainers: [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.InitContainers]?

        public var instanceFamilyLevel: String?

        public var instanceTypes: [String]?

        public var ipv6AddressCount: Int32?

        public var lifecycleState: String?

        public var loadBalancerWeight: Int32?

        public var memory: Double?

        public var ntpServers: [String]?

        public var ramRoleName: String?

        public var regionId: String?

        public var resourceGroupId: String?

        public var restartPolicy: String?

        public var scalingConfigurationId: String?

        public var scalingConfigurationName: String?

        public var scalingGroupId: String?

        public var securityContextSysCtls: [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.SecurityContextSysCtls]?

        public var securityGroupId: String?

        public var slsEnable: Bool?

        public var spotPriceLimit: Double?

        public var spotStrategy: String?

        public var tags: [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.Tags]?

        public var terminationGracePeriodSeconds: Int32?

        public var volumes: [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.Volumes]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.acrRegistryInfos != nil {
                var tmp : [Any] = []
                for k in self.acrRegistryInfos! {
                    tmp.append(k.toMap())
                }
                map["AcrRegistryInfos"] = tmp
            }
            if self.activeDeadlineSeconds != nil {
                map["ActiveDeadlineSeconds"] = self.activeDeadlineSeconds!
            }
            if self.autoCreateEip != nil {
                map["AutoCreateEip"] = self.autoCreateEip!
            }
            if self.autoMatchImageCache != nil {
                map["AutoMatchImageCache"] = self.autoMatchImageCache!
            }
            if self.computeCategory != nil {
                map["ComputeCategory"] = self.computeCategory!
            }
            if self.containerGroupName != nil {
                map["ContainerGroupName"] = self.containerGroupName!
            }
            if self.containers != nil {
                var tmp : [Any] = []
                for k in self.containers! {
                    tmp.append(k.toMap())
                }
                map["Containers"] = tmp
            }
            if self.costOptimization != nil {
                map["CostOptimization"] = self.costOptimization!
            }
            if self.cpu != nil {
                map["Cpu"] = self.cpu!
            }
            if self.cpuOptionsCore != nil {
                map["CpuOptionsCore"] = self.cpuOptionsCore!
            }
            if self.cpuOptionsThreadsPerCore != nil {
                map["CpuOptionsThreadsPerCore"] = self.cpuOptionsThreadsPerCore!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.dataCacheBucket != nil {
                map["DataCacheBucket"] = self.dataCacheBucket!
            }
            if self.dataCacheBurstingEnabled != nil {
                map["DataCacheBurstingEnabled"] = self.dataCacheBurstingEnabled!
            }
            if self.dataCachePL != nil {
                map["DataCachePL"] = self.dataCachePL!
            }
            if self.dataCacheProvisionedIops != nil {
                map["DataCacheProvisionedIops"] = self.dataCacheProvisionedIops!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.dnsConfigNameServers != nil {
                map["DnsConfigNameServers"] = self.dnsConfigNameServers!
            }
            if self.dnsConfigOptions != nil {
                var tmp : [Any] = []
                for k in self.dnsConfigOptions! {
                    tmp.append(k.toMap())
                }
                map["DnsConfigOptions"] = tmp
            }
            if self.dnsConfigSearches != nil {
                map["DnsConfigSearches"] = self.dnsConfigSearches!
            }
            if self.dnsPolicy != nil {
                map["DnsPolicy"] = self.dnsPolicy!
            }
            if self.egressBandwidth != nil {
                map["EgressBandwidth"] = self.egressBandwidth!
            }
            if self.eipBandwidth != nil {
                map["EipBandwidth"] = self.eipBandwidth!
            }
            if self.eipCommonBandwidthPackage != nil {
                map["EipCommonBandwidthPackage"] = self.eipCommonBandwidthPackage!
            }
            if self.eipISP != nil {
                map["EipISP"] = self.eipISP!
            }
            if self.eipPublicIpAddressPoolId != nil {
                map["EipPublicIpAddressPoolId"] = self.eipPublicIpAddressPoolId!
            }
            if self.ephemeralStorage != nil {
                map["EphemeralStorage"] = self.ephemeralStorage!
            }
            if self.hostAliases != nil {
                var tmp : [Any] = []
                for k in self.hostAliases! {
                    tmp.append(k.toMap())
                }
                map["HostAliases"] = tmp
            }
            if self.hostName != nil {
                map["HostName"] = self.hostName!
            }
            if self.imageRegistryCredentials != nil {
                var tmp : [Any] = []
                for k in self.imageRegistryCredentials! {
                    tmp.append(k.toMap())
                }
                map["ImageRegistryCredentials"] = tmp
            }
            if self.imageSnapshotId != nil {
                map["ImageSnapshotId"] = self.imageSnapshotId!
            }
            if self.ingressBandwidth != nil {
                map["IngressBandwidth"] = self.ingressBandwidth!
            }
            if self.initContainers != nil {
                var tmp : [Any] = []
                for k in self.initContainers! {
                    tmp.append(k.toMap())
                }
                map["InitContainers"] = tmp
            }
            if self.instanceFamilyLevel != nil {
                map["InstanceFamilyLevel"] = self.instanceFamilyLevel!
            }
            if self.instanceTypes != nil {
                map["InstanceTypes"] = self.instanceTypes!
            }
            if self.ipv6AddressCount != nil {
                map["Ipv6AddressCount"] = self.ipv6AddressCount!
            }
            if self.lifecycleState != nil {
                map["LifecycleState"] = self.lifecycleState!
            }
            if self.loadBalancerWeight != nil {
                map["LoadBalancerWeight"] = self.loadBalancerWeight!
            }
            if self.memory != nil {
                map["Memory"] = self.memory!
            }
            if self.ntpServers != nil {
                map["NtpServers"] = self.ntpServers!
            }
            if self.ramRoleName != nil {
                map["RamRoleName"] = self.ramRoleName!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.restartPolicy != nil {
                map["RestartPolicy"] = self.restartPolicy!
            }
            if self.scalingConfigurationId != nil {
                map["ScalingConfigurationId"] = self.scalingConfigurationId!
            }
            if self.scalingConfigurationName != nil {
                map["ScalingConfigurationName"] = self.scalingConfigurationName!
            }
            if self.scalingGroupId != nil {
                map["ScalingGroupId"] = self.scalingGroupId!
            }
            if self.securityContextSysCtls != nil {
                var tmp : [Any] = []
                for k in self.securityContextSysCtls! {
                    tmp.append(k.toMap())
                }
                map["SecurityContextSysCtls"] = tmp
            }
            if self.securityGroupId != nil {
                map["SecurityGroupId"] = self.securityGroupId!
            }
            if self.slsEnable != nil {
                map["SlsEnable"] = self.slsEnable!
            }
            if self.spotPriceLimit != nil {
                map["SpotPriceLimit"] = self.spotPriceLimit!
            }
            if self.spotStrategy != nil {
                map["SpotStrategy"] = self.spotStrategy!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            if self.terminationGracePeriodSeconds != nil {
                map["TerminationGracePeriodSeconds"] = self.terminationGracePeriodSeconds!
            }
            if self.volumes != nil {
                var tmp : [Any] = []
                for k in self.volumes! {
                    tmp.append(k.toMap())
                }
                map["Volumes"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AcrRegistryInfos") {
                var tmp : [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.AcrRegistryInfos] = []
                for v in dict["AcrRegistryInfos"] as! [Any] {
                    var model = DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.AcrRegistryInfos()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.acrRegistryInfos = tmp
            }
            if dict.keys.contains("ActiveDeadlineSeconds") {
                self.activeDeadlineSeconds = dict["ActiveDeadlineSeconds"] as! Int32
            }
            if dict.keys.contains("AutoCreateEip") {
                self.autoCreateEip = dict["AutoCreateEip"] as! Bool
            }
            if dict.keys.contains("AutoMatchImageCache") {
                self.autoMatchImageCache = dict["AutoMatchImageCache"] as! Bool
            }
            if dict.keys.contains("ComputeCategory") {
                self.computeCategory = dict["ComputeCategory"] as! [String]
            }
            if dict.keys.contains("ContainerGroupName") {
                self.containerGroupName = dict["ContainerGroupName"] as! String
            }
            if dict.keys.contains("Containers") {
                var tmp : [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.Containers] = []
                for v in dict["Containers"] as! [Any] {
                    var model = DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.Containers()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.containers = tmp
            }
            if dict.keys.contains("CostOptimization") {
                self.costOptimization = dict["CostOptimization"] as! Bool
            }
            if dict.keys.contains("Cpu") {
                self.cpu = dict["Cpu"] as! Double
            }
            if dict.keys.contains("CpuOptionsCore") {
                self.cpuOptionsCore = dict["CpuOptionsCore"] as! Int32
            }
            if dict.keys.contains("CpuOptionsThreadsPerCore") {
                self.cpuOptionsThreadsPerCore = dict["CpuOptionsThreadsPerCore"] as! Int32
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("DataCacheBucket") {
                self.dataCacheBucket = dict["DataCacheBucket"] as! String
            }
            if dict.keys.contains("DataCacheBurstingEnabled") {
                self.dataCacheBurstingEnabled = dict["DataCacheBurstingEnabled"] as! Bool
            }
            if dict.keys.contains("DataCachePL") {
                self.dataCachePL = dict["DataCachePL"] as! String
            }
            if dict.keys.contains("DataCacheProvisionedIops") {
                self.dataCacheProvisionedIops = dict["DataCacheProvisionedIops"] as! Int32
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("DnsConfigNameServers") {
                self.dnsConfigNameServers = dict["DnsConfigNameServers"] as! [String]
            }
            if dict.keys.contains("DnsConfigOptions") {
                var tmp : [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.DnsConfigOptions] = []
                for v in dict["DnsConfigOptions"] as! [Any] {
                    var model = DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.DnsConfigOptions()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.dnsConfigOptions = tmp
            }
            if dict.keys.contains("DnsConfigSearches") {
                self.dnsConfigSearches = dict["DnsConfigSearches"] as! [String]
            }
            if dict.keys.contains("DnsPolicy") {
                self.dnsPolicy = dict["DnsPolicy"] as! String
            }
            if dict.keys.contains("EgressBandwidth") {
                self.egressBandwidth = dict["EgressBandwidth"] as! Int64
            }
            if dict.keys.contains("EipBandwidth") {
                self.eipBandwidth = dict["EipBandwidth"] as! Int32
            }
            if dict.keys.contains("EipCommonBandwidthPackage") {
                self.eipCommonBandwidthPackage = dict["EipCommonBandwidthPackage"] as! String
            }
            if dict.keys.contains("EipISP") {
                self.eipISP = dict["EipISP"] as! String
            }
            if dict.keys.contains("EipPublicIpAddressPoolId") {
                self.eipPublicIpAddressPoolId = dict["EipPublicIpAddressPoolId"] as! String
            }
            if dict.keys.contains("EphemeralStorage") {
                self.ephemeralStorage = dict["EphemeralStorage"] as! Int32
            }
            if dict.keys.contains("HostAliases") {
                var tmp : [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.HostAliases] = []
                for v in dict["HostAliases"] as! [Any] {
                    var model = DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.HostAliases()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.hostAliases = tmp
            }
            if dict.keys.contains("HostName") {
                self.hostName = dict["HostName"] as! String
            }
            if dict.keys.contains("ImageRegistryCredentials") {
                var tmp : [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.ImageRegistryCredentials] = []
                for v in dict["ImageRegistryCredentials"] as! [Any] {
                    var model = DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.ImageRegistryCredentials()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.imageRegistryCredentials = tmp
            }
            if dict.keys.contains("ImageSnapshotId") {
                self.imageSnapshotId = dict["ImageSnapshotId"] as! String
            }
            if dict.keys.contains("IngressBandwidth") {
                self.ingressBandwidth = dict["IngressBandwidth"] as! Int64
            }
            if dict.keys.contains("InitContainers") {
                var tmp : [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.InitContainers] = []
                for v in dict["InitContainers"] as! [Any] {
                    var model = DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.InitContainers()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.initContainers = tmp
            }
            if dict.keys.contains("InstanceFamilyLevel") {
                self.instanceFamilyLevel = dict["InstanceFamilyLevel"] as! String
            }
            if dict.keys.contains("InstanceTypes") {
                self.instanceTypes = dict["InstanceTypes"] as! [String]
            }
            if dict.keys.contains("Ipv6AddressCount") {
                self.ipv6AddressCount = dict["Ipv6AddressCount"] as! Int32
            }
            if dict.keys.contains("LifecycleState") {
                self.lifecycleState = dict["LifecycleState"] as! String
            }
            if dict.keys.contains("LoadBalancerWeight") {
                self.loadBalancerWeight = dict["LoadBalancerWeight"] as! Int32
            }
            if dict.keys.contains("Memory") {
                self.memory = dict["Memory"] as! Double
            }
            if dict.keys.contains("NtpServers") {
                self.ntpServers = dict["NtpServers"] as! [String]
            }
            if dict.keys.contains("RamRoleName") {
                self.ramRoleName = dict["RamRoleName"] as! String
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("ResourceGroupId") {
                self.resourceGroupId = dict["ResourceGroupId"] as! String
            }
            if dict.keys.contains("RestartPolicy") {
                self.restartPolicy = dict["RestartPolicy"] as! String
            }
            if dict.keys.contains("ScalingConfigurationId") {
                self.scalingConfigurationId = dict["ScalingConfigurationId"] as! String
            }
            if dict.keys.contains("ScalingConfigurationName") {
                self.scalingConfigurationName = dict["ScalingConfigurationName"] as! String
            }
            if dict.keys.contains("ScalingGroupId") {
                self.scalingGroupId = dict["ScalingGroupId"] as! String
            }
            if dict.keys.contains("SecurityContextSysCtls") {
                var tmp : [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.SecurityContextSysCtls] = []
                for v in dict["SecurityContextSysCtls"] as! [Any] {
                    var model = DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.SecurityContextSysCtls()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.securityContextSysCtls = tmp
            }
            if dict.keys.contains("SecurityGroupId") {
                self.securityGroupId = dict["SecurityGroupId"] as! String
            }
            if dict.keys.contains("SlsEnable") {
                self.slsEnable = dict["SlsEnable"] as! Bool
            }
            if dict.keys.contains("SpotPriceLimit") {
                self.spotPriceLimit = dict["SpotPriceLimit"] as! Double
            }
            if dict.keys.contains("SpotStrategy") {
                self.spotStrategy = dict["SpotStrategy"] as! String
            }
            if dict.keys.contains("Tags") {
                var tmp : [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.Tags] = []
                for v in dict["Tags"] as! [Any] {
                    var model = DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.Tags()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tags = tmp
            }
            if dict.keys.contains("TerminationGracePeriodSeconds") {
                self.terminationGracePeriodSeconds = dict["TerminationGracePeriodSeconds"] as! Int32
            }
            if dict.keys.contains("Volumes") {
                var tmp : [DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.Volumes] = []
                for v in dict["Volumes"] as! [Any] {
                    var model = DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration.Volumes()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.volumes = tmp
            }
        }
    }
    public var output: String?

    public var requestId: String?

    public var scalingConfiguration: DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.scalingConfiguration?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.output != nil {
            map["Output"] = self.output!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingConfiguration != nil {
            map["ScalingConfiguration"] = self.scalingConfiguration?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Output") {
            self.output = dict["Output"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScalingConfiguration") {
            var model = DescribeEciScalingConfigurationDetailResponseBody.ScalingConfiguration()
            model.fromMap(dict["ScalingConfiguration"] as! [String: Any])
            self.scalingConfiguration = model
        }
    }
}

public class DescribeEciScalingConfigurationDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEciScalingConfigurationDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeEciScalingConfigurationDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEciScalingConfigurationsRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var scalingConfigurationIds: [String]?

    public var scalingConfigurationNames: [String]?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.scalingConfigurationIds != nil {
            map["ScalingConfigurationIds"] = self.scalingConfigurationIds!
        }
        if self.scalingConfigurationNames != nil {
            map["ScalingConfigurationNames"] = self.scalingConfigurationNames!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ScalingConfigurationIds") {
            self.scalingConfigurationIds = dict["ScalingConfigurationIds"] as! [String]
        }
        if dict.keys.contains("ScalingConfigurationNames") {
            self.scalingConfigurationNames = dict["ScalingConfigurationNames"] as! [String]
        }
        if dict.keys.contains("ScalingGroupId") {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
    }
}

public class DescribeEciScalingConfigurationsResponseBody : Tea.TeaModel {
    public class ScalingConfigurations : Tea.TeaModel {
        public class AcrRegistryInfos : Tea.TeaModel {
            public var domains: [String]?

            public var instanceId: String?

            public var instanceName: String?

            public var regionId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.domains != nil {
                    map["Domains"] = self.domains!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.instanceName != nil {
                    map["InstanceName"] = self.instanceName!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Domains") {
                    self.domains = dict["Domains"] as! [String]
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("InstanceName") {
                    self.instanceName = dict["InstanceName"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
            }
        }
        public class Containers : Tea.TeaModel {
            public class EnvironmentVars : Tea.TeaModel {
                public var fieldRefFieldPath: String?

                public var key: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.fieldRefFieldPath != nil {
                        map["FieldRefFieldPath"] = self.fieldRefFieldPath!
                    }
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("FieldRefFieldPath") {
                        self.fieldRefFieldPath = dict["FieldRefFieldPath"] as! String
                    }
                    if dict.keys.contains("Key") {
                        self.key = dict["Key"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class Ports : Tea.TeaModel {
                public var port: Int32?

                public var protocol_: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.port != nil {
                        map["Port"] = self.port!
                    }
                    if self.protocol_ != nil {
                        map["Protocol"] = self.protocol_!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Port") {
                        self.port = dict["Port"] as! Int32
                    }
                    if dict.keys.contains("Protocol") {
                        self.protocol_ = dict["Protocol"] as! String
                    }
                }
            }
            public class VolumeMounts : Tea.TeaModel {
                public var mountPath: String?

                public var mountPropagation: String?

                public var name: String?

                public var readOnly: Bool?

                public var subPath: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.mountPath != nil {
                        map["MountPath"] = self.mountPath!
                    }
                    if self.mountPropagation != nil {
                        map["MountPropagation"] = self.mountPropagation!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.readOnly != nil {
                        map["ReadOnly"] = self.readOnly!
                    }
                    if self.subPath != nil {
                        map["SubPath"] = self.subPath!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("MountPath") {
                        self.mountPath = dict["MountPath"] as! String
                    }
                    if dict.keys.contains("MountPropagation") {
                        self.mountPropagation = dict["MountPropagation"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("ReadOnly") {
                        self.readOnly = dict["ReadOnly"] as! Bool
                    }
                    if dict.keys.contains("SubPath") {
                        self.subPath = dict["SubPath"] as! String
                    }
                }
            }
            public var args: [String]?

            public var commands: [String]?

            public var cpu: Double?

            public var environmentVars: [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.Containers.EnvironmentVars]?

            public var gpu: Int32?

            public var image: String?

            public var imagePullPolicy: String?

            public var lifecyclePostStartHandlerExecs: [String]?

            public var lifecyclePostStartHandlerHttpGetHost: String?

            public var lifecyclePostStartHandlerHttpGetPath: String?

            public var lifecyclePostStartHandlerHttpGetPort: Int32?

            public var lifecyclePostStartHandlerHttpGetScheme: String?

            public var lifecyclePostStartHandlerTcpSocketHost: String?

            public var lifecyclePostStartHandlerTcpSocketPort: Int32?

            public var lifecyclePreStopHandlerExecs: [String]?

            public var lifecyclePreStopHandlerHttpGetHost: String?

            public var lifecyclePreStopHandlerHttpGetPath: String?

            public var lifecyclePreStopHandlerHttpGetPort: Int32?

            public var lifecyclePreStopHandlerHttpGetScheme: String?

            public var lifecyclePreStopHandlerTcpSocketHost: String?

            public var lifecyclePreStopHandlerTcpSocketPort: Int32?

            public var livenessProbeExecCommands: [String]?

            public var livenessProbeFailureThreshold: Int32?

            public var livenessProbeHttpGetPath: String?

            public var livenessProbeHttpGetPort: Int32?

            public var livenessProbeHttpGetScheme: String?

            public var livenessProbeInitialDelaySeconds: Int32?

            public var livenessProbePeriodSeconds: Int32?

            public var livenessProbeSuccessThreshold: Int32?

            public var livenessProbeTcpSocketPort: Int32?

            public var livenessProbeTimeoutSeconds: Int32?

            public var memory: Double?

            public var name: String?

            public var ports: [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.Containers.Ports]?

            public var readinessProbeExecCommands: [String]?

            public var readinessProbeFailureThreshold: Int32?

            public var readinessProbeHttpGetPath: String?

            public var readinessProbeHttpGetPort: Int32?

            public var readinessProbeHttpGetScheme: String?

            public var readinessProbeInitialDelaySeconds: Int32?

            public var readinessProbePeriodSeconds: Int32?

            public var readinessProbeSuccessThreshold: Int32?

            public var readinessProbeTcpSocketPort: Int32?

            public var readinessProbeTimeoutSeconds: Int32?

            public var securityContextCapabilityAdds: [String]?

            public var securityContextReadOnlyRootFilesystem: Bool?

            public var securityContextRunAsUser: Int64?

            public var stdin: Bool?

            public var stdinOnce: Bool?

            public var tty: Bool?

            public var volumeMounts: [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.Containers.VolumeMounts]?

            public var workingDir: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.args != nil {
                    map["Args"] = self.args!
                }
                if self.commands != nil {
                    map["Commands"] = self.commands!
                }
                if self.cpu != nil {
                    map["Cpu"] = self.cpu!
                }
                if self.environmentVars != nil {
                    var tmp : [Any] = []
                    for k in self.environmentVars! {
                        tmp.append(k.toMap())
                    }
                    map["EnvironmentVars"] = tmp
                }
                if self.gpu != nil {
                    map["Gpu"] = self.gpu!
                }
                if self.image != nil {
                    map["Image"] = self.image!
                }
                if self.imagePullPolicy != nil {
                    map["ImagePullPolicy"] = self.imagePullPolicy!
                }
                if self.lifecyclePostStartHandlerExecs != nil {
                    map["LifecyclePostStartHandlerExecs"] = self.lifecyclePostStartHandlerExecs!
                }
                if self.lifecyclePostStartHandlerHttpGetHost != nil {
                    map["LifecyclePostStartHandlerHttpGetHost"] = self.lifecyclePostStartHandlerHttpGetHost!
                }
                if self.lifecyclePostStartHandlerHttpGetPath != nil {
                    map["LifecyclePostStartHandlerHttpGetPath"] = self.lifecyclePostStartHandlerHttpGetPath!
                }
                if self.lifecyclePostStartHandlerHttpGetPort != nil {
                    map["LifecyclePostStartHandlerHttpGetPort"] = self.lifecyclePostStartHandlerHttpGetPort!
                }
                if self.lifecyclePostStartHandlerHttpGetScheme != nil {
                    map["LifecyclePostStartHandlerHttpGetScheme"] = self.lifecyclePostStartHandlerHttpGetScheme!
                }
                if self.lifecyclePostStartHandlerTcpSocketHost != nil {
                    map["LifecyclePostStartHandlerTcpSocketHost"] = self.lifecyclePostStartHandlerTcpSocketHost!
                }
                if self.lifecyclePostStartHandlerTcpSocketPort != nil {
                    map["LifecyclePostStartHandlerTcpSocketPort"] = self.lifecyclePostStartHandlerTcpSocketPort!
                }
                if self.lifecyclePreStopHandlerExecs != nil {
                    map["LifecyclePreStopHandlerExecs"] = self.lifecyclePreStopHandlerExecs!
                }
                if self.lifecyclePreStopHandlerHttpGetHost != nil {
                    map["LifecyclePreStopHandlerHttpGetHost"] = self.lifecyclePreStopHandlerHttpGetHost!
                }
                if self.lifecyclePreStopHandlerHttpGetPath != nil {
                    map["LifecyclePreStopHandlerHttpGetPath"] = self.lifecyclePreStopHandlerHttpGetPath!
                }
                if self.lifecyclePreStopHandlerHttpGetPort != nil {
                    map["LifecyclePreStopHandlerHttpGetPort"] = self.lifecyclePreStopHandlerHttpGetPort!
                }
                if self.lifecyclePreStopHandlerHttpGetScheme != nil {
                    map["LifecyclePreStopHandlerHttpGetScheme"] = self.lifecyclePreStopHandlerHttpGetScheme!
                }
                if self.lifecyclePreStopHandlerTcpSocketHost != nil {
                    map["LifecyclePreStopHandlerTcpSocketHost"] = self.lifecyclePreStopHandlerTcpSocketHost!
                }
                if self.lifecyclePreStopHandlerTcpSocketPort != nil {
                    map["LifecyclePreStopHandlerTcpSocketPort"] = self.lifecyclePreStopHandlerTcpSocketPort!
                }
                if self.livenessProbeExecCommands != nil {
                    map["LivenessProbeExecCommands"] = self.livenessProbeExecCommands!
                }
                if self.livenessProbeFailureThreshold != nil {
                    map["LivenessProbeFailureThreshold"] = self.livenessProbeFailureThreshold!
                }
                if self.livenessProbeHttpGetPath != nil {
                    map["LivenessProbeHttpGetPath"] = self.livenessProbeHttpGetPath!
                }
                if self.livenessProbeHttpGetPort != nil {
                    map["LivenessProbeHttpGetPort"] = self.livenessProbeHttpGetPort!
                }
                if self.livenessProbeHttpGetScheme != nil {
                    map["LivenessProbeHttpGetScheme"] = self.livenessProbeHttpGetScheme!
                }
                if self.livenessProbeInitialDelaySeconds != nil {
                    map["LivenessProbeInitialDelaySeconds"] = self.livenessProbeInitialDelaySeconds!
                }
                if self.livenessProbePeriodSeconds != nil {
                    map["LivenessProbePeriodSeconds"] = self.livenessProbePeriodSeconds!
                }
                if self.livenessProbeSuccessThreshold != nil {
                    map["LivenessProbeSuccessThreshold"] = self.livenessProbeSuccessThreshold!
                }
                if self.livenessProbeTcpSocketPort != nil {
                    map["LivenessProbeTcpSocketPort"] = self.livenessProbeTcpSocketPort!
                }
                if self.livenessProbeTimeoutSeconds != nil {
                    map["LivenessProbeTimeoutSeconds"] = self.livenessProbeTimeoutSeconds!
                }
                if self.memory != nil {
                    map["Memory"] = self.memory!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.ports != nil {
                    var tmp : [Any] = []
                    for k in self.ports! {
                        tmp.append(k.toMap())
                    }
                    map["Ports"] = tmp
                }
                if self.readinessProbeExecCommands != nil {
                    map["ReadinessProbeExecCommands"] = self.readinessProbeExecCommands!
                }
                if self.readinessProbeFailureThreshold != nil {
                    map["ReadinessProbeFailureThreshold"] = self.readinessProbeFailureThreshold!
                }
                if self.readinessProbeHttpGetPath != nil {
                    map["ReadinessProbeHttpGetPath"] = self.readinessProbeHttpGetPath!
                }
                if self.readinessProbeHttpGetPort != nil {
                    map["ReadinessProbeHttpGetPort"] = self.readinessProbeHttpGetPort!
                }
                if self.readinessProbeHttpGetScheme != nil {
                    map["ReadinessProbeHttpGetScheme"] = self.readinessProbeHttpGetScheme!
                }
                if self.readinessProbeInitialDelaySeconds != nil {
                    map["ReadinessProbeInitialDelaySeconds"] = self.readinessProbeInitialDelaySeconds!
                }
                if self.readinessProbePeriodSeconds != nil {
                    map["ReadinessProbePeriodSeconds"] = self.readinessProbePeriodSeconds!
                }
                if self.readinessProbeSuccessThreshold != nil {
                    map["ReadinessProbeSuccessThreshold"] = self.readinessProbeSuccessThreshold!
                }
                if self.readinessProbeTcpSocketPort != nil {
                    map["ReadinessProbeTcpSocketPort"] = self.readinessProbeTcpSocketPort!
                }
                if self.readinessProbeTimeoutSeconds != nil {
                    map["ReadinessProbeTimeoutSeconds"] = self.readinessProbeTimeoutSeconds!
                }
                if self.securityContextCapabilityAdds != nil {
                    map["SecurityContextCapabilityAdds"] = self.securityContextCapabilityAdds!
                }
                if self.securityContextReadOnlyRootFilesystem != nil {
                    map["SecurityContextReadOnlyRootFilesystem"] = self.securityContextReadOnlyRootFilesystem!
                }
                if self.securityContextRunAsUser != nil {
                    map["SecurityContextRunAsUser"] = self.securityContextRunAsUser!
                }
                if self.stdin != nil {
                    map["Stdin"] = self.stdin!
                }
                if self.stdinOnce != nil {
                    map["StdinOnce"] = self.stdinOnce!
                }
                if self.tty != nil {
                    map["Tty"] = self.tty!
                }
                if self.volumeMounts != nil {
                    var tmp : [Any] = []
                    for k in self.volumeMounts! {
                        tmp.append(k.toMap())
                    }
                    map["VolumeMounts"] = tmp
                }
                if self.workingDir != nil {
                    map["WorkingDir"] = self.workingDir!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Args") {
                    self.args = dict["Args"] as! [String]
                }
                if dict.keys.contains("Commands") {
                    self.commands = dict["Commands"] as! [String]
                }
                if dict.keys.contains("Cpu") {
                    self.cpu = dict["Cpu"] as! Double
                }
                if dict.keys.contains("EnvironmentVars") {
                    var tmp : [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.Containers.EnvironmentVars] = []
                    for v in dict["EnvironmentVars"] as! [Any] {
                        var model = DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.Containers.EnvironmentVars()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.environmentVars = tmp
                }
                if dict.keys.contains("Gpu") {
                    self.gpu = dict["Gpu"] as! Int32
                }
                if dict.keys.contains("Image") {
                    self.image = dict["Image"] as! String
                }
                if dict.keys.contains("ImagePullPolicy") {
                    self.imagePullPolicy = dict["ImagePullPolicy"] as! String
                }
                if dict.keys.contains("LifecyclePostStartHandlerExecs") {
                    self.lifecyclePostStartHandlerExecs = dict["LifecyclePostStartHandlerExecs"] as! [String]
                }
                if dict.keys.contains("LifecyclePostStartHandlerHttpGetHost") {
                    self.lifecyclePostStartHandlerHttpGetHost = dict["LifecyclePostStartHandlerHttpGetHost"] as! String
                }
                if dict.keys.contains("LifecyclePostStartHandlerHttpGetPath") {
                    self.lifecyclePostStartHandlerHttpGetPath = dict["LifecyclePostStartHandlerHttpGetPath"] as! String
                }
                if dict.keys.contains("LifecyclePostStartHandlerHttpGetPort") {
                    self.lifecyclePostStartHandlerHttpGetPort = dict["LifecyclePostStartHandlerHttpGetPort"] as! Int32
                }
                if dict.keys.contains("LifecyclePostStartHandlerHttpGetScheme") {
                    self.lifecyclePostStartHandlerHttpGetScheme = dict["LifecyclePostStartHandlerHttpGetScheme"] as! String
                }
                if dict.keys.contains("LifecyclePostStartHandlerTcpSocketHost") {
                    self.lifecyclePostStartHandlerTcpSocketHost = dict["LifecyclePostStartHandlerTcpSocketHost"] as! String
                }
                if dict.keys.contains("LifecyclePostStartHandlerTcpSocketPort") {
                    self.lifecyclePostStartHandlerTcpSocketPort = dict["LifecyclePostStartHandlerTcpSocketPort"] as! Int32
                }
                if dict.keys.contains("LifecyclePreStopHandlerExecs") {
                    self.lifecyclePreStopHandlerExecs = dict["LifecyclePreStopHandlerExecs"] as! [String]
                }
                if dict.keys.contains("LifecyclePreStopHandlerHttpGetHost") {
                    self.lifecyclePreStopHandlerHttpGetHost = dict["LifecyclePreStopHandlerHttpGetHost"] as! String
                }
                if dict.keys.contains("LifecyclePreStopHandlerHttpGetPath") {
                    self.lifecyclePreStopHandlerHttpGetPath = dict["LifecyclePreStopHandlerHttpGetPath"] as! String
                }
                if dict.keys.contains("LifecyclePreStopHandlerHttpGetPort") {
                    self.lifecyclePreStopHandlerHttpGetPort = dict["LifecyclePreStopHandlerHttpGetPort"] as! Int32
                }
                if dict.keys.contains("LifecyclePreStopHandlerHttpGetScheme") {
                    self.lifecyclePreStopHandlerHttpGetScheme = dict["LifecyclePreStopHandlerHttpGetScheme"] as! String
                }
                if dict.keys.contains("LifecyclePreStopHandlerTcpSocketHost") {
                    self.lifecyclePreStopHandlerTcpSocketHost = dict["LifecyclePreStopHandlerTcpSocketHost"] as! String
                }
                if dict.keys.contains("LifecyclePreStopHandlerTcpSocketPort") {
                    self.lifecyclePreStopHandlerTcpSocketPort = dict["LifecyclePreStopHandlerTcpSocketPort"] as! Int32
                }
                if dict.keys.contains("LivenessProbeExecCommands") {
                    self.livenessProbeExecCommands = dict["LivenessProbeExecCommands"] as! [String]
                }
                if dict.keys.contains("LivenessProbeFailureThreshold") {
                    self.livenessProbeFailureThreshold = dict["LivenessProbeFailureThreshold"] as! Int32
                }
                if dict.keys.contains("LivenessProbeHttpGetPath") {
                    self.livenessProbeHttpGetPath = dict["LivenessProbeHttpGetPath"] as! String
                }
                if dict.keys.contains("LivenessProbeHttpGetPort") {
                    self.livenessProbeHttpGetPort = dict["LivenessProbeHttpGetPort"] as! Int32
                }
                if dict.keys.contains("LivenessProbeHttpGetScheme") {
                    self.livenessProbeHttpGetScheme = dict["LivenessProbeHttpGetScheme"] as! String
                }
                if dict.keys.contains("LivenessProbeInitialDelaySeconds") {
                    self.livenessProbeInitialDelaySeconds = dict["LivenessProbeInitialDelaySeconds"] as! Int32
                }
                if dict.keys.contains("LivenessProbePeriodSeconds") {
                    self.livenessProbePeriodSeconds = dict["LivenessProbePeriodSeconds"] as! Int32
                }
                if dict.keys.contains("LivenessProbeSuccessThreshold") {
                    self.livenessProbeSuccessThreshold = dict["LivenessProbeSuccessThreshold"] as! Int32
                }
                if dict.keys.contains("LivenessProbeTcpSocketPort") {
                    self.livenessProbeTcpSocketPort = dict["LivenessProbeTcpSocketPort"] as! Int32
                }
                if dict.keys.contains("LivenessProbeTimeoutSeconds") {
                    self.livenessProbeTimeoutSeconds = dict["LivenessProbeTimeoutSeconds"] as! Int32
                }
                if dict.keys.contains("Memory") {
                    self.memory = dict["Memory"] as! Double
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Ports") {
                    var tmp : [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.Containers.Ports] = []
                    for v in dict["Ports"] as! [Any] {
                        var model = DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.Containers.Ports()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.ports = tmp
                }
                if dict.keys.contains("ReadinessProbeExecCommands") {
                    self.readinessProbeExecCommands = dict["ReadinessProbeExecCommands"] as! [String]
                }
                if dict.keys.contains("ReadinessProbeFailureThreshold") {
                    self.readinessProbeFailureThreshold = dict["ReadinessProbeFailureThreshold"] as! Int32
                }
                if dict.keys.contains("ReadinessProbeHttpGetPath") {
                    self.readinessProbeHttpGetPath = dict["ReadinessProbeHttpGetPath"] as! String
                }
                if dict.keys.contains("ReadinessProbeHttpGetPort") {
                    self.readinessProbeHttpGetPort = dict["ReadinessProbeHttpGetPort"] as! Int32
                }
                if dict.keys.contains("ReadinessProbeHttpGetScheme") {
                    self.readinessProbeHttpGetScheme = dict["ReadinessProbeHttpGetScheme"] as! String
                }
                if dict.keys.contains("ReadinessProbeInitialDelaySeconds") {
                    self.readinessProbeInitialDelaySeconds = dict["ReadinessProbeInitialDelaySeconds"] as! Int32
                }
                if dict.keys.contains("ReadinessProbePeriodSeconds") {
                    self.readinessProbePeriodSeconds = dict["ReadinessProbePeriodSeconds"] as! Int32
                }
                if dict.keys.contains("ReadinessProbeSuccessThreshold") {
                    self.readinessProbeSuccessThreshold = dict["ReadinessProbeSuccessThreshold"] as! Int32
                }
                if dict.keys.contains("ReadinessProbeTcpSocketPort") {
                    self.readinessProbeTcpSocketPort = dict["ReadinessProbeTcpSocketPort"] as! Int32
                }
                if dict.keys.contains("ReadinessProbeTimeoutSeconds") {
                    self.readinessProbeTimeoutSeconds = dict["ReadinessProbeTimeoutSeconds"] as! Int32
                }
                if dict.keys.contains("SecurityContextCapabilityAdds") {
                    self.securityContextCapabilityAdds = dict["SecurityContextCapabilityAdds"] as! [String]
                }
                if dict.keys.contains("SecurityContextReadOnlyRootFilesystem") {
                    self.securityContextReadOnlyRootFilesystem = dict["SecurityContextReadOnlyRootFilesystem"] as! Bool
                }
                if dict.keys.contains("SecurityContextRunAsUser") {
                    self.securityContextRunAsUser = dict["SecurityContextRunAsUser"] as! Int64
                }
                if dict.keys.contains("Stdin") {
                    self.stdin = dict["Stdin"] as! Bool
                }
                if dict.keys.contains("StdinOnce") {
                    self.stdinOnce = dict["StdinOnce"] as! Bool
                }
                if dict.keys.contains("Tty") {
                    self.tty = dict["Tty"] as! Bool
                }
                if dict.keys.contains("VolumeMounts") {
                    var tmp : [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.Containers.VolumeMounts] = []
                    for v in dict["VolumeMounts"] as! [Any] {
                        var model = DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.Containers.VolumeMounts()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.volumeMounts = tmp
                }
                if dict.keys.contains("WorkingDir") {
                    self.workingDir = dict["WorkingDir"] as! String
                }
            }
        }
        public class DnsConfigOptions : Tea.TeaModel {
            public var name: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public class HostAliases : Tea.TeaModel {
            public var hostnames: [String]?

            public var ip: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.hostnames != nil {
                    map["Hostnames"] = self.hostnames!
                }
                if self.ip != nil {
                    map["Ip"] = self.ip!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Hostnames") {
                    self.hostnames = dict["Hostnames"] as! [String]
                }
                if dict.keys.contains("Ip") {
                    self.ip = dict["Ip"] as! String
                }
            }
        }
        public class ImageRegistryCredentials : Tea.TeaModel {
            public var password: String?

            public var server: String?

            public var userName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.password != nil {
                    map["Password"] = self.password!
                }
                if self.server != nil {
                    map["Server"] = self.server!
                }
                if self.userName != nil {
                    map["UserName"] = self.userName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Password") {
                    self.password = dict["Password"] as! String
                }
                if dict.keys.contains("Server") {
                    self.server = dict["Server"] as! String
                }
                if dict.keys.contains("UserName") {
                    self.userName = dict["UserName"] as! String
                }
            }
        }
        public class InitContainers : Tea.TeaModel {
            public class InitContainerEnvironmentVars : Tea.TeaModel {
                public var fieldRefFieldPath: String?

                public var key: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.fieldRefFieldPath != nil {
                        map["FieldRefFieldPath"] = self.fieldRefFieldPath!
                    }
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("FieldRefFieldPath") {
                        self.fieldRefFieldPath = dict["FieldRefFieldPath"] as! String
                    }
                    if dict.keys.contains("Key") {
                        self.key = dict["Key"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class InitContainerPorts : Tea.TeaModel {
                public var port: Int32?

                public var protocol_: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.port != nil {
                        map["Port"] = self.port!
                    }
                    if self.protocol_ != nil {
                        map["Protocol"] = self.protocol_!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Port") {
                        self.port = dict["Port"] as! Int32
                    }
                    if dict.keys.contains("Protocol") {
                        self.protocol_ = dict["Protocol"] as! String
                    }
                }
            }
            public class InitContainerVolumeMounts : Tea.TeaModel {
                public var mountPath: String?

                public var mountPropagation: String?

                public var name: String?

                public var readOnly: Bool?

                public var subPath: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.mountPath != nil {
                        map["MountPath"] = self.mountPath!
                    }
                    if self.mountPropagation != nil {
                        map["MountPropagation"] = self.mountPropagation!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.readOnly != nil {
                        map["ReadOnly"] = self.readOnly!
                    }
                    if self.subPath != nil {
                        map["SubPath"] = self.subPath!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("MountPath") {
                        self.mountPath = dict["MountPath"] as! String
                    }
                    if dict.keys.contains("MountPropagation") {
                        self.mountPropagation = dict["MountPropagation"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("ReadOnly") {
                        self.readOnly = dict["ReadOnly"] as! Bool
                    }
                    if dict.keys.contains("SubPath") {
                        self.subPath = dict["SubPath"] as! String
                    }
                }
            }
            public var cpu: Double?

            public var gpu: Int32?

            public var image: String?

            public var imagePullPolicy: String?

            public var initContainerArgs: [String]?

            public var initContainerCommands: [String]?

            public var initContainerEnvironmentVars: [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.InitContainers.InitContainerEnvironmentVars]?

            public var initContainerPorts: [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.InitContainers.InitContainerPorts]?

            public var initContainerVolumeMounts: [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.InitContainers.InitContainerVolumeMounts]?

            public var memory: Double?

            public var name: String?

            public var securityContextCapabilityAdds: [String]?

            public var securityContextReadOnlyRootFilesystem: Bool?

            public var securityContextRunAsUser: String?

            public var workingDir: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cpu != nil {
                    map["Cpu"] = self.cpu!
                }
                if self.gpu != nil {
                    map["Gpu"] = self.gpu!
                }
                if self.image != nil {
                    map["Image"] = self.image!
                }
                if self.imagePullPolicy != nil {
                    map["ImagePullPolicy"] = self.imagePullPolicy!
                }
                if self.initContainerArgs != nil {
                    map["InitContainerArgs"] = self.initContainerArgs!
                }
                if self.initContainerCommands != nil {
                    map["InitContainerCommands"] = self.initContainerCommands!
                }
                if self.initContainerEnvironmentVars != nil {
                    var tmp : [Any] = []
                    for k in self.initContainerEnvironmentVars! {
                        tmp.append(k.toMap())
                    }
                    map["InitContainerEnvironmentVars"] = tmp
                }
                if self.initContainerPorts != nil {
                    var tmp : [Any] = []
                    for k in self.initContainerPorts! {
                        tmp.append(k.toMap())
                    }
                    map["InitContainerPorts"] = tmp
                }
                if self.initContainerVolumeMounts != nil {
                    var tmp : [Any] = []
                    for k in self.initContainerVolumeMounts! {
                        tmp.append(k.toMap())
                    }
                    map["InitContainerVolumeMounts"] = tmp
                }
                if self.memory != nil {
                    map["Memory"] = self.memory!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.securityContextCapabilityAdds != nil {
                    map["SecurityContextCapabilityAdds"] = self.securityContextCapabilityAdds!
                }
                if self.securityContextReadOnlyRootFilesystem != nil {
                    map["SecurityContextReadOnlyRootFilesystem"] = self.securityContextReadOnlyRootFilesystem!
                }
                if self.securityContextRunAsUser != nil {
                    map["SecurityContextRunAsUser"] = self.securityContextRunAsUser!
                }
                if self.workingDir != nil {
                    map["WorkingDir"] = self.workingDir!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Cpu") {
                    self.cpu = dict["Cpu"] as! Double
                }
                if dict.keys.contains("Gpu") {
                    self.gpu = dict["Gpu"] as! Int32
                }
                if dict.keys.contains("Image") {
                    self.image = dict["Image"] as! String
                }
                if dict.keys.contains("ImagePullPolicy") {
                    self.imagePullPolicy = dict["ImagePullPolicy"] as! String
                }
                if dict.keys.contains("InitContainerArgs") {
                    self.initContainerArgs = dict["InitContainerArgs"] as! [String]
                }
                if dict.keys.contains("InitContainerCommands") {
                    self.initContainerCommands = dict["InitContainerCommands"] as! [String]
                }
                if dict.keys.contains("InitContainerEnvironmentVars") {
                    var tmp : [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.InitContainers.InitContainerEnvironmentVars] = []
                    for v in dict["InitContainerEnvironmentVars"] as! [Any] {
                        var model = DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.InitContainers.InitContainerEnvironmentVars()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.initContainerEnvironmentVars = tmp
                }
                if dict.keys.contains("InitContainerPorts") {
                    var tmp : [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.InitContainers.InitContainerPorts] = []
                    for v in dict["InitContainerPorts"] as! [Any] {
                        var model = DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.InitContainers.InitContainerPorts()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.initContainerPorts = tmp
                }
                if dict.keys.contains("InitContainerVolumeMounts") {
                    var tmp : [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.InitContainers.InitContainerVolumeMounts] = []
                    for v in dict["InitContainerVolumeMounts"] as! [Any] {
                        var model = DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.InitContainers.InitContainerVolumeMounts()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.initContainerVolumeMounts = tmp
                }
                if dict.keys.contains("Memory") {
                    self.memory = dict["Memory"] as! Double
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("SecurityContextCapabilityAdds") {
                    self.securityContextCapabilityAdds = dict["SecurityContextCapabilityAdds"] as! [String]
                }
                if dict.keys.contains("SecurityContextReadOnlyRootFilesystem") {
                    self.securityContextReadOnlyRootFilesystem = dict["SecurityContextReadOnlyRootFilesystem"] as! Bool
                }
                if dict.keys.contains("SecurityContextRunAsUser") {
                    self.securityContextRunAsUser = dict["SecurityContextRunAsUser"] as! String
                }
                if dict.keys.contains("WorkingDir") {
                    self.workingDir = dict["WorkingDir"] as! String
                }
            }
        }
        public class SecurityContextSysCtls : Tea.TeaModel {
            public var name: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public class Tags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public class Volumes : Tea.TeaModel {
            public class ConfigFileVolumeConfigFileToPaths : Tea.TeaModel {
                public var content: String?

                public var mode: Int32?

                public var path: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.content != nil {
                        map["Content"] = self.content!
                    }
                    if self.mode != nil {
                        map["Mode"] = self.mode!
                    }
                    if self.path != nil {
                        map["Path"] = self.path!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Content") {
                        self.content = dict["Content"] as! String
                    }
                    if dict.keys.contains("Mode") {
                        self.mode = dict["Mode"] as! Int32
                    }
                    if dict.keys.contains("Path") {
                        self.path = dict["Path"] as! String
                    }
                }
            }
            public var configFileVolumeConfigFileToPaths: [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.Volumes.ConfigFileVolumeConfigFileToPaths]?

            public var configFileVolumeDefaultMode: Int32?

            public var diskVolumeDiskId: String?

            public var diskVolumeDiskSize: Int32?

            public var diskVolumeFsType: String?

            public var emptyDirVolumeMedium: String?

            public var emptyDirVolumeSizeLimit: String?

            public var flexVolumeDriver: String?

            public var flexVolumeFsType: String?

            public var flexVolumeOptions: String?

            public var hostPathVolumePath: String?

            public var hostPathVolumeType: String?

            public var NFSVolumePath: String?

            public var NFSVolumeReadOnly: Bool?

            public var NFSVolumeServer: String?

            public var name: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.configFileVolumeConfigFileToPaths != nil {
                    var tmp : [Any] = []
                    for k in self.configFileVolumeConfigFileToPaths! {
                        tmp.append(k.toMap())
                    }
                    map["ConfigFileVolumeConfigFileToPaths"] = tmp
                }
                if self.configFileVolumeDefaultMode != nil {
                    map["ConfigFileVolumeDefaultMode"] = self.configFileVolumeDefaultMode!
                }
                if self.diskVolumeDiskId != nil {
                    map["DiskVolumeDiskId"] = self.diskVolumeDiskId!
                }
                if self.diskVolumeDiskSize != nil {
                    map["DiskVolumeDiskSize"] = self.diskVolumeDiskSize!
                }
                if self.diskVolumeFsType != nil {
                    map["DiskVolumeFsType"] = self.diskVolumeFsType!
                }
                if self.emptyDirVolumeMedium != nil {
                    map["EmptyDirVolumeMedium"] = self.emptyDirVolumeMedium!
                }
                if self.emptyDirVolumeSizeLimit != nil {
                    map["EmptyDirVolumeSizeLimit"] = self.emptyDirVolumeSizeLimit!
                }
                if self.flexVolumeDriver != nil {
                    map["FlexVolumeDriver"] = self.flexVolumeDriver!
                }
                if self.flexVolumeFsType != nil {
                    map["FlexVolumeFsType"] = self.flexVolumeFsType!
                }
                if self.flexVolumeOptions != nil {
                    map["FlexVolumeOptions"] = self.flexVolumeOptions!
                }
                if self.hostPathVolumePath != nil {
                    map["HostPathVolumePath"] = self.hostPathVolumePath!
                }
                if self.hostPathVolumeType != nil {
                    map["HostPathVolumeType"] = self.hostPathVolumeType!
                }
                if self.NFSVolumePath != nil {
                    map["NFSVolumePath"] = self.NFSVolumePath!
                }
                if self.NFSVolumeReadOnly != nil {
                    map["NFSVolumeReadOnly"] = self.NFSVolumeReadOnly!
                }
                if self.NFSVolumeServer != nil {
                    map["NFSVolumeServer"] = self.NFSVolumeServer!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ConfigFileVolumeConfigFileToPaths") {
                    var tmp : [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.Volumes.ConfigFileVolumeConfigFileToPaths] = []
                    for v in dict["ConfigFileVolumeConfigFileToPaths"] as! [Any] {
                        var model = DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.Volumes.ConfigFileVolumeConfigFileToPaths()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.configFileVolumeConfigFileToPaths = tmp
                }
                if dict.keys.contains("ConfigFileVolumeDefaultMode") {
                    self.configFileVolumeDefaultMode = dict["ConfigFileVolumeDefaultMode"] as! Int32
                }
                if dict.keys.contains("DiskVolumeDiskId") {
                    self.diskVolumeDiskId = dict["DiskVolumeDiskId"] as! String
                }
                if dict.keys.contains("DiskVolumeDiskSize") {
                    self.diskVolumeDiskSize = dict["DiskVolumeDiskSize"] as! Int32
                }
                if dict.keys.contains("DiskVolumeFsType") {
                    self.diskVolumeFsType = dict["DiskVolumeFsType"] as! String
                }
                if dict.keys.contains("EmptyDirVolumeMedium") {
                    self.emptyDirVolumeMedium = dict["EmptyDirVolumeMedium"] as! String
                }
                if dict.keys.contains("EmptyDirVolumeSizeLimit") {
                    self.emptyDirVolumeSizeLimit = dict["EmptyDirVolumeSizeLimit"] as! String
                }
                if dict.keys.contains("FlexVolumeDriver") {
                    self.flexVolumeDriver = dict["FlexVolumeDriver"] as! String
                }
                if dict.keys.contains("FlexVolumeFsType") {
                    self.flexVolumeFsType = dict["FlexVolumeFsType"] as! String
                }
                if dict.keys.contains("FlexVolumeOptions") {
                    self.flexVolumeOptions = dict["FlexVolumeOptions"] as! String
                }
                if dict.keys.contains("HostPathVolumePath") {
                    self.hostPathVolumePath = dict["HostPathVolumePath"] as! String
                }
                if dict.keys.contains("HostPathVolumeType") {
                    self.hostPathVolumeType = dict["HostPathVolumeType"] as! String
                }
                if dict.keys.contains("NFSVolumePath") {
                    self.NFSVolumePath = dict["NFSVolumePath"] as! String
                }
                if dict.keys.contains("NFSVolumeReadOnly") {
                    self.NFSVolumeReadOnly = dict["NFSVolumeReadOnly"] as! Bool
                }
                if dict.keys.contains("NFSVolumeServer") {
                    self.NFSVolumeServer = dict["NFSVolumeServer"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var acrRegistryInfos: [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.AcrRegistryInfos]?

        public var activeDeadlineSeconds: Int32?

        public var autoCreateEip: Bool?

        public var autoMatchImageCache: Bool?

        public var containerGroupName: String?

        public var containers: [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.Containers]?

        public var costOptimization: Bool?

        public var cpu: Double?

        public var cpuOptionsCore: Int32?

        public var cpuOptionsThreadsPerCore: Int32?

        public var creationTime: String?

        public var dataCacheBucket: String?

        public var dataCacheBurstingEnabled: Bool?

        public var dataCachePL: String?

        public var dataCacheProvisionedIops: Int32?

        public var description_: String?

        public var dnsConfigNameServers: [String]?

        public var dnsConfigOptions: [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.DnsConfigOptions]?

        public var dnsConfigSearches: [String]?

        public var dnsPolicy: String?

        public var egressBandwidth: Int64?

        public var eipBandwidth: Int32?

        public var ephemeralStorage: Int32?

        public var gpuDriverVersion: String?

        public var hostAliases: [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.HostAliases]?

        public var hostName: String?

        public var imageRegistryCredentials: [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.ImageRegistryCredentials]?

        public var imageSnapshotId: String?

        public var ingressBandwidth: Int64?

        public var initContainers: [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.InitContainers]?

        public var instanceFamilyLevel: String?

        public var instanceTypes: [String]?

        public var ipv6AddressCount: Int32?

        public var lifecycleState: String?

        public var loadBalancerWeight: Int32?

        public var memory: Double?

        public var ntpServers: [String]?

        public var ramRoleName: String?

        public var regionId: String?

        public var resourceGroupId: String?

        public var restartPolicy: String?

        public var scalingConfigurationId: String?

        public var scalingConfigurationName: String?

        public var scalingGroupId: String?

        public var securityContextSysCtls: [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.SecurityContextSysCtls]?

        public var securityGroupId: String?

        public var slsEnable: Bool?

        public var spotPriceLimit: Double?

        public var spotStrategy: String?

        public var tags: [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.Tags]?

        public var terminationGracePeriodSeconds: Int32?

        public var volumes: [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.Volumes]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.acrRegistryInfos != nil {
                var tmp : [Any] = []
                for k in self.acrRegistryInfos! {
                    tmp.append(k.toMap())
                }
                map["AcrRegistryInfos"] = tmp
            }
            if self.activeDeadlineSeconds != nil {
                map["ActiveDeadlineSeconds"] = self.activeDeadlineSeconds!
            }
            if self.autoCreateEip != nil {
                map["AutoCreateEip"] = self.autoCreateEip!
            }
            if self.autoMatchImageCache != nil {
                map["AutoMatchImageCache"] = self.autoMatchImageCache!
            }
            if self.containerGroupName != nil {
                map["ContainerGroupName"] = self.containerGroupName!
            }
            if self.containers != nil {
                var tmp : [Any] = []
                for k in self.containers! {
                    tmp.append(k.toMap())
                }
                map["Containers"] = tmp
            }
            if self.costOptimization != nil {
                map["CostOptimization"] = self.costOptimization!
            }
            if self.cpu != nil {
                map["Cpu"] = self.cpu!
            }
            if self.cpuOptionsCore != nil {
                map["CpuOptionsCore"] = self.cpuOptionsCore!
            }
            if self.cpuOptionsThreadsPerCore != nil {
                map["CpuOptionsThreadsPerCore"] = self.cpuOptionsThreadsPerCore!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.dataCacheBucket != nil {
                map["DataCacheBucket"] = self.dataCacheBucket!
            }
            if self.dataCacheBurstingEnabled != nil {
                map["DataCacheBurstingEnabled"] = self.dataCacheBurstingEnabled!
            }
            if self.dataCachePL != nil {
                map["DataCachePL"] = self.dataCachePL!
            }
            if self.dataCacheProvisionedIops != nil {
                map["DataCacheProvisionedIops"] = self.dataCacheProvisionedIops!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.dnsConfigNameServers != nil {
                map["DnsConfigNameServers"] = self.dnsConfigNameServers!
            }
            if self.dnsConfigOptions != nil {
                var tmp : [Any] = []
                for k in self.dnsConfigOptions! {
                    tmp.append(k.toMap())
                }
                map["DnsConfigOptions"] = tmp
            }
            if self.dnsConfigSearches != nil {
                map["DnsConfigSearches"] = self.dnsConfigSearches!
            }
            if self.dnsPolicy != nil {
                map["DnsPolicy"] = self.dnsPolicy!
            }
            if self.egressBandwidth != nil {
                map["EgressBandwidth"] = self.egressBandwidth!
            }
            if self.eipBandwidth != nil {
                map["EipBandwidth"] = self.eipBandwidth!
            }
            if self.ephemeralStorage != nil {
                map["EphemeralStorage"] = self.ephemeralStorage!
            }
            if self.gpuDriverVersion != nil {
                map["GpuDriverVersion"] = self.gpuDriverVersion!
            }
            if self.hostAliases != nil {
                var tmp : [Any] = []
                for k in self.hostAliases! {
                    tmp.append(k.toMap())
                }
                map["HostAliases"] = tmp
            }
            if self.hostName != nil {
                map["HostName"] = self.hostName!
            }
            if self.imageRegistryCredentials != nil {
                var tmp : [Any] = []
                for k in self.imageRegistryCredentials! {
                    tmp.append(k.toMap())
                }
                map["ImageRegistryCredentials"] = tmp
            }
            if self.imageSnapshotId != nil {
                map["ImageSnapshotId"] = self.imageSnapshotId!
            }
            if self.ingressBandwidth != nil {
                map["IngressBandwidth"] = self.ingressBandwidth!
            }
            if self.initContainers != nil {
                var tmp : [Any] = []
                for k in self.initContainers! {
                    tmp.append(k.toMap())
                }
                map["InitContainers"] = tmp
            }
            if self.instanceFamilyLevel != nil {
                map["InstanceFamilyLevel"] = self.instanceFamilyLevel!
            }
            if self.instanceTypes != nil {
                map["InstanceTypes"] = self.instanceTypes!
            }
            if self.ipv6AddressCount != nil {
                map["Ipv6AddressCount"] = self.ipv6AddressCount!
            }
            if self.lifecycleState != nil {
                map["LifecycleState"] = self.lifecycleState!
            }
            if self.loadBalancerWeight != nil {
                map["LoadBalancerWeight"] = self.loadBalancerWeight!
            }
            if self.memory != nil {
                map["Memory"] = self.memory!
            }
            if self.ntpServers != nil {
                map["NtpServers"] = self.ntpServers!
            }
            if self.ramRoleName != nil {
                map["RamRoleName"] = self.ramRoleName!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.restartPolicy != nil {
                map["RestartPolicy"] = self.restartPolicy!
            }
            if self.scalingConfigurationId != nil {
                map["ScalingConfigurationId"] = self.scalingConfigurationId!
            }
            if self.scalingConfigurationName != nil {
                map["ScalingConfigurationName"] = self.scalingConfigurationName!
            }
            if self.scalingGroupId != nil {
                map["ScalingGroupId"] = self.scalingGroupId!
            }
            if self.securityContextSysCtls != nil {
                var tmp : [Any] = []
                for k in self.securityContextSysCtls! {
                    tmp.append(k.toMap())
                }
                map["SecurityContextSysCtls"] = tmp
            }
            if self.securityGroupId != nil {
                map["SecurityGroupId"] = self.securityGroupId!
            }
            if self.slsEnable != nil {
                map["SlsEnable"] = self.slsEnable!
            }
            if self.spotPriceLimit != nil {
                map["SpotPriceLimit"] = self.spotPriceLimit!
            }
            if self.spotStrategy != nil {
                map["SpotStrategy"] = self.spotStrategy!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            if self.terminationGracePeriodSeconds != nil {
                map["TerminationGracePeriodSeconds"] = self.terminationGracePeriodSeconds!
            }
            if self.volumes != nil {
                var tmp : [Any] = []
                for k in self.volumes! {
                    tmp.append(k.toMap())
                }
                map["Volumes"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AcrRegistryInfos") {
                var tmp : [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.AcrRegistryInfos] = []
                for v in dict["AcrRegistryInfos"] as! [Any] {
                    var model = DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.AcrRegistryInfos()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.acrRegistryInfos = tmp
            }
            if dict.keys.contains("ActiveDeadlineSeconds") {
                self.activeDeadlineSeconds = dict["ActiveDeadlineSeconds"] as! Int32
            }
            if dict.keys.contains("AutoCreateEip") {
                self.autoCreateEip = dict["AutoCreateEip"] as! Bool
            }
            if dict.keys.contains("AutoMatchImageCache") {
                self.autoMatchImageCache = dict["AutoMatchImageCache"] as! Bool
            }
            if dict.keys.contains("ContainerGroupName") {
                self.containerGroupName = dict["ContainerGroupName"] as! String
            }
            if dict.keys.contains("Containers") {
                var tmp : [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.Containers] = []
                for v in dict["Containers"] as! [Any] {
                    var model = DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.Containers()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.containers = tmp
            }
            if dict.keys.contains("CostOptimization") {
                self.costOptimization = dict["CostOptimization"] as! Bool
            }
            if dict.keys.contains("Cpu") {
                self.cpu = dict["Cpu"] as! Double
            }
            if dict.keys.contains("CpuOptionsCore") {
                self.cpuOptionsCore = dict["CpuOptionsCore"] as! Int32
            }
            if dict.keys.contains("CpuOptionsThreadsPerCore") {
                self.cpuOptionsThreadsPerCore = dict["CpuOptionsThreadsPerCore"] as! Int32
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("DataCacheBucket") {
                self.dataCacheBucket = dict["DataCacheBucket"] as! String
            }
            if dict.keys.contains("DataCacheBurstingEnabled") {
                self.dataCacheBurstingEnabled = dict["DataCacheBurstingEnabled"] as! Bool
            }
            if dict.keys.contains("DataCachePL") {
                self.dataCachePL = dict["DataCachePL"] as! String
            }
            if dict.keys.contains("DataCacheProvisionedIops") {
                self.dataCacheProvisionedIops = dict["DataCacheProvisionedIops"] as! Int32
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("DnsConfigNameServers") {
                self.dnsConfigNameServers = dict["DnsConfigNameServers"] as! [String]
            }
            if dict.keys.contains("DnsConfigOptions") {
                var tmp : [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.DnsConfigOptions] = []
                for v in dict["DnsConfigOptions"] as! [Any] {
                    var model = DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.DnsConfigOptions()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.dnsConfigOptions = tmp
            }
            if dict.keys.contains("DnsConfigSearches") {
                self.dnsConfigSearches = dict["DnsConfigSearches"] as! [String]
            }
            if dict.keys.contains("DnsPolicy") {
                self.dnsPolicy = dict["DnsPolicy"] as! String
            }
            if dict.keys.contains("EgressBandwidth") {
                self.egressBandwidth = dict["EgressBandwidth"] as! Int64
            }
            if dict.keys.contains("EipBandwidth") {
                self.eipBandwidth = dict["EipBandwidth"] as! Int32
            }
            if dict.keys.contains("EphemeralStorage") {
                self.ephemeralStorage = dict["EphemeralStorage"] as! Int32
            }
            if dict.keys.contains("GpuDriverVersion") {
                self.gpuDriverVersion = dict["GpuDriverVersion"] as! String
            }
            if dict.keys.contains("HostAliases") {
                var tmp : [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.HostAliases] = []
                for v in dict["HostAliases"] as! [Any] {
                    var model = DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.HostAliases()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.hostAliases = tmp
            }
            if dict.keys.contains("HostName") {
                self.hostName = dict["HostName"] as! String
            }
            if dict.keys.contains("ImageRegistryCredentials") {
                var tmp : [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.ImageRegistryCredentials] = []
                for v in dict["ImageRegistryCredentials"] as! [Any] {
                    var model = DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.ImageRegistryCredentials()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.imageRegistryCredentials = tmp
            }
            if dict.keys.contains("ImageSnapshotId") {
                self.imageSnapshotId = dict["ImageSnapshotId"] as! String
            }
            if dict.keys.contains("IngressBandwidth") {
                self.ingressBandwidth = dict["IngressBandwidth"] as! Int64
            }
            if dict.keys.contains("InitContainers") {
                var tmp : [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.InitContainers] = []
                for v in dict["InitContainers"] as! [Any] {
                    var model = DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.InitContainers()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.initContainers = tmp
            }
            if dict.keys.contains("InstanceFamilyLevel") {
                self.instanceFamilyLevel = dict["InstanceFamilyLevel"] as! String
            }
            if dict.keys.contains("InstanceTypes") {
                self.instanceTypes = dict["InstanceTypes"] as! [String]
            }
            if dict.keys.contains("Ipv6AddressCount") {
                self.ipv6AddressCount = dict["Ipv6AddressCount"] as! Int32
            }
            if dict.keys.contains("LifecycleState") {
                self.lifecycleState = dict["LifecycleState"] as! String
            }
            if dict.keys.contains("LoadBalancerWeight") {
                self.loadBalancerWeight = dict["LoadBalancerWeight"] as! Int32
            }
            if dict.keys.contains("Memory") {
                self.memory = dict["Memory"] as! Double
            }
            if dict.keys.contains("NtpServers") {
                self.ntpServers = dict["NtpServers"] as! [String]
            }
            if dict.keys.contains("RamRoleName") {
                self.ramRoleName = dict["RamRoleName"] as! String
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("ResourceGroupId") {
                self.resourceGroupId = dict["ResourceGroupId"] as! String
            }
            if dict.keys.contains("RestartPolicy") {
                self.restartPolicy = dict["RestartPolicy"] as! String
            }
            if dict.keys.contains("ScalingConfigurationId") {
                self.scalingConfigurationId = dict["ScalingConfigurationId"] as! String
            }
            if dict.keys.contains("ScalingConfigurationName") {
                self.scalingConfigurationName = dict["ScalingConfigurationName"] as! String
            }
            if dict.keys.contains("ScalingGroupId") {
                self.scalingGroupId = dict["ScalingGroupId"] as! String
            }
            if dict.keys.contains("SecurityContextSysCtls") {
                var tmp : [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.SecurityContextSysCtls] = []
                for v in dict["SecurityContextSysCtls"] as! [Any] {
                    var model = DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.SecurityContextSysCtls()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.securityContextSysCtls = tmp
            }
            if dict.keys.contains("SecurityGroupId") {
                self.securityGroupId = dict["SecurityGroupId"] as! String
            }
            if dict.keys.contains("SlsEnable") {
                self.slsEnable = dict["SlsEnable"] as! Bool
            }
            if dict.keys.contains("SpotPriceLimit") {
                self.spotPriceLimit = dict["SpotPriceLimit"] as! Double
            }
            if dict.keys.contains("SpotStrategy") {
                self.spotStrategy = dict["SpotStrategy"] as! String
            }
            if dict.keys.contains("Tags") {
                var tmp : [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.Tags] = []
                for v in dict["Tags"] as! [Any] {
                    var model = DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.Tags()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tags = tmp
            }
            if dict.keys.contains("TerminationGracePeriodSeconds") {
                self.terminationGracePeriodSeconds = dict["TerminationGracePeriodSeconds"] as! Int32
            }
            if dict.keys.contains("Volumes") {
                var tmp : [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.Volumes] = []
                for v in dict["Volumes"] as! [Any] {
                    var model = DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations.Volumes()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.volumes = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var scalingConfigurations: [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations]?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingConfigurations != nil {
            var tmp : [Any] = []
            for k in self.scalingConfigurations! {
                tmp.append(k.toMap())
            }
            map["ScalingConfigurations"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScalingConfigurations") {
            var tmp : [DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations] = []
            for v in dict["ScalingConfigurations"] as! [Any] {
                var model = DescribeEciScalingConfigurationsResponseBody.ScalingConfigurations()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.scalingConfigurations = tmp
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeEciScalingConfigurationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEciScalingConfigurationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeEciScalingConfigurationsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeElasticStrengthRequest : Tea.TeaModel {
    public var dataDiskCategories: [String]?

    public var imageFamily: String?

    public var imageId: String?

    public var imageName: String?

    public var instanceTypes: [String]?

    public var ipv6AddressCount: Int32?

    public var priorityStrategy: String?

    public var regionId: String?

    public var scalingGroupId: String?

    public var scalingGroupIds: [String]?

    public var spotStrategy: String?

    public var systemDiskCategories: [String]?

    public var vSwitchIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataDiskCategories != nil {
            map["DataDiskCategories"] = self.dataDiskCategories!
        }
        if self.imageFamily != nil {
            map["ImageFamily"] = self.imageFamily!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.imageName != nil {
            map["ImageName"] = self.imageName!
        }
        if self.instanceTypes != nil {
            map["InstanceTypes"] = self.instanceTypes!
        }
        if self.ipv6AddressCount != nil {
            map["Ipv6AddressCount"] = self.ipv6AddressCount!
        }
        if self.priorityStrategy != nil {
            map["PriorityStrategy"] = self.priorityStrategy!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        if self.scalingGroupIds != nil {
            map["ScalingGroupIds"] = self.scalingGroupIds!
        }
        if self.spotStrategy != nil {
            map["SpotStrategy"] = self.spotStrategy!
        }
        if self.systemDiskCategories != nil {
            map["SystemDiskCategories"] = self.systemDiskCategories!
        }
        if self.vSwitchIds != nil {
            map["VSwitchIds"] = self.vSwitchIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataDiskCategories") {
            self.dataDiskCategories = dict["DataDiskCategories"] as! [String]
        }
        if dict.keys.contains("ImageFamily") {
            self.imageFamily = dict["ImageFamily"] as! String
        }
        if dict.keys.contains("ImageId") {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("ImageName") {
            self.imageName = dict["ImageName"] as! String
        }
        if dict.keys.contains("InstanceTypes") {
            self.instanceTypes = dict["InstanceTypes"] as! [String]
        }
        if dict.keys.contains("Ipv6AddressCount") {
            self.ipv6AddressCount = dict["Ipv6AddressCount"] as! Int32
        }
        if dict.keys.contains("PriorityStrategy") {
            self.priorityStrategy = dict["PriorityStrategy"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ScalingGroupId") {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
        if dict.keys.contains("ScalingGroupIds") {
            self.scalingGroupIds = dict["ScalingGroupIds"] as! [String]
        }
        if dict.keys.contains("SpotStrategy") {
            self.spotStrategy = dict["SpotStrategy"] as! String
        }
        if dict.keys.contains("SystemDiskCategories") {
            self.systemDiskCategories = dict["SystemDiskCategories"] as! [String]
        }
        if dict.keys.contains("VSwitchIds") {
            self.vSwitchIds = dict["VSwitchIds"] as! [String]
        }
    }
}

public class DescribeElasticStrengthResponseBody : Tea.TeaModel {
    public class ElasticStrengthModels : Tea.TeaModel {
        public class ResourcePools : Tea.TeaModel {
            public class InventoryHealth : Tea.TeaModel {
                public var adequacyScore: Int32?

                public var healthScore: Int32?

                public var hotScore: Int32?

                public var supplyScore: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.adequacyScore != nil {
                        map["AdequacyScore"] = self.adequacyScore!
                    }
                    if self.healthScore != nil {
                        map["HealthScore"] = self.healthScore!
                    }
                    if self.hotScore != nil {
                        map["HotScore"] = self.hotScore!
                    }
                    if self.supplyScore != nil {
                        map["SupplyScore"] = self.supplyScore!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AdequacyScore") {
                        self.adequacyScore = dict["AdequacyScore"] as! Int32
                    }
                    if dict.keys.contains("HealthScore") {
                        self.healthScore = dict["HealthScore"] as! Int32
                    }
                    if dict.keys.contains("HotScore") {
                        self.hotScore = dict["HotScore"] as! Int32
                    }
                    if dict.keys.contains("SupplyScore") {
                        self.supplyScore = dict["SupplyScore"] as! Int32
                    }
                }
            }
            public var code: String?

            public var instanceType: String?

            public var inventoryHealth: DescribeElasticStrengthResponseBody.ElasticStrengthModels.ResourcePools.InventoryHealth?

            public var msg: String?

            public var status: String?

            public var strength: Double?

            public var vSwitchIds: [String]?

            public var zoneId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.inventoryHealth?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.instanceType != nil {
                    map["InstanceType"] = self.instanceType!
                }
                if self.inventoryHealth != nil {
                    map["InventoryHealth"] = self.inventoryHealth?.toMap()
                }
                if self.msg != nil {
                    map["Msg"] = self.msg!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.strength != nil {
                    map["Strength"] = self.strength!
                }
                if self.vSwitchIds != nil {
                    map["VSwitchIds"] = self.vSwitchIds!
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Code") {
                    self.code = dict["Code"] as! String
                }
                if dict.keys.contains("InstanceType") {
                    self.instanceType = dict["InstanceType"] as! String
                }
                if dict.keys.contains("InventoryHealth") {
                    var model = DescribeElasticStrengthResponseBody.ElasticStrengthModels.ResourcePools.InventoryHealth()
                    model.fromMap(dict["InventoryHealth"] as! [String: Any])
                    self.inventoryHealth = model
                }
                if dict.keys.contains("Msg") {
                    self.msg = dict["Msg"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Strength") {
                    self.strength = dict["Strength"] as! Double
                }
                if dict.keys.contains("VSwitchIds") {
                    self.vSwitchIds = dict["VSwitchIds"] as! [String]
                }
                if dict.keys.contains("ZoneId") {
                    self.zoneId = dict["ZoneId"] as! String
                }
            }
        }
        public var elasticStrength: String?

        public var resourcePools: [DescribeElasticStrengthResponseBody.ElasticStrengthModels.ResourcePools]?

        public var scalingGroupId: String?

        public var totalStrength: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.elasticStrength != nil {
                map["ElasticStrength"] = self.elasticStrength!
            }
            if self.resourcePools != nil {
                var tmp : [Any] = []
                for k in self.resourcePools! {
                    tmp.append(k.toMap())
                }
                map["ResourcePools"] = tmp
            }
            if self.scalingGroupId != nil {
                map["ScalingGroupId"] = self.scalingGroupId!
            }
            if self.totalStrength != nil {
                map["TotalStrength"] = self.totalStrength!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ElasticStrength") {
                self.elasticStrength = dict["ElasticStrength"] as! String
            }
            if dict.keys.contains("ResourcePools") {
                var tmp : [DescribeElasticStrengthResponseBody.ElasticStrengthModels.ResourcePools] = []
                for v in dict["ResourcePools"] as! [Any] {
                    var model = DescribeElasticStrengthResponseBody.ElasticStrengthModels.ResourcePools()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.resourcePools = tmp
            }
            if dict.keys.contains("ScalingGroupId") {
                self.scalingGroupId = dict["ScalingGroupId"] as! String
            }
            if dict.keys.contains("TotalStrength") {
                self.totalStrength = dict["TotalStrength"] as! Double
            }
        }
    }
    public class ResourcePools : Tea.TeaModel {
        public class InventoryHealth : Tea.TeaModel {
            public var adequacyScore: Int32?

            public var healthScore: Int32?

            public var hotScore: Int32?

            public var supplyScore: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.adequacyScore != nil {
                    map["AdequacyScore"] = self.adequacyScore!
                }
                if self.healthScore != nil {
                    map["HealthScore"] = self.healthScore!
                }
                if self.hotScore != nil {
                    map["HotScore"] = self.hotScore!
                }
                if self.supplyScore != nil {
                    map["SupplyScore"] = self.supplyScore!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AdequacyScore") {
                    self.adequacyScore = dict["AdequacyScore"] as! Int32
                }
                if dict.keys.contains("HealthScore") {
                    self.healthScore = dict["HealthScore"] as! Int32
                }
                if dict.keys.contains("HotScore") {
                    self.hotScore = dict["HotScore"] as! Int32
                }
                if dict.keys.contains("SupplyScore") {
                    self.supplyScore = dict["SupplyScore"] as! Int32
                }
            }
        }
        public var code: String?

        public var instanceType: String?

        public var inventoryHealth: DescribeElasticStrengthResponseBody.ResourcePools.InventoryHealth?

        public var msg: String?

        public var status: String?

        public var strength: Double?

        public var vSwitchIds: [String]?

        public var zoneId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.inventoryHealth?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.inventoryHealth != nil {
                map["InventoryHealth"] = self.inventoryHealth?.toMap()
            }
            if self.msg != nil {
                map["Msg"] = self.msg!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.strength != nil {
                map["Strength"] = self.strength!
            }
            if self.vSwitchIds != nil {
                map["VSwitchIds"] = self.vSwitchIds!
            }
            if self.zoneId != nil {
                map["ZoneId"] = self.zoneId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("InstanceType") {
                self.instanceType = dict["InstanceType"] as! String
            }
            if dict.keys.contains("InventoryHealth") {
                var model = DescribeElasticStrengthResponseBody.ResourcePools.InventoryHealth()
                model.fromMap(dict["InventoryHealth"] as! [String: Any])
                self.inventoryHealth = model
            }
            if dict.keys.contains("Msg") {
                self.msg = dict["Msg"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Strength") {
                self.strength = dict["Strength"] as! Double
            }
            if dict.keys.contains("VSwitchIds") {
                self.vSwitchIds = dict["VSwitchIds"] as! [String]
            }
            if dict.keys.contains("ZoneId") {
                self.zoneId = dict["ZoneId"] as! String
            }
        }
    }
    public var elasticStrength: String?

    public var elasticStrengthModels: [DescribeElasticStrengthResponseBody.ElasticStrengthModels]?

    public var requestId: String?

    public var resourcePools: [DescribeElasticStrengthResponseBody.ResourcePools]?

    public var totalStrength: Double?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.elasticStrength != nil {
            map["ElasticStrength"] = self.elasticStrength!
        }
        if self.elasticStrengthModels != nil {
            var tmp : [Any] = []
            for k in self.elasticStrengthModels! {
                tmp.append(k.toMap())
            }
            map["ElasticStrengthModels"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourcePools != nil {
            var tmp : [Any] = []
            for k in self.resourcePools! {
                tmp.append(k.toMap())
            }
            map["ResourcePools"] = tmp
        }
        if self.totalStrength != nil {
            map["TotalStrength"] = self.totalStrength!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ElasticStrength") {
            self.elasticStrength = dict["ElasticStrength"] as! String
        }
        if dict.keys.contains("ElasticStrengthModels") {
            var tmp : [DescribeElasticStrengthResponseBody.ElasticStrengthModels] = []
            for v in dict["ElasticStrengthModels"] as! [Any] {
                var model = DescribeElasticStrengthResponseBody.ElasticStrengthModels()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.elasticStrengthModels = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResourcePools") {
            var tmp : [DescribeElasticStrengthResponseBody.ResourcePools] = []
            for v in dict["ResourcePools"] as! [Any] {
                var model = DescribeElasticStrengthResponseBody.ResourcePools()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resourcePools = tmp
        }
        if dict.keys.contains("TotalStrength") {
            self.totalStrength = dict["TotalStrength"] as! Double
        }
    }
}

public class DescribeElasticStrengthResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeElasticStrengthResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeElasticStrengthResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeInstanceRefreshesRequest : Tea.TeaModel {
    public var instanceRefreshTaskIds: [String]?

    public var maxResults: Int32?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceRefreshTaskIds != nil {
            map["InstanceRefreshTaskIds"] = self.instanceRefreshTaskIds!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceRefreshTaskIds") {
            self.instanceRefreshTaskIds = dict["InstanceRefreshTaskIds"] as! [String]
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ScalingGroupId") {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
    }
}

public class DescribeInstanceRefreshesResponseBody : Tea.TeaModel {
    public class InstanceRefreshTasks : Tea.TeaModel {
        public class DesiredConfiguration : Tea.TeaModel {
            public var imageId: String?

            public var scalingConfigurationId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.imageId != nil {
                    map["ImageId"] = self.imageId!
                }
                if self.scalingConfigurationId != nil {
                    map["ScalingConfigurationId"] = self.scalingConfigurationId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ImageId") {
                    self.imageId = dict["ImageId"] as! String
                }
                if dict.keys.contains("ScalingConfigurationId") {
                    self.scalingConfigurationId = dict["ScalingConfigurationId"] as! String
                }
            }
        }
        public var desiredConfiguration: DescribeInstanceRefreshesResponseBody.InstanceRefreshTasks.DesiredConfiguration?

        public var detail: String?

        public var endTime: String?

        public var finishedUpdateCapacity: Int32?

        public var instanceRefreshTaskId: String?

        public var maxHealthyPercentage: Int32?

        public var minHealthyPercentage: Int32?

        public var regionId: String?

        public var scalingGroupId: String?

        public var skipMatching: Bool?

        public var startTime: String?

        public var status: String?

        public var totalNeedUpdateCapacity: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.desiredConfiguration?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.desiredConfiguration != nil {
                map["DesiredConfiguration"] = self.desiredConfiguration?.toMap()
            }
            if self.detail != nil {
                map["Detail"] = self.detail!
            }
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.finishedUpdateCapacity != nil {
                map["FinishedUpdateCapacity"] = self.finishedUpdateCapacity!
            }
            if self.instanceRefreshTaskId != nil {
                map["InstanceRefreshTaskId"] = self.instanceRefreshTaskId!
            }
            if self.maxHealthyPercentage != nil {
                map["MaxHealthyPercentage"] = self.maxHealthyPercentage!
            }
            if self.minHealthyPercentage != nil {
                map["MinHealthyPercentage"] = self.minHealthyPercentage!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.scalingGroupId != nil {
                map["ScalingGroupId"] = self.scalingGroupId!
            }
            if self.skipMatching != nil {
                map["SkipMatching"] = self.skipMatching!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.totalNeedUpdateCapacity != nil {
                map["TotalNeedUpdateCapacity"] = self.totalNeedUpdateCapacity!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DesiredConfiguration") {
                var model = DescribeInstanceRefreshesResponseBody.InstanceRefreshTasks.DesiredConfiguration()
                model.fromMap(dict["DesiredConfiguration"] as! [String: Any])
                self.desiredConfiguration = model
            }
            if dict.keys.contains("Detail") {
                self.detail = dict["Detail"] as! String
            }
            if dict.keys.contains("EndTime") {
                self.endTime = dict["EndTime"] as! String
            }
            if dict.keys.contains("FinishedUpdateCapacity") {
                self.finishedUpdateCapacity = dict["FinishedUpdateCapacity"] as! Int32
            }
            if dict.keys.contains("InstanceRefreshTaskId") {
                self.instanceRefreshTaskId = dict["InstanceRefreshTaskId"] as! String
            }
            if dict.keys.contains("MaxHealthyPercentage") {
                self.maxHealthyPercentage = dict["MaxHealthyPercentage"] as! Int32
            }
            if dict.keys.contains("MinHealthyPercentage") {
                self.minHealthyPercentage = dict["MinHealthyPercentage"] as! Int32
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("ScalingGroupId") {
                self.scalingGroupId = dict["ScalingGroupId"] as! String
            }
            if dict.keys.contains("SkipMatching") {
                self.skipMatching = dict["SkipMatching"] as! Bool
            }
            if dict.keys.contains("StartTime") {
                self.startTime = dict["StartTime"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TotalNeedUpdateCapacity") {
                self.totalNeedUpdateCapacity = dict["TotalNeedUpdateCapacity"] as! Int32
            }
        }
    }
    public var instanceRefreshTasks: [DescribeInstanceRefreshesResponseBody.InstanceRefreshTasks]?

    public var maxResults: Int32?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceRefreshTasks != nil {
            var tmp : [Any] = []
            for k in self.instanceRefreshTasks! {
                tmp.append(k.toMap())
            }
            map["InstanceRefreshTasks"] = tmp
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceRefreshTasks") {
            var tmp : [DescribeInstanceRefreshesResponseBody.InstanceRefreshTasks] = []
            for v in dict["InstanceRefreshTasks"] as! [Any] {
                var model = DescribeInstanceRefreshesResponseBody.InstanceRefreshTasks()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.instanceRefreshTasks = tmp
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeInstanceRefreshesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstanceRefreshesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeInstanceRefreshesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLifecycleActionsRequest : Tea.TeaModel {
    public var lifecycleActionStatus: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingActivityId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lifecycleActionStatus != nil {
            map["LifecycleActionStatus"] = self.lifecycleActionStatus!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingActivityId != nil {
            map["ScalingActivityId"] = self.scalingActivityId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LifecycleActionStatus") {
            self.lifecycleActionStatus = dict["LifecycleActionStatus"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScalingActivityId") {
            self.scalingActivityId = dict["ScalingActivityId"] as! String
        }
    }
}

public class DescribeLifecycleActionsResponseBody : Tea.TeaModel {
    public class LifecycleActions : Tea.TeaModel {
        public var instanceIds: [String]?

        public var lifecycleActionResult: String?

        public var lifecycleActionStatus: String?

        public var lifecycleActionToken: String?

        public var lifecycleHookId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceIds != nil {
                map["InstanceIds"] = self.instanceIds!
            }
            if self.lifecycleActionResult != nil {
                map["LifecycleActionResult"] = self.lifecycleActionResult!
            }
            if self.lifecycleActionStatus != nil {
                map["LifecycleActionStatus"] = self.lifecycleActionStatus!
            }
            if self.lifecycleActionToken != nil {
                map["LifecycleActionToken"] = self.lifecycleActionToken!
            }
            if self.lifecycleHookId != nil {
                map["LifecycleHookId"] = self.lifecycleHookId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceIds") {
                self.instanceIds = dict["InstanceIds"] as! [String]
            }
            if dict.keys.contains("LifecycleActionResult") {
                self.lifecycleActionResult = dict["LifecycleActionResult"] as! String
            }
            if dict.keys.contains("LifecycleActionStatus") {
                self.lifecycleActionStatus = dict["LifecycleActionStatus"] as! String
            }
            if dict.keys.contains("LifecycleActionToken") {
                self.lifecycleActionToken = dict["LifecycleActionToken"] as! String
            }
            if dict.keys.contains("LifecycleHookId") {
                self.lifecycleHookId = dict["LifecycleHookId"] as! String
            }
        }
    }
    public var lifecycleActions: [DescribeLifecycleActionsResponseBody.LifecycleActions]?

    public var maxResults: Int32?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lifecycleActions != nil {
            var tmp : [Any] = []
            for k in self.lifecycleActions! {
                tmp.append(k.toMap())
            }
            map["LifecycleActions"] = tmp
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LifecycleActions") {
            var tmp : [DescribeLifecycleActionsResponseBody.LifecycleActions] = []
            for v in dict["LifecycleActions"] as! [Any] {
                var model = DescribeLifecycleActionsResponseBody.LifecycleActions()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.lifecycleActions = tmp
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeLifecycleActionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLifecycleActionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLifecycleActionsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLifecycleHooksRequest : Tea.TeaModel {
    public var lifecycleHookIds: [String]?

    public var lifecycleHookName: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lifecycleHookIds != nil {
            map["LifecycleHookIds"] = self.lifecycleHookIds!
        }
        if self.lifecycleHookName != nil {
            map["LifecycleHookName"] = self.lifecycleHookName!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LifecycleHookIds") {
            self.lifecycleHookIds = dict["LifecycleHookIds"] as! [String]
        }
        if dict.keys.contains("LifecycleHookName") {
            self.lifecycleHookName = dict["LifecycleHookName"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScalingGroupId") {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
    }
}

public class DescribeLifecycleHooksResponseBody : Tea.TeaModel {
    public class LifecycleHooks : Tea.TeaModel {
        public var defaultResult: String?

        public var heartbeatTimeout: Int32?

        public var lifecycleHookId: String?

        public var lifecycleHookName: String?

        public var lifecycleHookStatus: String?

        public var lifecycleTransition: String?

        public var notificationArn: String?

        public var notificationMetadata: String?

        public var scalingGroupId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.defaultResult != nil {
                map["DefaultResult"] = self.defaultResult!
            }
            if self.heartbeatTimeout != nil {
                map["HeartbeatTimeout"] = self.heartbeatTimeout!
            }
            if self.lifecycleHookId != nil {
                map["LifecycleHookId"] = self.lifecycleHookId!
            }
            if self.lifecycleHookName != nil {
                map["LifecycleHookName"] = self.lifecycleHookName!
            }
            if self.lifecycleHookStatus != nil {
                map["LifecycleHookStatus"] = self.lifecycleHookStatus!
            }
            if self.lifecycleTransition != nil {
                map["LifecycleTransition"] = self.lifecycleTransition!
            }
            if self.notificationArn != nil {
                map["NotificationArn"] = self.notificationArn!
            }
            if self.notificationMetadata != nil {
                map["NotificationMetadata"] = self.notificationMetadata!
            }
            if self.scalingGroupId != nil {
                map["ScalingGroupId"] = self.scalingGroupId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DefaultResult") {
                self.defaultResult = dict["DefaultResult"] as! String
            }
            if dict.keys.contains("HeartbeatTimeout") {
                self.heartbeatTimeout = dict["HeartbeatTimeout"] as! Int32
            }
            if dict.keys.contains("LifecycleHookId") {
                self.lifecycleHookId = dict["LifecycleHookId"] as! String
            }
            if dict.keys.contains("LifecycleHookName") {
                self.lifecycleHookName = dict["LifecycleHookName"] as! String
            }
            if dict.keys.contains("LifecycleHookStatus") {
                self.lifecycleHookStatus = dict["LifecycleHookStatus"] as! String
            }
            if dict.keys.contains("LifecycleTransition") {
                self.lifecycleTransition = dict["LifecycleTransition"] as! String
            }
            if dict.keys.contains("NotificationArn") {
                self.notificationArn = dict["NotificationArn"] as! String
            }
            if dict.keys.contains("NotificationMetadata") {
                self.notificationMetadata = dict["NotificationMetadata"] as! String
            }
            if dict.keys.contains("ScalingGroupId") {
                self.scalingGroupId = dict["ScalingGroupId"] as! String
            }
        }
    }
    public var lifecycleHooks: [DescribeLifecycleHooksResponseBody.LifecycleHooks]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lifecycleHooks != nil {
            var tmp : [Any] = []
            for k in self.lifecycleHooks! {
                tmp.append(k.toMap())
            }
            map["LifecycleHooks"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LifecycleHooks") {
            var tmp : [DescribeLifecycleHooksResponseBody.LifecycleHooks] = []
            for v in dict["LifecycleHooks"] as! [Any] {
                var model = DescribeLifecycleHooksResponseBody.LifecycleHooks()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.lifecycleHooks = tmp
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeLifecycleHooksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLifecycleHooksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLifecycleHooksResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLimitationRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
    }
}

public class DescribeLimitationResponseBody : Tea.TeaModel {
    public var maxNumberOfAlbServerGroup: Int32?

    public var maxNumberOfDBInstances: Int32?

    public var maxNumberOfLifecycleHooks: Int32?

    public var maxNumberOfLoadBalancers: Int32?

    public var maxNumberOfMaxSize: Int32?

    public var maxNumberOfMinSize: Int32?

    public var maxNumberOfNlbServerGroup: Int32?

    public var maxNumberOfNotificationConfigurations: Int32?

    public var maxNumberOfScalingConfigurations: Int32?

    public var maxNumberOfScalingGroups: Int32?

    public var maxNumberOfScalingInstances: Int32?

    public var maxNumberOfScalingRules: Int32?

    public var maxNumberOfScheduledTasks: Int32?

    public var maxNumberOfVServerGroups: Int32?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxNumberOfAlbServerGroup != nil {
            map["MaxNumberOfAlbServerGroup"] = self.maxNumberOfAlbServerGroup!
        }
        if self.maxNumberOfDBInstances != nil {
            map["MaxNumberOfDBInstances"] = self.maxNumberOfDBInstances!
        }
        if self.maxNumberOfLifecycleHooks != nil {
            map["MaxNumberOfLifecycleHooks"] = self.maxNumberOfLifecycleHooks!
        }
        if self.maxNumberOfLoadBalancers != nil {
            map["MaxNumberOfLoadBalancers"] = self.maxNumberOfLoadBalancers!
        }
        if self.maxNumberOfMaxSize != nil {
            map["MaxNumberOfMaxSize"] = self.maxNumberOfMaxSize!
        }
        if self.maxNumberOfMinSize != nil {
            map["MaxNumberOfMinSize"] = self.maxNumberOfMinSize!
        }
        if self.maxNumberOfNlbServerGroup != nil {
            map["MaxNumberOfNlbServerGroup"] = self.maxNumberOfNlbServerGroup!
        }
        if self.maxNumberOfNotificationConfigurations != nil {
            map["MaxNumberOfNotificationConfigurations"] = self.maxNumberOfNotificationConfigurations!
        }
        if self.maxNumberOfScalingConfigurations != nil {
            map["MaxNumberOfScalingConfigurations"] = self.maxNumberOfScalingConfigurations!
        }
        if self.maxNumberOfScalingGroups != nil {
            map["MaxNumberOfScalingGroups"] = self.maxNumberOfScalingGroups!
        }
        if self.maxNumberOfScalingInstances != nil {
            map["MaxNumberOfScalingInstances"] = self.maxNumberOfScalingInstances!
        }
        if self.maxNumberOfScalingRules != nil {
            map["MaxNumberOfScalingRules"] = self.maxNumberOfScalingRules!
        }
        if self.maxNumberOfScheduledTasks != nil {
            map["MaxNumberOfScheduledTasks"] = self.maxNumberOfScheduledTasks!
        }
        if self.maxNumberOfVServerGroups != nil {
            map["MaxNumberOfVServerGroups"] = self.maxNumberOfVServerGroups!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxNumberOfAlbServerGroup") {
            self.maxNumberOfAlbServerGroup = dict["MaxNumberOfAlbServerGroup"] as! Int32
        }
        if dict.keys.contains("MaxNumberOfDBInstances") {
            self.maxNumberOfDBInstances = dict["MaxNumberOfDBInstances"] as! Int32
        }
        if dict.keys.contains("MaxNumberOfLifecycleHooks") {
            self.maxNumberOfLifecycleHooks = dict["MaxNumberOfLifecycleHooks"] as! Int32
        }
        if dict.keys.contains("MaxNumberOfLoadBalancers") {
            self.maxNumberOfLoadBalancers = dict["MaxNumberOfLoadBalancers"] as! Int32
        }
        if dict.keys.contains("MaxNumberOfMaxSize") {
            self.maxNumberOfMaxSize = dict["MaxNumberOfMaxSize"] as! Int32
        }
        if dict.keys.contains("MaxNumberOfMinSize") {
            self.maxNumberOfMinSize = dict["MaxNumberOfMinSize"] as! Int32
        }
        if dict.keys.contains("MaxNumberOfNlbServerGroup") {
            self.maxNumberOfNlbServerGroup = dict["MaxNumberOfNlbServerGroup"] as! Int32
        }
        if dict.keys.contains("MaxNumberOfNotificationConfigurations") {
            self.maxNumberOfNotificationConfigurations = dict["MaxNumberOfNotificationConfigurations"] as! Int32
        }
        if dict.keys.contains("MaxNumberOfScalingConfigurations") {
            self.maxNumberOfScalingConfigurations = dict["MaxNumberOfScalingConfigurations"] as! Int32
        }
        if dict.keys.contains("MaxNumberOfScalingGroups") {
            self.maxNumberOfScalingGroups = dict["MaxNumberOfScalingGroups"] as! Int32
        }
        if dict.keys.contains("MaxNumberOfScalingInstances") {
            self.maxNumberOfScalingInstances = dict["MaxNumberOfScalingInstances"] as! Int32
        }
        if dict.keys.contains("MaxNumberOfScalingRules") {
            self.maxNumberOfScalingRules = dict["MaxNumberOfScalingRules"] as! Int32
        }
        if dict.keys.contains("MaxNumberOfScheduledTasks") {
            self.maxNumberOfScheduledTasks = dict["MaxNumberOfScheduledTasks"] as! Int32
        }
        if dict.keys.contains("MaxNumberOfVServerGroups") {
            self.maxNumberOfVServerGroups = dict["MaxNumberOfVServerGroups"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeLimitationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLimitationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLimitationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeNotificationConfigurationsRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScalingGroupId") {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
    }
}

public class DescribeNotificationConfigurationsResponseBody : Tea.TeaModel {
    public class NotificationConfigurationModels : Tea.TeaModel {
        public var notificationArn: String?

        public var notificationTypes: [String]?

        public var scalingGroupId: String?

        public var timeZone: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.notificationArn != nil {
                map["NotificationArn"] = self.notificationArn!
            }
            if self.notificationTypes != nil {
                map["NotificationTypes"] = self.notificationTypes!
            }
            if self.scalingGroupId != nil {
                map["ScalingGroupId"] = self.scalingGroupId!
            }
            if self.timeZone != nil {
                map["TimeZone"] = self.timeZone!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("NotificationArn") {
                self.notificationArn = dict["NotificationArn"] as! String
            }
            if dict.keys.contains("NotificationTypes") {
                self.notificationTypes = dict["NotificationTypes"] as! [String]
            }
            if dict.keys.contains("ScalingGroupId") {
                self.scalingGroupId = dict["ScalingGroupId"] as! String
            }
            if dict.keys.contains("TimeZone") {
                self.timeZone = dict["TimeZone"] as! String
            }
        }
    }
    public var notificationConfigurationModels: [DescribeNotificationConfigurationsResponseBody.NotificationConfigurationModels]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.notificationConfigurationModels != nil {
            var tmp : [Any] = []
            for k in self.notificationConfigurationModels! {
                tmp.append(k.toMap())
            }
            map["NotificationConfigurationModels"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NotificationConfigurationModels") {
            var tmp : [DescribeNotificationConfigurationsResponseBody.NotificationConfigurationModels] = []
            for v in dict["NotificationConfigurationModels"] as! [Any] {
                var model = DescribeNotificationConfigurationsResponseBody.NotificationConfigurationModels()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.notificationConfigurationModels = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeNotificationConfigurationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeNotificationConfigurationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeNotificationConfigurationsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeNotificationTypesRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
    }
}

public class DescribeNotificationTypesResponseBody : Tea.TeaModel {
    public var notificationTypes: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.notificationTypes != nil {
            map["NotificationTypes"] = self.notificationTypes!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NotificationTypes") {
            self.notificationTypes = dict["NotificationTypes"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeNotificationTypesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeNotificationTypesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeNotificationTypesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePatternTypesRequest : Tea.TeaModel {
    public var architecture: [String]?

    public var burstablePerformance: String?

    public var channelId: Int64?

    public var cores: Int32?

    public var coresList: [Int32]?

    public var cpuArchitectures: [String]?

    public var excludedInstanceType: [String]?

    public var gpuSpecs: [String]?

    public var instanceCategories: [String]?

    public var instanceFamilyLevel: String?

    public var instanceTypeFamilies: [String]?

    public var maxPrice: Double?

    public var maximumCpuCoreCount: Int32?

    public var maximumGpuAmount: Int32?

    public var maximumMemorySize: Double?

    public var memory: Double?

    public var memoryList: [Double]?

    public var minimumBaselineCredit: Int32?

    public var minimumCpuCoreCount: Int32?

    public var minimumEniIpv6AddressQuantity: Int32?

    public var minimumEniPrivateIpAddressQuantity: Int32?

    public var minimumEniQuantity: Int32?

    public var minimumGpuAmount: Int32?

    public var minimumInitialCredit: Int32?

    public var minimumMemorySize: Double?

    public var physicalProcessorModels: [String]?

    public var regionId: String?

    public var spotStrategy: String?

    public var vSwitchId: [String]?

    public var zoneId: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.architecture != nil {
            map["Architecture"] = self.architecture!
        }
        if self.burstablePerformance != nil {
            map["BurstablePerformance"] = self.burstablePerformance!
        }
        if self.channelId != nil {
            map["ChannelId"] = self.channelId!
        }
        if self.cores != nil {
            map["Cores"] = self.cores!
        }
        if self.coresList != nil {
            map["CoresList"] = self.coresList!
        }
        if self.cpuArchitectures != nil {
            map["CpuArchitectures"] = self.cpuArchitectures!
        }
        if self.excludedInstanceType != nil {
            map["ExcludedInstanceType"] = self.excludedInstanceType!
        }
        if self.gpuSpecs != nil {
            map["GpuSpecs"] = self.gpuSpecs!
        }
        if self.instanceCategories != nil {
            map["InstanceCategories"] = self.instanceCategories!
        }
        if self.instanceFamilyLevel != nil {
            map["InstanceFamilyLevel"] = self.instanceFamilyLevel!
        }
        if self.instanceTypeFamilies != nil {
            map["InstanceTypeFamilies"] = self.instanceTypeFamilies!
        }
        if self.maxPrice != nil {
            map["MaxPrice"] = self.maxPrice!
        }
        if self.maximumCpuCoreCount != nil {
            map["MaximumCpuCoreCount"] = self.maximumCpuCoreCount!
        }
        if self.maximumGpuAmount != nil {
            map["MaximumGpuAmount"] = self.maximumGpuAmount!
        }
        if self.maximumMemorySize != nil {
            map["MaximumMemorySize"] = self.maximumMemorySize!
        }
        if self.memory != nil {
            map["Memory"] = self.memory!
        }
        if self.memoryList != nil {
            map["MemoryList"] = self.memoryList!
        }
        if self.minimumBaselineCredit != nil {
            map["MinimumBaselineCredit"] = self.minimumBaselineCredit!
        }
        if self.minimumCpuCoreCount != nil {
            map["MinimumCpuCoreCount"] = self.minimumCpuCoreCount!
        }
        if self.minimumEniIpv6AddressQuantity != nil {
            map["MinimumEniIpv6AddressQuantity"] = self.minimumEniIpv6AddressQuantity!
        }
        if self.minimumEniPrivateIpAddressQuantity != nil {
            map["MinimumEniPrivateIpAddressQuantity"] = self.minimumEniPrivateIpAddressQuantity!
        }
        if self.minimumEniQuantity != nil {
            map["MinimumEniQuantity"] = self.minimumEniQuantity!
        }
        if self.minimumGpuAmount != nil {
            map["MinimumGpuAmount"] = self.minimumGpuAmount!
        }
        if self.minimumInitialCredit != nil {
            map["MinimumInitialCredit"] = self.minimumInitialCredit!
        }
        if self.minimumMemorySize != nil {
            map["MinimumMemorySize"] = self.minimumMemorySize!
        }
        if self.physicalProcessorModels != nil {
            map["PhysicalProcessorModels"] = self.physicalProcessorModels!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.spotStrategy != nil {
            map["SpotStrategy"] = self.spotStrategy!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Architecture") {
            self.architecture = dict["Architecture"] as! [String]
        }
        if dict.keys.contains("BurstablePerformance") {
            self.burstablePerformance = dict["BurstablePerformance"] as! String
        }
        if dict.keys.contains("ChannelId") {
            self.channelId = dict["ChannelId"] as! Int64
        }
        if dict.keys.contains("Cores") {
            self.cores = dict["Cores"] as! Int32
        }
        if dict.keys.contains("CoresList") {
            self.coresList = dict["CoresList"] as! [Int32]
        }
        if dict.keys.contains("CpuArchitectures") {
            self.cpuArchitectures = dict["CpuArchitectures"] as! [String]
        }
        if dict.keys.contains("ExcludedInstanceType") {
            self.excludedInstanceType = dict["ExcludedInstanceType"] as! [String]
        }
        if dict.keys.contains("GpuSpecs") {
            self.gpuSpecs = dict["GpuSpecs"] as! [String]
        }
        if dict.keys.contains("InstanceCategories") {
            self.instanceCategories = dict["InstanceCategories"] as! [String]
        }
        if dict.keys.contains("InstanceFamilyLevel") {
            self.instanceFamilyLevel = dict["InstanceFamilyLevel"] as! String
        }
        if dict.keys.contains("InstanceTypeFamilies") {
            self.instanceTypeFamilies = dict["InstanceTypeFamilies"] as! [String]
        }
        if dict.keys.contains("MaxPrice") {
            self.maxPrice = dict["MaxPrice"] as! Double
        }
        if dict.keys.contains("MaximumCpuCoreCount") {
            self.maximumCpuCoreCount = dict["MaximumCpuCoreCount"] as! Int32
        }
        if dict.keys.contains("MaximumGpuAmount") {
            self.maximumGpuAmount = dict["MaximumGpuAmount"] as! Int32
        }
        if dict.keys.contains("MaximumMemorySize") {
            self.maximumMemorySize = dict["MaximumMemorySize"] as! Double
        }
        if dict.keys.contains("Memory") {
            self.memory = dict["Memory"] as! Double
        }
        if dict.keys.contains("MemoryList") {
            self.memoryList = dict["MemoryList"] as! [Double]
        }
        if dict.keys.contains("MinimumBaselineCredit") {
            self.minimumBaselineCredit = dict["MinimumBaselineCredit"] as! Int32
        }
        if dict.keys.contains("MinimumCpuCoreCount") {
            self.minimumCpuCoreCount = dict["MinimumCpuCoreCount"] as! Int32
        }
        if dict.keys.contains("MinimumEniIpv6AddressQuantity") {
            self.minimumEniIpv6AddressQuantity = dict["MinimumEniIpv6AddressQuantity"] as! Int32
        }
        if dict.keys.contains("MinimumEniPrivateIpAddressQuantity") {
            self.minimumEniPrivateIpAddressQuantity = dict["MinimumEniPrivateIpAddressQuantity"] as! Int32
        }
        if dict.keys.contains("MinimumEniQuantity") {
            self.minimumEniQuantity = dict["MinimumEniQuantity"] as! Int32
        }
        if dict.keys.contains("MinimumGpuAmount") {
            self.minimumGpuAmount = dict["MinimumGpuAmount"] as! Int32
        }
        if dict.keys.contains("MinimumInitialCredit") {
            self.minimumInitialCredit = dict["MinimumInitialCredit"] as! Int32
        }
        if dict.keys.contains("MinimumMemorySize") {
            self.minimumMemorySize = dict["MinimumMemorySize"] as! Double
        }
        if dict.keys.contains("PhysicalProcessorModels") {
            self.physicalProcessorModels = dict["PhysicalProcessorModels"] as! [String]
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("SpotStrategy") {
            self.spotStrategy = dict["SpotStrategy"] as! String
        }
        if dict.keys.contains("VSwitchId") {
            self.vSwitchId = dict["VSwitchId"] as! [String]
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! [String]
        }
    }
}

public class DescribePatternTypesResponseBody : Tea.TeaModel {
    public class PatternTypes : Tea.TeaModel {
        public var cores: Int32?

        public var instanceFamilyLevel: String?

        public var instanceType: String?

        public var instanceTypeFamily: String?

        public var memory: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cores != nil {
                map["Cores"] = self.cores!
            }
            if self.instanceFamilyLevel != nil {
                map["InstanceFamilyLevel"] = self.instanceFamilyLevel!
            }
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.instanceTypeFamily != nil {
                map["InstanceTypeFamily"] = self.instanceTypeFamily!
            }
            if self.memory != nil {
                map["Memory"] = self.memory!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Cores") {
                self.cores = dict["Cores"] as! Int32
            }
            if dict.keys.contains("InstanceFamilyLevel") {
                self.instanceFamilyLevel = dict["InstanceFamilyLevel"] as! String
            }
            if dict.keys.contains("InstanceType") {
                self.instanceType = dict["InstanceType"] as! String
            }
            if dict.keys.contains("InstanceTypeFamily") {
                self.instanceTypeFamily = dict["InstanceTypeFamily"] as! String
            }
            if dict.keys.contains("Memory") {
                self.memory = dict["Memory"] as! Double
            }
        }
    }
    public var patternTypes: [DescribePatternTypesResponseBody.PatternTypes]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.patternTypes != nil {
            var tmp : [Any] = []
            for k in self.patternTypes! {
                tmp.append(k.toMap())
            }
            map["PatternTypes"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PatternTypes") {
            var tmp : [DescribePatternTypesResponseBody.PatternTypes] = []
            for v in dict["PatternTypes"] as! [Any] {
                var model = DescribePatternTypesResponseBody.PatternTypes()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.patternTypes = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribePatternTypesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePatternTypesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribePatternTypesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeRegionsRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DescribeRegionsResponseBody : Tea.TeaModel {
    public class Regions : Tea.TeaModel {
        public var classicUnavailable: Bool?

        public var localName: String?

        public var regionEndpoint: String?

        public var regionId: String?

        public var vpcUnavailable: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.classicUnavailable != nil {
                map["ClassicUnavailable"] = self.classicUnavailable!
            }
            if self.localName != nil {
                map["LocalName"] = self.localName!
            }
            if self.regionEndpoint != nil {
                map["RegionEndpoint"] = self.regionEndpoint!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.vpcUnavailable != nil {
                map["VpcUnavailable"] = self.vpcUnavailable!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClassicUnavailable") {
                self.classicUnavailable = dict["ClassicUnavailable"] as! Bool
            }
            if dict.keys.contains("LocalName") {
                self.localName = dict["LocalName"] as! String
            }
            if dict.keys.contains("RegionEndpoint") {
                self.regionEndpoint = dict["RegionEndpoint"] as! String
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("VpcUnavailable") {
                self.vpcUnavailable = dict["VpcUnavailable"] as! Bool
            }
        }
    }
    public var regions: [DescribeRegionsResponseBody.Regions]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regions != nil {
            var tmp : [Any] = []
            for k in self.regions! {
                tmp.append(k.toMap())
            }
            map["Regions"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Regions") {
            var tmp : [DescribeRegionsResponseBody.Regions] = []
            for v in dict["Regions"] as! [Any] {
                var model = DescribeRegionsResponseBody.Regions()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.regions = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeRegionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRegionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeRegionsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeScalingActivitiesRequest : Tea.TeaModel {
    public var instanceRefreshTaskId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var scalingActivityIds: [String]?

    public var scalingGroupId: String?

    public var statusCode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceRefreshTaskId != nil {
            map["InstanceRefreshTaskId"] = self.instanceRefreshTaskId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.scalingActivityIds != nil {
            map["ScalingActivityIds"] = self.scalingActivityIds!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        if self.statusCode != nil {
            map["StatusCode"] = self.statusCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceRefreshTaskId") {
            self.instanceRefreshTaskId = dict["InstanceRefreshTaskId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ScalingActivityIds") {
            self.scalingActivityIds = dict["ScalingActivityIds"] as! [String]
        }
        if dict.keys.contains("ScalingGroupId") {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
        if dict.keys.contains("StatusCode") {
            self.statusCode = dict["StatusCode"] as! String
        }
    }
}

public class DescribeScalingActivitiesResponseBody : Tea.TeaModel {
    public class ScalingActivities : Tea.TeaModel {
        public class ErrorMessages : Tea.TeaModel {
            public var code: String?

            public var description_: String?

            public var failedInstanceIds: [String]?

            public var message: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.failedInstanceIds != nil {
                    map["FailedInstanceIds"] = self.failedInstanceIds!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Code") {
                    self.code = dict["Code"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("FailedInstanceIds") {
                    self.failedInstanceIds = dict["FailedInstanceIds"] as! [String]
                }
                if dict.keys.contains("Message") {
                    self.message = dict["Message"] as! String
                }
            }
        }
        public class LifecycleHookContext : Tea.TeaModel {
            public var disableLifecycleHook: Bool?

            public var ignoredLifecycleHookIds: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.disableLifecycleHook != nil {
                    map["DisableLifecycleHook"] = self.disableLifecycleHook!
                }
                if self.ignoredLifecycleHookIds != nil {
                    map["IgnoredLifecycleHookIds"] = self.ignoredLifecycleHookIds!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DisableLifecycleHook") {
                    self.disableLifecycleHook = dict["DisableLifecycleHook"] as! Bool
                }
                if dict.keys.contains("IgnoredLifecycleHookIds") {
                    self.ignoredLifecycleHookIds = dict["IgnoredLifecycleHookIds"] as! [String]
                }
            }
        }
        public var activityMetadata: String?

        public var attachedCapacity: String?

        public var autoCreatedCapacity: String?

        public var cause: String?

        public var createdCapacity: Int32?

        public var createdInstances: [String]?

        public var description_: String?

        public var destroyedCapacity: Int32?

        public var destroyedInstances: [String]?

        public var detail: String?

        public var endTime: String?

        public var errorCode: String?

        public var errorMessage: String?

        public var errorMessages: [DescribeScalingActivitiesResponseBody.ScalingActivities.ErrorMessages]?

        public var instanceRefreshTaskId: String?

        public var lifecycleHookContext: DescribeScalingActivitiesResponseBody.ScalingActivities.LifecycleHookContext?

        public var progress: Int32?

        public var scalingActivityId: String?

        public var scalingGroupId: String?

        public var scalingInstanceNumber: Int32?

        public var startTime: String?

        public var startedCapacity: Int32?

        public var startedInstances: [String]?

        public var statusCode: String?

        public var statusMessage: String?

        public var stoppedCapacity: Int32?

        public var stoppedInstances: [String]?

        public var totalCapacity: String?

        public var triggerSourceId: String?

        public var triggerSourceType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.lifecycleHookContext?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.activityMetadata != nil {
                map["ActivityMetadata"] = self.activityMetadata!
            }
            if self.attachedCapacity != nil {
                map["AttachedCapacity"] = self.attachedCapacity!
            }
            if self.autoCreatedCapacity != nil {
                map["AutoCreatedCapacity"] = self.autoCreatedCapacity!
            }
            if self.cause != nil {
                map["Cause"] = self.cause!
            }
            if self.createdCapacity != nil {
                map["CreatedCapacity"] = self.createdCapacity!
            }
            if self.createdInstances != nil {
                map["CreatedInstances"] = self.createdInstances!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.destroyedCapacity != nil {
                map["DestroyedCapacity"] = self.destroyedCapacity!
            }
            if self.destroyedInstances != nil {
                map["DestroyedInstances"] = self.destroyedInstances!
            }
            if self.detail != nil {
                map["Detail"] = self.detail!
            }
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.errorCode != nil {
                map["ErrorCode"] = self.errorCode!
            }
            if self.errorMessage != nil {
                map["ErrorMessage"] = self.errorMessage!
            }
            if self.errorMessages != nil {
                var tmp : [Any] = []
                for k in self.errorMessages! {
                    tmp.append(k.toMap())
                }
                map["ErrorMessages"] = tmp
            }
            if self.instanceRefreshTaskId != nil {
                map["InstanceRefreshTaskId"] = self.instanceRefreshTaskId!
            }
            if self.lifecycleHookContext != nil {
                map["LifecycleHookContext"] = self.lifecycleHookContext?.toMap()
            }
            if self.progress != nil {
                map["Progress"] = self.progress!
            }
            if self.scalingActivityId != nil {
                map["ScalingActivityId"] = self.scalingActivityId!
            }
            if self.scalingGroupId != nil {
                map["ScalingGroupId"] = self.scalingGroupId!
            }
            if self.scalingInstanceNumber != nil {
                map["ScalingInstanceNumber"] = self.scalingInstanceNumber!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.startedCapacity != nil {
                map["StartedCapacity"] = self.startedCapacity!
            }
            if self.startedInstances != nil {
                map["StartedInstances"] = self.startedInstances!
            }
            if self.statusCode != nil {
                map["StatusCode"] = self.statusCode!
            }
            if self.statusMessage != nil {
                map["StatusMessage"] = self.statusMessage!
            }
            if self.stoppedCapacity != nil {
                map["StoppedCapacity"] = self.stoppedCapacity!
            }
            if self.stoppedInstances != nil {
                map["StoppedInstances"] = self.stoppedInstances!
            }
            if self.totalCapacity != nil {
                map["TotalCapacity"] = self.totalCapacity!
            }
            if self.triggerSourceId != nil {
                map["TriggerSourceId"] = self.triggerSourceId!
            }
            if self.triggerSourceType != nil {
                map["TriggerSourceType"] = self.triggerSourceType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ActivityMetadata") {
                self.activityMetadata = dict["ActivityMetadata"] as! String
            }
            if dict.keys.contains("AttachedCapacity") {
                self.attachedCapacity = dict["AttachedCapacity"] as! String
            }
            if dict.keys.contains("AutoCreatedCapacity") {
                self.autoCreatedCapacity = dict["AutoCreatedCapacity"] as! String
            }
            if dict.keys.contains("Cause") {
                self.cause = dict["Cause"] as! String
            }
            if dict.keys.contains("CreatedCapacity") {
                self.createdCapacity = dict["CreatedCapacity"] as! Int32
            }
            if dict.keys.contains("CreatedInstances") {
                self.createdInstances = dict["CreatedInstances"] as! [String]
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("DestroyedCapacity") {
                self.destroyedCapacity = dict["DestroyedCapacity"] as! Int32
            }
            if dict.keys.contains("DestroyedInstances") {
                self.destroyedInstances = dict["DestroyedInstances"] as! [String]
            }
            if dict.keys.contains("Detail") {
                self.detail = dict["Detail"] as! String
            }
            if dict.keys.contains("EndTime") {
                self.endTime = dict["EndTime"] as! String
            }
            if dict.keys.contains("ErrorCode") {
                self.errorCode = dict["ErrorCode"] as! String
            }
            if dict.keys.contains("ErrorMessage") {
                self.errorMessage = dict["ErrorMessage"] as! String
            }
            if dict.keys.contains("ErrorMessages") {
                var tmp : [DescribeScalingActivitiesResponseBody.ScalingActivities.ErrorMessages] = []
                for v in dict["ErrorMessages"] as! [Any] {
                    var model = DescribeScalingActivitiesResponseBody.ScalingActivities.ErrorMessages()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.errorMessages = tmp
            }
            if dict.keys.contains("InstanceRefreshTaskId") {
                self.instanceRefreshTaskId = dict["InstanceRefreshTaskId"] as! String
            }
            if dict.keys.contains("LifecycleHookContext") {
                var model = DescribeScalingActivitiesResponseBody.ScalingActivities.LifecycleHookContext()
                model.fromMap(dict["LifecycleHookContext"] as! [String: Any])
                self.lifecycleHookContext = model
            }
            if dict.keys.contains("Progress") {
                self.progress = dict["Progress"] as! Int32
            }
            if dict.keys.contains("ScalingActivityId") {
                self.scalingActivityId = dict["ScalingActivityId"] as! String
            }
            if dict.keys.contains("ScalingGroupId") {
                self.scalingGroupId = dict["ScalingGroupId"] as! String
            }
            if dict.keys.contains("ScalingInstanceNumber") {
                self.scalingInstanceNumber = dict["ScalingInstanceNumber"] as! Int32
            }
            if dict.keys.contains("StartTime") {
                self.startTime = dict["StartTime"] as! String
            }
            if dict.keys.contains("StartedCapacity") {
                self.startedCapacity = dict["StartedCapacity"] as! Int32
            }
            if dict.keys.contains("StartedInstances") {
                self.startedInstances = dict["StartedInstances"] as! [String]
            }
            if dict.keys.contains("StatusCode") {
                self.statusCode = dict["StatusCode"] as! String
            }
            if dict.keys.contains("StatusMessage") {
                self.statusMessage = dict["StatusMessage"] as! String
            }
            if dict.keys.contains("StoppedCapacity") {
                self.stoppedCapacity = dict["StoppedCapacity"] as! Int32
            }
            if dict.keys.contains("StoppedInstances") {
                self.stoppedInstances = dict["StoppedInstances"] as! [String]
            }
            if dict.keys.contains("TotalCapacity") {
                self.totalCapacity = dict["TotalCapacity"] as! String
            }
            if dict.keys.contains("TriggerSourceId") {
                self.triggerSourceId = dict["TriggerSourceId"] as! String
            }
            if dict.keys.contains("TriggerSourceType") {
                self.triggerSourceType = dict["TriggerSourceType"] as! String
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var scalingActivities: [DescribeScalingActivitiesResponseBody.ScalingActivities]?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingActivities != nil {
            var tmp : [Any] = []
            for k in self.scalingActivities! {
                tmp.append(k.toMap())
            }
            map["ScalingActivities"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScalingActivities") {
            var tmp : [DescribeScalingActivitiesResponseBody.ScalingActivities] = []
            for v in dict["ScalingActivities"] as! [Any] {
                var model = DescribeScalingActivitiesResponseBody.ScalingActivities()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.scalingActivities = tmp
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeScalingActivitiesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeScalingActivitiesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeScalingActivitiesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeScalingActivityDetailRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var scalingActivityId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.scalingActivityId != nil {
            map["ScalingActivityId"] = self.scalingActivityId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ScalingActivityId") {
            self.scalingActivityId = dict["ScalingActivityId"] as! String
        }
    }
}

public class DescribeScalingActivityDetailResponseBody : Tea.TeaModel {
    public var detail: String?

    public var requestId: String?

    public var scalingActivityId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.detail != nil {
            map["Detail"] = self.detail!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingActivityId != nil {
            map["ScalingActivityId"] = self.scalingActivityId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Detail") {
            self.detail = dict["Detail"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScalingActivityId") {
            self.scalingActivityId = dict["ScalingActivityId"] as! String
        }
    }
}

public class DescribeScalingActivityDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeScalingActivityDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeScalingActivityDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeScalingConfigurationsRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var scalingConfigurationIds: [String]?

    public var scalingConfigurationNames: [String]?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.scalingConfigurationIds != nil {
            map["ScalingConfigurationIds"] = self.scalingConfigurationIds!
        }
        if self.scalingConfigurationNames != nil {
            map["ScalingConfigurationNames"] = self.scalingConfigurationNames!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ScalingConfigurationIds") {
            self.scalingConfigurationIds = dict["ScalingConfigurationIds"] as! [String]
        }
        if dict.keys.contains("ScalingConfigurationNames") {
            self.scalingConfigurationNames = dict["ScalingConfigurationNames"] as! [String]
        }
        if dict.keys.contains("ScalingGroupId") {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
    }
}

public class DescribeScalingConfigurationsResponseBody : Tea.TeaModel {
    public class ScalingConfigurations : Tea.TeaModel {
        public class CustomPriorities : Tea.TeaModel {
            public var instanceType: String?

            public var vswitchId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.instanceType != nil {
                    map["InstanceType"] = self.instanceType!
                }
                if self.vswitchId != nil {
                    map["VswitchId"] = self.vswitchId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("InstanceType") {
                    self.instanceType = dict["InstanceType"] as! String
                }
                if dict.keys.contains("VswitchId") {
                    self.vswitchId = dict["VswitchId"] as! String
                }
            }
        }
        public class DataDisks : Tea.TeaModel {
            public var autoSnapshotPolicyId: String?

            public var burstingEnabled: Bool?

            public var categories: [String]?

            public var category: String?

            public var deleteWithInstance: Bool?

            public var description_: String?

            public var device: String?

            public var diskName: String?

            public var encrypted: String?

            public var KMSKeyId: String?

            public var performanceLevel: String?

            public var provisionedIops: Int64?

            public var size: Int32?

            public var snapshotId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.autoSnapshotPolicyId != nil {
                    map["AutoSnapshotPolicyId"] = self.autoSnapshotPolicyId!
                }
                if self.burstingEnabled != nil {
                    map["BurstingEnabled"] = self.burstingEnabled!
                }
                if self.categories != nil {
                    map["Categories"] = self.categories!
                }
                if self.category != nil {
                    map["Category"] = self.category!
                }
                if self.deleteWithInstance != nil {
                    map["DeleteWithInstance"] = self.deleteWithInstance!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.device != nil {
                    map["Device"] = self.device!
                }
                if self.diskName != nil {
                    map["DiskName"] = self.diskName!
                }
                if self.encrypted != nil {
                    map["Encrypted"] = self.encrypted!
                }
                if self.KMSKeyId != nil {
                    map["KMSKeyId"] = self.KMSKeyId!
                }
                if self.performanceLevel != nil {
                    map["PerformanceLevel"] = self.performanceLevel!
                }
                if self.provisionedIops != nil {
                    map["ProvisionedIops"] = self.provisionedIops!
                }
                if self.size != nil {
                    map["Size"] = self.size!
                }
                if self.snapshotId != nil {
                    map["SnapshotId"] = self.snapshotId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AutoSnapshotPolicyId") {
                    self.autoSnapshotPolicyId = dict["AutoSnapshotPolicyId"] as! String
                }
                if dict.keys.contains("BurstingEnabled") {
                    self.burstingEnabled = dict["BurstingEnabled"] as! Bool
                }
                if dict.keys.contains("Categories") {
                    self.categories = dict["Categories"] as! [String]
                }
                if dict.keys.contains("Category") {
                    self.category = dict["Category"] as! String
                }
                if dict.keys.contains("DeleteWithInstance") {
                    self.deleteWithInstance = dict["DeleteWithInstance"] as! Bool
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Device") {
                    self.device = dict["Device"] as! String
                }
                if dict.keys.contains("DiskName") {
                    self.diskName = dict["DiskName"] as! String
                }
                if dict.keys.contains("Encrypted") {
                    self.encrypted = dict["Encrypted"] as! String
                }
                if dict.keys.contains("KMSKeyId") {
                    self.KMSKeyId = dict["KMSKeyId"] as! String
                }
                if dict.keys.contains("PerformanceLevel") {
                    self.performanceLevel = dict["PerformanceLevel"] as! String
                }
                if dict.keys.contains("ProvisionedIops") {
                    self.provisionedIops = dict["ProvisionedIops"] as! Int64
                }
                if dict.keys.contains("Size") {
                    self.size = dict["Size"] as! Int32
                }
                if dict.keys.contains("SnapshotId") {
                    self.snapshotId = dict["SnapshotId"] as! String
                }
            }
        }
        public class InstancePatternInfos : Tea.TeaModel {
            public var architectures: [String]?

            public var burstablePerformance: String?

            public var cores: Int32?

            public var cpuArchitectures: [String]?

            public var excludedInstanceTypes: [String]?

            public var gpuSpecs: [String]?

            public var instanceCategories: [String]?

            public var instanceFamilyLevel: String?

            public var instanceTypeFamilies: [String]?

            public var maxPrice: Double?

            public var maximumCpuCoreCount: Int32?

            public var maximumGpuAmount: Int32?

            public var maximumMemorySize: Double?

            public var memory: Double?

            public var minimumBaselineCredit: Int32?

            public var minimumCpuCoreCount: Int32?

            public var minimumEniIpv6AddressQuantity: Int32?

            public var minimumEniPrivateIpAddressQuantity: Int32?

            public var minimumEniQuantity: Int32?

            public var minimumGpuAmount: Int32?

            public var minimumInitialCredit: Int32?

            public var minimumMemorySize: Double?

            public var physicalProcessorModels: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.architectures != nil {
                    map["Architectures"] = self.architectures!
                }
                if self.burstablePerformance != nil {
                    map["BurstablePerformance"] = self.burstablePerformance!
                }
                if self.cores != nil {
                    map["Cores"] = self.cores!
                }
                if self.cpuArchitectures != nil {
                    map["CpuArchitectures"] = self.cpuArchitectures!
                }
                if self.excludedInstanceTypes != nil {
                    map["ExcludedInstanceTypes"] = self.excludedInstanceTypes!
                }
                if self.gpuSpecs != nil {
                    map["GpuSpecs"] = self.gpuSpecs!
                }
                if self.instanceCategories != nil {
                    map["InstanceCategories"] = self.instanceCategories!
                }
                if self.instanceFamilyLevel != nil {
                    map["InstanceFamilyLevel"] = self.instanceFamilyLevel!
                }
                if self.instanceTypeFamilies != nil {
                    map["InstanceTypeFamilies"] = self.instanceTypeFamilies!
                }
                if self.maxPrice != nil {
                    map["MaxPrice"] = self.maxPrice!
                }
                if self.maximumCpuCoreCount != nil {
                    map["MaximumCpuCoreCount"] = self.maximumCpuCoreCount!
                }
                if self.maximumGpuAmount != nil {
                    map["MaximumGpuAmount"] = self.maximumGpuAmount!
                }
                if self.maximumMemorySize != nil {
                    map["MaximumMemorySize"] = self.maximumMemorySize!
                }
                if self.memory != nil {
                    map["Memory"] = self.memory!
                }
                if self.minimumBaselineCredit != nil {
                    map["MinimumBaselineCredit"] = self.minimumBaselineCredit!
                }
                if self.minimumCpuCoreCount != nil {
                    map["MinimumCpuCoreCount"] = self.minimumCpuCoreCount!
                }
                if self.minimumEniIpv6AddressQuantity != nil {
                    map["MinimumEniIpv6AddressQuantity"] = self.minimumEniIpv6AddressQuantity!
                }
                if self.minimumEniPrivateIpAddressQuantity != nil {
                    map["MinimumEniPrivateIpAddressQuantity"] = self.minimumEniPrivateIpAddressQuantity!
                }
                if self.minimumEniQuantity != nil {
                    map["MinimumEniQuantity"] = self.minimumEniQuantity!
                }
                if self.minimumGpuAmount != nil {
                    map["MinimumGpuAmount"] = self.minimumGpuAmount!
                }
                if self.minimumInitialCredit != nil {
                    map["MinimumInitialCredit"] = self.minimumInitialCredit!
                }
                if self.minimumMemorySize != nil {
                    map["MinimumMemorySize"] = self.minimumMemorySize!
                }
                if self.physicalProcessorModels != nil {
                    map["PhysicalProcessorModels"] = self.physicalProcessorModels!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Architectures") {
                    self.architectures = dict["Architectures"] as! [String]
                }
                if dict.keys.contains("BurstablePerformance") {
                    self.burstablePerformance = dict["BurstablePerformance"] as! String
                }
                if dict.keys.contains("Cores") {
                    self.cores = dict["Cores"] as! Int32
                }
                if dict.keys.contains("CpuArchitectures") {
                    self.cpuArchitectures = dict["CpuArchitectures"] as! [String]
                }
                if dict.keys.contains("ExcludedInstanceTypes") {
                    self.excludedInstanceTypes = dict["ExcludedInstanceTypes"] as! [String]
                }
                if dict.keys.contains("GpuSpecs") {
                    self.gpuSpecs = dict["GpuSpecs"] as! [String]
                }
                if dict.keys.contains("InstanceCategories") {
                    self.instanceCategories = dict["InstanceCategories"] as! [String]
                }
                if dict.keys.contains("InstanceFamilyLevel") {
                    self.instanceFamilyLevel = dict["InstanceFamilyLevel"] as! String
                }
                if dict.keys.contains("InstanceTypeFamilies") {
                    self.instanceTypeFamilies = dict["InstanceTypeFamilies"] as! [String]
                }
                if dict.keys.contains("MaxPrice") {
                    self.maxPrice = dict["MaxPrice"] as! Double
                }
                if dict.keys.contains("MaximumCpuCoreCount") {
                    self.maximumCpuCoreCount = dict["MaximumCpuCoreCount"] as! Int32
                }
                if dict.keys.contains("MaximumGpuAmount") {
                    self.maximumGpuAmount = dict["MaximumGpuAmount"] as! Int32
                }
                if dict.keys.contains("MaximumMemorySize") {
                    self.maximumMemorySize = dict["MaximumMemorySize"] as! Double
                }
                if dict.keys.contains("Memory") {
                    self.memory = dict["Memory"] as! Double
                }
                if dict.keys.contains("MinimumBaselineCredit") {
                    self.minimumBaselineCredit = dict["MinimumBaselineCredit"] as! Int32
                }
                if dict.keys.contains("MinimumCpuCoreCount") {
                    self.minimumCpuCoreCount = dict["MinimumCpuCoreCount"] as! Int32
                }
                if dict.keys.contains("MinimumEniIpv6AddressQuantity") {
                    self.minimumEniIpv6AddressQuantity = dict["MinimumEniIpv6AddressQuantity"] as! Int32
                }
                if dict.keys.contains("MinimumEniPrivateIpAddressQuantity") {
                    self.minimumEniPrivateIpAddressQuantity = dict["MinimumEniPrivateIpAddressQuantity"] as! Int32
                }
                if dict.keys.contains("MinimumEniQuantity") {
                    self.minimumEniQuantity = dict["MinimumEniQuantity"] as! Int32
                }
                if dict.keys.contains("MinimumGpuAmount") {
                    self.minimumGpuAmount = dict["MinimumGpuAmount"] as! Int32
                }
                if dict.keys.contains("MinimumInitialCredit") {
                    self.minimumInitialCredit = dict["MinimumInitialCredit"] as! Int32
                }
                if dict.keys.contains("MinimumMemorySize") {
                    self.minimumMemorySize = dict["MinimumMemorySize"] as! Double
                }
                if dict.keys.contains("PhysicalProcessorModels") {
                    self.physicalProcessorModels = dict["PhysicalProcessorModels"] as! [String]
                }
            }
        }
        public class NetworkInterfaces : Tea.TeaModel {
            public var instanceType: String?

            public var ipv6AddressCount: Int32?

            public var networkInterfaceTrafficMode: String?

            public var securityGroupIds: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.instanceType != nil {
                    map["InstanceType"] = self.instanceType!
                }
                if self.ipv6AddressCount != nil {
                    map["Ipv6AddressCount"] = self.ipv6AddressCount!
                }
                if self.networkInterfaceTrafficMode != nil {
                    map["NetworkInterfaceTrafficMode"] = self.networkInterfaceTrafficMode!
                }
                if self.securityGroupIds != nil {
                    map["SecurityGroupIds"] = self.securityGroupIds!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("InstanceType") {
                    self.instanceType = dict["InstanceType"] as! String
                }
                if dict.keys.contains("Ipv6AddressCount") {
                    self.ipv6AddressCount = dict["Ipv6AddressCount"] as! Int32
                }
                if dict.keys.contains("NetworkInterfaceTrafficMode") {
                    self.networkInterfaceTrafficMode = dict["NetworkInterfaceTrafficMode"] as! String
                }
                if dict.keys.contains("SecurityGroupIds") {
                    self.securityGroupIds = dict["SecurityGroupIds"] as! [String]
                }
            }
        }
        public class SchedulerOptions : Tea.TeaModel {
            public var managedPrivateSpaceId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.managedPrivateSpaceId != nil {
                    map["ManagedPrivateSpaceId"] = self.managedPrivateSpaceId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ManagedPrivateSpaceId") {
                    self.managedPrivateSpaceId = dict["ManagedPrivateSpaceId"] as! String
                }
            }
        }
        public class SecurityOptions : Tea.TeaModel {
            public var confidentialComputingMode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.confidentialComputingMode != nil {
                    map["ConfidentialComputingMode"] = self.confidentialComputingMode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ConfidentialComputingMode") {
                    self.confidentialComputingMode = dict["ConfidentialComputingMode"] as! String
                }
            }
        }
        public class SpotPriceLimits : Tea.TeaModel {
            public var instanceType: String?

            public var priceLimit: Double?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.instanceType != nil {
                    map["InstanceType"] = self.instanceType!
                }
                if self.priceLimit != nil {
                    map["PriceLimit"] = self.priceLimit!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("InstanceType") {
                    self.instanceType = dict["InstanceType"] as! String
                }
                if dict.keys.contains("PriceLimit") {
                    self.priceLimit = dict["PriceLimit"] as! Double
                }
            }
        }
        public class Tags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var affinity: String?

        public var cpu: Int32?

        public var creationTime: String?

        public var creditSpecification: String?

        public var customPriorities: [DescribeScalingConfigurationsResponseBody.ScalingConfigurations.CustomPriorities]?

        public var dataDisks: [DescribeScalingConfigurationsResponseBody.ScalingConfigurations.DataDisks]?

        public var dedicatedHostClusterId: String?

        public var dedicatedHostId: String?

        public var deletionProtection: Bool?

        public var deploymentSetId: String?

        public var hostName: String?

        public var hpcClusterId: String?

        public var httpEndpoint: String?

        public var httpTokens: String?

        public var imageFamily: String?

        public var imageId: String?

        public var imageName: String?

        public var imageOptionsLoginAsNonRoot: Bool?

        public var imageOwnerAlias: String?

        public var instanceDescription: String?

        public var instanceGeneration: String?

        public var instanceName: String?

        public var instancePatternInfos: [DescribeScalingConfigurationsResponseBody.ScalingConfigurations.InstancePatternInfos]?

        public var instanceType: String?

        public var instanceTypes: [String]?

        public var internetChargeType: String?

        public var internetMaxBandwidthIn: Int32?

        public var internetMaxBandwidthOut: Int32?

        public var ioOptimized: String?

        public var ipv6AddressCount: Int32?

        public var keyPairName: String?

        public var lifecycleState: String?

        public var loadBalancerWeight: Int32?

        public var memory: Int32?

        public var networkInterfaces: [DescribeScalingConfigurationsResponseBody.ScalingConfigurations.NetworkInterfaces]?

        public var passwordInherit: Bool?

        public var passwordSetted: Bool?

        public var privatePoolOptions_id: String?

        public var privatePoolOptions_matchCriteria: String?

        public var ramRoleName: String?

        public var resourceGroupId: String?

        public var scalingConfigurationId: String?

        public var scalingConfigurationName: String?

        public var scalingGroupId: String?

        public var schedulerOptions: DescribeScalingConfigurationsResponseBody.ScalingConfigurations.SchedulerOptions?

        public var securityEnhancementStrategy: String?

        public var securityGroupId: String?

        public var securityGroupIds: [String]?

        public var securityOptions: DescribeScalingConfigurationsResponseBody.ScalingConfigurations.SecurityOptions?

        public var spotDuration: Int32?

        public var spotInterruptionBehavior: String?

        public var spotPriceLimits: [DescribeScalingConfigurationsResponseBody.ScalingConfigurations.SpotPriceLimits]?

        public var spotStrategy: String?

        public var storageSetId: String?

        public var storageSetPartitionNumber: Int32?

        public var systemDiskAutoSnapshotPolicyId: String?

        public var systemDiskBurstingEnabled: Bool?

        public var systemDiskCategories: [String]?

        public var systemDiskCategory: String?

        public var systemDiskDescription: String?

        public var systemDiskEncryptAlgorithm: String?

        public var systemDiskEncrypted: Bool?

        public var systemDiskKMSKeyId: String?

        public var systemDiskName: String?

        public var systemDiskPerformanceLevel: String?

        public var systemDiskProvisionedIops: Int64?

        public var systemDiskSize: Int32?

        public var tags: [DescribeScalingConfigurationsResponseBody.ScalingConfigurations.Tags]?

        public var tenancy: String?

        public var userData: String?

        public var weightedCapacities: [Int32]?

        public var zoneId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.schedulerOptions?.validate()
            try self.securityOptions?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.affinity != nil {
                map["Affinity"] = self.affinity!
            }
            if self.cpu != nil {
                map["Cpu"] = self.cpu!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.creditSpecification != nil {
                map["CreditSpecification"] = self.creditSpecification!
            }
            if self.customPriorities != nil {
                var tmp : [Any] = []
                for k in self.customPriorities! {
                    tmp.append(k.toMap())
                }
                map["CustomPriorities"] = tmp
            }
            if self.dataDisks != nil {
                var tmp : [Any] = []
                for k in self.dataDisks! {
                    tmp.append(k.toMap())
                }
                map["DataDisks"] = tmp
            }
            if self.dedicatedHostClusterId != nil {
                map["DedicatedHostClusterId"] = self.dedicatedHostClusterId!
            }
            if self.dedicatedHostId != nil {
                map["DedicatedHostId"] = self.dedicatedHostId!
            }
            if self.deletionProtection != nil {
                map["DeletionProtection"] = self.deletionProtection!
            }
            if self.deploymentSetId != nil {
                map["DeploymentSetId"] = self.deploymentSetId!
            }
            if self.hostName != nil {
                map["HostName"] = self.hostName!
            }
            if self.hpcClusterId != nil {
                map["HpcClusterId"] = self.hpcClusterId!
            }
            if self.httpEndpoint != nil {
                map["HttpEndpoint"] = self.httpEndpoint!
            }
            if self.httpTokens != nil {
                map["HttpTokens"] = self.httpTokens!
            }
            if self.imageFamily != nil {
                map["ImageFamily"] = self.imageFamily!
            }
            if self.imageId != nil {
                map["ImageId"] = self.imageId!
            }
            if self.imageName != nil {
                map["ImageName"] = self.imageName!
            }
            if self.imageOptionsLoginAsNonRoot != nil {
                map["ImageOptionsLoginAsNonRoot"] = self.imageOptionsLoginAsNonRoot!
            }
            if self.imageOwnerAlias != nil {
                map["ImageOwnerAlias"] = self.imageOwnerAlias!
            }
            if self.instanceDescription != nil {
                map["InstanceDescription"] = self.instanceDescription!
            }
            if self.instanceGeneration != nil {
                map["InstanceGeneration"] = self.instanceGeneration!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.instancePatternInfos != nil {
                var tmp : [Any] = []
                for k in self.instancePatternInfos! {
                    tmp.append(k.toMap())
                }
                map["InstancePatternInfos"] = tmp
            }
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.instanceTypes != nil {
                map["InstanceTypes"] = self.instanceTypes!
            }
            if self.internetChargeType != nil {
                map["InternetChargeType"] = self.internetChargeType!
            }
            if self.internetMaxBandwidthIn != nil {
                map["InternetMaxBandwidthIn"] = self.internetMaxBandwidthIn!
            }
            if self.internetMaxBandwidthOut != nil {
                map["InternetMaxBandwidthOut"] = self.internetMaxBandwidthOut!
            }
            if self.ioOptimized != nil {
                map["IoOptimized"] = self.ioOptimized!
            }
            if self.ipv6AddressCount != nil {
                map["Ipv6AddressCount"] = self.ipv6AddressCount!
            }
            if self.keyPairName != nil {
                map["KeyPairName"] = self.keyPairName!
            }
            if self.lifecycleState != nil {
                map["LifecycleState"] = self.lifecycleState!
            }
            if self.loadBalancerWeight != nil {
                map["LoadBalancerWeight"] = self.loadBalancerWeight!
            }
            if self.memory != nil {
                map["Memory"] = self.memory!
            }
            if self.networkInterfaces != nil {
                var tmp : [Any] = []
                for k in self.networkInterfaces! {
                    tmp.append(k.toMap())
                }
                map["NetworkInterfaces"] = tmp
            }
            if self.passwordInherit != nil {
                map["PasswordInherit"] = self.passwordInherit!
            }
            if self.passwordSetted != nil {
                map["PasswordSetted"] = self.passwordSetted!
            }
            if self.privatePoolOptions_id != nil {
                map["PrivatePoolOptions.Id"] = self.privatePoolOptions_id!
            }
            if self.privatePoolOptions_matchCriteria != nil {
                map["PrivatePoolOptions.MatchCriteria"] = self.privatePoolOptions_matchCriteria!
            }
            if self.ramRoleName != nil {
                map["RamRoleName"] = self.ramRoleName!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.scalingConfigurationId != nil {
                map["ScalingConfigurationId"] = self.scalingConfigurationId!
            }
            if self.scalingConfigurationName != nil {
                map["ScalingConfigurationName"] = self.scalingConfigurationName!
            }
            if self.scalingGroupId != nil {
                map["ScalingGroupId"] = self.scalingGroupId!
            }
            if self.schedulerOptions != nil {
                map["SchedulerOptions"] = self.schedulerOptions?.toMap()
            }
            if self.securityEnhancementStrategy != nil {
                map["SecurityEnhancementStrategy"] = self.securityEnhancementStrategy!
            }
            if self.securityGroupId != nil {
                map["SecurityGroupId"] = self.securityGroupId!
            }
            if self.securityGroupIds != nil {
                map["SecurityGroupIds"] = self.securityGroupIds!
            }
            if self.securityOptions != nil {
                map["SecurityOptions"] = self.securityOptions?.toMap()
            }
            if self.spotDuration != nil {
                map["SpotDuration"] = self.spotDuration!
            }
            if self.spotInterruptionBehavior != nil {
                map["SpotInterruptionBehavior"] = self.spotInterruptionBehavior!
            }
            if self.spotPriceLimits != nil {
                var tmp : [Any] = []
                for k in self.spotPriceLimits! {
                    tmp.append(k.toMap())
                }
                map["SpotPriceLimits"] = tmp
            }
            if self.spotStrategy != nil {
                map["SpotStrategy"] = self.spotStrategy!
            }
            if self.storageSetId != nil {
                map["StorageSetId"] = self.storageSetId!
            }
            if self.storageSetPartitionNumber != nil {
                map["StorageSetPartitionNumber"] = self.storageSetPartitionNumber!
            }
            if self.systemDiskAutoSnapshotPolicyId != nil {
                map["SystemDiskAutoSnapshotPolicyId"] = self.systemDiskAutoSnapshotPolicyId!
            }
            if self.systemDiskBurstingEnabled != nil {
                map["SystemDiskBurstingEnabled"] = self.systemDiskBurstingEnabled!
            }
            if self.systemDiskCategories != nil {
                map["SystemDiskCategories"] = self.systemDiskCategories!
            }
            if self.systemDiskCategory != nil {
                map["SystemDiskCategory"] = self.systemDiskCategory!
            }
            if self.systemDiskDescription != nil {
                map["SystemDiskDescription"] = self.systemDiskDescription!
            }
            if self.systemDiskEncryptAlgorithm != nil {
                map["SystemDiskEncryptAlgorithm"] = self.systemDiskEncryptAlgorithm!
            }
            if self.systemDiskEncrypted != nil {
                map["SystemDiskEncrypted"] = self.systemDiskEncrypted!
            }
            if self.systemDiskKMSKeyId != nil {
                map["SystemDiskKMSKeyId"] = self.systemDiskKMSKeyId!
            }
            if self.systemDiskName != nil {
                map["SystemDiskName"] = self.systemDiskName!
            }
            if self.systemDiskPerformanceLevel != nil {
                map["SystemDiskPerformanceLevel"] = self.systemDiskPerformanceLevel!
            }
            if self.systemDiskProvisionedIops != nil {
                map["SystemDiskProvisionedIops"] = self.systemDiskProvisionedIops!
            }
            if self.systemDiskSize != nil {
                map["SystemDiskSize"] = self.systemDiskSize!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            if self.tenancy != nil {
                map["Tenancy"] = self.tenancy!
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            if self.weightedCapacities != nil {
                map["WeightedCapacities"] = self.weightedCapacities!
            }
            if self.zoneId != nil {
                map["ZoneId"] = self.zoneId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Affinity") {
                self.affinity = dict["Affinity"] as! String
            }
            if dict.keys.contains("Cpu") {
                self.cpu = dict["Cpu"] as! Int32
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("CreditSpecification") {
                self.creditSpecification = dict["CreditSpecification"] as! String
            }
            if dict.keys.contains("CustomPriorities") {
                var tmp : [DescribeScalingConfigurationsResponseBody.ScalingConfigurations.CustomPriorities] = []
                for v in dict["CustomPriorities"] as! [Any] {
                    var model = DescribeScalingConfigurationsResponseBody.ScalingConfigurations.CustomPriorities()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.customPriorities = tmp
            }
            if dict.keys.contains("DataDisks") {
                var tmp : [DescribeScalingConfigurationsResponseBody.ScalingConfigurations.DataDisks] = []
                for v in dict["DataDisks"] as! [Any] {
                    var model = DescribeScalingConfigurationsResponseBody.ScalingConfigurations.DataDisks()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.dataDisks = tmp
            }
            if dict.keys.contains("DedicatedHostClusterId") {
                self.dedicatedHostClusterId = dict["DedicatedHostClusterId"] as! String
            }
            if dict.keys.contains("DedicatedHostId") {
                self.dedicatedHostId = dict["DedicatedHostId"] as! String
            }
            if dict.keys.contains("DeletionProtection") {
                self.deletionProtection = dict["DeletionProtection"] as! Bool
            }
            if dict.keys.contains("DeploymentSetId") {
                self.deploymentSetId = dict["DeploymentSetId"] as! String
            }
            if dict.keys.contains("HostName") {
                self.hostName = dict["HostName"] as! String
            }
            if dict.keys.contains("HpcClusterId") {
                self.hpcClusterId = dict["HpcClusterId"] as! String
            }
            if dict.keys.contains("HttpEndpoint") {
                self.httpEndpoint = dict["HttpEndpoint"] as! String
            }
            if dict.keys.contains("HttpTokens") {
                self.httpTokens = dict["HttpTokens"] as! String
            }
            if dict.keys.contains("ImageFamily") {
                self.imageFamily = dict["ImageFamily"] as! String
            }
            if dict.keys.contains("ImageId") {
                self.imageId = dict["ImageId"] as! String
            }
            if dict.keys.contains("ImageName") {
                self.imageName = dict["ImageName"] as! String
            }
            if dict.keys.contains("ImageOptionsLoginAsNonRoot") {
                self.imageOptionsLoginAsNonRoot = dict["ImageOptionsLoginAsNonRoot"] as! Bool
            }
            if dict.keys.contains("ImageOwnerAlias") {
                self.imageOwnerAlias = dict["ImageOwnerAlias"] as! String
            }
            if dict.keys.contains("InstanceDescription") {
                self.instanceDescription = dict["InstanceDescription"] as! String
            }
            if dict.keys.contains("InstanceGeneration") {
                self.instanceGeneration = dict["InstanceGeneration"] as! String
            }
            if dict.keys.contains("InstanceName") {
                self.instanceName = dict["InstanceName"] as! String
            }
            if dict.keys.contains("InstancePatternInfos") {
                var tmp : [DescribeScalingConfigurationsResponseBody.ScalingConfigurations.InstancePatternInfos] = []
                for v in dict["InstancePatternInfos"] as! [Any] {
                    var model = DescribeScalingConfigurationsResponseBody.ScalingConfigurations.InstancePatternInfos()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.instancePatternInfos = tmp
            }
            if dict.keys.contains("InstanceType") {
                self.instanceType = dict["InstanceType"] as! String
            }
            if dict.keys.contains("InstanceTypes") {
                self.instanceTypes = dict["InstanceTypes"] as! [String]
            }
            if dict.keys.contains("InternetChargeType") {
                self.internetChargeType = dict["InternetChargeType"] as! String
            }
            if dict.keys.contains("InternetMaxBandwidthIn") {
                self.internetMaxBandwidthIn = dict["InternetMaxBandwidthIn"] as! Int32
            }
            if dict.keys.contains("InternetMaxBandwidthOut") {
                self.internetMaxBandwidthOut = dict["InternetMaxBandwidthOut"] as! Int32
            }
            if dict.keys.contains("IoOptimized") {
                self.ioOptimized = dict["IoOptimized"] as! String
            }
            if dict.keys.contains("Ipv6AddressCount") {
                self.ipv6AddressCount = dict["Ipv6AddressCount"] as! Int32
            }
            if dict.keys.contains("KeyPairName") {
                self.keyPairName = dict["KeyPairName"] as! String
            }
            if dict.keys.contains("LifecycleState") {
                self.lifecycleState = dict["LifecycleState"] as! String
            }
            if dict.keys.contains("LoadBalancerWeight") {
                self.loadBalancerWeight = dict["LoadBalancerWeight"] as! Int32
            }
            if dict.keys.contains("Memory") {
                self.memory = dict["Memory"] as! Int32
            }
            if dict.keys.contains("NetworkInterfaces") {
                var tmp : [DescribeScalingConfigurationsResponseBody.ScalingConfigurations.NetworkInterfaces] = []
                for v in dict["NetworkInterfaces"] as! [Any] {
                    var model = DescribeScalingConfigurationsResponseBody.ScalingConfigurations.NetworkInterfaces()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.networkInterfaces = tmp
            }
            if dict.keys.contains("PasswordInherit") {
                self.passwordInherit = dict["PasswordInherit"] as! Bool
            }
            if dict.keys.contains("PasswordSetted") {
                self.passwordSetted = dict["PasswordSetted"] as! Bool
            }
            if dict.keys.contains("PrivatePoolOptions.Id") {
                self.privatePoolOptions_id = dict["PrivatePoolOptions.Id"] as! String
            }
            if dict.keys.contains("PrivatePoolOptions.MatchCriteria") {
                self.privatePoolOptions_matchCriteria = dict["PrivatePoolOptions.MatchCriteria"] as! String
            }
            if dict.keys.contains("RamRoleName") {
                self.ramRoleName = dict["RamRoleName"] as! String
            }
            if dict.keys.contains("ResourceGroupId") {
                self.resourceGroupId = dict["ResourceGroupId"] as! String
            }
            if dict.keys.contains("ScalingConfigurationId") {
                self.scalingConfigurationId = dict["ScalingConfigurationId"] as! String
            }
            if dict.keys.contains("ScalingConfigurationName") {
                self.scalingConfigurationName = dict["ScalingConfigurationName"] as! String
            }
            if dict.keys.contains("ScalingGroupId") {
                self.scalingGroupId = dict["ScalingGroupId"] as! String
            }
            if dict.keys.contains("SchedulerOptions") {
                var model = DescribeScalingConfigurationsResponseBody.ScalingConfigurations.SchedulerOptions()
                model.fromMap(dict["SchedulerOptions"] as! [String: Any])
                self.schedulerOptions = model
            }
            if dict.keys.contains("SecurityEnhancementStrategy") {
                self.securityEnhancementStrategy = dict["SecurityEnhancementStrategy"] as! String
            }
            if dict.keys.contains("SecurityGroupId") {
                self.securityGroupId = dict["SecurityGroupId"] as! String
            }
            if dict.keys.contains("SecurityGroupIds") {
                self.securityGroupIds = dict["SecurityGroupIds"] as! [String]
            }
            if dict.keys.contains("SecurityOptions") {
                var model = DescribeScalingConfigurationsResponseBody.ScalingConfigurations.SecurityOptions()
                model.fromMap(dict["SecurityOptions"] as! [String: Any])
                self.securityOptions = model
            }
            if dict.keys.contains("SpotDuration") {
                self.spotDuration = dict["SpotDuration"] as! Int32
            }
            if dict.keys.contains("SpotInterruptionBehavior") {
                self.spotInterruptionBehavior = dict["SpotInterruptionBehavior"] as! String
            }
            if dict.keys.contains("SpotPriceLimits") {
                var tmp : [DescribeScalingConfigurationsResponseBody.ScalingConfigurations.SpotPriceLimits] = []
                for v in dict["SpotPriceLimits"] as! [Any] {
                    var model = DescribeScalingConfigurationsResponseBody.ScalingConfigurations.SpotPriceLimits()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.spotPriceLimits = tmp
            }
            if dict.keys.contains("SpotStrategy") {
                self.spotStrategy = dict["SpotStrategy"] as! String
            }
            if dict.keys.contains("StorageSetId") {
                self.storageSetId = dict["StorageSetId"] as! String
            }
            if dict.keys.contains("StorageSetPartitionNumber") {
                self.storageSetPartitionNumber = dict["StorageSetPartitionNumber"] as! Int32
            }
            if dict.keys.contains("SystemDiskAutoSnapshotPolicyId") {
                self.systemDiskAutoSnapshotPolicyId = dict["SystemDiskAutoSnapshotPolicyId"] as! String
            }
            if dict.keys.contains("SystemDiskBurstingEnabled") {
                self.systemDiskBurstingEnabled = dict["SystemDiskBurstingEnabled"] as! Bool
            }
            if dict.keys.contains("SystemDiskCategories") {
                self.systemDiskCategories = dict["SystemDiskCategories"] as! [String]
            }
            if dict.keys.contains("SystemDiskCategory") {
                self.systemDiskCategory = dict["SystemDiskCategory"] as! String
            }
            if dict.keys.contains("SystemDiskDescription") {
                self.systemDiskDescription = dict["SystemDiskDescription"] as! String
            }
            if dict.keys.contains("SystemDiskEncryptAlgorithm") {
                self.systemDiskEncryptAlgorithm = dict["SystemDiskEncryptAlgorithm"] as! String
            }
            if dict.keys.contains("SystemDiskEncrypted") {
                self.systemDiskEncrypted = dict["SystemDiskEncrypted"] as! Bool
            }
            if dict.keys.contains("SystemDiskKMSKeyId") {
                self.systemDiskKMSKeyId = dict["SystemDiskKMSKeyId"] as! String
            }
            if dict.keys.contains("SystemDiskName") {
                self.systemDiskName = dict["SystemDiskName"] as! String
            }
            if dict.keys.contains("SystemDiskPerformanceLevel") {
                self.systemDiskPerformanceLevel = dict["SystemDiskPerformanceLevel"] as! String
            }
            if dict.keys.contains("SystemDiskProvisionedIops") {
                self.systemDiskProvisionedIops = dict["SystemDiskProvisionedIops"] as! Int64
            }
            if dict.keys.contains("SystemDiskSize") {
                self.systemDiskSize = dict["SystemDiskSize"] as! Int32
            }
            if dict.keys.contains("Tags") {
                var tmp : [DescribeScalingConfigurationsResponseBody.ScalingConfigurations.Tags] = []
                for v in dict["Tags"] as! [Any] {
                    var model = DescribeScalingConfigurationsResponseBody.ScalingConfigurations.Tags()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tags = tmp
            }
            if dict.keys.contains("Tenancy") {
                self.tenancy = dict["Tenancy"] as! String
            }
            if dict.keys.contains("UserData") {
                self.userData = dict["UserData"] as! String
            }
            if dict.keys.contains("WeightedCapacities") {
                self.weightedCapacities = dict["WeightedCapacities"] as! [Int32]
            }
            if dict.keys.contains("ZoneId") {
                self.zoneId = dict["ZoneId"] as! String
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var scalingConfigurations: [DescribeScalingConfigurationsResponseBody.ScalingConfigurations]?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingConfigurations != nil {
            var tmp : [Any] = []
            for k in self.scalingConfigurations! {
                tmp.append(k.toMap())
            }
            map["ScalingConfigurations"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScalingConfigurations") {
            var tmp : [DescribeScalingConfigurationsResponseBody.ScalingConfigurations] = []
            for v in dict["ScalingConfigurations"] as! [Any] {
                var model = DescribeScalingConfigurationsResponseBody.ScalingConfigurations()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.scalingConfigurations = tmp
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeScalingConfigurationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeScalingConfigurationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeScalingConfigurationsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeScalingGroupDetailRequest : Tea.TeaModel {
    public var outputFormat: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.outputFormat != nil {
            map["OutputFormat"] = self.outputFormat!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OutputFormat") {
            self.outputFormat = dict["OutputFormat"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ScalingGroupId") {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
    }
}

public class DescribeScalingGroupDetailResponseBody : Tea.TeaModel {
    public class ScalingGroup : Tea.TeaModel {
        public class AlbServerGroups : Tea.TeaModel {
            public var albServerGroupId: String?

            public var port: Int32?

            public var weight: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.albServerGroupId != nil {
                    map["AlbServerGroupId"] = self.albServerGroupId!
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.weight != nil {
                    map["Weight"] = self.weight!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AlbServerGroupId") {
                    self.albServerGroupId = dict["AlbServerGroupId"] as! String
                }
                if dict.keys.contains("Port") {
                    self.port = dict["Port"] as! Int32
                }
                if dict.keys.contains("Weight") {
                    self.weight = dict["Weight"] as! Int32
                }
            }
        }
        public class LaunchTemplateOverrides : Tea.TeaModel {
            public var instanceType: String?

            public var spotPriceLimit: Double?

            public var weightedCapacity: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.instanceType != nil {
                    map["InstanceType"] = self.instanceType!
                }
                if self.spotPriceLimit != nil {
                    map["SpotPriceLimit"] = self.spotPriceLimit!
                }
                if self.weightedCapacity != nil {
                    map["WeightedCapacity"] = self.weightedCapacity!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("InstanceType") {
                    self.instanceType = dict["InstanceType"] as! String
                }
                if dict.keys.contains("SpotPriceLimit") {
                    self.spotPriceLimit = dict["SpotPriceLimit"] as! Double
                }
                if dict.keys.contains("WeightedCapacity") {
                    self.weightedCapacity = dict["WeightedCapacity"] as! Int32
                }
            }
        }
        public class LoadBalancerConfigs : Tea.TeaModel {
            public var loadBalancerId: String?

            public var weight: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.loadBalancerId != nil {
                    map["LoadBalancerId"] = self.loadBalancerId!
                }
                if self.weight != nil {
                    map["Weight"] = self.weight!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("LoadBalancerId") {
                    self.loadBalancerId = dict["LoadBalancerId"] as! String
                }
                if dict.keys.contains("Weight") {
                    self.weight = dict["Weight"] as! Int32
                }
            }
        }
        public class ServerGroups : Tea.TeaModel {
            public var port: Int32?

            public var serverGroupId: String?

            public var type: String?

            public var weight: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.serverGroupId != nil {
                    map["ServerGroupId"] = self.serverGroupId!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.weight != nil {
                    map["Weight"] = self.weight!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Port") {
                    self.port = dict["Port"] as! Int32
                }
                if dict.keys.contains("ServerGroupId") {
                    self.serverGroupId = dict["ServerGroupId"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Weight") {
                    self.weight = dict["Weight"] as! Int32
                }
            }
        }
        public class Tags : Tea.TeaModel {
            public var propagate: Bool?

            public var tagKey: String?

            public var tagValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.propagate != nil {
                    map["Propagate"] = self.propagate!
                }
                if self.tagKey != nil {
                    map["TagKey"] = self.tagKey!
                }
                if self.tagValue != nil {
                    map["TagValue"] = self.tagValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Propagate") {
                    self.propagate = dict["Propagate"] as! Bool
                }
                if dict.keys.contains("TagKey") {
                    self.tagKey = dict["TagKey"] as! String
                }
                if dict.keys.contains("TagValue") {
                    self.tagValue = dict["TagValue"] as! String
                }
            }
        }
        public class VServerGroups : Tea.TeaModel {
            public class VServerGroupAttributes : Tea.TeaModel {
                public var port: Int32?

                public var VServerGroupId: String?

                public var weight: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.port != nil {
                        map["Port"] = self.port!
                    }
                    if self.VServerGroupId != nil {
                        map["VServerGroupId"] = self.VServerGroupId!
                    }
                    if self.weight != nil {
                        map["Weight"] = self.weight!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Port") {
                        self.port = dict["Port"] as! Int32
                    }
                    if dict.keys.contains("VServerGroupId") {
                        self.VServerGroupId = dict["VServerGroupId"] as! String
                    }
                    if dict.keys.contains("Weight") {
                        self.weight = dict["Weight"] as! Int32
                    }
                }
            }
            public var loadBalancerId: String?

            public var VServerGroupAttributes: [DescribeScalingGroupDetailResponseBody.ScalingGroup.VServerGroups.VServerGroupAttributes]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.loadBalancerId != nil {
                    map["LoadBalancerId"] = self.loadBalancerId!
                }
                if self.VServerGroupAttributes != nil {
                    var tmp : [Any] = []
                    for k in self.VServerGroupAttributes! {
                        tmp.append(k.toMap())
                    }
                    map["VServerGroupAttributes"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("LoadBalancerId") {
                    self.loadBalancerId = dict["LoadBalancerId"] as! String
                }
                if dict.keys.contains("VServerGroupAttributes") {
                    var tmp : [DescribeScalingGroupDetailResponseBody.ScalingGroup.VServerGroups.VServerGroupAttributes] = []
                    for v in dict["VServerGroupAttributes"] as! [Any] {
                        var model = DescribeScalingGroupDetailResponseBody.ScalingGroup.VServerGroups.VServerGroupAttributes()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.VServerGroupAttributes = tmp
                }
            }
        }
        public var activeCapacity: Int32?

        public var activeScalingConfigurationId: String?

        public var albServerGroups: [DescribeScalingGroupDetailResponseBody.ScalingGroup.AlbServerGroups]?

        public var allocationStrategy: String?

        public var azBalance: Bool?

        public var compensateWithOnDemand: Bool?

        public var creationTime: String?

        public var currentHostName: String?

        public var customPolicyARN: String?

        public var DBInstanceIds: [String]?

        public var defaultCooldown: Int32?

        public var desiredCapacity: Int32?

        public var enableDesiredCapacity: Bool?

        public var groupDeletionProtection: Bool?

        public var groupType: String?

        public var healthCheckType: String?

        public var healthCheckTypes: [String]?

        public var initCapacity: Int32?

        public var isElasticStrengthInAlarm: Bool?

        public var launchTemplateId: String?

        public var launchTemplateOverrides: [DescribeScalingGroupDetailResponseBody.ScalingGroup.LaunchTemplateOverrides]?

        public var launchTemplateVersion: String?

        public var lifecycleState: String?

        public var loadBalancerConfigs: [DescribeScalingGroupDetailResponseBody.ScalingGroup.LoadBalancerConfigs]?

        public var loadBalancerIds: [String]?

        public var maxInstanceLifetime: Int32?

        public var maxSize: Int32?

        public var minSize: Int32?

        public var modificationTime: String?

        public var monitorGroupId: String?

        public var multiAZPolicy: String?

        public var onDemandBaseCapacity: Int32?

        public var onDemandPercentageAboveBaseCapacity: Int32?

        public var pendingCapacity: Int32?

        public var pendingWaitCapacity: Int32?

        public var protectedCapacity: Int32?

        public var regionId: String?

        public var removalPolicies: [String]?

        public var removingCapacity: Int32?

        public var removingWaitCapacity: Int32?

        public var resourceGroupId: String?

        public var scalingGroupId: String?

        public var scalingGroupName: String?

        public var scalingPolicy: String?

        public var serverGroups: [DescribeScalingGroupDetailResponseBody.ScalingGroup.ServerGroups]?

        public var spotAllocationStrategy: String?

        public var spotInstancePools: Int32?

        public var spotInstanceRemedy: Bool?

        public var standbyCapacity: Int32?

        public var stoppedCapacity: Int32?

        public var suspendedProcesses: [String]?

        public var systemSuspended: Bool?

        public var tags: [DescribeScalingGroupDetailResponseBody.ScalingGroup.Tags]?

        public var totalCapacity: Int32?

        public var totalInstanceCount: Int32?

        public var VServerGroups: [DescribeScalingGroupDetailResponseBody.ScalingGroup.VServerGroups]?

        public var vSwitchId: String?

        public var vSwitchIds: [String]?

        public var vpcId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.activeCapacity != nil {
                map["ActiveCapacity"] = self.activeCapacity!
            }
            if self.activeScalingConfigurationId != nil {
                map["ActiveScalingConfigurationId"] = self.activeScalingConfigurationId!
            }
            if self.albServerGroups != nil {
                var tmp : [Any] = []
                for k in self.albServerGroups! {
                    tmp.append(k.toMap())
                }
                map["AlbServerGroups"] = tmp
            }
            if self.allocationStrategy != nil {
                map["AllocationStrategy"] = self.allocationStrategy!
            }
            if self.azBalance != nil {
                map["AzBalance"] = self.azBalance!
            }
            if self.compensateWithOnDemand != nil {
                map["CompensateWithOnDemand"] = self.compensateWithOnDemand!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.currentHostName != nil {
                map["CurrentHostName"] = self.currentHostName!
            }
            if self.customPolicyARN != nil {
                map["CustomPolicyARN"] = self.customPolicyARN!
            }
            if self.DBInstanceIds != nil {
                map["DBInstanceIds"] = self.DBInstanceIds!
            }
            if self.defaultCooldown != nil {
                map["DefaultCooldown"] = self.defaultCooldown!
            }
            if self.desiredCapacity != nil {
                map["DesiredCapacity"] = self.desiredCapacity!
            }
            if self.enableDesiredCapacity != nil {
                map["EnableDesiredCapacity"] = self.enableDesiredCapacity!
            }
            if self.groupDeletionProtection != nil {
                map["GroupDeletionProtection"] = self.groupDeletionProtection!
            }
            if self.groupType != nil {
                map["GroupType"] = self.groupType!
            }
            if self.healthCheckType != nil {
                map["HealthCheckType"] = self.healthCheckType!
            }
            if self.healthCheckTypes != nil {
                map["HealthCheckTypes"] = self.healthCheckTypes!
            }
            if self.initCapacity != nil {
                map["InitCapacity"] = self.initCapacity!
            }
            if self.isElasticStrengthInAlarm != nil {
                map["IsElasticStrengthInAlarm"] = self.isElasticStrengthInAlarm!
            }
            if self.launchTemplateId != nil {
                map["LaunchTemplateId"] = self.launchTemplateId!
            }
            if self.launchTemplateOverrides != nil {
                var tmp : [Any] = []
                for k in self.launchTemplateOverrides! {
                    tmp.append(k.toMap())
                }
                map["LaunchTemplateOverrides"] = tmp
            }
            if self.launchTemplateVersion != nil {
                map["LaunchTemplateVersion"] = self.launchTemplateVersion!
            }
            if self.lifecycleState != nil {
                map["LifecycleState"] = self.lifecycleState!
            }
            if self.loadBalancerConfigs != nil {
                var tmp : [Any] = []
                for k in self.loadBalancerConfigs! {
                    tmp.append(k.toMap())
                }
                map["LoadBalancerConfigs"] = tmp
            }
            if self.loadBalancerIds != nil {
                map["LoadBalancerIds"] = self.loadBalancerIds!
            }
            if self.maxInstanceLifetime != nil {
                map["MaxInstanceLifetime"] = self.maxInstanceLifetime!
            }
            if self.maxSize != nil {
                map["MaxSize"] = self.maxSize!
            }
            if self.minSize != nil {
                map["MinSize"] = self.minSize!
            }
            if self.modificationTime != nil {
                map["ModificationTime"] = self.modificationTime!
            }
            if self.monitorGroupId != nil {
                map["MonitorGroupId"] = self.monitorGroupId!
            }
            if self.multiAZPolicy != nil {
                map["MultiAZPolicy"] = self.multiAZPolicy!
            }
            if self.onDemandBaseCapacity != nil {
                map["OnDemandBaseCapacity"] = self.onDemandBaseCapacity!
            }
            if self.onDemandPercentageAboveBaseCapacity != nil {
                map["OnDemandPercentageAboveBaseCapacity"] = self.onDemandPercentageAboveBaseCapacity!
            }
            if self.pendingCapacity != nil {
                map["PendingCapacity"] = self.pendingCapacity!
            }
            if self.pendingWaitCapacity != nil {
                map["PendingWaitCapacity"] = self.pendingWaitCapacity!
            }
            if self.protectedCapacity != nil {
                map["ProtectedCapacity"] = self.protectedCapacity!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.removalPolicies != nil {
                map["RemovalPolicies"] = self.removalPolicies!
            }
            if self.removingCapacity != nil {
                map["RemovingCapacity"] = self.removingCapacity!
            }
            if self.removingWaitCapacity != nil {
                map["RemovingWaitCapacity"] = self.removingWaitCapacity!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.scalingGroupId != nil {
                map["ScalingGroupId"] = self.scalingGroupId!
            }
            if self.scalingGroupName != nil {
                map["ScalingGroupName"] = self.scalingGroupName!
            }
            if self.scalingPolicy != nil {
                map["ScalingPolicy"] = self.scalingPolicy!
            }
            if self.serverGroups != nil {
                var tmp : [Any] = []
                for k in self.serverGroups! {
                    tmp.append(k.toMap())
                }
                map["ServerGroups"] = tmp
            }
            if self.spotAllocationStrategy != nil {
                map["SpotAllocationStrategy"] = self.spotAllocationStrategy!
            }
            if self.spotInstancePools != nil {
                map["SpotInstancePools"] = self.spotInstancePools!
            }
            if self.spotInstanceRemedy != nil {
                map["SpotInstanceRemedy"] = self.spotInstanceRemedy!
            }
            if self.standbyCapacity != nil {
                map["StandbyCapacity"] = self.standbyCapacity!
            }
            if self.stoppedCapacity != nil {
                map["StoppedCapacity"] = self.stoppedCapacity!
            }
            if self.suspendedProcesses != nil {
                map["SuspendedProcesses"] = self.suspendedProcesses!
            }
            if self.systemSuspended != nil {
                map["SystemSuspended"] = self.systemSuspended!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            if self.totalCapacity != nil {
                map["TotalCapacity"] = self.totalCapacity!
            }
            if self.totalInstanceCount != nil {
                map["TotalInstanceCount"] = self.totalInstanceCount!
            }
            if self.VServerGroups != nil {
                var tmp : [Any] = []
                for k in self.VServerGroups! {
                    tmp.append(k.toMap())
                }
                map["VServerGroups"] = tmp
            }
            if self.vSwitchId != nil {
                map["VSwitchId"] = self.vSwitchId!
            }
            if self.vSwitchIds != nil {
                map["VSwitchIds"] = self.vSwitchIds!
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ActiveCapacity") {
                self.activeCapacity = dict["ActiveCapacity"] as! Int32
            }
            if dict.keys.contains("ActiveScalingConfigurationId") {
                self.activeScalingConfigurationId = dict["ActiveScalingConfigurationId"] as! String
            }
            if dict.keys.contains("AlbServerGroups") {
                var tmp : [DescribeScalingGroupDetailResponseBody.ScalingGroup.AlbServerGroups] = []
                for v in dict["AlbServerGroups"] as! [Any] {
                    var model = DescribeScalingGroupDetailResponseBody.ScalingGroup.AlbServerGroups()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.albServerGroups = tmp
            }
            if dict.keys.contains("AllocationStrategy") {
                self.allocationStrategy = dict["AllocationStrategy"] as! String
            }
            if dict.keys.contains("AzBalance") {
                self.azBalance = dict["AzBalance"] as! Bool
            }
            if dict.keys.contains("CompensateWithOnDemand") {
                self.compensateWithOnDemand = dict["CompensateWithOnDemand"] as! Bool
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("CurrentHostName") {
                self.currentHostName = dict["CurrentHostName"] as! String
            }
            if dict.keys.contains("CustomPolicyARN") {
                self.customPolicyARN = dict["CustomPolicyARN"] as! String
            }
            if dict.keys.contains("DBInstanceIds") {
                self.DBInstanceIds = dict["DBInstanceIds"] as! [String]
            }
            if dict.keys.contains("DefaultCooldown") {
                self.defaultCooldown = dict["DefaultCooldown"] as! Int32
            }
            if dict.keys.contains("DesiredCapacity") {
                self.desiredCapacity = dict["DesiredCapacity"] as! Int32
            }
            if dict.keys.contains("EnableDesiredCapacity") {
                self.enableDesiredCapacity = dict["EnableDesiredCapacity"] as! Bool
            }
            if dict.keys.contains("GroupDeletionProtection") {
                self.groupDeletionProtection = dict["GroupDeletionProtection"] as! Bool
            }
            if dict.keys.contains("GroupType") {
                self.groupType = dict["GroupType"] as! String
            }
            if dict.keys.contains("HealthCheckType") {
                self.healthCheckType = dict["HealthCheckType"] as! String
            }
            if dict.keys.contains("HealthCheckTypes") {
                self.healthCheckTypes = dict["HealthCheckTypes"] as! [String]
            }
            if dict.keys.contains("InitCapacity") {
                self.initCapacity = dict["InitCapacity"] as! Int32
            }
            if dict.keys.contains("IsElasticStrengthInAlarm") {
                self.isElasticStrengthInAlarm = dict["IsElasticStrengthInAlarm"] as! Bool
            }
            if dict.keys.contains("LaunchTemplateId") {
                self.launchTemplateId = dict["LaunchTemplateId"] as! String
            }
            if dict.keys.contains("LaunchTemplateOverrides") {
                var tmp : [DescribeScalingGroupDetailResponseBody.ScalingGroup.LaunchTemplateOverrides] = []
                for v in dict["LaunchTemplateOverrides"] as! [Any] {
                    var model = DescribeScalingGroupDetailResponseBody.ScalingGroup.LaunchTemplateOverrides()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.launchTemplateOverrides = tmp
            }
            if dict.keys.contains("LaunchTemplateVersion") {
                self.launchTemplateVersion = dict["LaunchTemplateVersion"] as! String
            }
            if dict.keys.contains("LifecycleState") {
                self.lifecycleState = dict["LifecycleState"] as! String
            }
            if dict.keys.contains("LoadBalancerConfigs") {
                var tmp : [DescribeScalingGroupDetailResponseBody.ScalingGroup.LoadBalancerConfigs] = []
                for v in dict["LoadBalancerConfigs"] as! [Any] {
                    var model = DescribeScalingGroupDetailResponseBody.ScalingGroup.LoadBalancerConfigs()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.loadBalancerConfigs = tmp
            }
            if dict.keys.contains("LoadBalancerIds") {
                self.loadBalancerIds = dict["LoadBalancerIds"] as! [String]
            }
            if dict.keys.contains("MaxInstanceLifetime") {
                self.maxInstanceLifetime = dict["MaxInstanceLifetime"] as! Int32
            }
            if dict.keys.contains("MaxSize") {
                self.maxSize = dict["MaxSize"] as! Int32
            }
            if dict.keys.contains("MinSize") {
                self.minSize = dict["MinSize"] as! Int32
            }
            if dict.keys.contains("ModificationTime") {
                self.modificationTime = dict["ModificationTime"] as! String
            }
            if dict.keys.contains("MonitorGroupId") {
                self.monitorGroupId = dict["MonitorGroupId"] as! String
            }
            if dict.keys.contains("MultiAZPolicy") {
                self.multiAZPolicy = dict["MultiAZPolicy"] as! String
            }
            if dict.keys.contains("OnDemandBaseCapacity") {
                self.onDemandBaseCapacity = dict["OnDemandBaseCapacity"] as! Int32
            }
            if dict.keys.contains("OnDemandPercentageAboveBaseCapacity") {
                self.onDemandPercentageAboveBaseCapacity = dict["OnDemandPercentageAboveBaseCapacity"] as! Int32
            }
            if dict.keys.contains("PendingCapacity") {
                self.pendingCapacity = dict["PendingCapacity"] as! Int32
            }
            if dict.keys.contains("PendingWaitCapacity") {
                self.pendingWaitCapacity = dict["PendingWaitCapacity"] as! Int32
            }
            if dict.keys.contains("ProtectedCapacity") {
                self.protectedCapacity = dict["ProtectedCapacity"] as! Int32
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("RemovalPolicies") {
                self.removalPolicies = dict["RemovalPolicies"] as! [String]
            }
            if dict.keys.contains("RemovingCapacity") {
                self.removingCapacity = dict["RemovingCapacity"] as! Int32
            }
            if dict.keys.contains("RemovingWaitCapacity") {
                self.removingWaitCapacity = dict["RemovingWaitCapacity"] as! Int32
            }
            if dict.keys.contains("ResourceGroupId") {
                self.resourceGroupId = dict["ResourceGroupId"] as! String
            }
            if dict.keys.contains("ScalingGroupId") {
                self.scalingGroupId = dict["ScalingGroupId"] as! String
            }
            if dict.keys.contains("ScalingGroupName") {
                self.scalingGroupName = dict["ScalingGroupName"] as! String
            }
            if dict.keys.contains("ScalingPolicy") {
                self.scalingPolicy = dict["ScalingPolicy"] as! String
            }
            if dict.keys.contains("ServerGroups") {
                var tmp : [DescribeScalingGroupDetailResponseBody.ScalingGroup.ServerGroups] = []
                for v in dict["ServerGroups"] as! [Any] {
                    var model = DescribeScalingGroupDetailResponseBody.ScalingGroup.ServerGroups()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.serverGroups = tmp
            }
            if dict.keys.contains("SpotAllocationStrategy") {
                self.spotAllocationStrategy = dict["SpotAllocationStrategy"] as! String
            }
            if dict.keys.contains("SpotInstancePools") {
                self.spotInstancePools = dict["SpotInstancePools"] as! Int32
            }
            if dict.keys.contains("SpotInstanceRemedy") {
                self.spotInstanceRemedy = dict["SpotInstanceRemedy"] as! Bool
            }
            if dict.keys.contains("StandbyCapacity") {
                self.standbyCapacity = dict["StandbyCapacity"] as! Int32
            }
            if dict.keys.contains("StoppedCapacity") {
                self.stoppedCapacity = dict["StoppedCapacity"] as! Int32
            }
            if dict.keys.contains("SuspendedProcesses") {
                self.suspendedProcesses = dict["SuspendedProcesses"] as! [String]
            }
            if dict.keys.contains("SystemSuspended") {
                self.systemSuspended = dict["SystemSuspended"] as! Bool
            }
            if dict.keys.contains("Tags") {
                var tmp : [DescribeScalingGroupDetailResponseBody.ScalingGroup.Tags] = []
                for v in dict["Tags"] as! [Any] {
                    var model = DescribeScalingGroupDetailResponseBody.ScalingGroup.Tags()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tags = tmp
            }
            if dict.keys.contains("TotalCapacity") {
                self.totalCapacity = dict["TotalCapacity"] as! Int32
            }
            if dict.keys.contains("TotalInstanceCount") {
                self.totalInstanceCount = dict["TotalInstanceCount"] as! Int32
            }
            if dict.keys.contains("VServerGroups") {
                var tmp : [DescribeScalingGroupDetailResponseBody.ScalingGroup.VServerGroups] = []
                for v in dict["VServerGroups"] as! [Any] {
                    var model = DescribeScalingGroupDetailResponseBody.ScalingGroup.VServerGroups()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.VServerGroups = tmp
            }
            if dict.keys.contains("VSwitchId") {
                self.vSwitchId = dict["VSwitchId"] as! String
            }
            if dict.keys.contains("VSwitchIds") {
                self.vSwitchIds = dict["VSwitchIds"] as! [String]
            }
            if dict.keys.contains("VpcId") {
                self.vpcId = dict["VpcId"] as! String
            }
        }
    }
    public var output: String?

    public var requestId: String?

    public var scalingGroup: DescribeScalingGroupDetailResponseBody.ScalingGroup?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.scalingGroup?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.output != nil {
            map["Output"] = self.output!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingGroup != nil {
            map["ScalingGroup"] = self.scalingGroup?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Output") {
            self.output = dict["Output"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScalingGroup") {
            var model = DescribeScalingGroupDetailResponseBody.ScalingGroup()
            model.fromMap(dict["ScalingGroup"] as! [String: Any])
            self.scalingGroup = model
        }
    }
}

public class DescribeScalingGroupDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeScalingGroupDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeScalingGroupDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeScalingGroupDiagnoseDetailsRequest : Tea.TeaModel {
    public var regionId: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ScalingGroupId") {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
    }
}

public class DescribeScalingGroupDiagnoseDetailsResponseBody : Tea.TeaModel {
    public class Details : Tea.TeaModel {
        public var diagnoseType: String?

        public var errorCode: String?

        public var resourceId: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.diagnoseType != nil {
                map["DiagnoseType"] = self.diagnoseType!
            }
            if self.errorCode != nil {
                map["ErrorCode"] = self.errorCode!
            }
            if self.resourceId != nil {
                map["ResourceId"] = self.resourceId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DiagnoseType") {
                self.diagnoseType = dict["DiagnoseType"] as! String
            }
            if dict.keys.contains("ErrorCode") {
                self.errorCode = dict["ErrorCode"] as! String
            }
            if dict.keys.contains("ResourceId") {
                self.resourceId = dict["ResourceId"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var details: [DescribeScalingGroupDiagnoseDetailsResponseBody.Details]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.details != nil {
            var tmp : [Any] = []
            for k in self.details! {
                tmp.append(k.toMap())
            }
            map["Details"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Details") {
            var tmp : [DescribeScalingGroupDiagnoseDetailsResponseBody.Details] = []
            for v in dict["Details"] as! [Any] {
                var model = DescribeScalingGroupDiagnoseDetailsResponseBody.Details()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.details = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeScalingGroupDiagnoseDetailsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeScalingGroupDiagnoseDetailsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeScalingGroupDiagnoseDetailsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeScalingGroupsRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var groupType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var scalingGroupIds: [String]?

    public var scalingGroupName: String?

    public var scalingGroupNames: [String]?

    public var tags: [DescribeScalingGroupsRequest.Tags]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupType != nil {
            map["GroupType"] = self.groupType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.scalingGroupIds != nil {
            map["ScalingGroupIds"] = self.scalingGroupIds!
        }
        if self.scalingGroupName != nil {
            map["ScalingGroupName"] = self.scalingGroupName!
        }
        if self.scalingGroupNames != nil {
            map["ScalingGroupNames"] = self.scalingGroupNames!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupType") {
            self.groupType = dict["GroupType"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ScalingGroupIds") {
            self.scalingGroupIds = dict["ScalingGroupIds"] as! [String]
        }
        if dict.keys.contains("ScalingGroupName") {
            self.scalingGroupName = dict["ScalingGroupName"] as! String
        }
        if dict.keys.contains("ScalingGroupNames") {
            self.scalingGroupNames = dict["ScalingGroupNames"] as! [String]
        }
        if dict.keys.contains("Tags") {
            var tmp : [DescribeScalingGroupsRequest.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = DescribeScalingGroupsRequest.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
    }
}

public class DescribeScalingGroupsResponseBody : Tea.TeaModel {
    public class ScalingGroups : Tea.TeaModel {
        public class AlbServerGroups : Tea.TeaModel {
            public var albServerGroupId: String?

            public var port: Int32?

            public var weight: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.albServerGroupId != nil {
                    map["AlbServerGroupId"] = self.albServerGroupId!
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.weight != nil {
                    map["Weight"] = self.weight!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AlbServerGroupId") {
                    self.albServerGroupId = dict["AlbServerGroupId"] as! String
                }
                if dict.keys.contains("Port") {
                    self.port = dict["Port"] as! Int32
                }
                if dict.keys.contains("Weight") {
                    self.weight = dict["Weight"] as! Int32
                }
            }
        }
        public class CapacityOptions : Tea.TeaModel {
            public var compensateWithOnDemand: Bool?

            public var onDemandBaseCapacity: Int32?

            public var onDemandPercentageAboveBaseCapacity: Int32?

            public var priceComparisonMode: String?

            public var spotAutoReplaceOnDemand: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.compensateWithOnDemand != nil {
                    map["CompensateWithOnDemand"] = self.compensateWithOnDemand!
                }
                if self.onDemandBaseCapacity != nil {
                    map["OnDemandBaseCapacity"] = self.onDemandBaseCapacity!
                }
                if self.onDemandPercentageAboveBaseCapacity != nil {
                    map["OnDemandPercentageAboveBaseCapacity"] = self.onDemandPercentageAboveBaseCapacity!
                }
                if self.priceComparisonMode != nil {
                    map["PriceComparisonMode"] = self.priceComparisonMode!
                }
                if self.spotAutoReplaceOnDemand != nil {
                    map["SpotAutoReplaceOnDemand"] = self.spotAutoReplaceOnDemand!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CompensateWithOnDemand") {
                    self.compensateWithOnDemand = dict["CompensateWithOnDemand"] as! Bool
                }
                if dict.keys.contains("OnDemandBaseCapacity") {
                    self.onDemandBaseCapacity = dict["OnDemandBaseCapacity"] as! Int32
                }
                if dict.keys.contains("OnDemandPercentageAboveBaseCapacity") {
                    self.onDemandPercentageAboveBaseCapacity = dict["OnDemandPercentageAboveBaseCapacity"] as! Int32
                }
                if dict.keys.contains("PriceComparisonMode") {
                    self.priceComparisonMode = dict["PriceComparisonMode"] as! String
                }
                if dict.keys.contains("SpotAutoReplaceOnDemand") {
                    self.spotAutoReplaceOnDemand = dict["SpotAutoReplaceOnDemand"] as! Bool
                }
            }
        }
        public class DBInstances : Tea.TeaModel {
            public var DBInstanceId: String?

            public var securityGroupIds: [String]?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.DBInstanceId != nil {
                    map["DBInstanceId"] = self.DBInstanceId!
                }
                if self.securityGroupIds != nil {
                    map["SecurityGroupIds"] = self.securityGroupIds!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DBInstanceId") {
                    self.DBInstanceId = dict["DBInstanceId"] as! String
                }
                if dict.keys.contains("SecurityGroupIds") {
                    self.securityGroupIds = dict["SecurityGroupIds"] as! [String]
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class LaunchTemplateOverrides : Tea.TeaModel {
            public var instanceType: String?

            public var spotPriceLimit: Double?

            public var weightedCapacity: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.instanceType != nil {
                    map["InstanceType"] = self.instanceType!
                }
                if self.spotPriceLimit != nil {
                    map["SpotPriceLimit"] = self.spotPriceLimit!
                }
                if self.weightedCapacity != nil {
                    map["WeightedCapacity"] = self.weightedCapacity!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("InstanceType") {
                    self.instanceType = dict["InstanceType"] as! String
                }
                if dict.keys.contains("SpotPriceLimit") {
                    self.spotPriceLimit = dict["SpotPriceLimit"] as! Double
                }
                if dict.keys.contains("WeightedCapacity") {
                    self.weightedCapacity = dict["WeightedCapacity"] as! Int32
                }
            }
        }
        public class LoadBalancerConfigs : Tea.TeaModel {
            public var loadBalancerId: String?

            public var weight: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.loadBalancerId != nil {
                    map["LoadBalancerId"] = self.loadBalancerId!
                }
                if self.weight != nil {
                    map["Weight"] = self.weight!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("LoadBalancerId") {
                    self.loadBalancerId = dict["LoadBalancerId"] as! String
                }
                if dict.keys.contains("Weight") {
                    self.weight = dict["Weight"] as! Int32
                }
            }
        }
        public class ServerGroups : Tea.TeaModel {
            public var port: Int32?

            public var serverGroupId: String?

            public var type: String?

            public var weight: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.serverGroupId != nil {
                    map["ServerGroupId"] = self.serverGroupId!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.weight != nil {
                    map["Weight"] = self.weight!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Port") {
                    self.port = dict["Port"] as! Int32
                }
                if dict.keys.contains("ServerGroupId") {
                    self.serverGroupId = dict["ServerGroupId"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Weight") {
                    self.weight = dict["Weight"] as! Int32
                }
            }
        }
        public class Tags : Tea.TeaModel {
            public var propagate: Bool?

            public var tagKey: String?

            public var tagValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.propagate != nil {
                    map["Propagate"] = self.propagate!
                }
                if self.tagKey != nil {
                    map["TagKey"] = self.tagKey!
                }
                if self.tagValue != nil {
                    map["TagValue"] = self.tagValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Propagate") {
                    self.propagate = dict["Propagate"] as! Bool
                }
                if dict.keys.contains("TagKey") {
                    self.tagKey = dict["TagKey"] as! String
                }
                if dict.keys.contains("TagValue") {
                    self.tagValue = dict["TagValue"] as! String
                }
            }
        }
        public class VServerGroups : Tea.TeaModel {
            public class VServerGroupAttributes : Tea.TeaModel {
                public var port: Int32?

                public var VServerGroupId: String?

                public var weight: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.port != nil {
                        map["Port"] = self.port!
                    }
                    if self.VServerGroupId != nil {
                        map["VServerGroupId"] = self.VServerGroupId!
                    }
                    if self.weight != nil {
                        map["Weight"] = self.weight!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Port") {
                        self.port = dict["Port"] as! Int32
                    }
                    if dict.keys.contains("VServerGroupId") {
                        self.VServerGroupId = dict["VServerGroupId"] as! String
                    }
                    if dict.keys.contains("Weight") {
                        self.weight = dict["Weight"] as! Int32
                    }
                }
            }
            public var loadBalancerId: String?

            public var VServerGroupAttributes: [DescribeScalingGroupsResponseBody.ScalingGroups.VServerGroups.VServerGroupAttributes]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.loadBalancerId != nil {
                    map["LoadBalancerId"] = self.loadBalancerId!
                }
                if self.VServerGroupAttributes != nil {
                    var tmp : [Any] = []
                    for k in self.VServerGroupAttributes! {
                        tmp.append(k.toMap())
                    }
                    map["VServerGroupAttributes"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("LoadBalancerId") {
                    self.loadBalancerId = dict["LoadBalancerId"] as! String
                }
                if dict.keys.contains("VServerGroupAttributes") {
                    var tmp : [DescribeScalingGroupsResponseBody.ScalingGroups.VServerGroups.VServerGroupAttributes] = []
                    for v in dict["VServerGroupAttributes"] as! [Any] {
                        var model = DescribeScalingGroupsResponseBody.ScalingGroups.VServerGroups.VServerGroupAttributes()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.VServerGroupAttributes = tmp
                }
            }
        }
        public var activeCapacity: Int32?

        public var activeScalingConfigurationId: String?

        public var albServerGroups: [DescribeScalingGroupsResponseBody.ScalingGroups.AlbServerGroups]?

        public var allocationStrategy: String?

        public var azBalance: Bool?

        public var capacityOptions: DescribeScalingGroupsResponseBody.ScalingGroups.CapacityOptions?

        public var compensateWithOnDemand: Bool?

        public var creationTime: String?

        public var currentHostName: String?

        public var customPolicyARN: String?

        public var DBInstanceIds: [String]?

        public var DBInstances: [DescribeScalingGroupsResponseBody.ScalingGroups.DBInstances]?

        public var defaultCooldown: Int32?

        public var desiredCapacity: Int32?

        public var enableDesiredCapacity: Bool?

        public var groupDeletionProtection: Bool?

        public var groupType: String?

        public var healthCheckType: String?

        public var healthCheckTypes: [String]?

        public var initCapacity: Int32?

        public var isElasticStrengthInAlarm: Bool?

        public var launchTemplateId: String?

        public var launchTemplateOverrides: [DescribeScalingGroupsResponseBody.ScalingGroups.LaunchTemplateOverrides]?

        public var launchTemplateVersion: String?

        public var lifecycleState: String?

        public var loadBalancerConfigs: [DescribeScalingGroupsResponseBody.ScalingGroups.LoadBalancerConfigs]?

        public var loadBalancerIds: [String]?

        public var maxInstanceLifetime: Int32?

        public var maxSize: Int32?

        public var minSize: Int32?

        public var modificationTime: String?

        public var monitorGroupId: String?

        public var multiAZPolicy: String?

        public var onDemandBaseCapacity: Int32?

        public var onDemandPercentageAboveBaseCapacity: Int32?

        public var pendingCapacity: Int32?

        public var pendingWaitCapacity: Int32?

        public var protectedCapacity: Int32?

        public var regionId: String?

        public var removalPolicies: [String]?

        public var removingCapacity: Int32?

        public var removingWaitCapacity: Int32?

        public var resourceGroupId: String?

        public var scalingGroupId: String?

        public var scalingGroupName: String?

        public var scalingPolicy: String?

        public var serverGroups: [DescribeScalingGroupsResponseBody.ScalingGroups.ServerGroups]?

        public var spotAllocationStrategy: String?

        public var spotCapacity: Int32?

        public var spotInstancePools: Int32?

        public var spotInstanceRemedy: Bool?

        public var standbyCapacity: Int32?

        public var stopInstanceTimeout: Int32?

        public var stoppedCapacity: Int32?

        public var suspendedProcesses: [String]?

        public var systemSuspended: Bool?

        public var tags: [DescribeScalingGroupsResponseBody.ScalingGroups.Tags]?

        public var totalCapacity: Int32?

        public var totalInstanceCount: Int32?

        public var VServerGroups: [DescribeScalingGroupsResponseBody.ScalingGroups.VServerGroups]?

        public var vSwitchId: String?

        public var vSwitchIds: [String]?

        public var vpcId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.capacityOptions?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.activeCapacity != nil {
                map["ActiveCapacity"] = self.activeCapacity!
            }
            if self.activeScalingConfigurationId != nil {
                map["ActiveScalingConfigurationId"] = self.activeScalingConfigurationId!
            }
            if self.albServerGroups != nil {
                var tmp : [Any] = []
                for k in self.albServerGroups! {
                    tmp.append(k.toMap())
                }
                map["AlbServerGroups"] = tmp
            }
            if self.allocationStrategy != nil {
                map["AllocationStrategy"] = self.allocationStrategy!
            }
            if self.azBalance != nil {
                map["AzBalance"] = self.azBalance!
            }
            if self.capacityOptions != nil {
                map["CapacityOptions"] = self.capacityOptions?.toMap()
            }
            if self.compensateWithOnDemand != nil {
                map["CompensateWithOnDemand"] = self.compensateWithOnDemand!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.currentHostName != nil {
                map["CurrentHostName"] = self.currentHostName!
            }
            if self.customPolicyARN != nil {
                map["CustomPolicyARN"] = self.customPolicyARN!
            }
            if self.DBInstanceIds != nil {
                map["DBInstanceIds"] = self.DBInstanceIds!
            }
            if self.DBInstances != nil {
                var tmp : [Any] = []
                for k in self.DBInstances! {
                    tmp.append(k.toMap())
                }
                map["DBInstances"] = tmp
            }
            if self.defaultCooldown != nil {
                map["DefaultCooldown"] = self.defaultCooldown!
            }
            if self.desiredCapacity != nil {
                map["DesiredCapacity"] = self.desiredCapacity!
            }
            if self.enableDesiredCapacity != nil {
                map["EnableDesiredCapacity"] = self.enableDesiredCapacity!
            }
            if self.groupDeletionProtection != nil {
                map["GroupDeletionProtection"] = self.groupDeletionProtection!
            }
            if self.groupType != nil {
                map["GroupType"] = self.groupType!
            }
            if self.healthCheckType != nil {
                map["HealthCheckType"] = self.healthCheckType!
            }
            if self.healthCheckTypes != nil {
                map["HealthCheckTypes"] = self.healthCheckTypes!
            }
            if self.initCapacity != nil {
                map["InitCapacity"] = self.initCapacity!
            }
            if self.isElasticStrengthInAlarm != nil {
                map["IsElasticStrengthInAlarm"] = self.isElasticStrengthInAlarm!
            }
            if self.launchTemplateId != nil {
                map["LaunchTemplateId"] = self.launchTemplateId!
            }
            if self.launchTemplateOverrides != nil {
                var tmp : [Any] = []
                for k in self.launchTemplateOverrides! {
                    tmp.append(k.toMap())
                }
                map["LaunchTemplateOverrides"] = tmp
            }
            if self.launchTemplateVersion != nil {
                map["LaunchTemplateVersion"] = self.launchTemplateVersion!
            }
            if self.lifecycleState != nil {
                map["LifecycleState"] = self.lifecycleState!
            }
            if self.loadBalancerConfigs != nil {
                var tmp : [Any] = []
                for k in self.loadBalancerConfigs! {
                    tmp.append(k.toMap())
                }
                map["LoadBalancerConfigs"] = tmp
            }
            if self.loadBalancerIds != nil {
                map["LoadBalancerIds"] = self.loadBalancerIds!
            }
            if self.maxInstanceLifetime != nil {
                map["MaxInstanceLifetime"] = self.maxInstanceLifetime!
            }
            if self.maxSize != nil {
                map["MaxSize"] = self.maxSize!
            }
            if self.minSize != nil {
                map["MinSize"] = self.minSize!
            }
            if self.modificationTime != nil {
                map["ModificationTime"] = self.modificationTime!
            }
            if self.monitorGroupId != nil {
                map["MonitorGroupId"] = self.monitorGroupId!
            }
            if self.multiAZPolicy != nil {
                map["MultiAZPolicy"] = self.multiAZPolicy!
            }
            if self.onDemandBaseCapacity != nil {
                map["OnDemandBaseCapacity"] = self.onDemandBaseCapacity!
            }
            if self.onDemandPercentageAboveBaseCapacity != nil {
                map["OnDemandPercentageAboveBaseCapacity"] = self.onDemandPercentageAboveBaseCapacity!
            }
            if self.pendingCapacity != nil {
                map["PendingCapacity"] = self.pendingCapacity!
            }
            if self.pendingWaitCapacity != nil {
                map["PendingWaitCapacity"] = self.pendingWaitCapacity!
            }
            if self.protectedCapacity != nil {
                map["ProtectedCapacity"] = self.protectedCapacity!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.removalPolicies != nil {
                map["RemovalPolicies"] = self.removalPolicies!
            }
            if self.removingCapacity != nil {
                map["RemovingCapacity"] = self.removingCapacity!
            }
            if self.removingWaitCapacity != nil {
                map["RemovingWaitCapacity"] = self.removingWaitCapacity!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.scalingGroupId != nil {
                map["ScalingGroupId"] = self.scalingGroupId!
            }
            if self.scalingGroupName != nil {
                map["ScalingGroupName"] = self.scalingGroupName!
            }
            if self.scalingPolicy != nil {
                map["ScalingPolicy"] = self.scalingPolicy!
            }
            if self.serverGroups != nil {
                var tmp : [Any] = []
                for k in self.serverGroups! {
                    tmp.append(k.toMap())
                }
                map["ServerGroups"] = tmp
            }
            if self.spotAllocationStrategy != nil {
                map["SpotAllocationStrategy"] = self.spotAllocationStrategy!
            }
            if self.spotCapacity != nil {
                map["SpotCapacity"] = self.spotCapacity!
            }
            if self.spotInstancePools != nil {
                map["SpotInstancePools"] = self.spotInstancePools!
            }
            if self.spotInstanceRemedy != nil {
                map["SpotInstanceRemedy"] = self.spotInstanceRemedy!
            }
            if self.standbyCapacity != nil {
                map["StandbyCapacity"] = self.standbyCapacity!
            }
            if self.stopInstanceTimeout != nil {
                map["StopInstanceTimeout"] = self.stopInstanceTimeout!
            }
            if self.stoppedCapacity != nil {
                map["StoppedCapacity"] = self.stoppedCapacity!
            }
            if self.suspendedProcesses != nil {
                map["SuspendedProcesses"] = self.suspendedProcesses!
            }
            if self.systemSuspended != nil {
                map["SystemSuspended"] = self.systemSuspended!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            if self.totalCapacity != nil {
                map["TotalCapacity"] = self.totalCapacity!
            }
            if self.totalInstanceCount != nil {
                map["TotalInstanceCount"] = self.totalInstanceCount!
            }
            if self.VServerGroups != nil {
                var tmp : [Any] = []
                for k in self.VServerGroups! {
                    tmp.append(k.toMap())
                }
                map["VServerGroups"] = tmp
            }
            if self.vSwitchId != nil {
                map["VSwitchId"] = self.vSwitchId!
            }
            if self.vSwitchIds != nil {
                map["VSwitchIds"] = self.vSwitchIds!
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ActiveCapacity") {
                self.activeCapacity = dict["ActiveCapacity"] as! Int32
            }
            if dict.keys.contains("ActiveScalingConfigurationId") {
                self.activeScalingConfigurationId = dict["ActiveScalingConfigurationId"] as! String
            }
            if dict.keys.contains("AlbServerGroups") {
                var tmp : [DescribeScalingGroupsResponseBody.ScalingGroups.AlbServerGroups] = []
                for v in dict["AlbServerGroups"] as! [Any] {
                    var model = DescribeScalingGroupsResponseBody.ScalingGroups.AlbServerGroups()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.albServerGroups = tmp
            }
            if dict.keys.contains("AllocationStrategy") {
                self.allocationStrategy = dict["AllocationStrategy"] as! String
            }
            if dict.keys.contains("AzBalance") {
                self.azBalance = dict["AzBalance"] as! Bool
            }
            if dict.keys.contains("CapacityOptions") {
                var model = DescribeScalingGroupsResponseBody.ScalingGroups.CapacityOptions()
                model.fromMap(dict["CapacityOptions"] as! [String: Any])
                self.capacityOptions = model
            }
            if dict.keys.contains("CompensateWithOnDemand") {
                self.compensateWithOnDemand = dict["CompensateWithOnDemand"] as! Bool
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("CurrentHostName") {
                self.currentHostName = dict["CurrentHostName"] as! String
            }
            if dict.keys.contains("CustomPolicyARN") {
                self.customPolicyARN = dict["CustomPolicyARN"] as! String
            }
            if dict.keys.contains("DBInstanceIds") {
                self.DBInstanceIds = dict["DBInstanceIds"] as! [String]
            }
            if dict.keys.contains("DBInstances") {
                var tmp : [DescribeScalingGroupsResponseBody.ScalingGroups.DBInstances] = []
                for v in dict["DBInstances"] as! [Any] {
                    var model = DescribeScalingGroupsResponseBody.ScalingGroups.DBInstances()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.DBInstances = tmp
            }
            if dict.keys.contains("DefaultCooldown") {
                self.defaultCooldown = dict["DefaultCooldown"] as! Int32
            }
            if dict.keys.contains("DesiredCapacity") {
                self.desiredCapacity = dict["DesiredCapacity"] as! Int32
            }
            if dict.keys.contains("EnableDesiredCapacity") {
                self.enableDesiredCapacity = dict["EnableDesiredCapacity"] as! Bool
            }
            if dict.keys.contains("GroupDeletionProtection") {
                self.groupDeletionProtection = dict["GroupDeletionProtection"] as! Bool
            }
            if dict.keys.contains("GroupType") {
                self.groupType = dict["GroupType"] as! String
            }
            if dict.keys.contains("HealthCheckType") {
                self.healthCheckType = dict["HealthCheckType"] as! String
            }
            if dict.keys.contains("HealthCheckTypes") {
                self.healthCheckTypes = dict["HealthCheckTypes"] as! [String]
            }
            if dict.keys.contains("InitCapacity") {
                self.initCapacity = dict["InitCapacity"] as! Int32
            }
            if dict.keys.contains("IsElasticStrengthInAlarm") {
                self.isElasticStrengthInAlarm = dict["IsElasticStrengthInAlarm"] as! Bool
            }
            if dict.keys.contains("LaunchTemplateId") {
                self.launchTemplateId = dict["LaunchTemplateId"] as! String
            }
            if dict.keys.contains("LaunchTemplateOverrides") {
                var tmp : [DescribeScalingGroupsResponseBody.ScalingGroups.LaunchTemplateOverrides] = []
                for v in dict["LaunchTemplateOverrides"] as! [Any] {
                    var model = DescribeScalingGroupsResponseBody.ScalingGroups.LaunchTemplateOverrides()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.launchTemplateOverrides = tmp
            }
            if dict.keys.contains("LaunchTemplateVersion") {
                self.launchTemplateVersion = dict["LaunchTemplateVersion"] as! String
            }
            if dict.keys.contains("LifecycleState") {
                self.lifecycleState = dict["LifecycleState"] as! String
            }
            if dict.keys.contains("LoadBalancerConfigs") {
                var tmp : [DescribeScalingGroupsResponseBody.ScalingGroups.LoadBalancerConfigs] = []
                for v in dict["LoadBalancerConfigs"] as! [Any] {
                    var model = DescribeScalingGroupsResponseBody.ScalingGroups.LoadBalancerConfigs()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.loadBalancerConfigs = tmp
            }
            if dict.keys.contains("LoadBalancerIds") {
                self.loadBalancerIds = dict["LoadBalancerIds"] as! [String]
            }
            if dict.keys.contains("MaxInstanceLifetime") {
                self.maxInstanceLifetime = dict["MaxInstanceLifetime"] as! Int32
            }
            if dict.keys.contains("MaxSize") {
                self.maxSize = dict["MaxSize"] as! Int32
            }
            if dict.keys.contains("MinSize") {
                self.minSize = dict["MinSize"] as! Int32
            }
            if dict.keys.contains("ModificationTime") {
                self.modificationTime = dict["ModificationTime"] as! String
            }
            if dict.keys.contains("MonitorGroupId") {
                self.monitorGroupId = dict["MonitorGroupId"] as! String
            }
            if dict.keys.contains("MultiAZPolicy") {
                self.multiAZPolicy = dict["MultiAZPolicy"] as! String
            }
            if dict.keys.contains("OnDemandBaseCapacity") {
                self.onDemandBaseCapacity = dict["OnDemandBaseCapacity"] as! Int32
            }
            if dict.keys.contains("OnDemandPercentageAboveBaseCapacity") {
                self.onDemandPercentageAboveBaseCapacity = dict["OnDemandPercentageAboveBaseCapacity"] as! Int32
            }
            if dict.keys.contains("PendingCapacity") {
                self.pendingCapacity = dict["PendingCapacity"] as! Int32
            }
            if dict.keys.contains("PendingWaitCapacity") {
                self.pendingWaitCapacity = dict["PendingWaitCapacity"] as! Int32
            }
            if dict.keys.contains("ProtectedCapacity") {
                self.protectedCapacity = dict["ProtectedCapacity"] as! Int32
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("RemovalPolicies") {
                self.removalPolicies = dict["RemovalPolicies"] as! [String]
            }
            if dict.keys.contains("RemovingCapacity") {
                self.removingCapacity = dict["RemovingCapacity"] as! Int32
            }
            if dict.keys.contains("RemovingWaitCapacity") {
                self.removingWaitCapacity = dict["RemovingWaitCapacity"] as! Int32
            }
            if dict.keys.contains("ResourceGroupId") {
                self.resourceGroupId = dict["ResourceGroupId"] as! String
            }
            if dict.keys.contains("ScalingGroupId") {
                self.scalingGroupId = dict["ScalingGroupId"] as! String
            }
            if dict.keys.contains("ScalingGroupName") {
                self.scalingGroupName = dict["ScalingGroupName"] as! String
            }
            if dict.keys.contains("ScalingPolicy") {
                self.scalingPolicy = dict["ScalingPolicy"] as! String
            }
            if dict.keys.contains("ServerGroups") {
                var tmp : [DescribeScalingGroupsResponseBody.ScalingGroups.ServerGroups] = []
                for v in dict["ServerGroups"] as! [Any] {
                    var model = DescribeScalingGroupsResponseBody.ScalingGroups.ServerGroups()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.serverGroups = tmp
            }
            if dict.keys.contains("SpotAllocationStrategy") {
                self.spotAllocationStrategy = dict["SpotAllocationStrategy"] as! String
            }
            if dict.keys.contains("SpotCapacity") {
                self.spotCapacity = dict["SpotCapacity"] as! Int32
            }
            if dict.keys.contains("SpotInstancePools") {
                self.spotInstancePools = dict["SpotInstancePools"] as! Int32
            }
            if dict.keys.contains("SpotInstanceRemedy") {
                self.spotInstanceRemedy = dict["SpotInstanceRemedy"] as! Bool
            }
            if dict.keys.contains("StandbyCapacity") {
                self.standbyCapacity = dict["StandbyCapacity"] as! Int32
            }
            if dict.keys.contains("StopInstanceTimeout") {
                self.stopInstanceTimeout = dict["StopInstanceTimeout"] as! Int32
            }
            if dict.keys.contains("StoppedCapacity") {
                self.stoppedCapacity = dict["StoppedCapacity"] as! Int32
            }
            if dict.keys.contains("SuspendedProcesses") {
                self.suspendedProcesses = dict["SuspendedProcesses"] as! [String]
            }
            if dict.keys.contains("SystemSuspended") {
                self.systemSuspended = dict["SystemSuspended"] as! Bool
            }
            if dict.keys.contains("Tags") {
                var tmp : [DescribeScalingGroupsResponseBody.ScalingGroups.Tags] = []
                for v in dict["Tags"] as! [Any] {
                    var model = DescribeScalingGroupsResponseBody.ScalingGroups.Tags()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tags = tmp
            }
            if dict.keys.contains("TotalCapacity") {
                self.totalCapacity = dict["TotalCapacity"] as! Int32
            }
            if dict.keys.contains("TotalInstanceCount") {
                self.totalInstanceCount = dict["TotalInstanceCount"] as! Int32
            }
            if dict.keys.contains("VServerGroups") {
                var tmp : [DescribeScalingGroupsResponseBody.ScalingGroups.VServerGroups] = []
                for v in dict["VServerGroups"] as! [Any] {
                    var model = DescribeScalingGroupsResponseBody.ScalingGroups.VServerGroups()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.VServerGroups = tmp
            }
            if dict.keys.contains("VSwitchId") {
                self.vSwitchId = dict["VSwitchId"] as! String
            }
            if dict.keys.contains("VSwitchIds") {
                self.vSwitchIds = dict["VSwitchIds"] as! [String]
            }
            if dict.keys.contains("VpcId") {
                self.vpcId = dict["VpcId"] as! String
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var scalingGroups: [DescribeScalingGroupsResponseBody.ScalingGroups]?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingGroups != nil {
            var tmp : [Any] = []
            for k in self.scalingGroups! {
                tmp.append(k.toMap())
            }
            map["ScalingGroups"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScalingGroups") {
            var tmp : [DescribeScalingGroupsResponseBody.ScalingGroups] = []
            for v in dict["ScalingGroups"] as! [Any] {
                var model = DescribeScalingGroupsResponseBody.ScalingGroups()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.scalingGroups = tmp
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeScalingGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeScalingGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeScalingGroupsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeScalingInstancesRequest : Tea.TeaModel {
    public var creationType: String?

    public var creationTypes: [String]?

    public var healthStatus: String?

    public var instanceIds: [String]?

    public var lifecycleState: String?

    public var lifecycleStates: [String]?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var scalingActivityId: String?

    public var scalingConfigurationId: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.creationType != nil {
            map["CreationType"] = self.creationType!
        }
        if self.creationTypes != nil {
            map["CreationTypes"] = self.creationTypes!
        }
        if self.healthStatus != nil {
            map["HealthStatus"] = self.healthStatus!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.lifecycleState != nil {
            map["LifecycleState"] = self.lifecycleState!
        }
        if self.lifecycleStates != nil {
            map["LifecycleStates"] = self.lifecycleStates!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.scalingActivityId != nil {
            map["ScalingActivityId"] = self.scalingActivityId!
        }
        if self.scalingConfigurationId != nil {
            map["ScalingConfigurationId"] = self.scalingConfigurationId!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreationType") {
            self.creationType = dict["CreationType"] as! String
        }
        if dict.keys.contains("CreationTypes") {
            self.creationTypes = dict["CreationTypes"] as! [String]
        }
        if dict.keys.contains("HealthStatus") {
            self.healthStatus = dict["HealthStatus"] as! String
        }
        if dict.keys.contains("InstanceIds") {
            self.instanceIds = dict["InstanceIds"] as! [String]
        }
        if dict.keys.contains("LifecycleState") {
            self.lifecycleState = dict["LifecycleState"] as! String
        }
        if dict.keys.contains("LifecycleStates") {
            self.lifecycleStates = dict["LifecycleStates"] as! [String]
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ScalingActivityId") {
            self.scalingActivityId = dict["ScalingActivityId"] as! String
        }
        if dict.keys.contains("ScalingConfigurationId") {
            self.scalingConfigurationId = dict["ScalingConfigurationId"] as! String
        }
        if dict.keys.contains("ScalingGroupId") {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
    }
}

public class DescribeScalingInstancesResponseBody : Tea.TeaModel {
    public class ScalingInstances : Tea.TeaModel {
        public var createdTime: String?

        public var creationTime: String?

        public var creationType: String?

        public var entrusted: Bool?

        public var healthStatus: String?

        public var instanceId: String?

        public var launchTemplateId: String?

        public var launchTemplateVersion: String?

        public var lifecycleState: String?

        public var loadBalancerWeight: Int32?

        public var privateIpAddress: String?

        public var scalingActivityId: String?

        public var scalingConfigurationId: String?

        public var scalingGroupId: String?

        public var scalingInstanceId: String?

        public var spotStrategy: String?

        public var warmupState: String?

        public var weightedCapacity: Int32?

        public var zoneId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createdTime != nil {
                map["CreatedTime"] = self.createdTime!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.creationType != nil {
                map["CreationType"] = self.creationType!
            }
            if self.entrusted != nil {
                map["Entrusted"] = self.entrusted!
            }
            if self.healthStatus != nil {
                map["HealthStatus"] = self.healthStatus!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.launchTemplateId != nil {
                map["LaunchTemplateId"] = self.launchTemplateId!
            }
            if self.launchTemplateVersion != nil {
                map["LaunchTemplateVersion"] = self.launchTemplateVersion!
            }
            if self.lifecycleState != nil {
                map["LifecycleState"] = self.lifecycleState!
            }
            if self.loadBalancerWeight != nil {
                map["LoadBalancerWeight"] = self.loadBalancerWeight!
            }
            if self.privateIpAddress != nil {
                map["PrivateIpAddress"] = self.privateIpAddress!
            }
            if self.scalingActivityId != nil {
                map["ScalingActivityId"] = self.scalingActivityId!
            }
            if self.scalingConfigurationId != nil {
                map["ScalingConfigurationId"] = self.scalingConfigurationId!
            }
            if self.scalingGroupId != nil {
                map["ScalingGroupId"] = self.scalingGroupId!
            }
            if self.scalingInstanceId != nil {
                map["ScalingInstanceId"] = self.scalingInstanceId!
            }
            if self.spotStrategy != nil {
                map["SpotStrategy"] = self.spotStrategy!
            }
            if self.warmupState != nil {
                map["WarmupState"] = self.warmupState!
            }
            if self.weightedCapacity != nil {
                map["WeightedCapacity"] = self.weightedCapacity!
            }
            if self.zoneId != nil {
                map["ZoneId"] = self.zoneId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreatedTime") {
                self.createdTime = dict["CreatedTime"] as! String
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("CreationType") {
                self.creationType = dict["CreationType"] as! String
            }
            if dict.keys.contains("Entrusted") {
                self.entrusted = dict["Entrusted"] as! Bool
            }
            if dict.keys.contains("HealthStatus") {
                self.healthStatus = dict["HealthStatus"] as! String
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("LaunchTemplateId") {
                self.launchTemplateId = dict["LaunchTemplateId"] as! String
            }
            if dict.keys.contains("LaunchTemplateVersion") {
                self.launchTemplateVersion = dict["LaunchTemplateVersion"] as! String
            }
            if dict.keys.contains("LifecycleState") {
                self.lifecycleState = dict["LifecycleState"] as! String
            }
            if dict.keys.contains("LoadBalancerWeight") {
                self.loadBalancerWeight = dict["LoadBalancerWeight"] as! Int32
            }
            if dict.keys.contains("PrivateIpAddress") {
                self.privateIpAddress = dict["PrivateIpAddress"] as! String
            }
            if dict.keys.contains("ScalingActivityId") {
                self.scalingActivityId = dict["ScalingActivityId"] as! String
            }
            if dict.keys.contains("ScalingConfigurationId") {
                self.scalingConfigurationId = dict["ScalingConfigurationId"] as! String
            }
            if dict.keys.contains("ScalingGroupId") {
                self.scalingGroupId = dict["ScalingGroupId"] as! String
            }
            if dict.keys.contains("ScalingInstanceId") {
                self.scalingInstanceId = dict["ScalingInstanceId"] as! String
            }
            if dict.keys.contains("SpotStrategy") {
                self.spotStrategy = dict["SpotStrategy"] as! String
            }
            if dict.keys.contains("WarmupState") {
                self.warmupState = dict["WarmupState"] as! String
            }
            if dict.keys.contains("WeightedCapacity") {
                self.weightedCapacity = dict["WeightedCapacity"] as! Int32
            }
            if dict.keys.contains("ZoneId") {
                self.zoneId = dict["ZoneId"] as! String
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var scalingInstances: [DescribeScalingInstancesResponseBody.ScalingInstances]?

    public var totalCount: Int32?

    public var totalSpotCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingInstances != nil {
            var tmp : [Any] = []
            for k in self.scalingInstances! {
                tmp.append(k.toMap())
            }
            map["ScalingInstances"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.totalSpotCount != nil {
            map["TotalSpotCount"] = self.totalSpotCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScalingInstances") {
            var tmp : [DescribeScalingInstancesResponseBody.ScalingInstances] = []
            for v in dict["ScalingInstances"] as! [Any] {
                var model = DescribeScalingInstancesResponseBody.ScalingInstances()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.scalingInstances = tmp
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
        if dict.keys.contains("TotalSpotCount") {
            self.totalSpotCount = dict["TotalSpotCount"] as! Int32
        }
    }
}

public class DescribeScalingInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeScalingInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeScalingInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeScalingRulesRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var scalingGroupId: String?

    public var scalingRuleAris: [String]?

    public var scalingRuleIds: [String]?

    public var scalingRuleNames: [String]?

    public var scalingRuleType: String?

    public var showAlarmRules: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        if self.scalingRuleAris != nil {
            map["ScalingRuleAris"] = self.scalingRuleAris!
        }
        if self.scalingRuleIds != nil {
            map["ScalingRuleIds"] = self.scalingRuleIds!
        }
        if self.scalingRuleNames != nil {
            map["ScalingRuleNames"] = self.scalingRuleNames!
        }
        if self.scalingRuleType != nil {
            map["ScalingRuleType"] = self.scalingRuleType!
        }
        if self.showAlarmRules != nil {
            map["ShowAlarmRules"] = self.showAlarmRules!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ScalingGroupId") {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
        if dict.keys.contains("ScalingRuleAris") {
            self.scalingRuleAris = dict["ScalingRuleAris"] as! [String]
        }
        if dict.keys.contains("ScalingRuleIds") {
            self.scalingRuleIds = dict["ScalingRuleIds"] as! [String]
        }
        if dict.keys.contains("ScalingRuleNames") {
            self.scalingRuleNames = dict["ScalingRuleNames"] as! [String]
        }
        if dict.keys.contains("ScalingRuleType") {
            self.scalingRuleType = dict["ScalingRuleType"] as! String
        }
        if dict.keys.contains("ShowAlarmRules") {
            self.showAlarmRules = dict["ShowAlarmRules"] as! Bool
        }
    }
}

public class DescribeScalingRulesResponseBody : Tea.TeaModel {
    public class ScalingRules : Tea.TeaModel {
        public class AlarmDimensions : Tea.TeaModel {
            public var dimensionKey: String?

            public var dimensionValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dimensionKey != nil {
                    map["DimensionKey"] = self.dimensionKey!
                }
                if self.dimensionValue != nil {
                    map["DimensionValue"] = self.dimensionValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DimensionKey") {
                    self.dimensionKey = dict["DimensionKey"] as! String
                }
                if dict.keys.contains("DimensionValue") {
                    self.dimensionValue = dict["DimensionValue"] as! String
                }
            }
        }
        public class Alarms : Tea.TeaModel {
            public class Dimensions : Tea.TeaModel {
                public var dimensionKey: String?

                public var dimensionValue: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dimensionKey != nil {
                        map["DimensionKey"] = self.dimensionKey!
                    }
                    if self.dimensionValue != nil {
                        map["DimensionValue"] = self.dimensionValue!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DimensionKey") {
                        self.dimensionKey = dict["DimensionKey"] as! String
                    }
                    if dict.keys.contains("DimensionValue") {
                        self.dimensionValue = dict["DimensionValue"] as! String
                    }
                }
            }
            public var alarmTaskId: String?

            public var alarmTaskName: String?

            public var comparisonOperator: String?

            public var dimensions: [DescribeScalingRulesResponseBody.ScalingRules.Alarms.Dimensions]?

            public var evaluationCount: Int32?

            public var metricName: String?

            public var metricType: String?

            public var statistics: String?

            public var threshold: Double?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.alarmTaskId != nil {
                    map["AlarmTaskId"] = self.alarmTaskId!
                }
                if self.alarmTaskName != nil {
                    map["AlarmTaskName"] = self.alarmTaskName!
                }
                if self.comparisonOperator != nil {
                    map["ComparisonOperator"] = self.comparisonOperator!
                }
                if self.dimensions != nil {
                    var tmp : [Any] = []
                    for k in self.dimensions! {
                        tmp.append(k.toMap())
                    }
                    map["Dimensions"] = tmp
                }
                if self.evaluationCount != nil {
                    map["EvaluationCount"] = self.evaluationCount!
                }
                if self.metricName != nil {
                    map["MetricName"] = self.metricName!
                }
                if self.metricType != nil {
                    map["MetricType"] = self.metricType!
                }
                if self.statistics != nil {
                    map["Statistics"] = self.statistics!
                }
                if self.threshold != nil {
                    map["Threshold"] = self.threshold!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AlarmTaskId") {
                    self.alarmTaskId = dict["AlarmTaskId"] as! String
                }
                if dict.keys.contains("AlarmTaskName") {
                    self.alarmTaskName = dict["AlarmTaskName"] as! String
                }
                if dict.keys.contains("ComparisonOperator") {
                    self.comparisonOperator = dict["ComparisonOperator"] as! String
                }
                if dict.keys.contains("Dimensions") {
                    var tmp : [DescribeScalingRulesResponseBody.ScalingRules.Alarms.Dimensions] = []
                    for v in dict["Dimensions"] as! [Any] {
                        var model = DescribeScalingRulesResponseBody.ScalingRules.Alarms.Dimensions()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.dimensions = tmp
                }
                if dict.keys.contains("EvaluationCount") {
                    self.evaluationCount = dict["EvaluationCount"] as! Int32
                }
                if dict.keys.contains("MetricName") {
                    self.metricName = dict["MetricName"] as! String
                }
                if dict.keys.contains("MetricType") {
                    self.metricType = dict["MetricType"] as! String
                }
                if dict.keys.contains("Statistics") {
                    self.statistics = dict["Statistics"] as! String
                }
                if dict.keys.contains("Threshold") {
                    self.threshold = dict["Threshold"] as! Double
                }
            }
        }
        public class HybridMetrics : Tea.TeaModel {
            public class Dimensions : Tea.TeaModel {
                public var dimensionKey: String?

                public var dimensionValue: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dimensionKey != nil {
                        map["DimensionKey"] = self.dimensionKey!
                    }
                    if self.dimensionValue != nil {
                        map["DimensionValue"] = self.dimensionValue!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DimensionKey") {
                        self.dimensionKey = dict["DimensionKey"] as! String
                    }
                    if dict.keys.contains("DimensionValue") {
                        self.dimensionValue = dict["DimensionValue"] as! String
                    }
                }
            }
            public var dimensions: [DescribeScalingRulesResponseBody.ScalingRules.HybridMetrics.Dimensions]?

            public var expression: String?

            public var id: String?

            public var metricName: String?

            public var statistic: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dimensions != nil {
                    var tmp : [Any] = []
                    for k in self.dimensions! {
                        tmp.append(k.toMap())
                    }
                    map["Dimensions"] = tmp
                }
                if self.expression != nil {
                    map["Expression"] = self.expression!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.metricName != nil {
                    map["MetricName"] = self.metricName!
                }
                if self.statistic != nil {
                    map["Statistic"] = self.statistic!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Dimensions") {
                    var tmp : [DescribeScalingRulesResponseBody.ScalingRules.HybridMetrics.Dimensions] = []
                    for v in dict["Dimensions"] as! [Any] {
                        var model = DescribeScalingRulesResponseBody.ScalingRules.HybridMetrics.Dimensions()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.dimensions = tmp
                }
                if dict.keys.contains("Expression") {
                    self.expression = dict["Expression"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("MetricName") {
                    self.metricName = dict["MetricName"] as! String
                }
                if dict.keys.contains("Statistic") {
                    self.statistic = dict["Statistic"] as! String
                }
            }
        }
        public class StepAdjustments : Tea.TeaModel {
            public var metricIntervalLowerBound: Double?

            public var metricIntervalUpperBound: Double?

            public var scalingAdjustment: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.metricIntervalLowerBound != nil {
                    map["MetricIntervalLowerBound"] = self.metricIntervalLowerBound!
                }
                if self.metricIntervalUpperBound != nil {
                    map["MetricIntervalUpperBound"] = self.metricIntervalUpperBound!
                }
                if self.scalingAdjustment != nil {
                    map["ScalingAdjustment"] = self.scalingAdjustment!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("MetricIntervalLowerBound") {
                    self.metricIntervalLowerBound = dict["MetricIntervalLowerBound"] as! Double
                }
                if dict.keys.contains("MetricIntervalUpperBound") {
                    self.metricIntervalUpperBound = dict["MetricIntervalUpperBound"] as! Double
                }
                if dict.keys.contains("ScalingAdjustment") {
                    self.scalingAdjustment = dict["ScalingAdjustment"] as! Int32
                }
            }
        }
        public var adjustmentType: String?

        public var adjustmentValue: Int32?

        public var alarmDimensions: [DescribeScalingRulesResponseBody.ScalingRules.AlarmDimensions]?

        public var alarms: [DescribeScalingRulesResponseBody.ScalingRules.Alarms]?

        public var cooldown: Int32?

        public var disableScaleIn: Bool?

        public var estimatedInstanceWarmup: Int32?

        public var hybridMetrics: [DescribeScalingRulesResponseBody.ScalingRules.HybridMetrics]?

        public var hybridMonitorNamespace: String?

        public var initialMaxSize: Int32?

        public var maxSize: Int32?

        public var metricName: String?

        public var metricType: String?

        public var minAdjustmentMagnitude: Int32?

        public var minSize: Int32?

        public var predictiveScalingMode: String?

        public var predictiveTaskBufferTime: Int32?

        public var predictiveValueBehavior: String?

        public var predictiveValueBuffer: Int32?

        public var scaleInEvaluationCount: Int32?

        public var scaleOutEvaluationCount: Int32?

        public var scalingGroupId: String?

        public var scalingRuleAri: String?

        public var scalingRuleId: String?

        public var scalingRuleName: String?

        public var scalingRuleType: String?

        public var stepAdjustments: [DescribeScalingRulesResponseBody.ScalingRules.StepAdjustments]?

        public var targetValue: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.adjustmentType != nil {
                map["AdjustmentType"] = self.adjustmentType!
            }
            if self.adjustmentValue != nil {
                map["AdjustmentValue"] = self.adjustmentValue!
            }
            if self.alarmDimensions != nil {
                var tmp : [Any] = []
                for k in self.alarmDimensions! {
                    tmp.append(k.toMap())
                }
                map["AlarmDimensions"] = tmp
            }
            if self.alarms != nil {
                var tmp : [Any] = []
                for k in self.alarms! {
                    tmp.append(k.toMap())
                }
                map["Alarms"] = tmp
            }
            if self.cooldown != nil {
                map["Cooldown"] = self.cooldown!
            }
            if self.disableScaleIn != nil {
                map["DisableScaleIn"] = self.disableScaleIn!
            }
            if self.estimatedInstanceWarmup != nil {
                map["EstimatedInstanceWarmup"] = self.estimatedInstanceWarmup!
            }
            if self.hybridMetrics != nil {
                var tmp : [Any] = []
                for k in self.hybridMetrics! {
                    tmp.append(k.toMap())
                }
                map["HybridMetrics"] = tmp
            }
            if self.hybridMonitorNamespace != nil {
                map["HybridMonitorNamespace"] = self.hybridMonitorNamespace!
            }
            if self.initialMaxSize != nil {
                map["InitialMaxSize"] = self.initialMaxSize!
            }
            if self.maxSize != nil {
                map["MaxSize"] = self.maxSize!
            }
            if self.metricName != nil {
                map["MetricName"] = self.metricName!
            }
            if self.metricType != nil {
                map["MetricType"] = self.metricType!
            }
            if self.minAdjustmentMagnitude != nil {
                map["MinAdjustmentMagnitude"] = self.minAdjustmentMagnitude!
            }
            if self.minSize != nil {
                map["MinSize"] = self.minSize!
            }
            if self.predictiveScalingMode != nil {
                map["PredictiveScalingMode"] = self.predictiveScalingMode!
            }
            if self.predictiveTaskBufferTime != nil {
                map["PredictiveTaskBufferTime"] = self.predictiveTaskBufferTime!
            }
            if self.predictiveValueBehavior != nil {
                map["PredictiveValueBehavior"] = self.predictiveValueBehavior!
            }
            if self.predictiveValueBuffer != nil {
                map["PredictiveValueBuffer"] = self.predictiveValueBuffer!
            }
            if self.scaleInEvaluationCount != nil {
                map["ScaleInEvaluationCount"] = self.scaleInEvaluationCount!
            }
            if self.scaleOutEvaluationCount != nil {
                map["ScaleOutEvaluationCount"] = self.scaleOutEvaluationCount!
            }
            if self.scalingGroupId != nil {
                map["ScalingGroupId"] = self.scalingGroupId!
            }
            if self.scalingRuleAri != nil {
                map["ScalingRuleAri"] = self.scalingRuleAri!
            }
            if self.scalingRuleId != nil {
                map["ScalingRuleId"] = self.scalingRuleId!
            }
            if self.scalingRuleName != nil {
                map["ScalingRuleName"] = self.scalingRuleName!
            }
            if self.scalingRuleType != nil {
                map["ScalingRuleType"] = self.scalingRuleType!
            }
            if self.stepAdjustments != nil {
                var tmp : [Any] = []
                for k in self.stepAdjustments! {
                    tmp.append(k.toMap())
                }
                map["StepAdjustments"] = tmp
            }
            if self.targetValue != nil {
                map["TargetValue"] = self.targetValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AdjustmentType") {
                self.adjustmentType = dict["AdjustmentType"] as! String
            }
            if dict.keys.contains("AdjustmentValue") {
                self.adjustmentValue = dict["AdjustmentValue"] as! Int32
            }
            if dict.keys.contains("AlarmDimensions") {
                var tmp : [DescribeScalingRulesResponseBody.ScalingRules.AlarmDimensions] = []
                for v in dict["AlarmDimensions"] as! [Any] {
                    var model = DescribeScalingRulesResponseBody.ScalingRules.AlarmDimensions()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.alarmDimensions = tmp
            }
            if dict.keys.contains("Alarms") {
                var tmp : [DescribeScalingRulesResponseBody.ScalingRules.Alarms] = []
                for v in dict["Alarms"] as! [Any] {
                    var model = DescribeScalingRulesResponseBody.ScalingRules.Alarms()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.alarms = tmp
            }
            if dict.keys.contains("Cooldown") {
                self.cooldown = dict["Cooldown"] as! Int32
            }
            if dict.keys.contains("DisableScaleIn") {
                self.disableScaleIn = dict["DisableScaleIn"] as! Bool
            }
            if dict.keys.contains("EstimatedInstanceWarmup") {
                self.estimatedInstanceWarmup = dict["EstimatedInstanceWarmup"] as! Int32
            }
            if dict.keys.contains("HybridMetrics") {
                var tmp : [DescribeScalingRulesResponseBody.ScalingRules.HybridMetrics] = []
                for v in dict["HybridMetrics"] as! [Any] {
                    var model = DescribeScalingRulesResponseBody.ScalingRules.HybridMetrics()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.hybridMetrics = tmp
            }
            if dict.keys.contains("HybridMonitorNamespace") {
                self.hybridMonitorNamespace = dict["HybridMonitorNamespace"] as! String
            }
            if dict.keys.contains("InitialMaxSize") {
                self.initialMaxSize = dict["InitialMaxSize"] as! Int32
            }
            if dict.keys.contains("MaxSize") {
                self.maxSize = dict["MaxSize"] as! Int32
            }
            if dict.keys.contains("MetricName") {
                self.metricName = dict["MetricName"] as! String
            }
            if dict.keys.contains("MetricType") {
                self.metricType = dict["MetricType"] as! String
            }
            if dict.keys.contains("MinAdjustmentMagnitude") {
                self.minAdjustmentMagnitude = dict["MinAdjustmentMagnitude"] as! Int32
            }
            if dict.keys.contains("MinSize") {
                self.minSize = dict["MinSize"] as! Int32
            }
            if dict.keys.contains("PredictiveScalingMode") {
                self.predictiveScalingMode = dict["PredictiveScalingMode"] as! String
            }
            if dict.keys.contains("PredictiveTaskBufferTime") {
                self.predictiveTaskBufferTime = dict["PredictiveTaskBufferTime"] as! Int32
            }
            if dict.keys.contains("PredictiveValueBehavior") {
                self.predictiveValueBehavior = dict["PredictiveValueBehavior"] as! String
            }
            if dict.keys.contains("PredictiveValueBuffer") {
                self.predictiveValueBuffer = dict["PredictiveValueBuffer"] as! Int32
            }
            if dict.keys.contains("ScaleInEvaluationCount") {
                self.scaleInEvaluationCount = dict["ScaleInEvaluationCount"] as! Int32
            }
            if dict.keys.contains("ScaleOutEvaluationCount") {
                self.scaleOutEvaluationCount = dict["ScaleOutEvaluationCount"] as! Int32
            }
            if dict.keys.contains("ScalingGroupId") {
                self.scalingGroupId = dict["ScalingGroupId"] as! String
            }
            if dict.keys.contains("ScalingRuleAri") {
                self.scalingRuleAri = dict["ScalingRuleAri"] as! String
            }
            if dict.keys.contains("ScalingRuleId") {
                self.scalingRuleId = dict["ScalingRuleId"] as! String
            }
            if dict.keys.contains("ScalingRuleName") {
                self.scalingRuleName = dict["ScalingRuleName"] as! String
            }
            if dict.keys.contains("ScalingRuleType") {
                self.scalingRuleType = dict["ScalingRuleType"] as! String
            }
            if dict.keys.contains("StepAdjustments") {
                var tmp : [DescribeScalingRulesResponseBody.ScalingRules.StepAdjustments] = []
                for v in dict["StepAdjustments"] as! [Any] {
                    var model = DescribeScalingRulesResponseBody.ScalingRules.StepAdjustments()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.stepAdjustments = tmp
            }
            if dict.keys.contains("TargetValue") {
                self.targetValue = dict["TargetValue"] as! Double
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var scalingRules: [DescribeScalingRulesResponseBody.ScalingRules]?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingRules != nil {
            var tmp : [Any] = []
            for k in self.scalingRules! {
                tmp.append(k.toMap())
            }
            map["ScalingRules"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScalingRules") {
            var tmp : [DescribeScalingRulesResponseBody.ScalingRules] = []
            for v in dict["ScalingRules"] as! [Any] {
                var model = DescribeScalingRulesResponseBody.ScalingRules()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.scalingRules = tmp
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeScalingRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeScalingRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeScalingRulesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeScheduledTasksRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var recurrenceType: String?

    public var recurrenceValue: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var scalingGroupId: String?

    public var scheduledActions: [String]?

    public var scheduledTaskIds: [String]?

    public var scheduledTaskNames: [String]?

    public var taskEnabled: Bool?

    public var taskName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.recurrenceType != nil {
            map["RecurrenceType"] = self.recurrenceType!
        }
        if self.recurrenceValue != nil {
            map["RecurrenceValue"] = self.recurrenceValue!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        if self.scheduledActions != nil {
            map["ScheduledActions"] = self.scheduledActions!
        }
        if self.scheduledTaskIds != nil {
            map["ScheduledTaskIds"] = self.scheduledTaskIds!
        }
        if self.scheduledTaskNames != nil {
            map["ScheduledTaskNames"] = self.scheduledTaskNames!
        }
        if self.taskEnabled != nil {
            map["TaskEnabled"] = self.taskEnabled!
        }
        if self.taskName != nil {
            map["TaskName"] = self.taskName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RecurrenceType") {
            self.recurrenceType = dict["RecurrenceType"] as! String
        }
        if dict.keys.contains("RecurrenceValue") {
            self.recurrenceValue = dict["RecurrenceValue"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ScalingGroupId") {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
        if dict.keys.contains("ScheduledActions") {
            self.scheduledActions = dict["ScheduledActions"] as! [String]
        }
        if dict.keys.contains("ScheduledTaskIds") {
            self.scheduledTaskIds = dict["ScheduledTaskIds"] as! [String]
        }
        if dict.keys.contains("ScheduledTaskNames") {
            self.scheduledTaskNames = dict["ScheduledTaskNames"] as! [String]
        }
        if dict.keys.contains("TaskEnabled") {
            self.taskEnabled = dict["TaskEnabled"] as! Bool
        }
        if dict.keys.contains("TaskName") {
            self.taskName = dict["TaskName"] as! String
        }
    }
}

public class DescribeScheduledTasksResponseBody : Tea.TeaModel {
    public class ScheduledTasks : Tea.TeaModel {
        public var description_: String?

        public var desiredCapacity: Int32?

        public var launchExpirationTime: Int32?

        public var launchTime: String?

        public var maxValue: Int32?

        public var minValue: Int32?

        public var recurrenceEndTime: String?

        public var recurrenceType: String?

        public var recurrenceValue: String?

        public var scalingGroupId: String?

        public var scheduledAction: String?

        public var scheduledTaskId: String?

        public var scheduledTaskName: String?

        public var taskEnabled: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.desiredCapacity != nil {
                map["DesiredCapacity"] = self.desiredCapacity!
            }
            if self.launchExpirationTime != nil {
                map["LaunchExpirationTime"] = self.launchExpirationTime!
            }
            if self.launchTime != nil {
                map["LaunchTime"] = self.launchTime!
            }
            if self.maxValue != nil {
                map["MaxValue"] = self.maxValue!
            }
            if self.minValue != nil {
                map["MinValue"] = self.minValue!
            }
            if self.recurrenceEndTime != nil {
                map["RecurrenceEndTime"] = self.recurrenceEndTime!
            }
            if self.recurrenceType != nil {
                map["RecurrenceType"] = self.recurrenceType!
            }
            if self.recurrenceValue != nil {
                map["RecurrenceValue"] = self.recurrenceValue!
            }
            if self.scalingGroupId != nil {
                map["ScalingGroupId"] = self.scalingGroupId!
            }
            if self.scheduledAction != nil {
                map["ScheduledAction"] = self.scheduledAction!
            }
            if self.scheduledTaskId != nil {
                map["ScheduledTaskId"] = self.scheduledTaskId!
            }
            if self.scheduledTaskName != nil {
                map["ScheduledTaskName"] = self.scheduledTaskName!
            }
            if self.taskEnabled != nil {
                map["TaskEnabled"] = self.taskEnabled!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("DesiredCapacity") {
                self.desiredCapacity = dict["DesiredCapacity"] as! Int32
            }
            if dict.keys.contains("LaunchExpirationTime") {
                self.launchExpirationTime = dict["LaunchExpirationTime"] as! Int32
            }
            if dict.keys.contains("LaunchTime") {
                self.launchTime = dict["LaunchTime"] as! String
            }
            if dict.keys.contains("MaxValue") {
                self.maxValue = dict["MaxValue"] as! Int32
            }
            if dict.keys.contains("MinValue") {
                self.minValue = dict["MinValue"] as! Int32
            }
            if dict.keys.contains("RecurrenceEndTime") {
                self.recurrenceEndTime = dict["RecurrenceEndTime"] as! String
            }
            if dict.keys.contains("RecurrenceType") {
                self.recurrenceType = dict["RecurrenceType"] as! String
            }
            if dict.keys.contains("RecurrenceValue") {
                self.recurrenceValue = dict["RecurrenceValue"] as! String
            }
            if dict.keys.contains("ScalingGroupId") {
                self.scalingGroupId = dict["ScalingGroupId"] as! String
            }
            if dict.keys.contains("ScheduledAction") {
                self.scheduledAction = dict["ScheduledAction"] as! String
            }
            if dict.keys.contains("ScheduledTaskId") {
                self.scheduledTaskId = dict["ScheduledTaskId"] as! String
            }
            if dict.keys.contains("ScheduledTaskName") {
                self.scheduledTaskName = dict["ScheduledTaskName"] as! String
            }
            if dict.keys.contains("TaskEnabled") {
                self.taskEnabled = dict["TaskEnabled"] as! Bool
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var scheduledTasks: [DescribeScheduledTasksResponseBody.ScheduledTasks]?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scheduledTasks != nil {
            var tmp : [Any] = []
            for k in self.scheduledTasks! {
                tmp.append(k.toMap())
            }
            map["ScheduledTasks"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScheduledTasks") {
            var tmp : [DescribeScheduledTasksResponseBody.ScheduledTasks] = []
            for v in dict["ScheduledTasks"] as! [Any] {
                var model = DescribeScheduledTasksResponseBody.ScheduledTasks()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.scheduledTasks = tmp
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeScheduledTasksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeScheduledTasksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeScheduledTasksResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DetachAlbServerGroupsRequest : Tea.TeaModel {
    public class AlbServerGroups : Tea.TeaModel {
        public var albServerGroupId: String?

        public var port: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.albServerGroupId != nil {
                map["AlbServerGroupId"] = self.albServerGroupId!
            }
            if self.port != nil {
                map["Port"] = self.port!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AlbServerGroupId") {
                self.albServerGroupId = dict["AlbServerGroupId"] as! String
            }
            if dict.keys.contains("Port") {
                self.port = dict["Port"] as! Int32
            }
        }
    }
    public var albServerGroups: [DetachAlbServerGroupsRequest.AlbServerGroups]?

    public var clientToken: String?

    public var forceDetach: Bool?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.albServerGroups != nil {
            var tmp : [Any] = []
            for k in self.albServerGroups! {
                tmp.append(k.toMap())
            }
            map["AlbServerGroups"] = tmp
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.forceDetach != nil {
            map["ForceDetach"] = self.forceDetach!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlbServerGroups") {
            var tmp : [DetachAlbServerGroupsRequest.AlbServerGroups] = []
            for v in dict["AlbServerGroups"] as! [Any] {
                var model = DetachAlbServerGroupsRequest.AlbServerGroups()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.albServerGroups = tmp
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("ForceDetach") {
            self.forceDetach = dict["ForceDetach"] as! Bool
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScalingGroupId") {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
    }
}

public class DetachAlbServerGroupsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var scalingActivityId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingActivityId != nil {
            map["ScalingActivityId"] = self.scalingActivityId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScalingActivityId") {
            self.scalingActivityId = dict["ScalingActivityId"] as! String
        }
    }
}

public class DetachAlbServerGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DetachAlbServerGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DetachAlbServerGroupsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DetachDBInstancesRequest : Tea.TeaModel {
    public var clientToken: String?

    public var DBInstances: [String]?

    public var forceDetach: Bool?

    public var ownerId: Int64?

    public var regionId: String?

    public var removeSecurityGroup: Bool?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.DBInstances != nil {
            map["DBInstances"] = self.DBInstances!
        }
        if self.forceDetach != nil {
            map["ForceDetach"] = self.forceDetach!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.removeSecurityGroup != nil {
            map["RemoveSecurityGroup"] = self.removeSecurityGroup!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DBInstances") {
            self.DBInstances = dict["DBInstances"] as! [String]
        }
        if dict.keys.contains("ForceDetach") {
            self.forceDetach = dict["ForceDetach"] as! Bool
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RemoveSecurityGroup") {
            self.removeSecurityGroup = dict["RemoveSecurityGroup"] as! Bool
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScalingGroupId") {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
    }
}

public class DetachDBInstancesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DetachDBInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DetachDBInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DetachDBInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DetachInstancesRequest : Tea.TeaModel {
    public var clientToken: String?

    public var decreaseDesiredCapacity: Bool?

    public var detachOption: String?

    public var ignoreInvalidInstance: Bool?

    public var instanceIds: [String]?

    public var lifecycleHook: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.decreaseDesiredCapacity != nil {
            map["DecreaseDesiredCapacity"] = self.decreaseDesiredCapacity!
        }
        if self.detachOption != nil {
            map["DetachOption"] = self.detachOption!
        }
        if self.ignoreInvalidInstance != nil {
            map["IgnoreInvalidInstance"] = self.ignoreInvalidInstance!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.lifecycleHook != nil {
            map["LifecycleHook"] = self.lifecycleHook!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DecreaseDesiredCapacity") {
            self.decreaseDesiredCapacity = dict["DecreaseDesiredCapacity"] as! Bool
        }
        if dict.keys.contains("DetachOption") {
            self.detachOption = dict["DetachOption"] as! String
        }
        if dict.keys.contains("IgnoreInvalidInstance") {
            self.ignoreInvalidInstance = dict["IgnoreInvalidInstance"] as! Bool
        }
        if dict.keys.contains("InstanceIds") {
            self.instanceIds = dict["InstanceIds"] as! [String]
        }
        if dict.keys.contains("LifecycleHook") {
            self.lifecycleHook = dict["LifecycleHook"] as! Bool
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ScalingGroupId") {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
    }
}

public class DetachInstancesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var scalingActivityId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingActivityId != nil {
            map["ScalingActivityId"] = self.scalingActivityId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScalingActivityId") {
            self.scalingActivityId = dict["ScalingActivityId"] as! String
        }
    }
}

public class DetachInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DetachInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DetachInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DetachLoadBalancersRequest : Tea.TeaModel {
    public var async: Bool?

    public var clientToken: String?

    public var forceDetach: Bool?

    public var loadBalancers: [String]?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.async != nil {
            map["Async"] = self.async!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.forceDetach != nil {
            map["ForceDetach"] = self.forceDetach!
        }
        if self.loadBalancers != nil {
            map["LoadBalancers"] = self.loadBalancers!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Async") {
            self.async = dict["Async"] as! Bool
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("ForceDetach") {
            self.forceDetach = dict["ForceDetach"] as! Bool
        }
        if dict.keys.contains("LoadBalancers") {
            self.loadBalancers = dict["LoadBalancers"] as! [String]
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScalingGroupId") {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
    }
}

public class DetachLoadBalancersResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var scalingActivityId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingActivityId != nil {
            map["ScalingActivityId"] = self.scalingActivityId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScalingActivityId") {
            self.scalingActivityId = dict["ScalingActivityId"] as! String
        }
    }
}

public class DetachLoadBalancersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DetachLoadBalancersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DetachLoadBalancersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DetachServerGroupsRequest : Tea.TeaModel {
    public class ServerGroups : Tea.TeaModel {
        public var port: Int32?

        public var serverGroupId: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.port != nil {
                map["Port"] = self.port!
            }
            if self.serverGroupId != nil {
                map["ServerGroupId"] = self.serverGroupId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Port") {
                self.port = dict["Port"] as! Int32
            }
            if dict.keys.contains("ServerGroupId") {
                self.serverGroupId = dict["ServerGroupId"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var clientToken: String?

    public var forceDetach: Bool?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public var serverGroups: [DetachServerGroupsRequest.ServerGroups]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.forceDetach != nil {
            map["ForceDetach"] = self.forceDetach!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        if self.serverGroups != nil {
            var tmp : [Any] = []
            for k in self.serverGroups! {
                tmp.append(k.toMap())
            }
            map["ServerGroups"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("ForceDetach") {
            self.forceDetach = dict["ForceDetach"] as! Bool
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScalingGroupId") {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
        if dict.keys.contains("ServerGroups") {
            var tmp : [DetachServerGroupsRequest.ServerGroups] = []
            for v in dict["ServerGroups"] as! [Any] {
                var model = DetachServerGroupsRequest.ServerGroups()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.serverGroups = tmp
        }
    }
}

public class DetachServerGroupsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var scalingActivityId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingActivityId != nil {
            map["ScalingActivityId"] = self.scalingActivityId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScalingActivityId") {
            self.scalingActivityId = dict["ScalingActivityId"] as! String
        }
    }
}

public class DetachServerGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DetachServerGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DetachServerGroupsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DetachVServerGroupsRequest : Tea.TeaModel {
    public class VServerGroups : Tea.TeaModel {
        public class VServerGroupAttributes : Tea.TeaModel {
            public var port: Int32?

            public var VServerGroupId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.VServerGroupId != nil {
                    map["VServerGroupId"] = self.VServerGroupId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Port") {
                    self.port = dict["Port"] as! Int32
                }
                if dict.keys.contains("VServerGroupId") {
                    self.VServerGroupId = dict["VServerGroupId"] as! String
                }
            }
        }
        public var loadBalancerId: String?

        public var VServerGroupAttributes: [DetachVServerGroupsRequest.VServerGroups.VServerGroupAttributes]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.loadBalancerId != nil {
                map["LoadBalancerId"] = self.loadBalancerId!
            }
            if self.VServerGroupAttributes != nil {
                var tmp : [Any] = []
                for k in self.VServerGroupAttributes! {
                    tmp.append(k.toMap())
                }
                map["VServerGroupAttributes"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LoadBalancerId") {
                self.loadBalancerId = dict["LoadBalancerId"] as! String
            }
            if dict.keys.contains("VServerGroupAttributes") {
                var tmp : [DetachVServerGroupsRequest.VServerGroups.VServerGroupAttributes] = []
                for v in dict["VServerGroupAttributes"] as! [Any] {
                    var model = DetachVServerGroupsRequest.VServerGroups.VServerGroupAttributes()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.VServerGroupAttributes = tmp
            }
        }
    }
    public var clientToken: String?

    public var forceDetach: Bool?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public var VServerGroups: [DetachVServerGroupsRequest.VServerGroups]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.forceDetach != nil {
            map["ForceDetach"] = self.forceDetach!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        if self.VServerGroups != nil {
            var tmp : [Any] = []
            for k in self.VServerGroups! {
                tmp.append(k.toMap())
            }
            map["VServerGroups"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("ForceDetach") {
            self.forceDetach = dict["ForceDetach"] as! Bool
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScalingGroupId") {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
        if dict.keys.contains("VServerGroups") {
            var tmp : [DetachVServerGroupsRequest.VServerGroups] = []
            for v in dict["VServerGroups"] as! [Any] {
                var model = DetachVServerGroupsRequest.VServerGroups()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.VServerGroups = tmp
        }
    }
}

public class DetachVServerGroupsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DetachVServerGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DetachVServerGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DetachVServerGroupsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DisableAlarmRequest : Tea.TeaModel {
    public var alarmTaskId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alarmTaskId != nil {
            map["AlarmTaskId"] = self.alarmTaskId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlarmTaskId") {
            self.alarmTaskId = dict["AlarmTaskId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
    }
}

public class DisableAlarmResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DisableAlarmResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DisableAlarmResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DisableAlarmResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DisableScalingGroupRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ScalingGroupId") {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
    }
}

public class DisableScalingGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DisableScalingGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DisableScalingGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DisableScalingGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class EnableAlarmRequest : Tea.TeaModel {
    public var alarmTaskId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alarmTaskId != nil {
            map["AlarmTaskId"] = self.alarmTaskId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlarmTaskId") {
            self.alarmTaskId = dict["AlarmTaskId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
    }
}

public class EnableAlarmResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class EnableAlarmResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EnableAlarmResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = EnableAlarmResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class EnableScalingGroupRequest : Tea.TeaModel {
    public class LaunchTemplateOverrides : Tea.TeaModel {
        public var instanceType: String?

        public var weightedCapacity: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.weightedCapacity != nil {
                map["WeightedCapacity"] = self.weightedCapacity!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceType") {
                self.instanceType = dict["InstanceType"] as! String
            }
            if dict.keys.contains("WeightedCapacity") {
                self.weightedCapacity = dict["WeightedCapacity"] as! Int32
            }
        }
    }
    public var activeScalingConfigurationId: String?

    public var instanceIds: [String]?

    public var launchTemplateId: String?

    public var launchTemplateOverrides: [EnableScalingGroupRequest.LaunchTemplateOverrides]?

    public var launchTemplateVersion: String?

    public var loadBalancerWeights: [Int32]?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.activeScalingConfigurationId != nil {
            map["ActiveScalingConfigurationId"] = self.activeScalingConfigurationId!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.launchTemplateId != nil {
            map["LaunchTemplateId"] = self.launchTemplateId!
        }
        if self.launchTemplateOverrides != nil {
            var tmp : [Any] = []
            for k in self.launchTemplateOverrides! {
                tmp.append(k.toMap())
            }
            map["LaunchTemplateOverrides"] = tmp
        }
        if self.launchTemplateVersion != nil {
            map["LaunchTemplateVersion"] = self.launchTemplateVersion!
        }
        if self.loadBalancerWeights != nil {
            map["LoadBalancerWeights"] = self.loadBalancerWeights!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ActiveScalingConfigurationId") {
            self.activeScalingConfigurationId = dict["ActiveScalingConfigurationId"] as! String
        }
        if dict.keys.contains("InstanceIds") {
            self.instanceIds = dict["InstanceIds"] as! [String]
        }
        if dict.keys.contains("LaunchTemplateId") {
            self.launchTemplateId = dict["LaunchTemplateId"] as! String
        }
        if dict.keys.contains("LaunchTemplateOverrides") {
            var tmp : [EnableScalingGroupRequest.LaunchTemplateOverrides] = []
            for v in dict["LaunchTemplateOverrides"] as! [Any] {
                var model = EnableScalingGroupRequest.LaunchTemplateOverrides()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.launchTemplateOverrides = tmp
        }
        if dict.keys.contains("LaunchTemplateVersion") {
            self.launchTemplateVersion = dict["LaunchTemplateVersion"] as! String
        }
        if dict.keys.contains("LoadBalancerWeights") {
            self.loadBalancerWeights = dict["LoadBalancerWeights"] as! [Int32]
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ScalingGroupId") {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
    }
}

public class EnableScalingGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class EnableScalingGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EnableScalingGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = EnableScalingGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class EnterStandbyRequest : Tea.TeaModel {
    public var async: Bool?

    public var clientToken: String?

    public var instanceIds: [String]?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.async != nil {
            map["Async"] = self.async!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Async") {
            self.async = dict["Async"] as! Bool
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("InstanceIds") {
            self.instanceIds = dict["InstanceIds"] as! [String]
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScalingGroupId") {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
    }
}

public class EnterStandbyResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var scalingActivityId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingActivityId != nil {
            map["ScalingActivityId"] = self.scalingActivityId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScalingActivityId") {
            self.scalingActivityId = dict["ScalingActivityId"] as! String
        }
    }
}

public class EnterStandbyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EnterStandbyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = EnterStandbyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ExecuteScalingRuleRequest : Tea.TeaModel {
    public var breachThreshold: Double?

    public var clientToken: String?

    public var metricValue: Double?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var scalingRuleAri: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.breachThreshold != nil {
            map["BreachThreshold"] = self.breachThreshold!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.metricValue != nil {
            map["MetricValue"] = self.metricValue!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.scalingRuleAri != nil {
            map["ScalingRuleAri"] = self.scalingRuleAri!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BreachThreshold") {
            self.breachThreshold = dict["BreachThreshold"] as! Double
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("MetricValue") {
            self.metricValue = dict["MetricValue"] as! Double
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ScalingRuleAri") {
            self.scalingRuleAri = dict["ScalingRuleAri"] as! String
        }
    }
}

public class ExecuteScalingRuleResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var scalingActivityId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingActivityId != nil {
            map["ScalingActivityId"] = self.scalingActivityId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScalingActivityId") {
            self.scalingActivityId = dict["ScalingActivityId"] as! String
        }
    }
}

public class ExecuteScalingRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ExecuteScalingRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ExecuteScalingRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ExitStandbyRequest : Tea.TeaModel {
    public var async: Bool?

    public var clientToken: String?

    public var instanceIds: [String]?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.async != nil {
            map["Async"] = self.async!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Async") {
            self.async = dict["Async"] as! Bool
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("InstanceIds") {
            self.instanceIds = dict["InstanceIds"] as! [String]
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScalingGroupId") {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
    }
}

public class ExitStandbyResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var scalingActivityId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingActivityId != nil {
            map["ScalingActivityId"] = self.scalingActivityId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScalingActivityId") {
            self.scalingActivityId = dict["ScalingActivityId"] as! String
        }
    }
}

public class ExitStandbyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ExitStandbyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ExitStandbyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListTagKeysRequest : Tea.TeaModel {
    public var nextToken: String?

    public var ownerId: Int64?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
    }
}

public class ListTagKeysResponseBody : Tea.TeaModel {
    public var keys: [String]?

    public var nextToken: String?

    public var pageSize: Int32?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.keys != nil {
            map["Keys"] = self.keys!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Keys") {
            self.keys = dict["Keys"] as! [String]
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListTagKeysResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTagKeysResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListTagKeysResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListTagResourcesRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var nextToken: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceIds: [String]?

    public var resourceOwnerAccount: String?

    public var resourceType: String?

    public var tags: [ListTagResourcesRequest.Tags]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceIds != nil {
            map["ResourceIds"] = self.resourceIds!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceIds") {
            self.resourceIds = dict["ResourceIds"] as! [String]
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("Tags") {
            var tmp : [ListTagResourcesRequest.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = ListTagResourcesRequest.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
    }
}

public class ListTagResourcesResponseBody : Tea.TeaModel {
    public class TagResources : Tea.TeaModel {
        public var propagate: Bool?

        public var resourceId: String?

        public var resourceType: String?

        public var tagKey: String?

        public var tagValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.propagate != nil {
                map["Propagate"] = self.propagate!
            }
            if self.resourceId != nil {
                map["ResourceId"] = self.resourceId!
            }
            if self.resourceType != nil {
                map["ResourceType"] = self.resourceType!
            }
            if self.tagKey != nil {
                map["TagKey"] = self.tagKey!
            }
            if self.tagValue != nil {
                map["TagValue"] = self.tagValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Propagate") {
                self.propagate = dict["Propagate"] as! Bool
            }
            if dict.keys.contains("ResourceId") {
                self.resourceId = dict["ResourceId"] as! String
            }
            if dict.keys.contains("ResourceType") {
                self.resourceType = dict["ResourceType"] as! String
            }
            if dict.keys.contains("TagKey") {
                self.tagKey = dict["TagKey"] as! String
            }
            if dict.keys.contains("TagValue") {
                self.tagValue = dict["TagValue"] as! String
            }
        }
    }
    public var nextToken: String?

    public var requestId: String?

    public var tagResources: [ListTagResourcesResponseBody.TagResources]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.tagResources != nil {
            var tmp : [Any] = []
            for k in self.tagResources! {
                tmp.append(k.toMap())
            }
            map["TagResources"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TagResources") {
            var tmp : [ListTagResourcesResponseBody.TagResources] = []
            for v in dict["TagResources"] as! [Any] {
                var model = ListTagResourcesResponseBody.TagResources()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tagResources = tmp
        }
    }
}

public class ListTagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListTagResourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListTagValuesRequest : Tea.TeaModel {
    public var key: String?

    public var nextToken: String?

    public var ownerId: Int64?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.key != nil {
            map["Key"] = self.key!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Key") {
            self.key = dict["Key"] as! String
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
    }
}

public class ListTagValuesResponseBody : Tea.TeaModel {
    public var nextToken: String?

    public var pageSize: Int32?

    public var requestId: String?

    public var values: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.values != nil {
            map["Values"] = self.values!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Values") {
            self.values = dict["Values"] as! [String]
        }
    }
}

public class ListTagValuesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTagValuesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListTagValuesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyAlarmRequest : Tea.TeaModel {
    public class Dimensions : Tea.TeaModel {
        public var dimensionKey: String?

        public var dimensionValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dimensionKey != nil {
                map["DimensionKey"] = self.dimensionKey!
            }
            if self.dimensionValue != nil {
                map["DimensionValue"] = self.dimensionValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DimensionKey") {
                self.dimensionKey = dict["DimensionKey"] as! String
            }
            if dict.keys.contains("DimensionValue") {
                self.dimensionValue = dict["DimensionValue"] as! String
            }
        }
    }
    public class Expressions : Tea.TeaModel {
        public var comparisonOperator: String?

        public var metricName: String?

        public var period: Int32?

        public var statistics: String?

        public var threshold: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.comparisonOperator != nil {
                map["ComparisonOperator"] = self.comparisonOperator!
            }
            if self.metricName != nil {
                map["MetricName"] = self.metricName!
            }
            if self.period != nil {
                map["Period"] = self.period!
            }
            if self.statistics != nil {
                map["Statistics"] = self.statistics!
            }
            if self.threshold != nil {
                map["Threshold"] = self.threshold!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ComparisonOperator") {
                self.comparisonOperator = dict["ComparisonOperator"] as! String
            }
            if dict.keys.contains("MetricName") {
                self.metricName = dict["MetricName"] as! String
            }
            if dict.keys.contains("Period") {
                self.period = dict["Period"] as! Int32
            }
            if dict.keys.contains("Statistics") {
                self.statistics = dict["Statistics"] as! String
            }
            if dict.keys.contains("Threshold") {
                self.threshold = dict["Threshold"] as! Double
            }
        }
    }
    public var alarmActions: [String]?

    public var alarmTaskId: String?

    public var comparisonOperator: String?

    public var description_: String?

    public var dimensions: [ModifyAlarmRequest.Dimensions]?

    public var effective: String?

    public var evaluationCount: Int32?

    public var expressions: [ModifyAlarmRequest.Expressions]?

    public var expressionsLogicOperator: String?

    public var groupId: Int32?

    public var metricName: String?

    public var metricType: String?

    public var name: String?

    public var ownerId: Int64?

    public var period: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var statistics: String?

    public var threshold: Double?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alarmActions != nil {
            map["AlarmActions"] = self.alarmActions!
        }
        if self.alarmTaskId != nil {
            map["AlarmTaskId"] = self.alarmTaskId!
        }
        if self.comparisonOperator != nil {
            map["ComparisonOperator"] = self.comparisonOperator!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.dimensions != nil {
            var tmp : [Any] = []
            for k in self.dimensions! {
                tmp.append(k.toMap())
            }
            map["Dimensions"] = tmp
        }
        if self.effective != nil {
            map["Effective"] = self.effective!
        }
        if self.evaluationCount != nil {
            map["EvaluationCount"] = self.evaluationCount!
        }
        if self.expressions != nil {
            var tmp : [Any] = []
            for k in self.expressions! {
                tmp.append(k.toMap())
            }
            map["Expressions"] = tmp
        }
        if self.expressionsLogicOperator != nil {
            map["ExpressionsLogicOperator"] = self.expressionsLogicOperator!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.metricName != nil {
            map["MetricName"] = self.metricName!
        }
        if self.metricType != nil {
            map["MetricType"] = self.metricType!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.statistics != nil {
            map["Statistics"] = self.statistics!
        }
        if self.threshold != nil {
            map["Threshold"] = self.threshold!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlarmActions") {
            self.alarmActions = dict["AlarmActions"] as! [String]
        }
        if dict.keys.contains("AlarmTaskId") {
            self.alarmTaskId = dict["AlarmTaskId"] as! String
        }
        if dict.keys.contains("ComparisonOperator") {
            self.comparisonOperator = dict["ComparisonOperator"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Dimensions") {
            var tmp : [ModifyAlarmRequest.Dimensions] = []
            for v in dict["Dimensions"] as! [Any] {
                var model = ModifyAlarmRequest.Dimensions()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.dimensions = tmp
        }
        if dict.keys.contains("Effective") {
            self.effective = dict["Effective"] as! String
        }
        if dict.keys.contains("EvaluationCount") {
            self.evaluationCount = dict["EvaluationCount"] as! Int32
        }
        if dict.keys.contains("Expressions") {
            var tmp : [ModifyAlarmRequest.Expressions] = []
            for v in dict["Expressions"] as! [Any] {
                var model = ModifyAlarmRequest.Expressions()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.expressions = tmp
        }
        if dict.keys.contains("ExpressionsLogicOperator") {
            self.expressionsLogicOperator = dict["ExpressionsLogicOperator"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! Int32
        }
        if dict.keys.contains("MetricName") {
            self.metricName = dict["MetricName"] as! String
        }
        if dict.keys.contains("MetricType") {
            self.metricType = dict["MetricType"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("Statistics") {
            self.statistics = dict["Statistics"] as! String
        }
        if dict.keys.contains("Threshold") {
            self.threshold = dict["Threshold"] as! Double
        }
    }
}

public class ModifyAlarmResponseBody : Tea.TeaModel {
    public var alarmTaskId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alarmTaskId != nil {
            map["AlarmTaskId"] = self.alarmTaskId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlarmTaskId") {
            self.alarmTaskId = dict["AlarmTaskId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyAlarmResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyAlarmResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyAlarmResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyAlertConfigurationRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scaleStatuses: [String]?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scaleStatuses != nil {
            map["ScaleStatuses"] = self.scaleStatuses!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScaleStatuses") {
            self.scaleStatuses = dict["ScaleStatuses"] as! [String]
        }
        if dict.keys.contains("ScalingGroupId") {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
    }
}

public class ModifyAlertConfigurationResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyAlertConfigurationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyAlertConfigurationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyAlertConfigurationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyEciScalingConfigurationRequest : Tea.TeaModel {
    public class AcrRegistryInfos : Tea.TeaModel {
        public var domains: [String]?

        public var instanceId: String?

        public var instanceName: String?

        public var regionId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.domains != nil {
                map["Domains"] = self.domains!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Domains") {
                self.domains = dict["Domains"] as! [String]
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("InstanceName") {
                self.instanceName = dict["InstanceName"] as! String
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
        }
    }
    public class Containers : Tea.TeaModel {
        public class LivenessProbe : Tea.TeaModel {
            public class Exec : Tea.TeaModel {
                public var commands: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.commands != nil {
                        map["Commands"] = self.commands!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Commands") {
                        self.commands = dict["Commands"] as! [String]
                    }
                }
            }
            public class HttpGet : Tea.TeaModel {
                public var path: String?

                public var port: Int32?

                public var scheme: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.path != nil {
                        map["Path"] = self.path!
                    }
                    if self.port != nil {
                        map["Port"] = self.port!
                    }
                    if self.scheme != nil {
                        map["Scheme"] = self.scheme!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Path") {
                        self.path = dict["Path"] as! String
                    }
                    if dict.keys.contains("Port") {
                        self.port = dict["Port"] as! Int32
                    }
                    if dict.keys.contains("Scheme") {
                        self.scheme = dict["Scheme"] as! String
                    }
                }
            }
            public class TcpSocket : Tea.TeaModel {
                public var port: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.port != nil {
                        map["Port"] = self.port!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Port") {
                        self.port = dict["Port"] as! Int32
                    }
                }
            }
            public var exec: ModifyEciScalingConfigurationRequest.Containers.LivenessProbe.Exec?

            public var failureThreshold: Int32?

            public var httpGet: ModifyEciScalingConfigurationRequest.Containers.LivenessProbe.HttpGet?

            public var initialDelaySeconds: Int32?

            public var periodSeconds: Int32?

            public var successThreshold: Int32?

            public var tcpSocket: ModifyEciScalingConfigurationRequest.Containers.LivenessProbe.TcpSocket?

            public var timeoutSeconds: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.exec?.validate()
                try self.httpGet?.validate()
                try self.tcpSocket?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.exec != nil {
                    map["Exec"] = self.exec?.toMap()
                }
                if self.failureThreshold != nil {
                    map["FailureThreshold"] = self.failureThreshold!
                }
                if self.httpGet != nil {
                    map["HttpGet"] = self.httpGet?.toMap()
                }
                if self.initialDelaySeconds != nil {
                    map["InitialDelaySeconds"] = self.initialDelaySeconds!
                }
                if self.periodSeconds != nil {
                    map["PeriodSeconds"] = self.periodSeconds!
                }
                if self.successThreshold != nil {
                    map["SuccessThreshold"] = self.successThreshold!
                }
                if self.tcpSocket != nil {
                    map["TcpSocket"] = self.tcpSocket?.toMap()
                }
                if self.timeoutSeconds != nil {
                    map["TimeoutSeconds"] = self.timeoutSeconds!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Exec") {
                    var model = ModifyEciScalingConfigurationRequest.Containers.LivenessProbe.Exec()
                    model.fromMap(dict["Exec"] as! [String: Any])
                    self.exec = model
                }
                if dict.keys.contains("FailureThreshold") {
                    self.failureThreshold = dict["FailureThreshold"] as! Int32
                }
                if dict.keys.contains("HttpGet") {
                    var model = ModifyEciScalingConfigurationRequest.Containers.LivenessProbe.HttpGet()
                    model.fromMap(dict["HttpGet"] as! [String: Any])
                    self.httpGet = model
                }
                if dict.keys.contains("InitialDelaySeconds") {
                    self.initialDelaySeconds = dict["InitialDelaySeconds"] as! Int32
                }
                if dict.keys.contains("PeriodSeconds") {
                    self.periodSeconds = dict["PeriodSeconds"] as! Int32
                }
                if dict.keys.contains("SuccessThreshold") {
                    self.successThreshold = dict["SuccessThreshold"] as! Int32
                }
                if dict.keys.contains("TcpSocket") {
                    var model = ModifyEciScalingConfigurationRequest.Containers.LivenessProbe.TcpSocket()
                    model.fromMap(dict["TcpSocket"] as! [String: Any])
                    self.tcpSocket = model
                }
                if dict.keys.contains("TimeoutSeconds") {
                    self.timeoutSeconds = dict["TimeoutSeconds"] as! Int32
                }
            }
        }
        public class ReadinessProbe : Tea.TeaModel {
            public class Exec : Tea.TeaModel {
                public var commands: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.commands != nil {
                        map["Commands"] = self.commands!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Commands") {
                        self.commands = dict["Commands"] as! [String]
                    }
                }
            }
            public class HttpGet : Tea.TeaModel {
                public var path: String?

                public var port: Int32?

                public var scheme: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.path != nil {
                        map["Path"] = self.path!
                    }
                    if self.port != nil {
                        map["Port"] = self.port!
                    }
                    if self.scheme != nil {
                        map["Scheme"] = self.scheme!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Path") {
                        self.path = dict["Path"] as! String
                    }
                    if dict.keys.contains("Port") {
                        self.port = dict["Port"] as! Int32
                    }
                    if dict.keys.contains("Scheme") {
                        self.scheme = dict["Scheme"] as! String
                    }
                }
            }
            public class TcpSocket : Tea.TeaModel {
                public var port: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.port != nil {
                        map["Port"] = self.port!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Port") {
                        self.port = dict["Port"] as! Int32
                    }
                }
            }
            public var exec: ModifyEciScalingConfigurationRequest.Containers.ReadinessProbe.Exec?

            public var failureThreshold: Int32?

            public var httpGet: ModifyEciScalingConfigurationRequest.Containers.ReadinessProbe.HttpGet?

            public var initialDelaySeconds: Int32?

            public var periodSeconds: Int32?

            public var successThreshold: Int32?

            public var tcpSocket: ModifyEciScalingConfigurationRequest.Containers.ReadinessProbe.TcpSocket?

            public var timeoutSeconds: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.exec?.validate()
                try self.httpGet?.validate()
                try self.tcpSocket?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.exec != nil {
                    map["Exec"] = self.exec?.toMap()
                }
                if self.failureThreshold != nil {
                    map["FailureThreshold"] = self.failureThreshold!
                }
                if self.httpGet != nil {
                    map["HttpGet"] = self.httpGet?.toMap()
                }
                if self.initialDelaySeconds != nil {
                    map["InitialDelaySeconds"] = self.initialDelaySeconds!
                }
                if self.periodSeconds != nil {
                    map["PeriodSeconds"] = self.periodSeconds!
                }
                if self.successThreshold != nil {
                    map["SuccessThreshold"] = self.successThreshold!
                }
                if self.tcpSocket != nil {
                    map["TcpSocket"] = self.tcpSocket?.toMap()
                }
                if self.timeoutSeconds != nil {
                    map["TimeoutSeconds"] = self.timeoutSeconds!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Exec") {
                    var model = ModifyEciScalingConfigurationRequest.Containers.ReadinessProbe.Exec()
                    model.fromMap(dict["Exec"] as! [String: Any])
                    self.exec = model
                }
                if dict.keys.contains("FailureThreshold") {
                    self.failureThreshold = dict["FailureThreshold"] as! Int32
                }
                if dict.keys.contains("HttpGet") {
                    var model = ModifyEciScalingConfigurationRequest.Containers.ReadinessProbe.HttpGet()
                    model.fromMap(dict["HttpGet"] as! [String: Any])
                    self.httpGet = model
                }
                if dict.keys.contains("InitialDelaySeconds") {
                    self.initialDelaySeconds = dict["InitialDelaySeconds"] as! Int32
                }
                if dict.keys.contains("PeriodSeconds") {
                    self.periodSeconds = dict["PeriodSeconds"] as! Int32
                }
                if dict.keys.contains("SuccessThreshold") {
                    self.successThreshold = dict["SuccessThreshold"] as! Int32
                }
                if dict.keys.contains("TcpSocket") {
                    var model = ModifyEciScalingConfigurationRequest.Containers.ReadinessProbe.TcpSocket()
                    model.fromMap(dict["TcpSocket"] as! [String: Any])
                    self.tcpSocket = model
                }
                if dict.keys.contains("TimeoutSeconds") {
                    self.timeoutSeconds = dict["TimeoutSeconds"] as! Int32
                }
            }
        }
        public class SecurityContext : Tea.TeaModel {
            public class Capability : Tea.TeaModel {
                public var adds: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.adds != nil {
                        map["Adds"] = self.adds!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Adds") {
                        self.adds = dict["Adds"] as! [String]
                    }
                }
            }
            public var capability: ModifyEciScalingConfigurationRequest.Containers.SecurityContext.Capability?

            public var readOnlyRootFilesystem: Bool?

            public var runAsUser: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.capability?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.capability != nil {
                    map["Capability"] = self.capability?.toMap()
                }
                if self.readOnlyRootFilesystem != nil {
                    map["ReadOnlyRootFilesystem"] = self.readOnlyRootFilesystem!
                }
                if self.runAsUser != nil {
                    map["RunAsUser"] = self.runAsUser!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Capability") {
                    var model = ModifyEciScalingConfigurationRequest.Containers.SecurityContext.Capability()
                    model.fromMap(dict["Capability"] as! [String: Any])
                    self.capability = model
                }
                if dict.keys.contains("ReadOnlyRootFilesystem") {
                    self.readOnlyRootFilesystem = dict["ReadOnlyRootFilesystem"] as! Bool
                }
                if dict.keys.contains("RunAsUser") {
                    self.runAsUser = dict["RunAsUser"] as! Int64
                }
            }
        }
        public class EnvironmentVars : Tea.TeaModel {
            public class FieldRef : Tea.TeaModel {
                public var fieldPath: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.fieldPath != nil {
                        map["FieldPath"] = self.fieldPath!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("FieldPath") {
                        self.fieldPath = dict["FieldPath"] as! String
                    }
                }
            }
            public var fieldRef: ModifyEciScalingConfigurationRequest.Containers.EnvironmentVars.FieldRef?

            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.fieldRef?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fieldRef != nil {
                    map["FieldRef"] = self.fieldRef?.toMap()
                }
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FieldRef") {
                    var model = ModifyEciScalingConfigurationRequest.Containers.EnvironmentVars.FieldRef()
                    model.fromMap(dict["FieldRef"] as! [String: Any])
                    self.fieldRef = model
                }
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public class Ports : Tea.TeaModel {
            public var port: Int32?

            public var protocol_: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.protocol_ != nil {
                    map["Protocol"] = self.protocol_!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Port") {
                    self.port = dict["Port"] as! Int32
                }
                if dict.keys.contains("Protocol") {
                    self.protocol_ = dict["Protocol"] as! String
                }
            }
        }
        public class VolumeMounts : Tea.TeaModel {
            public var mountPath: String?

            public var mountPropagation: String?

            public var name: String?

            public var readOnly: Bool?

            public var subPath: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.mountPath != nil {
                    map["MountPath"] = self.mountPath!
                }
                if self.mountPropagation != nil {
                    map["MountPropagation"] = self.mountPropagation!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.readOnly != nil {
                    map["ReadOnly"] = self.readOnly!
                }
                if self.subPath != nil {
                    map["SubPath"] = self.subPath!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("MountPath") {
                    self.mountPath = dict["MountPath"] as! String
                }
                if dict.keys.contains("MountPropagation") {
                    self.mountPropagation = dict["MountPropagation"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("ReadOnly") {
                    self.readOnly = dict["ReadOnly"] as! Bool
                }
                if dict.keys.contains("SubPath") {
                    self.subPath = dict["SubPath"] as! String
                }
            }
        }
        public var livenessProbe: ModifyEciScalingConfigurationRequest.Containers.LivenessProbe?

        public var readinessProbe: ModifyEciScalingConfigurationRequest.Containers.ReadinessProbe?

        public var securityContext: ModifyEciScalingConfigurationRequest.Containers.SecurityContext?

        public var args: [String]?

        public var commands: [String]?

        public var cpu: Double?

        public var environmentVars: [ModifyEciScalingConfigurationRequest.Containers.EnvironmentVars]?

        public var gpu: Int32?

        public var image: String?

        public var imagePullPolicy: String?

        public var lifecyclePostStartHandlerExecs: [String]?

        public var lifecyclePostStartHandlerHttpGetHost: String?

        public var lifecyclePostStartHandlerHttpGetPath: String?

        public var lifecyclePostStartHandlerHttpGetPort: Int32?

        public var lifecyclePostStartHandlerHttpGetScheme: String?

        public var lifecyclePostStartHandlerTcpSocketHost: String?

        public var lifecyclePostStartHandlerTcpSocketPort: Int32?

        public var lifecyclePreStopHandlerExecs: [String]?

        public var lifecyclePreStopHandlerHttpGetHost: String?

        public var lifecyclePreStopHandlerHttpGetPath: String?

        public var lifecyclePreStopHandlerHttpGetPort: Int32?

        public var lifecyclePreStopHandlerHttpGetScheme: String?

        public var lifecyclePreStopHandlerTcpSocketHost: String?

        public var lifecyclePreStopHandlerTcpSocketPort: Int32?

        public var memory: Double?

        public var name: String?

        public var ports: [ModifyEciScalingConfigurationRequest.Containers.Ports]?

        public var stdin: Bool?

        public var stdinOnce: Bool?

        public var tty: Bool?

        public var volumeMounts: [ModifyEciScalingConfigurationRequest.Containers.VolumeMounts]?

        public var workingDir: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.livenessProbe?.validate()
            try self.readinessProbe?.validate()
            try self.securityContext?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.livenessProbe != nil {
                map["LivenessProbe"] = self.livenessProbe?.toMap()
            }
            if self.readinessProbe != nil {
                map["ReadinessProbe"] = self.readinessProbe?.toMap()
            }
            if self.securityContext != nil {
                map["SecurityContext"] = self.securityContext?.toMap()
            }
            if self.args != nil {
                map["Args"] = self.args!
            }
            if self.commands != nil {
                map["Commands"] = self.commands!
            }
            if self.cpu != nil {
                map["Cpu"] = self.cpu!
            }
            if self.environmentVars != nil {
                var tmp : [Any] = []
                for k in self.environmentVars! {
                    tmp.append(k.toMap())
                }
                map["EnvironmentVars"] = tmp
            }
            if self.gpu != nil {
                map["Gpu"] = self.gpu!
            }
            if self.image != nil {
                map["Image"] = self.image!
            }
            if self.imagePullPolicy != nil {
                map["ImagePullPolicy"] = self.imagePullPolicy!
            }
            if self.lifecyclePostStartHandlerExecs != nil {
                map["LifecyclePostStartHandlerExecs"] = self.lifecyclePostStartHandlerExecs!
            }
            if self.lifecyclePostStartHandlerHttpGetHost != nil {
                map["LifecyclePostStartHandlerHttpGetHost"] = self.lifecyclePostStartHandlerHttpGetHost!
            }
            if self.lifecyclePostStartHandlerHttpGetPath != nil {
                map["LifecyclePostStartHandlerHttpGetPath"] = self.lifecyclePostStartHandlerHttpGetPath!
            }
            if self.lifecyclePostStartHandlerHttpGetPort != nil {
                map["LifecyclePostStartHandlerHttpGetPort"] = self.lifecyclePostStartHandlerHttpGetPort!
            }
            if self.lifecyclePostStartHandlerHttpGetScheme != nil {
                map["LifecyclePostStartHandlerHttpGetScheme"] = self.lifecyclePostStartHandlerHttpGetScheme!
            }
            if self.lifecyclePostStartHandlerTcpSocketHost != nil {
                map["LifecyclePostStartHandlerTcpSocketHost"] = self.lifecyclePostStartHandlerTcpSocketHost!
            }
            if self.lifecyclePostStartHandlerTcpSocketPort != nil {
                map["LifecyclePostStartHandlerTcpSocketPort"] = self.lifecyclePostStartHandlerTcpSocketPort!
            }
            if self.lifecyclePreStopHandlerExecs != nil {
                map["LifecyclePreStopHandlerExecs"] = self.lifecyclePreStopHandlerExecs!
            }
            if self.lifecyclePreStopHandlerHttpGetHost != nil {
                map["LifecyclePreStopHandlerHttpGetHost"] = self.lifecyclePreStopHandlerHttpGetHost!
            }
            if self.lifecyclePreStopHandlerHttpGetPath != nil {
                map["LifecyclePreStopHandlerHttpGetPath"] = self.lifecyclePreStopHandlerHttpGetPath!
            }
            if self.lifecyclePreStopHandlerHttpGetPort != nil {
                map["LifecyclePreStopHandlerHttpGetPort"] = self.lifecyclePreStopHandlerHttpGetPort!
            }
            if self.lifecyclePreStopHandlerHttpGetScheme != nil {
                map["LifecyclePreStopHandlerHttpGetScheme"] = self.lifecyclePreStopHandlerHttpGetScheme!
            }
            if self.lifecyclePreStopHandlerTcpSocketHost != nil {
                map["LifecyclePreStopHandlerTcpSocketHost"] = self.lifecyclePreStopHandlerTcpSocketHost!
            }
            if self.lifecyclePreStopHandlerTcpSocketPort != nil {
                map["LifecyclePreStopHandlerTcpSocketPort"] = self.lifecyclePreStopHandlerTcpSocketPort!
            }
            if self.memory != nil {
                map["Memory"] = self.memory!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.ports != nil {
                var tmp : [Any] = []
                for k in self.ports! {
                    tmp.append(k.toMap())
                }
                map["Ports"] = tmp
            }
            if self.stdin != nil {
                map["Stdin"] = self.stdin!
            }
            if self.stdinOnce != nil {
                map["StdinOnce"] = self.stdinOnce!
            }
            if self.tty != nil {
                map["Tty"] = self.tty!
            }
            if self.volumeMounts != nil {
                var tmp : [Any] = []
                for k in self.volumeMounts! {
                    tmp.append(k.toMap())
                }
                map["VolumeMounts"] = tmp
            }
            if self.workingDir != nil {
                map["WorkingDir"] = self.workingDir!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LivenessProbe") {
                var model = ModifyEciScalingConfigurationRequest.Containers.LivenessProbe()
                model.fromMap(dict["LivenessProbe"] as! [String: Any])
                self.livenessProbe = model
            }
            if dict.keys.contains("ReadinessProbe") {
                var model = ModifyEciScalingConfigurationRequest.Containers.ReadinessProbe()
                model.fromMap(dict["ReadinessProbe"] as! [String: Any])
                self.readinessProbe = model
            }
            if dict.keys.contains("SecurityContext") {
                var model = ModifyEciScalingConfigurationRequest.Containers.SecurityContext()
                model.fromMap(dict["SecurityContext"] as! [String: Any])
                self.securityContext = model
            }
            if dict.keys.contains("Args") {
                self.args = dict["Args"] as! [String]
            }
            if dict.keys.contains("Commands") {
                self.commands = dict["Commands"] as! [String]
            }
            if dict.keys.contains("Cpu") {
                self.cpu = dict["Cpu"] as! Double
            }
            if dict.keys.contains("EnvironmentVars") {
                var tmp : [ModifyEciScalingConfigurationRequest.Containers.EnvironmentVars] = []
                for v in dict["EnvironmentVars"] as! [Any] {
                    var model = ModifyEciScalingConfigurationRequest.Containers.EnvironmentVars()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.environmentVars = tmp
            }
            if dict.keys.contains("Gpu") {
                self.gpu = dict["Gpu"] as! Int32
            }
            if dict.keys.contains("Image") {
                self.image = dict["Image"] as! String
            }
            if dict.keys.contains("ImagePullPolicy") {
                self.imagePullPolicy = dict["ImagePullPolicy"] as! String
            }
            if dict.keys.contains("LifecyclePostStartHandlerExecs") {
                self.lifecyclePostStartHandlerExecs = dict["LifecyclePostStartHandlerExecs"] as! [String]
            }
            if dict.keys.contains("LifecyclePostStartHandlerHttpGetHost") {
                self.lifecyclePostStartHandlerHttpGetHost = dict["LifecyclePostStartHandlerHttpGetHost"] as! String
            }
            if dict.keys.contains("LifecyclePostStartHandlerHttpGetPath") {
                self.lifecyclePostStartHandlerHttpGetPath = dict["LifecyclePostStartHandlerHttpGetPath"] as! String
            }
            if dict.keys.contains("LifecyclePostStartHandlerHttpGetPort") {
                self.lifecyclePostStartHandlerHttpGetPort = dict["LifecyclePostStartHandlerHttpGetPort"] as! Int32
            }
            if dict.keys.contains("LifecyclePostStartHandlerHttpGetScheme") {
                self.lifecyclePostStartHandlerHttpGetScheme = dict["LifecyclePostStartHandlerHttpGetScheme"] as! String
            }
            if dict.keys.contains("LifecyclePostStartHandlerTcpSocketHost") {
                self.lifecyclePostStartHandlerTcpSocketHost = dict["LifecyclePostStartHandlerTcpSocketHost"] as! String
            }
            if dict.keys.contains("LifecyclePostStartHandlerTcpSocketPort") {
                self.lifecyclePostStartHandlerTcpSocketPort = dict["LifecyclePostStartHandlerTcpSocketPort"] as! Int32
            }
            if dict.keys.contains("LifecyclePreStopHandlerExecs") {
                self.lifecyclePreStopHandlerExecs = dict["LifecyclePreStopHandlerExecs"] as! [String]
            }
            if dict.keys.contains("LifecyclePreStopHandlerHttpGetHost") {
                self.lifecyclePreStopHandlerHttpGetHost = dict["LifecyclePreStopHandlerHttpGetHost"] as! String
            }
            if dict.keys.contains("LifecyclePreStopHandlerHttpGetPath") {
                self.lifecyclePreStopHandlerHttpGetPath = dict["LifecyclePreStopHandlerHttpGetPath"] as! String
            }
            if dict.keys.contains("LifecyclePreStopHandlerHttpGetPort") {
                self.lifecyclePreStopHandlerHttpGetPort = dict["LifecyclePreStopHandlerHttpGetPort"] as! Int32
            }
            if dict.keys.contains("LifecyclePreStopHandlerHttpGetScheme") {
                self.lifecyclePreStopHandlerHttpGetScheme = dict["LifecyclePreStopHandlerHttpGetScheme"] as! String
            }
            if dict.keys.contains("LifecyclePreStopHandlerTcpSocketHost") {
                self.lifecyclePreStopHandlerTcpSocketHost = dict["LifecyclePreStopHandlerTcpSocketHost"] as! String
            }
            if dict.keys.contains("LifecyclePreStopHandlerTcpSocketPort") {
                self.lifecyclePreStopHandlerTcpSocketPort = dict["LifecyclePreStopHandlerTcpSocketPort"] as! Int32
            }
            if dict.keys.contains("Memory") {
                self.memory = dict["Memory"] as! Double
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Ports") {
                var tmp : [ModifyEciScalingConfigurationRequest.Containers.Ports] = []
                for v in dict["Ports"] as! [Any] {
                    var model = ModifyEciScalingConfigurationRequest.Containers.Ports()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ports = tmp
            }
            if dict.keys.contains("Stdin") {
                self.stdin = dict["Stdin"] as! Bool
            }
            if dict.keys.contains("StdinOnce") {
                self.stdinOnce = dict["StdinOnce"] as! Bool
            }
            if dict.keys.contains("Tty") {
                self.tty = dict["Tty"] as! Bool
            }
            if dict.keys.contains("VolumeMounts") {
                var tmp : [ModifyEciScalingConfigurationRequest.Containers.VolumeMounts] = []
                for v in dict["VolumeMounts"] as! [Any] {
                    var model = ModifyEciScalingConfigurationRequest.Containers.VolumeMounts()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.volumeMounts = tmp
            }
            if dict.keys.contains("WorkingDir") {
                self.workingDir = dict["WorkingDir"] as! String
            }
        }
    }
    public class DnsConfigOptions : Tea.TeaModel {
        public var name: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public class HostAliases : Tea.TeaModel {
        public var hostnames: [String]?

        public var ip: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.hostnames != nil {
                map["Hostnames"] = self.hostnames!
            }
            if self.ip != nil {
                map["Ip"] = self.ip!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Hostnames") {
                self.hostnames = dict["Hostnames"] as! [String]
            }
            if dict.keys.contains("Ip") {
                self.ip = dict["Ip"] as! String
            }
        }
    }
    public class ImageRegistryCredentials : Tea.TeaModel {
        public var password: String?

        public var server: String?

        public var userName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.password != nil {
                map["Password"] = self.password!
            }
            if self.server != nil {
                map["Server"] = self.server!
            }
            if self.userName != nil {
                map["UserName"] = self.userName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Password") {
                self.password = dict["Password"] as! String
            }
            if dict.keys.contains("Server") {
                self.server = dict["Server"] as! String
            }
            if dict.keys.contains("UserName") {
                self.userName = dict["UserName"] as! String
            }
        }
    }
    public class InitContainers : Tea.TeaModel {
        public class SecurityContext : Tea.TeaModel {
            public class Capability : Tea.TeaModel {
                public var adds: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.adds != nil {
                        map["Adds"] = self.adds!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Adds") {
                        self.adds = dict["Adds"] as! [String]
                    }
                }
            }
            public var capability: ModifyEciScalingConfigurationRequest.InitContainers.SecurityContext.Capability?

            public var readOnlyRootFilesystem: Bool?

            public var runAsUser: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.capability?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.capability != nil {
                    map["Capability"] = self.capability?.toMap()
                }
                if self.readOnlyRootFilesystem != nil {
                    map["ReadOnlyRootFilesystem"] = self.readOnlyRootFilesystem!
                }
                if self.runAsUser != nil {
                    map["RunAsUser"] = self.runAsUser!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Capability") {
                    var model = ModifyEciScalingConfigurationRequest.InitContainers.SecurityContext.Capability()
                    model.fromMap(dict["Capability"] as! [String: Any])
                    self.capability = model
                }
                if dict.keys.contains("ReadOnlyRootFilesystem") {
                    self.readOnlyRootFilesystem = dict["ReadOnlyRootFilesystem"] as! Bool
                }
                if dict.keys.contains("RunAsUser") {
                    self.runAsUser = dict["RunAsUser"] as! Int64
                }
            }
        }
        public class InitContainerEnvironmentVars : Tea.TeaModel {
            public class FieldRef : Tea.TeaModel {
                public var fieldPath: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.fieldPath != nil {
                        map["FieldPath"] = self.fieldPath!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("FieldPath") {
                        self.fieldPath = dict["FieldPath"] as! String
                    }
                }
            }
            public var fieldRef: ModifyEciScalingConfigurationRequest.InitContainers.InitContainerEnvironmentVars.FieldRef?

            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.fieldRef?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fieldRef != nil {
                    map["FieldRef"] = self.fieldRef?.toMap()
                }
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FieldRef") {
                    var model = ModifyEciScalingConfigurationRequest.InitContainers.InitContainerEnvironmentVars.FieldRef()
                    model.fromMap(dict["FieldRef"] as! [String: Any])
                    self.fieldRef = model
                }
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public class InitContainerPorts : Tea.TeaModel {
            public var port: Int32?

            public var protocol_: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.protocol_ != nil {
                    map["Protocol"] = self.protocol_!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Port") {
                    self.port = dict["Port"] as! Int32
                }
                if dict.keys.contains("Protocol") {
                    self.protocol_ = dict["Protocol"] as! String
                }
            }
        }
        public class InitContainerVolumeMounts : Tea.TeaModel {
            public var mountPath: String?

            public var mountPropagation: String?

            public var name: String?

            public var readOnly: Bool?

            public var subPath: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.mountPath != nil {
                    map["MountPath"] = self.mountPath!
                }
                if self.mountPropagation != nil {
                    map["MountPropagation"] = self.mountPropagation!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.readOnly != nil {
                    map["ReadOnly"] = self.readOnly!
                }
                if self.subPath != nil {
                    map["SubPath"] = self.subPath!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("MountPath") {
                    self.mountPath = dict["MountPath"] as! String
                }
                if dict.keys.contains("MountPropagation") {
                    self.mountPropagation = dict["MountPropagation"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("ReadOnly") {
                    self.readOnly = dict["ReadOnly"] as! Bool
                }
                if dict.keys.contains("SubPath") {
                    self.subPath = dict["SubPath"] as! String
                }
            }
        }
        public var securityContext: ModifyEciScalingConfigurationRequest.InitContainers.SecurityContext?

        public var args: [String]?

        public var commands: [String]?

        public var cpu: Double?

        public var gpu: Int32?

        public var image: String?

        public var imagePullPolicy: String?

        public var initContainerEnvironmentVars: [ModifyEciScalingConfigurationRequest.InitContainers.InitContainerEnvironmentVars]?

        public var initContainerPorts: [ModifyEciScalingConfigurationRequest.InitContainers.InitContainerPorts]?

        public var initContainerVolumeMounts: [ModifyEciScalingConfigurationRequest.InitContainers.InitContainerVolumeMounts]?

        public var memory: Double?

        public var name: String?

        public var workingDir: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.securityContext?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.securityContext != nil {
                map["SecurityContext"] = self.securityContext?.toMap()
            }
            if self.args != nil {
                map["Args"] = self.args!
            }
            if self.commands != nil {
                map["Commands"] = self.commands!
            }
            if self.cpu != nil {
                map["Cpu"] = self.cpu!
            }
            if self.gpu != nil {
                map["Gpu"] = self.gpu!
            }
            if self.image != nil {
                map["Image"] = self.image!
            }
            if self.imagePullPolicy != nil {
                map["ImagePullPolicy"] = self.imagePullPolicy!
            }
            if self.initContainerEnvironmentVars != nil {
                var tmp : [Any] = []
                for k in self.initContainerEnvironmentVars! {
                    tmp.append(k.toMap())
                }
                map["InitContainerEnvironmentVars"] = tmp
            }
            if self.initContainerPorts != nil {
                var tmp : [Any] = []
                for k in self.initContainerPorts! {
                    tmp.append(k.toMap())
                }
                map["InitContainerPorts"] = tmp
            }
            if self.initContainerVolumeMounts != nil {
                var tmp : [Any] = []
                for k in self.initContainerVolumeMounts! {
                    tmp.append(k.toMap())
                }
                map["InitContainerVolumeMounts"] = tmp
            }
            if self.memory != nil {
                map["Memory"] = self.memory!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.workingDir != nil {
                map["WorkingDir"] = self.workingDir!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SecurityContext") {
                var model = ModifyEciScalingConfigurationRequest.InitContainers.SecurityContext()
                model.fromMap(dict["SecurityContext"] as! [String: Any])
                self.securityContext = model
            }
            if dict.keys.contains("Args") {
                self.args = dict["Args"] as! [String]
            }
            if dict.keys.contains("Commands") {
                self.commands = dict["Commands"] as! [String]
            }
            if dict.keys.contains("Cpu") {
                self.cpu = dict["Cpu"] as! Double
            }
            if dict.keys.contains("Gpu") {
                self.gpu = dict["Gpu"] as! Int32
            }
            if dict.keys.contains("Image") {
                self.image = dict["Image"] as! String
            }
            if dict.keys.contains("ImagePullPolicy") {
                self.imagePullPolicy = dict["ImagePullPolicy"] as! String
            }
            if dict.keys.contains("InitContainerEnvironmentVars") {
                var tmp : [ModifyEciScalingConfigurationRequest.InitContainers.InitContainerEnvironmentVars] = []
                for v in dict["InitContainerEnvironmentVars"] as! [Any] {
                    var model = ModifyEciScalingConfigurationRequest.InitContainers.InitContainerEnvironmentVars()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.initContainerEnvironmentVars = tmp
            }
            if dict.keys.contains("InitContainerPorts") {
                var tmp : [ModifyEciScalingConfigurationRequest.InitContainers.InitContainerPorts] = []
                for v in dict["InitContainerPorts"] as! [Any] {
                    var model = ModifyEciScalingConfigurationRequest.InitContainers.InitContainerPorts()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.initContainerPorts = tmp
            }
            if dict.keys.contains("InitContainerVolumeMounts") {
                var tmp : [ModifyEciScalingConfigurationRequest.InitContainers.InitContainerVolumeMounts] = []
                for v in dict["InitContainerVolumeMounts"] as! [Any] {
                    var model = ModifyEciScalingConfigurationRequest.InitContainers.InitContainerVolumeMounts()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.initContainerVolumeMounts = tmp
            }
            if dict.keys.contains("Memory") {
                self.memory = dict["Memory"] as! Double
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("WorkingDir") {
                self.workingDir = dict["WorkingDir"] as! String
            }
        }
    }
    public class SecurityContextSysCtls : Tea.TeaModel {
        public var name: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public class Volumes : Tea.TeaModel {
        public class DiskVolume : Tea.TeaModel {
            public var diskId: String?

            public var diskSize: Int32?

            public var fsType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.diskId != nil {
                    map["DiskId"] = self.diskId!
                }
                if self.diskSize != nil {
                    map["DiskSize"] = self.diskSize!
                }
                if self.fsType != nil {
                    map["FsType"] = self.fsType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DiskId") {
                    self.diskId = dict["DiskId"] as! String
                }
                if dict.keys.contains("DiskSize") {
                    self.diskSize = dict["DiskSize"] as! Int32
                }
                if dict.keys.contains("FsType") {
                    self.fsType = dict["FsType"] as! String
                }
            }
        }
        public class EmptyDirVolume : Tea.TeaModel {
            public var medium: String?

            public var sizeLimit: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.medium != nil {
                    map["Medium"] = self.medium!
                }
                if self.sizeLimit != nil {
                    map["SizeLimit"] = self.sizeLimit!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Medium") {
                    self.medium = dict["Medium"] as! String
                }
                if dict.keys.contains("SizeLimit") {
                    self.sizeLimit = dict["SizeLimit"] as! String
                }
            }
        }
        public class FlexVolume : Tea.TeaModel {
            public var driver: String?

            public var fsType: String?

            public var options: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.driver != nil {
                    map["Driver"] = self.driver!
                }
                if self.fsType != nil {
                    map["FsType"] = self.fsType!
                }
                if self.options != nil {
                    map["Options"] = self.options!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Driver") {
                    self.driver = dict["Driver"] as! String
                }
                if dict.keys.contains("FsType") {
                    self.fsType = dict["FsType"] as! String
                }
                if dict.keys.contains("Options") {
                    self.options = dict["Options"] as! String
                }
            }
        }
        public class HostPathVolume : Tea.TeaModel {
            public var path: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.path != nil {
                    map["Path"] = self.path!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Path") {
                    self.path = dict["Path"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class NFSVolume : Tea.TeaModel {
            public var path: String?

            public var readOnly: Bool?

            public var server: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.path != nil {
                    map["Path"] = self.path!
                }
                if self.readOnly != nil {
                    map["ReadOnly"] = self.readOnly!
                }
                if self.server != nil {
                    map["Server"] = self.server!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Path") {
                    self.path = dict["Path"] as! String
                }
                if dict.keys.contains("ReadOnly") {
                    self.readOnly = dict["ReadOnly"] as! Bool
                }
                if dict.keys.contains("Server") {
                    self.server = dict["Server"] as! String
                }
            }
        }
        public class ConfigFileVolumeConfigFileToPath : Tea.TeaModel {
            public var content: String?

            public var mode: Int32?

            public var path: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.content != nil {
                    map["Content"] = self.content!
                }
                if self.mode != nil {
                    map["Mode"] = self.mode!
                }
                if self.path != nil {
                    map["Path"] = self.path!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Content") {
                    self.content = dict["Content"] as! String
                }
                if dict.keys.contains("Mode") {
                    self.mode = dict["Mode"] as! Int32
                }
                if dict.keys.contains("Path") {
                    self.path = dict["Path"] as! String
                }
            }
        }
        public var diskVolume: ModifyEciScalingConfigurationRequest.Volumes.DiskVolume?

        public var emptyDirVolume: ModifyEciScalingConfigurationRequest.Volumes.EmptyDirVolume?

        public var flexVolume: ModifyEciScalingConfigurationRequest.Volumes.FlexVolume?

        public var hostPathVolume: ModifyEciScalingConfigurationRequest.Volumes.HostPathVolume?

        public var NFSVolume: ModifyEciScalingConfigurationRequest.Volumes.NFSVolume?

        public var configFileVolumeConfigFileToPath: [ModifyEciScalingConfigurationRequest.Volumes.ConfigFileVolumeConfigFileToPath]?

        public var configFileVolumeDefaultMode: Int32?

        public var name: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.diskVolume?.validate()
            try self.emptyDirVolume?.validate()
            try self.flexVolume?.validate()
            try self.hostPathVolume?.validate()
            try self.NFSVolume?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.diskVolume != nil {
                map["DiskVolume"] = self.diskVolume?.toMap()
            }
            if self.emptyDirVolume != nil {
                map["EmptyDirVolume"] = self.emptyDirVolume?.toMap()
            }
            if self.flexVolume != nil {
                map["FlexVolume"] = self.flexVolume?.toMap()
            }
            if self.hostPathVolume != nil {
                map["HostPathVolume"] = self.hostPathVolume?.toMap()
            }
            if self.NFSVolume != nil {
                map["NFSVolume"] = self.NFSVolume?.toMap()
            }
            if self.configFileVolumeConfigFileToPath != nil {
                var tmp : [Any] = []
                for k in self.configFileVolumeConfigFileToPath! {
                    tmp.append(k.toMap())
                }
                map["ConfigFileVolumeConfigFileToPath"] = tmp
            }
            if self.configFileVolumeDefaultMode != nil {
                map["ConfigFileVolumeDefaultMode"] = self.configFileVolumeDefaultMode!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DiskVolume") {
                var model = ModifyEciScalingConfigurationRequest.Volumes.DiskVolume()
                model.fromMap(dict["DiskVolume"] as! [String: Any])
                self.diskVolume = model
            }
            if dict.keys.contains("EmptyDirVolume") {
                var model = ModifyEciScalingConfigurationRequest.Volumes.EmptyDirVolume()
                model.fromMap(dict["EmptyDirVolume"] as! [String: Any])
                self.emptyDirVolume = model
            }
            if dict.keys.contains("FlexVolume") {
                var model = ModifyEciScalingConfigurationRequest.Volumes.FlexVolume()
                model.fromMap(dict["FlexVolume"] as! [String: Any])
                self.flexVolume = model
            }
            if dict.keys.contains("HostPathVolume") {
                var model = ModifyEciScalingConfigurationRequest.Volumes.HostPathVolume()
                model.fromMap(dict["HostPathVolume"] as! [String: Any])
                self.hostPathVolume = model
            }
            if dict.keys.contains("NFSVolume") {
                var model = ModifyEciScalingConfigurationRequest.Volumes.NFSVolume()
                model.fromMap(dict["NFSVolume"] as! [String: Any])
                self.NFSVolume = model
            }
            if dict.keys.contains("ConfigFileVolumeConfigFileToPath") {
                var tmp : [ModifyEciScalingConfigurationRequest.Volumes.ConfigFileVolumeConfigFileToPath] = []
                for v in dict["ConfigFileVolumeConfigFileToPath"] as! [Any] {
                    var model = ModifyEciScalingConfigurationRequest.Volumes.ConfigFileVolumeConfigFileToPath()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.configFileVolumeConfigFileToPath = tmp
            }
            if dict.keys.contains("ConfigFileVolumeDefaultMode") {
                self.configFileVolumeDefaultMode = dict["ConfigFileVolumeDefaultMode"] as! Int32
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var acrRegistryInfos: [ModifyEciScalingConfigurationRequest.AcrRegistryInfos]?

    public var activeDeadlineSeconds: Int64?

    public var autoCreateEip: Bool?

    public var autoMatchImageCache: Bool?

    public var containerGroupName: String?

    public var containers: [ModifyEciScalingConfigurationRequest.Containers]?

    public var containersUpdateType: String?

    public var costOptimization: Bool?

    public var cpu: Double?

    public var cpuOptionsCore: Int32?

    public var cpuOptionsThreadsPerCore: Int32?

    public var dataCacheBucket: String?

    public var dataCacheBurstingEnabled: Bool?

    public var dataCachePL: String?

    public var dataCacheProvisionedIops: Int32?

    public var description_: String?

    public var dnsConfigNameServers: [String]?

    public var dnsConfigOptions: [ModifyEciScalingConfigurationRequest.DnsConfigOptions]?

    public var dnsConfigSearchs: [String]?

    public var dnsPolicy: String?

    public var egressBandwidth: Int64?

    public var eipBandwidth: Int32?

    public var enableSls: Bool?

    public var ephemeralStorage: Int32?

    public var gpuDriverVersion: String?

    public var hostAliases: [ModifyEciScalingConfigurationRequest.HostAliases]?

    public var hostName: String?

    public var imageRegistryCredentials: [ModifyEciScalingConfigurationRequest.ImageRegistryCredentials]?

    public var imageSnapshotId: String?

    public var ingressBandwidth: Int64?

    public var initContainers: [ModifyEciScalingConfigurationRequest.InitContainers]?

    public var instanceFamilyLevel: String?

    public var instanceTypes: [String]?

    public var ipv6AddressCount: Int32?

    public var loadBalancerWeight: Int32?

    public var memory: Double?

    public var ntpServers: [String]?

    public var ownerId: Int64?

    public var ramRoleName: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var restartPolicy: String?

    public var scalingConfigurationId: String?

    public var scalingConfigurationName: String?

    public var securityContextSysCtls: [ModifyEciScalingConfigurationRequest.SecurityContextSysCtls]?

    public var securityGroupId: String?

    public var spotPriceLimit: Double?

    public var spotStrategy: String?

    public var tags: [ModifyEciScalingConfigurationRequest.Tags]?

    public var terminationGracePeriodSeconds: Int64?

    public var volumes: [ModifyEciScalingConfigurationRequest.Volumes]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acrRegistryInfos != nil {
            var tmp : [Any] = []
            for k in self.acrRegistryInfos! {
                tmp.append(k.toMap())
            }
            map["AcrRegistryInfos"] = tmp
        }
        if self.activeDeadlineSeconds != nil {
            map["ActiveDeadlineSeconds"] = self.activeDeadlineSeconds!
        }
        if self.autoCreateEip != nil {
            map["AutoCreateEip"] = self.autoCreateEip!
        }
        if self.autoMatchImageCache != nil {
            map["AutoMatchImageCache"] = self.autoMatchImageCache!
        }
        if self.containerGroupName != nil {
            map["ContainerGroupName"] = self.containerGroupName!
        }
        if self.containers != nil {
            var tmp : [Any] = []
            for k in self.containers! {
                tmp.append(k.toMap())
            }
            map["Containers"] = tmp
        }
        if self.containersUpdateType != nil {
            map["ContainersUpdateType"] = self.containersUpdateType!
        }
        if self.costOptimization != nil {
            map["CostOptimization"] = self.costOptimization!
        }
        if self.cpu != nil {
            map["Cpu"] = self.cpu!
        }
        if self.cpuOptionsCore != nil {
            map["CpuOptionsCore"] = self.cpuOptionsCore!
        }
        if self.cpuOptionsThreadsPerCore != nil {
            map["CpuOptionsThreadsPerCore"] = self.cpuOptionsThreadsPerCore!
        }
        if self.dataCacheBucket != nil {
            map["DataCacheBucket"] = self.dataCacheBucket!
        }
        if self.dataCacheBurstingEnabled != nil {
            map["DataCacheBurstingEnabled"] = self.dataCacheBurstingEnabled!
        }
        if self.dataCachePL != nil {
            map["DataCachePL"] = self.dataCachePL!
        }
        if self.dataCacheProvisionedIops != nil {
            map["DataCacheProvisionedIops"] = self.dataCacheProvisionedIops!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.dnsConfigNameServers != nil {
            map["DnsConfigNameServers"] = self.dnsConfigNameServers!
        }
        if self.dnsConfigOptions != nil {
            var tmp : [Any] = []
            for k in self.dnsConfigOptions! {
                tmp.append(k.toMap())
            }
            map["DnsConfigOptions"] = tmp
        }
        if self.dnsConfigSearchs != nil {
            map["DnsConfigSearchs"] = self.dnsConfigSearchs!
        }
        if self.dnsPolicy != nil {
            map["DnsPolicy"] = self.dnsPolicy!
        }
        if self.egressBandwidth != nil {
            map["EgressBandwidth"] = self.egressBandwidth!
        }
        if self.eipBandwidth != nil {
            map["EipBandwidth"] = self.eipBandwidth!
        }
        if self.enableSls != nil {
            map["EnableSls"] = self.enableSls!
        }
        if self.ephemeralStorage != nil {
            map["EphemeralStorage"] = self.ephemeralStorage!
        }
        if self.gpuDriverVersion != nil {
            map["GpuDriverVersion"] = self.gpuDriverVersion!
        }
        if self.hostAliases != nil {
            var tmp : [Any] = []
            for k in self.hostAliases! {
                tmp.append(k.toMap())
            }
            map["HostAliases"] = tmp
        }
        if self.hostName != nil {
            map["HostName"] = self.hostName!
        }
        if self.imageRegistryCredentials != nil {
            var tmp : [Any] = []
            for k in self.imageRegistryCredentials! {
                tmp.append(k.toMap())
            }
            map["ImageRegistryCredentials"] = tmp
        }
        if self.imageSnapshotId != nil {
            map["ImageSnapshotId"] = self.imageSnapshotId!
        }
        if self.ingressBandwidth != nil {
            map["IngressBandwidth"] = self.ingressBandwidth!
        }
        if self.initContainers != nil {
            var tmp : [Any] = []
            for k in self.initContainers! {
                tmp.append(k.toMap())
            }
            map["InitContainers"] = tmp
        }
        if self.instanceFamilyLevel != nil {
            map["InstanceFamilyLevel"] = self.instanceFamilyLevel!
        }
        if self.instanceTypes != nil {
            map["InstanceTypes"] = self.instanceTypes!
        }
        if self.ipv6AddressCount != nil {
            map["Ipv6AddressCount"] = self.ipv6AddressCount!
        }
        if self.loadBalancerWeight != nil {
            map["LoadBalancerWeight"] = self.loadBalancerWeight!
        }
        if self.memory != nil {
            map["Memory"] = self.memory!
        }
        if self.ntpServers != nil {
            map["NtpServers"] = self.ntpServers!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.ramRoleName != nil {
            map["RamRoleName"] = self.ramRoleName!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.restartPolicy != nil {
            map["RestartPolicy"] = self.restartPolicy!
        }
        if self.scalingConfigurationId != nil {
            map["ScalingConfigurationId"] = self.scalingConfigurationId!
        }
        if self.scalingConfigurationName != nil {
            map["ScalingConfigurationName"] = self.scalingConfigurationName!
        }
        if self.securityContextSysCtls != nil {
            var tmp : [Any] = []
            for k in self.securityContextSysCtls! {
                tmp.append(k.toMap())
            }
            map["SecurityContextSysCtls"] = tmp
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.spotPriceLimit != nil {
            map["SpotPriceLimit"] = self.spotPriceLimit!
        }
        if self.spotStrategy != nil {
            map["SpotStrategy"] = self.spotStrategy!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        if self.terminationGracePeriodSeconds != nil {
            map["TerminationGracePeriodSeconds"] = self.terminationGracePeriodSeconds!
        }
        if self.volumes != nil {
            var tmp : [Any] = []
            for k in self.volumes! {
                tmp.append(k.toMap())
            }
            map["Volumes"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcrRegistryInfos") {
            var tmp : [ModifyEciScalingConfigurationRequest.AcrRegistryInfos] = []
            for v in dict["AcrRegistryInfos"] as! [Any] {
                var model = ModifyEciScalingConfigurationRequest.AcrRegistryInfos()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.acrRegistryInfos = tmp
        }
        if dict.keys.contains("ActiveDeadlineSeconds") {
            self.activeDeadlineSeconds = dict["ActiveDeadlineSeconds"] as! Int64
        }
        if dict.keys.contains("AutoCreateEip") {
            self.autoCreateEip = dict["AutoCreateEip"] as! Bool
        }
        if dict.keys.contains("AutoMatchImageCache") {
            self.autoMatchImageCache = dict["AutoMatchImageCache"] as! Bool
        }
        if dict.keys.contains("ContainerGroupName") {
            self.containerGroupName = dict["ContainerGroupName"] as! String
        }
        if dict.keys.contains("Containers") {
            var tmp : [ModifyEciScalingConfigurationRequest.Containers] = []
            for v in dict["Containers"] as! [Any] {
                var model = ModifyEciScalingConfigurationRequest.Containers()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.containers = tmp
        }
        if dict.keys.contains("ContainersUpdateType") {
            self.containersUpdateType = dict["ContainersUpdateType"] as! String
        }
        if dict.keys.contains("CostOptimization") {
            self.costOptimization = dict["CostOptimization"] as! Bool
        }
        if dict.keys.contains("Cpu") {
            self.cpu = dict["Cpu"] as! Double
        }
        if dict.keys.contains("CpuOptionsCore") {
            self.cpuOptionsCore = dict["CpuOptionsCore"] as! Int32
        }
        if dict.keys.contains("CpuOptionsThreadsPerCore") {
            self.cpuOptionsThreadsPerCore = dict["CpuOptionsThreadsPerCore"] as! Int32
        }
        if dict.keys.contains("DataCacheBucket") {
            self.dataCacheBucket = dict["DataCacheBucket"] as! String
        }
        if dict.keys.contains("DataCacheBurstingEnabled") {
            self.dataCacheBurstingEnabled = dict["DataCacheBurstingEnabled"] as! Bool
        }
        if dict.keys.contains("DataCachePL") {
            self.dataCachePL = dict["DataCachePL"] as! String
        }
        if dict.keys.contains("DataCacheProvisionedIops") {
            self.dataCacheProvisionedIops = dict["DataCacheProvisionedIops"] as! Int32
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DnsConfigNameServers") {
            self.dnsConfigNameServers = dict["DnsConfigNameServers"] as! [String]
        }
        if dict.keys.contains("DnsConfigOptions") {
            var tmp : [ModifyEciScalingConfigurationRequest.DnsConfigOptions] = []
            for v in dict["DnsConfigOptions"] as! [Any] {
                var model = ModifyEciScalingConfigurationRequest.DnsConfigOptions()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.dnsConfigOptions = tmp
        }
        if dict.keys.contains("DnsConfigSearchs") {
            self.dnsConfigSearchs = dict["DnsConfigSearchs"] as! [String]
        }
        if dict.keys.contains("DnsPolicy") {
            self.dnsPolicy = dict["DnsPolicy"] as! String
        }
        if dict.keys.contains("EgressBandwidth") {
            self.egressBandwidth = dict["EgressBandwidth"] as! Int64
        }
        if dict.keys.contains("EipBandwidth") {
            self.eipBandwidth = dict["EipBandwidth"] as! Int32
        }
        if dict.keys.contains("EnableSls") {
            self.enableSls = dict["EnableSls"] as! Bool
        }
        if dict.keys.contains("EphemeralStorage") {
            self.ephemeralStorage = dict["EphemeralStorage"] as! Int32
        }
        if dict.keys.contains("GpuDriverVersion") {
            self.gpuDriverVersion = dict["GpuDriverVersion"] as! String
        }
        if dict.keys.contains("HostAliases") {
            var tmp : [ModifyEciScalingConfigurationRequest.HostAliases] = []
            for v in dict["HostAliases"] as! [Any] {
                var model = ModifyEciScalingConfigurationRequest.HostAliases()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.hostAliases = tmp
        }
        if dict.keys.contains("HostName") {
            self.hostName = dict["HostName"] as! String
        }
        if dict.keys.contains("ImageRegistryCredentials") {
            var tmp : [ModifyEciScalingConfigurationRequest.ImageRegistryCredentials] = []
            for v in dict["ImageRegistryCredentials"] as! [Any] {
                var model = ModifyEciScalingConfigurationRequest.ImageRegistryCredentials()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.imageRegistryCredentials = tmp
        }
        if dict.keys.contains("ImageSnapshotId") {
            self.imageSnapshotId = dict["ImageSnapshotId"] as! String
        }
        if dict.keys.contains("IngressBandwidth") {
            self.ingressBandwidth = dict["IngressBandwidth"] as! Int64
        }
        if dict.keys.contains("InitContainers") {
            var tmp : [ModifyEciScalingConfigurationRequest.InitContainers] = []
            for v in dict["InitContainers"] as! [Any] {
                var model = ModifyEciScalingConfigurationRequest.InitContainers()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.initContainers = tmp
        }
        if dict.keys.contains("InstanceFamilyLevel") {
            self.instanceFamilyLevel = dict["InstanceFamilyLevel"] as! String
        }
        if dict.keys.contains("InstanceTypes") {
            self.instanceTypes = dict["InstanceTypes"] as! [String]
        }
        if dict.keys.contains("Ipv6AddressCount") {
            self.ipv6AddressCount = dict["Ipv6AddressCount"] as! Int32
        }
        if dict.keys.contains("LoadBalancerWeight") {
            self.loadBalancerWeight = dict["LoadBalancerWeight"] as! Int32
        }
        if dict.keys.contains("Memory") {
            self.memory = dict["Memory"] as! Double
        }
        if dict.keys.contains("NtpServers") {
            self.ntpServers = dict["NtpServers"] as! [String]
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RamRoleName") {
            self.ramRoleName = dict["RamRoleName"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("RestartPolicy") {
            self.restartPolicy = dict["RestartPolicy"] as! String
        }
        if dict.keys.contains("ScalingConfigurationId") {
            self.scalingConfigurationId = dict["ScalingConfigurationId"] as! String
        }
        if dict.keys.contains("ScalingConfigurationName") {
            self.scalingConfigurationName = dict["ScalingConfigurationName"] as! String
        }
        if dict.keys.contains("SecurityContextSysCtls") {
            var tmp : [ModifyEciScalingConfigurationRequest.SecurityContextSysCtls] = []
            for v in dict["SecurityContextSysCtls"] as! [Any] {
                var model = ModifyEciScalingConfigurationRequest.SecurityContextSysCtls()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.securityContextSysCtls = tmp
        }
        if dict.keys.contains("SecurityGroupId") {
            self.securityGroupId = dict["SecurityGroupId"] as! String
        }
        if dict.keys.contains("SpotPriceLimit") {
            self.spotPriceLimit = dict["SpotPriceLimit"] as! Double
        }
        if dict.keys.contains("SpotStrategy") {
            self.spotStrategy = dict["SpotStrategy"] as! String
        }
        if dict.keys.contains("Tags") {
            var tmp : [ModifyEciScalingConfigurationRequest.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = ModifyEciScalingConfigurationRequest.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
        if dict.keys.contains("TerminationGracePeriodSeconds") {
            self.terminationGracePeriodSeconds = dict["TerminationGracePeriodSeconds"] as! Int64
        }
        if dict.keys.contains("Volumes") {
            var tmp : [ModifyEciScalingConfigurationRequest.Volumes] = []
            for v in dict["Volumes"] as! [Any] {
                var model = ModifyEciScalingConfigurationRequest.Volumes()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.volumes = tmp
        }
    }
}

public class ModifyEciScalingConfigurationResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyEciScalingConfigurationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyEciScalingConfigurationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyEciScalingConfigurationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyInstanceAttributeRequest : Tea.TeaModel {
    public var entrusted: Bool?

    public var instanceId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.entrusted != nil {
            map["Entrusted"] = self.entrusted!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Entrusted") {
            self.entrusted = dict["Entrusted"] as! Bool
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScalingGroupId") {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
    }
}

public class ModifyInstanceAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyInstanceAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyInstanceAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyInstanceAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyLifecycleHookRequest : Tea.TeaModel {
    public var defaultResult: String?

    public var heartbeatTimeout: Int32?

    public var lifecycleHookId: String?

    public var lifecycleHookName: String?

    public var lifecycleHookStatus: String?

    public var lifecycleTransition: String?

    public var notificationArn: String?

    public var notificationMetadata: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.defaultResult != nil {
            map["DefaultResult"] = self.defaultResult!
        }
        if self.heartbeatTimeout != nil {
            map["HeartbeatTimeout"] = self.heartbeatTimeout!
        }
        if self.lifecycleHookId != nil {
            map["LifecycleHookId"] = self.lifecycleHookId!
        }
        if self.lifecycleHookName != nil {
            map["LifecycleHookName"] = self.lifecycleHookName!
        }
        if self.lifecycleHookStatus != nil {
            map["LifecycleHookStatus"] = self.lifecycleHookStatus!
        }
        if self.lifecycleTransition != nil {
            map["LifecycleTransition"] = self.lifecycleTransition!
        }
        if self.notificationArn != nil {
            map["NotificationArn"] = self.notificationArn!
        }
        if self.notificationMetadata != nil {
            map["NotificationMetadata"] = self.notificationMetadata!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DefaultResult") {
            self.defaultResult = dict["DefaultResult"] as! String
        }
        if dict.keys.contains("HeartbeatTimeout") {
            self.heartbeatTimeout = dict["HeartbeatTimeout"] as! Int32
        }
        if dict.keys.contains("LifecycleHookId") {
            self.lifecycleHookId = dict["LifecycleHookId"] as! String
        }
        if dict.keys.contains("LifecycleHookName") {
            self.lifecycleHookName = dict["LifecycleHookName"] as! String
        }
        if dict.keys.contains("LifecycleHookStatus") {
            self.lifecycleHookStatus = dict["LifecycleHookStatus"] as! String
        }
        if dict.keys.contains("LifecycleTransition") {
            self.lifecycleTransition = dict["LifecycleTransition"] as! String
        }
        if dict.keys.contains("NotificationArn") {
            self.notificationArn = dict["NotificationArn"] as! String
        }
        if dict.keys.contains("NotificationMetadata") {
            self.notificationMetadata = dict["NotificationMetadata"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScalingGroupId") {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
    }
}

public class ModifyLifecycleHookResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyLifecycleHookResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyLifecycleHookResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyLifecycleHookResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyNotificationConfigurationRequest : Tea.TeaModel {
    public var notificationArn: String?

    public var notificationTypes: [String]?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public var timeZone: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.notificationArn != nil {
            map["NotificationArn"] = self.notificationArn!
        }
        if self.notificationTypes != nil {
            map["NotificationTypes"] = self.notificationTypes!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        if self.timeZone != nil {
            map["TimeZone"] = self.timeZone!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NotificationArn") {
            self.notificationArn = dict["NotificationArn"] as! String
        }
        if dict.keys.contains("NotificationTypes") {
            self.notificationTypes = dict["NotificationTypes"] as! [String]
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScalingGroupId") {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
        if dict.keys.contains("TimeZone") {
            self.timeZone = dict["TimeZone"] as! String
        }
    }
}

public class ModifyNotificationConfigurationResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyNotificationConfigurationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyNotificationConfigurationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyNotificationConfigurationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyScalingConfigurationRequest : Tea.TeaModel {
    public class ImageOptions : Tea.TeaModel {
        public var loginAsNonRoot: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.loginAsNonRoot != nil {
                map["LoginAsNonRoot"] = self.loginAsNonRoot!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LoginAsNonRoot") {
                self.loginAsNonRoot = dict["LoginAsNonRoot"] as! Bool
            }
        }
    }
    public class PrivatePoolOptions : Tea.TeaModel {
        public var id: String?

        public var matchCriteria: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.matchCriteria != nil {
                map["MatchCriteria"] = self.matchCriteria!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("MatchCriteria") {
                self.matchCriteria = dict["MatchCriteria"] as! String
            }
        }
    }
    public class SystemDisk : Tea.TeaModel {
        public var autoSnapshotPolicyId: String?

        public var burstingEnabled: Bool?

        public var category: String?

        public var description_: String?

        public var diskName: String?

        public var encryptAlgorithm: String?

        public var encrypted: Bool?

        public var KMSKeyId: String?

        public var performanceLevel: String?

        public var provisionedIops: Int64?

        public var size: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.autoSnapshotPolicyId != nil {
                map["AutoSnapshotPolicyId"] = self.autoSnapshotPolicyId!
            }
            if self.burstingEnabled != nil {
                map["BurstingEnabled"] = self.burstingEnabled!
            }
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.diskName != nil {
                map["DiskName"] = self.diskName!
            }
            if self.encryptAlgorithm != nil {
                map["EncryptAlgorithm"] = self.encryptAlgorithm!
            }
            if self.encrypted != nil {
                map["Encrypted"] = self.encrypted!
            }
            if self.KMSKeyId != nil {
                map["KMSKeyId"] = self.KMSKeyId!
            }
            if self.performanceLevel != nil {
                map["PerformanceLevel"] = self.performanceLevel!
            }
            if self.provisionedIops != nil {
                map["ProvisionedIops"] = self.provisionedIops!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AutoSnapshotPolicyId") {
                self.autoSnapshotPolicyId = dict["AutoSnapshotPolicyId"] as! String
            }
            if dict.keys.contains("BurstingEnabled") {
                self.burstingEnabled = dict["BurstingEnabled"] as! Bool
            }
            if dict.keys.contains("Category") {
                self.category = dict["Category"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("DiskName") {
                self.diskName = dict["DiskName"] as! String
            }
            if dict.keys.contains("EncryptAlgorithm") {
                self.encryptAlgorithm = dict["EncryptAlgorithm"] as! String
            }
            if dict.keys.contains("Encrypted") {
                self.encrypted = dict["Encrypted"] as! Bool
            }
            if dict.keys.contains("KMSKeyId") {
                self.KMSKeyId = dict["KMSKeyId"] as! String
            }
            if dict.keys.contains("PerformanceLevel") {
                self.performanceLevel = dict["PerformanceLevel"] as! String
            }
            if dict.keys.contains("ProvisionedIops") {
                self.provisionedIops = dict["ProvisionedIops"] as! Int64
            }
            if dict.keys.contains("Size") {
                self.size = dict["Size"] as! Int32
            }
        }
    }
    public class CustomPriorities : Tea.TeaModel {
        public var instanceType: String?

        public var vswitchId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.vswitchId != nil {
                map["VswitchId"] = self.vswitchId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceType") {
                self.instanceType = dict["InstanceType"] as! String
            }
            if dict.keys.contains("VswitchId") {
                self.vswitchId = dict["VswitchId"] as! String
            }
        }
    }
    public class DataDisks : Tea.TeaModel {
        public var autoSnapshotPolicyId: String?

        public var burstingEnabled: Bool?

        public var categories: [String]?

        public var category: String?

        public var deleteWithInstance: Bool?

        public var description_: String?

        public var device: String?

        public var diskName: String?

        public var encrypted: String?

        public var KMSKeyId: String?

        public var performanceLevel: String?

        public var provisionedIops: Int64?

        public var size: Int32?

        public var snapshotId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.autoSnapshotPolicyId != nil {
                map["AutoSnapshotPolicyId"] = self.autoSnapshotPolicyId!
            }
            if self.burstingEnabled != nil {
                map["BurstingEnabled"] = self.burstingEnabled!
            }
            if self.categories != nil {
                map["Categories"] = self.categories!
            }
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.deleteWithInstance != nil {
                map["DeleteWithInstance"] = self.deleteWithInstance!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.device != nil {
                map["Device"] = self.device!
            }
            if self.diskName != nil {
                map["DiskName"] = self.diskName!
            }
            if self.encrypted != nil {
                map["Encrypted"] = self.encrypted!
            }
            if self.KMSKeyId != nil {
                map["KMSKeyId"] = self.KMSKeyId!
            }
            if self.performanceLevel != nil {
                map["PerformanceLevel"] = self.performanceLevel!
            }
            if self.provisionedIops != nil {
                map["ProvisionedIops"] = self.provisionedIops!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.snapshotId != nil {
                map["SnapshotId"] = self.snapshotId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AutoSnapshotPolicyId") {
                self.autoSnapshotPolicyId = dict["AutoSnapshotPolicyId"] as! String
            }
            if dict.keys.contains("BurstingEnabled") {
                self.burstingEnabled = dict["BurstingEnabled"] as! Bool
            }
            if dict.keys.contains("Categories") {
                self.categories = dict["Categories"] as! [String]
            }
            if dict.keys.contains("Category") {
                self.category = dict["Category"] as! String
            }
            if dict.keys.contains("DeleteWithInstance") {
                self.deleteWithInstance = dict["DeleteWithInstance"] as! Bool
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Device") {
                self.device = dict["Device"] as! String
            }
            if dict.keys.contains("DiskName") {
                self.diskName = dict["DiskName"] as! String
            }
            if dict.keys.contains("Encrypted") {
                self.encrypted = dict["Encrypted"] as! String
            }
            if dict.keys.contains("KMSKeyId") {
                self.KMSKeyId = dict["KMSKeyId"] as! String
            }
            if dict.keys.contains("PerformanceLevel") {
                self.performanceLevel = dict["PerformanceLevel"] as! String
            }
            if dict.keys.contains("ProvisionedIops") {
                self.provisionedIops = dict["ProvisionedIops"] as! Int64
            }
            if dict.keys.contains("Size") {
                self.size = dict["Size"] as! Int32
            }
            if dict.keys.contains("SnapshotId") {
                self.snapshotId = dict["SnapshotId"] as! String
            }
        }
    }
    public class InstancePatternInfos : Tea.TeaModel {
        public var architectures: [String]?

        public var burstablePerformance: String?

        public var cores: Int32?

        public var cpuArchitectures: [String]?

        public var excludedInstanceTypes: [String]?

        public var gpuSpecs: [String]?

        public var instanceCategories: [String]?

        public var instanceFamilyLevel: String?

        public var instanceTypeFamilies: [String]?

        public var maxPrice: Double?

        public var maximumCpuCoreCount: Int32?

        public var maximumGpuAmount: Int32?

        public var maximumMemorySize: Double?

        public var memory: Double?

        public var minimumBaselineCredit: Int32?

        public var minimumCpuCoreCount: Int32?

        public var minimumEniIpv6AddressQuantity: Int32?

        public var minimumEniPrivateIpAddressQuantity: Int32?

        public var minimumEniQuantity: Int32?

        public var minimumGpuAmount: Int32?

        public var minimumInitialCredit: Int32?

        public var minimumMemorySize: Double?

        public var physicalProcessorModels: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.architectures != nil {
                map["Architectures"] = self.architectures!
            }
            if self.burstablePerformance != nil {
                map["BurstablePerformance"] = self.burstablePerformance!
            }
            if self.cores != nil {
                map["Cores"] = self.cores!
            }
            if self.cpuArchitectures != nil {
                map["CpuArchitectures"] = self.cpuArchitectures!
            }
            if self.excludedInstanceTypes != nil {
                map["ExcludedInstanceTypes"] = self.excludedInstanceTypes!
            }
            if self.gpuSpecs != nil {
                map["GpuSpecs"] = self.gpuSpecs!
            }
            if self.instanceCategories != nil {
                map["InstanceCategories"] = self.instanceCategories!
            }
            if self.instanceFamilyLevel != nil {
                map["InstanceFamilyLevel"] = self.instanceFamilyLevel!
            }
            if self.instanceTypeFamilies != nil {
                map["InstanceTypeFamilies"] = self.instanceTypeFamilies!
            }
            if self.maxPrice != nil {
                map["MaxPrice"] = self.maxPrice!
            }
            if self.maximumCpuCoreCount != nil {
                map["MaximumCpuCoreCount"] = self.maximumCpuCoreCount!
            }
            if self.maximumGpuAmount != nil {
                map["MaximumGpuAmount"] = self.maximumGpuAmount!
            }
            if self.maximumMemorySize != nil {
                map["MaximumMemorySize"] = self.maximumMemorySize!
            }
            if self.memory != nil {
                map["Memory"] = self.memory!
            }
            if self.minimumBaselineCredit != nil {
                map["MinimumBaselineCredit"] = self.minimumBaselineCredit!
            }
            if self.minimumCpuCoreCount != nil {
                map["MinimumCpuCoreCount"] = self.minimumCpuCoreCount!
            }
            if self.minimumEniIpv6AddressQuantity != nil {
                map["MinimumEniIpv6AddressQuantity"] = self.minimumEniIpv6AddressQuantity!
            }
            if self.minimumEniPrivateIpAddressQuantity != nil {
                map["MinimumEniPrivateIpAddressQuantity"] = self.minimumEniPrivateIpAddressQuantity!
            }
            if self.minimumEniQuantity != nil {
                map["MinimumEniQuantity"] = self.minimumEniQuantity!
            }
            if self.minimumGpuAmount != nil {
                map["MinimumGpuAmount"] = self.minimumGpuAmount!
            }
            if self.minimumInitialCredit != nil {
                map["MinimumInitialCredit"] = self.minimumInitialCredit!
            }
            if self.minimumMemorySize != nil {
                map["MinimumMemorySize"] = self.minimumMemorySize!
            }
            if self.physicalProcessorModels != nil {
                map["PhysicalProcessorModels"] = self.physicalProcessorModels!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Architectures") {
                self.architectures = dict["Architectures"] as! [String]
            }
            if dict.keys.contains("BurstablePerformance") {
                self.burstablePerformance = dict["BurstablePerformance"] as! String
            }
            if dict.keys.contains("Cores") {
                self.cores = dict["Cores"] as! Int32
            }
            if dict.keys.contains("CpuArchitectures") {
                self.cpuArchitectures = dict["CpuArchitectures"] as! [String]
            }
            if dict.keys.contains("ExcludedInstanceTypes") {
                self.excludedInstanceTypes = dict["ExcludedInstanceTypes"] as! [String]
            }
            if dict.keys.contains("GpuSpecs") {
                self.gpuSpecs = dict["GpuSpecs"] as! [String]
            }
            if dict.keys.contains("InstanceCategories") {
                self.instanceCategories = dict["InstanceCategories"] as! [String]
            }
            if dict.keys.contains("InstanceFamilyLevel") {
                self.instanceFamilyLevel = dict["InstanceFamilyLevel"] as! String
            }
            if dict.keys.contains("InstanceTypeFamilies") {
                self.instanceTypeFamilies = dict["InstanceTypeFamilies"] as! [String]
            }
            if dict.keys.contains("MaxPrice") {
                self.maxPrice = dict["MaxPrice"] as! Double
            }
            if dict.keys.contains("MaximumCpuCoreCount") {
                self.maximumCpuCoreCount = dict["MaximumCpuCoreCount"] as! Int32
            }
            if dict.keys.contains("MaximumGpuAmount") {
                self.maximumGpuAmount = dict["MaximumGpuAmount"] as! Int32
            }
            if dict.keys.contains("MaximumMemorySize") {
                self.maximumMemorySize = dict["MaximumMemorySize"] as! Double
            }
            if dict.keys.contains("Memory") {
                self.memory = dict["Memory"] as! Double
            }
            if dict.keys.contains("MinimumBaselineCredit") {
                self.minimumBaselineCredit = dict["MinimumBaselineCredit"] as! Int32
            }
            if dict.keys.contains("MinimumCpuCoreCount") {
                self.minimumCpuCoreCount = dict["MinimumCpuCoreCount"] as! Int32
            }
            if dict.keys.contains("MinimumEniIpv6AddressQuantity") {
                self.minimumEniIpv6AddressQuantity = dict["MinimumEniIpv6AddressQuantity"] as! Int32
            }
            if dict.keys.contains("MinimumEniPrivateIpAddressQuantity") {
                self.minimumEniPrivateIpAddressQuantity = dict["MinimumEniPrivateIpAddressQuantity"] as! Int32
            }
            if dict.keys.contains("MinimumEniQuantity") {
                self.minimumEniQuantity = dict["MinimumEniQuantity"] as! Int32
            }
            if dict.keys.contains("MinimumGpuAmount") {
                self.minimumGpuAmount = dict["MinimumGpuAmount"] as! Int32
            }
            if dict.keys.contains("MinimumInitialCredit") {
                self.minimumInitialCredit = dict["MinimumInitialCredit"] as! Int32
            }
            if dict.keys.contains("MinimumMemorySize") {
                self.minimumMemorySize = dict["MinimumMemorySize"] as! Double
            }
            if dict.keys.contains("PhysicalProcessorModels") {
                self.physicalProcessorModels = dict["PhysicalProcessorModels"] as! [String]
            }
        }
    }
    public class InstanceTypeOverrides : Tea.TeaModel {
        public var instanceType: String?

        public var weightedCapacity: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.weightedCapacity != nil {
                map["WeightedCapacity"] = self.weightedCapacity!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceType") {
                self.instanceType = dict["InstanceType"] as! String
            }
            if dict.keys.contains("WeightedCapacity") {
                self.weightedCapacity = dict["WeightedCapacity"] as! Int32
            }
        }
    }
    public class NetworkInterfaces : Tea.TeaModel {
        public var instanceType: String?

        public var ipv6AddressCount: Int32?

        public var networkInterfaceTrafficMode: String?

        public var securityGroupIds: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.ipv6AddressCount != nil {
                map["Ipv6AddressCount"] = self.ipv6AddressCount!
            }
            if self.networkInterfaceTrafficMode != nil {
                map["NetworkInterfaceTrafficMode"] = self.networkInterfaceTrafficMode!
            }
            if self.securityGroupIds != nil {
                map["SecurityGroupIds"] = self.securityGroupIds!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceType") {
                self.instanceType = dict["InstanceType"] as! String
            }
            if dict.keys.contains("Ipv6AddressCount") {
                self.ipv6AddressCount = dict["Ipv6AddressCount"] as! Int32
            }
            if dict.keys.contains("NetworkInterfaceTrafficMode") {
                self.networkInterfaceTrafficMode = dict["NetworkInterfaceTrafficMode"] as! String
            }
            if dict.keys.contains("SecurityGroupIds") {
                self.securityGroupIds = dict["SecurityGroupIds"] as! [String]
            }
        }
    }
    public class SecurityOptions : Tea.TeaModel {
        public var confidentialComputingMode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.confidentialComputingMode != nil {
                map["ConfidentialComputingMode"] = self.confidentialComputingMode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConfidentialComputingMode") {
                self.confidentialComputingMode = dict["ConfidentialComputingMode"] as! String
            }
        }
    }
    public class SpotPriceLimits : Tea.TeaModel {
        public var instanceType: String?

        public var priceLimit: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.priceLimit != nil {
                map["PriceLimit"] = self.priceLimit!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceType") {
                self.instanceType = dict["InstanceType"] as! String
            }
            if dict.keys.contains("PriceLimit") {
                self.priceLimit = dict["PriceLimit"] as! Double
            }
        }
    }
    public var imageOptions: ModifyScalingConfigurationRequest.ImageOptions?

    public var privatePoolOptions: ModifyScalingConfigurationRequest.PrivatePoolOptions?

    public var systemDisk: ModifyScalingConfigurationRequest.SystemDisk?

    public var affinity: String?

    public var cpu: Int32?

    public var creditSpecification: String?

    public var customPriorities: [ModifyScalingConfigurationRequest.CustomPriorities]?

    public var dataDisks: [ModifyScalingConfigurationRequest.DataDisks]?

    public var dedicatedHostClusterId: String?

    public var dedicatedHostId: String?

    public var deletionProtection: Bool?

    public var deploymentSetId: String?

    public var hostName: String?

    public var hpcClusterId: String?

    public var httpEndpoint: String?

    public var httpTokens: String?

    public var imageFamily: String?

    public var imageId: String?

    public var imageName: String?

    public var instanceDescription: String?

    public var instanceName: String?

    public var instancePatternInfos: [ModifyScalingConfigurationRequest.InstancePatternInfos]?

    public var instanceTypeOverrides: [ModifyScalingConfigurationRequest.InstanceTypeOverrides]?

    public var instanceTypes: [String]?

    public var internetChargeType: String?

    public var internetMaxBandwidthIn: Int32?

    public var internetMaxBandwidthOut: Int32?

    public var ioOptimized: String?

    public var ipv6AddressCount: Int32?

    public var keyPairName: String?

    public var loadBalancerWeight: Int32?

    public var memory: Int32?

    public var networkInterfaces: [ModifyScalingConfigurationRequest.NetworkInterfaces]?

    public var override_: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var password: String?

    public var passwordInherit: Bool?

    public var ramRoleName: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var scalingConfigurationId: String?

    public var scalingConfigurationName: String?

    public var schedulerOptions: [String: Any]?

    public var securityGroupId: String?

    public var securityGroupIds: [String]?

    public var securityOptions: ModifyScalingConfigurationRequest.SecurityOptions?

    public var spotDuration: Int32?

    public var spotInterruptionBehavior: String?

    public var spotPriceLimits: [ModifyScalingConfigurationRequest.SpotPriceLimits]?

    public var spotStrategy: String?

    public var storageSetId: String?

    public var storageSetPartitionNumber: Int32?

    public var systemDiskCategories: [String]?

    public var tags: String?

    public var tenancy: String?

    public var userData: String?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.imageOptions?.validate()
        try self.privatePoolOptions?.validate()
        try self.systemDisk?.validate()
        try self.securityOptions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imageOptions != nil {
            map["ImageOptions"] = self.imageOptions?.toMap()
        }
        if self.privatePoolOptions != nil {
            map["PrivatePoolOptions"] = self.privatePoolOptions?.toMap()
        }
        if self.systemDisk != nil {
            map["SystemDisk"] = self.systemDisk?.toMap()
        }
        if self.affinity != nil {
            map["Affinity"] = self.affinity!
        }
        if self.cpu != nil {
            map["Cpu"] = self.cpu!
        }
        if self.creditSpecification != nil {
            map["CreditSpecification"] = self.creditSpecification!
        }
        if self.customPriorities != nil {
            var tmp : [Any] = []
            for k in self.customPriorities! {
                tmp.append(k.toMap())
            }
            map["CustomPriorities"] = tmp
        }
        if self.dataDisks != nil {
            var tmp : [Any] = []
            for k in self.dataDisks! {
                tmp.append(k.toMap())
            }
            map["DataDisks"] = tmp
        }
        if self.dedicatedHostClusterId != nil {
            map["DedicatedHostClusterId"] = self.dedicatedHostClusterId!
        }
        if self.dedicatedHostId != nil {
            map["DedicatedHostId"] = self.dedicatedHostId!
        }
        if self.deletionProtection != nil {
            map["DeletionProtection"] = self.deletionProtection!
        }
        if self.deploymentSetId != nil {
            map["DeploymentSetId"] = self.deploymentSetId!
        }
        if self.hostName != nil {
            map["HostName"] = self.hostName!
        }
        if self.hpcClusterId != nil {
            map["HpcClusterId"] = self.hpcClusterId!
        }
        if self.httpEndpoint != nil {
            map["HttpEndpoint"] = self.httpEndpoint!
        }
        if self.httpTokens != nil {
            map["HttpTokens"] = self.httpTokens!
        }
        if self.imageFamily != nil {
            map["ImageFamily"] = self.imageFamily!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.imageName != nil {
            map["ImageName"] = self.imageName!
        }
        if self.instanceDescription != nil {
            map["InstanceDescription"] = self.instanceDescription!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.instancePatternInfos != nil {
            var tmp : [Any] = []
            for k in self.instancePatternInfos! {
                tmp.append(k.toMap())
            }
            map["InstancePatternInfos"] = tmp
        }
        if self.instanceTypeOverrides != nil {
            var tmp : [Any] = []
            for k in self.instanceTypeOverrides! {
                tmp.append(k.toMap())
            }
            map["InstanceTypeOverrides"] = tmp
        }
        if self.instanceTypes != nil {
            map["InstanceTypes"] = self.instanceTypes!
        }
        if self.internetChargeType != nil {
            map["InternetChargeType"] = self.internetChargeType!
        }
        if self.internetMaxBandwidthIn != nil {
            map["InternetMaxBandwidthIn"] = self.internetMaxBandwidthIn!
        }
        if self.internetMaxBandwidthOut != nil {
            map["InternetMaxBandwidthOut"] = self.internetMaxBandwidthOut!
        }
        if self.ioOptimized != nil {
            map["IoOptimized"] = self.ioOptimized!
        }
        if self.ipv6AddressCount != nil {
            map["Ipv6AddressCount"] = self.ipv6AddressCount!
        }
        if self.keyPairName != nil {
            map["KeyPairName"] = self.keyPairName!
        }
        if self.loadBalancerWeight != nil {
            map["LoadBalancerWeight"] = self.loadBalancerWeight!
        }
        if self.memory != nil {
            map["Memory"] = self.memory!
        }
        if self.networkInterfaces != nil {
            var tmp : [Any] = []
            for k in self.networkInterfaces! {
                tmp.append(k.toMap())
            }
            map["NetworkInterfaces"] = tmp
        }
        if self.override_ != nil {
            map["Override"] = self.override_!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        if self.passwordInherit != nil {
            map["PasswordInherit"] = self.passwordInherit!
        }
        if self.ramRoleName != nil {
            map["RamRoleName"] = self.ramRoleName!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingConfigurationId != nil {
            map["ScalingConfigurationId"] = self.scalingConfigurationId!
        }
        if self.scalingConfigurationName != nil {
            map["ScalingConfigurationName"] = self.scalingConfigurationName!
        }
        if self.schedulerOptions != nil {
            map["SchedulerOptions"] = self.schedulerOptions!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.securityGroupIds != nil {
            map["SecurityGroupIds"] = self.securityGroupIds!
        }
        if self.securityOptions != nil {
            map["SecurityOptions"] = self.securityOptions?.toMap()
        }
        if self.spotDuration != nil {
            map["SpotDuration"] = self.spotDuration!
        }
        if self.spotInterruptionBehavior != nil {
            map["SpotInterruptionBehavior"] = self.spotInterruptionBehavior!
        }
        if self.spotPriceLimits != nil {
            var tmp : [Any] = []
            for k in self.spotPriceLimits! {
                tmp.append(k.toMap())
            }
            map["SpotPriceLimits"] = tmp
        }
        if self.spotStrategy != nil {
            map["SpotStrategy"] = self.spotStrategy!
        }
        if self.storageSetId != nil {
            map["StorageSetId"] = self.storageSetId!
        }
        if self.storageSetPartitionNumber != nil {
            map["StorageSetPartitionNumber"] = self.storageSetPartitionNumber!
        }
        if self.systemDiskCategories != nil {
            map["SystemDiskCategories"] = self.systemDiskCategories!
        }
        if self.tags != nil {
            map["Tags"] = self.tags!
        }
        if self.tenancy != nil {
            map["Tenancy"] = self.tenancy!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ImageOptions") {
            var model = ModifyScalingConfigurationRequest.ImageOptions()
            model.fromMap(dict["ImageOptions"] as! [String: Any])
            self.imageOptions = model
        }
        if dict.keys.contains("PrivatePoolOptions") {
            var model = ModifyScalingConfigurationRequest.PrivatePoolOptions()
            model.fromMap(dict["PrivatePoolOptions"] as! [String: Any])
            self.privatePoolOptions = model
        }
        if dict.keys.contains("SystemDisk") {
            var model = ModifyScalingConfigurationRequest.SystemDisk()
            model.fromMap(dict["SystemDisk"] as! [String: Any])
            self.systemDisk = model
        }
        if dict.keys.contains("Affinity") {
            self.affinity = dict["Affinity"] as! String
        }
        if dict.keys.contains("Cpu") {
            self.cpu = dict["Cpu"] as! Int32
        }
        if dict.keys.contains("CreditSpecification") {
            self.creditSpecification = dict["CreditSpecification"] as! String
        }
        if dict.keys.contains("CustomPriorities") {
            var tmp : [ModifyScalingConfigurationRequest.CustomPriorities] = []
            for v in dict["CustomPriorities"] as! [Any] {
                var model = ModifyScalingConfigurationRequest.CustomPriorities()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.customPriorities = tmp
        }
        if dict.keys.contains("DataDisks") {
            var tmp : [ModifyScalingConfigurationRequest.DataDisks] = []
            for v in dict["DataDisks"] as! [Any] {
                var model = ModifyScalingConfigurationRequest.DataDisks()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.dataDisks = tmp
        }
        if dict.keys.contains("DedicatedHostClusterId") {
            self.dedicatedHostClusterId = dict["DedicatedHostClusterId"] as! String
        }
        if dict.keys.contains("DedicatedHostId") {
            self.dedicatedHostId = dict["DedicatedHostId"] as! String
        }
        if dict.keys.contains("DeletionProtection") {
            self.deletionProtection = dict["DeletionProtection"] as! Bool
        }
        if dict.keys.contains("DeploymentSetId") {
            self.deploymentSetId = dict["DeploymentSetId"] as! String
        }
        if dict.keys.contains("HostName") {
            self.hostName = dict["HostName"] as! String
        }
        if dict.keys.contains("HpcClusterId") {
            self.hpcClusterId = dict["HpcClusterId"] as! String
        }
        if dict.keys.contains("HttpEndpoint") {
            self.httpEndpoint = dict["HttpEndpoint"] as! String
        }
        if dict.keys.contains("HttpTokens") {
            self.httpTokens = dict["HttpTokens"] as! String
        }
        if dict.keys.contains("ImageFamily") {
            self.imageFamily = dict["ImageFamily"] as! String
        }
        if dict.keys.contains("ImageId") {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("ImageName") {
            self.imageName = dict["ImageName"] as! String
        }
        if dict.keys.contains("InstanceDescription") {
            self.instanceDescription = dict["InstanceDescription"] as! String
        }
        if dict.keys.contains("InstanceName") {
            self.instanceName = dict["InstanceName"] as! String
        }
        if dict.keys.contains("InstancePatternInfos") {
            var tmp : [ModifyScalingConfigurationRequest.InstancePatternInfos] = []
            for v in dict["InstancePatternInfos"] as! [Any] {
                var model = ModifyScalingConfigurationRequest.InstancePatternInfos()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.instancePatternInfos = tmp
        }
        if dict.keys.contains("InstanceTypeOverrides") {
            var tmp : [ModifyScalingConfigurationRequest.InstanceTypeOverrides] = []
            for v in dict["InstanceTypeOverrides"] as! [Any] {
                var model = ModifyScalingConfigurationRequest.InstanceTypeOverrides()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.instanceTypeOverrides = tmp
        }
        if dict.keys.contains("InstanceTypes") {
            self.instanceTypes = dict["InstanceTypes"] as! [String]
        }
        if dict.keys.contains("InternetChargeType") {
            self.internetChargeType = dict["InternetChargeType"] as! String
        }
        if dict.keys.contains("InternetMaxBandwidthIn") {
            self.internetMaxBandwidthIn = dict["InternetMaxBandwidthIn"] as! Int32
        }
        if dict.keys.contains("InternetMaxBandwidthOut") {
            self.internetMaxBandwidthOut = dict["InternetMaxBandwidthOut"] as! Int32
        }
        if dict.keys.contains("IoOptimized") {
            self.ioOptimized = dict["IoOptimized"] as! String
        }
        if dict.keys.contains("Ipv6AddressCount") {
            self.ipv6AddressCount = dict["Ipv6AddressCount"] as! Int32
        }
        if dict.keys.contains("KeyPairName") {
            self.keyPairName = dict["KeyPairName"] as! String
        }
        if dict.keys.contains("LoadBalancerWeight") {
            self.loadBalancerWeight = dict["LoadBalancerWeight"] as! Int32
        }
        if dict.keys.contains("Memory") {
            self.memory = dict["Memory"] as! Int32
        }
        if dict.keys.contains("NetworkInterfaces") {
            var tmp : [ModifyScalingConfigurationRequest.NetworkInterfaces] = []
            for v in dict["NetworkInterfaces"] as! [Any] {
                var model = ModifyScalingConfigurationRequest.NetworkInterfaces()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.networkInterfaces = tmp
        }
        if dict.keys.contains("Override") {
            self.override_ = dict["Override"] as! Bool
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Password") {
            self.password = dict["Password"] as! String
        }
        if dict.keys.contains("PasswordInherit") {
            self.passwordInherit = dict["PasswordInherit"] as! Bool
        }
        if dict.keys.contains("RamRoleName") {
            self.ramRoleName = dict["RamRoleName"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScalingConfigurationId") {
            self.scalingConfigurationId = dict["ScalingConfigurationId"] as! String
        }
        if dict.keys.contains("ScalingConfigurationName") {
            self.scalingConfigurationName = dict["ScalingConfigurationName"] as! String
        }
        if dict.keys.contains("SchedulerOptions") {
            self.schedulerOptions = dict["SchedulerOptions"] as! [String: Any]
        }
        if dict.keys.contains("SecurityGroupId") {
            self.securityGroupId = dict["SecurityGroupId"] as! String
        }
        if dict.keys.contains("SecurityGroupIds") {
            self.securityGroupIds = dict["SecurityGroupIds"] as! [String]
        }
        if dict.keys.contains("SecurityOptions") {
            var model = ModifyScalingConfigurationRequest.SecurityOptions()
            model.fromMap(dict["SecurityOptions"] as! [String: Any])
            self.securityOptions = model
        }
        if dict.keys.contains("SpotDuration") {
            self.spotDuration = dict["SpotDuration"] as! Int32
        }
        if dict.keys.contains("SpotInterruptionBehavior") {
            self.spotInterruptionBehavior = dict["SpotInterruptionBehavior"] as! String
        }
        if dict.keys.contains("SpotPriceLimits") {
            var tmp : [ModifyScalingConfigurationRequest.SpotPriceLimits] = []
            for v in dict["SpotPriceLimits"] as! [Any] {
                var model = ModifyScalingConfigurationRequest.SpotPriceLimits()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.spotPriceLimits = tmp
        }
        if dict.keys.contains("SpotStrategy") {
            self.spotStrategy = dict["SpotStrategy"] as! String
        }
        if dict.keys.contains("StorageSetId") {
            self.storageSetId = dict["StorageSetId"] as! String
        }
        if dict.keys.contains("StorageSetPartitionNumber") {
            self.storageSetPartitionNumber = dict["StorageSetPartitionNumber"] as! Int32
        }
        if dict.keys.contains("SystemDiskCategories") {
            self.systemDiskCategories = dict["SystemDiskCategories"] as! [String]
        }
        if dict.keys.contains("Tags") {
            self.tags = dict["Tags"] as! String
        }
        if dict.keys.contains("Tenancy") {
            self.tenancy = dict["Tenancy"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! String
        }
    }
}

public class ModifyScalingConfigurationShrinkRequest : Tea.TeaModel {
    public class ImageOptions : Tea.TeaModel {
        public var loginAsNonRoot: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.loginAsNonRoot != nil {
                map["LoginAsNonRoot"] = self.loginAsNonRoot!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LoginAsNonRoot") {
                self.loginAsNonRoot = dict["LoginAsNonRoot"] as! Bool
            }
        }
    }
    public class PrivatePoolOptions : Tea.TeaModel {
        public var id: String?

        public var matchCriteria: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.matchCriteria != nil {
                map["MatchCriteria"] = self.matchCriteria!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("MatchCriteria") {
                self.matchCriteria = dict["MatchCriteria"] as! String
            }
        }
    }
    public class SystemDisk : Tea.TeaModel {
        public var autoSnapshotPolicyId: String?

        public var burstingEnabled: Bool?

        public var category: String?

        public var description_: String?

        public var diskName: String?

        public var encryptAlgorithm: String?

        public var encrypted: Bool?

        public var KMSKeyId: String?

        public var performanceLevel: String?

        public var provisionedIops: Int64?

        public var size: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.autoSnapshotPolicyId != nil {
                map["AutoSnapshotPolicyId"] = self.autoSnapshotPolicyId!
            }
            if self.burstingEnabled != nil {
                map["BurstingEnabled"] = self.burstingEnabled!
            }
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.diskName != nil {
                map["DiskName"] = self.diskName!
            }
            if self.encryptAlgorithm != nil {
                map["EncryptAlgorithm"] = self.encryptAlgorithm!
            }
            if self.encrypted != nil {
                map["Encrypted"] = self.encrypted!
            }
            if self.KMSKeyId != nil {
                map["KMSKeyId"] = self.KMSKeyId!
            }
            if self.performanceLevel != nil {
                map["PerformanceLevel"] = self.performanceLevel!
            }
            if self.provisionedIops != nil {
                map["ProvisionedIops"] = self.provisionedIops!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AutoSnapshotPolicyId") {
                self.autoSnapshotPolicyId = dict["AutoSnapshotPolicyId"] as! String
            }
            if dict.keys.contains("BurstingEnabled") {
                self.burstingEnabled = dict["BurstingEnabled"] as! Bool
            }
            if dict.keys.contains("Category") {
                self.category = dict["Category"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("DiskName") {
                self.diskName = dict["DiskName"] as! String
            }
            if dict.keys.contains("EncryptAlgorithm") {
                self.encryptAlgorithm = dict["EncryptAlgorithm"] as! String
            }
            if dict.keys.contains("Encrypted") {
                self.encrypted = dict["Encrypted"] as! Bool
            }
            if dict.keys.contains("KMSKeyId") {
                self.KMSKeyId = dict["KMSKeyId"] as! String
            }
            if dict.keys.contains("PerformanceLevel") {
                self.performanceLevel = dict["PerformanceLevel"] as! String
            }
            if dict.keys.contains("ProvisionedIops") {
                self.provisionedIops = dict["ProvisionedIops"] as! Int64
            }
            if dict.keys.contains("Size") {
                self.size = dict["Size"] as! Int32
            }
        }
    }
    public class CustomPriorities : Tea.TeaModel {
        public var instanceType: String?

        public var vswitchId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.vswitchId != nil {
                map["VswitchId"] = self.vswitchId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceType") {
                self.instanceType = dict["InstanceType"] as! String
            }
            if dict.keys.contains("VswitchId") {
                self.vswitchId = dict["VswitchId"] as! String
            }
        }
    }
    public class DataDisks : Tea.TeaModel {
        public var autoSnapshotPolicyId: String?

        public var burstingEnabled: Bool?

        public var categories: [String]?

        public var category: String?

        public var deleteWithInstance: Bool?

        public var description_: String?

        public var device: String?

        public var diskName: String?

        public var encrypted: String?

        public var KMSKeyId: String?

        public var performanceLevel: String?

        public var provisionedIops: Int64?

        public var size: Int32?

        public var snapshotId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.autoSnapshotPolicyId != nil {
                map["AutoSnapshotPolicyId"] = self.autoSnapshotPolicyId!
            }
            if self.burstingEnabled != nil {
                map["BurstingEnabled"] = self.burstingEnabled!
            }
            if self.categories != nil {
                map["Categories"] = self.categories!
            }
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.deleteWithInstance != nil {
                map["DeleteWithInstance"] = self.deleteWithInstance!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.device != nil {
                map["Device"] = self.device!
            }
            if self.diskName != nil {
                map["DiskName"] = self.diskName!
            }
            if self.encrypted != nil {
                map["Encrypted"] = self.encrypted!
            }
            if self.KMSKeyId != nil {
                map["KMSKeyId"] = self.KMSKeyId!
            }
            if self.performanceLevel != nil {
                map["PerformanceLevel"] = self.performanceLevel!
            }
            if self.provisionedIops != nil {
                map["ProvisionedIops"] = self.provisionedIops!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.snapshotId != nil {
                map["SnapshotId"] = self.snapshotId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AutoSnapshotPolicyId") {
                self.autoSnapshotPolicyId = dict["AutoSnapshotPolicyId"] as! String
            }
            if dict.keys.contains("BurstingEnabled") {
                self.burstingEnabled = dict["BurstingEnabled"] as! Bool
            }
            if dict.keys.contains("Categories") {
                self.categories = dict["Categories"] as! [String]
            }
            if dict.keys.contains("Category") {
                self.category = dict["Category"] as! String
            }
            if dict.keys.contains("DeleteWithInstance") {
                self.deleteWithInstance = dict["DeleteWithInstance"] as! Bool
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Device") {
                self.device = dict["Device"] as! String
            }
            if dict.keys.contains("DiskName") {
                self.diskName = dict["DiskName"] as! String
            }
            if dict.keys.contains("Encrypted") {
                self.encrypted = dict["Encrypted"] as! String
            }
            if dict.keys.contains("KMSKeyId") {
                self.KMSKeyId = dict["KMSKeyId"] as! String
            }
            if dict.keys.contains("PerformanceLevel") {
                self.performanceLevel = dict["PerformanceLevel"] as! String
            }
            if dict.keys.contains("ProvisionedIops") {
                self.provisionedIops = dict["ProvisionedIops"] as! Int64
            }
            if dict.keys.contains("Size") {
                self.size = dict["Size"] as! Int32
            }
            if dict.keys.contains("SnapshotId") {
                self.snapshotId = dict["SnapshotId"] as! String
            }
        }
    }
    public class InstancePatternInfos : Tea.TeaModel {
        public var architectures: [String]?

        public var burstablePerformance: String?

        public var cores: Int32?

        public var cpuArchitectures: [String]?

        public var excludedInstanceTypes: [String]?

        public var gpuSpecs: [String]?

        public var instanceCategories: [String]?

        public var instanceFamilyLevel: String?

        public var instanceTypeFamilies: [String]?

        public var maxPrice: Double?

        public var maximumCpuCoreCount: Int32?

        public var maximumGpuAmount: Int32?

        public var maximumMemorySize: Double?

        public var memory: Double?

        public var minimumBaselineCredit: Int32?

        public var minimumCpuCoreCount: Int32?

        public var minimumEniIpv6AddressQuantity: Int32?

        public var minimumEniPrivateIpAddressQuantity: Int32?

        public var minimumEniQuantity: Int32?

        public var minimumGpuAmount: Int32?

        public var minimumInitialCredit: Int32?

        public var minimumMemorySize: Double?

        public var physicalProcessorModels: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.architectures != nil {
                map["Architectures"] = self.architectures!
            }
            if self.burstablePerformance != nil {
                map["BurstablePerformance"] = self.burstablePerformance!
            }
            if self.cores != nil {
                map["Cores"] = self.cores!
            }
            if self.cpuArchitectures != nil {
                map["CpuArchitectures"] = self.cpuArchitectures!
            }
            if self.excludedInstanceTypes != nil {
                map["ExcludedInstanceTypes"] = self.excludedInstanceTypes!
            }
            if self.gpuSpecs != nil {
                map["GpuSpecs"] = self.gpuSpecs!
            }
            if self.instanceCategories != nil {
                map["InstanceCategories"] = self.instanceCategories!
            }
            if self.instanceFamilyLevel != nil {
                map["InstanceFamilyLevel"] = self.instanceFamilyLevel!
            }
            if self.instanceTypeFamilies != nil {
                map["InstanceTypeFamilies"] = self.instanceTypeFamilies!
            }
            if self.maxPrice != nil {
                map["MaxPrice"] = self.maxPrice!
            }
            if self.maximumCpuCoreCount != nil {
                map["MaximumCpuCoreCount"] = self.maximumCpuCoreCount!
            }
            if self.maximumGpuAmount != nil {
                map["MaximumGpuAmount"] = self.maximumGpuAmount!
            }
            if self.maximumMemorySize != nil {
                map["MaximumMemorySize"] = self.maximumMemorySize!
            }
            if self.memory != nil {
                map["Memory"] = self.memory!
            }
            if self.minimumBaselineCredit != nil {
                map["MinimumBaselineCredit"] = self.minimumBaselineCredit!
            }
            if self.minimumCpuCoreCount != nil {
                map["MinimumCpuCoreCount"] = self.minimumCpuCoreCount!
            }
            if self.minimumEniIpv6AddressQuantity != nil {
                map["MinimumEniIpv6AddressQuantity"] = self.minimumEniIpv6AddressQuantity!
            }
            if self.minimumEniPrivateIpAddressQuantity != nil {
                map["MinimumEniPrivateIpAddressQuantity"] = self.minimumEniPrivateIpAddressQuantity!
            }
            if self.minimumEniQuantity != nil {
                map["MinimumEniQuantity"] = self.minimumEniQuantity!
            }
            if self.minimumGpuAmount != nil {
                map["MinimumGpuAmount"] = self.minimumGpuAmount!
            }
            if self.minimumInitialCredit != nil {
                map["MinimumInitialCredit"] = self.minimumInitialCredit!
            }
            if self.minimumMemorySize != nil {
                map["MinimumMemorySize"] = self.minimumMemorySize!
            }
            if self.physicalProcessorModels != nil {
                map["PhysicalProcessorModels"] = self.physicalProcessorModels!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Architectures") {
                self.architectures = dict["Architectures"] as! [String]
            }
            if dict.keys.contains("BurstablePerformance") {
                self.burstablePerformance = dict["BurstablePerformance"] as! String
            }
            if dict.keys.contains("Cores") {
                self.cores = dict["Cores"] as! Int32
            }
            if dict.keys.contains("CpuArchitectures") {
                self.cpuArchitectures = dict["CpuArchitectures"] as! [String]
            }
            if dict.keys.contains("ExcludedInstanceTypes") {
                self.excludedInstanceTypes = dict["ExcludedInstanceTypes"] as! [String]
            }
            if dict.keys.contains("GpuSpecs") {
                self.gpuSpecs = dict["GpuSpecs"] as! [String]
            }
            if dict.keys.contains("InstanceCategories") {
                self.instanceCategories = dict["InstanceCategories"] as! [String]
            }
            if dict.keys.contains("InstanceFamilyLevel") {
                self.instanceFamilyLevel = dict["InstanceFamilyLevel"] as! String
            }
            if dict.keys.contains("InstanceTypeFamilies") {
                self.instanceTypeFamilies = dict["InstanceTypeFamilies"] as! [String]
            }
            if dict.keys.contains("MaxPrice") {
                self.maxPrice = dict["MaxPrice"] as! Double
            }
            if dict.keys.contains("MaximumCpuCoreCount") {
                self.maximumCpuCoreCount = dict["MaximumCpuCoreCount"] as! Int32
            }
            if dict.keys.contains("MaximumGpuAmount") {
                self.maximumGpuAmount = dict["MaximumGpuAmount"] as! Int32
            }
            if dict.keys.contains("MaximumMemorySize") {
                self.maximumMemorySize = dict["MaximumMemorySize"] as! Double
            }
            if dict.keys.contains("Memory") {
                self.memory = dict["Memory"] as! Double
            }
            if dict.keys.contains("MinimumBaselineCredit") {
                self.minimumBaselineCredit = dict["MinimumBaselineCredit"] as! Int32
            }
            if dict.keys.contains("MinimumCpuCoreCount") {
                self.minimumCpuCoreCount = dict["MinimumCpuCoreCount"] as! Int32
            }
            if dict.keys.contains("MinimumEniIpv6AddressQuantity") {
                self.minimumEniIpv6AddressQuantity = dict["MinimumEniIpv6AddressQuantity"] as! Int32
            }
            if dict.keys.contains("MinimumEniPrivateIpAddressQuantity") {
                self.minimumEniPrivateIpAddressQuantity = dict["MinimumEniPrivateIpAddressQuantity"] as! Int32
            }
            if dict.keys.contains("MinimumEniQuantity") {
                self.minimumEniQuantity = dict["MinimumEniQuantity"] as! Int32
            }
            if dict.keys.contains("MinimumGpuAmount") {
                self.minimumGpuAmount = dict["MinimumGpuAmount"] as! Int32
            }
            if dict.keys.contains("MinimumInitialCredit") {
                self.minimumInitialCredit = dict["MinimumInitialCredit"] as! Int32
            }
            if dict.keys.contains("MinimumMemorySize") {
                self.minimumMemorySize = dict["MinimumMemorySize"] as! Double
            }
            if dict.keys.contains("PhysicalProcessorModels") {
                self.physicalProcessorModels = dict["PhysicalProcessorModels"] as! [String]
            }
        }
    }
    public class InstanceTypeOverrides : Tea.TeaModel {
        public var instanceType: String?

        public var weightedCapacity: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.weightedCapacity != nil {
                map["WeightedCapacity"] = self.weightedCapacity!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceType") {
                self.instanceType = dict["InstanceType"] as! String
            }
            if dict.keys.contains("WeightedCapacity") {
                self.weightedCapacity = dict["WeightedCapacity"] as! Int32
            }
        }
    }
    public class NetworkInterfaces : Tea.TeaModel {
        public var instanceType: String?

        public var ipv6AddressCount: Int32?

        public var networkInterfaceTrafficMode: String?

        public var securityGroupIds: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.ipv6AddressCount != nil {
                map["Ipv6AddressCount"] = self.ipv6AddressCount!
            }
            if self.networkInterfaceTrafficMode != nil {
                map["NetworkInterfaceTrafficMode"] = self.networkInterfaceTrafficMode!
            }
            if self.securityGroupIds != nil {
                map["SecurityGroupIds"] = self.securityGroupIds!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceType") {
                self.instanceType = dict["InstanceType"] as! String
            }
            if dict.keys.contains("Ipv6AddressCount") {
                self.ipv6AddressCount = dict["Ipv6AddressCount"] as! Int32
            }
            if dict.keys.contains("NetworkInterfaceTrafficMode") {
                self.networkInterfaceTrafficMode = dict["NetworkInterfaceTrafficMode"] as! String
            }
            if dict.keys.contains("SecurityGroupIds") {
                self.securityGroupIds = dict["SecurityGroupIds"] as! [String]
            }
        }
    }
    public class SecurityOptions : Tea.TeaModel {
        public var confidentialComputingMode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.confidentialComputingMode != nil {
                map["ConfidentialComputingMode"] = self.confidentialComputingMode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConfidentialComputingMode") {
                self.confidentialComputingMode = dict["ConfidentialComputingMode"] as! String
            }
        }
    }
    public class SpotPriceLimits : Tea.TeaModel {
        public var instanceType: String?

        public var priceLimit: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.priceLimit != nil {
                map["PriceLimit"] = self.priceLimit!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceType") {
                self.instanceType = dict["InstanceType"] as! String
            }
            if dict.keys.contains("PriceLimit") {
                self.priceLimit = dict["PriceLimit"] as! Double
            }
        }
    }
    public var imageOptions: ModifyScalingConfigurationShrinkRequest.ImageOptions?

    public var privatePoolOptions: ModifyScalingConfigurationShrinkRequest.PrivatePoolOptions?

    public var systemDisk: ModifyScalingConfigurationShrinkRequest.SystemDisk?

    public var affinity: String?

    public var cpu: Int32?

    public var creditSpecification: String?

    public var customPriorities: [ModifyScalingConfigurationShrinkRequest.CustomPriorities]?

    public var dataDisks: [ModifyScalingConfigurationShrinkRequest.DataDisks]?

    public var dedicatedHostClusterId: String?

    public var dedicatedHostId: String?

    public var deletionProtection: Bool?

    public var deploymentSetId: String?

    public var hostName: String?

    public var hpcClusterId: String?

    public var httpEndpoint: String?

    public var httpTokens: String?

    public var imageFamily: String?

    public var imageId: String?

    public var imageName: String?

    public var instanceDescription: String?

    public var instanceName: String?

    public var instancePatternInfos: [ModifyScalingConfigurationShrinkRequest.InstancePatternInfos]?

    public var instanceTypeOverrides: [ModifyScalingConfigurationShrinkRequest.InstanceTypeOverrides]?

    public var instanceTypes: [String]?

    public var internetChargeType: String?

    public var internetMaxBandwidthIn: Int32?

    public var internetMaxBandwidthOut: Int32?

    public var ioOptimized: String?

    public var ipv6AddressCount: Int32?

    public var keyPairName: String?

    public var loadBalancerWeight: Int32?

    public var memory: Int32?

    public var networkInterfaces: [ModifyScalingConfigurationShrinkRequest.NetworkInterfaces]?

    public var override_: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var password: String?

    public var passwordInherit: Bool?

    public var ramRoleName: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var scalingConfigurationId: String?

    public var scalingConfigurationName: String?

    public var schedulerOptionsShrink: String?

    public var securityGroupId: String?

    public var securityGroupIds: [String]?

    public var securityOptions: ModifyScalingConfigurationShrinkRequest.SecurityOptions?

    public var spotDuration: Int32?

    public var spotInterruptionBehavior: String?

    public var spotPriceLimits: [ModifyScalingConfigurationShrinkRequest.SpotPriceLimits]?

    public var spotStrategy: String?

    public var storageSetId: String?

    public var storageSetPartitionNumber: Int32?

    public var systemDiskCategories: [String]?

    public var tags: String?

    public var tenancy: String?

    public var userData: String?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.imageOptions?.validate()
        try self.privatePoolOptions?.validate()
        try self.systemDisk?.validate()
        try self.securityOptions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imageOptions != nil {
            map["ImageOptions"] = self.imageOptions?.toMap()
        }
        if self.privatePoolOptions != nil {
            map["PrivatePoolOptions"] = self.privatePoolOptions?.toMap()
        }
        if self.systemDisk != nil {
            map["SystemDisk"] = self.systemDisk?.toMap()
        }
        if self.affinity != nil {
            map["Affinity"] = self.affinity!
        }
        if self.cpu != nil {
            map["Cpu"] = self.cpu!
        }
        if self.creditSpecification != nil {
            map["CreditSpecification"] = self.creditSpecification!
        }
        if self.customPriorities != nil {
            var tmp : [Any] = []
            for k in self.customPriorities! {
                tmp.append(k.toMap())
            }
            map["CustomPriorities"] = tmp
        }
        if self.dataDisks != nil {
            var tmp : [Any] = []
            for k in self.dataDisks! {
                tmp.append(k.toMap())
            }
            map["DataDisks"] = tmp
        }
        if self.dedicatedHostClusterId != nil {
            map["DedicatedHostClusterId"] = self.dedicatedHostClusterId!
        }
        if self.dedicatedHostId != nil {
            map["DedicatedHostId"] = self.dedicatedHostId!
        }
        if self.deletionProtection != nil {
            map["DeletionProtection"] = self.deletionProtection!
        }
        if self.deploymentSetId != nil {
            map["DeploymentSetId"] = self.deploymentSetId!
        }
        if self.hostName != nil {
            map["HostName"] = self.hostName!
        }
        if self.hpcClusterId != nil {
            map["HpcClusterId"] = self.hpcClusterId!
        }
        if self.httpEndpoint != nil {
            map["HttpEndpoint"] = self.httpEndpoint!
        }
        if self.httpTokens != nil {
            map["HttpTokens"] = self.httpTokens!
        }
        if self.imageFamily != nil {
            map["ImageFamily"] = self.imageFamily!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.imageName != nil {
            map["ImageName"] = self.imageName!
        }
        if self.instanceDescription != nil {
            map["InstanceDescription"] = self.instanceDescription!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.instancePatternInfos != nil {
            var tmp : [Any] = []
            for k in self.instancePatternInfos! {
                tmp.append(k.toMap())
            }
            map["InstancePatternInfos"] = tmp
        }
        if self.instanceTypeOverrides != nil {
            var tmp : [Any] = []
            for k in self.instanceTypeOverrides! {
                tmp.append(k.toMap())
            }
            map["InstanceTypeOverrides"] = tmp
        }
        if self.instanceTypes != nil {
            map["InstanceTypes"] = self.instanceTypes!
        }
        if self.internetChargeType != nil {
            map["InternetChargeType"] = self.internetChargeType!
        }
        if self.internetMaxBandwidthIn != nil {
            map["InternetMaxBandwidthIn"] = self.internetMaxBandwidthIn!
        }
        if self.internetMaxBandwidthOut != nil {
            map["InternetMaxBandwidthOut"] = self.internetMaxBandwidthOut!
        }
        if self.ioOptimized != nil {
            map["IoOptimized"] = self.ioOptimized!
        }
        if self.ipv6AddressCount != nil {
            map["Ipv6AddressCount"] = self.ipv6AddressCount!
        }
        if self.keyPairName != nil {
            map["KeyPairName"] = self.keyPairName!
        }
        if self.loadBalancerWeight != nil {
            map["LoadBalancerWeight"] = self.loadBalancerWeight!
        }
        if self.memory != nil {
            map["Memory"] = self.memory!
        }
        if self.networkInterfaces != nil {
            var tmp : [Any] = []
            for k in self.networkInterfaces! {
                tmp.append(k.toMap())
            }
            map["NetworkInterfaces"] = tmp
        }
        if self.override_ != nil {
            map["Override"] = self.override_!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        if self.passwordInherit != nil {
            map["PasswordInherit"] = self.passwordInherit!
        }
        if self.ramRoleName != nil {
            map["RamRoleName"] = self.ramRoleName!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingConfigurationId != nil {
            map["ScalingConfigurationId"] = self.scalingConfigurationId!
        }
        if self.scalingConfigurationName != nil {
            map["ScalingConfigurationName"] = self.scalingConfigurationName!
        }
        if self.schedulerOptionsShrink != nil {
            map["SchedulerOptions"] = self.schedulerOptionsShrink!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.securityGroupIds != nil {
            map["SecurityGroupIds"] = self.securityGroupIds!
        }
        if self.securityOptions != nil {
            map["SecurityOptions"] = self.securityOptions?.toMap()
        }
        if self.spotDuration != nil {
            map["SpotDuration"] = self.spotDuration!
        }
        if self.spotInterruptionBehavior != nil {
            map["SpotInterruptionBehavior"] = self.spotInterruptionBehavior!
        }
        if self.spotPriceLimits != nil {
            var tmp : [Any] = []
            for k in self.spotPriceLimits! {
                tmp.append(k.toMap())
            }
            map["SpotPriceLimits"] = tmp
        }
        if self.spotStrategy != nil {
            map["SpotStrategy"] = self.spotStrategy!
        }
        if self.storageSetId != nil {
            map["StorageSetId"] = self.storageSetId!
        }
        if self.storageSetPartitionNumber != nil {
            map["StorageSetPartitionNumber"] = self.storageSetPartitionNumber!
        }
        if self.systemDiskCategories != nil {
            map["SystemDiskCategories"] = self.systemDiskCategories!
        }
        if self.tags != nil {
            map["Tags"] = self.tags!
        }
        if self.tenancy != nil {
            map["Tenancy"] = self.tenancy!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ImageOptions") {
            var model = ModifyScalingConfigurationShrinkRequest.ImageOptions()
            model.fromMap(dict["ImageOptions"] as! [String: Any])
            self.imageOptions = model
        }
        if dict.keys.contains("PrivatePoolOptions") {
            var model = ModifyScalingConfigurationShrinkRequest.PrivatePoolOptions()
            model.fromMap(dict["PrivatePoolOptions"] as! [String: Any])
            self.privatePoolOptions = model
        }
        if dict.keys.contains("SystemDisk") {
            var model = ModifyScalingConfigurationShrinkRequest.SystemDisk()
            model.fromMap(dict["SystemDisk"] as! [String: Any])
            self.systemDisk = model
        }
        if dict.keys.contains("Affinity") {
            self.affinity = dict["Affinity"] as! String
        }
        if dict.keys.contains("Cpu") {
            self.cpu = dict["Cpu"] as! Int32
        }
        if dict.keys.contains("CreditSpecification") {
            self.creditSpecification = dict["CreditSpecification"] as! String
        }
        if dict.keys.contains("CustomPriorities") {
            var tmp : [ModifyScalingConfigurationShrinkRequest.CustomPriorities] = []
            for v in dict["CustomPriorities"] as! [Any] {
                var model = ModifyScalingConfigurationShrinkRequest.CustomPriorities()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.customPriorities = tmp
        }
        if dict.keys.contains("DataDisks") {
            var tmp : [ModifyScalingConfigurationShrinkRequest.DataDisks] = []
            for v in dict["DataDisks"] as! [Any] {
                var model = ModifyScalingConfigurationShrinkRequest.DataDisks()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.dataDisks = tmp
        }
        if dict.keys.contains("DedicatedHostClusterId") {
            self.dedicatedHostClusterId = dict["DedicatedHostClusterId"] as! String
        }
        if dict.keys.contains("DedicatedHostId") {
            self.dedicatedHostId = dict["DedicatedHostId"] as! String
        }
        if dict.keys.contains("DeletionProtection") {
            self.deletionProtection = dict["DeletionProtection"] as! Bool
        }
        if dict.keys.contains("DeploymentSetId") {
            self.deploymentSetId = dict["DeploymentSetId"] as! String
        }
        if dict.keys.contains("HostName") {
            self.hostName = dict["HostName"] as! String
        }
        if dict.keys.contains("HpcClusterId") {
            self.hpcClusterId = dict["HpcClusterId"] as! String
        }
        if dict.keys.contains("HttpEndpoint") {
            self.httpEndpoint = dict["HttpEndpoint"] as! String
        }
        if dict.keys.contains("HttpTokens") {
            self.httpTokens = dict["HttpTokens"] as! String
        }
        if dict.keys.contains("ImageFamily") {
            self.imageFamily = dict["ImageFamily"] as! String
        }
        if dict.keys.contains("ImageId") {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("ImageName") {
            self.imageName = dict["ImageName"] as! String
        }
        if dict.keys.contains("InstanceDescription") {
            self.instanceDescription = dict["InstanceDescription"] as! String
        }
        if dict.keys.contains("InstanceName") {
            self.instanceName = dict["InstanceName"] as! String
        }
        if dict.keys.contains("InstancePatternInfos") {
            var tmp : [ModifyScalingConfigurationShrinkRequest.InstancePatternInfos] = []
            for v in dict["InstancePatternInfos"] as! [Any] {
                var model = ModifyScalingConfigurationShrinkRequest.InstancePatternInfos()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.instancePatternInfos = tmp
        }
        if dict.keys.contains("InstanceTypeOverrides") {
            var tmp : [ModifyScalingConfigurationShrinkRequest.InstanceTypeOverrides] = []
            for v in dict["InstanceTypeOverrides"] as! [Any] {
                var model = ModifyScalingConfigurationShrinkRequest.InstanceTypeOverrides()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.instanceTypeOverrides = tmp
        }
        if dict.keys.contains("InstanceTypes") {
            self.instanceTypes = dict["InstanceTypes"] as! [String]
        }
        if dict.keys.contains("InternetChargeType") {
            self.internetChargeType = dict["InternetChargeType"] as! String
        }
        if dict.keys.contains("InternetMaxBandwidthIn") {
            self.internetMaxBandwidthIn = dict["InternetMaxBandwidthIn"] as! Int32
        }
        if dict.keys.contains("InternetMaxBandwidthOut") {
            self.internetMaxBandwidthOut = dict["InternetMaxBandwidthOut"] as! Int32
        }
        if dict.keys.contains("IoOptimized") {
            self.ioOptimized = dict["IoOptimized"] as! String
        }
        if dict.keys.contains("Ipv6AddressCount") {
            self.ipv6AddressCount = dict["Ipv6AddressCount"] as! Int32
        }
        if dict.keys.contains("KeyPairName") {
            self.keyPairName = dict["KeyPairName"] as! String
        }
        if dict.keys.contains("LoadBalancerWeight") {
            self.loadBalancerWeight = dict["LoadBalancerWeight"] as! Int32
        }
        if dict.keys.contains("Memory") {
            self.memory = dict["Memory"] as! Int32
        }
        if dict.keys.contains("NetworkInterfaces") {
            var tmp : [ModifyScalingConfigurationShrinkRequest.NetworkInterfaces] = []
            for v in dict["NetworkInterfaces"] as! [Any] {
                var model = ModifyScalingConfigurationShrinkRequest.NetworkInterfaces()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.networkInterfaces = tmp
        }
        if dict.keys.contains("Override") {
            self.override_ = dict["Override"] as! Bool
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Password") {
            self.password = dict["Password"] as! String
        }
        if dict.keys.contains("PasswordInherit") {
            self.passwordInherit = dict["PasswordInherit"] as! Bool
        }
        if dict.keys.contains("RamRoleName") {
            self.ramRoleName = dict["RamRoleName"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScalingConfigurationId") {
            self.scalingConfigurationId = dict["ScalingConfigurationId"] as! String
        }
        if dict.keys.contains("ScalingConfigurationName") {
            self.scalingConfigurationName = dict["ScalingConfigurationName"] as! String
        }
        if dict.keys.contains("SchedulerOptions") {
            self.schedulerOptionsShrink = dict["SchedulerOptions"] as! String
        }
        if dict.keys.contains("SecurityGroupId") {
            self.securityGroupId = dict["SecurityGroupId"] as! String
        }
        if dict.keys.contains("SecurityGroupIds") {
            self.securityGroupIds = dict["SecurityGroupIds"] as! [String]
        }
        if dict.keys.contains("SecurityOptions") {
            var model = ModifyScalingConfigurationShrinkRequest.SecurityOptions()
            model.fromMap(dict["SecurityOptions"] as! [String: Any])
            self.securityOptions = model
        }
        if dict.keys.contains("SpotDuration") {
            self.spotDuration = dict["SpotDuration"] as! Int32
        }
        if dict.keys.contains("SpotInterruptionBehavior") {
            self.spotInterruptionBehavior = dict["SpotInterruptionBehavior"] as! String
        }
        if dict.keys.contains("SpotPriceLimits") {
            var tmp : [ModifyScalingConfigurationShrinkRequest.SpotPriceLimits] = []
            for v in dict["SpotPriceLimits"] as! [Any] {
                var model = ModifyScalingConfigurationShrinkRequest.SpotPriceLimits()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.spotPriceLimits = tmp
        }
        if dict.keys.contains("SpotStrategy") {
            self.spotStrategy = dict["SpotStrategy"] as! String
        }
        if dict.keys.contains("StorageSetId") {
            self.storageSetId = dict["StorageSetId"] as! String
        }
        if dict.keys.contains("StorageSetPartitionNumber") {
            self.storageSetPartitionNumber = dict["StorageSetPartitionNumber"] as! Int32
        }
        if dict.keys.contains("SystemDiskCategories") {
            self.systemDiskCategories = dict["SystemDiskCategories"] as! [String]
        }
        if dict.keys.contains("Tags") {
            self.tags = dict["Tags"] as! String
        }
        if dict.keys.contains("Tenancy") {
            self.tenancy = dict["Tenancy"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! String
        }
    }
}

public class ModifyScalingConfigurationResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyScalingConfigurationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyScalingConfigurationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyScalingConfigurationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyScalingGroupRequest : Tea.TeaModel {
    public class CapacityOptions : Tea.TeaModel {
        public var compensateWithOnDemand: Bool?

        public var onDemandBaseCapacity: Int32?

        public var onDemandPercentageAboveBaseCapacity: Int32?

        public var priceComparisonMode: String?

        public var spotAutoReplaceOnDemand: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.compensateWithOnDemand != nil {
                map["CompensateWithOnDemand"] = self.compensateWithOnDemand!
            }
            if self.onDemandBaseCapacity != nil {
                map["OnDemandBaseCapacity"] = self.onDemandBaseCapacity!
            }
            if self.onDemandPercentageAboveBaseCapacity != nil {
                map["OnDemandPercentageAboveBaseCapacity"] = self.onDemandPercentageAboveBaseCapacity!
            }
            if self.priceComparisonMode != nil {
                map["PriceComparisonMode"] = self.priceComparisonMode!
            }
            if self.spotAutoReplaceOnDemand != nil {
                map["SpotAutoReplaceOnDemand"] = self.spotAutoReplaceOnDemand!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CompensateWithOnDemand") {
                self.compensateWithOnDemand = dict["CompensateWithOnDemand"] as! Bool
            }
            if dict.keys.contains("OnDemandBaseCapacity") {
                self.onDemandBaseCapacity = dict["OnDemandBaseCapacity"] as! Int32
            }
            if dict.keys.contains("OnDemandPercentageAboveBaseCapacity") {
                self.onDemandPercentageAboveBaseCapacity = dict["OnDemandPercentageAboveBaseCapacity"] as! Int32
            }
            if dict.keys.contains("PriceComparisonMode") {
                self.priceComparisonMode = dict["PriceComparisonMode"] as! String
            }
            if dict.keys.contains("SpotAutoReplaceOnDemand") {
                self.spotAutoReplaceOnDemand = dict["SpotAutoReplaceOnDemand"] as! Bool
            }
        }
    }
    public class LaunchTemplateOverrides : Tea.TeaModel {
        public var instanceType: String?

        public var spotPriceLimit: Double?

        public var weightedCapacity: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.spotPriceLimit != nil {
                map["SpotPriceLimit"] = self.spotPriceLimit!
            }
            if self.weightedCapacity != nil {
                map["WeightedCapacity"] = self.weightedCapacity!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceType") {
                self.instanceType = dict["InstanceType"] as! String
            }
            if dict.keys.contains("SpotPriceLimit") {
                self.spotPriceLimit = dict["SpotPriceLimit"] as! Double
            }
            if dict.keys.contains("WeightedCapacity") {
                self.weightedCapacity = dict["WeightedCapacity"] as! Int32
            }
        }
    }
    public var activeScalingConfigurationId: String?

    public var allocationStrategy: String?

    public var azBalance: Bool?

    public var capacityOptions: ModifyScalingGroupRequest.CapacityOptions?

    public var compensateWithOnDemand: Bool?

    public var customPolicyARN: String?

    public var defaultCooldown: Int32?

    public var desiredCapacity: Int32?

    public var disableDesiredCapacity: Bool?

    public var groupDeletionProtection: Bool?

    public var healthCheckType: String?

    public var healthCheckTypes: [String]?

    public var launchTemplateId: String?

    public var launchTemplateOverrides: [ModifyScalingGroupRequest.LaunchTemplateOverrides]?

    public var launchTemplateVersion: String?

    public var maxInstanceLifetime: Int32?

    public var maxSize: Int32?

    public var minSize: Int32?

    public var multiAZPolicy: String?

    public var onDemandBaseCapacity: Int32?

    public var onDemandPercentageAboveBaseCapacity: Int32?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var removalPolicies: [String]?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var scalingGroupId: String?

    public var scalingGroupName: String?

    public var scalingPolicy: String?

    public var spotAllocationStrategy: String?

    public var spotInstancePools: Int32?

    public var spotInstanceRemedy: Bool?

    public var stopInstanceTimeout: Int32?

    public var vSwitchIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.capacityOptions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.activeScalingConfigurationId != nil {
            map["ActiveScalingConfigurationId"] = self.activeScalingConfigurationId!
        }
        if self.allocationStrategy != nil {
            map["AllocationStrategy"] = self.allocationStrategy!
        }
        if self.azBalance != nil {
            map["AzBalance"] = self.azBalance!
        }
        if self.capacityOptions != nil {
            map["CapacityOptions"] = self.capacityOptions?.toMap()
        }
        if self.compensateWithOnDemand != nil {
            map["CompensateWithOnDemand"] = self.compensateWithOnDemand!
        }
        if self.customPolicyARN != nil {
            map["CustomPolicyARN"] = self.customPolicyARN!
        }
        if self.defaultCooldown != nil {
            map["DefaultCooldown"] = self.defaultCooldown!
        }
        if self.desiredCapacity != nil {
            map["DesiredCapacity"] = self.desiredCapacity!
        }
        if self.disableDesiredCapacity != nil {
            map["DisableDesiredCapacity"] = self.disableDesiredCapacity!
        }
        if self.groupDeletionProtection != nil {
            map["GroupDeletionProtection"] = self.groupDeletionProtection!
        }
        if self.healthCheckType != nil {
            map["HealthCheckType"] = self.healthCheckType!
        }
        if self.healthCheckTypes != nil {
            map["HealthCheckTypes"] = self.healthCheckTypes!
        }
        if self.launchTemplateId != nil {
            map["LaunchTemplateId"] = self.launchTemplateId!
        }
        if self.launchTemplateOverrides != nil {
            var tmp : [Any] = []
            for k in self.launchTemplateOverrides! {
                tmp.append(k.toMap())
            }
            map["LaunchTemplateOverrides"] = tmp
        }
        if self.launchTemplateVersion != nil {
            map["LaunchTemplateVersion"] = self.launchTemplateVersion!
        }
        if self.maxInstanceLifetime != nil {
            map["MaxInstanceLifetime"] = self.maxInstanceLifetime!
        }
        if self.maxSize != nil {
            map["MaxSize"] = self.maxSize!
        }
        if self.minSize != nil {
            map["MinSize"] = self.minSize!
        }
        if self.multiAZPolicy != nil {
            map["MultiAZPolicy"] = self.multiAZPolicy!
        }
        if self.onDemandBaseCapacity != nil {
            map["OnDemandBaseCapacity"] = self.onDemandBaseCapacity!
        }
        if self.onDemandPercentageAboveBaseCapacity != nil {
            map["OnDemandPercentageAboveBaseCapacity"] = self.onDemandPercentageAboveBaseCapacity!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.removalPolicies != nil {
            map["RemovalPolicies"] = self.removalPolicies!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        if self.scalingGroupName != nil {
            map["ScalingGroupName"] = self.scalingGroupName!
        }
        if self.scalingPolicy != nil {
            map["ScalingPolicy"] = self.scalingPolicy!
        }
        if self.spotAllocationStrategy != nil {
            map["SpotAllocationStrategy"] = self.spotAllocationStrategy!
        }
        if self.spotInstancePools != nil {
            map["SpotInstancePools"] = self.spotInstancePools!
        }
        if self.spotInstanceRemedy != nil {
            map["SpotInstanceRemedy"] = self.spotInstanceRemedy!
        }
        if self.stopInstanceTimeout != nil {
            map["StopInstanceTimeout"] = self.stopInstanceTimeout!
        }
        if self.vSwitchIds != nil {
            map["VSwitchIds"] = self.vSwitchIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ActiveScalingConfigurationId") {
            self.activeScalingConfigurationId = dict["ActiveScalingConfigurationId"] as! String
        }
        if dict.keys.contains("AllocationStrategy") {
            self.allocationStrategy = dict["AllocationStrategy"] as! String
        }
        if dict.keys.contains("AzBalance") {
            self.azBalance = dict["AzBalance"] as! Bool
        }
        if dict.keys.contains("CapacityOptions") {
            var model = ModifyScalingGroupRequest.CapacityOptions()
            model.fromMap(dict["CapacityOptions"] as! [String: Any])
            self.capacityOptions = model
        }
        if dict.keys.contains("CompensateWithOnDemand") {
            self.compensateWithOnDemand = dict["CompensateWithOnDemand"] as! Bool
        }
        if dict.keys.contains("CustomPolicyARN") {
            self.customPolicyARN = dict["CustomPolicyARN"] as! String
        }
        if dict.keys.contains("DefaultCooldown") {
            self.defaultCooldown = dict["DefaultCooldown"] as! Int32
        }
        if dict.keys.contains("DesiredCapacity") {
            self.desiredCapacity = dict["DesiredCapacity"] as! Int32
        }
        if dict.keys.contains("DisableDesiredCapacity") {
            self.disableDesiredCapacity = dict["DisableDesiredCapacity"] as! Bool
        }
        if dict.keys.contains("GroupDeletionProtection") {
            self.groupDeletionProtection = dict["GroupDeletionProtection"] as! Bool
        }
        if dict.keys.contains("HealthCheckType") {
            self.healthCheckType = dict["HealthCheckType"] as! String
        }
        if dict.keys.contains("HealthCheckTypes") {
            self.healthCheckTypes = dict["HealthCheckTypes"] as! [String]
        }
        if dict.keys.contains("LaunchTemplateId") {
            self.launchTemplateId = dict["LaunchTemplateId"] as! String
        }
        if dict.keys.contains("LaunchTemplateOverrides") {
            var tmp : [ModifyScalingGroupRequest.LaunchTemplateOverrides] = []
            for v in dict["LaunchTemplateOverrides"] as! [Any] {
                var model = ModifyScalingGroupRequest.LaunchTemplateOverrides()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.launchTemplateOverrides = tmp
        }
        if dict.keys.contains("LaunchTemplateVersion") {
            self.launchTemplateVersion = dict["LaunchTemplateVersion"] as! String
        }
        if dict.keys.contains("MaxInstanceLifetime") {
            self.maxInstanceLifetime = dict["MaxInstanceLifetime"] as! Int32
        }
        if dict.keys.contains("MaxSize") {
            self.maxSize = dict["MaxSize"] as! Int32
        }
        if dict.keys.contains("MinSize") {
            self.minSize = dict["MinSize"] as! Int32
        }
        if dict.keys.contains("MultiAZPolicy") {
            self.multiAZPolicy = dict["MultiAZPolicy"] as! String
        }
        if dict.keys.contains("OnDemandBaseCapacity") {
            self.onDemandBaseCapacity = dict["OnDemandBaseCapacity"] as! Int32
        }
        if dict.keys.contains("OnDemandPercentageAboveBaseCapacity") {
            self.onDemandPercentageAboveBaseCapacity = dict["OnDemandPercentageAboveBaseCapacity"] as! Int32
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RemovalPolicies") {
            self.removalPolicies = dict["RemovalPolicies"] as! [String]
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ScalingGroupId") {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
        if dict.keys.contains("ScalingGroupName") {
            self.scalingGroupName = dict["ScalingGroupName"] as! String
        }
        if dict.keys.contains("ScalingPolicy") {
            self.scalingPolicy = dict["ScalingPolicy"] as! String
        }
        if dict.keys.contains("SpotAllocationStrategy") {
            self.spotAllocationStrategy = dict["SpotAllocationStrategy"] as! String
        }
        if dict.keys.contains("SpotInstancePools") {
            self.spotInstancePools = dict["SpotInstancePools"] as! Int32
        }
        if dict.keys.contains("SpotInstanceRemedy") {
            self.spotInstanceRemedy = dict["SpotInstanceRemedy"] as! Bool
        }
        if dict.keys.contains("StopInstanceTimeout") {
            self.stopInstanceTimeout = dict["StopInstanceTimeout"] as! Int32
        }
        if dict.keys.contains("VSwitchIds") {
            self.vSwitchIds = dict["VSwitchIds"] as! [String]
        }
    }
}

public class ModifyScalingGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyScalingGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyScalingGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyScalingGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyScalingRuleRequest : Tea.TeaModel {
    public class AlarmDimensions : Tea.TeaModel {
        public var dimensionKey: String?

        public var dimensionValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dimensionKey != nil {
                map["DimensionKey"] = self.dimensionKey!
            }
            if self.dimensionValue != nil {
                map["DimensionValue"] = self.dimensionValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DimensionKey") {
                self.dimensionKey = dict["DimensionKey"] as! String
            }
            if dict.keys.contains("DimensionValue") {
                self.dimensionValue = dict["DimensionValue"] as! String
            }
        }
    }
    public class HybridMetrics : Tea.TeaModel {
        public class Dimensions : Tea.TeaModel {
            public var dimensionKey: String?

            public var dimensionValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dimensionKey != nil {
                    map["DimensionKey"] = self.dimensionKey!
                }
                if self.dimensionValue != nil {
                    map["DimensionValue"] = self.dimensionValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DimensionKey") {
                    self.dimensionKey = dict["DimensionKey"] as! String
                }
                if dict.keys.contains("DimensionValue") {
                    self.dimensionValue = dict["DimensionValue"] as! String
                }
            }
        }
        public var dimensions: [ModifyScalingRuleRequest.HybridMetrics.Dimensions]?

        public var expression: String?

        public var id: String?

        public var metricName: String?

        public var statistic: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dimensions != nil {
                var tmp : [Any] = []
                for k in self.dimensions! {
                    tmp.append(k.toMap())
                }
                map["Dimensions"] = tmp
            }
            if self.expression != nil {
                map["Expression"] = self.expression!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.metricName != nil {
                map["MetricName"] = self.metricName!
            }
            if self.statistic != nil {
                map["Statistic"] = self.statistic!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Dimensions") {
                var tmp : [ModifyScalingRuleRequest.HybridMetrics.Dimensions] = []
                for v in dict["Dimensions"] as! [Any] {
                    var model = ModifyScalingRuleRequest.HybridMetrics.Dimensions()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.dimensions = tmp
            }
            if dict.keys.contains("Expression") {
                self.expression = dict["Expression"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("MetricName") {
                self.metricName = dict["MetricName"] as! String
            }
            if dict.keys.contains("Statistic") {
                self.statistic = dict["Statistic"] as! String
            }
        }
    }
    public class StepAdjustments : Tea.TeaModel {
        public var metricIntervalLowerBound: Double?

        public var metricIntervalUpperBound: Double?

        public var scalingAdjustment: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.metricIntervalLowerBound != nil {
                map["MetricIntervalLowerBound"] = self.metricIntervalLowerBound!
            }
            if self.metricIntervalUpperBound != nil {
                map["MetricIntervalUpperBound"] = self.metricIntervalUpperBound!
            }
            if self.scalingAdjustment != nil {
                map["ScalingAdjustment"] = self.scalingAdjustment!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MetricIntervalLowerBound") {
                self.metricIntervalLowerBound = dict["MetricIntervalLowerBound"] as! Double
            }
            if dict.keys.contains("MetricIntervalUpperBound") {
                self.metricIntervalUpperBound = dict["MetricIntervalUpperBound"] as! Double
            }
            if dict.keys.contains("ScalingAdjustment") {
                self.scalingAdjustment = dict["ScalingAdjustment"] as! Int32
            }
        }
    }
    public var adjustmentType: String?

    public var adjustmentValue: Int32?

    public var alarmDimensions: [ModifyScalingRuleRequest.AlarmDimensions]?

    public var cooldown: Int32?

    public var disableScaleIn: Bool?

    public var estimatedInstanceWarmup: Int32?

    public var hybridMetrics: [ModifyScalingRuleRequest.HybridMetrics]?

    public var hybridMonitorNamespace: String?

    public var initialMaxSize: Int32?

    public var metricName: String?

    public var metricType: String?

    public var minAdjustmentMagnitude: Int32?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var predictiveScalingMode: String?

    public var predictiveTaskBufferTime: Int32?

    public var predictiveValueBehavior: String?

    public var predictiveValueBuffer: Int32?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var scaleInEvaluationCount: Int32?

    public var scaleOutEvaluationCount: Int32?

    public var scalingRuleId: String?

    public var scalingRuleName: String?

    public var stepAdjustments: [ModifyScalingRuleRequest.StepAdjustments]?

    public var targetValue: Double?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.adjustmentType != nil {
            map["AdjustmentType"] = self.adjustmentType!
        }
        if self.adjustmentValue != nil {
            map["AdjustmentValue"] = self.adjustmentValue!
        }
        if self.alarmDimensions != nil {
            var tmp : [Any] = []
            for k in self.alarmDimensions! {
                tmp.append(k.toMap())
            }
            map["AlarmDimensions"] = tmp
        }
        if self.cooldown != nil {
            map["Cooldown"] = self.cooldown!
        }
        if self.disableScaleIn != nil {
            map["DisableScaleIn"] = self.disableScaleIn!
        }
        if self.estimatedInstanceWarmup != nil {
            map["EstimatedInstanceWarmup"] = self.estimatedInstanceWarmup!
        }
        if self.hybridMetrics != nil {
            var tmp : [Any] = []
            for k in self.hybridMetrics! {
                tmp.append(k.toMap())
            }
            map["HybridMetrics"] = tmp
        }
        if self.hybridMonitorNamespace != nil {
            map["HybridMonitorNamespace"] = self.hybridMonitorNamespace!
        }
        if self.initialMaxSize != nil {
            map["InitialMaxSize"] = self.initialMaxSize!
        }
        if self.metricName != nil {
            map["MetricName"] = self.metricName!
        }
        if self.metricType != nil {
            map["MetricType"] = self.metricType!
        }
        if self.minAdjustmentMagnitude != nil {
            map["MinAdjustmentMagnitude"] = self.minAdjustmentMagnitude!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.predictiveScalingMode != nil {
            map["PredictiveScalingMode"] = self.predictiveScalingMode!
        }
        if self.predictiveTaskBufferTime != nil {
            map["PredictiveTaskBufferTime"] = self.predictiveTaskBufferTime!
        }
        if self.predictiveValueBehavior != nil {
            map["PredictiveValueBehavior"] = self.predictiveValueBehavior!
        }
        if self.predictiveValueBuffer != nil {
            map["PredictiveValueBuffer"] = self.predictiveValueBuffer!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.scaleInEvaluationCount != nil {
            map["ScaleInEvaluationCount"] = self.scaleInEvaluationCount!
        }
        if self.scaleOutEvaluationCount != nil {
            map["ScaleOutEvaluationCount"] = self.scaleOutEvaluationCount!
        }
        if self.scalingRuleId != nil {
            map["ScalingRuleId"] = self.scalingRuleId!
        }
        if self.scalingRuleName != nil {
            map["ScalingRuleName"] = self.scalingRuleName!
        }
        if self.stepAdjustments != nil {
            var tmp : [Any] = []
            for k in self.stepAdjustments! {
                tmp.append(k.toMap())
            }
            map["StepAdjustments"] = tmp
        }
        if self.targetValue != nil {
            map["TargetValue"] = self.targetValue!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AdjustmentType") {
            self.adjustmentType = dict["AdjustmentType"] as! String
        }
        if dict.keys.contains("AdjustmentValue") {
            self.adjustmentValue = dict["AdjustmentValue"] as! Int32
        }
        if dict.keys.contains("AlarmDimensions") {
            var tmp : [ModifyScalingRuleRequest.AlarmDimensions] = []
            for v in dict["AlarmDimensions"] as! [Any] {
                var model = ModifyScalingRuleRequest.AlarmDimensions()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.alarmDimensions = tmp
        }
        if dict.keys.contains("Cooldown") {
            self.cooldown = dict["Cooldown"] as! Int32
        }
        if dict.keys.contains("DisableScaleIn") {
            self.disableScaleIn = dict["DisableScaleIn"] as! Bool
        }
        if dict.keys.contains("EstimatedInstanceWarmup") {
            self.estimatedInstanceWarmup = dict["EstimatedInstanceWarmup"] as! Int32
        }
        if dict.keys.contains("HybridMetrics") {
            var tmp : [ModifyScalingRuleRequest.HybridMetrics] = []
            for v in dict["HybridMetrics"] as! [Any] {
                var model = ModifyScalingRuleRequest.HybridMetrics()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.hybridMetrics = tmp
        }
        if dict.keys.contains("HybridMonitorNamespace") {
            self.hybridMonitorNamespace = dict["HybridMonitorNamespace"] as! String
        }
        if dict.keys.contains("InitialMaxSize") {
            self.initialMaxSize = dict["InitialMaxSize"] as! Int32
        }
        if dict.keys.contains("MetricName") {
            self.metricName = dict["MetricName"] as! String
        }
        if dict.keys.contains("MetricType") {
            self.metricType = dict["MetricType"] as! String
        }
        if dict.keys.contains("MinAdjustmentMagnitude") {
            self.minAdjustmentMagnitude = dict["MinAdjustmentMagnitude"] as! Int32
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PredictiveScalingMode") {
            self.predictiveScalingMode = dict["PredictiveScalingMode"] as! String
        }
        if dict.keys.contains("PredictiveTaskBufferTime") {
            self.predictiveTaskBufferTime = dict["PredictiveTaskBufferTime"] as! Int32
        }
        if dict.keys.contains("PredictiveValueBehavior") {
            self.predictiveValueBehavior = dict["PredictiveValueBehavior"] as! String
        }
        if dict.keys.contains("PredictiveValueBuffer") {
            self.predictiveValueBuffer = dict["PredictiveValueBuffer"] as! Int32
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ScaleInEvaluationCount") {
            self.scaleInEvaluationCount = dict["ScaleInEvaluationCount"] as! Int32
        }
        if dict.keys.contains("ScaleOutEvaluationCount") {
            self.scaleOutEvaluationCount = dict["ScaleOutEvaluationCount"] as! Int32
        }
        if dict.keys.contains("ScalingRuleId") {
            self.scalingRuleId = dict["ScalingRuleId"] as! String
        }
        if dict.keys.contains("ScalingRuleName") {
            self.scalingRuleName = dict["ScalingRuleName"] as! String
        }
        if dict.keys.contains("StepAdjustments") {
            var tmp : [ModifyScalingRuleRequest.StepAdjustments] = []
            for v in dict["StepAdjustments"] as! [Any] {
                var model = ModifyScalingRuleRequest.StepAdjustments()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.stepAdjustments = tmp
        }
        if dict.keys.contains("TargetValue") {
            self.targetValue = dict["TargetValue"] as! Double
        }
    }
}

public class ModifyScalingRuleResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyScalingRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyScalingRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyScalingRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyScheduledTaskRequest : Tea.TeaModel {
    public var description_: String?

    public var desiredCapacity: Int32?

    public var launchExpirationTime: Int32?

    public var launchTime: String?

    public var maxValue: Int32?

    public var minValue: Int32?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var recurrenceEndTime: String?

    public var recurrenceType: String?

    public var recurrenceValue: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var scalingGroupId: String?

    public var scheduledAction: String?

    public var scheduledTaskId: String?

    public var scheduledTaskName: String?

    public var taskEnabled: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.desiredCapacity != nil {
            map["DesiredCapacity"] = self.desiredCapacity!
        }
        if self.launchExpirationTime != nil {
            map["LaunchExpirationTime"] = self.launchExpirationTime!
        }
        if self.launchTime != nil {
            map["LaunchTime"] = self.launchTime!
        }
        if self.maxValue != nil {
            map["MaxValue"] = self.maxValue!
        }
        if self.minValue != nil {
            map["MinValue"] = self.minValue!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.recurrenceEndTime != nil {
            map["RecurrenceEndTime"] = self.recurrenceEndTime!
        }
        if self.recurrenceType != nil {
            map["RecurrenceType"] = self.recurrenceType!
        }
        if self.recurrenceValue != nil {
            map["RecurrenceValue"] = self.recurrenceValue!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        if self.scheduledAction != nil {
            map["ScheduledAction"] = self.scheduledAction!
        }
        if self.scheduledTaskId != nil {
            map["ScheduledTaskId"] = self.scheduledTaskId!
        }
        if self.scheduledTaskName != nil {
            map["ScheduledTaskName"] = self.scheduledTaskName!
        }
        if self.taskEnabled != nil {
            map["TaskEnabled"] = self.taskEnabled!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DesiredCapacity") {
            self.desiredCapacity = dict["DesiredCapacity"] as! Int32
        }
        if dict.keys.contains("LaunchExpirationTime") {
            self.launchExpirationTime = dict["LaunchExpirationTime"] as! Int32
        }
        if dict.keys.contains("LaunchTime") {
            self.launchTime = dict["LaunchTime"] as! String
        }
        if dict.keys.contains("MaxValue") {
            self.maxValue = dict["MaxValue"] as! Int32
        }
        if dict.keys.contains("MinValue") {
            self.minValue = dict["MinValue"] as! Int32
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RecurrenceEndTime") {
            self.recurrenceEndTime = dict["RecurrenceEndTime"] as! String
        }
        if dict.keys.contains("RecurrenceType") {
            self.recurrenceType = dict["RecurrenceType"] as! String
        }
        if dict.keys.contains("RecurrenceValue") {
            self.recurrenceValue = dict["RecurrenceValue"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ScalingGroupId") {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
        if dict.keys.contains("ScheduledAction") {
            self.scheduledAction = dict["ScheduledAction"] as! String
        }
        if dict.keys.contains("ScheduledTaskId") {
            self.scheduledTaskId = dict["ScheduledTaskId"] as! String
        }
        if dict.keys.contains("ScheduledTaskName") {
            self.scheduledTaskName = dict["ScheduledTaskName"] as! String
        }
        if dict.keys.contains("TaskEnabled") {
            self.taskEnabled = dict["TaskEnabled"] as! Bool
        }
    }
}

public class ModifyScheduledTaskResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyScheduledTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyScheduledTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyScheduledTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RebalanceInstancesRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ScalingGroupId") {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
    }
}

public class RebalanceInstancesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var scalingActivityId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingActivityId != nil {
            map["ScalingActivityId"] = self.scalingActivityId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScalingActivityId") {
            self.scalingActivityId = dict["ScalingActivityId"] as! String
        }
    }
}

public class RebalanceInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RebalanceInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RebalanceInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RecordLifecycleActionHeartbeatRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var heartbeatTimeout: Int32?

    public var lifecycleActionToken: String?

    public var lifecycleHookId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.heartbeatTimeout != nil {
            map["heartbeatTimeout"] = self.heartbeatTimeout!
        }
        if self.lifecycleActionToken != nil {
            map["lifecycleActionToken"] = self.lifecycleActionToken!
        }
        if self.lifecycleHookId != nil {
            map["lifecycleHookId"] = self.lifecycleHookId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("heartbeatTimeout") {
            self.heartbeatTimeout = dict["heartbeatTimeout"] as! Int32
        }
        if dict.keys.contains("lifecycleActionToken") {
            self.lifecycleActionToken = dict["lifecycleActionToken"] as! String
        }
        if dict.keys.contains("lifecycleHookId") {
            self.lifecycleHookId = dict["lifecycleHookId"] as! String
        }
    }
}

public class RecordLifecycleActionHeartbeatResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RecordLifecycleActionHeartbeatResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RecordLifecycleActionHeartbeatResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RecordLifecycleActionHeartbeatResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemoveInstancesRequest : Tea.TeaModel {
    public var clientToken: String?

    public var decreaseDesiredCapacity: Bool?

    public var ignoreInvalidInstance: Bool?

    public var instanceIds: [String]?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var removePolicy: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var scalingGroupId: String?

    public var stopInstanceTimeout: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.decreaseDesiredCapacity != nil {
            map["DecreaseDesiredCapacity"] = self.decreaseDesiredCapacity!
        }
        if self.ignoreInvalidInstance != nil {
            map["IgnoreInvalidInstance"] = self.ignoreInvalidInstance!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.removePolicy != nil {
            map["RemovePolicy"] = self.removePolicy!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        if self.stopInstanceTimeout != nil {
            map["StopInstanceTimeout"] = self.stopInstanceTimeout!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DecreaseDesiredCapacity") {
            self.decreaseDesiredCapacity = dict["DecreaseDesiredCapacity"] as! Bool
        }
        if dict.keys.contains("IgnoreInvalidInstance") {
            self.ignoreInvalidInstance = dict["IgnoreInvalidInstance"] as! Bool
        }
        if dict.keys.contains("InstanceIds") {
            self.instanceIds = dict["InstanceIds"] as! [String]
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RemovePolicy") {
            self.removePolicy = dict["RemovePolicy"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ScalingGroupId") {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
        if dict.keys.contains("StopInstanceTimeout") {
            self.stopInstanceTimeout = dict["StopInstanceTimeout"] as! Int32
        }
    }
}

public class RemoveInstancesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var scalingActivityId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingActivityId != nil {
            map["ScalingActivityId"] = self.scalingActivityId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScalingActivityId") {
            self.scalingActivityId = dict["ScalingActivityId"] as! String
        }
    }
}

public class RemoveInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RemoveInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ResumeInstanceRefreshRequest : Tea.TeaModel {
    public var instanceRefreshTaskId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceRefreshTaskId != nil {
            map["InstanceRefreshTaskId"] = self.instanceRefreshTaskId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceRefreshTaskId") {
            self.instanceRefreshTaskId = dict["InstanceRefreshTaskId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScalingGroupId") {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
    }
}

public class ResumeInstanceRefreshResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ResumeInstanceRefreshResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ResumeInstanceRefreshResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ResumeInstanceRefreshResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ResumeProcessesRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerId: Int64?

    public var processes: [String]?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.processes != nil {
            map["Processes"] = self.processes!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Processes") {
            self.processes = dict["Processes"] as! [String]
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScalingGroupId") {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
    }
}

public class ResumeProcessesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ResumeProcessesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ResumeProcessesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ResumeProcessesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RollbackInstanceRefreshRequest : Tea.TeaModel {
    public var instanceRefreshTaskId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceRefreshTaskId != nil {
            map["InstanceRefreshTaskId"] = self.instanceRefreshTaskId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceRefreshTaskId") {
            self.instanceRefreshTaskId = dict["InstanceRefreshTaskId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScalingGroupId") {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
    }
}

public class RollbackInstanceRefreshResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RollbackInstanceRefreshResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RollbackInstanceRefreshResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RollbackInstanceRefreshResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ScaleWithAdjustmentRequest : Tea.TeaModel {
    public class LifecycleHookContext : Tea.TeaModel {
        public var disableLifecycleHook: Bool?

        public var ignoredLifecycleHookIds: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.disableLifecycleHook != nil {
                map["DisableLifecycleHook"] = self.disableLifecycleHook!
            }
            if self.ignoredLifecycleHookIds != nil {
                map["IgnoredLifecycleHookIds"] = self.ignoredLifecycleHookIds!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DisableLifecycleHook") {
                self.disableLifecycleHook = dict["DisableLifecycleHook"] as! Bool
            }
            if dict.keys.contains("IgnoredLifecycleHookIds") {
                self.ignoredLifecycleHookIds = dict["IgnoredLifecycleHookIds"] as! [String]
            }
        }
    }
    public class Overrides : Tea.TeaModel {
        public class ContainerOverrides : Tea.TeaModel {
            public class EnvironmentVars : Tea.TeaModel {
                public var key: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Key") {
                        self.key = dict["Key"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public var args: [String]?

            public var commands: [String]?

            public var cpu: Double?

            public var environmentVars: [ScaleWithAdjustmentRequest.Overrides.ContainerOverrides.EnvironmentVars]?

            public var memory: Double?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.args != nil {
                    map["Args"] = self.args!
                }
                if self.commands != nil {
                    map["Commands"] = self.commands!
                }
                if self.cpu != nil {
                    map["Cpu"] = self.cpu!
                }
                if self.environmentVars != nil {
                    var tmp : [Any] = []
                    for k in self.environmentVars! {
                        tmp.append(k.toMap())
                    }
                    map["EnvironmentVars"] = tmp
                }
                if self.memory != nil {
                    map["Memory"] = self.memory!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Args") {
                    self.args = dict["Args"] as! [String]
                }
                if dict.keys.contains("Commands") {
                    self.commands = dict["Commands"] as! [String]
                }
                if dict.keys.contains("Cpu") {
                    self.cpu = dict["Cpu"] as! Double
                }
                if dict.keys.contains("EnvironmentVars") {
                    var tmp : [ScaleWithAdjustmentRequest.Overrides.ContainerOverrides.EnvironmentVars] = []
                    for v in dict["EnvironmentVars"] as! [Any] {
                        var model = ScaleWithAdjustmentRequest.Overrides.ContainerOverrides.EnvironmentVars()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.environmentVars = tmp
                }
                if dict.keys.contains("Memory") {
                    self.memory = dict["Memory"] as! Double
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
            }
        }
        public var containerOverrides: [ScaleWithAdjustmentRequest.Overrides.ContainerOverrides]?

        public var cpu: Double?

        public var memory: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.containerOverrides != nil {
                var tmp : [Any] = []
                for k in self.containerOverrides! {
                    tmp.append(k.toMap())
                }
                map["ContainerOverrides"] = tmp
            }
            if self.cpu != nil {
                map["Cpu"] = self.cpu!
            }
            if self.memory != nil {
                map["Memory"] = self.memory!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ContainerOverrides") {
                var tmp : [ScaleWithAdjustmentRequest.Overrides.ContainerOverrides] = []
                for v in dict["ContainerOverrides"] as! [Any] {
                    var model = ScaleWithAdjustmentRequest.Overrides.ContainerOverrides()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.containerOverrides = tmp
            }
            if dict.keys.contains("Cpu") {
                self.cpu = dict["Cpu"] as! Double
            }
            if dict.keys.contains("Memory") {
                self.memory = dict["Memory"] as! Double
            }
        }
    }
    public var activityMetadata: String?

    public var adjustmentType: String?

    public var adjustmentValue: Int32?

    public var clientToken: String?

    public var lifecycleHookContext: ScaleWithAdjustmentRequest.LifecycleHookContext?

    public var minAdjustmentMagnitude: Int32?

    public var overrides: ScaleWithAdjustmentRequest.Overrides?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public var syncActivity: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.lifecycleHookContext?.validate()
        try self.overrides?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.activityMetadata != nil {
            map["ActivityMetadata"] = self.activityMetadata!
        }
        if self.adjustmentType != nil {
            map["AdjustmentType"] = self.adjustmentType!
        }
        if self.adjustmentValue != nil {
            map["AdjustmentValue"] = self.adjustmentValue!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.lifecycleHookContext != nil {
            map["LifecycleHookContext"] = self.lifecycleHookContext?.toMap()
        }
        if self.minAdjustmentMagnitude != nil {
            map["MinAdjustmentMagnitude"] = self.minAdjustmentMagnitude!
        }
        if self.overrides != nil {
            map["Overrides"] = self.overrides?.toMap()
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        if self.syncActivity != nil {
            map["SyncActivity"] = self.syncActivity!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ActivityMetadata") {
            self.activityMetadata = dict["ActivityMetadata"] as! String
        }
        if dict.keys.contains("AdjustmentType") {
            self.adjustmentType = dict["AdjustmentType"] as! String
        }
        if dict.keys.contains("AdjustmentValue") {
            self.adjustmentValue = dict["AdjustmentValue"] as! Int32
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("LifecycleHookContext") {
            var model = ScaleWithAdjustmentRequest.LifecycleHookContext()
            model.fromMap(dict["LifecycleHookContext"] as! [String: Any])
            self.lifecycleHookContext = model
        }
        if dict.keys.contains("MinAdjustmentMagnitude") {
            self.minAdjustmentMagnitude = dict["MinAdjustmentMagnitude"] as! Int32
        }
        if dict.keys.contains("Overrides") {
            var model = ScaleWithAdjustmentRequest.Overrides()
            model.fromMap(dict["Overrides"] as! [String: Any])
            self.overrides = model
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScalingGroupId") {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
        if dict.keys.contains("SyncActivity") {
            self.syncActivity = dict["SyncActivity"] as! Bool
        }
    }
}

public class ScaleWithAdjustmentShrinkRequest : Tea.TeaModel {
    public var activityMetadata: String?

    public var adjustmentType: String?

    public var adjustmentValue: Int32?

    public var clientToken: String?

    public var lifecycleHookContextShrink: String?

    public var minAdjustmentMagnitude: Int32?

    public var overridesShrink: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public var syncActivity: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.activityMetadata != nil {
            map["ActivityMetadata"] = self.activityMetadata!
        }
        if self.adjustmentType != nil {
            map["AdjustmentType"] = self.adjustmentType!
        }
        if self.adjustmentValue != nil {
            map["AdjustmentValue"] = self.adjustmentValue!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.lifecycleHookContextShrink != nil {
            map["LifecycleHookContext"] = self.lifecycleHookContextShrink!
        }
        if self.minAdjustmentMagnitude != nil {
            map["MinAdjustmentMagnitude"] = self.minAdjustmentMagnitude!
        }
        if self.overridesShrink != nil {
            map["Overrides"] = self.overridesShrink!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        if self.syncActivity != nil {
            map["SyncActivity"] = self.syncActivity!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ActivityMetadata") {
            self.activityMetadata = dict["ActivityMetadata"] as! String
        }
        if dict.keys.contains("AdjustmentType") {
            self.adjustmentType = dict["AdjustmentType"] as! String
        }
        if dict.keys.contains("AdjustmentValue") {
            self.adjustmentValue = dict["AdjustmentValue"] as! Int32
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("LifecycleHookContext") {
            self.lifecycleHookContextShrink = dict["LifecycleHookContext"] as! String
        }
        if dict.keys.contains("MinAdjustmentMagnitude") {
            self.minAdjustmentMagnitude = dict["MinAdjustmentMagnitude"] as! Int32
        }
        if dict.keys.contains("Overrides") {
            self.overridesShrink = dict["Overrides"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScalingGroupId") {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
        if dict.keys.contains("SyncActivity") {
            self.syncActivity = dict["SyncActivity"] as! Bool
        }
    }
}

public class ScaleWithAdjustmentResponseBody : Tea.TeaModel {
    public var activityType: String?

    public var requestId: String?

    public var scalingActivityId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.activityType != nil {
            map["ActivityType"] = self.activityType!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingActivityId != nil {
            map["ScalingActivityId"] = self.scalingActivityId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ActivityType") {
            self.activityType = dict["ActivityType"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScalingActivityId") {
            self.scalingActivityId = dict["ScalingActivityId"] as! String
        }
    }
}

public class ScaleWithAdjustmentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ScaleWithAdjustmentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ScaleWithAdjustmentResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetGroupDeletionProtectionRequest : Tea.TeaModel {
    public var groupDeletionProtection: Bool?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupDeletionProtection != nil {
            map["GroupDeletionProtection"] = self.groupDeletionProtection!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupDeletionProtection") {
            self.groupDeletionProtection = dict["GroupDeletionProtection"] as! Bool
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScalingGroupId") {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
    }
}

public class SetGroupDeletionProtectionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetGroupDeletionProtectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetGroupDeletionProtectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SetGroupDeletionProtectionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetInstanceHealthRequest : Tea.TeaModel {
    public var healthStatus: String?

    public var instanceId: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.healthStatus != nil {
            map["HealthStatus"] = self.healthStatus!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("HealthStatus") {
            self.healthStatus = dict["HealthStatus"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
    }
}

public class SetInstanceHealthResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetInstanceHealthResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetInstanceHealthResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SetInstanceHealthResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetInstancesProtectionRequest : Tea.TeaModel {
    public var instanceIds: [String]?

    public var ownerId: Int64?

    public var protectedFromScaleIn: Bool?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.protectedFromScaleIn != nil {
            map["ProtectedFromScaleIn"] = self.protectedFromScaleIn!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceIds") {
            self.instanceIds = dict["InstanceIds"] as! [String]
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ProtectedFromScaleIn") {
            self.protectedFromScaleIn = dict["ProtectedFromScaleIn"] as! Bool
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScalingGroupId") {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
    }
}

public class SetInstancesProtectionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetInstancesProtectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetInstancesProtectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SetInstancesProtectionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StartInstanceRefreshRequest : Tea.TeaModel {
    public class DesiredConfiguration : Tea.TeaModel {
        public var imageId: String?

        public var scalingConfigurationId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.imageId != nil {
                map["ImageId"] = self.imageId!
            }
            if self.scalingConfigurationId != nil {
                map["ScalingConfigurationId"] = self.scalingConfigurationId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ImageId") {
                self.imageId = dict["ImageId"] as! String
            }
            if dict.keys.contains("ScalingConfigurationId") {
                self.scalingConfigurationId = dict["ScalingConfigurationId"] as! String
            }
        }
    }
    public var clientToken: String?

    public var desiredConfiguration: StartInstanceRefreshRequest.DesiredConfiguration?

    public var maxHealthyPercentage: Int32?

    public var minHealthyPercentage: Int32?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public var skipMatching: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.desiredConfiguration?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.desiredConfiguration != nil {
            map["DesiredConfiguration"] = self.desiredConfiguration?.toMap()
        }
        if self.maxHealthyPercentage != nil {
            map["MaxHealthyPercentage"] = self.maxHealthyPercentage!
        }
        if self.minHealthyPercentage != nil {
            map["MinHealthyPercentage"] = self.minHealthyPercentage!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        if self.skipMatching != nil {
            map["SkipMatching"] = self.skipMatching!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DesiredConfiguration") {
            var model = StartInstanceRefreshRequest.DesiredConfiguration()
            model.fromMap(dict["DesiredConfiguration"] as! [String: Any])
            self.desiredConfiguration = model
        }
        if dict.keys.contains("MaxHealthyPercentage") {
            self.maxHealthyPercentage = dict["MaxHealthyPercentage"] as! Int32
        }
        if dict.keys.contains("MinHealthyPercentage") {
            self.minHealthyPercentage = dict["MinHealthyPercentage"] as! Int32
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScalingGroupId") {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
        if dict.keys.contains("SkipMatching") {
            self.skipMatching = dict["SkipMatching"] as! Bool
        }
    }
}

public class StartInstanceRefreshResponseBody : Tea.TeaModel {
    public var instanceRefreshTaskId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceRefreshTaskId != nil {
            map["InstanceRefreshTaskId"] = self.instanceRefreshTaskId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceRefreshTaskId") {
            self.instanceRefreshTaskId = dict["InstanceRefreshTaskId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class StartInstanceRefreshResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartInstanceRefreshResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StartInstanceRefreshResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SuspendInstanceRefreshRequest : Tea.TeaModel {
    public var instanceRefreshTaskId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceRefreshTaskId != nil {
            map["InstanceRefreshTaskId"] = self.instanceRefreshTaskId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceRefreshTaskId") {
            self.instanceRefreshTaskId = dict["InstanceRefreshTaskId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScalingGroupId") {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
    }
}

public class SuspendInstanceRefreshResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SuspendInstanceRefreshResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SuspendInstanceRefreshResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SuspendInstanceRefreshResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SuspendProcessesRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerId: Int64?

    public var processes: [String]?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var scalingGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.processes != nil {
            map["Processes"] = self.processes!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Processes") {
            self.processes = dict["Processes"] as! [String]
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ScalingGroupId") {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
    }
}

public class SuspendProcessesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SuspendProcessesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SuspendProcessesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SuspendProcessesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class TagResourcesRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var propagate: Bool?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.propagate != nil {
                map["Propagate"] = self.propagate!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Propagate") {
                self.propagate = dict["Propagate"] as! Bool
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var ownerId: Int64?

    public var regionId: String?

    public var resourceIds: [String]?

    public var resourceOwnerAccount: String?

    public var resourceType: String?

    public var tags: [TagResourcesRequest.Tags]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceIds != nil {
            map["ResourceIds"] = self.resourceIds!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceIds") {
            self.resourceIds = dict["ResourceIds"] as! [String]
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("Tags") {
            var tmp : [TagResourcesRequest.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = TagResourcesRequest.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
    }
}

public class TagResourcesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class TagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: TagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = TagResourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UntagResourcesRequest : Tea.TeaModel {
    public var all: Bool?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceIds: [String]?

    public var resourceOwnerAccount: String?

    public var resourceType: String?

    public var tagKeys: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.all != nil {
            map["All"] = self.all!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceIds != nil {
            map["ResourceIds"] = self.resourceIds!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tagKeys != nil {
            map["TagKeys"] = self.tagKeys!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("All") {
            self.all = dict["All"] as! Bool
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceIds") {
            self.resourceIds = dict["ResourceIds"] as! [String]
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("TagKeys") {
            self.tagKeys = dict["TagKeys"] as! [String]
        }
    }
}

public class UntagResourcesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UntagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UntagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UntagResourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class VerifyAuthenticationRequest : Tea.TeaModel {
    public var onlyCheck: Bool?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var uid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.onlyCheck != nil {
            map["OnlyCheck"] = self.onlyCheck!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.uid != nil {
            map["Uid"] = self.uid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OnlyCheck") {
            self.onlyCheck = dict["OnlyCheck"] as! Bool
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Uid") {
            self.uid = dict["Uid"] as! Int64
        }
    }
}

public class VerifyAuthenticationResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class VerifyAuthenticationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: VerifyAuthenticationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = VerifyAuthenticationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class VerifyUserRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class VerifyUserResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class VerifyUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: VerifyUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = VerifyUserResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}
