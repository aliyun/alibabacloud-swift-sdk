import Foundation
import Tea
import TeaUtils
import AlibabacloudOpenApi
import AlibabaCloudOpenApiUtil
import AlibabacloudEndpointUtil

public class AbolishApiRequest : Tea.TeaModel {
    public var apiId: String?

    public var groupId: String?

    public var securityToken: String?

    public var stageName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.stageName != nil {
            map["StageName"] = self.stageName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiId") && dict["ApiId"] != nil {
            self.apiId = dict["ApiId"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StageName") && dict["StageName"] != nil {
            self.stageName = dict["StageName"] as! String
        }
    }
}

public class AbolishApiResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AbolishApiResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AbolishApiResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AbolishApiResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddAccessControlListEntryRequest : Tea.TeaModel {
    public var aclEntrys: String?

    public var aclId: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aclEntrys != nil {
            map["AclEntrys"] = self.aclEntrys!
        }
        if self.aclId != nil {
            map["AclId"] = self.aclId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AclEntrys") && dict["AclEntrys"] != nil {
            self.aclEntrys = dict["AclEntrys"] as! String
        }
        if dict.keys.contains("AclId") && dict["AclId"] != nil {
            self.aclId = dict["AclId"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class AddAccessControlListEntryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddAccessControlListEntryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddAccessControlListEntryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AddAccessControlListEntryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddIpControlPolicyItemRequest : Tea.TeaModel {
    public var appId: String?

    public var cidrIp: String?

    public var ipControlId: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.cidrIp != nil {
            map["CidrIp"] = self.cidrIp!
        }
        if self.ipControlId != nil {
            map["IpControlId"] = self.ipControlId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("CidrIp") && dict["CidrIp"] != nil {
            self.cidrIp = dict["CidrIp"] as! String
        }
        if dict.keys.contains("IpControlId") && dict["IpControlId"] != nil {
            self.ipControlId = dict["IpControlId"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class AddIpControlPolicyItemResponseBody : Tea.TeaModel {
    public var policyItemId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.policyItemId != nil {
            map["PolicyItemId"] = self.policyItemId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PolicyItemId") && dict["PolicyItemId"] != nil {
            self.policyItemId = dict["PolicyItemId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddIpControlPolicyItemResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddIpControlPolicyItemResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AddIpControlPolicyItemResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddTrafficSpecialControlRequest : Tea.TeaModel {
    public var securityToken: String?

    public var specialKey: String?

    public var specialType: String?

    public var trafficControlId: String?

    public var trafficValue: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.specialKey != nil {
            map["SpecialKey"] = self.specialKey!
        }
        if self.specialType != nil {
            map["SpecialType"] = self.specialType!
        }
        if self.trafficControlId != nil {
            map["TrafficControlId"] = self.trafficControlId!
        }
        if self.trafficValue != nil {
            map["TrafficValue"] = self.trafficValue!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("SpecialKey") && dict["SpecialKey"] != nil {
            self.specialKey = dict["SpecialKey"] as! String
        }
        if dict.keys.contains("SpecialType") && dict["SpecialType"] != nil {
            self.specialType = dict["SpecialType"] as! String
        }
        if dict.keys.contains("TrafficControlId") && dict["TrafficControlId"] != nil {
            self.trafficControlId = dict["TrafficControlId"] as! String
        }
        if dict.keys.contains("TrafficValue") && dict["TrafficValue"] != nil {
            self.trafficValue = dict["TrafficValue"] as! Int32
        }
    }
}

public class AddTrafficSpecialControlResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddTrafficSpecialControlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddTrafficSpecialControlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AddTrafficSpecialControlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AttachApiProductRequest : Tea.TeaModel {
    public class Apis : Tea.TeaModel {
        public var apiId: String?

        public var stageName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apiId != nil {
                map["ApiId"] = self.apiId!
            }
            if self.stageName != nil {
                map["StageName"] = self.stageName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApiId") && dict["ApiId"] != nil {
                self.apiId = dict["ApiId"] as! String
            }
            if dict.keys.contains("StageName") && dict["StageName"] != nil {
                self.stageName = dict["StageName"] as! String
            }
        }
    }
    public var apiProductId: String?

    public var apis: [AttachApiProductRequest.Apis]?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiProductId != nil {
            map["ApiProductId"] = self.apiProductId!
        }
        if self.apis != nil {
            var tmp : [Any] = []
            for k in self.apis! {
                tmp.append(k.toMap())
            }
            map["Apis"] = tmp
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiProductId") && dict["ApiProductId"] != nil {
            self.apiProductId = dict["ApiProductId"] as! String
        }
        if dict.keys.contains("Apis") && dict["Apis"] != nil {
            var tmp : [AttachApiProductRequest.Apis] = []
            for v in dict["Apis"] as! [Any] {
                var model = AttachApiProductRequest.Apis()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.apis = tmp
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class AttachApiProductResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AttachApiProductResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AttachApiProductResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AttachApiProductResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AttachPluginRequest : Tea.TeaModel {
    public var apiId: String?

    public var apiIds: String?

    public var groupId: String?

    public var pluginId: String?

    public var securityToken: String?

    public var stageName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.apiIds != nil {
            map["ApiIds"] = self.apiIds!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.pluginId != nil {
            map["PluginId"] = self.pluginId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.stageName != nil {
            map["StageName"] = self.stageName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiId") && dict["ApiId"] != nil {
            self.apiId = dict["ApiId"] as! String
        }
        if dict.keys.contains("ApiIds") && dict["ApiIds"] != nil {
            self.apiIds = dict["ApiIds"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("PluginId") && dict["PluginId"] != nil {
            self.pluginId = dict["PluginId"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StageName") && dict["StageName"] != nil {
            self.stageName = dict["StageName"] as! String
        }
    }
}

public class AttachPluginResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AttachPluginResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AttachPluginResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AttachPluginResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class BatchAbolishApisRequest : Tea.TeaModel {
    public class Api : Tea.TeaModel {
        public var apiUid: String?

        public var groupId: String?

        public var stageId: String?

        public var stageName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apiUid != nil {
                map["ApiUid"] = self.apiUid!
            }
            if self.groupId != nil {
                map["GroupId"] = self.groupId!
            }
            if self.stageId != nil {
                map["StageId"] = self.stageId!
            }
            if self.stageName != nil {
                map["StageName"] = self.stageName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApiUid") && dict["ApiUid"] != nil {
                self.apiUid = dict["ApiUid"] as! String
            }
            if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                self.groupId = dict["GroupId"] as! String
            }
            if dict.keys.contains("StageId") && dict["StageId"] != nil {
                self.stageId = dict["StageId"] as! String
            }
            if dict.keys.contains("StageName") && dict["StageName"] != nil {
                self.stageName = dict["StageName"] as! String
            }
        }
    }
    public var api: [BatchAbolishApisRequest.Api]?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.api != nil {
            var tmp : [Any] = []
            for k in self.api! {
                tmp.append(k.toMap())
            }
            map["Api"] = tmp
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Api") && dict["Api"] != nil {
            var tmp : [BatchAbolishApisRequest.Api] = []
            for v in dict["Api"] as! [Any] {
                var model = BatchAbolishApisRequest.Api()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.api = tmp
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class BatchAbolishApisResponseBody : Tea.TeaModel {
    public var operationId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.operationId != nil {
            map["OperationId"] = self.operationId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OperationId") && dict["OperationId"] != nil {
            self.operationId = dict["OperationId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class BatchAbolishApisResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BatchAbolishApisResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = BatchAbolishApisResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class BatchDeployApisRequest : Tea.TeaModel {
    public class Api : Tea.TeaModel {
        public var apiUid: String?

        public var groupId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apiUid != nil {
                map["ApiUid"] = self.apiUid!
            }
            if self.groupId != nil {
                map["GroupId"] = self.groupId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApiUid") && dict["ApiUid"] != nil {
                self.apiUid = dict["ApiUid"] as! String
            }
            if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                self.groupId = dict["GroupId"] as! String
            }
        }
    }
    public var api: [BatchDeployApisRequest.Api]?

    public var description_: String?

    public var securityToken: String?

    public var stageName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.api != nil {
            var tmp : [Any] = []
            for k in self.api! {
                tmp.append(k.toMap())
            }
            map["Api"] = tmp
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.stageName != nil {
            map["StageName"] = self.stageName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Api") && dict["Api"] != nil {
            var tmp : [BatchDeployApisRequest.Api] = []
            for v in dict["Api"] as! [Any] {
                var model = BatchDeployApisRequest.Api()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.api = tmp
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StageName") && dict["StageName"] != nil {
            self.stageName = dict["StageName"] as! String
        }
    }
}

public class BatchDeployApisResponseBody : Tea.TeaModel {
    public var operationId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.operationId != nil {
            map["OperationId"] = self.operationId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OperationId") && dict["OperationId"] != nil {
            self.operationId = dict["OperationId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class BatchDeployApisResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BatchDeployApisResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = BatchDeployApisResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateAccessControlListRequest : Tea.TeaModel {
    public var aclName: String?

    public var addressIPVersion: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aclName != nil {
            map["AclName"] = self.aclName!
        }
        if self.addressIPVersion != nil {
            map["AddressIPVersion"] = self.addressIPVersion!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AclName") && dict["AclName"] != nil {
            self.aclName = dict["AclName"] as! String
        }
        if dict.keys.contains("AddressIPVersion") && dict["AddressIPVersion"] != nil {
            self.addressIPVersion = dict["AddressIPVersion"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class CreateAccessControlListResponseBody : Tea.TeaModel {
    public var aclId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aclId != nil {
            map["AclId"] = self.aclId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AclId") && dict["AclId"] != nil {
            self.aclId = dict["AclId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateAccessControlListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateAccessControlListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateAccessControlListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateApiRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var allowSignatureMethod: String?

    public var apiName: String?

    public var appCodeAuthType: String?

    public var authType: String?

    public var backendEnable: Bool?

    public var backendId: String?

    public var constantParameters: String?

    public var description_: String?

    public var disableInternet: Bool?

    public var errorCodeSamples: String?

    public var failResultSample: String?

    public var forceNonceCheck: Bool?

    public var groupId: String?

    public var openIdConnectConfig: String?

    public var requestConfig: String?

    public var requestParameters: String?

    public var resultBodyModel: String?

    public var resultDescriptions: String?

    public var resultSample: String?

    public var resultType: String?

    public var securityToken: String?

    public var serviceConfig: String?

    public var serviceParameters: String?

    public var serviceParametersMap: String?

    public var systemParameters: String?

    public var tag: [CreateApiRequest.Tag]?

    public var visibility: String?

    public var webSocketApiType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.allowSignatureMethod != nil {
            map["AllowSignatureMethod"] = self.allowSignatureMethod!
        }
        if self.apiName != nil {
            map["ApiName"] = self.apiName!
        }
        if self.appCodeAuthType != nil {
            map["AppCodeAuthType"] = self.appCodeAuthType!
        }
        if self.authType != nil {
            map["AuthType"] = self.authType!
        }
        if self.backendEnable != nil {
            map["BackendEnable"] = self.backendEnable!
        }
        if self.backendId != nil {
            map["BackendId"] = self.backendId!
        }
        if self.constantParameters != nil {
            map["ConstantParameters"] = self.constantParameters!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.disableInternet != nil {
            map["DisableInternet"] = self.disableInternet!
        }
        if self.errorCodeSamples != nil {
            map["ErrorCodeSamples"] = self.errorCodeSamples!
        }
        if self.failResultSample != nil {
            map["FailResultSample"] = self.failResultSample!
        }
        if self.forceNonceCheck != nil {
            map["ForceNonceCheck"] = self.forceNonceCheck!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.openIdConnectConfig != nil {
            map["OpenIdConnectConfig"] = self.openIdConnectConfig!
        }
        if self.requestConfig != nil {
            map["RequestConfig"] = self.requestConfig!
        }
        if self.requestParameters != nil {
            map["RequestParameters"] = self.requestParameters!
        }
        if self.resultBodyModel != nil {
            map["ResultBodyModel"] = self.resultBodyModel!
        }
        if self.resultDescriptions != nil {
            map["ResultDescriptions"] = self.resultDescriptions!
        }
        if self.resultSample != nil {
            map["ResultSample"] = self.resultSample!
        }
        if self.resultType != nil {
            map["ResultType"] = self.resultType!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.serviceConfig != nil {
            map["ServiceConfig"] = self.serviceConfig!
        }
        if self.serviceParameters != nil {
            map["ServiceParameters"] = self.serviceParameters!
        }
        if self.serviceParametersMap != nil {
            map["ServiceParametersMap"] = self.serviceParametersMap!
        }
        if self.systemParameters != nil {
            map["SystemParameters"] = self.systemParameters!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.visibility != nil {
            map["Visibility"] = self.visibility!
        }
        if self.webSocketApiType != nil {
            map["WebSocketApiType"] = self.webSocketApiType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AllowSignatureMethod") && dict["AllowSignatureMethod"] != nil {
            self.allowSignatureMethod = dict["AllowSignatureMethod"] as! String
        }
        if dict.keys.contains("ApiName") && dict["ApiName"] != nil {
            self.apiName = dict["ApiName"] as! String
        }
        if dict.keys.contains("AppCodeAuthType") && dict["AppCodeAuthType"] != nil {
            self.appCodeAuthType = dict["AppCodeAuthType"] as! String
        }
        if dict.keys.contains("AuthType") && dict["AuthType"] != nil {
            self.authType = dict["AuthType"] as! String
        }
        if dict.keys.contains("BackendEnable") && dict["BackendEnable"] != nil {
            self.backendEnable = dict["BackendEnable"] as! Bool
        }
        if dict.keys.contains("BackendId") && dict["BackendId"] != nil {
            self.backendId = dict["BackendId"] as! String
        }
        if dict.keys.contains("ConstantParameters") && dict["ConstantParameters"] != nil {
            self.constantParameters = dict["ConstantParameters"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DisableInternet") && dict["DisableInternet"] != nil {
            self.disableInternet = dict["DisableInternet"] as! Bool
        }
        if dict.keys.contains("ErrorCodeSamples") && dict["ErrorCodeSamples"] != nil {
            self.errorCodeSamples = dict["ErrorCodeSamples"] as! String
        }
        if dict.keys.contains("FailResultSample") && dict["FailResultSample"] != nil {
            self.failResultSample = dict["FailResultSample"] as! String
        }
        if dict.keys.contains("ForceNonceCheck") && dict["ForceNonceCheck"] != nil {
            self.forceNonceCheck = dict["ForceNonceCheck"] as! Bool
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("OpenIdConnectConfig") && dict["OpenIdConnectConfig"] != nil {
            self.openIdConnectConfig = dict["OpenIdConnectConfig"] as! String
        }
        if dict.keys.contains("RequestConfig") && dict["RequestConfig"] != nil {
            self.requestConfig = dict["RequestConfig"] as! String
        }
        if dict.keys.contains("RequestParameters") && dict["RequestParameters"] != nil {
            self.requestParameters = dict["RequestParameters"] as! String
        }
        if dict.keys.contains("ResultBodyModel") && dict["ResultBodyModel"] != nil {
            self.resultBodyModel = dict["ResultBodyModel"] as! String
        }
        if dict.keys.contains("ResultDescriptions") && dict["ResultDescriptions"] != nil {
            self.resultDescriptions = dict["ResultDescriptions"] as! String
        }
        if dict.keys.contains("ResultSample") && dict["ResultSample"] != nil {
            self.resultSample = dict["ResultSample"] as! String
        }
        if dict.keys.contains("ResultType") && dict["ResultType"] != nil {
            self.resultType = dict["ResultType"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("ServiceConfig") && dict["ServiceConfig"] != nil {
            self.serviceConfig = dict["ServiceConfig"] as! String
        }
        if dict.keys.contains("ServiceParameters") && dict["ServiceParameters"] != nil {
            self.serviceParameters = dict["ServiceParameters"] as! String
        }
        if dict.keys.contains("ServiceParametersMap") && dict["ServiceParametersMap"] != nil {
            self.serviceParametersMap = dict["ServiceParametersMap"] as! String
        }
        if dict.keys.contains("SystemParameters") && dict["SystemParameters"] != nil {
            self.systemParameters = dict["SystemParameters"] as! String
        }
        if dict.keys.contains("Tag") && dict["Tag"] != nil {
            var tmp : [CreateApiRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = CreateApiRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("Visibility") && dict["Visibility"] != nil {
            self.visibility = dict["Visibility"] as! String
        }
        if dict.keys.contains("WebSocketApiType") && dict["WebSocketApiType"] != nil {
            self.webSocketApiType = dict["WebSocketApiType"] as! String
        }
    }
}

public class CreateApiResponseBody : Tea.TeaModel {
    public var apiId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiId") && dict["ApiId"] != nil {
            self.apiId = dict["ApiId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateApiResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateApiResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateApiResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateApiGroupRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var basePath: String?

    public var description_: String?

    public var groupName: String?

    public var instanceId: String?

    public var securityToken: String?

    public var tag: [CreateApiGroupRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.basePath != nil {
            map["BasePath"] = self.basePath!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BasePath") && dict["BasePath"] != nil {
            self.basePath = dict["BasePath"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("Tag") && dict["Tag"] != nil {
            var tmp : [CreateApiGroupRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = CreateApiGroupRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class CreateApiGroupResponseBody : Tea.TeaModel {
    public var basePath: String?

    public var description_: String?

    public var groupId: String?

    public var groupName: String?

    public var instanceId: String?

    public var instanceType: String?

    public var requestId: String?

    public var subDomain: String?

    public var tagStatus: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.basePath != nil {
            map["BasePath"] = self.basePath!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.subDomain != nil {
            map["SubDomain"] = self.subDomain!
        }
        if self.tagStatus != nil {
            map["TagStatus"] = self.tagStatus!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BasePath") && dict["BasePath"] != nil {
            self.basePath = dict["BasePath"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("InstanceType") && dict["InstanceType"] != nil {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SubDomain") && dict["SubDomain"] != nil {
            self.subDomain = dict["SubDomain"] as! String
        }
        if dict.keys.contains("TagStatus") && dict["TagStatus"] != nil {
            self.tagStatus = dict["TagStatus"] as! Bool
        }
    }
}

public class CreateApiGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateApiGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateApiGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateApiStageVariableRequest : Tea.TeaModel {
    public var groupId: String?

    public var securityToken: String?

    public var stageId: String?

    public var stageRouteModel: String?

    public var supportRoute: Bool?

    public var variableName: String?

    public var variableValue: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.stageId != nil {
            map["StageId"] = self.stageId!
        }
        if self.stageRouteModel != nil {
            map["StageRouteModel"] = self.stageRouteModel!
        }
        if self.supportRoute != nil {
            map["SupportRoute"] = self.supportRoute!
        }
        if self.variableName != nil {
            map["VariableName"] = self.variableName!
        }
        if self.variableValue != nil {
            map["VariableValue"] = self.variableValue!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StageId") && dict["StageId"] != nil {
            self.stageId = dict["StageId"] as! String
        }
        if dict.keys.contains("StageRouteModel") && dict["StageRouteModel"] != nil {
            self.stageRouteModel = dict["StageRouteModel"] as! String
        }
        if dict.keys.contains("SupportRoute") && dict["SupportRoute"] != nil {
            self.supportRoute = dict["SupportRoute"] as! Bool
        }
        if dict.keys.contains("VariableName") && dict["VariableName"] != nil {
            self.variableName = dict["VariableName"] as! String
        }
        if dict.keys.contains("VariableValue") && dict["VariableValue"] != nil {
            self.variableValue = dict["VariableValue"] as! String
        }
    }
}

public class CreateApiStageVariableResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateApiStageVariableResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateApiStageVariableResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateApiStageVariableResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateAppRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var appCode: String?

    public var appKey: String?

    public var appName: String?

    public var appSecret: String?

    public var description_: String?

    public var extend: String?

    public var securityToken: String?

    public var tag: [CreateAppRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appCode != nil {
            map["AppCode"] = self.appCode!
        }
        if self.appKey != nil {
            map["AppKey"] = self.appKey!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.appSecret != nil {
            map["AppSecret"] = self.appSecret!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.extend != nil {
            map["Extend"] = self.extend!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppCode") && dict["AppCode"] != nil {
            self.appCode = dict["AppCode"] as! String
        }
        if dict.keys.contains("AppKey") && dict["AppKey"] != nil {
            self.appKey = dict["AppKey"] as! String
        }
        if dict.keys.contains("AppName") && dict["AppName"] != nil {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("AppSecret") && dict["AppSecret"] != nil {
            self.appSecret = dict["AppSecret"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Extend") && dict["Extend"] != nil {
            self.extend = dict["Extend"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("Tag") && dict["Tag"] != nil {
            var tmp : [CreateAppRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = CreateAppRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class CreateAppResponseBody : Tea.TeaModel {
    public var appId: Int64?

    public var requestId: String?

    public var tagStatus: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.tagStatus != nil {
            map["TagStatus"] = self.tagStatus!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! Int64
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TagStatus") && dict["TagStatus"] != nil {
            self.tagStatus = dict["TagStatus"] as! Bool
        }
    }
}

public class CreateAppResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateAppResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateAppResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateBackendRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var backendName: String?

    public var backendType: String?

    public var createEventBridgeServiceLinkedRole: Bool?

    public var createSlr: Bool?

    public var description_: String?

    public var securityToken: String?

    public var tag: [CreateBackendRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backendName != nil {
            map["BackendName"] = self.backendName!
        }
        if self.backendType != nil {
            map["BackendType"] = self.backendType!
        }
        if self.createEventBridgeServiceLinkedRole != nil {
            map["CreateEventBridgeServiceLinkedRole"] = self.createEventBridgeServiceLinkedRole!
        }
        if self.createSlr != nil {
            map["CreateSlr"] = self.createSlr!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BackendName") && dict["BackendName"] != nil {
            self.backendName = dict["BackendName"] as! String
        }
        if dict.keys.contains("BackendType") && dict["BackendType"] != nil {
            self.backendType = dict["BackendType"] as! String
        }
        if dict.keys.contains("CreateEventBridgeServiceLinkedRole") && dict["CreateEventBridgeServiceLinkedRole"] != nil {
            self.createEventBridgeServiceLinkedRole = dict["CreateEventBridgeServiceLinkedRole"] as! Bool
        }
        if dict.keys.contains("CreateSlr") && dict["CreateSlr"] != nil {
            self.createSlr = dict["CreateSlr"] as! Bool
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("Tag") && dict["Tag"] != nil {
            var tmp : [CreateBackendRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = CreateBackendRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class CreateBackendResponseBody : Tea.TeaModel {
    public var backendId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backendId != nil {
            map["BackendId"] = self.backendId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BackendId") && dict["BackendId"] != nil {
            self.backendId = dict["BackendId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateBackendResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateBackendResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateBackendResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateBackendModelRequest : Tea.TeaModel {
    public var backendId: String?

    public var backendModelData: String?

    public var backendType: String?

    public var description_: String?

    public var securityToken: String?

    public var stageName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backendId != nil {
            map["BackendId"] = self.backendId!
        }
        if self.backendModelData != nil {
            map["BackendModelData"] = self.backendModelData!
        }
        if self.backendType != nil {
            map["BackendType"] = self.backendType!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.stageName != nil {
            map["StageName"] = self.stageName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BackendId") && dict["BackendId"] != nil {
            self.backendId = dict["BackendId"] as! String
        }
        if dict.keys.contains("BackendModelData") && dict["BackendModelData"] != nil {
            self.backendModelData = dict["BackendModelData"] as! String
        }
        if dict.keys.contains("BackendType") && dict["BackendType"] != nil {
            self.backendType = dict["BackendType"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StageName") && dict["StageName"] != nil {
            self.stageName = dict["StageName"] as! String
        }
    }
}

public class CreateBackendModelResponseBody : Tea.TeaModel {
    public var backendModelId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backendModelId != nil {
            map["BackendModelId"] = self.backendModelId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BackendModelId") && dict["BackendModelId"] != nil {
            self.backendModelId = dict["BackendModelId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateBackendModelResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateBackendModelResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateBackendModelResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateDatasetRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var datasetName: String?

    public var datasetType: String?

    public var securityToken: String?

    public var tag: [CreateDatasetRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.datasetName != nil {
            map["DatasetName"] = self.datasetName!
        }
        if self.datasetType != nil {
            map["DatasetType"] = self.datasetType!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DatasetName") && dict["DatasetName"] != nil {
            self.datasetName = dict["DatasetName"] as! String
        }
        if dict.keys.contains("DatasetType") && dict["DatasetType"] != nil {
            self.datasetType = dict["DatasetType"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("Tag") && dict["Tag"] != nil {
            var tmp : [CreateDatasetRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = CreateDatasetRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class CreateDatasetResponseBody : Tea.TeaModel {
    public var datasetId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.datasetId != nil {
            map["DatasetId"] = self.datasetId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DatasetId") && dict["DatasetId"] != nil {
            self.datasetId = dict["DatasetId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateDatasetResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDatasetResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateDatasetResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateDatasetItemRequest : Tea.TeaModel {
    public var datasetId: String?

    public var description_: String?

    public var expiredTime: String?

    public var securityToken: String?

    public var value: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.datasetId != nil {
            map["DatasetId"] = self.datasetId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.expiredTime != nil {
            map["ExpiredTime"] = self.expiredTime!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.value != nil {
            map["Value"] = self.value!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DatasetId") && dict["DatasetId"] != nil {
            self.datasetId = dict["DatasetId"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("ExpiredTime") && dict["ExpiredTime"] != nil {
            self.expiredTime = dict["ExpiredTime"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("Value") && dict["Value"] != nil {
            self.value = dict["Value"] as! String
        }
    }
}

public class CreateDatasetItemResponseBody : Tea.TeaModel {
    public var datasetItemId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.datasetItemId != nil {
            map["DatasetItemId"] = self.datasetItemId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DatasetItemId") && dict["DatasetItemId"] != nil {
            self.datasetItemId = dict["DatasetItemId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateDatasetItemResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDatasetItemResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateDatasetItemResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateInstanceRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public class ZoneVSwitchSecurityGroup : Tea.TeaModel {
        public var cidrBlock: String?

        public var securityGroupId: String?

        public var vSwitchId: String?

        public var zoneId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cidrBlock != nil {
                map["CidrBlock"] = self.cidrBlock!
            }
            if self.securityGroupId != nil {
                map["SecurityGroupId"] = self.securityGroupId!
            }
            if self.vSwitchId != nil {
                map["VSwitchId"] = self.vSwitchId!
            }
            if self.zoneId != nil {
                map["ZoneId"] = self.zoneId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CidrBlock") && dict["CidrBlock"] != nil {
                self.cidrBlock = dict["CidrBlock"] as! String
            }
            if dict.keys.contains("SecurityGroupId") && dict["SecurityGroupId"] != nil {
                self.securityGroupId = dict["SecurityGroupId"] as! String
            }
            if dict.keys.contains("VSwitchId") && dict["VSwitchId"] != nil {
                self.vSwitchId = dict["VSwitchId"] as! String
            }
            if dict.keys.contains("ZoneId") && dict["ZoneId"] != nil {
                self.zoneId = dict["ZoneId"] as! String
            }
        }
    }
    public var autoPay: Bool?

    public var chargeType: String?

    public var duration: Int32?

    public var httpsPolicy: String?

    public var instanceCidr: String?

    public var instanceName: String?

    public var instanceSpec: String?

    public var instanceType: String?

    public var pricingCycle: String?

    public var tag: [CreateInstanceRequest.Tag]?

    public var token: String?

    public var userVpcId: String?

    public var zoneId: String?

    public var zoneVSwitchSecurityGroup: [CreateInstanceRequest.ZoneVSwitchSecurityGroup]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.chargeType != nil {
            map["ChargeType"] = self.chargeType!
        }
        if self.duration != nil {
            map["Duration"] = self.duration!
        }
        if self.httpsPolicy != nil {
            map["HttpsPolicy"] = self.httpsPolicy!
        }
        if self.instanceCidr != nil {
            map["InstanceCidr"] = self.instanceCidr!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.instanceSpec != nil {
            map["InstanceSpec"] = self.instanceSpec!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.pricingCycle != nil {
            map["PricingCycle"] = self.pricingCycle!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.token != nil {
            map["Token"] = self.token!
        }
        if self.userVpcId != nil {
            map["UserVpcId"] = self.userVpcId!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        if self.zoneVSwitchSecurityGroup != nil {
            var tmp : [Any] = []
            for k in self.zoneVSwitchSecurityGroup! {
                tmp.append(k.toMap())
            }
            map["ZoneVSwitchSecurityGroup"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoPay") && dict["AutoPay"] != nil {
            self.autoPay = dict["AutoPay"] as! Bool
        }
        if dict.keys.contains("ChargeType") && dict["ChargeType"] != nil {
            self.chargeType = dict["ChargeType"] as! String
        }
        if dict.keys.contains("Duration") && dict["Duration"] != nil {
            self.duration = dict["Duration"] as! Int32
        }
        if dict.keys.contains("HttpsPolicy") && dict["HttpsPolicy"] != nil {
            self.httpsPolicy = dict["HttpsPolicy"] as! String
        }
        if dict.keys.contains("InstanceCidr") && dict["InstanceCidr"] != nil {
            self.instanceCidr = dict["InstanceCidr"] as! String
        }
        if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
            self.instanceName = dict["InstanceName"] as! String
        }
        if dict.keys.contains("InstanceSpec") && dict["InstanceSpec"] != nil {
            self.instanceSpec = dict["InstanceSpec"] as! String
        }
        if dict.keys.contains("InstanceType") && dict["InstanceType"] != nil {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("PricingCycle") && dict["PricingCycle"] != nil {
            self.pricingCycle = dict["PricingCycle"] as! String
        }
        if dict.keys.contains("Tag") && dict["Tag"] != nil {
            var tmp : [CreateInstanceRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = CreateInstanceRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("Token") && dict["Token"] != nil {
            self.token = dict["Token"] as! String
        }
        if dict.keys.contains("UserVpcId") && dict["UserVpcId"] != nil {
            self.userVpcId = dict["UserVpcId"] as! String
        }
        if dict.keys.contains("ZoneId") && dict["ZoneId"] != nil {
            self.zoneId = dict["ZoneId"] as! String
        }
        if dict.keys.contains("ZoneVSwitchSecurityGroup") && dict["ZoneVSwitchSecurityGroup"] != nil {
            var tmp : [CreateInstanceRequest.ZoneVSwitchSecurityGroup] = []
            for v in dict["ZoneVSwitchSecurityGroup"] as! [Any] {
                var model = CreateInstanceRequest.ZoneVSwitchSecurityGroup()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.zoneVSwitchSecurityGroup = tmp
        }
    }
}

public class CreateInstanceResponseBody : Tea.TeaModel {
    public var instanceId: String?

    public var requestId: String?

    public var tagStatus: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.tagStatus != nil {
            map["TagStatus"] = self.tagStatus!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TagStatus") && dict["TagStatus"] != nil {
            self.tagStatus = dict["TagStatus"] as! Bool
        }
    }
}

public class CreateInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateIntranetDomainRequest : Tea.TeaModel {
    public var groupId: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class CreateIntranetDomainResponseBody : Tea.TeaModel {
    public var domainName: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") && dict["DomainName"] != nil {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateIntranetDomainResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateIntranetDomainResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateIntranetDomainResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateIpControlRequest : Tea.TeaModel {
    public class IpControlPolicys : Tea.TeaModel {
        public var appId: String?

        public var cidrIp: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.cidrIp != nil {
                map["CidrIp"] = self.cidrIp!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") && dict["AppId"] != nil {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("CidrIp") && dict["CidrIp"] != nil {
                self.cidrIp = dict["CidrIp"] as! String
            }
        }
    }
    public var description_: String?

    public var ipControlName: String?

    public var ipControlPolicys: [CreateIpControlRequest.IpControlPolicys]?

    public var ipControlType: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.ipControlName != nil {
            map["IpControlName"] = self.ipControlName!
        }
        if self.ipControlPolicys != nil {
            var tmp : [Any] = []
            for k in self.ipControlPolicys! {
                tmp.append(k.toMap())
            }
            map["IpControlPolicys"] = tmp
        }
        if self.ipControlType != nil {
            map["IpControlType"] = self.ipControlType!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("IpControlName") && dict["IpControlName"] != nil {
            self.ipControlName = dict["IpControlName"] as! String
        }
        if dict.keys.contains("IpControlPolicys") && dict["IpControlPolicys"] != nil {
            var tmp : [CreateIpControlRequest.IpControlPolicys] = []
            for v in dict["IpControlPolicys"] as! [Any] {
                var model = CreateIpControlRequest.IpControlPolicys()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.ipControlPolicys = tmp
        }
        if dict.keys.contains("IpControlType") && dict["IpControlType"] != nil {
            self.ipControlType = dict["IpControlType"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class CreateIpControlResponseBody : Tea.TeaModel {
    public var ipControlId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ipControlId != nil {
            map["IpControlId"] = self.ipControlId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IpControlId") && dict["IpControlId"] != nil {
            self.ipControlId = dict["IpControlId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateIpControlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateIpControlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateIpControlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateLogConfigRequest : Tea.TeaModel {
    public var logType: String?

    public var securityToken: String?

    public var slsLogStore: String?

    public var slsProject: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.logType != nil {
            map["LogType"] = self.logType!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.slsLogStore != nil {
            map["SlsLogStore"] = self.slsLogStore!
        }
        if self.slsProject != nil {
            map["SlsProject"] = self.slsProject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LogType") && dict["LogType"] != nil {
            self.logType = dict["LogType"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("SlsLogStore") && dict["SlsLogStore"] != nil {
            self.slsLogStore = dict["SlsLogStore"] as! String
        }
        if dict.keys.contains("SlsProject") && dict["SlsProject"] != nil {
            self.slsProject = dict["SlsProject"] as! String
        }
    }
}

public class CreateLogConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateLogConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateLogConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateLogConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateModelRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var description_: String?

    public var groupId: String?

    public var modelName: String?

    public var schema: String?

    public var tag: [CreateModelRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.modelName != nil {
            map["ModelName"] = self.modelName!
        }
        if self.schema != nil {
            map["Schema"] = self.schema!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("ModelName") && dict["ModelName"] != nil {
            self.modelName = dict["ModelName"] as! String
        }
        if dict.keys.contains("Schema") && dict["Schema"] != nil {
            self.schema = dict["Schema"] as! String
        }
        if dict.keys.contains("Tag") && dict["Tag"] != nil {
            var tmp : [CreateModelRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = CreateModelRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class CreateModelResponseBody : Tea.TeaModel {
    public var createdTime: String?

    public var description_: String?

    public var groupId: String?

    public var modelId: String?

    public var modelName: String?

    public var modelRef: String?

    public var modifiedTime: String?

    public var regionId: String?

    public var requestId: String?

    public var schema: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createdTime != nil {
            map["CreatedTime"] = self.createdTime!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.modelId != nil {
            map["ModelId"] = self.modelId!
        }
        if self.modelName != nil {
            map["ModelName"] = self.modelName!
        }
        if self.modelRef != nil {
            map["ModelRef"] = self.modelRef!
        }
        if self.modifiedTime != nil {
            map["ModifiedTime"] = self.modifiedTime!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.schema != nil {
            map["Schema"] = self.schema!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreatedTime") && dict["CreatedTime"] != nil {
            self.createdTime = dict["CreatedTime"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("ModelId") && dict["ModelId"] != nil {
            self.modelId = dict["ModelId"] as! String
        }
        if dict.keys.contains("ModelName") && dict["ModelName"] != nil {
            self.modelName = dict["ModelName"] as! String
        }
        if dict.keys.contains("ModelRef") && dict["ModelRef"] != nil {
            self.modelRef = dict["ModelRef"] as! String
        }
        if dict.keys.contains("ModifiedTime") && dict["ModifiedTime"] != nil {
            self.modifiedTime = dict["ModifiedTime"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Schema") && dict["Schema"] != nil {
            self.schema = dict["Schema"] as! String
        }
    }
}

public class CreateModelResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateModelResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateModelResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateMonitorGroupRequest : Tea.TeaModel {
    public var auth: String?

    public var groupId: String?

    public var rawMonitorGroupId: Int64?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.auth != nil {
            map["Auth"] = self.auth!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.rawMonitorGroupId != nil {
            map["RawMonitorGroupId"] = self.rawMonitorGroupId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Auth") && dict["Auth"] != nil {
            self.auth = dict["Auth"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("RawMonitorGroupId") && dict["RawMonitorGroupId"] != nil {
            self.rawMonitorGroupId = dict["RawMonitorGroupId"] as! Int64
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class CreateMonitorGroupResponseBody : Tea.TeaModel {
    public var monitorGroupId: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.monitorGroupId != nil {
            map["MonitorGroupId"] = self.monitorGroupId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MonitorGroupId") && dict["MonitorGroupId"] != nil {
            self.monitorGroupId = dict["MonitorGroupId"] as! Int64
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateMonitorGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateMonitorGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateMonitorGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreatePluginRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var description_: String?

    public var pluginData: String?

    public var pluginName: String?

    public var pluginType: String?

    public var securityToken: String?

    public var tag: [CreatePluginRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.pluginData != nil {
            map["PluginData"] = self.pluginData!
        }
        if self.pluginName != nil {
            map["PluginName"] = self.pluginName!
        }
        if self.pluginType != nil {
            map["PluginType"] = self.pluginType!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("PluginData") && dict["PluginData"] != nil {
            self.pluginData = dict["PluginData"] as! String
        }
        if dict.keys.contains("PluginName") && dict["PluginName"] != nil {
            self.pluginName = dict["PluginName"] as! String
        }
        if dict.keys.contains("PluginType") && dict["PluginType"] != nil {
            self.pluginType = dict["PluginType"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("Tag") && dict["Tag"] != nil {
            var tmp : [CreatePluginRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = CreatePluginRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class CreatePluginResponseBody : Tea.TeaModel {
    public var pluginId: String?

    public var requestId: String?

    public var tagStatus: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pluginId != nil {
            map["PluginId"] = self.pluginId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.tagStatus != nil {
            map["TagStatus"] = self.tagStatus!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PluginId") && dict["PluginId"] != nil {
            self.pluginId = dict["PluginId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TagStatus") && dict["TagStatus"] != nil {
            self.tagStatus = dict["TagStatus"] as! Bool
        }
    }
}

public class CreatePluginResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreatePluginResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreatePluginResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateSignatureRequest : Tea.TeaModel {
    public var securityToken: String?

    public var signatureKey: String?

    public var signatureName: String?

    public var signatureSecret: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.signatureKey != nil {
            map["SignatureKey"] = self.signatureKey!
        }
        if self.signatureName != nil {
            map["SignatureName"] = self.signatureName!
        }
        if self.signatureSecret != nil {
            map["SignatureSecret"] = self.signatureSecret!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("SignatureKey") && dict["SignatureKey"] != nil {
            self.signatureKey = dict["SignatureKey"] as! String
        }
        if dict.keys.contains("SignatureName") && dict["SignatureName"] != nil {
            self.signatureName = dict["SignatureName"] as! String
        }
        if dict.keys.contains("SignatureSecret") && dict["SignatureSecret"] != nil {
            self.signatureSecret = dict["SignatureSecret"] as! String
        }
    }
}

public class CreateSignatureResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var signatureId: String?

    public var signatureName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.signatureId != nil {
            map["SignatureId"] = self.signatureId!
        }
        if self.signatureName != nil {
            map["SignatureName"] = self.signatureName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SignatureId") && dict["SignatureId"] != nil {
            self.signatureId = dict["SignatureId"] as! String
        }
        if dict.keys.contains("SignatureName") && dict["SignatureName"] != nil {
            self.signatureName = dict["SignatureName"] as! String
        }
    }
}

public class CreateSignatureResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateSignatureResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateSignatureResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateTrafficControlRequest : Tea.TeaModel {
    public var apiDefault: Int32?

    public var appDefault: Int32?

    public var description_: String?

    public var securityToken: String?

    public var trafficControlName: String?

    public var trafficControlUnit: String?

    public var userDefault: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiDefault != nil {
            map["ApiDefault"] = self.apiDefault!
        }
        if self.appDefault != nil {
            map["AppDefault"] = self.appDefault!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.trafficControlName != nil {
            map["TrafficControlName"] = self.trafficControlName!
        }
        if self.trafficControlUnit != nil {
            map["TrafficControlUnit"] = self.trafficControlUnit!
        }
        if self.userDefault != nil {
            map["UserDefault"] = self.userDefault!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiDefault") && dict["ApiDefault"] != nil {
            self.apiDefault = dict["ApiDefault"] as! Int32
        }
        if dict.keys.contains("AppDefault") && dict["AppDefault"] != nil {
            self.appDefault = dict["AppDefault"] as! Int32
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("TrafficControlName") && dict["TrafficControlName"] != nil {
            self.trafficControlName = dict["TrafficControlName"] as! String
        }
        if dict.keys.contains("TrafficControlUnit") && dict["TrafficControlUnit"] != nil {
            self.trafficControlUnit = dict["TrafficControlUnit"] as! String
        }
        if dict.keys.contains("UserDefault") && dict["UserDefault"] != nil {
            self.userDefault = dict["UserDefault"] as! Int32
        }
    }
}

public class CreateTrafficControlResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var trafficControlId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.trafficControlId != nil {
            map["TrafficControlId"] = self.trafficControlId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TrafficControlId") && dict["TrafficControlId"] != nil {
            self.trafficControlId = dict["TrafficControlId"] as! String
        }
    }
}

public class CreateTrafficControlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateTrafficControlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateTrafficControlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteAccessControlListRequest : Tea.TeaModel {
    public var aclId: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aclId != nil {
            map["AclId"] = self.aclId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AclId") && dict["AclId"] != nil {
            self.aclId = dict["AclId"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DeleteAccessControlListResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteAccessControlListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteAccessControlListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteAccessControlListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteAllTrafficSpecialControlRequest : Tea.TeaModel {
    public var securityToken: String?

    public var trafficControlId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.trafficControlId != nil {
            map["TrafficControlId"] = self.trafficControlId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("TrafficControlId") && dict["TrafficControlId"] != nil {
            self.trafficControlId = dict["TrafficControlId"] as! String
        }
    }
}

public class DeleteAllTrafficSpecialControlResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteAllTrafficSpecialControlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteAllTrafficSpecialControlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteAllTrafficSpecialControlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteApiRequest : Tea.TeaModel {
    public var apiId: String?

    public var groupId: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiId") && dict["ApiId"] != nil {
            self.apiId = dict["ApiId"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DeleteApiResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteApiResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteApiResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteApiResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteApiGroupRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var groupId: String?

    public var securityToken: String?

    public var tag: [DeleteApiGroupRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("Tag") && dict["Tag"] != nil {
            var tmp : [DeleteApiGroupRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = DeleteApiGroupRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class DeleteApiGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteApiGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteApiGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteApiGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteApiProductRequest : Tea.TeaModel {
    public var apiProductId: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiProductId != nil {
            map["ApiProductId"] = self.apiProductId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiProductId") && dict["ApiProductId"] != nil {
            self.apiProductId = dict["ApiProductId"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DeleteApiProductResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteApiProductResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteApiProductResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteApiProductResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteApiStageVariableRequest : Tea.TeaModel {
    public var groupId: String?

    public var securityToken: String?

    public var stageId: String?

    public var variableName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.stageId != nil {
            map["StageId"] = self.stageId!
        }
        if self.variableName != nil {
            map["VariableName"] = self.variableName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StageId") && dict["StageId"] != nil {
            self.stageId = dict["StageId"] as! String
        }
        if dict.keys.contains("VariableName") && dict["VariableName"] != nil {
            self.variableName = dict["VariableName"] as! String
        }
    }
}

public class DeleteApiStageVariableResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteApiStageVariableResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteApiStageVariableResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteApiStageVariableResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteAppRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var appId: Int64?

    public var securityToken: String?

    public var tag: [DeleteAppRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! Int64
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("Tag") && dict["Tag"] != nil {
            var tmp : [DeleteAppRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = DeleteAppRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class DeleteAppResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteAppResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteAppResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteAppResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteBackendRequest : Tea.TeaModel {
    public var backendId: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backendId != nil {
            map["BackendId"] = self.backendId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BackendId") && dict["BackendId"] != nil {
            self.backendId = dict["BackendId"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DeleteBackendResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteBackendResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteBackendResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteBackendResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteBackendModelRequest : Tea.TeaModel {
    public var backendId: String?

    public var backendModelId: String?

    public var securityToken: String?

    public var stageName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backendId != nil {
            map["BackendId"] = self.backendId!
        }
        if self.backendModelId != nil {
            map["BackendModelId"] = self.backendModelId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.stageName != nil {
            map["StageName"] = self.stageName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BackendId") && dict["BackendId"] != nil {
            self.backendId = dict["BackendId"] as! String
        }
        if dict.keys.contains("BackendModelId") && dict["BackendModelId"] != nil {
            self.backendModelId = dict["BackendModelId"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StageName") && dict["StageName"] != nil {
            self.stageName = dict["StageName"] as! String
        }
    }
}

public class DeleteBackendModelResponseBody : Tea.TeaModel {
    public var operationId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.operationId != nil {
            map["OperationId"] = self.operationId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OperationId") && dict["OperationId"] != nil {
            self.operationId = dict["OperationId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteBackendModelResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteBackendModelResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteBackendModelResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteDatasetRequest : Tea.TeaModel {
    public var datasetId: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.datasetId != nil {
            map["DatasetId"] = self.datasetId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DatasetId") && dict["DatasetId"] != nil {
            self.datasetId = dict["DatasetId"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DeleteDatasetResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteDatasetResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDatasetResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteDatasetResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteDatasetItemRequest : Tea.TeaModel {
    public var datasetId: String?

    public var datasetItemId: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.datasetId != nil {
            map["DatasetId"] = self.datasetId!
        }
        if self.datasetItemId != nil {
            map["DatasetItemId"] = self.datasetItemId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DatasetId") && dict["DatasetId"] != nil {
            self.datasetId = dict["DatasetId"] as! String
        }
        if dict.keys.contains("DatasetItemId") && dict["DatasetItemId"] != nil {
            self.datasetItemId = dict["DatasetItemId"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DeleteDatasetItemResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteDatasetItemResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDatasetItemResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteDatasetItemResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteDomainRequest : Tea.TeaModel {
    public var domainName: String?

    public var groupId: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") && dict["DomainName"] != nil {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DeleteDomainResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteDomainResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDomainResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteDomainResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteDomainCertificateRequest : Tea.TeaModel {
    public var certificateId: String?

    public var domainName: String?

    public var groupId: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.certificateId != nil {
            map["CertificateId"] = self.certificateId!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CertificateId") && dict["CertificateId"] != nil {
            self.certificateId = dict["CertificateId"] as! String
        }
        if dict.keys.contains("DomainName") && dict["DomainName"] != nil {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DeleteDomainCertificateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteDomainCertificateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDomainCertificateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteDomainCertificateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteInstanceRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var instanceId: String?

    public var tag: [DeleteInstanceRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Tag") && dict["Tag"] != nil {
            var tmp : [DeleteInstanceRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = DeleteInstanceRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class DeleteInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteIpControlRequest : Tea.TeaModel {
    public var ipControlId: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ipControlId != nil {
            map["IpControlId"] = self.ipControlId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IpControlId") && dict["IpControlId"] != nil {
            self.ipControlId = dict["IpControlId"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DeleteIpControlResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteIpControlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteIpControlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteIpControlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteLogConfigRequest : Tea.TeaModel {
    public var logType: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.logType != nil {
            map["LogType"] = self.logType!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LogType") && dict["LogType"] != nil {
            self.logType = dict["LogType"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DeleteLogConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteLogConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLogConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteLogConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteModelRequest : Tea.TeaModel {
    public var groupId: String?

    public var modelName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.modelName != nil {
            map["ModelName"] = self.modelName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("ModelName") && dict["ModelName"] != nil {
            self.modelName = dict["ModelName"] as! String
        }
    }
}

public class DeleteModelResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteModelResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteModelResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteModelResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteMonitorGroupRequest : Tea.TeaModel {
    public var groupId: String?

    public var rawMonitorGroupId: Int64?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.rawMonitorGroupId != nil {
            map["RawMonitorGroupId"] = self.rawMonitorGroupId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("RawMonitorGroupId") && dict["RawMonitorGroupId"] != nil {
            self.rawMonitorGroupId = dict["RawMonitorGroupId"] as! Int64
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DeleteMonitorGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteMonitorGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteMonitorGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteMonitorGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeletePluginRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var pluginId: String?

    public var securityToken: String?

    public var tag: [DeletePluginRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pluginId != nil {
            map["PluginId"] = self.pluginId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PluginId") && dict["PluginId"] != nil {
            self.pluginId = dict["PluginId"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("Tag") && dict["Tag"] != nil {
            var tmp : [DeletePluginRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = DeletePluginRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class DeletePluginResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeletePluginResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeletePluginResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeletePluginResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteSignatureRequest : Tea.TeaModel {
    public var securityToken: String?

    public var signatureId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.signatureId != nil {
            map["SignatureId"] = self.signatureId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("SignatureId") && dict["SignatureId"] != nil {
            self.signatureId = dict["SignatureId"] as! String
        }
    }
}

public class DeleteSignatureResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteSignatureResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteSignatureResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteSignatureResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteTrafficControlRequest : Tea.TeaModel {
    public var securityToken: String?

    public var trafficControlId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.trafficControlId != nil {
            map["TrafficControlId"] = self.trafficControlId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("TrafficControlId") && dict["TrafficControlId"] != nil {
            self.trafficControlId = dict["TrafficControlId"] as! String
        }
    }
}

public class DeleteTrafficControlResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteTrafficControlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteTrafficControlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteTrafficControlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteTrafficSpecialControlRequest : Tea.TeaModel {
    public var securityToken: String?

    public var specialKey: String?

    public var specialType: String?

    public var trafficControlId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.specialKey != nil {
            map["SpecialKey"] = self.specialKey!
        }
        if self.specialType != nil {
            map["SpecialType"] = self.specialType!
        }
        if self.trafficControlId != nil {
            map["TrafficControlId"] = self.trafficControlId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("SpecialKey") && dict["SpecialKey"] != nil {
            self.specialKey = dict["SpecialKey"] as! String
        }
        if dict.keys.contains("SpecialType") && dict["SpecialType"] != nil {
            self.specialType = dict["SpecialType"] as! String
        }
        if dict.keys.contains("TrafficControlId") && dict["TrafficControlId"] != nil {
            self.trafficControlId = dict["TrafficControlId"] as! String
        }
    }
}

public class DeleteTrafficSpecialControlResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteTrafficSpecialControlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteTrafficSpecialControlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteTrafficSpecialControlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeployApiRequest : Tea.TeaModel {
    public var apiId: String?

    public var description_: String?

    public var groupId: String?

    public var securityToken: String?

    public var stageName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.stageName != nil {
            map["StageName"] = self.stageName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiId") && dict["ApiId"] != nil {
            self.apiId = dict["ApiId"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StageName") && dict["StageName"] != nil {
            self.stageName = dict["StageName"] as! String
        }
    }
}

public class DeployApiResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeployApiResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeployApiResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeployApiResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAbolishApiTaskRequest : Tea.TeaModel {
    public var operationUid: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.operationUid != nil {
            map["OperationUid"] = self.operationUid!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OperationUid") && dict["OperationUid"] != nil {
            self.operationUid = dict["OperationUid"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DescribeAbolishApiTaskResponseBody : Tea.TeaModel {
    public class ApiAbolishResults : Tea.TeaModel {
        public class ApiAbolishResult : Tea.TeaModel {
            public var abolishStatus: String?

            public var apiName: String?

            public var apiUid: String?

            public var errorMsg: String?

            public var groupId: String?

            public var groupName: String?

            public var stageId: String?

            public var stageName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.abolishStatus != nil {
                    map["AbolishStatus"] = self.abolishStatus!
                }
                if self.apiName != nil {
                    map["ApiName"] = self.apiName!
                }
                if self.apiUid != nil {
                    map["ApiUid"] = self.apiUid!
                }
                if self.errorMsg != nil {
                    map["ErrorMsg"] = self.errorMsg!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.stageId != nil {
                    map["StageId"] = self.stageId!
                }
                if self.stageName != nil {
                    map["StageName"] = self.stageName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AbolishStatus") && dict["AbolishStatus"] != nil {
                    self.abolishStatus = dict["AbolishStatus"] as! String
                }
                if dict.keys.contains("ApiName") && dict["ApiName"] != nil {
                    self.apiName = dict["ApiName"] as! String
                }
                if dict.keys.contains("ApiUid") && dict["ApiUid"] != nil {
                    self.apiUid = dict["ApiUid"] as! String
                }
                if dict.keys.contains("ErrorMsg") && dict["ErrorMsg"] != nil {
                    self.errorMsg = dict["ErrorMsg"] as! String
                }
                if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
                    self.groupName = dict["GroupName"] as! String
                }
                if dict.keys.contains("StageId") && dict["StageId"] != nil {
                    self.stageId = dict["StageId"] as! String
                }
                if dict.keys.contains("StageName") && dict["StageName"] != nil {
                    self.stageName = dict["StageName"] as! String
                }
            }
        }
        public var apiAbolishResult: [DescribeAbolishApiTaskResponseBody.ApiAbolishResults.ApiAbolishResult]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apiAbolishResult != nil {
                var tmp : [Any] = []
                for k in self.apiAbolishResult! {
                    tmp.append(k.toMap())
                }
                map["ApiAbolishResult"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApiAbolishResult") && dict["ApiAbolishResult"] != nil {
                var tmp : [DescribeAbolishApiTaskResponseBody.ApiAbolishResults.ApiAbolishResult] = []
                for v in dict["ApiAbolishResult"] as! [Any] {
                    var model = DescribeAbolishApiTaskResponseBody.ApiAbolishResults.ApiAbolishResult()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.apiAbolishResult = tmp
            }
        }
    }
    public var apiAbolishResults: DescribeAbolishApiTaskResponseBody.ApiAbolishResults?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.apiAbolishResults?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiAbolishResults != nil {
            map["ApiAbolishResults"] = self.apiAbolishResults?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiAbolishResults") && dict["ApiAbolishResults"] != nil {
            var model = DescribeAbolishApiTaskResponseBody.ApiAbolishResults()
            model.fromMap(dict["ApiAbolishResults"] as! [String: Any])
            self.apiAbolishResults = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeAbolishApiTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAbolishApiTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeAbolishApiTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAccessControlListAttributeRequest : Tea.TeaModel {
    public var aclId: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aclId != nil {
            map["AclId"] = self.aclId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AclId") && dict["AclId"] != nil {
            self.aclId = dict["AclId"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DescribeAccessControlListAttributeResponseBody : Tea.TeaModel {
    public class AclEntrys : Tea.TeaModel {
        public class AclEntry : Tea.TeaModel {
            public var aclEntryComment: String?

            public var aclEntryIp: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.aclEntryComment != nil {
                    map["AclEntryComment"] = self.aclEntryComment!
                }
                if self.aclEntryIp != nil {
                    map["AclEntryIp"] = self.aclEntryIp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AclEntryComment") && dict["AclEntryComment"] != nil {
                    self.aclEntryComment = dict["AclEntryComment"] as! String
                }
                if dict.keys.contains("AclEntryIp") && dict["AclEntryIp"] != nil {
                    self.aclEntryIp = dict["AclEntryIp"] as! String
                }
            }
        }
        public var aclEntry: [DescribeAccessControlListAttributeResponseBody.AclEntrys.AclEntry]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aclEntry != nil {
                var tmp : [Any] = []
                for k in self.aclEntry! {
                    tmp.append(k.toMap())
                }
                map["AclEntry"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AclEntry") && dict["AclEntry"] != nil {
                var tmp : [DescribeAccessControlListAttributeResponseBody.AclEntrys.AclEntry] = []
                for v in dict["AclEntry"] as! [Any] {
                    var model = DescribeAccessControlListAttributeResponseBody.AclEntrys.AclEntry()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.aclEntry = tmp
            }
        }
    }
    public var aclEntrys: DescribeAccessControlListAttributeResponseBody.AclEntrys?

    public var aclId: String?

    public var aclName: String?

    public var addressIPVersion: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.aclEntrys?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aclEntrys != nil {
            map["AclEntrys"] = self.aclEntrys?.toMap()
        }
        if self.aclId != nil {
            map["AclId"] = self.aclId!
        }
        if self.aclName != nil {
            map["AclName"] = self.aclName!
        }
        if self.addressIPVersion != nil {
            map["AddressIPVersion"] = self.addressIPVersion!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AclEntrys") && dict["AclEntrys"] != nil {
            var model = DescribeAccessControlListAttributeResponseBody.AclEntrys()
            model.fromMap(dict["AclEntrys"] as! [String: Any])
            self.aclEntrys = model
        }
        if dict.keys.contains("AclId") && dict["AclId"] != nil {
            self.aclId = dict["AclId"] as! String
        }
        if dict.keys.contains("AclName") && dict["AclName"] != nil {
            self.aclName = dict["AclName"] as! String
        }
        if dict.keys.contains("AddressIPVersion") && dict["AddressIPVersion"] != nil {
            self.addressIPVersion = dict["AddressIPVersion"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeAccessControlListAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAccessControlListAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeAccessControlListAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAccessControlListsRequest : Tea.TeaModel {
    public var aclName: String?

    public var addressIPVersion: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aclName != nil {
            map["AclName"] = self.aclName!
        }
        if self.addressIPVersion != nil {
            map["AddressIPVersion"] = self.addressIPVersion!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AclName") && dict["AclName"] != nil {
            self.aclName = dict["AclName"] as! String
        }
        if dict.keys.contains("AddressIPVersion") && dict["AddressIPVersion"] != nil {
            self.addressIPVersion = dict["AddressIPVersion"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DescribeAccessControlListsResponseBody : Tea.TeaModel {
    public class Acls : Tea.TeaModel {
        public class Acl : Tea.TeaModel {
            public var aclId: String?

            public var aclName: String?

            public var addressIPVersion: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.aclId != nil {
                    map["AclId"] = self.aclId!
                }
                if self.aclName != nil {
                    map["AclName"] = self.aclName!
                }
                if self.addressIPVersion != nil {
                    map["AddressIPVersion"] = self.addressIPVersion!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AclId") && dict["AclId"] != nil {
                    self.aclId = dict["AclId"] as! String
                }
                if dict.keys.contains("AclName") && dict["AclName"] != nil {
                    self.aclName = dict["AclName"] as! String
                }
                if dict.keys.contains("AddressIPVersion") && dict["AddressIPVersion"] != nil {
                    self.addressIPVersion = dict["AddressIPVersion"] as! String
                }
            }
        }
        public var acl: [DescribeAccessControlListsResponseBody.Acls.Acl]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.acl != nil {
                var tmp : [Any] = []
                for k in self.acl! {
                    tmp.append(k.toMap())
                }
                map["Acl"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Acl") && dict["Acl"] != nil {
                var tmp : [DescribeAccessControlListsResponseBody.Acls.Acl] = []
                for v in dict["Acl"] as! [Any] {
                    var model = DescribeAccessControlListsResponseBody.Acls.Acl()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.acl = tmp
            }
        }
    }
    public var acls: DescribeAccessControlListsResponseBody.Acls?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.acls?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acls != nil {
            map["Acls"] = self.acls?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Acls") && dict["Acls"] != nil {
            var model = DescribeAccessControlListsResponseBody.Acls()
            model.fromMap(dict["Acls"] as! [String: Any])
            self.acls = model
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeAccessControlListsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAccessControlListsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeAccessControlListsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeApiRequest : Tea.TeaModel {
    public var apiId: String?

    public var groupId: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiId") && dict["ApiId"] != nil {
            self.apiId = dict["ApiId"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DescribeApiResponseBody : Tea.TeaModel {
    public class BackendConfig : Tea.TeaModel {
        public var backendId: String?

        public var backendName: String?

        public var backendType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.backendId != nil {
                map["BackendId"] = self.backendId!
            }
            if self.backendName != nil {
                map["BackendName"] = self.backendName!
            }
            if self.backendType != nil {
                map["BackendType"] = self.backendType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BackendId") && dict["BackendId"] != nil {
                self.backendId = dict["BackendId"] as! String
            }
            if dict.keys.contains("BackendName") && dict["BackendName"] != nil {
                self.backendName = dict["BackendName"] as! String
            }
            if dict.keys.contains("BackendType") && dict["BackendType"] != nil {
                self.backendType = dict["BackendType"] as! String
            }
        }
    }
    public class ConstantParameters : Tea.TeaModel {
        public class ConstantParameter : Tea.TeaModel {
            public var constantValue: String?

            public var description_: String?

            public var location: String?

            public var serviceParameterName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.constantValue != nil {
                    map["ConstantValue"] = self.constantValue!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.location != nil {
                    map["Location"] = self.location!
                }
                if self.serviceParameterName != nil {
                    map["ServiceParameterName"] = self.serviceParameterName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ConstantValue") && dict["ConstantValue"] != nil {
                    self.constantValue = dict["ConstantValue"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Location") && dict["Location"] != nil {
                    self.location = dict["Location"] as! String
                }
                if dict.keys.contains("ServiceParameterName") && dict["ServiceParameterName"] != nil {
                    self.serviceParameterName = dict["ServiceParameterName"] as! String
                }
            }
        }
        public var constantParameter: [DescribeApiResponseBody.ConstantParameters.ConstantParameter]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.constantParameter != nil {
                var tmp : [Any] = []
                for k in self.constantParameter! {
                    tmp.append(k.toMap())
                }
                map["ConstantParameter"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConstantParameter") && dict["ConstantParameter"] != nil {
                var tmp : [DescribeApiResponseBody.ConstantParameters.ConstantParameter] = []
                for v in dict["ConstantParameter"] as! [Any] {
                    var model = DescribeApiResponseBody.ConstantParameters.ConstantParameter()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.constantParameter = tmp
            }
        }
    }
    public class CustomSystemParameters : Tea.TeaModel {
        public class CustomSystemParameter : Tea.TeaModel {
            public var demoValue: String?

            public var description_: String?

            public var location: String?

            public var parameterName: String?

            public var serviceParameterName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.demoValue != nil {
                    map["DemoValue"] = self.demoValue!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.location != nil {
                    map["Location"] = self.location!
                }
                if self.parameterName != nil {
                    map["ParameterName"] = self.parameterName!
                }
                if self.serviceParameterName != nil {
                    map["ServiceParameterName"] = self.serviceParameterName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DemoValue") && dict["DemoValue"] != nil {
                    self.demoValue = dict["DemoValue"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Location") && dict["Location"] != nil {
                    self.location = dict["Location"] as! String
                }
                if dict.keys.contains("ParameterName") && dict["ParameterName"] != nil {
                    self.parameterName = dict["ParameterName"] as! String
                }
                if dict.keys.contains("ServiceParameterName") && dict["ServiceParameterName"] != nil {
                    self.serviceParameterName = dict["ServiceParameterName"] as! String
                }
            }
        }
        public var customSystemParameter: [DescribeApiResponseBody.CustomSystemParameters.CustomSystemParameter]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.customSystemParameter != nil {
                var tmp : [Any] = []
                for k in self.customSystemParameter! {
                    tmp.append(k.toMap())
                }
                map["CustomSystemParameter"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CustomSystemParameter") && dict["CustomSystemParameter"] != nil {
                var tmp : [DescribeApiResponseBody.CustomSystemParameters.CustomSystemParameter] = []
                for v in dict["CustomSystemParameter"] as! [Any] {
                    var model = DescribeApiResponseBody.CustomSystemParameters.CustomSystemParameter()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.customSystemParameter = tmp
            }
        }
    }
    public class DeployedInfos : Tea.TeaModel {
        public class DeployedInfo : Tea.TeaModel {
            public var deployedStatus: String?

            public var effectiveVersion: String?

            public var stageName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.deployedStatus != nil {
                    map["DeployedStatus"] = self.deployedStatus!
                }
                if self.effectiveVersion != nil {
                    map["EffectiveVersion"] = self.effectiveVersion!
                }
                if self.stageName != nil {
                    map["StageName"] = self.stageName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DeployedStatus") && dict["DeployedStatus"] != nil {
                    self.deployedStatus = dict["DeployedStatus"] as! String
                }
                if dict.keys.contains("EffectiveVersion") && dict["EffectiveVersion"] != nil {
                    self.effectiveVersion = dict["EffectiveVersion"] as! String
                }
                if dict.keys.contains("StageName") && dict["StageName"] != nil {
                    self.stageName = dict["StageName"] as! String
                }
            }
        }
        public var deployedInfo: [DescribeApiResponseBody.DeployedInfos.DeployedInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.deployedInfo != nil {
                var tmp : [Any] = []
                for k in self.deployedInfo! {
                    tmp.append(k.toMap())
                }
                map["DeployedInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DeployedInfo") && dict["DeployedInfo"] != nil {
                var tmp : [DescribeApiResponseBody.DeployedInfos.DeployedInfo] = []
                for v in dict["DeployedInfo"] as! [Any] {
                    var model = DescribeApiResponseBody.DeployedInfos.DeployedInfo()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.deployedInfo = tmp
            }
        }
    }
    public class ErrorCodeSamples : Tea.TeaModel {
        public class ErrorCodeSample : Tea.TeaModel {
            public var code: String?

            public var description_: String?

            public var message: String?

            public var model: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.model != nil {
                    map["Model"] = self.model!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Code") && dict["Code"] != nil {
                    self.code = dict["Code"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Message") && dict["Message"] != nil {
                    self.message = dict["Message"] as! String
                }
                if dict.keys.contains("Model") && dict["Model"] != nil {
                    self.model = dict["Model"] as! String
                }
            }
        }
        public var errorCodeSample: [DescribeApiResponseBody.ErrorCodeSamples.ErrorCodeSample]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.errorCodeSample != nil {
                var tmp : [Any] = []
                for k in self.errorCodeSample! {
                    tmp.append(k.toMap())
                }
                map["ErrorCodeSample"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ErrorCodeSample") && dict["ErrorCodeSample"] != nil {
                var tmp : [DescribeApiResponseBody.ErrorCodeSamples.ErrorCodeSample] = []
                for v in dict["ErrorCodeSample"] as! [Any] {
                    var model = DescribeApiResponseBody.ErrorCodeSamples.ErrorCodeSample()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.errorCodeSample = tmp
            }
        }
    }
    public class OpenIdConnectConfig : Tea.TeaModel {
        public var idTokenParamName: String?

        public var openIdApiType: String?

        public var publicKey: String?

        public var publicKeyId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.idTokenParamName != nil {
                map["IdTokenParamName"] = self.idTokenParamName!
            }
            if self.openIdApiType != nil {
                map["OpenIdApiType"] = self.openIdApiType!
            }
            if self.publicKey != nil {
                map["PublicKey"] = self.publicKey!
            }
            if self.publicKeyId != nil {
                map["PublicKeyId"] = self.publicKeyId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("IdTokenParamName") && dict["IdTokenParamName"] != nil {
                self.idTokenParamName = dict["IdTokenParamName"] as! String
            }
            if dict.keys.contains("OpenIdApiType") && dict["OpenIdApiType"] != nil {
                self.openIdApiType = dict["OpenIdApiType"] as! String
            }
            if dict.keys.contains("PublicKey") && dict["PublicKey"] != nil {
                self.publicKey = dict["PublicKey"] as! String
            }
            if dict.keys.contains("PublicKeyId") && dict["PublicKeyId"] != nil {
                self.publicKeyId = dict["PublicKeyId"] as! String
            }
        }
    }
    public class RequestConfig : Tea.TeaModel {
        public var bodyFormat: String?

        public var bodyModel: String?

        public var postBodyDescription: String?

        public var requestHttpMethod: String?

        public var requestMode: String?

        public var requestPath: String?

        public var requestProtocol: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bodyFormat != nil {
                map["BodyFormat"] = self.bodyFormat!
            }
            if self.bodyModel != nil {
                map["BodyModel"] = self.bodyModel!
            }
            if self.postBodyDescription != nil {
                map["PostBodyDescription"] = self.postBodyDescription!
            }
            if self.requestHttpMethod != nil {
                map["RequestHttpMethod"] = self.requestHttpMethod!
            }
            if self.requestMode != nil {
                map["RequestMode"] = self.requestMode!
            }
            if self.requestPath != nil {
                map["RequestPath"] = self.requestPath!
            }
            if self.requestProtocol != nil {
                map["RequestProtocol"] = self.requestProtocol!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BodyFormat") && dict["BodyFormat"] != nil {
                self.bodyFormat = dict["BodyFormat"] as! String
            }
            if dict.keys.contains("BodyModel") && dict["BodyModel"] != nil {
                self.bodyModel = dict["BodyModel"] as! String
            }
            if dict.keys.contains("PostBodyDescription") && dict["PostBodyDescription"] != nil {
                self.postBodyDescription = dict["PostBodyDescription"] as! String
            }
            if dict.keys.contains("RequestHttpMethod") && dict["RequestHttpMethod"] != nil {
                self.requestHttpMethod = dict["RequestHttpMethod"] as! String
            }
            if dict.keys.contains("RequestMode") && dict["RequestMode"] != nil {
                self.requestMode = dict["RequestMode"] as! String
            }
            if dict.keys.contains("RequestPath") && dict["RequestPath"] != nil {
                self.requestPath = dict["RequestPath"] as! String
            }
            if dict.keys.contains("RequestProtocol") && dict["RequestProtocol"] != nil {
                self.requestProtocol = dict["RequestProtocol"] as! String
            }
        }
    }
    public class RequestParameters : Tea.TeaModel {
        public class RequestParameter : Tea.TeaModel {
            public var apiParameterName: String?

            public var arrayItemsType: String?

            public var defaultValue: String?

            public var demoValue: String?

            public var description_: String?

            public var docOrder: Int32?

            public var docShow: String?

            public var enumValue: String?

            public var jsonScheme: String?

            public var location: String?

            public var maxLength: Int64?

            public var maxValue: Int64?

            public var minLength: Int64?

            public var minValue: Int64?

            public var parameterType: String?

            public var regularExpression: String?

            public var required_: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.apiParameterName != nil {
                    map["ApiParameterName"] = self.apiParameterName!
                }
                if self.arrayItemsType != nil {
                    map["ArrayItemsType"] = self.arrayItemsType!
                }
                if self.defaultValue != nil {
                    map["DefaultValue"] = self.defaultValue!
                }
                if self.demoValue != nil {
                    map["DemoValue"] = self.demoValue!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.docOrder != nil {
                    map["DocOrder"] = self.docOrder!
                }
                if self.docShow != nil {
                    map["DocShow"] = self.docShow!
                }
                if self.enumValue != nil {
                    map["EnumValue"] = self.enumValue!
                }
                if self.jsonScheme != nil {
                    map["JsonScheme"] = self.jsonScheme!
                }
                if self.location != nil {
                    map["Location"] = self.location!
                }
                if self.maxLength != nil {
                    map["MaxLength"] = self.maxLength!
                }
                if self.maxValue != nil {
                    map["MaxValue"] = self.maxValue!
                }
                if self.minLength != nil {
                    map["MinLength"] = self.minLength!
                }
                if self.minValue != nil {
                    map["MinValue"] = self.minValue!
                }
                if self.parameterType != nil {
                    map["ParameterType"] = self.parameterType!
                }
                if self.regularExpression != nil {
                    map["RegularExpression"] = self.regularExpression!
                }
                if self.required_ != nil {
                    map["Required"] = self.required_!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ApiParameterName") && dict["ApiParameterName"] != nil {
                    self.apiParameterName = dict["ApiParameterName"] as! String
                }
                if dict.keys.contains("ArrayItemsType") && dict["ArrayItemsType"] != nil {
                    self.arrayItemsType = dict["ArrayItemsType"] as! String
                }
                if dict.keys.contains("DefaultValue") && dict["DefaultValue"] != nil {
                    self.defaultValue = dict["DefaultValue"] as! String
                }
                if dict.keys.contains("DemoValue") && dict["DemoValue"] != nil {
                    self.demoValue = dict["DemoValue"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("DocOrder") && dict["DocOrder"] != nil {
                    self.docOrder = dict["DocOrder"] as! Int32
                }
                if dict.keys.contains("DocShow") && dict["DocShow"] != nil {
                    self.docShow = dict["DocShow"] as! String
                }
                if dict.keys.contains("EnumValue") && dict["EnumValue"] != nil {
                    self.enumValue = dict["EnumValue"] as! String
                }
                if dict.keys.contains("JsonScheme") && dict["JsonScheme"] != nil {
                    self.jsonScheme = dict["JsonScheme"] as! String
                }
                if dict.keys.contains("Location") && dict["Location"] != nil {
                    self.location = dict["Location"] as! String
                }
                if dict.keys.contains("MaxLength") && dict["MaxLength"] != nil {
                    self.maxLength = dict["MaxLength"] as! Int64
                }
                if dict.keys.contains("MaxValue") && dict["MaxValue"] != nil {
                    self.maxValue = dict["MaxValue"] as! Int64
                }
                if dict.keys.contains("MinLength") && dict["MinLength"] != nil {
                    self.minLength = dict["MinLength"] as! Int64
                }
                if dict.keys.contains("MinValue") && dict["MinValue"] != nil {
                    self.minValue = dict["MinValue"] as! Int64
                }
                if dict.keys.contains("ParameterType") && dict["ParameterType"] != nil {
                    self.parameterType = dict["ParameterType"] as! String
                }
                if dict.keys.contains("RegularExpression") && dict["RegularExpression"] != nil {
                    self.regularExpression = dict["RegularExpression"] as! String
                }
                if dict.keys.contains("Required") && dict["Required"] != nil {
                    self.required_ = dict["Required"] as! String
                }
            }
        }
        public var requestParameter: [DescribeApiResponseBody.RequestParameters.RequestParameter]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.requestParameter != nil {
                var tmp : [Any] = []
                for k in self.requestParameter! {
                    tmp.append(k.toMap())
                }
                map["RequestParameter"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("RequestParameter") && dict["RequestParameter"] != nil {
                var tmp : [DescribeApiResponseBody.RequestParameters.RequestParameter] = []
                for v in dict["RequestParameter"] as! [Any] {
                    var model = DescribeApiResponseBody.RequestParameters.RequestParameter()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.requestParameter = tmp
            }
        }
    }
    public class ServiceConfig : Tea.TeaModel {
        public class EventBridgeConfig : Tea.TeaModel {
            public var eventBridgeRegionId: String?

            public var eventBus: String?

            public var eventSource: String?

            public var roleArn: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.eventBridgeRegionId != nil {
                    map["EventBridgeRegionId"] = self.eventBridgeRegionId!
                }
                if self.eventBus != nil {
                    map["EventBus"] = self.eventBus!
                }
                if self.eventSource != nil {
                    map["EventSource"] = self.eventSource!
                }
                if self.roleArn != nil {
                    map["RoleArn"] = self.roleArn!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EventBridgeRegionId") && dict["EventBridgeRegionId"] != nil {
                    self.eventBridgeRegionId = dict["EventBridgeRegionId"] as! String
                }
                if dict.keys.contains("EventBus") && dict["EventBus"] != nil {
                    self.eventBus = dict["EventBus"] as! String
                }
                if dict.keys.contains("EventSource") && dict["EventSource"] != nil {
                    self.eventSource = dict["EventSource"] as! String
                }
                if dict.keys.contains("RoleArn") && dict["RoleArn"] != nil {
                    self.roleArn = dict["RoleArn"] as! String
                }
            }
        }
        public class FunctionComputeConfig : Tea.TeaModel {
            public var contentTypeCatagory: String?

            public var contentTypeValue: String?

            public var fcBaseUrl: String?

            public var fcType: String?

            public var functionName: String?

            public var method: String?

            public var onlyBusinessPath: Bool?

            public var path: String?

            public var qualifier: String?

            public var regionId: String?

            public var roleArn: String?

            public var serviceName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.contentTypeCatagory != nil {
                    map["ContentTypeCatagory"] = self.contentTypeCatagory!
                }
                if self.contentTypeValue != nil {
                    map["ContentTypeValue"] = self.contentTypeValue!
                }
                if self.fcBaseUrl != nil {
                    map["FcBaseUrl"] = self.fcBaseUrl!
                }
                if self.fcType != nil {
                    map["FcType"] = self.fcType!
                }
                if self.functionName != nil {
                    map["FunctionName"] = self.functionName!
                }
                if self.method != nil {
                    map["Method"] = self.method!
                }
                if self.onlyBusinessPath != nil {
                    map["OnlyBusinessPath"] = self.onlyBusinessPath!
                }
                if self.path != nil {
                    map["Path"] = self.path!
                }
                if self.qualifier != nil {
                    map["Qualifier"] = self.qualifier!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.roleArn != nil {
                    map["RoleArn"] = self.roleArn!
                }
                if self.serviceName != nil {
                    map["ServiceName"] = self.serviceName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ContentTypeCatagory") && dict["ContentTypeCatagory"] != nil {
                    self.contentTypeCatagory = dict["ContentTypeCatagory"] as! String
                }
                if dict.keys.contains("ContentTypeValue") && dict["ContentTypeValue"] != nil {
                    self.contentTypeValue = dict["ContentTypeValue"] as! String
                }
                if dict.keys.contains("FcBaseUrl") && dict["FcBaseUrl"] != nil {
                    self.fcBaseUrl = dict["FcBaseUrl"] as! String
                }
                if dict.keys.contains("FcType") && dict["FcType"] != nil {
                    self.fcType = dict["FcType"] as! String
                }
                if dict.keys.contains("FunctionName") && dict["FunctionName"] != nil {
                    self.functionName = dict["FunctionName"] as! String
                }
                if dict.keys.contains("Method") && dict["Method"] != nil {
                    self.method = dict["Method"] as! String
                }
                if dict.keys.contains("OnlyBusinessPath") && dict["OnlyBusinessPath"] != nil {
                    self.onlyBusinessPath = dict["OnlyBusinessPath"] as! Bool
                }
                if dict.keys.contains("Path") && dict["Path"] != nil {
                    self.path = dict["Path"] as! String
                }
                if dict.keys.contains("Qualifier") && dict["Qualifier"] != nil {
                    self.qualifier = dict["Qualifier"] as! String
                }
                if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("RoleArn") && dict["RoleArn"] != nil {
                    self.roleArn = dict["RoleArn"] as! String
                }
                if dict.keys.contains("ServiceName") && dict["ServiceName"] != nil {
                    self.serviceName = dict["ServiceName"] as! String
                }
            }
        }
        public class MockHeaders : Tea.TeaModel {
            public class MockHeader : Tea.TeaModel {
                public var headerName: String?

                public var headerValue: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.headerName != nil {
                        map["HeaderName"] = self.headerName!
                    }
                    if self.headerValue != nil {
                        map["HeaderValue"] = self.headerValue!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("HeaderName") && dict["HeaderName"] != nil {
                        self.headerName = dict["HeaderName"] as! String
                    }
                    if dict.keys.contains("HeaderValue") && dict["HeaderValue"] != nil {
                        self.headerValue = dict["HeaderValue"] as! String
                    }
                }
            }
            public var mockHeader: [DescribeApiResponseBody.ServiceConfig.MockHeaders.MockHeader]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.mockHeader != nil {
                    var tmp : [Any] = []
                    for k in self.mockHeader! {
                        tmp.append(k.toMap())
                    }
                    map["MockHeader"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("MockHeader") && dict["MockHeader"] != nil {
                    var tmp : [DescribeApiResponseBody.ServiceConfig.MockHeaders.MockHeader] = []
                    for v in dict["MockHeader"] as! [Any] {
                        var model = DescribeApiResponseBody.ServiceConfig.MockHeaders.MockHeader()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.mockHeader = tmp
                }
            }
        }
        public class OssConfig : Tea.TeaModel {
            public var action: String?

            public var bucketName: String?

            public var key: String?

            public var ossRegionId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.action != nil {
                    map["Action"] = self.action!
                }
                if self.bucketName != nil {
                    map["BucketName"] = self.bucketName!
                }
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.ossRegionId != nil {
                    map["OssRegionId"] = self.ossRegionId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Action") && dict["Action"] != nil {
                    self.action = dict["Action"] as! String
                }
                if dict.keys.contains("BucketName") && dict["BucketName"] != nil {
                    self.bucketName = dict["BucketName"] as! String
                }
                if dict.keys.contains("Key") && dict["Key"] != nil {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("OssRegionId") && dict["OssRegionId"] != nil {
                    self.ossRegionId = dict["OssRegionId"] as! String
                }
            }
        }
        public class VpcConfig : Tea.TeaModel {
            public var instanceId: String?

            public var name: String?

            public var port: Int32?

            public var vpcId: String?

            public var vpcScheme: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                if self.vpcScheme != nil {
                    map["VpcScheme"] = self.vpcScheme!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Port") && dict["Port"] != nil {
                    self.port = dict["Port"] as! Int32
                }
                if dict.keys.contains("VpcId") && dict["VpcId"] != nil {
                    self.vpcId = dict["VpcId"] as! String
                }
                if dict.keys.contains("VpcScheme") && dict["VpcScheme"] != nil {
                    self.vpcScheme = dict["VpcScheme"] as! String
                }
            }
        }
        public var aoneAppName: String?

        public var contentTypeCatagory: String?

        public var contentTypeValue: String?

        public var eventBridgeConfig: DescribeApiResponseBody.ServiceConfig.EventBridgeConfig?

        public var functionComputeConfig: DescribeApiResponseBody.ServiceConfig.FunctionComputeConfig?

        public var mock: String?

        public var mockHeaders: DescribeApiResponseBody.ServiceConfig.MockHeaders?

        public var mockResult: String?

        public var mockStatusCode: Int32?

        public var ossConfig: DescribeApiResponseBody.ServiceConfig.OssConfig?

        public var serviceAddress: String?

        public var serviceHttpMethod: String?

        public var servicePath: String?

        public var serviceProtocol: String?

        public var serviceTimeout: Int32?

        public var serviceVpcEnable: String?

        public var vpcConfig: DescribeApiResponseBody.ServiceConfig.VpcConfig?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.eventBridgeConfig?.validate()
            try self.functionComputeConfig?.validate()
            try self.mockHeaders?.validate()
            try self.ossConfig?.validate()
            try self.vpcConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aoneAppName != nil {
                map["AoneAppName"] = self.aoneAppName!
            }
            if self.contentTypeCatagory != nil {
                map["ContentTypeCatagory"] = self.contentTypeCatagory!
            }
            if self.contentTypeValue != nil {
                map["ContentTypeValue"] = self.contentTypeValue!
            }
            if self.eventBridgeConfig != nil {
                map["EventBridgeConfig"] = self.eventBridgeConfig?.toMap()
            }
            if self.functionComputeConfig != nil {
                map["FunctionComputeConfig"] = self.functionComputeConfig?.toMap()
            }
            if self.mock != nil {
                map["Mock"] = self.mock!
            }
            if self.mockHeaders != nil {
                map["MockHeaders"] = self.mockHeaders?.toMap()
            }
            if self.mockResult != nil {
                map["MockResult"] = self.mockResult!
            }
            if self.mockStatusCode != nil {
                map["MockStatusCode"] = self.mockStatusCode!
            }
            if self.ossConfig != nil {
                map["OssConfig"] = self.ossConfig?.toMap()
            }
            if self.serviceAddress != nil {
                map["ServiceAddress"] = self.serviceAddress!
            }
            if self.serviceHttpMethod != nil {
                map["ServiceHttpMethod"] = self.serviceHttpMethod!
            }
            if self.servicePath != nil {
                map["ServicePath"] = self.servicePath!
            }
            if self.serviceProtocol != nil {
                map["ServiceProtocol"] = self.serviceProtocol!
            }
            if self.serviceTimeout != nil {
                map["ServiceTimeout"] = self.serviceTimeout!
            }
            if self.serviceVpcEnable != nil {
                map["ServiceVpcEnable"] = self.serviceVpcEnable!
            }
            if self.vpcConfig != nil {
                map["VpcConfig"] = self.vpcConfig?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AoneAppName") && dict["AoneAppName"] != nil {
                self.aoneAppName = dict["AoneAppName"] as! String
            }
            if dict.keys.contains("ContentTypeCatagory") && dict["ContentTypeCatagory"] != nil {
                self.contentTypeCatagory = dict["ContentTypeCatagory"] as! String
            }
            if dict.keys.contains("ContentTypeValue") && dict["ContentTypeValue"] != nil {
                self.contentTypeValue = dict["ContentTypeValue"] as! String
            }
            if dict.keys.contains("EventBridgeConfig") && dict["EventBridgeConfig"] != nil {
                var model = DescribeApiResponseBody.ServiceConfig.EventBridgeConfig()
                model.fromMap(dict["EventBridgeConfig"] as! [String: Any])
                self.eventBridgeConfig = model
            }
            if dict.keys.contains("FunctionComputeConfig") && dict["FunctionComputeConfig"] != nil {
                var model = DescribeApiResponseBody.ServiceConfig.FunctionComputeConfig()
                model.fromMap(dict["FunctionComputeConfig"] as! [String: Any])
                self.functionComputeConfig = model
            }
            if dict.keys.contains("Mock") && dict["Mock"] != nil {
                self.mock = dict["Mock"] as! String
            }
            if dict.keys.contains("MockHeaders") && dict["MockHeaders"] != nil {
                var model = DescribeApiResponseBody.ServiceConfig.MockHeaders()
                model.fromMap(dict["MockHeaders"] as! [String: Any])
                self.mockHeaders = model
            }
            if dict.keys.contains("MockResult") && dict["MockResult"] != nil {
                self.mockResult = dict["MockResult"] as! String
            }
            if dict.keys.contains("MockStatusCode") && dict["MockStatusCode"] != nil {
                self.mockStatusCode = dict["MockStatusCode"] as! Int32
            }
            if dict.keys.contains("OssConfig") && dict["OssConfig"] != nil {
                var model = DescribeApiResponseBody.ServiceConfig.OssConfig()
                model.fromMap(dict["OssConfig"] as! [String: Any])
                self.ossConfig = model
            }
            if dict.keys.contains("ServiceAddress") && dict["ServiceAddress"] != nil {
                self.serviceAddress = dict["ServiceAddress"] as! String
            }
            if dict.keys.contains("ServiceHttpMethod") && dict["ServiceHttpMethod"] != nil {
                self.serviceHttpMethod = dict["ServiceHttpMethod"] as! String
            }
            if dict.keys.contains("ServicePath") && dict["ServicePath"] != nil {
                self.servicePath = dict["ServicePath"] as! String
            }
            if dict.keys.contains("ServiceProtocol") && dict["ServiceProtocol"] != nil {
                self.serviceProtocol = dict["ServiceProtocol"] as! String
            }
            if dict.keys.contains("ServiceTimeout") && dict["ServiceTimeout"] != nil {
                self.serviceTimeout = dict["ServiceTimeout"] as! Int32
            }
            if dict.keys.contains("ServiceVpcEnable") && dict["ServiceVpcEnable"] != nil {
                self.serviceVpcEnable = dict["ServiceVpcEnable"] as! String
            }
            if dict.keys.contains("VpcConfig") && dict["VpcConfig"] != nil {
                var model = DescribeApiResponseBody.ServiceConfig.VpcConfig()
                model.fromMap(dict["VpcConfig"] as! [String: Any])
                self.vpcConfig = model
            }
        }
    }
    public class ServiceParameters : Tea.TeaModel {
        public class ServiceParameter : Tea.TeaModel {
            public var location: String?

            public var parameterType: String?

            public var serviceParameterName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.location != nil {
                    map["Location"] = self.location!
                }
                if self.parameterType != nil {
                    map["ParameterType"] = self.parameterType!
                }
                if self.serviceParameterName != nil {
                    map["ServiceParameterName"] = self.serviceParameterName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Location") && dict["Location"] != nil {
                    self.location = dict["Location"] as! String
                }
                if dict.keys.contains("ParameterType") && dict["ParameterType"] != nil {
                    self.parameterType = dict["ParameterType"] as! String
                }
                if dict.keys.contains("ServiceParameterName") && dict["ServiceParameterName"] != nil {
                    self.serviceParameterName = dict["ServiceParameterName"] as! String
                }
            }
        }
        public var serviceParameter: [DescribeApiResponseBody.ServiceParameters.ServiceParameter]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.serviceParameter != nil {
                var tmp : [Any] = []
                for k in self.serviceParameter! {
                    tmp.append(k.toMap())
                }
                map["ServiceParameter"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ServiceParameter") && dict["ServiceParameter"] != nil {
                var tmp : [DescribeApiResponseBody.ServiceParameters.ServiceParameter] = []
                for v in dict["ServiceParameter"] as! [Any] {
                    var model = DescribeApiResponseBody.ServiceParameters.ServiceParameter()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.serviceParameter = tmp
            }
        }
    }
    public class ServiceParametersMap : Tea.TeaModel {
        public class ServiceParameterMap : Tea.TeaModel {
            public var requestParameterName: String?

            public var serviceParameterName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.requestParameterName != nil {
                    map["RequestParameterName"] = self.requestParameterName!
                }
                if self.serviceParameterName != nil {
                    map["ServiceParameterName"] = self.serviceParameterName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("RequestParameterName") && dict["RequestParameterName"] != nil {
                    self.requestParameterName = dict["RequestParameterName"] as! String
                }
                if dict.keys.contains("ServiceParameterName") && dict["ServiceParameterName"] != nil {
                    self.serviceParameterName = dict["ServiceParameterName"] as! String
                }
            }
        }
        public var serviceParameterMap: [DescribeApiResponseBody.ServiceParametersMap.ServiceParameterMap]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.serviceParameterMap != nil {
                var tmp : [Any] = []
                for k in self.serviceParameterMap! {
                    tmp.append(k.toMap())
                }
                map["ServiceParameterMap"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ServiceParameterMap") && dict["ServiceParameterMap"] != nil {
                var tmp : [DescribeApiResponseBody.ServiceParametersMap.ServiceParameterMap] = []
                for v in dict["ServiceParameterMap"] as! [Any] {
                    var model = DescribeApiResponseBody.ServiceParametersMap.ServiceParameterMap()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.serviceParameterMap = tmp
            }
        }
    }
    public class SystemParameters : Tea.TeaModel {
        public class SystemParameter : Tea.TeaModel {
            public var demoValue: String?

            public var description_: String?

            public var location: String?

            public var parameterName: String?

            public var serviceParameterName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.demoValue != nil {
                    map["DemoValue"] = self.demoValue!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.location != nil {
                    map["Location"] = self.location!
                }
                if self.parameterName != nil {
                    map["ParameterName"] = self.parameterName!
                }
                if self.serviceParameterName != nil {
                    map["ServiceParameterName"] = self.serviceParameterName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DemoValue") && dict["DemoValue"] != nil {
                    self.demoValue = dict["DemoValue"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Location") && dict["Location"] != nil {
                    self.location = dict["Location"] as! String
                }
                if dict.keys.contains("ParameterName") && dict["ParameterName"] != nil {
                    self.parameterName = dict["ParameterName"] as! String
                }
                if dict.keys.contains("ServiceParameterName") && dict["ServiceParameterName"] != nil {
                    self.serviceParameterName = dict["ServiceParameterName"] as! String
                }
            }
        }
        public var systemParameter: [DescribeApiResponseBody.SystemParameters.SystemParameter]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.systemParameter != nil {
                var tmp : [Any] = []
                for k in self.systemParameter! {
                    tmp.append(k.toMap())
                }
                map["SystemParameter"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SystemParameter") && dict["SystemParameter"] != nil {
                var tmp : [DescribeApiResponseBody.SystemParameters.SystemParameter] = []
                for v in dict["SystemParameter"] as! [Any] {
                    var model = DescribeApiResponseBody.SystemParameters.SystemParameter()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.systemParameter = tmp
            }
        }
    }
    public class TagList : Tea.TeaModel {
        public class Tag : Tea.TeaModel {
            public var tagKey: String?

            public var tagValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.tagKey != nil {
                    map["TagKey"] = self.tagKey!
                }
                if self.tagValue != nil {
                    map["TagValue"] = self.tagValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("TagKey") && dict["TagKey"] != nil {
                    self.tagKey = dict["TagKey"] as! String
                }
                if dict.keys.contains("TagValue") && dict["TagValue"] != nil {
                    self.tagValue = dict["TagValue"] as! String
                }
            }
        }
        public var tag: [DescribeApiResponseBody.TagList.Tag]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tag != nil {
                var tmp : [Any] = []
                for k in self.tag! {
                    tmp.append(k.toMap())
                }
                map["Tag"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Tag") && dict["Tag"] != nil {
                var tmp : [DescribeApiResponseBody.TagList.Tag] = []
                for v in dict["Tag"] as! [Any] {
                    var model = DescribeApiResponseBody.TagList.Tag()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tag = tmp
            }
        }
    }
    public var allowSignatureMethod: String?

    public var apiId: String?

    public var apiName: String?

    public var appCodeAuthType: String?

    public var authType: String?

    public var backendConfig: DescribeApiResponseBody.BackendConfig?

    public var backendEnable: Bool?

    public var constantParameters: DescribeApiResponseBody.ConstantParameters?

    public var createdTime: String?

    public var customSystemParameters: DescribeApiResponseBody.CustomSystemParameters?

    public var deployedInfos: DescribeApiResponseBody.DeployedInfos?

    public var description_: String?

    public var disableInternet: Bool?

    public var errorCodeSamples: DescribeApiResponseBody.ErrorCodeSamples?

    public var failResultSample: String?

    public var forceNonceCheck: Bool?

    public var groupId: String?

    public var groupName: String?

    public var mock: String?

    public var mockResult: String?

    public var modifiedTime: String?

    public var openIdConnectConfig: DescribeApiResponseBody.OpenIdConnectConfig?

    public var regionId: String?

    public var requestConfig: DescribeApiResponseBody.RequestConfig?

    public var requestId: String?

    public var requestParameters: DescribeApiResponseBody.RequestParameters?

    public var resultBodyModel: String?

    public var resultSample: String?

    public var resultType: String?

    public var serviceConfig: DescribeApiResponseBody.ServiceConfig?

    public var serviceParameters: DescribeApiResponseBody.ServiceParameters?

    public var serviceParametersMap: DescribeApiResponseBody.ServiceParametersMap?

    public var systemParameters: DescribeApiResponseBody.SystemParameters?

    public var tagList: DescribeApiResponseBody.TagList?

    public var visibility: String?

    public var webSocketApiType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.backendConfig?.validate()
        try self.constantParameters?.validate()
        try self.customSystemParameters?.validate()
        try self.deployedInfos?.validate()
        try self.errorCodeSamples?.validate()
        try self.openIdConnectConfig?.validate()
        try self.requestConfig?.validate()
        try self.requestParameters?.validate()
        try self.serviceConfig?.validate()
        try self.serviceParameters?.validate()
        try self.serviceParametersMap?.validate()
        try self.systemParameters?.validate()
        try self.tagList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.allowSignatureMethod != nil {
            map["AllowSignatureMethod"] = self.allowSignatureMethod!
        }
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.apiName != nil {
            map["ApiName"] = self.apiName!
        }
        if self.appCodeAuthType != nil {
            map["AppCodeAuthType"] = self.appCodeAuthType!
        }
        if self.authType != nil {
            map["AuthType"] = self.authType!
        }
        if self.backendConfig != nil {
            map["BackendConfig"] = self.backendConfig?.toMap()
        }
        if self.backendEnable != nil {
            map["BackendEnable"] = self.backendEnable!
        }
        if self.constantParameters != nil {
            map["ConstantParameters"] = self.constantParameters?.toMap()
        }
        if self.createdTime != nil {
            map["CreatedTime"] = self.createdTime!
        }
        if self.customSystemParameters != nil {
            map["CustomSystemParameters"] = self.customSystemParameters?.toMap()
        }
        if self.deployedInfos != nil {
            map["DeployedInfos"] = self.deployedInfos?.toMap()
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.disableInternet != nil {
            map["DisableInternet"] = self.disableInternet!
        }
        if self.errorCodeSamples != nil {
            map["ErrorCodeSamples"] = self.errorCodeSamples?.toMap()
        }
        if self.failResultSample != nil {
            map["FailResultSample"] = self.failResultSample!
        }
        if self.forceNonceCheck != nil {
            map["ForceNonceCheck"] = self.forceNonceCheck!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.mock != nil {
            map["Mock"] = self.mock!
        }
        if self.mockResult != nil {
            map["MockResult"] = self.mockResult!
        }
        if self.modifiedTime != nil {
            map["ModifiedTime"] = self.modifiedTime!
        }
        if self.openIdConnectConfig != nil {
            map["OpenIdConnectConfig"] = self.openIdConnectConfig?.toMap()
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestConfig != nil {
            map["RequestConfig"] = self.requestConfig?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.requestParameters != nil {
            map["RequestParameters"] = self.requestParameters?.toMap()
        }
        if self.resultBodyModel != nil {
            map["ResultBodyModel"] = self.resultBodyModel!
        }
        if self.resultSample != nil {
            map["ResultSample"] = self.resultSample!
        }
        if self.resultType != nil {
            map["ResultType"] = self.resultType!
        }
        if self.serviceConfig != nil {
            map["ServiceConfig"] = self.serviceConfig?.toMap()
        }
        if self.serviceParameters != nil {
            map["ServiceParameters"] = self.serviceParameters?.toMap()
        }
        if self.serviceParametersMap != nil {
            map["ServiceParametersMap"] = self.serviceParametersMap?.toMap()
        }
        if self.systemParameters != nil {
            map["SystemParameters"] = self.systemParameters?.toMap()
        }
        if self.tagList != nil {
            map["TagList"] = self.tagList?.toMap()
        }
        if self.visibility != nil {
            map["Visibility"] = self.visibility!
        }
        if self.webSocketApiType != nil {
            map["WebSocketApiType"] = self.webSocketApiType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AllowSignatureMethod") && dict["AllowSignatureMethod"] != nil {
            self.allowSignatureMethod = dict["AllowSignatureMethod"] as! String
        }
        if dict.keys.contains("ApiId") && dict["ApiId"] != nil {
            self.apiId = dict["ApiId"] as! String
        }
        if dict.keys.contains("ApiName") && dict["ApiName"] != nil {
            self.apiName = dict["ApiName"] as! String
        }
        if dict.keys.contains("AppCodeAuthType") && dict["AppCodeAuthType"] != nil {
            self.appCodeAuthType = dict["AppCodeAuthType"] as! String
        }
        if dict.keys.contains("AuthType") && dict["AuthType"] != nil {
            self.authType = dict["AuthType"] as! String
        }
        if dict.keys.contains("BackendConfig") && dict["BackendConfig"] != nil {
            var model = DescribeApiResponseBody.BackendConfig()
            model.fromMap(dict["BackendConfig"] as! [String: Any])
            self.backendConfig = model
        }
        if dict.keys.contains("BackendEnable") && dict["BackendEnable"] != nil {
            self.backendEnable = dict["BackendEnable"] as! Bool
        }
        if dict.keys.contains("ConstantParameters") && dict["ConstantParameters"] != nil {
            var model = DescribeApiResponseBody.ConstantParameters()
            model.fromMap(dict["ConstantParameters"] as! [String: Any])
            self.constantParameters = model
        }
        if dict.keys.contains("CreatedTime") && dict["CreatedTime"] != nil {
            self.createdTime = dict["CreatedTime"] as! String
        }
        if dict.keys.contains("CustomSystemParameters") && dict["CustomSystemParameters"] != nil {
            var model = DescribeApiResponseBody.CustomSystemParameters()
            model.fromMap(dict["CustomSystemParameters"] as! [String: Any])
            self.customSystemParameters = model
        }
        if dict.keys.contains("DeployedInfos") && dict["DeployedInfos"] != nil {
            var model = DescribeApiResponseBody.DeployedInfos()
            model.fromMap(dict["DeployedInfos"] as! [String: Any])
            self.deployedInfos = model
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DisableInternet") && dict["DisableInternet"] != nil {
            self.disableInternet = dict["DisableInternet"] as! Bool
        }
        if dict.keys.contains("ErrorCodeSamples") && dict["ErrorCodeSamples"] != nil {
            var model = DescribeApiResponseBody.ErrorCodeSamples()
            model.fromMap(dict["ErrorCodeSamples"] as! [String: Any])
            self.errorCodeSamples = model
        }
        if dict.keys.contains("FailResultSample") && dict["FailResultSample"] != nil {
            self.failResultSample = dict["FailResultSample"] as! String
        }
        if dict.keys.contains("ForceNonceCheck") && dict["ForceNonceCheck"] != nil {
            self.forceNonceCheck = dict["ForceNonceCheck"] as! Bool
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("Mock") && dict["Mock"] != nil {
            self.mock = dict["Mock"] as! String
        }
        if dict.keys.contains("MockResult") && dict["MockResult"] != nil {
            self.mockResult = dict["MockResult"] as! String
        }
        if dict.keys.contains("ModifiedTime") && dict["ModifiedTime"] != nil {
            self.modifiedTime = dict["ModifiedTime"] as! String
        }
        if dict.keys.contains("OpenIdConnectConfig") && dict["OpenIdConnectConfig"] != nil {
            var model = DescribeApiResponseBody.OpenIdConnectConfig()
            model.fromMap(dict["OpenIdConnectConfig"] as! [String: Any])
            self.openIdConnectConfig = model
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RequestConfig") && dict["RequestConfig"] != nil {
            var model = DescribeApiResponseBody.RequestConfig()
            model.fromMap(dict["RequestConfig"] as! [String: Any])
            self.requestConfig = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RequestParameters") && dict["RequestParameters"] != nil {
            var model = DescribeApiResponseBody.RequestParameters()
            model.fromMap(dict["RequestParameters"] as! [String: Any])
            self.requestParameters = model
        }
        if dict.keys.contains("ResultBodyModel") && dict["ResultBodyModel"] != nil {
            self.resultBodyModel = dict["ResultBodyModel"] as! String
        }
        if dict.keys.contains("ResultSample") && dict["ResultSample"] != nil {
            self.resultSample = dict["ResultSample"] as! String
        }
        if dict.keys.contains("ResultType") && dict["ResultType"] != nil {
            self.resultType = dict["ResultType"] as! String
        }
        if dict.keys.contains("ServiceConfig") && dict["ServiceConfig"] != nil {
            var model = DescribeApiResponseBody.ServiceConfig()
            model.fromMap(dict["ServiceConfig"] as! [String: Any])
            self.serviceConfig = model
        }
        if dict.keys.contains("ServiceParameters") && dict["ServiceParameters"] != nil {
            var model = DescribeApiResponseBody.ServiceParameters()
            model.fromMap(dict["ServiceParameters"] as! [String: Any])
            self.serviceParameters = model
        }
        if dict.keys.contains("ServiceParametersMap") && dict["ServiceParametersMap"] != nil {
            var model = DescribeApiResponseBody.ServiceParametersMap()
            model.fromMap(dict["ServiceParametersMap"] as! [String: Any])
            self.serviceParametersMap = model
        }
        if dict.keys.contains("SystemParameters") && dict["SystemParameters"] != nil {
            var model = DescribeApiResponseBody.SystemParameters()
            model.fromMap(dict["SystemParameters"] as! [String: Any])
            self.systemParameters = model
        }
        if dict.keys.contains("TagList") && dict["TagList"] != nil {
            var model = DescribeApiResponseBody.TagList()
            model.fromMap(dict["TagList"] as! [String: Any])
            self.tagList = model
        }
        if dict.keys.contains("Visibility") && dict["Visibility"] != nil {
            self.visibility = dict["Visibility"] as! String
        }
        if dict.keys.contains("WebSocketApiType") && dict["WebSocketApiType"] != nil {
            self.webSocketApiType = dict["WebSocketApiType"] as! String
        }
    }
}

public class DescribeApiResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeApiResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeApiResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeApiDocRequest : Tea.TeaModel {
    public var apiId: String?

    public var groupId: String?

    public var securityToken: String?

    public var stageName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.stageName != nil {
            map["StageName"] = self.stageName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiId") && dict["ApiId"] != nil {
            self.apiId = dict["ApiId"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StageName") && dict["StageName"] != nil {
            self.stageName = dict["StageName"] as! String
        }
    }
}

public class DescribeApiDocResponseBody : Tea.TeaModel {
    public class ErrorCodeSamples : Tea.TeaModel {
        public class ErrorCodeSample : Tea.TeaModel {
            public var code: String?

            public var description_: String?

            public var message: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Code") && dict["Code"] != nil {
                    self.code = dict["Code"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Message") && dict["Message"] != nil {
                    self.message = dict["Message"] as! String
                }
            }
        }
        public var errorCodeSample: [DescribeApiDocResponseBody.ErrorCodeSamples.ErrorCodeSample]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.errorCodeSample != nil {
                var tmp : [Any] = []
                for k in self.errorCodeSample! {
                    tmp.append(k.toMap())
                }
                map["ErrorCodeSample"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ErrorCodeSample") && dict["ErrorCodeSample"] != nil {
                var tmp : [DescribeApiDocResponseBody.ErrorCodeSamples.ErrorCodeSample] = []
                for v in dict["ErrorCodeSample"] as! [Any] {
                    var model = DescribeApiDocResponseBody.ErrorCodeSamples.ErrorCodeSample()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.errorCodeSample = tmp
            }
        }
    }
    public class RequestConfig : Tea.TeaModel {
        public var bodyFormat: String?

        public var postBodyDescription: String?

        public var requestHttpMethod: String?

        public var requestMode: String?

        public var requestPath: String?

        public var requestProtocol: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bodyFormat != nil {
                map["BodyFormat"] = self.bodyFormat!
            }
            if self.postBodyDescription != nil {
                map["PostBodyDescription"] = self.postBodyDescription!
            }
            if self.requestHttpMethod != nil {
                map["RequestHttpMethod"] = self.requestHttpMethod!
            }
            if self.requestMode != nil {
                map["RequestMode"] = self.requestMode!
            }
            if self.requestPath != nil {
                map["RequestPath"] = self.requestPath!
            }
            if self.requestProtocol != nil {
                map["RequestProtocol"] = self.requestProtocol!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BodyFormat") && dict["BodyFormat"] != nil {
                self.bodyFormat = dict["BodyFormat"] as! String
            }
            if dict.keys.contains("PostBodyDescription") && dict["PostBodyDescription"] != nil {
                self.postBodyDescription = dict["PostBodyDescription"] as! String
            }
            if dict.keys.contains("RequestHttpMethod") && dict["RequestHttpMethod"] != nil {
                self.requestHttpMethod = dict["RequestHttpMethod"] as! String
            }
            if dict.keys.contains("RequestMode") && dict["RequestMode"] != nil {
                self.requestMode = dict["RequestMode"] as! String
            }
            if dict.keys.contains("RequestPath") && dict["RequestPath"] != nil {
                self.requestPath = dict["RequestPath"] as! String
            }
            if dict.keys.contains("RequestProtocol") && dict["RequestProtocol"] != nil {
                self.requestProtocol = dict["RequestProtocol"] as! String
            }
        }
    }
    public class RequestParameters : Tea.TeaModel {
        public class RequestParameter : Tea.TeaModel {
            public var apiParameterName: String?

            public var arrayItemsType: String?

            public var defaultValue: String?

            public var demoValue: String?

            public var description_: String?

            public var docOrder: Int32?

            public var docShow: String?

            public var enumValue: String?

            public var jsonScheme: String?

            public var location: String?

            public var maxLength: Int64?

            public var maxValue: Int64?

            public var minLength: Int64?

            public var minValue: Int64?

            public var parameterType: String?

            public var regularExpression: String?

            public var required_: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.apiParameterName != nil {
                    map["ApiParameterName"] = self.apiParameterName!
                }
                if self.arrayItemsType != nil {
                    map["ArrayItemsType"] = self.arrayItemsType!
                }
                if self.defaultValue != nil {
                    map["DefaultValue"] = self.defaultValue!
                }
                if self.demoValue != nil {
                    map["DemoValue"] = self.demoValue!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.docOrder != nil {
                    map["DocOrder"] = self.docOrder!
                }
                if self.docShow != nil {
                    map["DocShow"] = self.docShow!
                }
                if self.enumValue != nil {
                    map["EnumValue"] = self.enumValue!
                }
                if self.jsonScheme != nil {
                    map["JsonScheme"] = self.jsonScheme!
                }
                if self.location != nil {
                    map["Location"] = self.location!
                }
                if self.maxLength != nil {
                    map["MaxLength"] = self.maxLength!
                }
                if self.maxValue != nil {
                    map["MaxValue"] = self.maxValue!
                }
                if self.minLength != nil {
                    map["MinLength"] = self.minLength!
                }
                if self.minValue != nil {
                    map["MinValue"] = self.minValue!
                }
                if self.parameterType != nil {
                    map["ParameterType"] = self.parameterType!
                }
                if self.regularExpression != nil {
                    map["RegularExpression"] = self.regularExpression!
                }
                if self.required_ != nil {
                    map["Required"] = self.required_!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ApiParameterName") && dict["ApiParameterName"] != nil {
                    self.apiParameterName = dict["ApiParameterName"] as! String
                }
                if dict.keys.contains("ArrayItemsType") && dict["ArrayItemsType"] != nil {
                    self.arrayItemsType = dict["ArrayItemsType"] as! String
                }
                if dict.keys.contains("DefaultValue") && dict["DefaultValue"] != nil {
                    self.defaultValue = dict["DefaultValue"] as! String
                }
                if dict.keys.contains("DemoValue") && dict["DemoValue"] != nil {
                    self.demoValue = dict["DemoValue"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("DocOrder") && dict["DocOrder"] != nil {
                    self.docOrder = dict["DocOrder"] as! Int32
                }
                if dict.keys.contains("DocShow") && dict["DocShow"] != nil {
                    self.docShow = dict["DocShow"] as! String
                }
                if dict.keys.contains("EnumValue") && dict["EnumValue"] != nil {
                    self.enumValue = dict["EnumValue"] as! String
                }
                if dict.keys.contains("JsonScheme") && dict["JsonScheme"] != nil {
                    self.jsonScheme = dict["JsonScheme"] as! String
                }
                if dict.keys.contains("Location") && dict["Location"] != nil {
                    self.location = dict["Location"] as! String
                }
                if dict.keys.contains("MaxLength") && dict["MaxLength"] != nil {
                    self.maxLength = dict["MaxLength"] as! Int64
                }
                if dict.keys.contains("MaxValue") && dict["MaxValue"] != nil {
                    self.maxValue = dict["MaxValue"] as! Int64
                }
                if dict.keys.contains("MinLength") && dict["MinLength"] != nil {
                    self.minLength = dict["MinLength"] as! Int64
                }
                if dict.keys.contains("MinValue") && dict["MinValue"] != nil {
                    self.minValue = dict["MinValue"] as! Int64
                }
                if dict.keys.contains("ParameterType") && dict["ParameterType"] != nil {
                    self.parameterType = dict["ParameterType"] as! String
                }
                if dict.keys.contains("RegularExpression") && dict["RegularExpression"] != nil {
                    self.regularExpression = dict["RegularExpression"] as! String
                }
                if dict.keys.contains("Required") && dict["Required"] != nil {
                    self.required_ = dict["Required"] as! String
                }
            }
        }
        public var requestParameter: [DescribeApiDocResponseBody.RequestParameters.RequestParameter]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.requestParameter != nil {
                var tmp : [Any] = []
                for k in self.requestParameter! {
                    tmp.append(k.toMap())
                }
                map["RequestParameter"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("RequestParameter") && dict["RequestParameter"] != nil {
                var tmp : [DescribeApiDocResponseBody.RequestParameters.RequestParameter] = []
                for v in dict["RequestParameter"] as! [Any] {
                    var model = DescribeApiDocResponseBody.RequestParameters.RequestParameter()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.requestParameter = tmp
            }
        }
    }
    public var apiId: String?

    public var apiName: String?

    public var authType: String?

    public var deployedTime: String?

    public var description_: String?

    public var disableInternet: Bool?

    public var errorCodeSamples: DescribeApiDocResponseBody.ErrorCodeSamples?

    public var failResultSample: String?

    public var forceNonceCheck: Bool?

    public var groupId: String?

    public var groupName: String?

    public var regionId: String?

    public var requestConfig: DescribeApiDocResponseBody.RequestConfig?

    public var requestId: String?

    public var requestParameters: DescribeApiDocResponseBody.RequestParameters?

    public var resultSample: String?

    public var resultType: String?

    public var stageName: String?

    public var visibility: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.errorCodeSamples?.validate()
        try self.requestConfig?.validate()
        try self.requestParameters?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.apiName != nil {
            map["ApiName"] = self.apiName!
        }
        if self.authType != nil {
            map["AuthType"] = self.authType!
        }
        if self.deployedTime != nil {
            map["DeployedTime"] = self.deployedTime!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.disableInternet != nil {
            map["DisableInternet"] = self.disableInternet!
        }
        if self.errorCodeSamples != nil {
            map["ErrorCodeSamples"] = self.errorCodeSamples?.toMap()
        }
        if self.failResultSample != nil {
            map["FailResultSample"] = self.failResultSample!
        }
        if self.forceNonceCheck != nil {
            map["ForceNonceCheck"] = self.forceNonceCheck!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestConfig != nil {
            map["RequestConfig"] = self.requestConfig?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.requestParameters != nil {
            map["RequestParameters"] = self.requestParameters?.toMap()
        }
        if self.resultSample != nil {
            map["ResultSample"] = self.resultSample!
        }
        if self.resultType != nil {
            map["ResultType"] = self.resultType!
        }
        if self.stageName != nil {
            map["StageName"] = self.stageName!
        }
        if self.visibility != nil {
            map["Visibility"] = self.visibility!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiId") && dict["ApiId"] != nil {
            self.apiId = dict["ApiId"] as! String
        }
        if dict.keys.contains("ApiName") && dict["ApiName"] != nil {
            self.apiName = dict["ApiName"] as! String
        }
        if dict.keys.contains("AuthType") && dict["AuthType"] != nil {
            self.authType = dict["AuthType"] as! String
        }
        if dict.keys.contains("DeployedTime") && dict["DeployedTime"] != nil {
            self.deployedTime = dict["DeployedTime"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DisableInternet") && dict["DisableInternet"] != nil {
            self.disableInternet = dict["DisableInternet"] as! Bool
        }
        if dict.keys.contains("ErrorCodeSamples") && dict["ErrorCodeSamples"] != nil {
            var model = DescribeApiDocResponseBody.ErrorCodeSamples()
            model.fromMap(dict["ErrorCodeSamples"] as! [String: Any])
            self.errorCodeSamples = model
        }
        if dict.keys.contains("FailResultSample") && dict["FailResultSample"] != nil {
            self.failResultSample = dict["FailResultSample"] as! String
        }
        if dict.keys.contains("ForceNonceCheck") && dict["ForceNonceCheck"] != nil {
            self.forceNonceCheck = dict["ForceNonceCheck"] as! Bool
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RequestConfig") && dict["RequestConfig"] != nil {
            var model = DescribeApiDocResponseBody.RequestConfig()
            model.fromMap(dict["RequestConfig"] as! [String: Any])
            self.requestConfig = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RequestParameters") && dict["RequestParameters"] != nil {
            var model = DescribeApiDocResponseBody.RequestParameters()
            model.fromMap(dict["RequestParameters"] as! [String: Any])
            self.requestParameters = model
        }
        if dict.keys.contains("ResultSample") && dict["ResultSample"] != nil {
            self.resultSample = dict["ResultSample"] as! String
        }
        if dict.keys.contains("ResultType") && dict["ResultType"] != nil {
            self.resultType = dict["ResultType"] as! String
        }
        if dict.keys.contains("StageName") && dict["StageName"] != nil {
            self.stageName = dict["StageName"] as! String
        }
        if dict.keys.contains("Visibility") && dict["Visibility"] != nil {
            self.visibility = dict["Visibility"] as! String
        }
    }
}

public class DescribeApiDocResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeApiDocResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeApiDocResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeApiGroupRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var groupId: String?

    public var securityToken: String?

    public var tag: [DescribeApiGroupRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("Tag") && dict["Tag"] != nil {
            var tmp : [DescribeApiGroupRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = DescribeApiGroupRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class DescribeApiGroupResponseBody : Tea.TeaModel {
    public class CustomDomains : Tea.TeaModel {
        public class DomainItem : Tea.TeaModel {
            public var bindStageAlias: String?

            public var bindStageName: String?

            public var certificateId: String?

            public var certificateName: String?

            public var certificateValidEnd: Int64?

            public var certificateValidStart: Int64?

            public var customDomainType: String?

            public var domainBindingStatus: String?

            public var domainCNAMEStatus: String?

            public var domainLegalStatus: String?

            public var domainName: String?

            public var domainRemark: String?

            public var domainWebSocketStatus: String?

            public var isHttpRedirectToHttps: Bool?

            public var wildcardDomainPatterns: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bindStageAlias != nil {
                    map["BindStageAlias"] = self.bindStageAlias!
                }
                if self.bindStageName != nil {
                    map["BindStageName"] = self.bindStageName!
                }
                if self.certificateId != nil {
                    map["CertificateId"] = self.certificateId!
                }
                if self.certificateName != nil {
                    map["CertificateName"] = self.certificateName!
                }
                if self.certificateValidEnd != nil {
                    map["CertificateValidEnd"] = self.certificateValidEnd!
                }
                if self.certificateValidStart != nil {
                    map["CertificateValidStart"] = self.certificateValidStart!
                }
                if self.customDomainType != nil {
                    map["CustomDomainType"] = self.customDomainType!
                }
                if self.domainBindingStatus != nil {
                    map["DomainBindingStatus"] = self.domainBindingStatus!
                }
                if self.domainCNAMEStatus != nil {
                    map["DomainCNAMEStatus"] = self.domainCNAMEStatus!
                }
                if self.domainLegalStatus != nil {
                    map["DomainLegalStatus"] = self.domainLegalStatus!
                }
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.domainRemark != nil {
                    map["DomainRemark"] = self.domainRemark!
                }
                if self.domainWebSocketStatus != nil {
                    map["DomainWebSocketStatus"] = self.domainWebSocketStatus!
                }
                if self.isHttpRedirectToHttps != nil {
                    map["IsHttpRedirectToHttps"] = self.isHttpRedirectToHttps!
                }
                if self.wildcardDomainPatterns != nil {
                    map["WildcardDomainPatterns"] = self.wildcardDomainPatterns!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BindStageAlias") && dict["BindStageAlias"] != nil {
                    self.bindStageAlias = dict["BindStageAlias"] as! String
                }
                if dict.keys.contains("BindStageName") && dict["BindStageName"] != nil {
                    self.bindStageName = dict["BindStageName"] as! String
                }
                if dict.keys.contains("CertificateId") && dict["CertificateId"] != nil {
                    self.certificateId = dict["CertificateId"] as! String
                }
                if dict.keys.contains("CertificateName") && dict["CertificateName"] != nil {
                    self.certificateName = dict["CertificateName"] as! String
                }
                if dict.keys.contains("CertificateValidEnd") && dict["CertificateValidEnd"] != nil {
                    self.certificateValidEnd = dict["CertificateValidEnd"] as! Int64
                }
                if dict.keys.contains("CertificateValidStart") && dict["CertificateValidStart"] != nil {
                    self.certificateValidStart = dict["CertificateValidStart"] as! Int64
                }
                if dict.keys.contains("CustomDomainType") && dict["CustomDomainType"] != nil {
                    self.customDomainType = dict["CustomDomainType"] as! String
                }
                if dict.keys.contains("DomainBindingStatus") && dict["DomainBindingStatus"] != nil {
                    self.domainBindingStatus = dict["DomainBindingStatus"] as! String
                }
                if dict.keys.contains("DomainCNAMEStatus") && dict["DomainCNAMEStatus"] != nil {
                    self.domainCNAMEStatus = dict["DomainCNAMEStatus"] as! String
                }
                if dict.keys.contains("DomainLegalStatus") && dict["DomainLegalStatus"] != nil {
                    self.domainLegalStatus = dict["DomainLegalStatus"] as! String
                }
                if dict.keys.contains("DomainName") && dict["DomainName"] != nil {
                    self.domainName = dict["DomainName"] as! String
                }
                if dict.keys.contains("DomainRemark") && dict["DomainRemark"] != nil {
                    self.domainRemark = dict["DomainRemark"] as! String
                }
                if dict.keys.contains("DomainWebSocketStatus") && dict["DomainWebSocketStatus"] != nil {
                    self.domainWebSocketStatus = dict["DomainWebSocketStatus"] as! String
                }
                if dict.keys.contains("IsHttpRedirectToHttps") && dict["IsHttpRedirectToHttps"] != nil {
                    self.isHttpRedirectToHttps = dict["IsHttpRedirectToHttps"] as! Bool
                }
                if dict.keys.contains("WildcardDomainPatterns") && dict["WildcardDomainPatterns"] != nil {
                    self.wildcardDomainPatterns = dict["WildcardDomainPatterns"] as! String
                }
            }
        }
        public var domainItem: [DescribeApiGroupResponseBody.CustomDomains.DomainItem]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.domainItem != nil {
                var tmp : [Any] = []
                for k in self.domainItem! {
                    tmp.append(k.toMap())
                }
                map["DomainItem"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DomainItem") && dict["DomainItem"] != nil {
                var tmp : [DescribeApiGroupResponseBody.CustomDomains.DomainItem] = []
                for v in dict["DomainItem"] as! [Any] {
                    var model = DescribeApiGroupResponseBody.CustomDomains.DomainItem()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.domainItem = tmp
            }
        }
    }
    public class StageItems : Tea.TeaModel {
        public class StageInfo : Tea.TeaModel {
            public var description_: String?

            public var stageId: String?

            public var stageName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.stageId != nil {
                    map["StageId"] = self.stageId!
                }
                if self.stageName != nil {
                    map["StageName"] = self.stageName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("StageId") && dict["StageId"] != nil {
                    self.stageId = dict["StageId"] as! String
                }
                if dict.keys.contains("StageName") && dict["StageName"] != nil {
                    self.stageName = dict["StageName"] as! String
                }
            }
        }
        public var stageInfo: [DescribeApiGroupResponseBody.StageItems.StageInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.stageInfo != nil {
                var tmp : [Any] = []
                for k in self.stageInfo! {
                    tmp.append(k.toMap())
                }
                map["StageInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("StageInfo") && dict["StageInfo"] != nil {
                var tmp : [DescribeApiGroupResponseBody.StageItems.StageInfo] = []
                for v in dict["StageInfo"] as! [Any] {
                    var model = DescribeApiGroupResponseBody.StageItems.StageInfo()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.stageInfo = tmp
            }
        }
    }
    public var basePath: String?

    public var billingStatus: String?

    public var cloudMarketCommodity: Bool?

    public var cmsMonitorGroup: String?

    public var compatibleFlags: String?

    public var createdTime: String?

    public var customDomains: DescribeApiGroupResponseBody.CustomDomains?

    public var customTraceConfig: String?

    public var customerConfigs: String?

    public var dedicatedInstanceType: String?

    public var defaultDomain: String?

    public var description_: String?

    public var disableInnerDomain: Bool?

    public var groupId: String?

    public var groupName: String?

    public var httpsPolicy: String?

    public var illegalStatus: String?

    public var instanceId: String?

    public var instanceType: String?

    public var ipv6Status: String?

    public var migrationError: String?

    public var migrationStatus: String?

    public var modifiedTime: String?

    public var passthroughHeaders: String?

    public var regionId: String?

    public var requestId: String?

    public var stageItems: DescribeApiGroupResponseBody.StageItems?

    public var status: String?

    public var subDomain: String?

    public var trafficLimit: Int32?

    public var userLogConfig: String?

    public var vpcDomain: String?

    public var vpcSlbIntranetDomain: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.customDomains?.validate()
        try self.stageItems?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.basePath != nil {
            map["BasePath"] = self.basePath!
        }
        if self.billingStatus != nil {
            map["BillingStatus"] = self.billingStatus!
        }
        if self.cloudMarketCommodity != nil {
            map["CloudMarketCommodity"] = self.cloudMarketCommodity!
        }
        if self.cmsMonitorGroup != nil {
            map["CmsMonitorGroup"] = self.cmsMonitorGroup!
        }
        if self.compatibleFlags != nil {
            map["CompatibleFlags"] = self.compatibleFlags!
        }
        if self.createdTime != nil {
            map["CreatedTime"] = self.createdTime!
        }
        if self.customDomains != nil {
            map["CustomDomains"] = self.customDomains?.toMap()
        }
        if self.customTraceConfig != nil {
            map["CustomTraceConfig"] = self.customTraceConfig!
        }
        if self.customerConfigs != nil {
            map["CustomerConfigs"] = self.customerConfigs!
        }
        if self.dedicatedInstanceType != nil {
            map["DedicatedInstanceType"] = self.dedicatedInstanceType!
        }
        if self.defaultDomain != nil {
            map["DefaultDomain"] = self.defaultDomain!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.disableInnerDomain != nil {
            map["DisableInnerDomain"] = self.disableInnerDomain!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.httpsPolicy != nil {
            map["HttpsPolicy"] = self.httpsPolicy!
        }
        if self.illegalStatus != nil {
            map["IllegalStatus"] = self.illegalStatus!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.ipv6Status != nil {
            map["Ipv6Status"] = self.ipv6Status!
        }
        if self.migrationError != nil {
            map["MigrationError"] = self.migrationError!
        }
        if self.migrationStatus != nil {
            map["MigrationStatus"] = self.migrationStatus!
        }
        if self.modifiedTime != nil {
            map["ModifiedTime"] = self.modifiedTime!
        }
        if self.passthroughHeaders != nil {
            map["PassthroughHeaders"] = self.passthroughHeaders!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.stageItems != nil {
            map["StageItems"] = self.stageItems?.toMap()
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.subDomain != nil {
            map["SubDomain"] = self.subDomain!
        }
        if self.trafficLimit != nil {
            map["TrafficLimit"] = self.trafficLimit!
        }
        if self.userLogConfig != nil {
            map["UserLogConfig"] = self.userLogConfig!
        }
        if self.vpcDomain != nil {
            map["VpcDomain"] = self.vpcDomain!
        }
        if self.vpcSlbIntranetDomain != nil {
            map["VpcSlbIntranetDomain"] = self.vpcSlbIntranetDomain!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BasePath") && dict["BasePath"] != nil {
            self.basePath = dict["BasePath"] as! String
        }
        if dict.keys.contains("BillingStatus") && dict["BillingStatus"] != nil {
            self.billingStatus = dict["BillingStatus"] as! String
        }
        if dict.keys.contains("CloudMarketCommodity") && dict["CloudMarketCommodity"] != nil {
            self.cloudMarketCommodity = dict["CloudMarketCommodity"] as! Bool
        }
        if dict.keys.contains("CmsMonitorGroup") && dict["CmsMonitorGroup"] != nil {
            self.cmsMonitorGroup = dict["CmsMonitorGroup"] as! String
        }
        if dict.keys.contains("CompatibleFlags") && dict["CompatibleFlags"] != nil {
            self.compatibleFlags = dict["CompatibleFlags"] as! String
        }
        if dict.keys.contains("CreatedTime") && dict["CreatedTime"] != nil {
            self.createdTime = dict["CreatedTime"] as! String
        }
        if dict.keys.contains("CustomDomains") && dict["CustomDomains"] != nil {
            var model = DescribeApiGroupResponseBody.CustomDomains()
            model.fromMap(dict["CustomDomains"] as! [String: Any])
            self.customDomains = model
        }
        if dict.keys.contains("CustomTraceConfig") && dict["CustomTraceConfig"] != nil {
            self.customTraceConfig = dict["CustomTraceConfig"] as! String
        }
        if dict.keys.contains("CustomerConfigs") && dict["CustomerConfigs"] != nil {
            self.customerConfigs = dict["CustomerConfigs"] as! String
        }
        if dict.keys.contains("DedicatedInstanceType") && dict["DedicatedInstanceType"] != nil {
            self.dedicatedInstanceType = dict["DedicatedInstanceType"] as! String
        }
        if dict.keys.contains("DefaultDomain") && dict["DefaultDomain"] != nil {
            self.defaultDomain = dict["DefaultDomain"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DisableInnerDomain") && dict["DisableInnerDomain"] != nil {
            self.disableInnerDomain = dict["DisableInnerDomain"] as! Bool
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("HttpsPolicy") && dict["HttpsPolicy"] != nil {
            self.httpsPolicy = dict["HttpsPolicy"] as! String
        }
        if dict.keys.contains("IllegalStatus") && dict["IllegalStatus"] != nil {
            self.illegalStatus = dict["IllegalStatus"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("InstanceType") && dict["InstanceType"] != nil {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("Ipv6Status") && dict["Ipv6Status"] != nil {
            self.ipv6Status = dict["Ipv6Status"] as! String
        }
        if dict.keys.contains("MigrationError") && dict["MigrationError"] != nil {
            self.migrationError = dict["MigrationError"] as! String
        }
        if dict.keys.contains("MigrationStatus") && dict["MigrationStatus"] != nil {
            self.migrationStatus = dict["MigrationStatus"] as! String
        }
        if dict.keys.contains("ModifiedTime") && dict["ModifiedTime"] != nil {
            self.modifiedTime = dict["ModifiedTime"] as! String
        }
        if dict.keys.contains("PassthroughHeaders") && dict["PassthroughHeaders"] != nil {
            self.passthroughHeaders = dict["PassthroughHeaders"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StageItems") && dict["StageItems"] != nil {
            var model = DescribeApiGroupResponseBody.StageItems()
            model.fromMap(dict["StageItems"] as! [String: Any])
            self.stageItems = model
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("SubDomain") && dict["SubDomain"] != nil {
            self.subDomain = dict["SubDomain"] as! String
        }
        if dict.keys.contains("TrafficLimit") && dict["TrafficLimit"] != nil {
            self.trafficLimit = dict["TrafficLimit"] as! Int32
        }
        if dict.keys.contains("UserLogConfig") && dict["UserLogConfig"] != nil {
            self.userLogConfig = dict["UserLogConfig"] as! String
        }
        if dict.keys.contains("VpcDomain") && dict["VpcDomain"] != nil {
            self.vpcDomain = dict["VpcDomain"] as! String
        }
        if dict.keys.contains("VpcSlbIntranetDomain") && dict["VpcSlbIntranetDomain"] != nil {
            self.vpcSlbIntranetDomain = dict["VpcSlbIntranetDomain"] as! String
        }
    }
}

public class DescribeApiGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeApiGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeApiGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeApiGroupVpcWhitelistRequest : Tea.TeaModel {
    public var groupId: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DescribeApiGroupVpcWhitelistResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var vpcIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.vpcIds != nil {
            map["VpcIds"] = self.vpcIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("VpcIds") && dict["VpcIds"] != nil {
            self.vpcIds = dict["VpcIds"] as! String
        }
    }
}

public class DescribeApiGroupVpcWhitelistResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeApiGroupVpcWhitelistResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeApiGroupVpcWhitelistResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeApiGroupsRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var enableTagAuth: Bool?

    public var groupId: String?

    public var groupName: String?

    public var instanceId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var securityToken: String?

    public var sort: String?

    public var tag: [DescribeApiGroupsRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.enableTagAuth != nil {
            map["EnableTagAuth"] = self.enableTagAuth!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.sort != nil {
            map["Sort"] = self.sort!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnableTagAuth") && dict["EnableTagAuth"] != nil {
            self.enableTagAuth = dict["EnableTagAuth"] as! Bool
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("Sort") && dict["Sort"] != nil {
            self.sort = dict["Sort"] as! String
        }
        if dict.keys.contains("Tag") && dict["Tag"] != nil {
            var tmp : [DescribeApiGroupsRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = DescribeApiGroupsRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class DescribeApiGroupsResponseBody : Tea.TeaModel {
    public class ApiGroupAttributes : Tea.TeaModel {
        public class ApiGroupAttribute : Tea.TeaModel {
            public class Tags : Tea.TeaModel {
                public class TagInfo : Tea.TeaModel {
                    public var key: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Key") && dict["Key"] != nil {
                            self.key = dict["Key"] as! String
                        }
                        if dict.keys.contains("Value") && dict["Value"] != nil {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var tagInfo: [DescribeApiGroupsResponseBody.ApiGroupAttributes.ApiGroupAttribute.Tags.TagInfo]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tagInfo != nil {
                        var tmp : [Any] = []
                        for k in self.tagInfo! {
                            tmp.append(k.toMap())
                        }
                        map["TagInfo"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("TagInfo") && dict["TagInfo"] != nil {
                        var tmp : [DescribeApiGroupsResponseBody.ApiGroupAttributes.ApiGroupAttribute.Tags.TagInfo] = []
                        for v in dict["TagInfo"] as! [Any] {
                            var model = DescribeApiGroupsResponseBody.ApiGroupAttributes.ApiGroupAttribute.Tags.TagInfo()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.tagInfo = tmp
                    }
                }
            }
            public var basePath: String?

            public var billingStatus: String?

            public var createdTime: String?

            public var description_: String?

            public var groupId: String?

            public var groupName: String?

            public var httpsPolicy: String?

            public var illegalStatus: String?

            public var instanceId: String?

            public var instanceType: String?

            public var modifiedTime: String?

            public var regionId: String?

            public var subDomain: String?

            public var tags: DescribeApiGroupsResponseBody.ApiGroupAttributes.ApiGroupAttribute.Tags?

            public var trafficLimit: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.basePath != nil {
                    map["BasePath"] = self.basePath!
                }
                if self.billingStatus != nil {
                    map["BillingStatus"] = self.billingStatus!
                }
                if self.createdTime != nil {
                    map["CreatedTime"] = self.createdTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.httpsPolicy != nil {
                    map["HttpsPolicy"] = self.httpsPolicy!
                }
                if self.illegalStatus != nil {
                    map["IllegalStatus"] = self.illegalStatus!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.instanceType != nil {
                    map["InstanceType"] = self.instanceType!
                }
                if self.modifiedTime != nil {
                    map["ModifiedTime"] = self.modifiedTime!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.subDomain != nil {
                    map["SubDomain"] = self.subDomain!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                if self.trafficLimit != nil {
                    map["TrafficLimit"] = self.trafficLimit!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BasePath") && dict["BasePath"] != nil {
                    self.basePath = dict["BasePath"] as! String
                }
                if dict.keys.contains("BillingStatus") && dict["BillingStatus"] != nil {
                    self.billingStatus = dict["BillingStatus"] as! String
                }
                if dict.keys.contains("CreatedTime") && dict["CreatedTime"] != nil {
                    self.createdTime = dict["CreatedTime"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
                    self.groupName = dict["GroupName"] as! String
                }
                if dict.keys.contains("HttpsPolicy") && dict["HttpsPolicy"] != nil {
                    self.httpsPolicy = dict["HttpsPolicy"] as! String
                }
                if dict.keys.contains("IllegalStatus") && dict["IllegalStatus"] != nil {
                    self.illegalStatus = dict["IllegalStatus"] as! String
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("InstanceType") && dict["InstanceType"] != nil {
                    self.instanceType = dict["InstanceType"] as! String
                }
                if dict.keys.contains("ModifiedTime") && dict["ModifiedTime"] != nil {
                    self.modifiedTime = dict["ModifiedTime"] as! String
                }
                if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("SubDomain") && dict["SubDomain"] != nil {
                    self.subDomain = dict["SubDomain"] as! String
                }
                if dict.keys.contains("Tags") && dict["Tags"] != nil {
                    var model = DescribeApiGroupsResponseBody.ApiGroupAttributes.ApiGroupAttribute.Tags()
                    model.fromMap(dict["Tags"] as! [String: Any])
                    self.tags = model
                }
                if dict.keys.contains("TrafficLimit") && dict["TrafficLimit"] != nil {
                    self.trafficLimit = dict["TrafficLimit"] as! Int32
                }
            }
        }
        public var apiGroupAttribute: [DescribeApiGroupsResponseBody.ApiGroupAttributes.ApiGroupAttribute]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apiGroupAttribute != nil {
                var tmp : [Any] = []
                for k in self.apiGroupAttribute! {
                    tmp.append(k.toMap())
                }
                map["ApiGroupAttribute"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApiGroupAttribute") && dict["ApiGroupAttribute"] != nil {
                var tmp : [DescribeApiGroupsResponseBody.ApiGroupAttributes.ApiGroupAttribute] = []
                for v in dict["ApiGroupAttribute"] as! [Any] {
                    var model = DescribeApiGroupsResponseBody.ApiGroupAttributes.ApiGroupAttribute()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.apiGroupAttribute = tmp
            }
        }
    }
    public var apiGroupAttributes: DescribeApiGroupsResponseBody.ApiGroupAttributes?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.apiGroupAttributes?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiGroupAttributes != nil {
            map["ApiGroupAttributes"] = self.apiGroupAttributes?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiGroupAttributes") && dict["ApiGroupAttributes"] != nil {
            var model = DescribeApiGroupsResponseBody.ApiGroupAttributes()
            model.fromMap(dict["ApiGroupAttributes"] as! [String: Any])
            self.apiGroupAttributes = model
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeApiGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeApiGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeApiGroupsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeApiHistoriesRequest : Tea.TeaModel {
    public var apiId: String?

    public var apiName: String?

    public var groupId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var securityToken: String?

    public var stageName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.apiName != nil {
            map["ApiName"] = self.apiName!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.stageName != nil {
            map["StageName"] = self.stageName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiId") && dict["ApiId"] != nil {
            self.apiId = dict["ApiId"] as! String
        }
        if dict.keys.contains("ApiName") && dict["ApiName"] != nil {
            self.apiName = dict["ApiName"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StageName") && dict["StageName"] != nil {
            self.stageName = dict["StageName"] as! String
        }
    }
}

public class DescribeApiHistoriesResponseBody : Tea.TeaModel {
    public class ApiHisItems : Tea.TeaModel {
        public class ApiHisItem : Tea.TeaModel {
            public var apiId: String?

            public var apiName: String?

            public var deployedTime: String?

            public var description_: String?

            public var groupId: String?

            public var groupName: String?

            public var historyVersion: String?

            public var regionId: String?

            public var stageName: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.apiId != nil {
                    map["ApiId"] = self.apiId!
                }
                if self.apiName != nil {
                    map["ApiName"] = self.apiName!
                }
                if self.deployedTime != nil {
                    map["DeployedTime"] = self.deployedTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.historyVersion != nil {
                    map["HistoryVersion"] = self.historyVersion!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.stageName != nil {
                    map["StageName"] = self.stageName!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ApiId") && dict["ApiId"] != nil {
                    self.apiId = dict["ApiId"] as! String
                }
                if dict.keys.contains("ApiName") && dict["ApiName"] != nil {
                    self.apiName = dict["ApiName"] as! String
                }
                if dict.keys.contains("DeployedTime") && dict["DeployedTime"] != nil {
                    self.deployedTime = dict["DeployedTime"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
                    self.groupName = dict["GroupName"] as! String
                }
                if dict.keys.contains("HistoryVersion") && dict["HistoryVersion"] != nil {
                    self.historyVersion = dict["HistoryVersion"] as! String
                }
                if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("StageName") && dict["StageName"] != nil {
                    self.stageName = dict["StageName"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var apiHisItem: [DescribeApiHistoriesResponseBody.ApiHisItems.ApiHisItem]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apiHisItem != nil {
                var tmp : [Any] = []
                for k in self.apiHisItem! {
                    tmp.append(k.toMap())
                }
                map["ApiHisItem"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApiHisItem") && dict["ApiHisItem"] != nil {
                var tmp : [DescribeApiHistoriesResponseBody.ApiHisItems.ApiHisItem] = []
                for v in dict["ApiHisItem"] as! [Any] {
                    var model = DescribeApiHistoriesResponseBody.ApiHisItems.ApiHisItem()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.apiHisItem = tmp
            }
        }
    }
    public var apiHisItems: DescribeApiHistoriesResponseBody.ApiHisItems?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.apiHisItems?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiHisItems != nil {
            map["ApiHisItems"] = self.apiHisItems?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiHisItems") && dict["ApiHisItems"] != nil {
            var model = DescribeApiHistoriesResponseBody.ApiHisItems()
            model.fromMap(dict["ApiHisItems"] as! [String: Any])
            self.apiHisItems = model
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeApiHistoriesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeApiHistoriesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeApiHistoriesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeApiHistoryRequest : Tea.TeaModel {
    public var apiId: String?

    public var groupId: String?

    public var historyVersion: String?

    public var securityToken: String?

    public var stageName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.historyVersion != nil {
            map["HistoryVersion"] = self.historyVersion!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.stageName != nil {
            map["StageName"] = self.stageName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiId") && dict["ApiId"] != nil {
            self.apiId = dict["ApiId"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("HistoryVersion") && dict["HistoryVersion"] != nil {
            self.historyVersion = dict["HistoryVersion"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StageName") && dict["StageName"] != nil {
            self.stageName = dict["StageName"] as! String
        }
    }
}

public class DescribeApiHistoryResponseBody : Tea.TeaModel {
    public class BackendConfig : Tea.TeaModel {
        public var backendId: String?

        public var backendName: String?

        public var backendType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.backendId != nil {
                map["BackendId"] = self.backendId!
            }
            if self.backendName != nil {
                map["BackendName"] = self.backendName!
            }
            if self.backendType != nil {
                map["BackendType"] = self.backendType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BackendId") && dict["BackendId"] != nil {
                self.backendId = dict["BackendId"] as! String
            }
            if dict.keys.contains("BackendName") && dict["BackendName"] != nil {
                self.backendName = dict["BackendName"] as! String
            }
            if dict.keys.contains("BackendType") && dict["BackendType"] != nil {
                self.backendType = dict["BackendType"] as! String
            }
        }
    }
    public class ConstantParameters : Tea.TeaModel {
        public class ConstantParameter : Tea.TeaModel {
            public var constantValue: String?

            public var description_: String?

            public var location: String?

            public var serviceParameterName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.constantValue != nil {
                    map["ConstantValue"] = self.constantValue!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.location != nil {
                    map["Location"] = self.location!
                }
                if self.serviceParameterName != nil {
                    map["ServiceParameterName"] = self.serviceParameterName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ConstantValue") && dict["ConstantValue"] != nil {
                    self.constantValue = dict["ConstantValue"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Location") && dict["Location"] != nil {
                    self.location = dict["Location"] as! String
                }
                if dict.keys.contains("ServiceParameterName") && dict["ServiceParameterName"] != nil {
                    self.serviceParameterName = dict["ServiceParameterName"] as! String
                }
            }
        }
        public var constantParameter: [DescribeApiHistoryResponseBody.ConstantParameters.ConstantParameter]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.constantParameter != nil {
                var tmp : [Any] = []
                for k in self.constantParameter! {
                    tmp.append(k.toMap())
                }
                map["ConstantParameter"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConstantParameter") && dict["ConstantParameter"] != nil {
                var tmp : [DescribeApiHistoryResponseBody.ConstantParameters.ConstantParameter] = []
                for v in dict["ConstantParameter"] as! [Any] {
                    var model = DescribeApiHistoryResponseBody.ConstantParameters.ConstantParameter()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.constantParameter = tmp
            }
        }
    }
    public class CustomSystemParameters : Tea.TeaModel {
        public class CustomSystemParameter : Tea.TeaModel {
            public var demoValue: String?

            public var description_: String?

            public var location: String?

            public var parameterName: String?

            public var serviceParameterName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.demoValue != nil {
                    map["DemoValue"] = self.demoValue!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.location != nil {
                    map["Location"] = self.location!
                }
                if self.parameterName != nil {
                    map["ParameterName"] = self.parameterName!
                }
                if self.serviceParameterName != nil {
                    map["ServiceParameterName"] = self.serviceParameterName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DemoValue") && dict["DemoValue"] != nil {
                    self.demoValue = dict["DemoValue"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Location") && dict["Location"] != nil {
                    self.location = dict["Location"] as! String
                }
                if dict.keys.contains("ParameterName") && dict["ParameterName"] != nil {
                    self.parameterName = dict["ParameterName"] as! String
                }
                if dict.keys.contains("ServiceParameterName") && dict["ServiceParameterName"] != nil {
                    self.serviceParameterName = dict["ServiceParameterName"] as! String
                }
            }
        }
        public var customSystemParameter: [DescribeApiHistoryResponseBody.CustomSystemParameters.CustomSystemParameter]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.customSystemParameter != nil {
                var tmp : [Any] = []
                for k in self.customSystemParameter! {
                    tmp.append(k.toMap())
                }
                map["CustomSystemParameter"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CustomSystemParameter") && dict["CustomSystemParameter"] != nil {
                var tmp : [DescribeApiHistoryResponseBody.CustomSystemParameters.CustomSystemParameter] = []
                for v in dict["CustomSystemParameter"] as! [Any] {
                    var model = DescribeApiHistoryResponseBody.CustomSystemParameters.CustomSystemParameter()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.customSystemParameter = tmp
            }
        }
    }
    public class ErrorCodeSamples : Tea.TeaModel {
        public class ErrorCodeSample : Tea.TeaModel {
            public var code: String?

            public var description_: String?

            public var message: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Code") && dict["Code"] != nil {
                    self.code = dict["Code"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Message") && dict["Message"] != nil {
                    self.message = dict["Message"] as! String
                }
            }
        }
        public var errorCodeSample: [DescribeApiHistoryResponseBody.ErrorCodeSamples.ErrorCodeSample]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.errorCodeSample != nil {
                var tmp : [Any] = []
                for k in self.errorCodeSample! {
                    tmp.append(k.toMap())
                }
                map["ErrorCodeSample"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ErrorCodeSample") && dict["ErrorCodeSample"] != nil {
                var tmp : [DescribeApiHistoryResponseBody.ErrorCodeSamples.ErrorCodeSample] = []
                for v in dict["ErrorCodeSample"] as! [Any] {
                    var model = DescribeApiHistoryResponseBody.ErrorCodeSamples.ErrorCodeSample()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.errorCodeSample = tmp
            }
        }
    }
    public class OpenIdConnectConfig : Tea.TeaModel {
        public var idTokenParamName: String?

        public var openIdApiType: String?

        public var publicKey: String?

        public var publicKeyId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.idTokenParamName != nil {
                map["IdTokenParamName"] = self.idTokenParamName!
            }
            if self.openIdApiType != nil {
                map["OpenIdApiType"] = self.openIdApiType!
            }
            if self.publicKey != nil {
                map["PublicKey"] = self.publicKey!
            }
            if self.publicKeyId != nil {
                map["PublicKeyId"] = self.publicKeyId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("IdTokenParamName") && dict["IdTokenParamName"] != nil {
                self.idTokenParamName = dict["IdTokenParamName"] as! String
            }
            if dict.keys.contains("OpenIdApiType") && dict["OpenIdApiType"] != nil {
                self.openIdApiType = dict["OpenIdApiType"] as! String
            }
            if dict.keys.contains("PublicKey") && dict["PublicKey"] != nil {
                self.publicKey = dict["PublicKey"] as! String
            }
            if dict.keys.contains("PublicKeyId") && dict["PublicKeyId"] != nil {
                self.publicKeyId = dict["PublicKeyId"] as! String
            }
        }
    }
    public class RequestConfig : Tea.TeaModel {
        public var bodyFormat: String?

        public var bodyModel: String?

        public var postBodyDescription: String?

        public var requestHttpMethod: String?

        public var requestMode: String?

        public var requestPath: String?

        public var requestProtocol: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bodyFormat != nil {
                map["BodyFormat"] = self.bodyFormat!
            }
            if self.bodyModel != nil {
                map["BodyModel"] = self.bodyModel!
            }
            if self.postBodyDescription != nil {
                map["PostBodyDescription"] = self.postBodyDescription!
            }
            if self.requestHttpMethod != nil {
                map["RequestHttpMethod"] = self.requestHttpMethod!
            }
            if self.requestMode != nil {
                map["RequestMode"] = self.requestMode!
            }
            if self.requestPath != nil {
                map["RequestPath"] = self.requestPath!
            }
            if self.requestProtocol != nil {
                map["RequestProtocol"] = self.requestProtocol!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BodyFormat") && dict["BodyFormat"] != nil {
                self.bodyFormat = dict["BodyFormat"] as! String
            }
            if dict.keys.contains("BodyModel") && dict["BodyModel"] != nil {
                self.bodyModel = dict["BodyModel"] as! String
            }
            if dict.keys.contains("PostBodyDescription") && dict["PostBodyDescription"] != nil {
                self.postBodyDescription = dict["PostBodyDescription"] as! String
            }
            if dict.keys.contains("RequestHttpMethod") && dict["RequestHttpMethod"] != nil {
                self.requestHttpMethod = dict["RequestHttpMethod"] as! String
            }
            if dict.keys.contains("RequestMode") && dict["RequestMode"] != nil {
                self.requestMode = dict["RequestMode"] as! String
            }
            if dict.keys.contains("RequestPath") && dict["RequestPath"] != nil {
                self.requestPath = dict["RequestPath"] as! String
            }
            if dict.keys.contains("RequestProtocol") && dict["RequestProtocol"] != nil {
                self.requestProtocol = dict["RequestProtocol"] as! String
            }
        }
    }
    public class RequestParameters : Tea.TeaModel {
        public class RequestParameter : Tea.TeaModel {
            public var apiParameterName: String?

            public var arrayItemsType: String?

            public var defaultValue: String?

            public var demoValue: String?

            public var description_: String?

            public var docOrder: Int32?

            public var docShow: String?

            public var enumValue: String?

            public var jsonScheme: String?

            public var location: String?

            public var maxLength: Int64?

            public var maxValue: Int64?

            public var minLength: Int64?

            public var minValue: Int64?

            public var parameterType: String?

            public var regularExpression: String?

            public var required_: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.apiParameterName != nil {
                    map["ApiParameterName"] = self.apiParameterName!
                }
                if self.arrayItemsType != nil {
                    map["ArrayItemsType"] = self.arrayItemsType!
                }
                if self.defaultValue != nil {
                    map["DefaultValue"] = self.defaultValue!
                }
                if self.demoValue != nil {
                    map["DemoValue"] = self.demoValue!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.docOrder != nil {
                    map["DocOrder"] = self.docOrder!
                }
                if self.docShow != nil {
                    map["DocShow"] = self.docShow!
                }
                if self.enumValue != nil {
                    map["EnumValue"] = self.enumValue!
                }
                if self.jsonScheme != nil {
                    map["JsonScheme"] = self.jsonScheme!
                }
                if self.location != nil {
                    map["Location"] = self.location!
                }
                if self.maxLength != nil {
                    map["MaxLength"] = self.maxLength!
                }
                if self.maxValue != nil {
                    map["MaxValue"] = self.maxValue!
                }
                if self.minLength != nil {
                    map["MinLength"] = self.minLength!
                }
                if self.minValue != nil {
                    map["MinValue"] = self.minValue!
                }
                if self.parameterType != nil {
                    map["ParameterType"] = self.parameterType!
                }
                if self.regularExpression != nil {
                    map["RegularExpression"] = self.regularExpression!
                }
                if self.required_ != nil {
                    map["Required"] = self.required_!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ApiParameterName") && dict["ApiParameterName"] != nil {
                    self.apiParameterName = dict["ApiParameterName"] as! String
                }
                if dict.keys.contains("ArrayItemsType") && dict["ArrayItemsType"] != nil {
                    self.arrayItemsType = dict["ArrayItemsType"] as! String
                }
                if dict.keys.contains("DefaultValue") && dict["DefaultValue"] != nil {
                    self.defaultValue = dict["DefaultValue"] as! String
                }
                if dict.keys.contains("DemoValue") && dict["DemoValue"] != nil {
                    self.demoValue = dict["DemoValue"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("DocOrder") && dict["DocOrder"] != nil {
                    self.docOrder = dict["DocOrder"] as! Int32
                }
                if dict.keys.contains("DocShow") && dict["DocShow"] != nil {
                    self.docShow = dict["DocShow"] as! String
                }
                if dict.keys.contains("EnumValue") && dict["EnumValue"] != nil {
                    self.enumValue = dict["EnumValue"] as! String
                }
                if dict.keys.contains("JsonScheme") && dict["JsonScheme"] != nil {
                    self.jsonScheme = dict["JsonScheme"] as! String
                }
                if dict.keys.contains("Location") && dict["Location"] != nil {
                    self.location = dict["Location"] as! String
                }
                if dict.keys.contains("MaxLength") && dict["MaxLength"] != nil {
                    self.maxLength = dict["MaxLength"] as! Int64
                }
                if dict.keys.contains("MaxValue") && dict["MaxValue"] != nil {
                    self.maxValue = dict["MaxValue"] as! Int64
                }
                if dict.keys.contains("MinLength") && dict["MinLength"] != nil {
                    self.minLength = dict["MinLength"] as! Int64
                }
                if dict.keys.contains("MinValue") && dict["MinValue"] != nil {
                    self.minValue = dict["MinValue"] as! Int64
                }
                if dict.keys.contains("ParameterType") && dict["ParameterType"] != nil {
                    self.parameterType = dict["ParameterType"] as! String
                }
                if dict.keys.contains("RegularExpression") && dict["RegularExpression"] != nil {
                    self.regularExpression = dict["RegularExpression"] as! String
                }
                if dict.keys.contains("Required") && dict["Required"] != nil {
                    self.required_ = dict["Required"] as! String
                }
            }
        }
        public var requestParameter: [DescribeApiHistoryResponseBody.RequestParameters.RequestParameter]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.requestParameter != nil {
                var tmp : [Any] = []
                for k in self.requestParameter! {
                    tmp.append(k.toMap())
                }
                map["RequestParameter"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("RequestParameter") && dict["RequestParameter"] != nil {
                var tmp : [DescribeApiHistoryResponseBody.RequestParameters.RequestParameter] = []
                for v in dict["RequestParameter"] as! [Any] {
                    var model = DescribeApiHistoryResponseBody.RequestParameters.RequestParameter()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.requestParameter = tmp
            }
        }
    }
    public class ResultDescriptions : Tea.TeaModel {
        public class ResultDescription : Tea.TeaModel {
            public var description_: String?

            public var hasChild: Bool?

            public var id: String?

            public var key: String?

            public var mandatory: Bool?

            public var name: String?

            public var pid: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.hasChild != nil {
                    map["HasChild"] = self.hasChild!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.mandatory != nil {
                    map["Mandatory"] = self.mandatory!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.pid != nil {
                    map["Pid"] = self.pid!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("HasChild") && dict["HasChild"] != nil {
                    self.hasChild = dict["HasChild"] as! Bool
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("Key") && dict["Key"] != nil {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Mandatory") && dict["Mandatory"] != nil {
                    self.mandatory = dict["Mandatory"] as! Bool
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Pid") && dict["Pid"] != nil {
                    self.pid = dict["Pid"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var resultDescription: [DescribeApiHistoryResponseBody.ResultDescriptions.ResultDescription]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.resultDescription != nil {
                var tmp : [Any] = []
                for k in self.resultDescription! {
                    tmp.append(k.toMap())
                }
                map["ResultDescription"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ResultDescription") && dict["ResultDescription"] != nil {
                var tmp : [DescribeApiHistoryResponseBody.ResultDescriptions.ResultDescription] = []
                for v in dict["ResultDescription"] as! [Any] {
                    var model = DescribeApiHistoryResponseBody.ResultDescriptions.ResultDescription()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.resultDescription = tmp
            }
        }
    }
    public class ServiceConfig : Tea.TeaModel {
        public class EventBridgeConfig : Tea.TeaModel {
            public var eventBridgeRegionId: String?

            public var eventBus: String?

            public var eventSource: String?

            public var roleArn: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.eventBridgeRegionId != nil {
                    map["EventBridgeRegionId"] = self.eventBridgeRegionId!
                }
                if self.eventBus != nil {
                    map["EventBus"] = self.eventBus!
                }
                if self.eventSource != nil {
                    map["EventSource"] = self.eventSource!
                }
                if self.roleArn != nil {
                    map["RoleArn"] = self.roleArn!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EventBridgeRegionId") && dict["EventBridgeRegionId"] != nil {
                    self.eventBridgeRegionId = dict["EventBridgeRegionId"] as! String
                }
                if dict.keys.contains("EventBus") && dict["EventBus"] != nil {
                    self.eventBus = dict["EventBus"] as! String
                }
                if dict.keys.contains("EventSource") && dict["EventSource"] != nil {
                    self.eventSource = dict["EventSource"] as! String
                }
                if dict.keys.contains("RoleArn") && dict["RoleArn"] != nil {
                    self.roleArn = dict["RoleArn"] as! String
                }
            }
        }
        public class FunctionComputeConfig : Tea.TeaModel {
            public var contentTypeCatagory: String?

            public var contentTypeValue: String?

            public var fcBaseUrl: String?

            public var fcType: String?

            public var functionName: String?

            public var method: String?

            public var onlyBusinessPath: Bool?

            public var path: String?

            public var qualifier: String?

            public var regionId: String?

            public var roleArn: String?

            public var serviceName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.contentTypeCatagory != nil {
                    map["ContentTypeCatagory"] = self.contentTypeCatagory!
                }
                if self.contentTypeValue != nil {
                    map["ContentTypeValue"] = self.contentTypeValue!
                }
                if self.fcBaseUrl != nil {
                    map["FcBaseUrl"] = self.fcBaseUrl!
                }
                if self.fcType != nil {
                    map["FcType"] = self.fcType!
                }
                if self.functionName != nil {
                    map["FunctionName"] = self.functionName!
                }
                if self.method != nil {
                    map["Method"] = self.method!
                }
                if self.onlyBusinessPath != nil {
                    map["OnlyBusinessPath"] = self.onlyBusinessPath!
                }
                if self.path != nil {
                    map["Path"] = self.path!
                }
                if self.qualifier != nil {
                    map["Qualifier"] = self.qualifier!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.roleArn != nil {
                    map["RoleArn"] = self.roleArn!
                }
                if self.serviceName != nil {
                    map["ServiceName"] = self.serviceName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ContentTypeCatagory") && dict["ContentTypeCatagory"] != nil {
                    self.contentTypeCatagory = dict["ContentTypeCatagory"] as! String
                }
                if dict.keys.contains("ContentTypeValue") && dict["ContentTypeValue"] != nil {
                    self.contentTypeValue = dict["ContentTypeValue"] as! String
                }
                if dict.keys.contains("FcBaseUrl") && dict["FcBaseUrl"] != nil {
                    self.fcBaseUrl = dict["FcBaseUrl"] as! String
                }
                if dict.keys.contains("FcType") && dict["FcType"] != nil {
                    self.fcType = dict["FcType"] as! String
                }
                if dict.keys.contains("FunctionName") && dict["FunctionName"] != nil {
                    self.functionName = dict["FunctionName"] as! String
                }
                if dict.keys.contains("Method") && dict["Method"] != nil {
                    self.method = dict["Method"] as! String
                }
                if dict.keys.contains("OnlyBusinessPath") && dict["OnlyBusinessPath"] != nil {
                    self.onlyBusinessPath = dict["OnlyBusinessPath"] as! Bool
                }
                if dict.keys.contains("Path") && dict["Path"] != nil {
                    self.path = dict["Path"] as! String
                }
                if dict.keys.contains("Qualifier") && dict["Qualifier"] != nil {
                    self.qualifier = dict["Qualifier"] as! String
                }
                if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("RoleArn") && dict["RoleArn"] != nil {
                    self.roleArn = dict["RoleArn"] as! String
                }
                if dict.keys.contains("ServiceName") && dict["ServiceName"] != nil {
                    self.serviceName = dict["ServiceName"] as! String
                }
            }
        }
        public class MockHeaders : Tea.TeaModel {
            public class MockHeader : Tea.TeaModel {
                public var headerName: String?

                public var headerValue: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.headerName != nil {
                        map["HeaderName"] = self.headerName!
                    }
                    if self.headerValue != nil {
                        map["HeaderValue"] = self.headerValue!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("HeaderName") && dict["HeaderName"] != nil {
                        self.headerName = dict["HeaderName"] as! String
                    }
                    if dict.keys.contains("HeaderValue") && dict["HeaderValue"] != nil {
                        self.headerValue = dict["HeaderValue"] as! String
                    }
                }
            }
            public var mockHeader: [DescribeApiHistoryResponseBody.ServiceConfig.MockHeaders.MockHeader]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.mockHeader != nil {
                    var tmp : [Any] = []
                    for k in self.mockHeader! {
                        tmp.append(k.toMap())
                    }
                    map["MockHeader"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("MockHeader") && dict["MockHeader"] != nil {
                    var tmp : [DescribeApiHistoryResponseBody.ServiceConfig.MockHeaders.MockHeader] = []
                    for v in dict["MockHeader"] as! [Any] {
                        var model = DescribeApiHistoryResponseBody.ServiceConfig.MockHeaders.MockHeader()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.mockHeader = tmp
                }
            }
        }
        public class OssConfig : Tea.TeaModel {
            public var action: String?

            public var bucketName: String?

            public var key: String?

            public var ossRegionId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.action != nil {
                    map["Action"] = self.action!
                }
                if self.bucketName != nil {
                    map["BucketName"] = self.bucketName!
                }
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.ossRegionId != nil {
                    map["OssRegionId"] = self.ossRegionId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Action") && dict["Action"] != nil {
                    self.action = dict["Action"] as! String
                }
                if dict.keys.contains("BucketName") && dict["BucketName"] != nil {
                    self.bucketName = dict["BucketName"] as! String
                }
                if dict.keys.contains("Key") && dict["Key"] != nil {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("OssRegionId") && dict["OssRegionId"] != nil {
                    self.ossRegionId = dict["OssRegionId"] as! String
                }
            }
        }
        public class VpcConfig : Tea.TeaModel {
            public var instanceId: String?

            public var name: String?

            public var port: Int32?

            public var vpcId: String?

            public var vpcScheme: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                if self.vpcScheme != nil {
                    map["VpcScheme"] = self.vpcScheme!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Port") && dict["Port"] != nil {
                    self.port = dict["Port"] as! Int32
                }
                if dict.keys.contains("VpcId") && dict["VpcId"] != nil {
                    self.vpcId = dict["VpcId"] as! String
                }
                if dict.keys.contains("VpcScheme") && dict["VpcScheme"] != nil {
                    self.vpcScheme = dict["VpcScheme"] as! String
                }
            }
        }
        public var contentTypeCatagory: String?

        public var contentTypeValue: String?

        public var eventBridgeConfig: DescribeApiHistoryResponseBody.ServiceConfig.EventBridgeConfig?

        public var functionComputeConfig: DescribeApiHistoryResponseBody.ServiceConfig.FunctionComputeConfig?

        public var mock: String?

        public var mockHeaders: DescribeApiHistoryResponseBody.ServiceConfig.MockHeaders?

        public var mockResult: String?

        public var mockStatusCode: Int32?

        public var ossConfig: DescribeApiHistoryResponseBody.ServiceConfig.OssConfig?

        public var serviceAddress: String?

        public var serviceHttpMethod: String?

        public var servicePath: String?

        public var serviceProtocol: String?

        public var serviceTimeout: Int32?

        public var serviceVpcEnable: String?

        public var vpcConfig: DescribeApiHistoryResponseBody.ServiceConfig.VpcConfig?

        public var vpcId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.eventBridgeConfig?.validate()
            try self.functionComputeConfig?.validate()
            try self.mockHeaders?.validate()
            try self.ossConfig?.validate()
            try self.vpcConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.contentTypeCatagory != nil {
                map["ContentTypeCatagory"] = self.contentTypeCatagory!
            }
            if self.contentTypeValue != nil {
                map["ContentTypeValue"] = self.contentTypeValue!
            }
            if self.eventBridgeConfig != nil {
                map["EventBridgeConfig"] = self.eventBridgeConfig?.toMap()
            }
            if self.functionComputeConfig != nil {
                map["FunctionComputeConfig"] = self.functionComputeConfig?.toMap()
            }
            if self.mock != nil {
                map["Mock"] = self.mock!
            }
            if self.mockHeaders != nil {
                map["MockHeaders"] = self.mockHeaders?.toMap()
            }
            if self.mockResult != nil {
                map["MockResult"] = self.mockResult!
            }
            if self.mockStatusCode != nil {
                map["MockStatusCode"] = self.mockStatusCode!
            }
            if self.ossConfig != nil {
                map["OssConfig"] = self.ossConfig?.toMap()
            }
            if self.serviceAddress != nil {
                map["ServiceAddress"] = self.serviceAddress!
            }
            if self.serviceHttpMethod != nil {
                map["ServiceHttpMethod"] = self.serviceHttpMethod!
            }
            if self.servicePath != nil {
                map["ServicePath"] = self.servicePath!
            }
            if self.serviceProtocol != nil {
                map["ServiceProtocol"] = self.serviceProtocol!
            }
            if self.serviceTimeout != nil {
                map["ServiceTimeout"] = self.serviceTimeout!
            }
            if self.serviceVpcEnable != nil {
                map["ServiceVpcEnable"] = self.serviceVpcEnable!
            }
            if self.vpcConfig != nil {
                map["VpcConfig"] = self.vpcConfig?.toMap()
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ContentTypeCatagory") && dict["ContentTypeCatagory"] != nil {
                self.contentTypeCatagory = dict["ContentTypeCatagory"] as! String
            }
            if dict.keys.contains("ContentTypeValue") && dict["ContentTypeValue"] != nil {
                self.contentTypeValue = dict["ContentTypeValue"] as! String
            }
            if dict.keys.contains("EventBridgeConfig") && dict["EventBridgeConfig"] != nil {
                var model = DescribeApiHistoryResponseBody.ServiceConfig.EventBridgeConfig()
                model.fromMap(dict["EventBridgeConfig"] as! [String: Any])
                self.eventBridgeConfig = model
            }
            if dict.keys.contains("FunctionComputeConfig") && dict["FunctionComputeConfig"] != nil {
                var model = DescribeApiHistoryResponseBody.ServiceConfig.FunctionComputeConfig()
                model.fromMap(dict["FunctionComputeConfig"] as! [String: Any])
                self.functionComputeConfig = model
            }
            if dict.keys.contains("Mock") && dict["Mock"] != nil {
                self.mock = dict["Mock"] as! String
            }
            if dict.keys.contains("MockHeaders") && dict["MockHeaders"] != nil {
                var model = DescribeApiHistoryResponseBody.ServiceConfig.MockHeaders()
                model.fromMap(dict["MockHeaders"] as! [String: Any])
                self.mockHeaders = model
            }
            if dict.keys.contains("MockResult") && dict["MockResult"] != nil {
                self.mockResult = dict["MockResult"] as! String
            }
            if dict.keys.contains("MockStatusCode") && dict["MockStatusCode"] != nil {
                self.mockStatusCode = dict["MockStatusCode"] as! Int32
            }
            if dict.keys.contains("OssConfig") && dict["OssConfig"] != nil {
                var model = DescribeApiHistoryResponseBody.ServiceConfig.OssConfig()
                model.fromMap(dict["OssConfig"] as! [String: Any])
                self.ossConfig = model
            }
            if dict.keys.contains("ServiceAddress") && dict["ServiceAddress"] != nil {
                self.serviceAddress = dict["ServiceAddress"] as! String
            }
            if dict.keys.contains("ServiceHttpMethod") && dict["ServiceHttpMethod"] != nil {
                self.serviceHttpMethod = dict["ServiceHttpMethod"] as! String
            }
            if dict.keys.contains("ServicePath") && dict["ServicePath"] != nil {
                self.servicePath = dict["ServicePath"] as! String
            }
            if dict.keys.contains("ServiceProtocol") && dict["ServiceProtocol"] != nil {
                self.serviceProtocol = dict["ServiceProtocol"] as! String
            }
            if dict.keys.contains("ServiceTimeout") && dict["ServiceTimeout"] != nil {
                self.serviceTimeout = dict["ServiceTimeout"] as! Int32
            }
            if dict.keys.contains("ServiceVpcEnable") && dict["ServiceVpcEnable"] != nil {
                self.serviceVpcEnable = dict["ServiceVpcEnable"] as! String
            }
            if dict.keys.contains("VpcConfig") && dict["VpcConfig"] != nil {
                var model = DescribeApiHistoryResponseBody.ServiceConfig.VpcConfig()
                model.fromMap(dict["VpcConfig"] as! [String: Any])
                self.vpcConfig = model
            }
            if dict.keys.contains("VpcId") && dict["VpcId"] != nil {
                self.vpcId = dict["VpcId"] as! String
            }
        }
    }
    public class ServiceParameters : Tea.TeaModel {
        public class ServiceParameter : Tea.TeaModel {
            public var location: String?

            public var parameterType: String?

            public var serviceParameterName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.location != nil {
                    map["Location"] = self.location!
                }
                if self.parameterType != nil {
                    map["ParameterType"] = self.parameterType!
                }
                if self.serviceParameterName != nil {
                    map["ServiceParameterName"] = self.serviceParameterName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Location") && dict["Location"] != nil {
                    self.location = dict["Location"] as! String
                }
                if dict.keys.contains("ParameterType") && dict["ParameterType"] != nil {
                    self.parameterType = dict["ParameterType"] as! String
                }
                if dict.keys.contains("ServiceParameterName") && dict["ServiceParameterName"] != nil {
                    self.serviceParameterName = dict["ServiceParameterName"] as! String
                }
            }
        }
        public var serviceParameter: [DescribeApiHistoryResponseBody.ServiceParameters.ServiceParameter]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.serviceParameter != nil {
                var tmp : [Any] = []
                for k in self.serviceParameter! {
                    tmp.append(k.toMap())
                }
                map["ServiceParameter"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ServiceParameter") && dict["ServiceParameter"] != nil {
                var tmp : [DescribeApiHistoryResponseBody.ServiceParameters.ServiceParameter] = []
                for v in dict["ServiceParameter"] as! [Any] {
                    var model = DescribeApiHistoryResponseBody.ServiceParameters.ServiceParameter()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.serviceParameter = tmp
            }
        }
    }
    public class ServiceParametersMap : Tea.TeaModel {
        public class ServiceParameterMap : Tea.TeaModel {
            public var requestParameterName: String?

            public var serviceParameterName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.requestParameterName != nil {
                    map["RequestParameterName"] = self.requestParameterName!
                }
                if self.serviceParameterName != nil {
                    map["ServiceParameterName"] = self.serviceParameterName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("RequestParameterName") && dict["RequestParameterName"] != nil {
                    self.requestParameterName = dict["RequestParameterName"] as! String
                }
                if dict.keys.contains("ServiceParameterName") && dict["ServiceParameterName"] != nil {
                    self.serviceParameterName = dict["ServiceParameterName"] as! String
                }
            }
        }
        public var serviceParameterMap: [DescribeApiHistoryResponseBody.ServiceParametersMap.ServiceParameterMap]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.serviceParameterMap != nil {
                var tmp : [Any] = []
                for k in self.serviceParameterMap! {
                    tmp.append(k.toMap())
                }
                map["ServiceParameterMap"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ServiceParameterMap") && dict["ServiceParameterMap"] != nil {
                var tmp : [DescribeApiHistoryResponseBody.ServiceParametersMap.ServiceParameterMap] = []
                for v in dict["ServiceParameterMap"] as! [Any] {
                    var model = DescribeApiHistoryResponseBody.ServiceParametersMap.ServiceParameterMap()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.serviceParameterMap = tmp
            }
        }
    }
    public class SystemParameters : Tea.TeaModel {
        public class SystemParameter : Tea.TeaModel {
            public var demoValue: String?

            public var description_: String?

            public var location: String?

            public var parameterName: String?

            public var serviceParameterName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.demoValue != nil {
                    map["DemoValue"] = self.demoValue!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.location != nil {
                    map["Location"] = self.location!
                }
                if self.parameterName != nil {
                    map["ParameterName"] = self.parameterName!
                }
                if self.serviceParameterName != nil {
                    map["ServiceParameterName"] = self.serviceParameterName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DemoValue") && dict["DemoValue"] != nil {
                    self.demoValue = dict["DemoValue"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Location") && dict["Location"] != nil {
                    self.location = dict["Location"] as! String
                }
                if dict.keys.contains("ParameterName") && dict["ParameterName"] != nil {
                    self.parameterName = dict["ParameterName"] as! String
                }
                if dict.keys.contains("ServiceParameterName") && dict["ServiceParameterName"] != nil {
                    self.serviceParameterName = dict["ServiceParameterName"] as! String
                }
            }
        }
        public var systemParameter: [DescribeApiHistoryResponseBody.SystemParameters.SystemParameter]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.systemParameter != nil {
                var tmp : [Any] = []
                for k in self.systemParameter! {
                    tmp.append(k.toMap())
                }
                map["SystemParameter"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SystemParameter") && dict["SystemParameter"] != nil {
                var tmp : [DescribeApiHistoryResponseBody.SystemParameters.SystemParameter] = []
                for v in dict["SystemParameter"] as! [Any] {
                    var model = DescribeApiHistoryResponseBody.SystemParameters.SystemParameter()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.systemParameter = tmp
            }
        }
    }
    public var allowSignatureMethod: String?

    public var apiId: String?

    public var apiName: String?

    public var appCodeAuthType: String?

    public var authType: String?

    public var backendConfig: DescribeApiHistoryResponseBody.BackendConfig?

    public var backendEnable: Bool?

    public var constantParameters: DescribeApiHistoryResponseBody.ConstantParameters?

    public var customSystemParameters: DescribeApiHistoryResponseBody.CustomSystemParameters?

    public var deployedTime: String?

    public var description_: String?

    public var disableInternet: Bool?

    public var errorCodeSamples: DescribeApiHistoryResponseBody.ErrorCodeSamples?

    public var failResultSample: String?

    public var forceNonceCheck: Bool?

    public var groupId: String?

    public var groupName: String?

    public var historyVersion: String?

    public var openIdConnectConfig: DescribeApiHistoryResponseBody.OpenIdConnectConfig?

    public var regionId: String?

    public var requestConfig: DescribeApiHistoryResponseBody.RequestConfig?

    public var requestId: String?

    public var requestParameters: DescribeApiHistoryResponseBody.RequestParameters?

    public var resultBodyModel: String?

    public var resultDescriptions: DescribeApiHistoryResponseBody.ResultDescriptions?

    public var resultSample: String?

    public var resultType: String?

    public var serviceConfig: DescribeApiHistoryResponseBody.ServiceConfig?

    public var serviceParameters: DescribeApiHistoryResponseBody.ServiceParameters?

    public var serviceParametersMap: DescribeApiHistoryResponseBody.ServiceParametersMap?

    public var stageName: String?

    public var status: String?

    public var systemParameters: DescribeApiHistoryResponseBody.SystemParameters?

    public var visibility: String?

    public var webSocketApiType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.backendConfig?.validate()
        try self.constantParameters?.validate()
        try self.customSystemParameters?.validate()
        try self.errorCodeSamples?.validate()
        try self.openIdConnectConfig?.validate()
        try self.requestConfig?.validate()
        try self.requestParameters?.validate()
        try self.resultDescriptions?.validate()
        try self.serviceConfig?.validate()
        try self.serviceParameters?.validate()
        try self.serviceParametersMap?.validate()
        try self.systemParameters?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.allowSignatureMethod != nil {
            map["AllowSignatureMethod"] = self.allowSignatureMethod!
        }
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.apiName != nil {
            map["ApiName"] = self.apiName!
        }
        if self.appCodeAuthType != nil {
            map["AppCodeAuthType"] = self.appCodeAuthType!
        }
        if self.authType != nil {
            map["AuthType"] = self.authType!
        }
        if self.backendConfig != nil {
            map["BackendConfig"] = self.backendConfig?.toMap()
        }
        if self.backendEnable != nil {
            map["BackendEnable"] = self.backendEnable!
        }
        if self.constantParameters != nil {
            map["ConstantParameters"] = self.constantParameters?.toMap()
        }
        if self.customSystemParameters != nil {
            map["CustomSystemParameters"] = self.customSystemParameters?.toMap()
        }
        if self.deployedTime != nil {
            map["DeployedTime"] = self.deployedTime!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.disableInternet != nil {
            map["DisableInternet"] = self.disableInternet!
        }
        if self.errorCodeSamples != nil {
            map["ErrorCodeSamples"] = self.errorCodeSamples?.toMap()
        }
        if self.failResultSample != nil {
            map["FailResultSample"] = self.failResultSample!
        }
        if self.forceNonceCheck != nil {
            map["ForceNonceCheck"] = self.forceNonceCheck!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.historyVersion != nil {
            map["HistoryVersion"] = self.historyVersion!
        }
        if self.openIdConnectConfig != nil {
            map["OpenIdConnectConfig"] = self.openIdConnectConfig?.toMap()
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestConfig != nil {
            map["RequestConfig"] = self.requestConfig?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.requestParameters != nil {
            map["RequestParameters"] = self.requestParameters?.toMap()
        }
        if self.resultBodyModel != nil {
            map["ResultBodyModel"] = self.resultBodyModel!
        }
        if self.resultDescriptions != nil {
            map["ResultDescriptions"] = self.resultDescriptions?.toMap()
        }
        if self.resultSample != nil {
            map["ResultSample"] = self.resultSample!
        }
        if self.resultType != nil {
            map["ResultType"] = self.resultType!
        }
        if self.serviceConfig != nil {
            map["ServiceConfig"] = self.serviceConfig?.toMap()
        }
        if self.serviceParameters != nil {
            map["ServiceParameters"] = self.serviceParameters?.toMap()
        }
        if self.serviceParametersMap != nil {
            map["ServiceParametersMap"] = self.serviceParametersMap?.toMap()
        }
        if self.stageName != nil {
            map["StageName"] = self.stageName!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.systemParameters != nil {
            map["SystemParameters"] = self.systemParameters?.toMap()
        }
        if self.visibility != nil {
            map["Visibility"] = self.visibility!
        }
        if self.webSocketApiType != nil {
            map["WebSocketApiType"] = self.webSocketApiType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AllowSignatureMethod") && dict["AllowSignatureMethod"] != nil {
            self.allowSignatureMethod = dict["AllowSignatureMethod"] as! String
        }
        if dict.keys.contains("ApiId") && dict["ApiId"] != nil {
            self.apiId = dict["ApiId"] as! String
        }
        if dict.keys.contains("ApiName") && dict["ApiName"] != nil {
            self.apiName = dict["ApiName"] as! String
        }
        if dict.keys.contains("AppCodeAuthType") && dict["AppCodeAuthType"] != nil {
            self.appCodeAuthType = dict["AppCodeAuthType"] as! String
        }
        if dict.keys.contains("AuthType") && dict["AuthType"] != nil {
            self.authType = dict["AuthType"] as! String
        }
        if dict.keys.contains("BackendConfig") && dict["BackendConfig"] != nil {
            var model = DescribeApiHistoryResponseBody.BackendConfig()
            model.fromMap(dict["BackendConfig"] as! [String: Any])
            self.backendConfig = model
        }
        if dict.keys.contains("BackendEnable") && dict["BackendEnable"] != nil {
            self.backendEnable = dict["BackendEnable"] as! Bool
        }
        if dict.keys.contains("ConstantParameters") && dict["ConstantParameters"] != nil {
            var model = DescribeApiHistoryResponseBody.ConstantParameters()
            model.fromMap(dict["ConstantParameters"] as! [String: Any])
            self.constantParameters = model
        }
        if dict.keys.contains("CustomSystemParameters") && dict["CustomSystemParameters"] != nil {
            var model = DescribeApiHistoryResponseBody.CustomSystemParameters()
            model.fromMap(dict["CustomSystemParameters"] as! [String: Any])
            self.customSystemParameters = model
        }
        if dict.keys.contains("DeployedTime") && dict["DeployedTime"] != nil {
            self.deployedTime = dict["DeployedTime"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DisableInternet") && dict["DisableInternet"] != nil {
            self.disableInternet = dict["DisableInternet"] as! Bool
        }
        if dict.keys.contains("ErrorCodeSamples") && dict["ErrorCodeSamples"] != nil {
            var model = DescribeApiHistoryResponseBody.ErrorCodeSamples()
            model.fromMap(dict["ErrorCodeSamples"] as! [String: Any])
            self.errorCodeSamples = model
        }
        if dict.keys.contains("FailResultSample") && dict["FailResultSample"] != nil {
            self.failResultSample = dict["FailResultSample"] as! String
        }
        if dict.keys.contains("ForceNonceCheck") && dict["ForceNonceCheck"] != nil {
            self.forceNonceCheck = dict["ForceNonceCheck"] as! Bool
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("HistoryVersion") && dict["HistoryVersion"] != nil {
            self.historyVersion = dict["HistoryVersion"] as! String
        }
        if dict.keys.contains("OpenIdConnectConfig") && dict["OpenIdConnectConfig"] != nil {
            var model = DescribeApiHistoryResponseBody.OpenIdConnectConfig()
            model.fromMap(dict["OpenIdConnectConfig"] as! [String: Any])
            self.openIdConnectConfig = model
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RequestConfig") && dict["RequestConfig"] != nil {
            var model = DescribeApiHistoryResponseBody.RequestConfig()
            model.fromMap(dict["RequestConfig"] as! [String: Any])
            self.requestConfig = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RequestParameters") && dict["RequestParameters"] != nil {
            var model = DescribeApiHistoryResponseBody.RequestParameters()
            model.fromMap(dict["RequestParameters"] as! [String: Any])
            self.requestParameters = model
        }
        if dict.keys.contains("ResultBodyModel") && dict["ResultBodyModel"] != nil {
            self.resultBodyModel = dict["ResultBodyModel"] as! String
        }
        if dict.keys.contains("ResultDescriptions") && dict["ResultDescriptions"] != nil {
            var model = DescribeApiHistoryResponseBody.ResultDescriptions()
            model.fromMap(dict["ResultDescriptions"] as! [String: Any])
            self.resultDescriptions = model
        }
        if dict.keys.contains("ResultSample") && dict["ResultSample"] != nil {
            self.resultSample = dict["ResultSample"] as! String
        }
        if dict.keys.contains("ResultType") && dict["ResultType"] != nil {
            self.resultType = dict["ResultType"] as! String
        }
        if dict.keys.contains("ServiceConfig") && dict["ServiceConfig"] != nil {
            var model = DescribeApiHistoryResponseBody.ServiceConfig()
            model.fromMap(dict["ServiceConfig"] as! [String: Any])
            self.serviceConfig = model
        }
        if dict.keys.contains("ServiceParameters") && dict["ServiceParameters"] != nil {
            var model = DescribeApiHistoryResponseBody.ServiceParameters()
            model.fromMap(dict["ServiceParameters"] as! [String: Any])
            self.serviceParameters = model
        }
        if dict.keys.contains("ServiceParametersMap") && dict["ServiceParametersMap"] != nil {
            var model = DescribeApiHistoryResponseBody.ServiceParametersMap()
            model.fromMap(dict["ServiceParametersMap"] as! [String: Any])
            self.serviceParametersMap = model
        }
        if dict.keys.contains("StageName") && dict["StageName"] != nil {
            self.stageName = dict["StageName"] as! String
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("SystemParameters") && dict["SystemParameters"] != nil {
            var model = DescribeApiHistoryResponseBody.SystemParameters()
            model.fromMap(dict["SystemParameters"] as! [String: Any])
            self.systemParameters = model
        }
        if dict.keys.contains("Visibility") && dict["Visibility"] != nil {
            self.visibility = dict["Visibility"] as! String
        }
        if dict.keys.contains("WebSocketApiType") && dict["WebSocketApiType"] != nil {
            self.webSocketApiType = dict["WebSocketApiType"] as! String
        }
    }
}

public class DescribeApiHistoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeApiHistoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeApiHistoryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeApiIpControlsRequest : Tea.TeaModel {
    public var apiIds: String?

    public var groupId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var securityToken: String?

    public var stageName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiIds != nil {
            map["ApiIds"] = self.apiIds!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.stageName != nil {
            map["StageName"] = self.stageName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiIds") && dict["ApiIds"] != nil {
            self.apiIds = dict["ApiIds"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StageName") && dict["StageName"] != nil {
            self.stageName = dict["StageName"] as! String
        }
    }
}

public class DescribeApiIpControlsResponseBody : Tea.TeaModel {
    public class ApiIpControls : Tea.TeaModel {
        public class ApiIpControlItem : Tea.TeaModel {
            public var apiId: String?

            public var apiName: String?

            public var boundTime: String?

            public var ipControlId: String?

            public var ipControlName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.apiId != nil {
                    map["ApiId"] = self.apiId!
                }
                if self.apiName != nil {
                    map["ApiName"] = self.apiName!
                }
                if self.boundTime != nil {
                    map["BoundTime"] = self.boundTime!
                }
                if self.ipControlId != nil {
                    map["IpControlId"] = self.ipControlId!
                }
                if self.ipControlName != nil {
                    map["IpControlName"] = self.ipControlName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ApiId") && dict["ApiId"] != nil {
                    self.apiId = dict["ApiId"] as! String
                }
                if dict.keys.contains("ApiName") && dict["ApiName"] != nil {
                    self.apiName = dict["ApiName"] as! String
                }
                if dict.keys.contains("BoundTime") && dict["BoundTime"] != nil {
                    self.boundTime = dict["BoundTime"] as! String
                }
                if dict.keys.contains("IpControlId") && dict["IpControlId"] != nil {
                    self.ipControlId = dict["IpControlId"] as! String
                }
                if dict.keys.contains("IpControlName") && dict["IpControlName"] != nil {
                    self.ipControlName = dict["IpControlName"] as! String
                }
            }
        }
        public var apiIpControlItem: [DescribeApiIpControlsResponseBody.ApiIpControls.ApiIpControlItem]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apiIpControlItem != nil {
                var tmp : [Any] = []
                for k in self.apiIpControlItem! {
                    tmp.append(k.toMap())
                }
                map["ApiIpControlItem"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApiIpControlItem") && dict["ApiIpControlItem"] != nil {
                var tmp : [DescribeApiIpControlsResponseBody.ApiIpControls.ApiIpControlItem] = []
                for v in dict["ApiIpControlItem"] as! [Any] {
                    var model = DescribeApiIpControlsResponseBody.ApiIpControls.ApiIpControlItem()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.apiIpControlItem = tmp
            }
        }
    }
    public var apiIpControls: DescribeApiIpControlsResponseBody.ApiIpControls?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.apiIpControls?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiIpControls != nil {
            map["ApiIpControls"] = self.apiIpControls?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiIpControls") && dict["ApiIpControls"] != nil {
            var model = DescribeApiIpControlsResponseBody.ApiIpControls()
            model.fromMap(dict["ApiIpControls"] as! [String: Any])
            self.apiIpControls = model
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeApiIpControlsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeApiIpControlsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeApiIpControlsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeApiLatencyDataRequest : Tea.TeaModel {
    public var apiId: String?

    public var endTime: String?

    public var groupId: String?

    public var securityToken: String?

    public var stageName: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.stageName != nil {
            map["StageName"] = self.stageName!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiId") && dict["ApiId"] != nil {
            self.apiId = dict["ApiId"] as! String
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StageName") && dict["StageName"] != nil {
            self.stageName = dict["StageName"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeApiLatencyDataResponseBody : Tea.TeaModel {
    public class CallLatencys : Tea.TeaModel {
        public class MonitorItem : Tea.TeaModel {
            public var itemTime: String?

            public var itemValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.itemTime != nil {
                    map["ItemTime"] = self.itemTime!
                }
                if self.itemValue != nil {
                    map["ItemValue"] = self.itemValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ItemTime") && dict["ItemTime"] != nil {
                    self.itemTime = dict["ItemTime"] as! String
                }
                if dict.keys.contains("ItemValue") && dict["ItemValue"] != nil {
                    self.itemValue = dict["ItemValue"] as! String
                }
            }
        }
        public var monitorItem: [DescribeApiLatencyDataResponseBody.CallLatencys.MonitorItem]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.monitorItem != nil {
                var tmp : [Any] = []
                for k in self.monitorItem! {
                    tmp.append(k.toMap())
                }
                map["MonitorItem"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MonitorItem") && dict["MonitorItem"] != nil {
                var tmp : [DescribeApiLatencyDataResponseBody.CallLatencys.MonitorItem] = []
                for v in dict["MonitorItem"] as! [Any] {
                    var model = DescribeApiLatencyDataResponseBody.CallLatencys.MonitorItem()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.monitorItem = tmp
            }
        }
    }
    public var callLatencys: DescribeApiLatencyDataResponseBody.CallLatencys?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.callLatencys?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.callLatencys != nil {
            map["CallLatencys"] = self.callLatencys?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CallLatencys") && dict["CallLatencys"] != nil {
            var model = DescribeApiLatencyDataResponseBody.CallLatencys()
            model.fromMap(dict["CallLatencys"] as! [String: Any])
            self.callLatencys = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeApiLatencyDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeApiLatencyDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeApiLatencyDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeApiMarketAttributesRequest : Tea.TeaModel {
    public var apiId: String?

    public var groupId: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiId") && dict["ApiId"] != nil {
            self.apiId = dict["ApiId"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DescribeApiMarketAttributesResponseBody : Tea.TeaModel {
    public var apiId: String?

    public var marketChargingMode: String?

    public var needCharging: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.marketChargingMode != nil {
            map["MarketChargingMode"] = self.marketChargingMode!
        }
        if self.needCharging != nil {
            map["NeedCharging"] = self.needCharging!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiId") && dict["ApiId"] != nil {
            self.apiId = dict["ApiId"] as! String
        }
        if dict.keys.contains("MarketChargingMode") && dict["MarketChargingMode"] != nil {
            self.marketChargingMode = dict["MarketChargingMode"] as! String
        }
        if dict.keys.contains("NeedCharging") && dict["NeedCharging"] != nil {
            self.needCharging = dict["NeedCharging"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeApiMarketAttributesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeApiMarketAttributesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeApiMarketAttributesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeApiProductApisRequest : Tea.TeaModel {
    public var apiProductId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiProductId != nil {
            map["ApiProductId"] = self.apiProductId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiProductId") && dict["ApiProductId"] != nil {
            self.apiProductId = dict["ApiProductId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DescribeApiProductApisResponseBody : Tea.TeaModel {
    public class ApiInfoList : Tea.TeaModel {
        public class ApiInfo : Tea.TeaModel {
            public var apiId: String?

            public var apiName: String?

            public var description_: String?

            public var groupId: String?

            public var groupName: String?

            public var method: String?

            public var path: String?

            public var regionId: String?

            public var stageName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.apiId != nil {
                    map["ApiId"] = self.apiId!
                }
                if self.apiName != nil {
                    map["ApiName"] = self.apiName!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.method != nil {
                    map["Method"] = self.method!
                }
                if self.path != nil {
                    map["Path"] = self.path!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.stageName != nil {
                    map["StageName"] = self.stageName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ApiId") && dict["ApiId"] != nil {
                    self.apiId = dict["ApiId"] as! String
                }
                if dict.keys.contains("ApiName") && dict["ApiName"] != nil {
                    self.apiName = dict["ApiName"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
                    self.groupName = dict["GroupName"] as! String
                }
                if dict.keys.contains("Method") && dict["Method"] != nil {
                    self.method = dict["Method"] as! String
                }
                if dict.keys.contains("Path") && dict["Path"] != nil {
                    self.path = dict["Path"] as! String
                }
                if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("StageName") && dict["StageName"] != nil {
                    self.stageName = dict["StageName"] as! String
                }
            }
        }
        public var apiInfo: [DescribeApiProductApisResponseBody.ApiInfoList.ApiInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apiInfo != nil {
                var tmp : [Any] = []
                for k in self.apiInfo! {
                    tmp.append(k.toMap())
                }
                map["ApiInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApiInfo") && dict["ApiInfo"] != nil {
                var tmp : [DescribeApiProductApisResponseBody.ApiInfoList.ApiInfo] = []
                for v in dict["ApiInfo"] as! [Any] {
                    var model = DescribeApiProductApisResponseBody.ApiInfoList.ApiInfo()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.apiInfo = tmp
            }
        }
    }
    public var apiInfoList: DescribeApiProductApisResponseBody.ApiInfoList?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.apiInfoList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiInfoList != nil {
            map["ApiInfoList"] = self.apiInfoList?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiInfoList") && dict["ApiInfoList"] != nil {
            var model = DescribeApiProductApisResponseBody.ApiInfoList()
            model.fromMap(dict["ApiInfoList"] as! [String: Any])
            self.apiInfoList = model
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeApiProductApisResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeApiProductApisResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeApiProductApisResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeApiProductsByAppRequest : Tea.TeaModel {
    public var appId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! Int64
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DescribeApiProductsByAppResponseBody : Tea.TeaModel {
    public class ApiProductInfoList : Tea.TeaModel {
        public class ApiProductInfo : Tea.TeaModel {
            public var apiProductId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.apiProductId != nil {
                    map["ApiProductId"] = self.apiProductId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ApiProductId") && dict["ApiProductId"] != nil {
                    self.apiProductId = dict["ApiProductId"] as! String
                }
            }
        }
        public var apiProductInfo: [DescribeApiProductsByAppResponseBody.ApiProductInfoList.ApiProductInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apiProductInfo != nil {
                var tmp : [Any] = []
                for k in self.apiProductInfo! {
                    tmp.append(k.toMap())
                }
                map["ApiProductInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApiProductInfo") && dict["ApiProductInfo"] != nil {
                var tmp : [DescribeApiProductsByAppResponseBody.ApiProductInfoList.ApiProductInfo] = []
                for v in dict["ApiProductInfo"] as! [Any] {
                    var model = DescribeApiProductsByAppResponseBody.ApiProductInfoList.ApiProductInfo()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.apiProductInfo = tmp
            }
        }
    }
    public var apiProductInfoList: DescribeApiProductsByAppResponseBody.ApiProductInfoList?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.apiProductInfoList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiProductInfoList != nil {
            map["ApiProductInfoList"] = self.apiProductInfoList?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiProductInfoList") && dict["ApiProductInfoList"] != nil {
            var model = DescribeApiProductsByAppResponseBody.ApiProductInfoList()
            model.fromMap(dict["ApiProductInfoList"] as! [String: Any])
            self.apiProductInfoList = model
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeApiProductsByAppResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeApiProductsByAppResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeApiProductsByAppResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeApiQpsDataRequest : Tea.TeaModel {
    public var apiId: String?

    public var endTime: String?

    public var groupId: String?

    public var securityToken: String?

    public var stageName: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.stageName != nil {
            map["StageName"] = self.stageName!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiId") && dict["ApiId"] != nil {
            self.apiId = dict["ApiId"] as! String
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StageName") && dict["StageName"] != nil {
            self.stageName = dict["StageName"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeApiQpsDataResponseBody : Tea.TeaModel {
    public class CallFails : Tea.TeaModel {
        public class MonitorItem : Tea.TeaModel {
            public var itemTime: String?

            public var itemValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.itemTime != nil {
                    map["ItemTime"] = self.itemTime!
                }
                if self.itemValue != nil {
                    map["ItemValue"] = self.itemValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ItemTime") && dict["ItemTime"] != nil {
                    self.itemTime = dict["ItemTime"] as! String
                }
                if dict.keys.contains("ItemValue") && dict["ItemValue"] != nil {
                    self.itemValue = dict["ItemValue"] as! String
                }
            }
        }
        public var monitorItem: [DescribeApiQpsDataResponseBody.CallFails.MonitorItem]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.monitorItem != nil {
                var tmp : [Any] = []
                for k in self.monitorItem! {
                    tmp.append(k.toMap())
                }
                map["MonitorItem"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MonitorItem") && dict["MonitorItem"] != nil {
                var tmp : [DescribeApiQpsDataResponseBody.CallFails.MonitorItem] = []
                for v in dict["MonitorItem"] as! [Any] {
                    var model = DescribeApiQpsDataResponseBody.CallFails.MonitorItem()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.monitorItem = tmp
            }
        }
    }
    public class CallSuccesses : Tea.TeaModel {
        public class MonitorItem : Tea.TeaModel {
            public var itemTime: String?

            public var itemValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.itemTime != nil {
                    map["ItemTime"] = self.itemTime!
                }
                if self.itemValue != nil {
                    map["ItemValue"] = self.itemValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ItemTime") && dict["ItemTime"] != nil {
                    self.itemTime = dict["ItemTime"] as! String
                }
                if dict.keys.contains("ItemValue") && dict["ItemValue"] != nil {
                    self.itemValue = dict["ItemValue"] as! String
                }
            }
        }
        public var monitorItem: [DescribeApiQpsDataResponseBody.CallSuccesses.MonitorItem]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.monitorItem != nil {
                var tmp : [Any] = []
                for k in self.monitorItem! {
                    tmp.append(k.toMap())
                }
                map["MonitorItem"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MonitorItem") && dict["MonitorItem"] != nil {
                var tmp : [DescribeApiQpsDataResponseBody.CallSuccesses.MonitorItem] = []
                for v in dict["MonitorItem"] as! [Any] {
                    var model = DescribeApiQpsDataResponseBody.CallSuccesses.MonitorItem()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.monitorItem = tmp
            }
        }
    }
    public var callFails: DescribeApiQpsDataResponseBody.CallFails?

    public var callSuccesses: DescribeApiQpsDataResponseBody.CallSuccesses?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.callFails?.validate()
        try self.callSuccesses?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.callFails != nil {
            map["CallFails"] = self.callFails?.toMap()
        }
        if self.callSuccesses != nil {
            map["CallSuccesses"] = self.callSuccesses?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CallFails") && dict["CallFails"] != nil {
            var model = DescribeApiQpsDataResponseBody.CallFails()
            model.fromMap(dict["CallFails"] as! [String: Any])
            self.callFails = model
        }
        if dict.keys.contains("CallSuccesses") && dict["CallSuccesses"] != nil {
            var model = DescribeApiQpsDataResponseBody.CallSuccesses()
            model.fromMap(dict["CallSuccesses"] as! [String: Any])
            self.callSuccesses = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeApiQpsDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeApiQpsDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeApiQpsDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeApiSignaturesRequest : Tea.TeaModel {
    public var apiIds: String?

    public var groupId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var securityToken: String?

    public var stageName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiIds != nil {
            map["ApiIds"] = self.apiIds!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.stageName != nil {
            map["StageName"] = self.stageName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiIds") && dict["ApiIds"] != nil {
            self.apiIds = dict["ApiIds"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StageName") && dict["StageName"] != nil {
            self.stageName = dict["StageName"] as! String
        }
    }
}

public class DescribeApiSignaturesResponseBody : Tea.TeaModel {
    public class ApiSignatures : Tea.TeaModel {
        public class ApiSignatureItem : Tea.TeaModel {
            public var apiId: String?

            public var apiName: String?

            public var boundTime: String?

            public var signatureId: String?

            public var signatureName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.apiId != nil {
                    map["ApiId"] = self.apiId!
                }
                if self.apiName != nil {
                    map["ApiName"] = self.apiName!
                }
                if self.boundTime != nil {
                    map["BoundTime"] = self.boundTime!
                }
                if self.signatureId != nil {
                    map["SignatureId"] = self.signatureId!
                }
                if self.signatureName != nil {
                    map["SignatureName"] = self.signatureName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ApiId") && dict["ApiId"] != nil {
                    self.apiId = dict["ApiId"] as! String
                }
                if dict.keys.contains("ApiName") && dict["ApiName"] != nil {
                    self.apiName = dict["ApiName"] as! String
                }
                if dict.keys.contains("BoundTime") && dict["BoundTime"] != nil {
                    self.boundTime = dict["BoundTime"] as! String
                }
                if dict.keys.contains("SignatureId") && dict["SignatureId"] != nil {
                    self.signatureId = dict["SignatureId"] as! String
                }
                if dict.keys.contains("SignatureName") && dict["SignatureName"] != nil {
                    self.signatureName = dict["SignatureName"] as! String
                }
            }
        }
        public var apiSignatureItem: [DescribeApiSignaturesResponseBody.ApiSignatures.ApiSignatureItem]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apiSignatureItem != nil {
                var tmp : [Any] = []
                for k in self.apiSignatureItem! {
                    tmp.append(k.toMap())
                }
                map["ApiSignatureItem"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApiSignatureItem") && dict["ApiSignatureItem"] != nil {
                var tmp : [DescribeApiSignaturesResponseBody.ApiSignatures.ApiSignatureItem] = []
                for v in dict["ApiSignatureItem"] as! [Any] {
                    var model = DescribeApiSignaturesResponseBody.ApiSignatures.ApiSignatureItem()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.apiSignatureItem = tmp
            }
        }
    }
    public var apiSignatures: DescribeApiSignaturesResponseBody.ApiSignatures?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.apiSignatures?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiSignatures != nil {
            map["ApiSignatures"] = self.apiSignatures?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiSignatures") && dict["ApiSignatures"] != nil {
            var model = DescribeApiSignaturesResponseBody.ApiSignatures()
            model.fromMap(dict["ApiSignatures"] as! [String: Any])
            self.apiSignatures = model
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeApiSignaturesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeApiSignaturesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeApiSignaturesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeApiTrafficControlsRequest : Tea.TeaModel {
    public var apiIds: String?

    public var groupId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var securityToken: String?

    public var stageName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiIds != nil {
            map["ApiIds"] = self.apiIds!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.stageName != nil {
            map["StageName"] = self.stageName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiIds") && dict["ApiIds"] != nil {
            self.apiIds = dict["ApiIds"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StageName") && dict["StageName"] != nil {
            self.stageName = dict["StageName"] as! String
        }
    }
}

public class DescribeApiTrafficControlsResponseBody : Tea.TeaModel {
    public class ApiTrafficControls : Tea.TeaModel {
        public class ApiTrafficControlItem : Tea.TeaModel {
            public var apiId: String?

            public var apiName: String?

            public var boundTime: String?

            public var trafficControlId: String?

            public var trafficControlName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.apiId != nil {
                    map["ApiId"] = self.apiId!
                }
                if self.apiName != nil {
                    map["ApiName"] = self.apiName!
                }
                if self.boundTime != nil {
                    map["BoundTime"] = self.boundTime!
                }
                if self.trafficControlId != nil {
                    map["TrafficControlId"] = self.trafficControlId!
                }
                if self.trafficControlName != nil {
                    map["TrafficControlName"] = self.trafficControlName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ApiId") && dict["ApiId"] != nil {
                    self.apiId = dict["ApiId"] as! String
                }
                if dict.keys.contains("ApiName") && dict["ApiName"] != nil {
                    self.apiName = dict["ApiName"] as! String
                }
                if dict.keys.contains("BoundTime") && dict["BoundTime"] != nil {
                    self.boundTime = dict["BoundTime"] as! String
                }
                if dict.keys.contains("TrafficControlId") && dict["TrafficControlId"] != nil {
                    self.trafficControlId = dict["TrafficControlId"] as! String
                }
                if dict.keys.contains("TrafficControlName") && dict["TrafficControlName"] != nil {
                    self.trafficControlName = dict["TrafficControlName"] as! String
                }
            }
        }
        public var apiTrafficControlItem: [DescribeApiTrafficControlsResponseBody.ApiTrafficControls.ApiTrafficControlItem]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apiTrafficControlItem != nil {
                var tmp : [Any] = []
                for k in self.apiTrafficControlItem! {
                    tmp.append(k.toMap())
                }
                map["ApiTrafficControlItem"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApiTrafficControlItem") && dict["ApiTrafficControlItem"] != nil {
                var tmp : [DescribeApiTrafficControlsResponseBody.ApiTrafficControls.ApiTrafficControlItem] = []
                for v in dict["ApiTrafficControlItem"] as! [Any] {
                    var model = DescribeApiTrafficControlsResponseBody.ApiTrafficControls.ApiTrafficControlItem()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.apiTrafficControlItem = tmp
            }
        }
    }
    public var apiTrafficControls: DescribeApiTrafficControlsResponseBody.ApiTrafficControls?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.apiTrafficControls?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiTrafficControls != nil {
            map["ApiTrafficControls"] = self.apiTrafficControls?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiTrafficControls") && dict["ApiTrafficControls"] != nil {
            var model = DescribeApiTrafficControlsResponseBody.ApiTrafficControls()
            model.fromMap(dict["ApiTrafficControls"] as! [String: Any])
            self.apiTrafficControls = model
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeApiTrafficControlsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeApiTrafficControlsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeApiTrafficControlsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeApiTrafficDataRequest : Tea.TeaModel {
    public var apiId: String?

    public var endTime: String?

    public var groupId: String?

    public var securityToken: String?

    public var stageName: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.stageName != nil {
            map["StageName"] = self.stageName!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiId") && dict["ApiId"] != nil {
            self.apiId = dict["ApiId"] as! String
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StageName") && dict["StageName"] != nil {
            self.stageName = dict["StageName"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeApiTrafficDataResponseBody : Tea.TeaModel {
    public class CallDownloads : Tea.TeaModel {
        public class MonitorItem : Tea.TeaModel {
            public var itemTime: String?

            public var itemValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.itemTime != nil {
                    map["ItemTime"] = self.itemTime!
                }
                if self.itemValue != nil {
                    map["ItemValue"] = self.itemValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ItemTime") && dict["ItemTime"] != nil {
                    self.itemTime = dict["ItemTime"] as! String
                }
                if dict.keys.contains("ItemValue") && dict["ItemValue"] != nil {
                    self.itemValue = dict["ItemValue"] as! String
                }
            }
        }
        public var monitorItem: [DescribeApiTrafficDataResponseBody.CallDownloads.MonitorItem]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.monitorItem != nil {
                var tmp : [Any] = []
                for k in self.monitorItem! {
                    tmp.append(k.toMap())
                }
                map["MonitorItem"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MonitorItem") && dict["MonitorItem"] != nil {
                var tmp : [DescribeApiTrafficDataResponseBody.CallDownloads.MonitorItem] = []
                for v in dict["MonitorItem"] as! [Any] {
                    var model = DescribeApiTrafficDataResponseBody.CallDownloads.MonitorItem()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.monitorItem = tmp
            }
        }
    }
    public class CallUploads : Tea.TeaModel {
        public class MonitorItem : Tea.TeaModel {
            public var itemTime: String?

            public var itemValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.itemTime != nil {
                    map["ItemTime"] = self.itemTime!
                }
                if self.itemValue != nil {
                    map["ItemValue"] = self.itemValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ItemTime") && dict["ItemTime"] != nil {
                    self.itemTime = dict["ItemTime"] as! String
                }
                if dict.keys.contains("ItemValue") && dict["ItemValue"] != nil {
                    self.itemValue = dict["ItemValue"] as! String
                }
            }
        }
        public var monitorItem: [DescribeApiTrafficDataResponseBody.CallUploads.MonitorItem]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.monitorItem != nil {
                var tmp : [Any] = []
                for k in self.monitorItem! {
                    tmp.append(k.toMap())
                }
                map["MonitorItem"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MonitorItem") && dict["MonitorItem"] != nil {
                var tmp : [DescribeApiTrafficDataResponseBody.CallUploads.MonitorItem] = []
                for v in dict["MonitorItem"] as! [Any] {
                    var model = DescribeApiTrafficDataResponseBody.CallUploads.MonitorItem()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.monitorItem = tmp
            }
        }
    }
    public var callDownloads: DescribeApiTrafficDataResponseBody.CallDownloads?

    public var callUploads: DescribeApiTrafficDataResponseBody.CallUploads?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.callDownloads?.validate()
        try self.callUploads?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.callDownloads != nil {
            map["CallDownloads"] = self.callDownloads?.toMap()
        }
        if self.callUploads != nil {
            map["CallUploads"] = self.callUploads?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CallDownloads") && dict["CallDownloads"] != nil {
            var model = DescribeApiTrafficDataResponseBody.CallDownloads()
            model.fromMap(dict["CallDownloads"] as! [String: Any])
            self.callDownloads = model
        }
        if dict.keys.contains("CallUploads") && dict["CallUploads"] != nil {
            var model = DescribeApiTrafficDataResponseBody.CallUploads()
            model.fromMap(dict["CallUploads"] as! [String: Any])
            self.callUploads = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeApiTrafficDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeApiTrafficDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeApiTrafficDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeApisRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var apiId: String?

    public var apiMethod: String?

    public var apiName: String?

    public var apiPath: String?

    public var catalogId: String?

    public var enableTagAuth: Bool?

    public var groupId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var securityToken: String?

    public var stageName: String?

    public var tag: [DescribeApisRequest.Tag]?

    public var unDeployed: Bool?

    public var visibility: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.apiMethod != nil {
            map["ApiMethod"] = self.apiMethod!
        }
        if self.apiName != nil {
            map["ApiName"] = self.apiName!
        }
        if self.apiPath != nil {
            map["ApiPath"] = self.apiPath!
        }
        if self.catalogId != nil {
            map["CatalogId"] = self.catalogId!
        }
        if self.enableTagAuth != nil {
            map["EnableTagAuth"] = self.enableTagAuth!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.stageName != nil {
            map["StageName"] = self.stageName!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.unDeployed != nil {
            map["UnDeployed"] = self.unDeployed!
        }
        if self.visibility != nil {
            map["Visibility"] = self.visibility!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiId") && dict["ApiId"] != nil {
            self.apiId = dict["ApiId"] as! String
        }
        if dict.keys.contains("ApiMethod") && dict["ApiMethod"] != nil {
            self.apiMethod = dict["ApiMethod"] as! String
        }
        if dict.keys.contains("ApiName") && dict["ApiName"] != nil {
            self.apiName = dict["ApiName"] as! String
        }
        if dict.keys.contains("ApiPath") && dict["ApiPath"] != nil {
            self.apiPath = dict["ApiPath"] as! String
        }
        if dict.keys.contains("CatalogId") && dict["CatalogId"] != nil {
            self.catalogId = dict["CatalogId"] as! String
        }
        if dict.keys.contains("EnableTagAuth") && dict["EnableTagAuth"] != nil {
            self.enableTagAuth = dict["EnableTagAuth"] as! Bool
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StageName") && dict["StageName"] != nil {
            self.stageName = dict["StageName"] as! String
        }
        if dict.keys.contains("Tag") && dict["Tag"] != nil {
            var tmp : [DescribeApisRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = DescribeApisRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("UnDeployed") && dict["UnDeployed"] != nil {
            self.unDeployed = dict["UnDeployed"] as! Bool
        }
        if dict.keys.contains("Visibility") && dict["Visibility"] != nil {
            self.visibility = dict["Visibility"] as! String
        }
    }
}

public class DescribeApisResponseBody : Tea.TeaModel {
    public class ApiSummarys : Tea.TeaModel {
        public class ApiSummary : Tea.TeaModel {
            public class DeployedInfos : Tea.TeaModel {
                public class DeployedInfo : Tea.TeaModel {
                    public var deployedStatus: String?

                    public var effectiveVersion: String?

                    public var stageName: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.deployedStatus != nil {
                            map["DeployedStatus"] = self.deployedStatus!
                        }
                        if self.effectiveVersion != nil {
                            map["EffectiveVersion"] = self.effectiveVersion!
                        }
                        if self.stageName != nil {
                            map["StageName"] = self.stageName!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("DeployedStatus") && dict["DeployedStatus"] != nil {
                            self.deployedStatus = dict["DeployedStatus"] as! String
                        }
                        if dict.keys.contains("EffectiveVersion") && dict["EffectiveVersion"] != nil {
                            self.effectiveVersion = dict["EffectiveVersion"] as! String
                        }
                        if dict.keys.contains("StageName") && dict["StageName"] != nil {
                            self.stageName = dict["StageName"] as! String
                        }
                    }
                }
                public var deployedInfo: [DescribeApisResponseBody.ApiSummarys.ApiSummary.DeployedInfos.DeployedInfo]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.deployedInfo != nil {
                        var tmp : [Any] = []
                        for k in self.deployedInfo! {
                            tmp.append(k.toMap())
                        }
                        map["DeployedInfo"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DeployedInfo") && dict["DeployedInfo"] != nil {
                        var tmp : [DescribeApisResponseBody.ApiSummarys.ApiSummary.DeployedInfos.DeployedInfo] = []
                        for v in dict["DeployedInfo"] as! [Any] {
                            var model = DescribeApisResponseBody.ApiSummarys.ApiSummary.DeployedInfos.DeployedInfo()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.deployedInfo = tmp
                    }
                }
            }
            public class TagList : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var tagKey: String?

                    public var tagValue: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.tagKey != nil {
                            map["TagKey"] = self.tagKey!
                        }
                        if self.tagValue != nil {
                            map["TagValue"] = self.tagValue!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("TagKey") && dict["TagKey"] != nil {
                            self.tagKey = dict["TagKey"] as! String
                        }
                        if dict.keys.contains("TagValue") && dict["TagValue"] != nil {
                            self.tagValue = dict["TagValue"] as! String
                        }
                    }
                }
                public var tag: [DescribeApisResponseBody.ApiSummarys.ApiSummary.TagList.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Tag") && dict["Tag"] != nil {
                        var tmp : [DescribeApisResponseBody.ApiSummarys.ApiSummary.TagList.Tag] = []
                        for v in dict["Tag"] as! [Any] {
                            var model = DescribeApisResponseBody.ApiSummarys.ApiSummary.TagList.Tag()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.tag = tmp
                    }
                }
            }
            public var apiId: String?

            public var apiMethod: String?

            public var apiName: String?

            public var apiPath: String?

            public var createdTime: String?

            public var deployedInfos: DescribeApisResponseBody.ApiSummarys.ApiSummary.DeployedInfos?

            public var description_: String?

            public var groupId: String?

            public var groupName: String?

            public var modifiedTime: String?

            public var regionId: String?

            public var tagList: DescribeApisResponseBody.ApiSummarys.ApiSummary.TagList?

            public var visibility: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.deployedInfos?.validate()
                try self.tagList?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.apiId != nil {
                    map["ApiId"] = self.apiId!
                }
                if self.apiMethod != nil {
                    map["ApiMethod"] = self.apiMethod!
                }
                if self.apiName != nil {
                    map["ApiName"] = self.apiName!
                }
                if self.apiPath != nil {
                    map["ApiPath"] = self.apiPath!
                }
                if self.createdTime != nil {
                    map["CreatedTime"] = self.createdTime!
                }
                if self.deployedInfos != nil {
                    map["DeployedInfos"] = self.deployedInfos?.toMap()
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.modifiedTime != nil {
                    map["ModifiedTime"] = self.modifiedTime!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.tagList != nil {
                    map["TagList"] = self.tagList?.toMap()
                }
                if self.visibility != nil {
                    map["Visibility"] = self.visibility!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ApiId") && dict["ApiId"] != nil {
                    self.apiId = dict["ApiId"] as! String
                }
                if dict.keys.contains("ApiMethod") && dict["ApiMethod"] != nil {
                    self.apiMethod = dict["ApiMethod"] as! String
                }
                if dict.keys.contains("ApiName") && dict["ApiName"] != nil {
                    self.apiName = dict["ApiName"] as! String
                }
                if dict.keys.contains("ApiPath") && dict["ApiPath"] != nil {
                    self.apiPath = dict["ApiPath"] as! String
                }
                if dict.keys.contains("CreatedTime") && dict["CreatedTime"] != nil {
                    self.createdTime = dict["CreatedTime"] as! String
                }
                if dict.keys.contains("DeployedInfos") && dict["DeployedInfos"] != nil {
                    var model = DescribeApisResponseBody.ApiSummarys.ApiSummary.DeployedInfos()
                    model.fromMap(dict["DeployedInfos"] as! [String: Any])
                    self.deployedInfos = model
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
                    self.groupName = dict["GroupName"] as! String
                }
                if dict.keys.contains("ModifiedTime") && dict["ModifiedTime"] != nil {
                    self.modifiedTime = dict["ModifiedTime"] as! String
                }
                if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("TagList") && dict["TagList"] != nil {
                    var model = DescribeApisResponseBody.ApiSummarys.ApiSummary.TagList()
                    model.fromMap(dict["TagList"] as! [String: Any])
                    self.tagList = model
                }
                if dict.keys.contains("Visibility") && dict["Visibility"] != nil {
                    self.visibility = dict["Visibility"] as! String
                }
            }
        }
        public var apiSummary: [DescribeApisResponseBody.ApiSummarys.ApiSummary]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apiSummary != nil {
                var tmp : [Any] = []
                for k in self.apiSummary! {
                    tmp.append(k.toMap())
                }
                map["ApiSummary"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApiSummary") && dict["ApiSummary"] != nil {
                var tmp : [DescribeApisResponseBody.ApiSummarys.ApiSummary] = []
                for v in dict["ApiSummary"] as! [Any] {
                    var model = DescribeApisResponseBody.ApiSummarys.ApiSummary()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.apiSummary = tmp
            }
        }
    }
    public var apiSummarys: DescribeApisResponseBody.ApiSummarys?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.apiSummarys?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiSummarys != nil {
            map["ApiSummarys"] = self.apiSummarys?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiSummarys") && dict["ApiSummarys"] != nil {
            var model = DescribeApisResponseBody.ApiSummarys()
            model.fromMap(dict["ApiSummarys"] as! [String: Any])
            self.apiSummarys = model
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeApisResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeApisResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeApisResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeApisByAppRequest : Tea.TeaModel {
    public var apiName: String?

    public var apiUid: String?

    public var appId: Int64?

    public var description_: String?

    public var method: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var path: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiName != nil {
            map["ApiName"] = self.apiName!
        }
        if self.apiUid != nil {
            map["ApiUid"] = self.apiUid!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.method != nil {
            map["Method"] = self.method!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.path != nil {
            map["Path"] = self.path!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiName") && dict["ApiName"] != nil {
            self.apiName = dict["ApiName"] as! String
        }
        if dict.keys.contains("ApiUid") && dict["ApiUid"] != nil {
            self.apiUid = dict["ApiUid"] as! String
        }
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! Int64
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Method") && dict["Method"] != nil {
            self.method = dict["Method"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Path") && dict["Path"] != nil {
            self.path = dict["Path"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DescribeApisByAppResponseBody : Tea.TeaModel {
    public class AppApiRelationInfos : Tea.TeaModel {
        public class AppApiRelationInfo : Tea.TeaModel {
            public var apiId: String?

            public var apiName: String?

            public var authVaildTime: String?

            public var authorizationSource: String?

            public var createdTime: String?

            public var description_: String?

            public var groupId: String?

            public var groupName: String?

            public var method: String?

            public var operator_: String?

            public var path: String?

            public var regionId: String?

            public var stageAlias: String?

            public var stageName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.apiId != nil {
                    map["ApiId"] = self.apiId!
                }
                if self.apiName != nil {
                    map["ApiName"] = self.apiName!
                }
                if self.authVaildTime != nil {
                    map["AuthVaildTime"] = self.authVaildTime!
                }
                if self.authorizationSource != nil {
                    map["AuthorizationSource"] = self.authorizationSource!
                }
                if self.createdTime != nil {
                    map["CreatedTime"] = self.createdTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.method != nil {
                    map["Method"] = self.method!
                }
                if self.operator_ != nil {
                    map["Operator"] = self.operator_!
                }
                if self.path != nil {
                    map["Path"] = self.path!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.stageAlias != nil {
                    map["StageAlias"] = self.stageAlias!
                }
                if self.stageName != nil {
                    map["StageName"] = self.stageName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ApiId") && dict["ApiId"] != nil {
                    self.apiId = dict["ApiId"] as! String
                }
                if dict.keys.contains("ApiName") && dict["ApiName"] != nil {
                    self.apiName = dict["ApiName"] as! String
                }
                if dict.keys.contains("AuthVaildTime") && dict["AuthVaildTime"] != nil {
                    self.authVaildTime = dict["AuthVaildTime"] as! String
                }
                if dict.keys.contains("AuthorizationSource") && dict["AuthorizationSource"] != nil {
                    self.authorizationSource = dict["AuthorizationSource"] as! String
                }
                if dict.keys.contains("CreatedTime") && dict["CreatedTime"] != nil {
                    self.createdTime = dict["CreatedTime"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
                    self.groupName = dict["GroupName"] as! String
                }
                if dict.keys.contains("Method") && dict["Method"] != nil {
                    self.method = dict["Method"] as! String
                }
                if dict.keys.contains("Operator") && dict["Operator"] != nil {
                    self.operator_ = dict["Operator"] as! String
                }
                if dict.keys.contains("Path") && dict["Path"] != nil {
                    self.path = dict["Path"] as! String
                }
                if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("StageAlias") && dict["StageAlias"] != nil {
                    self.stageAlias = dict["StageAlias"] as! String
                }
                if dict.keys.contains("StageName") && dict["StageName"] != nil {
                    self.stageName = dict["StageName"] as! String
                }
            }
        }
        public var appApiRelationInfo: [DescribeApisByAppResponseBody.AppApiRelationInfos.AppApiRelationInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appApiRelationInfo != nil {
                var tmp : [Any] = []
                for k in self.appApiRelationInfo! {
                    tmp.append(k.toMap())
                }
                map["AppApiRelationInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppApiRelationInfo") && dict["AppApiRelationInfo"] != nil {
                var tmp : [DescribeApisByAppResponseBody.AppApiRelationInfos.AppApiRelationInfo] = []
                for v in dict["AppApiRelationInfo"] as! [Any] {
                    var model = DescribeApisByAppResponseBody.AppApiRelationInfos.AppApiRelationInfo()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.appApiRelationInfo = tmp
            }
        }
    }
    public var appApiRelationInfos: DescribeApisByAppResponseBody.AppApiRelationInfos?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.appApiRelationInfos?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appApiRelationInfos != nil {
            map["AppApiRelationInfos"] = self.appApiRelationInfos?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppApiRelationInfos") && dict["AppApiRelationInfos"] != nil {
            var model = DescribeApisByAppResponseBody.AppApiRelationInfos()
            model.fromMap(dict["AppApiRelationInfos"] as! [String: Any])
            self.appApiRelationInfos = model
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeApisByAppResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeApisByAppResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeApisByAppResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeApisByBackendRequest : Tea.TeaModel {
    public var backendId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var securityToken: String?

    public var stageName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backendId != nil {
            map["BackendId"] = self.backendId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.stageName != nil {
            map["StageName"] = self.stageName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BackendId") && dict["BackendId"] != nil {
            self.backendId = dict["BackendId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StageName") && dict["StageName"] != nil {
            self.stageName = dict["StageName"] as! String
        }
    }
}

public class DescribeApisByBackendResponseBody : Tea.TeaModel {
    public class ApiInfoList : Tea.TeaModel {
        public class ApiInfo : Tea.TeaModel {
            public var apiId: String?

            public var apiName: String?

            public var description_: String?

            public var groupId: String?

            public var groupName: String?

            public var method: String?

            public var path: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.apiId != nil {
                    map["ApiId"] = self.apiId!
                }
                if self.apiName != nil {
                    map["ApiName"] = self.apiName!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.method != nil {
                    map["Method"] = self.method!
                }
                if self.path != nil {
                    map["Path"] = self.path!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ApiId") && dict["ApiId"] != nil {
                    self.apiId = dict["ApiId"] as! String
                }
                if dict.keys.contains("ApiName") && dict["ApiName"] != nil {
                    self.apiName = dict["ApiName"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
                    self.groupName = dict["GroupName"] as! String
                }
                if dict.keys.contains("Method") && dict["Method"] != nil {
                    self.method = dict["Method"] as! String
                }
                if dict.keys.contains("Path") && dict["Path"] != nil {
                    self.path = dict["Path"] as! String
                }
            }
        }
        public var apiInfo: [DescribeApisByBackendResponseBody.ApiInfoList.ApiInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apiInfo != nil {
                var tmp : [Any] = []
                for k in self.apiInfo! {
                    tmp.append(k.toMap())
                }
                map["ApiInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApiInfo") && dict["ApiInfo"] != nil {
                var tmp : [DescribeApisByBackendResponseBody.ApiInfoList.ApiInfo] = []
                for v in dict["ApiInfo"] as! [Any] {
                    var model = DescribeApisByBackendResponseBody.ApiInfoList.ApiInfo()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.apiInfo = tmp
            }
        }
    }
    public var apiInfoList: DescribeApisByBackendResponseBody.ApiInfoList?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.apiInfoList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiInfoList != nil {
            map["ApiInfoList"] = self.apiInfoList?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiInfoList") && dict["ApiInfoList"] != nil {
            var model = DescribeApisByBackendResponseBody.ApiInfoList()
            model.fromMap(dict["ApiInfoList"] as! [String: Any])
            self.apiInfoList = model
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeApisByBackendResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeApisByBackendResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeApisByBackendResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeApisByIpControlRequest : Tea.TeaModel {
    public var ipControlId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ipControlId != nil {
            map["IpControlId"] = self.ipControlId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IpControlId") && dict["IpControlId"] != nil {
            self.ipControlId = dict["IpControlId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DescribeApisByIpControlResponseBody : Tea.TeaModel {
    public class ApiInfos : Tea.TeaModel {
        public class ApiInfo : Tea.TeaModel {
            public var apiId: String?

            public var apiName: String?

            public var boundTime: String?

            public var description_: String?

            public var groupId: String?

            public var groupName: String?

            public var regionId: String?

            public var stageName: String?

            public var visibility: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.apiId != nil {
                    map["ApiId"] = self.apiId!
                }
                if self.apiName != nil {
                    map["ApiName"] = self.apiName!
                }
                if self.boundTime != nil {
                    map["BoundTime"] = self.boundTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.stageName != nil {
                    map["StageName"] = self.stageName!
                }
                if self.visibility != nil {
                    map["Visibility"] = self.visibility!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ApiId") && dict["ApiId"] != nil {
                    self.apiId = dict["ApiId"] as! String
                }
                if dict.keys.contains("ApiName") && dict["ApiName"] != nil {
                    self.apiName = dict["ApiName"] as! String
                }
                if dict.keys.contains("BoundTime") && dict["BoundTime"] != nil {
                    self.boundTime = dict["BoundTime"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
                    self.groupName = dict["GroupName"] as! String
                }
                if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("StageName") && dict["StageName"] != nil {
                    self.stageName = dict["StageName"] as! String
                }
                if dict.keys.contains("Visibility") && dict["Visibility"] != nil {
                    self.visibility = dict["Visibility"] as! String
                }
            }
        }
        public var apiInfo: [DescribeApisByIpControlResponseBody.ApiInfos.ApiInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apiInfo != nil {
                var tmp : [Any] = []
                for k in self.apiInfo! {
                    tmp.append(k.toMap())
                }
                map["ApiInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApiInfo") && dict["ApiInfo"] != nil {
                var tmp : [DescribeApisByIpControlResponseBody.ApiInfos.ApiInfo] = []
                for v in dict["ApiInfo"] as! [Any] {
                    var model = DescribeApisByIpControlResponseBody.ApiInfos.ApiInfo()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.apiInfo = tmp
            }
        }
    }
    public var apiInfos: DescribeApisByIpControlResponseBody.ApiInfos?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.apiInfos?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiInfos != nil {
            map["ApiInfos"] = self.apiInfos?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiInfos") && dict["ApiInfos"] != nil {
            var model = DescribeApisByIpControlResponseBody.ApiInfos()
            model.fromMap(dict["ApiInfos"] as! [String: Any])
            self.apiInfos = model
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeApisByIpControlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeApisByIpControlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeApisByIpControlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeApisBySignatureRequest : Tea.TeaModel {
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var securityToken: String?

    public var signatureId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.signatureId != nil {
            map["SignatureId"] = self.signatureId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("SignatureId") && dict["SignatureId"] != nil {
            self.signatureId = dict["SignatureId"] as! String
        }
    }
}

public class DescribeApisBySignatureResponseBody : Tea.TeaModel {
    public class ApiInfos : Tea.TeaModel {
        public class ApiInfo : Tea.TeaModel {
            public var apiId: String?

            public var apiName: String?

            public var boundTime: String?

            public var description_: String?

            public var groupId: String?

            public var groupName: String?

            public var regionId: String?

            public var stageName: String?

            public var visibility: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.apiId != nil {
                    map["ApiId"] = self.apiId!
                }
                if self.apiName != nil {
                    map["ApiName"] = self.apiName!
                }
                if self.boundTime != nil {
                    map["BoundTime"] = self.boundTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.stageName != nil {
                    map["StageName"] = self.stageName!
                }
                if self.visibility != nil {
                    map["Visibility"] = self.visibility!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ApiId") && dict["ApiId"] != nil {
                    self.apiId = dict["ApiId"] as! String
                }
                if dict.keys.contains("ApiName") && dict["ApiName"] != nil {
                    self.apiName = dict["ApiName"] as! String
                }
                if dict.keys.contains("BoundTime") && dict["BoundTime"] != nil {
                    self.boundTime = dict["BoundTime"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
                    self.groupName = dict["GroupName"] as! String
                }
                if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("StageName") && dict["StageName"] != nil {
                    self.stageName = dict["StageName"] as! String
                }
                if dict.keys.contains("Visibility") && dict["Visibility"] != nil {
                    self.visibility = dict["Visibility"] as! String
                }
            }
        }
        public var apiInfo: [DescribeApisBySignatureResponseBody.ApiInfos.ApiInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apiInfo != nil {
                var tmp : [Any] = []
                for k in self.apiInfo! {
                    tmp.append(k.toMap())
                }
                map["ApiInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApiInfo") && dict["ApiInfo"] != nil {
                var tmp : [DescribeApisBySignatureResponseBody.ApiInfos.ApiInfo] = []
                for v in dict["ApiInfo"] as! [Any] {
                    var model = DescribeApisBySignatureResponseBody.ApiInfos.ApiInfo()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.apiInfo = tmp
            }
        }
    }
    public var apiInfos: DescribeApisBySignatureResponseBody.ApiInfos?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.apiInfos?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiInfos != nil {
            map["ApiInfos"] = self.apiInfos?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiInfos") && dict["ApiInfos"] != nil {
            var model = DescribeApisBySignatureResponseBody.ApiInfos()
            model.fromMap(dict["ApiInfos"] as! [String: Any])
            self.apiInfos = model
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeApisBySignatureResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeApisBySignatureResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeApisBySignatureResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeApisByTrafficControlRequest : Tea.TeaModel {
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var securityToken: String?

    public var trafficControlId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.trafficControlId != nil {
            map["TrafficControlId"] = self.trafficControlId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("TrafficControlId") && dict["TrafficControlId"] != nil {
            self.trafficControlId = dict["TrafficControlId"] as! String
        }
    }
}

public class DescribeApisByTrafficControlResponseBody : Tea.TeaModel {
    public class ApiInfos : Tea.TeaModel {
        public class ApiInfo : Tea.TeaModel {
            public var apiId: String?

            public var apiName: String?

            public var boundTime: String?

            public var description_: String?

            public var groupId: String?

            public var groupName: String?

            public var regionId: String?

            public var stageName: String?

            public var visibility: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.apiId != nil {
                    map["ApiId"] = self.apiId!
                }
                if self.apiName != nil {
                    map["ApiName"] = self.apiName!
                }
                if self.boundTime != nil {
                    map["BoundTime"] = self.boundTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.stageName != nil {
                    map["StageName"] = self.stageName!
                }
                if self.visibility != nil {
                    map["Visibility"] = self.visibility!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ApiId") && dict["ApiId"] != nil {
                    self.apiId = dict["ApiId"] as! String
                }
                if dict.keys.contains("ApiName") && dict["ApiName"] != nil {
                    self.apiName = dict["ApiName"] as! String
                }
                if dict.keys.contains("BoundTime") && dict["BoundTime"] != nil {
                    self.boundTime = dict["BoundTime"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
                    self.groupName = dict["GroupName"] as! String
                }
                if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("StageName") && dict["StageName"] != nil {
                    self.stageName = dict["StageName"] as! String
                }
                if dict.keys.contains("Visibility") && dict["Visibility"] != nil {
                    self.visibility = dict["Visibility"] as! String
                }
            }
        }
        public var apiInfo: [DescribeApisByTrafficControlResponseBody.ApiInfos.ApiInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apiInfo != nil {
                var tmp : [Any] = []
                for k in self.apiInfo! {
                    tmp.append(k.toMap())
                }
                map["ApiInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApiInfo") && dict["ApiInfo"] != nil {
                var tmp : [DescribeApisByTrafficControlResponseBody.ApiInfos.ApiInfo] = []
                for v in dict["ApiInfo"] as! [Any] {
                    var model = DescribeApisByTrafficControlResponseBody.ApiInfos.ApiInfo()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.apiInfo = tmp
            }
        }
    }
    public var apiInfos: DescribeApisByTrafficControlResponseBody.ApiInfos?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.apiInfos?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiInfos != nil {
            map["ApiInfos"] = self.apiInfos?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiInfos") && dict["ApiInfos"] != nil {
            var model = DescribeApisByTrafficControlResponseBody.ApiInfos()
            model.fromMap(dict["ApiInfos"] as! [String: Any])
            self.apiInfos = model
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeApisByTrafficControlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeApisByTrafficControlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeApisByTrafficControlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeApisByVpcAccessRequest : Tea.TeaModel {
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var securityToken: String?

    public var vpcName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.vpcName != nil {
            map["VpcName"] = self.vpcName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("VpcName") && dict["VpcName"] != nil {
            self.vpcName = dict["VpcName"] as! String
        }
    }
}

public class DescribeApisByVpcAccessResponseBody : Tea.TeaModel {
    public class ApiVpcAccessInfos : Tea.TeaModel {
        public class ApiVpcAccessInfo : Tea.TeaModel {
            public var apiId: String?

            public var apiName: String?

            public var description_: String?

            public var groupId: String?

            public var groupName: String?

            public var instanceId: String?

            public var method: String?

            public var path: String?

            public var port: Int32?

            public var regionId: String?

            public var stageId: String?

            public var stageName: String?

            public var vpcId: String?

            public var vpcName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.apiId != nil {
                    map["ApiId"] = self.apiId!
                }
                if self.apiName != nil {
                    map["ApiName"] = self.apiName!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.method != nil {
                    map["Method"] = self.method!
                }
                if self.path != nil {
                    map["Path"] = self.path!
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.stageId != nil {
                    map["StageId"] = self.stageId!
                }
                if self.stageName != nil {
                    map["StageName"] = self.stageName!
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                if self.vpcName != nil {
                    map["VpcName"] = self.vpcName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ApiId") && dict["ApiId"] != nil {
                    self.apiId = dict["ApiId"] as! String
                }
                if dict.keys.contains("ApiName") && dict["ApiName"] != nil {
                    self.apiName = dict["ApiName"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
                    self.groupName = dict["GroupName"] as! String
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("Method") && dict["Method"] != nil {
                    self.method = dict["Method"] as! String
                }
                if dict.keys.contains("Path") && dict["Path"] != nil {
                    self.path = dict["Path"] as! String
                }
                if dict.keys.contains("Port") && dict["Port"] != nil {
                    self.port = dict["Port"] as! Int32
                }
                if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("StageId") && dict["StageId"] != nil {
                    self.stageId = dict["StageId"] as! String
                }
                if dict.keys.contains("StageName") && dict["StageName"] != nil {
                    self.stageName = dict["StageName"] as! String
                }
                if dict.keys.contains("VpcId") && dict["VpcId"] != nil {
                    self.vpcId = dict["VpcId"] as! String
                }
                if dict.keys.contains("VpcName") && dict["VpcName"] != nil {
                    self.vpcName = dict["VpcName"] as! String
                }
            }
        }
        public var apiVpcAccessInfo: [DescribeApisByVpcAccessResponseBody.ApiVpcAccessInfos.ApiVpcAccessInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apiVpcAccessInfo != nil {
                var tmp : [Any] = []
                for k in self.apiVpcAccessInfo! {
                    tmp.append(k.toMap())
                }
                map["ApiVpcAccessInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApiVpcAccessInfo") && dict["ApiVpcAccessInfo"] != nil {
                var tmp : [DescribeApisByVpcAccessResponseBody.ApiVpcAccessInfos.ApiVpcAccessInfo] = []
                for v in dict["ApiVpcAccessInfo"] as! [Any] {
                    var model = DescribeApisByVpcAccessResponseBody.ApiVpcAccessInfos.ApiVpcAccessInfo()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.apiVpcAccessInfo = tmp
            }
        }
    }
    public var apiVpcAccessInfos: DescribeApisByVpcAccessResponseBody.ApiVpcAccessInfos?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.apiVpcAccessInfos?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiVpcAccessInfos != nil {
            map["ApiVpcAccessInfos"] = self.apiVpcAccessInfos?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiVpcAccessInfos") && dict["ApiVpcAccessInfos"] != nil {
            var model = DescribeApisByVpcAccessResponseBody.ApiVpcAccessInfos()
            model.fromMap(dict["ApiVpcAccessInfos"] as! [String: Any])
            self.apiVpcAccessInfos = model
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeApisByVpcAccessResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeApisByVpcAccessResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeApisByVpcAccessResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeApisWithStageNameIntegratedByAppRequest : Tea.TeaModel {
    public var apiName: String?

    public var apiUid: String?

    public var appId: Int64?

    public var description_: String?

    public var method: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var path: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiName != nil {
            map["ApiName"] = self.apiName!
        }
        if self.apiUid != nil {
            map["ApiUid"] = self.apiUid!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.method != nil {
            map["Method"] = self.method!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.path != nil {
            map["Path"] = self.path!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiName") && dict["ApiName"] != nil {
            self.apiName = dict["ApiName"] as! String
        }
        if dict.keys.contains("ApiUid") && dict["ApiUid"] != nil {
            self.apiUid = dict["ApiUid"] as! String
        }
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! Int64
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Method") && dict["Method"] != nil {
            self.method = dict["Method"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Path") && dict["Path"] != nil {
            self.path = dict["Path"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DescribeApisWithStageNameIntegratedByAppResponseBody : Tea.TeaModel {
    public class AppApiRelationInfos : Tea.TeaModel {
        public class AppApiRelationInfo : Tea.TeaModel {
            public var apiId: String?

            public var apiName: String?

            public var authorizationSource: String?

            public var createdTime: String?

            public var description_: String?

            public var groupId: String?

            public var groupName: String?

            public var method: String?

            public var operator_: String?

            public var path: String?

            public var regionId: String?

            public var stageNameAndAuth: [String: String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.apiId != nil {
                    map["ApiId"] = self.apiId!
                }
                if self.apiName != nil {
                    map["ApiName"] = self.apiName!
                }
                if self.authorizationSource != nil {
                    map["AuthorizationSource"] = self.authorizationSource!
                }
                if self.createdTime != nil {
                    map["CreatedTime"] = self.createdTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.method != nil {
                    map["Method"] = self.method!
                }
                if self.operator_ != nil {
                    map["Operator"] = self.operator_!
                }
                if self.path != nil {
                    map["Path"] = self.path!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.stageNameAndAuth != nil {
                    map["StageNameAndAuth"] = self.stageNameAndAuth!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ApiId") && dict["ApiId"] != nil {
                    self.apiId = dict["ApiId"] as! String
                }
                if dict.keys.contains("ApiName") && dict["ApiName"] != nil {
                    self.apiName = dict["ApiName"] as! String
                }
                if dict.keys.contains("AuthorizationSource") && dict["AuthorizationSource"] != nil {
                    self.authorizationSource = dict["AuthorizationSource"] as! String
                }
                if dict.keys.contains("CreatedTime") && dict["CreatedTime"] != nil {
                    self.createdTime = dict["CreatedTime"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
                    self.groupName = dict["GroupName"] as! String
                }
                if dict.keys.contains("Method") && dict["Method"] != nil {
                    self.method = dict["Method"] as! String
                }
                if dict.keys.contains("Operator") && dict["Operator"] != nil {
                    self.operator_ = dict["Operator"] as! String
                }
                if dict.keys.contains("Path") && dict["Path"] != nil {
                    self.path = dict["Path"] as! String
                }
                if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("StageNameAndAuth") && dict["StageNameAndAuth"] != nil {
                    self.stageNameAndAuth = dict["StageNameAndAuth"] as! [String: String]
                }
            }
        }
        public var appApiRelationInfo: [DescribeApisWithStageNameIntegratedByAppResponseBody.AppApiRelationInfos.AppApiRelationInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appApiRelationInfo != nil {
                var tmp : [Any] = []
                for k in self.appApiRelationInfo! {
                    tmp.append(k.toMap())
                }
                map["AppApiRelationInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppApiRelationInfo") && dict["AppApiRelationInfo"] != nil {
                var tmp : [DescribeApisWithStageNameIntegratedByAppResponseBody.AppApiRelationInfos.AppApiRelationInfo] = []
                for v in dict["AppApiRelationInfo"] as! [Any] {
                    var model = DescribeApisWithStageNameIntegratedByAppResponseBody.AppApiRelationInfos.AppApiRelationInfo()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.appApiRelationInfo = tmp
            }
        }
    }
    public var appApiRelationInfos: DescribeApisWithStageNameIntegratedByAppResponseBody.AppApiRelationInfos?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.appApiRelationInfos?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appApiRelationInfos != nil {
            map["AppApiRelationInfos"] = self.appApiRelationInfos?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppApiRelationInfos") && dict["AppApiRelationInfos"] != nil {
            var model = DescribeApisWithStageNameIntegratedByAppResponseBody.AppApiRelationInfos()
            model.fromMap(dict["AppApiRelationInfos"] as! [String: Any])
            self.appApiRelationInfos = model
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeApisWithStageNameIntegratedByAppResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeApisWithStageNameIntegratedByAppResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeApisWithStageNameIntegratedByAppResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAppRequest : Tea.TeaModel {
    public var appId: Int64?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! Int64
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DescribeAppResponseBody : Tea.TeaModel {
    public var appId: Int64?

    public var appName: String?

    public var createdTime: String?

    public var description_: String?

    public var extend: String?

    public var modifiedTime: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.createdTime != nil {
            map["CreatedTime"] = self.createdTime!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.extend != nil {
            map["Extend"] = self.extend!
        }
        if self.modifiedTime != nil {
            map["ModifiedTime"] = self.modifiedTime!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! Int64
        }
        if dict.keys.contains("AppName") && dict["AppName"] != nil {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("CreatedTime") && dict["CreatedTime"] != nil {
            self.createdTime = dict["CreatedTime"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Extend") && dict["Extend"] != nil {
            self.extend = dict["Extend"] as! String
        }
        if dict.keys.contains("ModifiedTime") && dict["ModifiedTime"] != nil {
            self.modifiedTime = dict["ModifiedTime"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeAppResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAppResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeAppResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAppAttributesRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var appCode: String?

    public var appId: Int64?

    public var appKey: String?

    public var appName: String?

    public var enableTagAuth: Bool?

    public var extend: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var securityToken: String?

    public var sort: String?

    public var tag: [DescribeAppAttributesRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appCode != nil {
            map["AppCode"] = self.appCode!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appKey != nil {
            map["AppKey"] = self.appKey!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.enableTagAuth != nil {
            map["EnableTagAuth"] = self.enableTagAuth!
        }
        if self.extend != nil {
            map["Extend"] = self.extend!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.sort != nil {
            map["Sort"] = self.sort!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppCode") && dict["AppCode"] != nil {
            self.appCode = dict["AppCode"] as! String
        }
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! Int64
        }
        if dict.keys.contains("AppKey") && dict["AppKey"] != nil {
            self.appKey = dict["AppKey"] as! String
        }
        if dict.keys.contains("AppName") && dict["AppName"] != nil {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("EnableTagAuth") && dict["EnableTagAuth"] != nil {
            self.enableTagAuth = dict["EnableTagAuth"] as! Bool
        }
        if dict.keys.contains("Extend") && dict["Extend"] != nil {
            self.extend = dict["Extend"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("Sort") && dict["Sort"] != nil {
            self.sort = dict["Sort"] as! String
        }
        if dict.keys.contains("Tag") && dict["Tag"] != nil {
            var tmp : [DescribeAppAttributesRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = DescribeAppAttributesRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class DescribeAppAttributesResponseBody : Tea.TeaModel {
    public class Apps : Tea.TeaModel {
        public class AppAttribute : Tea.TeaModel {
            public class Tags : Tea.TeaModel {
                public class TagInfo : Tea.TeaModel {
                    public var key: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Key") && dict["Key"] != nil {
                            self.key = dict["Key"] as! String
                        }
                        if dict.keys.contains("Value") && dict["Value"] != nil {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var tagInfo: [DescribeAppAttributesResponseBody.Apps.AppAttribute.Tags.TagInfo]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tagInfo != nil {
                        var tmp : [Any] = []
                        for k in self.tagInfo! {
                            tmp.append(k.toMap())
                        }
                        map["TagInfo"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("TagInfo") && dict["TagInfo"] != nil {
                        var tmp : [DescribeAppAttributesResponseBody.Apps.AppAttribute.Tags.TagInfo] = []
                        for v in dict["TagInfo"] as! [Any] {
                            var model = DescribeAppAttributesResponseBody.Apps.AppAttribute.Tags.TagInfo()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.tagInfo = tmp
                    }
                }
            }
            public var appId: Int64?

            public var appName: String?

            public var createdTime: String?

            public var description_: String?

            public var extend: String?

            public var modifiedTime: String?

            public var tags: DescribeAppAttributesResponseBody.Apps.AppAttribute.Tags?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.createdTime != nil {
                    map["CreatedTime"] = self.createdTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.extend != nil {
                    map["Extend"] = self.extend!
                }
                if self.modifiedTime != nil {
                    map["ModifiedTime"] = self.modifiedTime!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppId") && dict["AppId"] != nil {
                    self.appId = dict["AppId"] as! Int64
                }
                if dict.keys.contains("AppName") && dict["AppName"] != nil {
                    self.appName = dict["AppName"] as! String
                }
                if dict.keys.contains("CreatedTime") && dict["CreatedTime"] != nil {
                    self.createdTime = dict["CreatedTime"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Extend") && dict["Extend"] != nil {
                    self.extend = dict["Extend"] as! String
                }
                if dict.keys.contains("ModifiedTime") && dict["ModifiedTime"] != nil {
                    self.modifiedTime = dict["ModifiedTime"] as! String
                }
                if dict.keys.contains("Tags") && dict["Tags"] != nil {
                    var model = DescribeAppAttributesResponseBody.Apps.AppAttribute.Tags()
                    model.fromMap(dict["Tags"] as! [String: Any])
                    self.tags = model
                }
            }
        }
        public var appAttribute: [DescribeAppAttributesResponseBody.Apps.AppAttribute]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appAttribute != nil {
                var tmp : [Any] = []
                for k in self.appAttribute! {
                    tmp.append(k.toMap())
                }
                map["AppAttribute"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppAttribute") && dict["AppAttribute"] != nil {
                var tmp : [DescribeAppAttributesResponseBody.Apps.AppAttribute] = []
                for v in dict["AppAttribute"] as! [Any] {
                    var model = DescribeAppAttributesResponseBody.Apps.AppAttribute()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.appAttribute = tmp
            }
        }
    }
    public var apps: DescribeAppAttributesResponseBody.Apps?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.apps?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apps != nil {
            map["Apps"] = self.apps?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Apps") && dict["Apps"] != nil {
            var model = DescribeAppAttributesResponseBody.Apps()
            model.fromMap(dict["Apps"] as! [String: Any])
            self.apps = model
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeAppAttributesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAppAttributesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeAppAttributesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAppSecurityRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var appId: Int64?

    public var securityToken: String?

    public var tag: [DescribeAppSecurityRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! Int64
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("Tag") && dict["Tag"] != nil {
            var tmp : [DescribeAppSecurityRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = DescribeAppSecurityRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class DescribeAppSecurityResponseBody : Tea.TeaModel {
    public var appCode: String?

    public var appKey: String?

    public var appSecret: String?

    public var createdTime: String?

    public var modifiedTime: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appCode != nil {
            map["AppCode"] = self.appCode!
        }
        if self.appKey != nil {
            map["AppKey"] = self.appKey!
        }
        if self.appSecret != nil {
            map["AppSecret"] = self.appSecret!
        }
        if self.createdTime != nil {
            map["CreatedTime"] = self.createdTime!
        }
        if self.modifiedTime != nil {
            map["ModifiedTime"] = self.modifiedTime!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppCode") && dict["AppCode"] != nil {
            self.appCode = dict["AppCode"] as! String
        }
        if dict.keys.contains("AppKey") && dict["AppKey"] != nil {
            self.appKey = dict["AppKey"] as! String
        }
        if dict.keys.contains("AppSecret") && dict["AppSecret"] != nil {
            self.appSecret = dict["AppSecret"] as! String
        }
        if dict.keys.contains("CreatedTime") && dict["CreatedTime"] != nil {
            self.createdTime = dict["CreatedTime"] as! String
        }
        if dict.keys.contains("ModifiedTime") && dict["ModifiedTime"] != nil {
            self.modifiedTime = dict["ModifiedTime"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeAppSecurityResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAppSecurityResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeAppSecurityResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAppsRequest : Tea.TeaModel {
    public var appId: Int64?

    public var appOwner: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appOwner != nil {
            map["AppOwner"] = self.appOwner!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! Int64
        }
        if dict.keys.contains("AppOwner") && dict["AppOwner"] != nil {
            self.appOwner = dict["AppOwner"] as! Int64
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DescribeAppsResponseBody : Tea.TeaModel {
    public class Apps : Tea.TeaModel {
        public class AppItem : Tea.TeaModel {
            public var appId: Int64?

            public var appName: String?

            public var description_: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppId") && dict["AppId"] != nil {
                    self.appId = dict["AppId"] as! Int64
                }
                if dict.keys.contains("AppName") && dict["AppName"] != nil {
                    self.appName = dict["AppName"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
            }
        }
        public var appItem: [DescribeAppsResponseBody.Apps.AppItem]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appItem != nil {
                var tmp : [Any] = []
                for k in self.appItem! {
                    tmp.append(k.toMap())
                }
                map["AppItem"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppItem") && dict["AppItem"] != nil {
                var tmp : [DescribeAppsResponseBody.Apps.AppItem] = []
                for v in dict["AppItem"] as! [Any] {
                    var model = DescribeAppsResponseBody.Apps.AppItem()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.appItem = tmp
            }
        }
    }
    public var apps: DescribeAppsResponseBody.Apps?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.apps?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apps != nil {
            map["Apps"] = self.apps?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Apps") && dict["Apps"] != nil {
            var model = DescribeAppsResponseBody.Apps()
            model.fromMap(dict["Apps"] as! [String: Any])
            self.apps = model
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeAppsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAppsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeAppsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAppsByApiProductRequest : Tea.TeaModel {
    public var apiProductId: String?

    public var appName: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiProductId != nil {
            map["ApiProductId"] = self.apiProductId!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiProductId") && dict["ApiProductId"] != nil {
            self.apiProductId = dict["ApiProductId"] as! String
        }
        if dict.keys.contains("AppName") && dict["AppName"] != nil {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DescribeAppsByApiProductResponseBody : Tea.TeaModel {
    public class AuthorizedApps : Tea.TeaModel {
        public class AuthorizedApp : Tea.TeaModel {
            public var appId: Int64?

            public var appName: String?

            public var authValidTime: String?

            public var authorizedTime: String?

            public var description_: String?

            public var extend: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.authValidTime != nil {
                    map["AuthValidTime"] = self.authValidTime!
                }
                if self.authorizedTime != nil {
                    map["AuthorizedTime"] = self.authorizedTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.extend != nil {
                    map["Extend"] = self.extend!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppId") && dict["AppId"] != nil {
                    self.appId = dict["AppId"] as! Int64
                }
                if dict.keys.contains("AppName") && dict["AppName"] != nil {
                    self.appName = dict["AppName"] as! String
                }
                if dict.keys.contains("AuthValidTime") && dict["AuthValidTime"] != nil {
                    self.authValidTime = dict["AuthValidTime"] as! String
                }
                if dict.keys.contains("AuthorizedTime") && dict["AuthorizedTime"] != nil {
                    self.authorizedTime = dict["AuthorizedTime"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Extend") && dict["Extend"] != nil {
                    self.extend = dict["Extend"] as! String
                }
            }
        }
        public var authorizedApp: [DescribeAppsByApiProductResponseBody.AuthorizedApps.AuthorizedApp]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.authorizedApp != nil {
                var tmp : [Any] = []
                for k in self.authorizedApp! {
                    tmp.append(k.toMap())
                }
                map["AuthorizedApp"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AuthorizedApp") && dict["AuthorizedApp"] != nil {
                var tmp : [DescribeAppsByApiProductResponseBody.AuthorizedApps.AuthorizedApp] = []
                for v in dict["AuthorizedApp"] as! [Any] {
                    var model = DescribeAppsByApiProductResponseBody.AuthorizedApps.AuthorizedApp()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.authorizedApp = tmp
            }
        }
    }
    public var authorizedApps: DescribeAppsByApiProductResponseBody.AuthorizedApps?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.authorizedApps?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.authorizedApps != nil {
            map["AuthorizedApps"] = self.authorizedApps?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AuthorizedApps") && dict["AuthorizedApps"] != nil {
            var model = DescribeAppsByApiProductResponseBody.AuthorizedApps()
            model.fromMap(dict["AuthorizedApps"] as! [String: Any])
            self.authorizedApps = model
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeAppsByApiProductResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAppsByApiProductResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeAppsByApiProductResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAuthorizedApisRequest : Tea.TeaModel {
    public var appId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! Int64
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DescribeAuthorizedApisResponseBody : Tea.TeaModel {
    public class AuthorizedApis : Tea.TeaModel {
        public class AuthorizedApi : Tea.TeaModel {
            public var apiId: String?

            public var apiName: String?

            public var authVaildTime: String?

            public var authorizationSource: String?

            public var authorizedTime: String?

            public var description_: String?

            public var groupId: String?

            public var groupName: String?

            public var operator_: String?

            public var regionId: String?

            public var stageName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.apiId != nil {
                    map["ApiId"] = self.apiId!
                }
                if self.apiName != nil {
                    map["ApiName"] = self.apiName!
                }
                if self.authVaildTime != nil {
                    map["AuthVaildTime"] = self.authVaildTime!
                }
                if self.authorizationSource != nil {
                    map["AuthorizationSource"] = self.authorizationSource!
                }
                if self.authorizedTime != nil {
                    map["AuthorizedTime"] = self.authorizedTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.operator_ != nil {
                    map["Operator"] = self.operator_!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.stageName != nil {
                    map["StageName"] = self.stageName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ApiId") && dict["ApiId"] != nil {
                    self.apiId = dict["ApiId"] as! String
                }
                if dict.keys.contains("ApiName") && dict["ApiName"] != nil {
                    self.apiName = dict["ApiName"] as! String
                }
                if dict.keys.contains("AuthVaildTime") && dict["AuthVaildTime"] != nil {
                    self.authVaildTime = dict["AuthVaildTime"] as! String
                }
                if dict.keys.contains("AuthorizationSource") && dict["AuthorizationSource"] != nil {
                    self.authorizationSource = dict["AuthorizationSource"] as! String
                }
                if dict.keys.contains("AuthorizedTime") && dict["AuthorizedTime"] != nil {
                    self.authorizedTime = dict["AuthorizedTime"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
                    self.groupName = dict["GroupName"] as! String
                }
                if dict.keys.contains("Operator") && dict["Operator"] != nil {
                    self.operator_ = dict["Operator"] as! String
                }
                if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("StageName") && dict["StageName"] != nil {
                    self.stageName = dict["StageName"] as! String
                }
            }
        }
        public var authorizedApi: [DescribeAuthorizedApisResponseBody.AuthorizedApis.AuthorizedApi]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.authorizedApi != nil {
                var tmp : [Any] = []
                for k in self.authorizedApi! {
                    tmp.append(k.toMap())
                }
                map["AuthorizedApi"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AuthorizedApi") && dict["AuthorizedApi"] != nil {
                var tmp : [DescribeAuthorizedApisResponseBody.AuthorizedApis.AuthorizedApi] = []
                for v in dict["AuthorizedApi"] as! [Any] {
                    var model = DescribeAuthorizedApisResponseBody.AuthorizedApis.AuthorizedApi()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.authorizedApi = tmp
            }
        }
    }
    public var authorizedApis: DescribeAuthorizedApisResponseBody.AuthorizedApis?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.authorizedApis?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.authorizedApis != nil {
            map["AuthorizedApis"] = self.authorizedApis?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AuthorizedApis") && dict["AuthorizedApis"] != nil {
            var model = DescribeAuthorizedApisResponseBody.AuthorizedApis()
            model.fromMap(dict["AuthorizedApis"] as! [String: Any])
            self.authorizedApis = model
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeAuthorizedApisResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAuthorizedApisResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeAuthorizedApisResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAuthorizedAppsRequest : Tea.TeaModel {
    public var apiId: String?

    public var appId: Int64?

    public var appName: String?

    public var appOwnerId: Int64?

    public var groupId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var securityToken: String?

    public var stageName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.appOwnerId != nil {
            map["AppOwnerId"] = self.appOwnerId!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.stageName != nil {
            map["StageName"] = self.stageName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiId") && dict["ApiId"] != nil {
            self.apiId = dict["ApiId"] as! String
        }
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! Int64
        }
        if dict.keys.contains("AppName") && dict["AppName"] != nil {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("AppOwnerId") && dict["AppOwnerId"] != nil {
            self.appOwnerId = dict["AppOwnerId"] as! Int64
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StageName") && dict["StageName"] != nil {
            self.stageName = dict["StageName"] as! String
        }
    }
}

public class DescribeAuthorizedAppsResponseBody : Tea.TeaModel {
    public class AuthorizedApps : Tea.TeaModel {
        public class AuthorizedApp : Tea.TeaModel {
            public var appDescription: String?

            public var appId: Int64?

            public var appName: String?

            public var authVaildTime: String?

            public var authorizationSource: String?

            public var authorizedTime: String?

            public var description_: String?

            public var operator_: String?

            public var stageAlias: String?

            public var stageName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appDescription != nil {
                    map["AppDescription"] = self.appDescription!
                }
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.authVaildTime != nil {
                    map["AuthVaildTime"] = self.authVaildTime!
                }
                if self.authorizationSource != nil {
                    map["AuthorizationSource"] = self.authorizationSource!
                }
                if self.authorizedTime != nil {
                    map["AuthorizedTime"] = self.authorizedTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.operator_ != nil {
                    map["Operator"] = self.operator_!
                }
                if self.stageAlias != nil {
                    map["StageAlias"] = self.stageAlias!
                }
                if self.stageName != nil {
                    map["StageName"] = self.stageName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppDescription") && dict["AppDescription"] != nil {
                    self.appDescription = dict["AppDescription"] as! String
                }
                if dict.keys.contains("AppId") && dict["AppId"] != nil {
                    self.appId = dict["AppId"] as! Int64
                }
                if dict.keys.contains("AppName") && dict["AppName"] != nil {
                    self.appName = dict["AppName"] as! String
                }
                if dict.keys.contains("AuthVaildTime") && dict["AuthVaildTime"] != nil {
                    self.authVaildTime = dict["AuthVaildTime"] as! String
                }
                if dict.keys.contains("AuthorizationSource") && dict["AuthorizationSource"] != nil {
                    self.authorizationSource = dict["AuthorizationSource"] as! String
                }
                if dict.keys.contains("AuthorizedTime") && dict["AuthorizedTime"] != nil {
                    self.authorizedTime = dict["AuthorizedTime"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Operator") && dict["Operator"] != nil {
                    self.operator_ = dict["Operator"] as! String
                }
                if dict.keys.contains("StageAlias") && dict["StageAlias"] != nil {
                    self.stageAlias = dict["StageAlias"] as! String
                }
                if dict.keys.contains("StageName") && dict["StageName"] != nil {
                    self.stageName = dict["StageName"] as! String
                }
            }
        }
        public var authorizedApp: [DescribeAuthorizedAppsResponseBody.AuthorizedApps.AuthorizedApp]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.authorizedApp != nil {
                var tmp : [Any] = []
                for k in self.authorizedApp! {
                    tmp.append(k.toMap())
                }
                map["AuthorizedApp"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AuthorizedApp") && dict["AuthorizedApp"] != nil {
                var tmp : [DescribeAuthorizedAppsResponseBody.AuthorizedApps.AuthorizedApp] = []
                for v in dict["AuthorizedApp"] as! [Any] {
                    var model = DescribeAuthorizedAppsResponseBody.AuthorizedApps.AuthorizedApp()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.authorizedApp = tmp
            }
        }
    }
    public var authorizedApps: DescribeAuthorizedAppsResponseBody.AuthorizedApps?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.authorizedApps?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.authorizedApps != nil {
            map["AuthorizedApps"] = self.authorizedApps?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AuthorizedApps") && dict["AuthorizedApps"] != nil {
            var model = DescribeAuthorizedAppsResponseBody.AuthorizedApps()
            model.fromMap(dict["AuthorizedApps"] as! [String: Any])
            self.authorizedApps = model
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeAuthorizedAppsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAuthorizedAppsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeAuthorizedAppsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeBackendInfoRequest : Tea.TeaModel {
    public var backendId: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backendId != nil {
            map["BackendId"] = self.backendId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BackendId") && dict["BackendId"] != nil {
            self.backendId = dict["BackendId"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DescribeBackendInfoResponseBody : Tea.TeaModel {
    public class BackendInfo : Tea.TeaModel {
        public class BackendModels : Tea.TeaModel {
            public class BackendConfig : Tea.TeaModel {
                public class DiscoveryConfig : Tea.TeaModel {
                    public class NacosConfig : Tea.TeaModel {
                        public var accessKey: String?

                        public var authType: String?

                        public var clusters: String?

                        public var groupName: String?

                        public var namespace: String?

                        public var password: String?

                        public var secretKey: String?

                        public var serverAddress: String?

                        public var serviceName: String?

                        public var userName: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.accessKey != nil {
                                map["AccessKey"] = self.accessKey!
                            }
                            if self.authType != nil {
                                map["AuthType"] = self.authType!
                            }
                            if self.clusters != nil {
                                map["Clusters"] = self.clusters!
                            }
                            if self.groupName != nil {
                                map["GroupName"] = self.groupName!
                            }
                            if self.namespace != nil {
                                map["Namespace"] = self.namespace!
                            }
                            if self.password != nil {
                                map["Password"] = self.password!
                            }
                            if self.secretKey != nil {
                                map["SecretKey"] = self.secretKey!
                            }
                            if self.serverAddress != nil {
                                map["ServerAddress"] = self.serverAddress!
                            }
                            if self.serviceName != nil {
                                map["ServiceName"] = self.serviceName!
                            }
                            if self.userName != nil {
                                map["UserName"] = self.userName!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("AccessKey") && dict["AccessKey"] != nil {
                                self.accessKey = dict["AccessKey"] as! String
                            }
                            if dict.keys.contains("AuthType") && dict["AuthType"] != nil {
                                self.authType = dict["AuthType"] as! String
                            }
                            if dict.keys.contains("Clusters") && dict["Clusters"] != nil {
                                self.clusters = dict["Clusters"] as! String
                            }
                            if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
                                self.groupName = dict["GroupName"] as! String
                            }
                            if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
                                self.namespace = dict["Namespace"] as! String
                            }
                            if dict.keys.contains("Password") && dict["Password"] != nil {
                                self.password = dict["Password"] as! String
                            }
                            if dict.keys.contains("SecretKey") && dict["SecretKey"] != nil {
                                self.secretKey = dict["SecretKey"] as! String
                            }
                            if dict.keys.contains("ServerAddress") && dict["ServerAddress"] != nil {
                                self.serverAddress = dict["ServerAddress"] as! String
                            }
                            if dict.keys.contains("ServiceName") && dict["ServiceName"] != nil {
                                self.serviceName = dict["ServiceName"] as! String
                            }
                            if dict.keys.contains("UserName") && dict["UserName"] != nil {
                                self.userName = dict["UserName"] as! String
                            }
                        }
                    }
                    public class ZookeeperConfig : Tea.TeaModel {
                        public var connectString: String?

                        public var namespace: String?

                        public var serviceName: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.connectString != nil {
                                map["ConnectString"] = self.connectString!
                            }
                            if self.namespace != nil {
                                map["Namespace"] = self.namespace!
                            }
                            if self.serviceName != nil {
                                map["ServiceName"] = self.serviceName!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("ConnectString") && dict["ConnectString"] != nil {
                                self.connectString = dict["ConnectString"] as! String
                            }
                            if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
                                self.namespace = dict["Namespace"] as! String
                            }
                            if dict.keys.contains("ServiceName") && dict["ServiceName"] != nil {
                                self.serviceName = dict["ServiceName"] as! String
                            }
                        }
                    }
                    public var nacosConfig: DescribeBackendInfoResponseBody.BackendInfo.BackendModels.BackendConfig.DiscoveryConfig.NacosConfig?

                    public var rcType: String?

                    public var zookeeperConfig: DescribeBackendInfoResponseBody.BackendInfo.BackendModels.BackendConfig.DiscoveryConfig.ZookeeperConfig?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.nacosConfig?.validate()
                        try self.zookeeperConfig?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.nacosConfig != nil {
                            map["NacosConfig"] = self.nacosConfig?.toMap()
                        }
                        if self.rcType != nil {
                            map["RcType"] = self.rcType!
                        }
                        if self.zookeeperConfig != nil {
                            map["ZookeeperConfig"] = self.zookeeperConfig?.toMap()
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("NacosConfig") && dict["NacosConfig"] != nil {
                            var model = DescribeBackendInfoResponseBody.BackendInfo.BackendModels.BackendConfig.DiscoveryConfig.NacosConfig()
                            model.fromMap(dict["NacosConfig"] as! [String: Any])
                            self.nacosConfig = model
                        }
                        if dict.keys.contains("RcType") && dict["RcType"] != nil {
                            self.rcType = dict["RcType"] as! String
                        }
                        if dict.keys.contains("ZookeeperConfig") && dict["ZookeeperConfig"] != nil {
                            var model = DescribeBackendInfoResponseBody.BackendInfo.BackendModels.BackendConfig.DiscoveryConfig.ZookeeperConfig()
                            model.fromMap(dict["ZookeeperConfig"] as! [String: Any])
                            self.zookeeperConfig = model
                        }
                    }
                }
                public class EdasConfig : Tea.TeaModel {
                    public var edasAppId: String?

                    public var microserviceNamespace: String?

                    public var microserviceNamespaceId: String?

                    public var microserviceNamespaceName: String?

                    public var mseInstanceId: String?

                    public var registryType: String?

                    public var serviceName: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.edasAppId != nil {
                            map["EdasAppId"] = self.edasAppId!
                        }
                        if self.microserviceNamespace != nil {
                            map["MicroserviceNamespace"] = self.microserviceNamespace!
                        }
                        if self.microserviceNamespaceId != nil {
                            map["MicroserviceNamespaceId"] = self.microserviceNamespaceId!
                        }
                        if self.microserviceNamespaceName != nil {
                            map["MicroserviceNamespaceName"] = self.microserviceNamespaceName!
                        }
                        if self.mseInstanceId != nil {
                            map["MseInstanceId"] = self.mseInstanceId!
                        }
                        if self.registryType != nil {
                            map["RegistryType"] = self.registryType!
                        }
                        if self.serviceName != nil {
                            map["ServiceName"] = self.serviceName!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("EdasAppId") && dict["EdasAppId"] != nil {
                            self.edasAppId = dict["EdasAppId"] as! String
                        }
                        if dict.keys.contains("MicroserviceNamespace") && dict["MicroserviceNamespace"] != nil {
                            self.microserviceNamespace = dict["MicroserviceNamespace"] as! String
                        }
                        if dict.keys.contains("MicroserviceNamespaceId") && dict["MicroserviceNamespaceId"] != nil {
                            self.microserviceNamespaceId = dict["MicroserviceNamespaceId"] as! String
                        }
                        if dict.keys.contains("MicroserviceNamespaceName") && dict["MicroserviceNamespaceName"] != nil {
                            self.microserviceNamespaceName = dict["MicroserviceNamespaceName"] as! String
                        }
                        if dict.keys.contains("MseInstanceId") && dict["MseInstanceId"] != nil {
                            self.mseInstanceId = dict["MseInstanceId"] as! String
                        }
                        if dict.keys.contains("RegistryType") && dict["RegistryType"] != nil {
                            self.registryType = dict["RegistryType"] as! String
                        }
                        if dict.keys.contains("ServiceName") && dict["ServiceName"] != nil {
                            self.serviceName = dict["ServiceName"] as! String
                        }
                    }
                }
                public class EventBridgeConfig : Tea.TeaModel {
                    public var eventBridgeRegionId: String?

                    public var eventBus: String?

                    public var eventSource: String?

                    public var roleArn: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.eventBridgeRegionId != nil {
                            map["EventBridgeRegionId"] = self.eventBridgeRegionId!
                        }
                        if self.eventBus != nil {
                            map["EventBus"] = self.eventBus!
                        }
                        if self.eventSource != nil {
                            map["EventSource"] = self.eventSource!
                        }
                        if self.roleArn != nil {
                            map["RoleArn"] = self.roleArn!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("EventBridgeRegionId") && dict["EventBridgeRegionId"] != nil {
                            self.eventBridgeRegionId = dict["EventBridgeRegionId"] as! String
                        }
                        if dict.keys.contains("EventBus") && dict["EventBus"] != nil {
                            self.eventBus = dict["EventBus"] as! String
                        }
                        if dict.keys.contains("EventSource") && dict["EventSource"] != nil {
                            self.eventSource = dict["EventSource"] as! String
                        }
                        if dict.keys.contains("RoleArn") && dict["RoleArn"] != nil {
                            self.roleArn = dict["RoleArn"] as! String
                        }
                    }
                }
                public class FunctionComputeConfig : Tea.TeaModel {
                    public var fcBaseUrl: String?

                    public var fcRegionId: String?

                    public var fcType: String?

                    public var functionName: String?

                    public var onlyBusinessPath: Bool?

                    public var qualifier: String?

                    public var roleArn: String?

                    public var serviceName: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.fcBaseUrl != nil {
                            map["FcBaseUrl"] = self.fcBaseUrl!
                        }
                        if self.fcRegionId != nil {
                            map["FcRegionId"] = self.fcRegionId!
                        }
                        if self.fcType != nil {
                            map["FcType"] = self.fcType!
                        }
                        if self.functionName != nil {
                            map["FunctionName"] = self.functionName!
                        }
                        if self.onlyBusinessPath != nil {
                            map["OnlyBusinessPath"] = self.onlyBusinessPath!
                        }
                        if self.qualifier != nil {
                            map["Qualifier"] = self.qualifier!
                        }
                        if self.roleArn != nil {
                            map["RoleArn"] = self.roleArn!
                        }
                        if self.serviceName != nil {
                            map["ServiceName"] = self.serviceName!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("FcBaseUrl") && dict["FcBaseUrl"] != nil {
                            self.fcBaseUrl = dict["FcBaseUrl"] as! String
                        }
                        if dict.keys.contains("FcRegionId") && dict["FcRegionId"] != nil {
                            self.fcRegionId = dict["FcRegionId"] as! String
                        }
                        if dict.keys.contains("FcType") && dict["FcType"] != nil {
                            self.fcType = dict["FcType"] as! String
                        }
                        if dict.keys.contains("FunctionName") && dict["FunctionName"] != nil {
                            self.functionName = dict["FunctionName"] as! String
                        }
                        if dict.keys.contains("OnlyBusinessPath") && dict["OnlyBusinessPath"] != nil {
                            self.onlyBusinessPath = dict["OnlyBusinessPath"] as! Bool
                        }
                        if dict.keys.contains("Qualifier") && dict["Qualifier"] != nil {
                            self.qualifier = dict["Qualifier"] as! String
                        }
                        if dict.keys.contains("RoleArn") && dict["RoleArn"] != nil {
                            self.roleArn = dict["RoleArn"] as! String
                        }
                        if dict.keys.contains("ServiceName") && dict["ServiceName"] != nil {
                            self.serviceName = dict["ServiceName"] as! String
                        }
                    }
                }
                public class MockConfig : Tea.TeaModel {
                    public class MockHeaders : Tea.TeaModel {
                        public var headerName: String?

                        public var headerValue: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.headerName != nil {
                                map["HeaderName"] = self.headerName!
                            }
                            if self.headerValue != nil {
                                map["HeaderValue"] = self.headerValue!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("HeaderName") && dict["HeaderName"] != nil {
                                self.headerName = dict["HeaderName"] as! String
                            }
                            if dict.keys.contains("HeaderValue") && dict["HeaderValue"] != nil {
                                self.headerValue = dict["HeaderValue"] as! String
                            }
                        }
                    }
                    public var mockHeaders: [DescribeBackendInfoResponseBody.BackendInfo.BackendModels.BackendConfig.MockConfig.MockHeaders]?

                    public var mockResult: String?

                    public var mockStatusCode: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.mockHeaders != nil {
                            var tmp : [Any] = []
                            for k in self.mockHeaders! {
                                tmp.append(k.toMap())
                            }
                            map["MockHeaders"] = tmp
                        }
                        if self.mockResult != nil {
                            map["MockResult"] = self.mockResult!
                        }
                        if self.mockStatusCode != nil {
                            map["MockStatusCode"] = self.mockStatusCode!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("MockHeaders") && dict["MockHeaders"] != nil {
                            var tmp : [DescribeBackendInfoResponseBody.BackendInfo.BackendModels.BackendConfig.MockConfig.MockHeaders] = []
                            for v in dict["MockHeaders"] as! [Any] {
                                var model = DescribeBackendInfoResponseBody.BackendInfo.BackendModels.BackendConfig.MockConfig.MockHeaders()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.mockHeaders = tmp
                        }
                        if dict.keys.contains("MockResult") && dict["MockResult"] != nil {
                            self.mockResult = dict["MockResult"] as! String
                        }
                        if dict.keys.contains("MockStatusCode") && dict["MockStatusCode"] != nil {
                            self.mockStatusCode = dict["MockStatusCode"] as! String
                        }
                    }
                }
                public class OssConfig : Tea.TeaModel {
                    public var bucketName: String?

                    public var ossRegionId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.bucketName != nil {
                            map["BucketName"] = self.bucketName!
                        }
                        if self.ossRegionId != nil {
                            map["OssRegionId"] = self.ossRegionId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("BucketName") && dict["BucketName"] != nil {
                            self.bucketName = dict["BucketName"] as! String
                        }
                        if dict.keys.contains("OssRegionId") && dict["OssRegionId"] != nil {
                            self.ossRegionId = dict["OssRegionId"] as! String
                        }
                    }
                }
                public class VpcConfig : Tea.TeaModel {
                    public var instanceId: String?

                    public var name: String?

                    public var port: Int64?

                    public var vpcAccessId: String?

                    public var vpcId: String?

                    public var vpcScheme: String?

                    public var vpcTargetHostName: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.instanceId != nil {
                            map["InstanceId"] = self.instanceId!
                        }
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        if self.port != nil {
                            map["Port"] = self.port!
                        }
                        if self.vpcAccessId != nil {
                            map["VpcAccessId"] = self.vpcAccessId!
                        }
                        if self.vpcId != nil {
                            map["VpcId"] = self.vpcId!
                        }
                        if self.vpcScheme != nil {
                            map["VpcScheme"] = self.vpcScheme!
                        }
                        if self.vpcTargetHostName != nil {
                            map["VpcTargetHostName"] = self.vpcTargetHostName!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                            self.instanceId = dict["InstanceId"] as! String
                        }
                        if dict.keys.contains("Name") && dict["Name"] != nil {
                            self.name = dict["Name"] as! String
                        }
                        if dict.keys.contains("Port") && dict["Port"] != nil {
                            self.port = dict["Port"] as! Int64
                        }
                        if dict.keys.contains("VpcAccessId") && dict["VpcAccessId"] != nil {
                            self.vpcAccessId = dict["VpcAccessId"] as! String
                        }
                        if dict.keys.contains("VpcId") && dict["VpcId"] != nil {
                            self.vpcId = dict["VpcId"] as! String
                        }
                        if dict.keys.contains("VpcScheme") && dict["VpcScheme"] != nil {
                            self.vpcScheme = dict["VpcScheme"] as! String
                        }
                        if dict.keys.contains("VpcTargetHostName") && dict["VpcTargetHostName"] != nil {
                            self.vpcTargetHostName = dict["VpcTargetHostName"] as! String
                        }
                    }
                }
                public var discoveryConfig: DescribeBackendInfoResponseBody.BackendInfo.BackendModels.BackendConfig.DiscoveryConfig?

                public var edasConfig: DescribeBackendInfoResponseBody.BackendInfo.BackendModels.BackendConfig.EdasConfig?

                public var eventBridgeConfig: DescribeBackendInfoResponseBody.BackendInfo.BackendModels.BackendConfig.EventBridgeConfig?

                public var functionComputeConfig: DescribeBackendInfoResponseBody.BackendInfo.BackendModels.BackendConfig.FunctionComputeConfig?

                public var httpTargetHostName: String?

                public var mockConfig: DescribeBackendInfoResponseBody.BackendInfo.BackendModels.BackendConfig.MockConfig?

                public var ossConfig: DescribeBackendInfoResponseBody.BackendInfo.BackendModels.BackendConfig.OssConfig?

                public var serviceAddress: String?

                public var serviceTimeout: Int32?

                public var type: String?

                public var vpcConfig: DescribeBackendInfoResponseBody.BackendInfo.BackendModels.BackendConfig.VpcConfig?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.discoveryConfig?.validate()
                    try self.edasConfig?.validate()
                    try self.eventBridgeConfig?.validate()
                    try self.functionComputeConfig?.validate()
                    try self.mockConfig?.validate()
                    try self.ossConfig?.validate()
                    try self.vpcConfig?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.discoveryConfig != nil {
                        map["DiscoveryConfig"] = self.discoveryConfig?.toMap()
                    }
                    if self.edasConfig != nil {
                        map["EdasConfig"] = self.edasConfig?.toMap()
                    }
                    if self.eventBridgeConfig != nil {
                        map["EventBridgeConfig"] = self.eventBridgeConfig?.toMap()
                    }
                    if self.functionComputeConfig != nil {
                        map["FunctionComputeConfig"] = self.functionComputeConfig?.toMap()
                    }
                    if self.httpTargetHostName != nil {
                        map["HttpTargetHostName"] = self.httpTargetHostName!
                    }
                    if self.mockConfig != nil {
                        map["MockConfig"] = self.mockConfig?.toMap()
                    }
                    if self.ossConfig != nil {
                        map["OssConfig"] = self.ossConfig?.toMap()
                    }
                    if self.serviceAddress != nil {
                        map["ServiceAddress"] = self.serviceAddress!
                    }
                    if self.serviceTimeout != nil {
                        map["ServiceTimeout"] = self.serviceTimeout!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    if self.vpcConfig != nil {
                        map["VpcConfig"] = self.vpcConfig?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DiscoveryConfig") && dict["DiscoveryConfig"] != nil {
                        var model = DescribeBackendInfoResponseBody.BackendInfo.BackendModels.BackendConfig.DiscoveryConfig()
                        model.fromMap(dict["DiscoveryConfig"] as! [String: Any])
                        self.discoveryConfig = model
                    }
                    if dict.keys.contains("EdasConfig") && dict["EdasConfig"] != nil {
                        var model = DescribeBackendInfoResponseBody.BackendInfo.BackendModels.BackendConfig.EdasConfig()
                        model.fromMap(dict["EdasConfig"] as! [String: Any])
                        self.edasConfig = model
                    }
                    if dict.keys.contains("EventBridgeConfig") && dict["EventBridgeConfig"] != nil {
                        var model = DescribeBackendInfoResponseBody.BackendInfo.BackendModels.BackendConfig.EventBridgeConfig()
                        model.fromMap(dict["EventBridgeConfig"] as! [String: Any])
                        self.eventBridgeConfig = model
                    }
                    if dict.keys.contains("FunctionComputeConfig") && dict["FunctionComputeConfig"] != nil {
                        var model = DescribeBackendInfoResponseBody.BackendInfo.BackendModels.BackendConfig.FunctionComputeConfig()
                        model.fromMap(dict["FunctionComputeConfig"] as! [String: Any])
                        self.functionComputeConfig = model
                    }
                    if dict.keys.contains("HttpTargetHostName") && dict["HttpTargetHostName"] != nil {
                        self.httpTargetHostName = dict["HttpTargetHostName"] as! String
                    }
                    if dict.keys.contains("MockConfig") && dict["MockConfig"] != nil {
                        var model = DescribeBackendInfoResponseBody.BackendInfo.BackendModels.BackendConfig.MockConfig()
                        model.fromMap(dict["MockConfig"] as! [String: Any])
                        self.mockConfig = model
                    }
                    if dict.keys.contains("OssConfig") && dict["OssConfig"] != nil {
                        var model = DescribeBackendInfoResponseBody.BackendInfo.BackendModels.BackendConfig.OssConfig()
                        model.fromMap(dict["OssConfig"] as! [String: Any])
                        self.ossConfig = model
                    }
                    if dict.keys.contains("ServiceAddress") && dict["ServiceAddress"] != nil {
                        self.serviceAddress = dict["ServiceAddress"] as! String
                    }
                    if dict.keys.contains("ServiceTimeout") && dict["ServiceTimeout"] != nil {
                        self.serviceTimeout = dict["ServiceTimeout"] as! Int32
                    }
                    if dict.keys.contains("Type") && dict["Type"] != nil {
                        self.type = dict["Type"] as! String
                    }
                    if dict.keys.contains("VpcConfig") && dict["VpcConfig"] != nil {
                        var model = DescribeBackendInfoResponseBody.BackendInfo.BackendModels.BackendConfig.VpcConfig()
                        model.fromMap(dict["VpcConfig"] as! [String: Any])
                        self.vpcConfig = model
                    }
                }
            }
            public var backendConfig: DescribeBackendInfoResponseBody.BackendInfo.BackendModels.BackendConfig?

            public var backendModelId: String?

            public var description_: String?

            public var gmtCreate: String?

            public var gmtModified: String?

            public var stageModeId: String?

            public var stageName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.backendConfig?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.backendConfig != nil {
                    map["BackendConfig"] = self.backendConfig?.toMap()
                }
                if self.backendModelId != nil {
                    map["BackendModelId"] = self.backendModelId!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.gmtModified != nil {
                    map["GmtModified"] = self.gmtModified!
                }
                if self.stageModeId != nil {
                    map["StageModeId"] = self.stageModeId!
                }
                if self.stageName != nil {
                    map["StageName"] = self.stageName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BackendConfig") && dict["BackendConfig"] != nil {
                    var model = DescribeBackendInfoResponseBody.BackendInfo.BackendModels.BackendConfig()
                    model.fromMap(dict["BackendConfig"] as! [String: Any])
                    self.backendConfig = model
                }
                if dict.keys.contains("BackendModelId") && dict["BackendModelId"] != nil {
                    self.backendModelId = dict["BackendModelId"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
                    self.gmtCreate = dict["GmtCreate"] as! String
                }
                if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
                    self.gmtModified = dict["GmtModified"] as! String
                }
                if dict.keys.contains("StageModeId") && dict["StageModeId"] != nil {
                    self.stageModeId = dict["StageModeId"] as! String
                }
                if dict.keys.contains("StageName") && dict["StageName"] != nil {
                    self.stageName = dict["StageName"] as! String
                }
            }
        }
        public var backendId: String?

        public var backendModels: [DescribeBackendInfoResponseBody.BackendInfo.BackendModels]?

        public var backendName: String?

        public var backendType: String?

        public var createdTime: String?

        public var description_: String?

        public var modifiedTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.backendId != nil {
                map["BackendId"] = self.backendId!
            }
            if self.backendModels != nil {
                var tmp : [Any] = []
                for k in self.backendModels! {
                    tmp.append(k.toMap())
                }
                map["BackendModels"] = tmp
            }
            if self.backendName != nil {
                map["BackendName"] = self.backendName!
            }
            if self.backendType != nil {
                map["BackendType"] = self.backendType!
            }
            if self.createdTime != nil {
                map["CreatedTime"] = self.createdTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BackendId") && dict["BackendId"] != nil {
                self.backendId = dict["BackendId"] as! String
            }
            if dict.keys.contains("BackendModels") && dict["BackendModels"] != nil {
                var tmp : [DescribeBackendInfoResponseBody.BackendInfo.BackendModels] = []
                for v in dict["BackendModels"] as! [Any] {
                    var model = DescribeBackendInfoResponseBody.BackendInfo.BackendModels()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.backendModels = tmp
            }
            if dict.keys.contains("BackendName") && dict["BackendName"] != nil {
                self.backendName = dict["BackendName"] as! String
            }
            if dict.keys.contains("BackendType") && dict["BackendType"] != nil {
                self.backendType = dict["BackendType"] as! String
            }
            if dict.keys.contains("CreatedTime") && dict["CreatedTime"] != nil {
                self.createdTime = dict["CreatedTime"] as! String
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("ModifiedTime") && dict["ModifiedTime"] != nil {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
        }
    }
    public var backendInfo: DescribeBackendInfoResponseBody.BackendInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.backendInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backendInfo != nil {
            map["BackendInfo"] = self.backendInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BackendInfo") && dict["BackendInfo"] != nil {
            var model = DescribeBackendInfoResponseBody.BackendInfo()
            model.fromMap(dict["BackendInfo"] as! [String: Any])
            self.backendInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeBackendInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeBackendInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeBackendInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeBackendListRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var backendName: String?

    public var backendType: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var securityToken: String?

    public var tag: [DescribeBackendListRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backendName != nil {
            map["BackendName"] = self.backendName!
        }
        if self.backendType != nil {
            map["BackendType"] = self.backendType!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BackendName") && dict["BackendName"] != nil {
            self.backendName = dict["BackendName"] as! String
        }
        if dict.keys.contains("BackendType") && dict["BackendType"] != nil {
            self.backendType = dict["BackendType"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("Tag") && dict["Tag"] != nil {
            var tmp : [DescribeBackendListRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = DescribeBackendListRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class DescribeBackendListResponseBody : Tea.TeaModel {
    public class BackendInfoList : Tea.TeaModel {
        public class Tags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") && dict["Key"] != nil {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var backendId: String?

        public var backendName: String?

        public var backendType: String?

        public var createdTime: String?

        public var description_: String?

        public var modifiedTime: String?

        public var tags: [DescribeBackendListResponseBody.BackendInfoList.Tags]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.backendId != nil {
                map["BackendId"] = self.backendId!
            }
            if self.backendName != nil {
                map["BackendName"] = self.backendName!
            }
            if self.backendType != nil {
                map["BackendType"] = self.backendType!
            }
            if self.createdTime != nil {
                map["CreatedTime"] = self.createdTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BackendId") && dict["BackendId"] != nil {
                self.backendId = dict["BackendId"] as! String
            }
            if dict.keys.contains("BackendName") && dict["BackendName"] != nil {
                self.backendName = dict["BackendName"] as! String
            }
            if dict.keys.contains("BackendType") && dict["BackendType"] != nil {
                self.backendType = dict["BackendType"] as! String
            }
            if dict.keys.contains("CreatedTime") && dict["CreatedTime"] != nil {
                self.createdTime = dict["CreatedTime"] as! String
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("ModifiedTime") && dict["ModifiedTime"] != nil {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("Tags") && dict["Tags"] != nil {
                var tmp : [DescribeBackendListResponseBody.BackendInfoList.Tags] = []
                for v in dict["Tags"] as! [Any] {
                    var model = DescribeBackendListResponseBody.BackendInfoList.Tags()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tags = tmp
            }
        }
    }
    public var backendInfoList: [DescribeBackendListResponseBody.BackendInfoList]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backendInfoList != nil {
            var tmp : [Any] = []
            for k in self.backendInfoList! {
                tmp.append(k.toMap())
            }
            map["BackendInfoList"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BackendInfoList") && dict["BackendInfoList"] != nil {
            var tmp : [DescribeBackendListResponseBody.BackendInfoList] = []
            for v in dict["BackendInfoList"] as! [Any] {
                var model = DescribeBackendListResponseBody.BackendInfoList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.backendInfoList = tmp
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeBackendListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeBackendListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeBackendListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDatasetInfoRequest : Tea.TeaModel {
    public var datasetId: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.datasetId != nil {
            map["DatasetId"] = self.datasetId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DatasetId") && dict["DatasetId"] != nil {
            self.datasetId = dict["DatasetId"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DescribeDatasetInfoResponseBody : Tea.TeaModel {
    public class DatasetInfo : Tea.TeaModel {
        public var createdTime: String?

        public var datasetId: String?

        public var datasetName: String?

        public var datasetType: String?

        public var modifiedTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createdTime != nil {
                map["CreatedTime"] = self.createdTime!
            }
            if self.datasetId != nil {
                map["DatasetId"] = self.datasetId!
            }
            if self.datasetName != nil {
                map["DatasetName"] = self.datasetName!
            }
            if self.datasetType != nil {
                map["DatasetType"] = self.datasetType!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreatedTime") && dict["CreatedTime"] != nil {
                self.createdTime = dict["CreatedTime"] as! String
            }
            if dict.keys.contains("DatasetId") && dict["DatasetId"] != nil {
                self.datasetId = dict["DatasetId"] as! String
            }
            if dict.keys.contains("DatasetName") && dict["DatasetName"] != nil {
                self.datasetName = dict["DatasetName"] as! String
            }
            if dict.keys.contains("DatasetType") && dict["DatasetType"] != nil {
                self.datasetType = dict["DatasetType"] as! String
            }
            if dict.keys.contains("ModifiedTime") && dict["ModifiedTime"] != nil {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
        }
    }
    public var datasetInfo: DescribeDatasetInfoResponseBody.DatasetInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.datasetInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.datasetInfo != nil {
            map["DatasetInfo"] = self.datasetInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DatasetInfo") && dict["DatasetInfo"] != nil {
            var model = DescribeDatasetInfoResponseBody.DatasetInfo()
            model.fromMap(dict["DatasetInfo"] as! [String: Any])
            self.datasetInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeDatasetInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDatasetInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeDatasetInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDatasetItemInfoRequest : Tea.TeaModel {
    public var datasetId: String?

    public var datasetItemId: String?

    public var securityToken: String?

    public var value: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.datasetId != nil {
            map["DatasetId"] = self.datasetId!
        }
        if self.datasetItemId != nil {
            map["DatasetItemId"] = self.datasetItemId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.value != nil {
            map["Value"] = self.value!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DatasetId") && dict["DatasetId"] != nil {
            self.datasetId = dict["DatasetId"] as! String
        }
        if dict.keys.contains("DatasetItemId") && dict["DatasetItemId"] != nil {
            self.datasetItemId = dict["DatasetItemId"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("Value") && dict["Value"] != nil {
            self.value = dict["Value"] as! String
        }
    }
}

public class DescribeDatasetItemInfoResponseBody : Tea.TeaModel {
    public class DatasetItemInfo : Tea.TeaModel {
        public var createdTime: String?

        public var datasetId: String?

        public var datasetItemId: String?

        public var description_: String?

        public var expiredTime: String?

        public var modifiedTime: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createdTime != nil {
                map["CreatedTime"] = self.createdTime!
            }
            if self.datasetId != nil {
                map["DatasetId"] = self.datasetId!
            }
            if self.datasetItemId != nil {
                map["DatasetItemId"] = self.datasetItemId!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.expiredTime != nil {
                map["ExpiredTime"] = self.expiredTime!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreatedTime") && dict["CreatedTime"] != nil {
                self.createdTime = dict["CreatedTime"] as! String
            }
            if dict.keys.contains("DatasetId") && dict["DatasetId"] != nil {
                self.datasetId = dict["DatasetId"] as! String
            }
            if dict.keys.contains("DatasetItemId") && dict["DatasetItemId"] != nil {
                self.datasetItemId = dict["DatasetItemId"] as! String
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("ExpiredTime") && dict["ExpiredTime"] != nil {
                self.expiredTime = dict["ExpiredTime"] as! String
            }
            if dict.keys.contains("ModifiedTime") && dict["ModifiedTime"] != nil {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var datasetItemInfo: DescribeDatasetItemInfoResponseBody.DatasetItemInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.datasetItemInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.datasetItemInfo != nil {
            map["DatasetItemInfo"] = self.datasetItemInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DatasetItemInfo") && dict["DatasetItemInfo"] != nil {
            var model = DescribeDatasetItemInfoResponseBody.DatasetItemInfo()
            model.fromMap(dict["DatasetItemInfo"] as! [String: Any])
            self.datasetItemInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeDatasetItemInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDatasetItemInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeDatasetItemInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDatasetItemListRequest : Tea.TeaModel {
    public var datasetId: String?

    public var datasetItemIds: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.datasetId != nil {
            map["DatasetId"] = self.datasetId!
        }
        if self.datasetItemIds != nil {
            map["DatasetItemIds"] = self.datasetItemIds!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DatasetId") && dict["DatasetId"] != nil {
            self.datasetId = dict["DatasetId"] as! String
        }
        if dict.keys.contains("DatasetItemIds") && dict["DatasetItemIds"] != nil {
            self.datasetItemIds = dict["DatasetItemIds"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DescribeDatasetItemListResponseBody : Tea.TeaModel {
    public class DatasetItemInfoList : Tea.TeaModel {
        public var createdTime: String?

        public var datasetId: String?

        public var datasetItemId: String?

        public var description_: String?

        public var expiredTime: String?

        public var modifiedTime: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createdTime != nil {
                map["CreatedTime"] = self.createdTime!
            }
            if self.datasetId != nil {
                map["DatasetId"] = self.datasetId!
            }
            if self.datasetItemId != nil {
                map["DatasetItemId"] = self.datasetItemId!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.expiredTime != nil {
                map["ExpiredTime"] = self.expiredTime!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreatedTime") && dict["CreatedTime"] != nil {
                self.createdTime = dict["CreatedTime"] as! String
            }
            if dict.keys.contains("DatasetId") && dict["DatasetId"] != nil {
                self.datasetId = dict["DatasetId"] as! String
            }
            if dict.keys.contains("DatasetItemId") && dict["DatasetItemId"] != nil {
                self.datasetItemId = dict["DatasetItemId"] as! String
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("ExpiredTime") && dict["ExpiredTime"] != nil {
                self.expiredTime = dict["ExpiredTime"] as! String
            }
            if dict.keys.contains("ModifiedTime") && dict["ModifiedTime"] != nil {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var datasetItemInfoList: [DescribeDatasetItemListResponseBody.DatasetItemInfoList]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.datasetItemInfoList != nil {
            var tmp : [Any] = []
            for k in self.datasetItemInfoList! {
                tmp.append(k.toMap())
            }
            map["DatasetItemInfoList"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DatasetItemInfoList") && dict["DatasetItemInfoList"] != nil {
            var tmp : [DescribeDatasetItemListResponseBody.DatasetItemInfoList] = []
            for v in dict["DatasetItemInfoList"] as! [Any] {
                var model = DescribeDatasetItemListResponseBody.DatasetItemInfoList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.datasetItemInfoList = tmp
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeDatasetItemListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDatasetItemListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeDatasetItemListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDatasetListRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var datasetIds: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var securityToken: String?

    public var tag: [DescribeDatasetListRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.datasetIds != nil {
            map["DatasetIds"] = self.datasetIds!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DatasetIds") && dict["DatasetIds"] != nil {
            self.datasetIds = dict["DatasetIds"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("Tag") && dict["Tag"] != nil {
            var tmp : [DescribeDatasetListRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = DescribeDatasetListRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class DescribeDatasetListResponseBody : Tea.TeaModel {
    public class DatasetInfoList : Tea.TeaModel {
        public class Tags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") && dict["Key"] != nil {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var createdTime: String?

        public var datasetId: String?

        public var datasetName: String?

        public var datasetType: String?

        public var modifiedTime: String?

        public var tags: [DescribeDatasetListResponseBody.DatasetInfoList.Tags]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createdTime != nil {
                map["CreatedTime"] = self.createdTime!
            }
            if self.datasetId != nil {
                map["DatasetId"] = self.datasetId!
            }
            if self.datasetName != nil {
                map["DatasetName"] = self.datasetName!
            }
            if self.datasetType != nil {
                map["DatasetType"] = self.datasetType!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreatedTime") && dict["CreatedTime"] != nil {
                self.createdTime = dict["CreatedTime"] as! String
            }
            if dict.keys.contains("DatasetId") && dict["DatasetId"] != nil {
                self.datasetId = dict["DatasetId"] as! String
            }
            if dict.keys.contains("DatasetName") && dict["DatasetName"] != nil {
                self.datasetName = dict["DatasetName"] as! String
            }
            if dict.keys.contains("DatasetType") && dict["DatasetType"] != nil {
                self.datasetType = dict["DatasetType"] as! String
            }
            if dict.keys.contains("ModifiedTime") && dict["ModifiedTime"] != nil {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("Tags") && dict["Tags"] != nil {
                var tmp : [DescribeDatasetListResponseBody.DatasetInfoList.Tags] = []
                for v in dict["Tags"] as! [Any] {
                    var model = DescribeDatasetListResponseBody.DatasetInfoList.Tags()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tags = tmp
            }
        }
    }
    public var datasetInfoList: [DescribeDatasetListResponseBody.DatasetInfoList]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.datasetInfoList != nil {
            var tmp : [Any] = []
            for k in self.datasetInfoList! {
                tmp.append(k.toMap())
            }
            map["DatasetInfoList"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DatasetInfoList") && dict["DatasetInfoList"] != nil {
            var tmp : [DescribeDatasetListResponseBody.DatasetInfoList] = []
            for v in dict["DatasetInfoList"] as! [Any] {
                var model = DescribeDatasetListResponseBody.DatasetInfoList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.datasetInfoList = tmp
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeDatasetListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDatasetListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeDatasetListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDeployApiTaskRequest : Tea.TeaModel {
    public var operationUid: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.operationUid != nil {
            map["OperationUid"] = self.operationUid!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OperationUid") && dict["OperationUid"] != nil {
            self.operationUid = dict["OperationUid"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DescribeDeployApiTaskResponseBody : Tea.TeaModel {
    public class DeployedResults : Tea.TeaModel {
        public class DeployedResult : Tea.TeaModel {
            public var apiUid: String?

            public var deployedStatus: String?

            public var errorMsg: String?

            public var groupId: String?

            public var stageName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.apiUid != nil {
                    map["ApiUid"] = self.apiUid!
                }
                if self.deployedStatus != nil {
                    map["DeployedStatus"] = self.deployedStatus!
                }
                if self.errorMsg != nil {
                    map["ErrorMsg"] = self.errorMsg!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.stageName != nil {
                    map["StageName"] = self.stageName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ApiUid") && dict["ApiUid"] != nil {
                    self.apiUid = dict["ApiUid"] as! String
                }
                if dict.keys.contains("DeployedStatus") && dict["DeployedStatus"] != nil {
                    self.deployedStatus = dict["DeployedStatus"] as! String
                }
                if dict.keys.contains("ErrorMsg") && dict["ErrorMsg"] != nil {
                    self.errorMsg = dict["ErrorMsg"] as! String
                }
                if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("StageName") && dict["StageName"] != nil {
                    self.stageName = dict["StageName"] as! String
                }
            }
        }
        public var deployedResult: [DescribeDeployApiTaskResponseBody.DeployedResults.DeployedResult]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.deployedResult != nil {
                var tmp : [Any] = []
                for k in self.deployedResult! {
                    tmp.append(k.toMap())
                }
                map["DeployedResult"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DeployedResult") && dict["DeployedResult"] != nil {
                var tmp : [DescribeDeployApiTaskResponseBody.DeployedResults.DeployedResult] = []
                for v in dict["DeployedResult"] as! [Any] {
                    var model = DescribeDeployApiTaskResponseBody.DeployedResults.DeployedResult()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.deployedResult = tmp
            }
        }
    }
    public var deployedResults: DescribeDeployApiTaskResponseBody.DeployedResults?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.deployedResults?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deployedResults != nil {
            map["DeployedResults"] = self.deployedResults?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeployedResults") && dict["DeployedResults"] != nil {
            var model = DescribeDeployApiTaskResponseBody.DeployedResults()
            model.fromMap(dict["DeployedResults"] as! [String: Any])
            self.deployedResults = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeDeployApiTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDeployApiTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeDeployApiTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDeployedApiRequest : Tea.TeaModel {
    public var apiId: String?

    public var groupId: String?

    public var securityToken: String?

    public var stageName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.stageName != nil {
            map["StageName"] = self.stageName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiId") && dict["ApiId"] != nil {
            self.apiId = dict["ApiId"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StageName") && dict["StageName"] != nil {
            self.stageName = dict["StageName"] as! String
        }
    }
}

public class DescribeDeployedApiResponseBody : Tea.TeaModel {
    public class ConstantParameters : Tea.TeaModel {
        public class ConstantParameter : Tea.TeaModel {
            public var constantValue: String?

            public var description_: String?

            public var location: String?

            public var serviceParameterName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.constantValue != nil {
                    map["ConstantValue"] = self.constantValue!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.location != nil {
                    map["Location"] = self.location!
                }
                if self.serviceParameterName != nil {
                    map["ServiceParameterName"] = self.serviceParameterName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ConstantValue") && dict["ConstantValue"] != nil {
                    self.constantValue = dict["ConstantValue"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Location") && dict["Location"] != nil {
                    self.location = dict["Location"] as! String
                }
                if dict.keys.contains("ServiceParameterName") && dict["ServiceParameterName"] != nil {
                    self.serviceParameterName = dict["ServiceParameterName"] as! String
                }
            }
        }
        public var constantParameter: [DescribeDeployedApiResponseBody.ConstantParameters.ConstantParameter]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.constantParameter != nil {
                var tmp : [Any] = []
                for k in self.constantParameter! {
                    tmp.append(k.toMap())
                }
                map["ConstantParameter"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConstantParameter") && dict["ConstantParameter"] != nil {
                var tmp : [DescribeDeployedApiResponseBody.ConstantParameters.ConstantParameter] = []
                for v in dict["ConstantParameter"] as! [Any] {
                    var model = DescribeDeployedApiResponseBody.ConstantParameters.ConstantParameter()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.constantParameter = tmp
            }
        }
    }
    public class CustomSystemParameters : Tea.TeaModel {
        public class CustomSystemParameter : Tea.TeaModel {
            public var demoValue: String?

            public var description_: String?

            public var location: String?

            public var parameterName: String?

            public var serviceParameterName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.demoValue != nil {
                    map["DemoValue"] = self.demoValue!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.location != nil {
                    map["Location"] = self.location!
                }
                if self.parameterName != nil {
                    map["ParameterName"] = self.parameterName!
                }
                if self.serviceParameterName != nil {
                    map["ServiceParameterName"] = self.serviceParameterName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DemoValue") && dict["DemoValue"] != nil {
                    self.demoValue = dict["DemoValue"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Location") && dict["Location"] != nil {
                    self.location = dict["Location"] as! String
                }
                if dict.keys.contains("ParameterName") && dict["ParameterName"] != nil {
                    self.parameterName = dict["ParameterName"] as! String
                }
                if dict.keys.contains("ServiceParameterName") && dict["ServiceParameterName"] != nil {
                    self.serviceParameterName = dict["ServiceParameterName"] as! String
                }
            }
        }
        public var customSystemParameter: [DescribeDeployedApiResponseBody.CustomSystemParameters.CustomSystemParameter]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.customSystemParameter != nil {
                var tmp : [Any] = []
                for k in self.customSystemParameter! {
                    tmp.append(k.toMap())
                }
                map["CustomSystemParameter"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CustomSystemParameter") && dict["CustomSystemParameter"] != nil {
                var tmp : [DescribeDeployedApiResponseBody.CustomSystemParameters.CustomSystemParameter] = []
                for v in dict["CustomSystemParameter"] as! [Any] {
                    var model = DescribeDeployedApiResponseBody.CustomSystemParameters.CustomSystemParameter()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.customSystemParameter = tmp
            }
        }
    }
    public class ErrorCodeSamples : Tea.TeaModel {
        public class ErrorCodeSample : Tea.TeaModel {
            public var code: String?

            public var description_: String?

            public var message: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Code") && dict["Code"] != nil {
                    self.code = dict["Code"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Message") && dict["Message"] != nil {
                    self.message = dict["Message"] as! String
                }
            }
        }
        public var errorCodeSample: [DescribeDeployedApiResponseBody.ErrorCodeSamples.ErrorCodeSample]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.errorCodeSample != nil {
                var tmp : [Any] = []
                for k in self.errorCodeSample! {
                    tmp.append(k.toMap())
                }
                map["ErrorCodeSample"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ErrorCodeSample") && dict["ErrorCodeSample"] != nil {
                var tmp : [DescribeDeployedApiResponseBody.ErrorCodeSamples.ErrorCodeSample] = []
                for v in dict["ErrorCodeSample"] as! [Any] {
                    var model = DescribeDeployedApiResponseBody.ErrorCodeSamples.ErrorCodeSample()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.errorCodeSample = tmp
            }
        }
    }
    public class OpenIdConnectConfig : Tea.TeaModel {
        public var idTokenParamName: String?

        public var openIdApiType: String?

        public var publicKey: String?

        public var publicKeyId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.idTokenParamName != nil {
                map["IdTokenParamName"] = self.idTokenParamName!
            }
            if self.openIdApiType != nil {
                map["OpenIdApiType"] = self.openIdApiType!
            }
            if self.publicKey != nil {
                map["PublicKey"] = self.publicKey!
            }
            if self.publicKeyId != nil {
                map["PublicKeyId"] = self.publicKeyId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("IdTokenParamName") && dict["IdTokenParamName"] != nil {
                self.idTokenParamName = dict["IdTokenParamName"] as! String
            }
            if dict.keys.contains("OpenIdApiType") && dict["OpenIdApiType"] != nil {
                self.openIdApiType = dict["OpenIdApiType"] as! String
            }
            if dict.keys.contains("PublicKey") && dict["PublicKey"] != nil {
                self.publicKey = dict["PublicKey"] as! String
            }
            if dict.keys.contains("PublicKeyId") && dict["PublicKeyId"] != nil {
                self.publicKeyId = dict["PublicKeyId"] as! String
            }
        }
    }
    public class RequestConfig : Tea.TeaModel {
        public var bodyFormat: String?

        public var bodyModel: String?

        public var postBodyDescription: String?

        public var requestHttpMethod: String?

        public var requestMode: String?

        public var requestPath: String?

        public var requestProtocol: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bodyFormat != nil {
                map["BodyFormat"] = self.bodyFormat!
            }
            if self.bodyModel != nil {
                map["BodyModel"] = self.bodyModel!
            }
            if self.postBodyDescription != nil {
                map["PostBodyDescription"] = self.postBodyDescription!
            }
            if self.requestHttpMethod != nil {
                map["RequestHttpMethod"] = self.requestHttpMethod!
            }
            if self.requestMode != nil {
                map["RequestMode"] = self.requestMode!
            }
            if self.requestPath != nil {
                map["RequestPath"] = self.requestPath!
            }
            if self.requestProtocol != nil {
                map["RequestProtocol"] = self.requestProtocol!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BodyFormat") && dict["BodyFormat"] != nil {
                self.bodyFormat = dict["BodyFormat"] as! String
            }
            if dict.keys.contains("BodyModel") && dict["BodyModel"] != nil {
                self.bodyModel = dict["BodyModel"] as! String
            }
            if dict.keys.contains("PostBodyDescription") && dict["PostBodyDescription"] != nil {
                self.postBodyDescription = dict["PostBodyDescription"] as! String
            }
            if dict.keys.contains("RequestHttpMethod") && dict["RequestHttpMethod"] != nil {
                self.requestHttpMethod = dict["RequestHttpMethod"] as! String
            }
            if dict.keys.contains("RequestMode") && dict["RequestMode"] != nil {
                self.requestMode = dict["RequestMode"] as! String
            }
            if dict.keys.contains("RequestPath") && dict["RequestPath"] != nil {
                self.requestPath = dict["RequestPath"] as! String
            }
            if dict.keys.contains("RequestProtocol") && dict["RequestProtocol"] != nil {
                self.requestProtocol = dict["RequestProtocol"] as! String
            }
        }
    }
    public class RequestParameters : Tea.TeaModel {
        public class RequestParameter : Tea.TeaModel {
            public var apiParameterName: String?

            public var arrayItemsType: String?

            public var defaultValue: String?

            public var demoValue: String?

            public var description_: String?

            public var docOrder: Int32?

            public var docShow: String?

            public var enumValue: String?

            public var jsonScheme: String?

            public var location: String?

            public var maxLength: Int64?

            public var maxValue: Int64?

            public var minLength: Int64?

            public var minValue: Int64?

            public var parameterType: String?

            public var regularExpression: String?

            public var required_: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.apiParameterName != nil {
                    map["ApiParameterName"] = self.apiParameterName!
                }
                if self.arrayItemsType != nil {
                    map["ArrayItemsType"] = self.arrayItemsType!
                }
                if self.defaultValue != nil {
                    map["DefaultValue"] = self.defaultValue!
                }
                if self.demoValue != nil {
                    map["DemoValue"] = self.demoValue!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.docOrder != nil {
                    map["DocOrder"] = self.docOrder!
                }
                if self.docShow != nil {
                    map["DocShow"] = self.docShow!
                }
                if self.enumValue != nil {
                    map["EnumValue"] = self.enumValue!
                }
                if self.jsonScheme != nil {
                    map["JsonScheme"] = self.jsonScheme!
                }
                if self.location != nil {
                    map["Location"] = self.location!
                }
                if self.maxLength != nil {
                    map["MaxLength"] = self.maxLength!
                }
                if self.maxValue != nil {
                    map["MaxValue"] = self.maxValue!
                }
                if self.minLength != nil {
                    map["MinLength"] = self.minLength!
                }
                if self.minValue != nil {
                    map["MinValue"] = self.minValue!
                }
                if self.parameterType != nil {
                    map["ParameterType"] = self.parameterType!
                }
                if self.regularExpression != nil {
                    map["RegularExpression"] = self.regularExpression!
                }
                if self.required_ != nil {
                    map["Required"] = self.required_!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ApiParameterName") && dict["ApiParameterName"] != nil {
                    self.apiParameterName = dict["ApiParameterName"] as! String
                }
                if dict.keys.contains("ArrayItemsType") && dict["ArrayItemsType"] != nil {
                    self.arrayItemsType = dict["ArrayItemsType"] as! String
                }
                if dict.keys.contains("DefaultValue") && dict["DefaultValue"] != nil {
                    self.defaultValue = dict["DefaultValue"] as! String
                }
                if dict.keys.contains("DemoValue") && dict["DemoValue"] != nil {
                    self.demoValue = dict["DemoValue"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("DocOrder") && dict["DocOrder"] != nil {
                    self.docOrder = dict["DocOrder"] as! Int32
                }
                if dict.keys.contains("DocShow") && dict["DocShow"] != nil {
                    self.docShow = dict["DocShow"] as! String
                }
                if dict.keys.contains("EnumValue") && dict["EnumValue"] != nil {
                    self.enumValue = dict["EnumValue"] as! String
                }
                if dict.keys.contains("JsonScheme") && dict["JsonScheme"] != nil {
                    self.jsonScheme = dict["JsonScheme"] as! String
                }
                if dict.keys.contains("Location") && dict["Location"] != nil {
                    self.location = dict["Location"] as! String
                }
                if dict.keys.contains("MaxLength") && dict["MaxLength"] != nil {
                    self.maxLength = dict["MaxLength"] as! Int64
                }
                if dict.keys.contains("MaxValue") && dict["MaxValue"] != nil {
                    self.maxValue = dict["MaxValue"] as! Int64
                }
                if dict.keys.contains("MinLength") && dict["MinLength"] != nil {
                    self.minLength = dict["MinLength"] as! Int64
                }
                if dict.keys.contains("MinValue") && dict["MinValue"] != nil {
                    self.minValue = dict["MinValue"] as! Int64
                }
                if dict.keys.contains("ParameterType") && dict["ParameterType"] != nil {
                    self.parameterType = dict["ParameterType"] as! String
                }
                if dict.keys.contains("RegularExpression") && dict["RegularExpression"] != nil {
                    self.regularExpression = dict["RegularExpression"] as! String
                }
                if dict.keys.contains("Required") && dict["Required"] != nil {
                    self.required_ = dict["Required"] as! String
                }
            }
        }
        public var requestParameter: [DescribeDeployedApiResponseBody.RequestParameters.RequestParameter]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.requestParameter != nil {
                var tmp : [Any] = []
                for k in self.requestParameter! {
                    tmp.append(k.toMap())
                }
                map["RequestParameter"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("RequestParameter") && dict["RequestParameter"] != nil {
                var tmp : [DescribeDeployedApiResponseBody.RequestParameters.RequestParameter] = []
                for v in dict["RequestParameter"] as! [Any] {
                    var model = DescribeDeployedApiResponseBody.RequestParameters.RequestParameter()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.requestParameter = tmp
            }
        }
    }
    public class ResultDescriptions : Tea.TeaModel {
        public class ResultDescription : Tea.TeaModel {
            public var description_: String?

            public var hasChild: Bool?

            public var id: String?

            public var key: String?

            public var mandatory: Bool?

            public var name: String?

            public var pid: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.hasChild != nil {
                    map["HasChild"] = self.hasChild!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.mandatory != nil {
                    map["Mandatory"] = self.mandatory!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.pid != nil {
                    map["Pid"] = self.pid!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("HasChild") && dict["HasChild"] != nil {
                    self.hasChild = dict["HasChild"] as! Bool
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("Key") && dict["Key"] != nil {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Mandatory") && dict["Mandatory"] != nil {
                    self.mandatory = dict["Mandatory"] as! Bool
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Pid") && dict["Pid"] != nil {
                    self.pid = dict["Pid"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var resultDescription: [DescribeDeployedApiResponseBody.ResultDescriptions.ResultDescription]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.resultDescription != nil {
                var tmp : [Any] = []
                for k in self.resultDescription! {
                    tmp.append(k.toMap())
                }
                map["ResultDescription"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ResultDescription") && dict["ResultDescription"] != nil {
                var tmp : [DescribeDeployedApiResponseBody.ResultDescriptions.ResultDescription] = []
                for v in dict["ResultDescription"] as! [Any] {
                    var model = DescribeDeployedApiResponseBody.ResultDescriptions.ResultDescription()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.resultDescription = tmp
            }
        }
    }
    public class ServiceConfig : Tea.TeaModel {
        public class FunctionComputeConfig : Tea.TeaModel {
            public var contentTypeCatagory: String?

            public var contentTypeValue: String?

            public var fcBaseUrl: String?

            public var fcType: String?

            public var functionName: String?

            public var method: String?

            public var onlyBusinessPath: Bool?

            public var path: String?

            public var qualifier: String?

            public var regionId: String?

            public var roleArn: String?

            public var serviceName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.contentTypeCatagory != nil {
                    map["ContentTypeCatagory"] = self.contentTypeCatagory!
                }
                if self.contentTypeValue != nil {
                    map["ContentTypeValue"] = self.contentTypeValue!
                }
                if self.fcBaseUrl != nil {
                    map["FcBaseUrl"] = self.fcBaseUrl!
                }
                if self.fcType != nil {
                    map["FcType"] = self.fcType!
                }
                if self.functionName != nil {
                    map["FunctionName"] = self.functionName!
                }
                if self.method != nil {
                    map["Method"] = self.method!
                }
                if self.onlyBusinessPath != nil {
                    map["OnlyBusinessPath"] = self.onlyBusinessPath!
                }
                if self.path != nil {
                    map["Path"] = self.path!
                }
                if self.qualifier != nil {
                    map["Qualifier"] = self.qualifier!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.roleArn != nil {
                    map["RoleArn"] = self.roleArn!
                }
                if self.serviceName != nil {
                    map["ServiceName"] = self.serviceName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ContentTypeCatagory") && dict["ContentTypeCatagory"] != nil {
                    self.contentTypeCatagory = dict["ContentTypeCatagory"] as! String
                }
                if dict.keys.contains("ContentTypeValue") && dict["ContentTypeValue"] != nil {
                    self.contentTypeValue = dict["ContentTypeValue"] as! String
                }
                if dict.keys.contains("FcBaseUrl") && dict["FcBaseUrl"] != nil {
                    self.fcBaseUrl = dict["FcBaseUrl"] as! String
                }
                if dict.keys.contains("FcType") && dict["FcType"] != nil {
                    self.fcType = dict["FcType"] as! String
                }
                if dict.keys.contains("FunctionName") && dict["FunctionName"] != nil {
                    self.functionName = dict["FunctionName"] as! String
                }
                if dict.keys.contains("Method") && dict["Method"] != nil {
                    self.method = dict["Method"] as! String
                }
                if dict.keys.contains("OnlyBusinessPath") && dict["OnlyBusinessPath"] != nil {
                    self.onlyBusinessPath = dict["OnlyBusinessPath"] as! Bool
                }
                if dict.keys.contains("Path") && dict["Path"] != nil {
                    self.path = dict["Path"] as! String
                }
                if dict.keys.contains("Qualifier") && dict["Qualifier"] != nil {
                    self.qualifier = dict["Qualifier"] as! String
                }
                if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("RoleArn") && dict["RoleArn"] != nil {
                    self.roleArn = dict["RoleArn"] as! String
                }
                if dict.keys.contains("ServiceName") && dict["ServiceName"] != nil {
                    self.serviceName = dict["ServiceName"] as! String
                }
            }
        }
        public class MockHeaders : Tea.TeaModel {
            public class MockHeader : Tea.TeaModel {
                public var headerName: String?

                public var headerValue: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.headerName != nil {
                        map["HeaderName"] = self.headerName!
                    }
                    if self.headerValue != nil {
                        map["HeaderValue"] = self.headerValue!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("HeaderName") && dict["HeaderName"] != nil {
                        self.headerName = dict["HeaderName"] as! String
                    }
                    if dict.keys.contains("HeaderValue") && dict["HeaderValue"] != nil {
                        self.headerValue = dict["HeaderValue"] as! String
                    }
                }
            }
            public var mockHeader: [DescribeDeployedApiResponseBody.ServiceConfig.MockHeaders.MockHeader]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.mockHeader != nil {
                    var tmp : [Any] = []
                    for k in self.mockHeader! {
                        tmp.append(k.toMap())
                    }
                    map["MockHeader"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("MockHeader") && dict["MockHeader"] != nil {
                    var tmp : [DescribeDeployedApiResponseBody.ServiceConfig.MockHeaders.MockHeader] = []
                    for v in dict["MockHeader"] as! [Any] {
                        var model = DescribeDeployedApiResponseBody.ServiceConfig.MockHeaders.MockHeader()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.mockHeader = tmp
                }
            }
        }
        public class VpcConfig : Tea.TeaModel {
            public var instanceId: String?

            public var name: String?

            public var port: Int32?

            public var vpcId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Port") && dict["Port"] != nil {
                    self.port = dict["Port"] as! Int32
                }
                if dict.keys.contains("VpcId") && dict["VpcId"] != nil {
                    self.vpcId = dict["VpcId"] as! String
                }
            }
        }
        public var functionComputeConfig: DescribeDeployedApiResponseBody.ServiceConfig.FunctionComputeConfig?

        public var mock: String?

        public var mockHeaders: DescribeDeployedApiResponseBody.ServiceConfig.MockHeaders?

        public var mockResult: String?

        public var mockStatusCode: Int32?

        public var serviceAddress: String?

        public var serviceHttpMethod: String?

        public var servicePath: String?

        public var serviceProtocol: String?

        public var serviceTimeout: Int32?

        public var serviceVpcEnable: String?

        public var vpcConfig: DescribeDeployedApiResponseBody.ServiceConfig.VpcConfig?

        public var vpcId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.functionComputeConfig?.validate()
            try self.mockHeaders?.validate()
            try self.vpcConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.functionComputeConfig != nil {
                map["FunctionComputeConfig"] = self.functionComputeConfig?.toMap()
            }
            if self.mock != nil {
                map["Mock"] = self.mock!
            }
            if self.mockHeaders != nil {
                map["MockHeaders"] = self.mockHeaders?.toMap()
            }
            if self.mockResult != nil {
                map["MockResult"] = self.mockResult!
            }
            if self.mockStatusCode != nil {
                map["MockStatusCode"] = self.mockStatusCode!
            }
            if self.serviceAddress != nil {
                map["ServiceAddress"] = self.serviceAddress!
            }
            if self.serviceHttpMethod != nil {
                map["ServiceHttpMethod"] = self.serviceHttpMethod!
            }
            if self.servicePath != nil {
                map["ServicePath"] = self.servicePath!
            }
            if self.serviceProtocol != nil {
                map["ServiceProtocol"] = self.serviceProtocol!
            }
            if self.serviceTimeout != nil {
                map["ServiceTimeout"] = self.serviceTimeout!
            }
            if self.serviceVpcEnable != nil {
                map["ServiceVpcEnable"] = self.serviceVpcEnable!
            }
            if self.vpcConfig != nil {
                map["VpcConfig"] = self.vpcConfig?.toMap()
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FunctionComputeConfig") && dict["FunctionComputeConfig"] != nil {
                var model = DescribeDeployedApiResponseBody.ServiceConfig.FunctionComputeConfig()
                model.fromMap(dict["FunctionComputeConfig"] as! [String: Any])
                self.functionComputeConfig = model
            }
            if dict.keys.contains("Mock") && dict["Mock"] != nil {
                self.mock = dict["Mock"] as! String
            }
            if dict.keys.contains("MockHeaders") && dict["MockHeaders"] != nil {
                var model = DescribeDeployedApiResponseBody.ServiceConfig.MockHeaders()
                model.fromMap(dict["MockHeaders"] as! [String: Any])
                self.mockHeaders = model
            }
            if dict.keys.contains("MockResult") && dict["MockResult"] != nil {
                self.mockResult = dict["MockResult"] as! String
            }
            if dict.keys.contains("MockStatusCode") && dict["MockStatusCode"] != nil {
                self.mockStatusCode = dict["MockStatusCode"] as! Int32
            }
            if dict.keys.contains("ServiceAddress") && dict["ServiceAddress"] != nil {
                self.serviceAddress = dict["ServiceAddress"] as! String
            }
            if dict.keys.contains("ServiceHttpMethod") && dict["ServiceHttpMethod"] != nil {
                self.serviceHttpMethod = dict["ServiceHttpMethod"] as! String
            }
            if dict.keys.contains("ServicePath") && dict["ServicePath"] != nil {
                self.servicePath = dict["ServicePath"] as! String
            }
            if dict.keys.contains("ServiceProtocol") && dict["ServiceProtocol"] != nil {
                self.serviceProtocol = dict["ServiceProtocol"] as! String
            }
            if dict.keys.contains("ServiceTimeout") && dict["ServiceTimeout"] != nil {
                self.serviceTimeout = dict["ServiceTimeout"] as! Int32
            }
            if dict.keys.contains("ServiceVpcEnable") && dict["ServiceVpcEnable"] != nil {
                self.serviceVpcEnable = dict["ServiceVpcEnable"] as! String
            }
            if dict.keys.contains("VpcConfig") && dict["VpcConfig"] != nil {
                var model = DescribeDeployedApiResponseBody.ServiceConfig.VpcConfig()
                model.fromMap(dict["VpcConfig"] as! [String: Any])
                self.vpcConfig = model
            }
            if dict.keys.contains("VpcId") && dict["VpcId"] != nil {
                self.vpcId = dict["VpcId"] as! String
            }
        }
    }
    public class ServiceParameters : Tea.TeaModel {
        public class ServiceParameter : Tea.TeaModel {
            public var location: String?

            public var parameterType: String?

            public var serviceParameterName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.location != nil {
                    map["Location"] = self.location!
                }
                if self.parameterType != nil {
                    map["ParameterType"] = self.parameterType!
                }
                if self.serviceParameterName != nil {
                    map["ServiceParameterName"] = self.serviceParameterName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Location") && dict["Location"] != nil {
                    self.location = dict["Location"] as! String
                }
                if dict.keys.contains("ParameterType") && dict["ParameterType"] != nil {
                    self.parameterType = dict["ParameterType"] as! String
                }
                if dict.keys.contains("ServiceParameterName") && dict["ServiceParameterName"] != nil {
                    self.serviceParameterName = dict["ServiceParameterName"] as! String
                }
            }
        }
        public var serviceParameter: [DescribeDeployedApiResponseBody.ServiceParameters.ServiceParameter]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.serviceParameter != nil {
                var tmp : [Any] = []
                for k in self.serviceParameter! {
                    tmp.append(k.toMap())
                }
                map["ServiceParameter"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ServiceParameter") && dict["ServiceParameter"] != nil {
                var tmp : [DescribeDeployedApiResponseBody.ServiceParameters.ServiceParameter] = []
                for v in dict["ServiceParameter"] as! [Any] {
                    var model = DescribeDeployedApiResponseBody.ServiceParameters.ServiceParameter()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.serviceParameter = tmp
            }
        }
    }
    public class ServiceParametersMap : Tea.TeaModel {
        public class ServiceParameterMap : Tea.TeaModel {
            public var requestParameterName: String?

            public var serviceParameterName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.requestParameterName != nil {
                    map["RequestParameterName"] = self.requestParameterName!
                }
                if self.serviceParameterName != nil {
                    map["ServiceParameterName"] = self.serviceParameterName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("RequestParameterName") && dict["RequestParameterName"] != nil {
                    self.requestParameterName = dict["RequestParameterName"] as! String
                }
                if dict.keys.contains("ServiceParameterName") && dict["ServiceParameterName"] != nil {
                    self.serviceParameterName = dict["ServiceParameterName"] as! String
                }
            }
        }
        public var serviceParameterMap: [DescribeDeployedApiResponseBody.ServiceParametersMap.ServiceParameterMap]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.serviceParameterMap != nil {
                var tmp : [Any] = []
                for k in self.serviceParameterMap! {
                    tmp.append(k.toMap())
                }
                map["ServiceParameterMap"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ServiceParameterMap") && dict["ServiceParameterMap"] != nil {
                var tmp : [DescribeDeployedApiResponseBody.ServiceParametersMap.ServiceParameterMap] = []
                for v in dict["ServiceParameterMap"] as! [Any] {
                    var model = DescribeDeployedApiResponseBody.ServiceParametersMap.ServiceParameterMap()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.serviceParameterMap = tmp
            }
        }
    }
    public class SystemParameters : Tea.TeaModel {
        public class SystemParameter : Tea.TeaModel {
            public var demoValue: String?

            public var description_: String?

            public var location: String?

            public var parameterName: String?

            public var serviceParameterName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.demoValue != nil {
                    map["DemoValue"] = self.demoValue!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.location != nil {
                    map["Location"] = self.location!
                }
                if self.parameterName != nil {
                    map["ParameterName"] = self.parameterName!
                }
                if self.serviceParameterName != nil {
                    map["ServiceParameterName"] = self.serviceParameterName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DemoValue") && dict["DemoValue"] != nil {
                    self.demoValue = dict["DemoValue"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Location") && dict["Location"] != nil {
                    self.location = dict["Location"] as! String
                }
                if dict.keys.contains("ParameterName") && dict["ParameterName"] != nil {
                    self.parameterName = dict["ParameterName"] as! String
                }
                if dict.keys.contains("ServiceParameterName") && dict["ServiceParameterName"] != nil {
                    self.serviceParameterName = dict["ServiceParameterName"] as! String
                }
            }
        }
        public var systemParameter: [DescribeDeployedApiResponseBody.SystemParameters.SystemParameter]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.systemParameter != nil {
                var tmp : [Any] = []
                for k in self.systemParameter! {
                    tmp.append(k.toMap())
                }
                map["SystemParameter"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SystemParameter") && dict["SystemParameter"] != nil {
                var tmp : [DescribeDeployedApiResponseBody.SystemParameters.SystemParameter] = []
                for v in dict["SystemParameter"] as! [Any] {
                    var model = DescribeDeployedApiResponseBody.SystemParameters.SystemParameter()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.systemParameter = tmp
            }
        }
    }
    public var allowSignatureMethod: String?

    public var apiId: String?

    public var apiName: String?

    public var authType: String?

    public var constantParameters: DescribeDeployedApiResponseBody.ConstantParameters?

    public var customSystemParameters: DescribeDeployedApiResponseBody.CustomSystemParameters?

    public var deployedTime: String?

    public var description_: String?

    public var disableInternet: Bool?

    public var errorCodeSamples: DescribeDeployedApiResponseBody.ErrorCodeSamples?

    public var failResultSample: String?

    public var forceNonceCheck: Bool?

    public var groupId: String?

    public var groupName: String?

    public var openIdConnectConfig: DescribeDeployedApiResponseBody.OpenIdConnectConfig?

    public var regionId: String?

    public var requestConfig: DescribeDeployedApiResponseBody.RequestConfig?

    public var requestId: String?

    public var requestParameters: DescribeDeployedApiResponseBody.RequestParameters?

    public var resultBodyModel: String?

    public var resultDescriptions: DescribeDeployedApiResponseBody.ResultDescriptions?

    public var resultSample: String?

    public var resultType: String?

    public var serviceConfig: DescribeDeployedApiResponseBody.ServiceConfig?

    public var serviceParameters: DescribeDeployedApiResponseBody.ServiceParameters?

    public var serviceParametersMap: DescribeDeployedApiResponseBody.ServiceParametersMap?

    public var stageName: String?

    public var systemParameters: DescribeDeployedApiResponseBody.SystemParameters?

    public var visibility: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.constantParameters?.validate()
        try self.customSystemParameters?.validate()
        try self.errorCodeSamples?.validate()
        try self.openIdConnectConfig?.validate()
        try self.requestConfig?.validate()
        try self.requestParameters?.validate()
        try self.resultDescriptions?.validate()
        try self.serviceConfig?.validate()
        try self.serviceParameters?.validate()
        try self.serviceParametersMap?.validate()
        try self.systemParameters?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.allowSignatureMethod != nil {
            map["AllowSignatureMethod"] = self.allowSignatureMethod!
        }
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.apiName != nil {
            map["ApiName"] = self.apiName!
        }
        if self.authType != nil {
            map["AuthType"] = self.authType!
        }
        if self.constantParameters != nil {
            map["ConstantParameters"] = self.constantParameters?.toMap()
        }
        if self.customSystemParameters != nil {
            map["CustomSystemParameters"] = self.customSystemParameters?.toMap()
        }
        if self.deployedTime != nil {
            map["DeployedTime"] = self.deployedTime!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.disableInternet != nil {
            map["DisableInternet"] = self.disableInternet!
        }
        if self.errorCodeSamples != nil {
            map["ErrorCodeSamples"] = self.errorCodeSamples?.toMap()
        }
        if self.failResultSample != nil {
            map["FailResultSample"] = self.failResultSample!
        }
        if self.forceNonceCheck != nil {
            map["ForceNonceCheck"] = self.forceNonceCheck!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.openIdConnectConfig != nil {
            map["OpenIdConnectConfig"] = self.openIdConnectConfig?.toMap()
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestConfig != nil {
            map["RequestConfig"] = self.requestConfig?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.requestParameters != nil {
            map["RequestParameters"] = self.requestParameters?.toMap()
        }
        if self.resultBodyModel != nil {
            map["ResultBodyModel"] = self.resultBodyModel!
        }
        if self.resultDescriptions != nil {
            map["ResultDescriptions"] = self.resultDescriptions?.toMap()
        }
        if self.resultSample != nil {
            map["ResultSample"] = self.resultSample!
        }
        if self.resultType != nil {
            map["ResultType"] = self.resultType!
        }
        if self.serviceConfig != nil {
            map["ServiceConfig"] = self.serviceConfig?.toMap()
        }
        if self.serviceParameters != nil {
            map["ServiceParameters"] = self.serviceParameters?.toMap()
        }
        if self.serviceParametersMap != nil {
            map["ServiceParametersMap"] = self.serviceParametersMap?.toMap()
        }
        if self.stageName != nil {
            map["StageName"] = self.stageName!
        }
        if self.systemParameters != nil {
            map["SystemParameters"] = self.systemParameters?.toMap()
        }
        if self.visibility != nil {
            map["Visibility"] = self.visibility!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AllowSignatureMethod") && dict["AllowSignatureMethod"] != nil {
            self.allowSignatureMethod = dict["AllowSignatureMethod"] as! String
        }
        if dict.keys.contains("ApiId") && dict["ApiId"] != nil {
            self.apiId = dict["ApiId"] as! String
        }
        if dict.keys.contains("ApiName") && dict["ApiName"] != nil {
            self.apiName = dict["ApiName"] as! String
        }
        if dict.keys.contains("AuthType") && dict["AuthType"] != nil {
            self.authType = dict["AuthType"] as! String
        }
        if dict.keys.contains("ConstantParameters") && dict["ConstantParameters"] != nil {
            var model = DescribeDeployedApiResponseBody.ConstantParameters()
            model.fromMap(dict["ConstantParameters"] as! [String: Any])
            self.constantParameters = model
        }
        if dict.keys.contains("CustomSystemParameters") && dict["CustomSystemParameters"] != nil {
            var model = DescribeDeployedApiResponseBody.CustomSystemParameters()
            model.fromMap(dict["CustomSystemParameters"] as! [String: Any])
            self.customSystemParameters = model
        }
        if dict.keys.contains("DeployedTime") && dict["DeployedTime"] != nil {
            self.deployedTime = dict["DeployedTime"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DisableInternet") && dict["DisableInternet"] != nil {
            self.disableInternet = dict["DisableInternet"] as! Bool
        }
        if dict.keys.contains("ErrorCodeSamples") && dict["ErrorCodeSamples"] != nil {
            var model = DescribeDeployedApiResponseBody.ErrorCodeSamples()
            model.fromMap(dict["ErrorCodeSamples"] as! [String: Any])
            self.errorCodeSamples = model
        }
        if dict.keys.contains("FailResultSample") && dict["FailResultSample"] != nil {
            self.failResultSample = dict["FailResultSample"] as! String
        }
        if dict.keys.contains("ForceNonceCheck") && dict["ForceNonceCheck"] != nil {
            self.forceNonceCheck = dict["ForceNonceCheck"] as! Bool
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("OpenIdConnectConfig") && dict["OpenIdConnectConfig"] != nil {
            var model = DescribeDeployedApiResponseBody.OpenIdConnectConfig()
            model.fromMap(dict["OpenIdConnectConfig"] as! [String: Any])
            self.openIdConnectConfig = model
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RequestConfig") && dict["RequestConfig"] != nil {
            var model = DescribeDeployedApiResponseBody.RequestConfig()
            model.fromMap(dict["RequestConfig"] as! [String: Any])
            self.requestConfig = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RequestParameters") && dict["RequestParameters"] != nil {
            var model = DescribeDeployedApiResponseBody.RequestParameters()
            model.fromMap(dict["RequestParameters"] as! [String: Any])
            self.requestParameters = model
        }
        if dict.keys.contains("ResultBodyModel") && dict["ResultBodyModel"] != nil {
            self.resultBodyModel = dict["ResultBodyModel"] as! String
        }
        if dict.keys.contains("ResultDescriptions") && dict["ResultDescriptions"] != nil {
            var model = DescribeDeployedApiResponseBody.ResultDescriptions()
            model.fromMap(dict["ResultDescriptions"] as! [String: Any])
            self.resultDescriptions = model
        }
        if dict.keys.contains("ResultSample") && dict["ResultSample"] != nil {
            self.resultSample = dict["ResultSample"] as! String
        }
        if dict.keys.contains("ResultType") && dict["ResultType"] != nil {
            self.resultType = dict["ResultType"] as! String
        }
        if dict.keys.contains("ServiceConfig") && dict["ServiceConfig"] != nil {
            var model = DescribeDeployedApiResponseBody.ServiceConfig()
            model.fromMap(dict["ServiceConfig"] as! [String: Any])
            self.serviceConfig = model
        }
        if dict.keys.contains("ServiceParameters") && dict["ServiceParameters"] != nil {
            var model = DescribeDeployedApiResponseBody.ServiceParameters()
            model.fromMap(dict["ServiceParameters"] as! [String: Any])
            self.serviceParameters = model
        }
        if dict.keys.contains("ServiceParametersMap") && dict["ServiceParametersMap"] != nil {
            var model = DescribeDeployedApiResponseBody.ServiceParametersMap()
            model.fromMap(dict["ServiceParametersMap"] as! [String: Any])
            self.serviceParametersMap = model
        }
        if dict.keys.contains("StageName") && dict["StageName"] != nil {
            self.stageName = dict["StageName"] as! String
        }
        if dict.keys.contains("SystemParameters") && dict["SystemParameters"] != nil {
            var model = DescribeDeployedApiResponseBody.SystemParameters()
            model.fromMap(dict["SystemParameters"] as! [String: Any])
            self.systemParameters = model
        }
        if dict.keys.contains("Visibility") && dict["Visibility"] != nil {
            self.visibility = dict["Visibility"] as! String
        }
    }
}

public class DescribeDeployedApiResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDeployedApiResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeDeployedApiResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDeployedApisRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var apiId: String?

    public var apiMethod: String?

    public var apiName: String?

    public var apiPath: String?

    public var enableTagAuth: Bool?

    public var groupId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var securityToken: String?

    public var stageName: String?

    public var tag: [DescribeDeployedApisRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.apiMethod != nil {
            map["ApiMethod"] = self.apiMethod!
        }
        if self.apiName != nil {
            map["ApiName"] = self.apiName!
        }
        if self.apiPath != nil {
            map["ApiPath"] = self.apiPath!
        }
        if self.enableTagAuth != nil {
            map["EnableTagAuth"] = self.enableTagAuth!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.stageName != nil {
            map["StageName"] = self.stageName!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiId") && dict["ApiId"] != nil {
            self.apiId = dict["ApiId"] as! String
        }
        if dict.keys.contains("ApiMethod") && dict["ApiMethod"] != nil {
            self.apiMethod = dict["ApiMethod"] as! String
        }
        if dict.keys.contains("ApiName") && dict["ApiName"] != nil {
            self.apiName = dict["ApiName"] as! String
        }
        if dict.keys.contains("ApiPath") && dict["ApiPath"] != nil {
            self.apiPath = dict["ApiPath"] as! String
        }
        if dict.keys.contains("EnableTagAuth") && dict["EnableTagAuth"] != nil {
            self.enableTagAuth = dict["EnableTagAuth"] as! Bool
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StageName") && dict["StageName"] != nil {
            self.stageName = dict["StageName"] as! String
        }
        if dict.keys.contains("Tag") && dict["Tag"] != nil {
            var tmp : [DescribeDeployedApisRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = DescribeDeployedApisRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class DescribeDeployedApisResponseBody : Tea.TeaModel {
    public class DeployedApis : Tea.TeaModel {
        public class DeployedApiItem : Tea.TeaModel {
            public var apiId: String?

            public var apiMethod: String?

            public var apiName: String?

            public var apiPath: String?

            public var deployedTime: String?

            public var description_: String?

            public var groupId: String?

            public var groupName: String?

            public var regionId: String?

            public var stageName: String?

            public var visibility: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.apiId != nil {
                    map["ApiId"] = self.apiId!
                }
                if self.apiMethod != nil {
                    map["ApiMethod"] = self.apiMethod!
                }
                if self.apiName != nil {
                    map["ApiName"] = self.apiName!
                }
                if self.apiPath != nil {
                    map["ApiPath"] = self.apiPath!
                }
                if self.deployedTime != nil {
                    map["DeployedTime"] = self.deployedTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.stageName != nil {
                    map["StageName"] = self.stageName!
                }
                if self.visibility != nil {
                    map["Visibility"] = self.visibility!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ApiId") && dict["ApiId"] != nil {
                    self.apiId = dict["ApiId"] as! String
                }
                if dict.keys.contains("ApiMethod") && dict["ApiMethod"] != nil {
                    self.apiMethod = dict["ApiMethod"] as! String
                }
                if dict.keys.contains("ApiName") && dict["ApiName"] != nil {
                    self.apiName = dict["ApiName"] as! String
                }
                if dict.keys.contains("ApiPath") && dict["ApiPath"] != nil {
                    self.apiPath = dict["ApiPath"] as! String
                }
                if dict.keys.contains("DeployedTime") && dict["DeployedTime"] != nil {
                    self.deployedTime = dict["DeployedTime"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
                    self.groupName = dict["GroupName"] as! String
                }
                if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("StageName") && dict["StageName"] != nil {
                    self.stageName = dict["StageName"] as! String
                }
                if dict.keys.contains("Visibility") && dict["Visibility"] != nil {
                    self.visibility = dict["Visibility"] as! String
                }
            }
        }
        public var deployedApiItem: [DescribeDeployedApisResponseBody.DeployedApis.DeployedApiItem]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.deployedApiItem != nil {
                var tmp : [Any] = []
                for k in self.deployedApiItem! {
                    tmp.append(k.toMap())
                }
                map["DeployedApiItem"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DeployedApiItem") && dict["DeployedApiItem"] != nil {
                var tmp : [DescribeDeployedApisResponseBody.DeployedApis.DeployedApiItem] = []
                for v in dict["DeployedApiItem"] as! [Any] {
                    var model = DescribeDeployedApisResponseBody.DeployedApis.DeployedApiItem()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.deployedApiItem = tmp
            }
        }
    }
    public var deployedApis: DescribeDeployedApisResponseBody.DeployedApis?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.deployedApis?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deployedApis != nil {
            map["DeployedApis"] = self.deployedApis?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeployedApis") && dict["DeployedApis"] != nil {
            var model = DescribeDeployedApisResponseBody.DeployedApis()
            model.fromMap(dict["DeployedApis"] as! [String: Any])
            self.deployedApis = model
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeDeployedApisResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDeployedApisResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeDeployedApisResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDomainRequest : Tea.TeaModel {
    public var domainName: String?

    public var groupId: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") && dict["DomainName"] != nil {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DescribeDomainResponseBody : Tea.TeaModel {
    public var certificateBody: String?

    public var certificateId: String?

    public var certificateName: String?

    public var certificatePrivateKey: String?

    public var certificateValidEnd: Int64?

    public var certificateValidStart: Int64?

    public var domainBindingStatus: String?

    public var domainCNAMEStatus: String?

    public var domainLegalStatus: String?

    public var domainName: String?

    public var domainRemark: String?

    public var domainWebSocketStatus: String?

    public var groupId: String?

    public var requestId: String?

    public var subDomain: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.certificateBody != nil {
            map["CertificateBody"] = self.certificateBody!
        }
        if self.certificateId != nil {
            map["CertificateId"] = self.certificateId!
        }
        if self.certificateName != nil {
            map["CertificateName"] = self.certificateName!
        }
        if self.certificatePrivateKey != nil {
            map["CertificatePrivateKey"] = self.certificatePrivateKey!
        }
        if self.certificateValidEnd != nil {
            map["CertificateValidEnd"] = self.certificateValidEnd!
        }
        if self.certificateValidStart != nil {
            map["CertificateValidStart"] = self.certificateValidStart!
        }
        if self.domainBindingStatus != nil {
            map["DomainBindingStatus"] = self.domainBindingStatus!
        }
        if self.domainCNAMEStatus != nil {
            map["DomainCNAMEStatus"] = self.domainCNAMEStatus!
        }
        if self.domainLegalStatus != nil {
            map["DomainLegalStatus"] = self.domainLegalStatus!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.domainRemark != nil {
            map["DomainRemark"] = self.domainRemark!
        }
        if self.domainWebSocketStatus != nil {
            map["DomainWebSocketStatus"] = self.domainWebSocketStatus!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.subDomain != nil {
            map["SubDomain"] = self.subDomain!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CertificateBody") && dict["CertificateBody"] != nil {
            self.certificateBody = dict["CertificateBody"] as! String
        }
        if dict.keys.contains("CertificateId") && dict["CertificateId"] != nil {
            self.certificateId = dict["CertificateId"] as! String
        }
        if dict.keys.contains("CertificateName") && dict["CertificateName"] != nil {
            self.certificateName = dict["CertificateName"] as! String
        }
        if dict.keys.contains("CertificatePrivateKey") && dict["CertificatePrivateKey"] != nil {
            self.certificatePrivateKey = dict["CertificatePrivateKey"] as! String
        }
        if dict.keys.contains("CertificateValidEnd") && dict["CertificateValidEnd"] != nil {
            self.certificateValidEnd = dict["CertificateValidEnd"] as! Int64
        }
        if dict.keys.contains("CertificateValidStart") && dict["CertificateValidStart"] != nil {
            self.certificateValidStart = dict["CertificateValidStart"] as! Int64
        }
        if dict.keys.contains("DomainBindingStatus") && dict["DomainBindingStatus"] != nil {
            self.domainBindingStatus = dict["DomainBindingStatus"] as! String
        }
        if dict.keys.contains("DomainCNAMEStatus") && dict["DomainCNAMEStatus"] != nil {
            self.domainCNAMEStatus = dict["DomainCNAMEStatus"] as! String
        }
        if dict.keys.contains("DomainLegalStatus") && dict["DomainLegalStatus"] != nil {
            self.domainLegalStatus = dict["DomainLegalStatus"] as! String
        }
        if dict.keys.contains("DomainName") && dict["DomainName"] != nil {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("DomainRemark") && dict["DomainRemark"] != nil {
            self.domainRemark = dict["DomainRemark"] as! String
        }
        if dict.keys.contains("DomainWebSocketStatus") && dict["DomainWebSocketStatus"] != nil {
            self.domainWebSocketStatus = dict["DomainWebSocketStatus"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SubDomain") && dict["SubDomain"] != nil {
            self.subDomain = dict["SubDomain"] as! String
        }
    }
}

public class DescribeDomainResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDomainResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeDomainResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeGroupLatencyRequest : Tea.TeaModel {
    public var endTime: String?

    public var groupId: String?

    public var securityToken: String?

    public var stageName: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.stageName != nil {
            map["StageName"] = self.stageName!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StageName") && dict["StageName"] != nil {
            self.stageName = dict["StageName"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeGroupLatencyResponseBody : Tea.TeaModel {
    public class LatencyPacket : Tea.TeaModel {
        public class MonitorItem : Tea.TeaModel {
            public var item: String?

            public var itemTime: String?

            public var itemValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.item != nil {
                    map["Item"] = self.item!
                }
                if self.itemTime != nil {
                    map["ItemTime"] = self.itemTime!
                }
                if self.itemValue != nil {
                    map["ItemValue"] = self.itemValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Item") && dict["Item"] != nil {
                    self.item = dict["Item"] as! String
                }
                if dict.keys.contains("ItemTime") && dict["ItemTime"] != nil {
                    self.itemTime = dict["ItemTime"] as! String
                }
                if dict.keys.contains("ItemValue") && dict["ItemValue"] != nil {
                    self.itemValue = dict["ItemValue"] as! String
                }
            }
        }
        public var monitorItem: [DescribeGroupLatencyResponseBody.LatencyPacket.MonitorItem]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.monitorItem != nil {
                var tmp : [Any] = []
                for k in self.monitorItem! {
                    tmp.append(k.toMap())
                }
                map["MonitorItem"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MonitorItem") && dict["MonitorItem"] != nil {
                var tmp : [DescribeGroupLatencyResponseBody.LatencyPacket.MonitorItem] = []
                for v in dict["MonitorItem"] as! [Any] {
                    var model = DescribeGroupLatencyResponseBody.LatencyPacket.MonitorItem()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.monitorItem = tmp
            }
        }
    }
    public var latencyPacket: DescribeGroupLatencyResponseBody.LatencyPacket?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.latencyPacket?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.latencyPacket != nil {
            map["LatencyPacket"] = self.latencyPacket?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LatencyPacket") && dict["LatencyPacket"] != nil {
            var model = DescribeGroupLatencyResponseBody.LatencyPacket()
            model.fromMap(dict["LatencyPacket"] as! [String: Any])
            self.latencyPacket = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeGroupLatencyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeGroupLatencyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeGroupLatencyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeGroupQpsRequest : Tea.TeaModel {
    public var endTime: String?

    public var groupId: String?

    public var securityToken: String?

    public var stageName: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.stageName != nil {
            map["StageName"] = self.stageName!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StageName") && dict["StageName"] != nil {
            self.stageName = dict["StageName"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeGroupQpsResponseBody : Tea.TeaModel {
    public class GroupQps : Tea.TeaModel {
        public class MonitorItem : Tea.TeaModel {
            public var itemTime: String?

            public var itemValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.itemTime != nil {
                    map["ItemTime"] = self.itemTime!
                }
                if self.itemValue != nil {
                    map["ItemValue"] = self.itemValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ItemTime") && dict["ItemTime"] != nil {
                    self.itemTime = dict["ItemTime"] as! String
                }
                if dict.keys.contains("ItemValue") && dict["ItemValue"] != nil {
                    self.itemValue = dict["ItemValue"] as! String
                }
            }
        }
        public var monitorItem: [DescribeGroupQpsResponseBody.GroupQps.MonitorItem]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.monitorItem != nil {
                var tmp : [Any] = []
                for k in self.monitorItem! {
                    tmp.append(k.toMap())
                }
                map["MonitorItem"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MonitorItem") && dict["MonitorItem"] != nil {
                var tmp : [DescribeGroupQpsResponseBody.GroupQps.MonitorItem] = []
                for v in dict["MonitorItem"] as! [Any] {
                    var model = DescribeGroupQpsResponseBody.GroupQps.MonitorItem()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.monitorItem = tmp
            }
        }
    }
    public var groupQps: DescribeGroupQpsResponseBody.GroupQps?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.groupQps?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupQps != nil {
            map["GroupQps"] = self.groupQps?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupQps") && dict["GroupQps"] != nil {
            var model = DescribeGroupQpsResponseBody.GroupQps()
            model.fromMap(dict["GroupQps"] as! [String: Any])
            self.groupQps = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeGroupQpsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeGroupQpsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeGroupQpsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeGroupTrafficRequest : Tea.TeaModel {
    public var endTime: String?

    public var groupId: String?

    public var securityToken: String?

    public var stageName: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.stageName != nil {
            map["StageName"] = self.stageName!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StageName") && dict["StageName"] != nil {
            self.stageName = dict["StageName"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeGroupTrafficResponseBody : Tea.TeaModel {
    public class TrafficPerSecond : Tea.TeaModel {
        public class MonitorItem : Tea.TeaModel {
            public var item: String?

            public var itemTime: String?

            public var itemValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.item != nil {
                    map["Item"] = self.item!
                }
                if self.itemTime != nil {
                    map["ItemTime"] = self.itemTime!
                }
                if self.itemValue != nil {
                    map["ItemValue"] = self.itemValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Item") && dict["Item"] != nil {
                    self.item = dict["Item"] as! String
                }
                if dict.keys.contains("ItemTime") && dict["ItemTime"] != nil {
                    self.itemTime = dict["ItemTime"] as! String
                }
                if dict.keys.contains("ItemValue") && dict["ItemValue"] != nil {
                    self.itemValue = dict["ItemValue"] as! String
                }
            }
        }
        public var monitorItem: [DescribeGroupTrafficResponseBody.TrafficPerSecond.MonitorItem]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.monitorItem != nil {
                var tmp : [Any] = []
                for k in self.monitorItem! {
                    tmp.append(k.toMap())
                }
                map["MonitorItem"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MonitorItem") && dict["MonitorItem"] != nil {
                var tmp : [DescribeGroupTrafficResponseBody.TrafficPerSecond.MonitorItem] = []
                for v in dict["MonitorItem"] as! [Any] {
                    var model = DescribeGroupTrafficResponseBody.TrafficPerSecond.MonitorItem()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.monitorItem = tmp
            }
        }
    }
    public var requestId: String?

    public var trafficPerSecond: DescribeGroupTrafficResponseBody.TrafficPerSecond?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.trafficPerSecond?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.trafficPerSecond != nil {
            map["TrafficPerSecond"] = self.trafficPerSecond?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TrafficPerSecond") && dict["TrafficPerSecond"] != nil {
            var model = DescribeGroupTrafficResponseBody.TrafficPerSecond()
            model.fromMap(dict["TrafficPerSecond"] as! [String: Any])
            self.trafficPerSecond = model
        }
    }
}

public class DescribeGroupTrafficResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeGroupTrafficResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeGroupTrafficResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeHistoryApisRequest : Tea.TeaModel {
    public var apiId: String?

    public var apiName: String?

    public var groupId: String?

    public var pageNumber: String?

    public var pageSize: String?

    public var securityToken: String?

    public var stageName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.apiName != nil {
            map["ApiName"] = self.apiName!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.stageName != nil {
            map["StageName"] = self.stageName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiId") && dict["ApiId"] != nil {
            self.apiId = dict["ApiId"] as! String
        }
        if dict.keys.contains("ApiName") && dict["ApiName"] != nil {
            self.apiName = dict["ApiName"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StageName") && dict["StageName"] != nil {
            self.stageName = dict["StageName"] as! String
        }
    }
}

public class DescribeHistoryApisResponseBody : Tea.TeaModel {
    public class ApiHisItems : Tea.TeaModel {
        public class ApiHisItem : Tea.TeaModel {
            public var apiId: String?

            public var apiName: String?

            public var deployedTime: String?

            public var description_: String?

            public var groupId: String?

            public var groupName: String?

            public var historyVersion: String?

            public var regionId: String?

            public var stageAlias: String?

            public var stageName: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.apiId != nil {
                    map["ApiId"] = self.apiId!
                }
                if self.apiName != nil {
                    map["ApiName"] = self.apiName!
                }
                if self.deployedTime != nil {
                    map["DeployedTime"] = self.deployedTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.historyVersion != nil {
                    map["HistoryVersion"] = self.historyVersion!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.stageAlias != nil {
                    map["StageAlias"] = self.stageAlias!
                }
                if self.stageName != nil {
                    map["StageName"] = self.stageName!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ApiId") && dict["ApiId"] != nil {
                    self.apiId = dict["ApiId"] as! String
                }
                if dict.keys.contains("ApiName") && dict["ApiName"] != nil {
                    self.apiName = dict["ApiName"] as! String
                }
                if dict.keys.contains("DeployedTime") && dict["DeployedTime"] != nil {
                    self.deployedTime = dict["DeployedTime"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
                    self.groupName = dict["GroupName"] as! String
                }
                if dict.keys.contains("HistoryVersion") && dict["HistoryVersion"] != nil {
                    self.historyVersion = dict["HistoryVersion"] as! String
                }
                if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("StageAlias") && dict["StageAlias"] != nil {
                    self.stageAlias = dict["StageAlias"] as! String
                }
                if dict.keys.contains("StageName") && dict["StageName"] != nil {
                    self.stageName = dict["StageName"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var apiHisItem: [DescribeHistoryApisResponseBody.ApiHisItems.ApiHisItem]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apiHisItem != nil {
                var tmp : [Any] = []
                for k in self.apiHisItem! {
                    tmp.append(k.toMap())
                }
                map["ApiHisItem"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApiHisItem") && dict["ApiHisItem"] != nil {
                var tmp : [DescribeHistoryApisResponseBody.ApiHisItems.ApiHisItem] = []
                for v in dict["ApiHisItem"] as! [Any] {
                    var model = DescribeHistoryApisResponseBody.ApiHisItems.ApiHisItem()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.apiHisItem = tmp
            }
        }
    }
    public var apiHisItems: DescribeHistoryApisResponseBody.ApiHisItems?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.apiHisItems?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiHisItems != nil {
            map["ApiHisItems"] = self.apiHisItems?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiHisItems") && dict["ApiHisItems"] != nil {
            var model = DescribeHistoryApisResponseBody.ApiHisItems()
            model.fromMap(dict["ApiHisItems"] as! [String: Any])
            self.apiHisItems = model
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeHistoryApisResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeHistoryApisResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeHistoryApisResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeImportOASTaskRequest : Tea.TeaModel {
    public var operationId: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.operationId != nil {
            map["OperationId"] = self.operationId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OperationId") && dict["OperationId"] != nil {
            self.operationId = dict["OperationId"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DescribeImportOASTaskResponseBody : Tea.TeaModel {
    public class ApiResults : Tea.TeaModel {
        public class ApiResult : Tea.TeaModel {
            public var apiId: String?

            public var apiName: String?

            public var description_: String?

            public var errorMessage: String?

            public var groupId: String?

            public var method: String?

            public var path: String?

            public var updateStatus: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.apiId != nil {
                    map["ApiId"] = self.apiId!
                }
                if self.apiName != nil {
                    map["ApiName"] = self.apiName!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.errorMessage != nil {
                    map["ErrorMessage"] = self.errorMessage!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.method != nil {
                    map["Method"] = self.method!
                }
                if self.path != nil {
                    map["Path"] = self.path!
                }
                if self.updateStatus != nil {
                    map["UpdateStatus"] = self.updateStatus!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ApiId") && dict["ApiId"] != nil {
                    self.apiId = dict["ApiId"] as! String
                }
                if dict.keys.contains("ApiName") && dict["ApiName"] != nil {
                    self.apiName = dict["ApiName"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
                    self.errorMessage = dict["ErrorMessage"] as! String
                }
                if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("Method") && dict["Method"] != nil {
                    self.method = dict["Method"] as! String
                }
                if dict.keys.contains("Path") && dict["Path"] != nil {
                    self.path = dict["Path"] as! String
                }
                if dict.keys.contains("UpdateStatus") && dict["UpdateStatus"] != nil {
                    self.updateStatus = dict["UpdateStatus"] as! String
                }
            }
        }
        public var apiResult: [DescribeImportOASTaskResponseBody.ApiResults.ApiResult]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apiResult != nil {
                var tmp : [Any] = []
                for k in self.apiResult! {
                    tmp.append(k.toMap())
                }
                map["ApiResult"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApiResult") && dict["ApiResult"] != nil {
                var tmp : [DescribeImportOASTaskResponseBody.ApiResults.ApiResult] = []
                for v in dict["ApiResult"] as! [Any] {
                    var model = DescribeImportOASTaskResponseBody.ApiResults.ApiResult()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.apiResult = tmp
            }
        }
    }
    public class ModelResults : Tea.TeaModel {
        public class ModelResult : Tea.TeaModel {
            public var errorMessage: String?

            public var groupId: String?

            public var modelId: String?

            public var modelName: String?

            public var updateStatus: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.errorMessage != nil {
                    map["ErrorMessage"] = self.errorMessage!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.modelId != nil {
                    map["ModelId"] = self.modelId!
                }
                if self.modelName != nil {
                    map["ModelName"] = self.modelName!
                }
                if self.updateStatus != nil {
                    map["UpdateStatus"] = self.updateStatus!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
                    self.errorMessage = dict["ErrorMessage"] as! String
                }
                if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("ModelId") && dict["ModelId"] != nil {
                    self.modelId = dict["ModelId"] as! String
                }
                if dict.keys.contains("ModelName") && dict["ModelName"] != nil {
                    self.modelName = dict["ModelName"] as! String
                }
                if dict.keys.contains("UpdateStatus") && dict["UpdateStatus"] != nil {
                    self.updateStatus = dict["UpdateStatus"] as! String
                }
            }
        }
        public var modelResult: [DescribeImportOASTaskResponseBody.ModelResults.ModelResult]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.modelResult != nil {
                var tmp : [Any] = []
                for k in self.modelResult! {
                    tmp.append(k.toMap())
                }
                map["ModelResult"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ModelResult") && dict["ModelResult"] != nil {
                var tmp : [DescribeImportOASTaskResponseBody.ModelResults.ModelResult] = []
                for v in dict["ModelResult"] as! [Any] {
                    var model = DescribeImportOASTaskResponseBody.ModelResults.ModelResult()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.modelResult = tmp
            }
        }
    }
    public var apiResults: DescribeImportOASTaskResponseBody.ApiResults?

    public var modelResults: DescribeImportOASTaskResponseBody.ModelResults?

    public var requestId: String?

    public var taskStatus: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.apiResults?.validate()
        try self.modelResults?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiResults != nil {
            map["ApiResults"] = self.apiResults?.toMap()
        }
        if self.modelResults != nil {
            map["ModelResults"] = self.modelResults?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.taskStatus != nil {
            map["TaskStatus"] = self.taskStatus!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiResults") && dict["ApiResults"] != nil {
            var model = DescribeImportOASTaskResponseBody.ApiResults()
            model.fromMap(dict["ApiResults"] as! [String: Any])
            self.apiResults = model
        }
        if dict.keys.contains("ModelResults") && dict["ModelResults"] != nil {
            var model = DescribeImportOASTaskResponseBody.ModelResults()
            model.fromMap(dict["ModelResults"] as! [String: Any])
            self.modelResults = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TaskStatus") && dict["TaskStatus"] != nil {
            self.taskStatus = dict["TaskStatus"] as! String
        }
    }
}

public class DescribeImportOASTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeImportOASTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeImportOASTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeInstanceDropConnectionsRequest : Tea.TeaModel {
    public var endTime: String?

    public var instanceId: String?

    public var sbcName: String?

    public var securityToken: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.sbcName != nil {
            map["SbcName"] = self.sbcName!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("SbcName") && dict["SbcName"] != nil {
            self.sbcName = dict["SbcName"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeInstanceDropConnectionsResponseBody : Tea.TeaModel {
    public class InstanceDropConnections : Tea.TeaModel {
        public class MonitorItem : Tea.TeaModel {
            public var itemTime: String?

            public var itemValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.itemTime != nil {
                    map["ItemTime"] = self.itemTime!
                }
                if self.itemValue != nil {
                    map["ItemValue"] = self.itemValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ItemTime") && dict["ItemTime"] != nil {
                    self.itemTime = dict["ItemTime"] as! String
                }
                if dict.keys.contains("ItemValue") && dict["ItemValue"] != nil {
                    self.itemValue = dict["ItemValue"] as! String
                }
            }
        }
        public var monitorItem: [DescribeInstanceDropConnectionsResponseBody.InstanceDropConnections.MonitorItem]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.monitorItem != nil {
                var tmp : [Any] = []
                for k in self.monitorItem! {
                    tmp.append(k.toMap())
                }
                map["MonitorItem"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MonitorItem") && dict["MonitorItem"] != nil {
                var tmp : [DescribeInstanceDropConnectionsResponseBody.InstanceDropConnections.MonitorItem] = []
                for v in dict["MonitorItem"] as! [Any] {
                    var model = DescribeInstanceDropConnectionsResponseBody.InstanceDropConnections.MonitorItem()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.monitorItem = tmp
            }
        }
    }
    public var instanceDropConnections: DescribeInstanceDropConnectionsResponseBody.InstanceDropConnections?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instanceDropConnections?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceDropConnections != nil {
            map["InstanceDropConnections"] = self.instanceDropConnections?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceDropConnections") && dict["InstanceDropConnections"] != nil {
            var model = DescribeInstanceDropConnectionsResponseBody.InstanceDropConnections()
            model.fromMap(dict["InstanceDropConnections"] as! [String: Any])
            self.instanceDropConnections = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeInstanceDropConnectionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstanceDropConnectionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeInstanceDropConnectionsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeInstanceDropPacketRequest : Tea.TeaModel {
    public var endTime: String?

    public var instanceId: String?

    public var sbcName: String?

    public var securityToken: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.sbcName != nil {
            map["SbcName"] = self.sbcName!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("SbcName") && dict["SbcName"] != nil {
            self.sbcName = dict["SbcName"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeInstanceDropPacketResponseBody : Tea.TeaModel {
    public class InstanceDropPacket : Tea.TeaModel {
        public class MonitorItem : Tea.TeaModel {
            public var item: String?

            public var itemTime: String?

            public var itemValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.item != nil {
                    map["Item"] = self.item!
                }
                if self.itemTime != nil {
                    map["ItemTime"] = self.itemTime!
                }
                if self.itemValue != nil {
                    map["ItemValue"] = self.itemValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Item") && dict["Item"] != nil {
                    self.item = dict["Item"] as! String
                }
                if dict.keys.contains("ItemTime") && dict["ItemTime"] != nil {
                    self.itemTime = dict["ItemTime"] as! String
                }
                if dict.keys.contains("ItemValue") && dict["ItemValue"] != nil {
                    self.itemValue = dict["ItemValue"] as! String
                }
            }
        }
        public var monitorItem: [DescribeInstanceDropPacketResponseBody.InstanceDropPacket.MonitorItem]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.monitorItem != nil {
                var tmp : [Any] = []
                for k in self.monitorItem! {
                    tmp.append(k.toMap())
                }
                map["MonitorItem"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MonitorItem") && dict["MonitorItem"] != nil {
                var tmp : [DescribeInstanceDropPacketResponseBody.InstanceDropPacket.MonitorItem] = []
                for v in dict["MonitorItem"] as! [Any] {
                    var model = DescribeInstanceDropPacketResponseBody.InstanceDropPacket.MonitorItem()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.monitorItem = tmp
            }
        }
    }
    public var instanceDropPacket: DescribeInstanceDropPacketResponseBody.InstanceDropPacket?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instanceDropPacket?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceDropPacket != nil {
            map["InstanceDropPacket"] = self.instanceDropPacket?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceDropPacket") && dict["InstanceDropPacket"] != nil {
            var model = DescribeInstanceDropPacketResponseBody.InstanceDropPacket()
            model.fromMap(dict["InstanceDropPacket"] as! [String: Any])
            self.instanceDropPacket = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeInstanceDropPacketResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstanceDropPacketResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeInstanceDropPacketResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeInstanceHttpCodeRequest : Tea.TeaModel {
    public var endTime: String?

    public var instanceId: String?

    public var securityToken: String?

    public var stageName: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.stageName != nil {
            map["StageName"] = self.stageName!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StageName") && dict["StageName"] != nil {
            self.stageName = dict["StageName"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeInstanceHttpCodeResponseBody : Tea.TeaModel {
    public class InstanceHttpCode : Tea.TeaModel {
        public class MonitorItem : Tea.TeaModel {
            public var itemTime: String?

            public var itemValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.itemTime != nil {
                    map["ItemTime"] = self.itemTime!
                }
                if self.itemValue != nil {
                    map["ItemValue"] = self.itemValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ItemTime") && dict["ItemTime"] != nil {
                    self.itemTime = dict["ItemTime"] as! String
                }
                if dict.keys.contains("ItemValue") && dict["ItemValue"] != nil {
                    self.itemValue = dict["ItemValue"] as! String
                }
            }
        }
        public var monitorItem: [DescribeInstanceHttpCodeResponseBody.InstanceHttpCode.MonitorItem]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.monitorItem != nil {
                var tmp : [Any] = []
                for k in self.monitorItem! {
                    tmp.append(k.toMap())
                }
                map["MonitorItem"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MonitorItem") && dict["MonitorItem"] != nil {
                var tmp : [DescribeInstanceHttpCodeResponseBody.InstanceHttpCode.MonitorItem] = []
                for v in dict["MonitorItem"] as! [Any] {
                    var model = DescribeInstanceHttpCodeResponseBody.InstanceHttpCode.MonitorItem()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.monitorItem = tmp
            }
        }
    }
    public var instanceHttpCode: DescribeInstanceHttpCodeResponseBody.InstanceHttpCode?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instanceHttpCode?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceHttpCode != nil {
            map["InstanceHttpCode"] = self.instanceHttpCode?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceHttpCode") && dict["InstanceHttpCode"] != nil {
            var model = DescribeInstanceHttpCodeResponseBody.InstanceHttpCode()
            model.fromMap(dict["InstanceHttpCode"] as! [String: Any])
            self.instanceHttpCode = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeInstanceHttpCodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstanceHttpCodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeInstanceHttpCodeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeInstanceLatencyRequest : Tea.TeaModel {
    public var endTime: String?

    public var instanceId: String?

    public var securityToken: String?

    public var stageName: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.stageName != nil {
            map["StageName"] = self.stageName!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StageName") && dict["StageName"] != nil {
            self.stageName = dict["StageName"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeInstanceLatencyResponseBody : Tea.TeaModel {
    public class InstanceLatency : Tea.TeaModel {
        public class MonitorItem : Tea.TeaModel {
            public var item: String?

            public var itemTime: String?

            public var itemValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.item != nil {
                    map["Item"] = self.item!
                }
                if self.itemTime != nil {
                    map["ItemTime"] = self.itemTime!
                }
                if self.itemValue != nil {
                    map["ItemValue"] = self.itemValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Item") && dict["Item"] != nil {
                    self.item = dict["Item"] as! String
                }
                if dict.keys.contains("ItemTime") && dict["ItemTime"] != nil {
                    self.itemTime = dict["ItemTime"] as! String
                }
                if dict.keys.contains("ItemValue") && dict["ItemValue"] != nil {
                    self.itemValue = dict["ItemValue"] as! String
                }
            }
        }
        public var monitorItem: [DescribeInstanceLatencyResponseBody.InstanceLatency.MonitorItem]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.monitorItem != nil {
                var tmp : [Any] = []
                for k in self.monitorItem! {
                    tmp.append(k.toMap())
                }
                map["MonitorItem"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MonitorItem") && dict["MonitorItem"] != nil {
                var tmp : [DescribeInstanceLatencyResponseBody.InstanceLatency.MonitorItem] = []
                for v in dict["MonitorItem"] as! [Any] {
                    var model = DescribeInstanceLatencyResponseBody.InstanceLatency.MonitorItem()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.monitorItem = tmp
            }
        }
    }
    public var instanceLatency: DescribeInstanceLatencyResponseBody.InstanceLatency?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instanceLatency?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceLatency != nil {
            map["InstanceLatency"] = self.instanceLatency?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceLatency") && dict["InstanceLatency"] != nil {
            var model = DescribeInstanceLatencyResponseBody.InstanceLatency()
            model.fromMap(dict["InstanceLatency"] as! [String: Any])
            self.instanceLatency = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeInstanceLatencyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstanceLatencyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeInstanceLatencyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeInstanceNewConnectionsRequest : Tea.TeaModel {
    public var endTime: String?

    public var instanceId: String?

    public var sbcName: String?

    public var securityToken: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.sbcName != nil {
            map["SbcName"] = self.sbcName!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("SbcName") && dict["SbcName"] != nil {
            self.sbcName = dict["SbcName"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeInstanceNewConnectionsResponseBody : Tea.TeaModel {
    public class InstanceNewConnections : Tea.TeaModel {
        public class MonitorItem : Tea.TeaModel {
            public var itemTime: String?

            public var itemValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.itemTime != nil {
                    map["ItemTime"] = self.itemTime!
                }
                if self.itemValue != nil {
                    map["ItemValue"] = self.itemValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ItemTime") && dict["ItemTime"] != nil {
                    self.itemTime = dict["ItemTime"] as! String
                }
                if dict.keys.contains("ItemValue") && dict["ItemValue"] != nil {
                    self.itemValue = dict["ItemValue"] as! String
                }
            }
        }
        public var monitorItem: [DescribeInstanceNewConnectionsResponseBody.InstanceNewConnections.MonitorItem]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.monitorItem != nil {
                var tmp : [Any] = []
                for k in self.monitorItem! {
                    tmp.append(k.toMap())
                }
                map["MonitorItem"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MonitorItem") && dict["MonitorItem"] != nil {
                var tmp : [DescribeInstanceNewConnectionsResponseBody.InstanceNewConnections.MonitorItem] = []
                for v in dict["MonitorItem"] as! [Any] {
                    var model = DescribeInstanceNewConnectionsResponseBody.InstanceNewConnections.MonitorItem()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.monitorItem = tmp
            }
        }
    }
    public var instanceNewConnections: DescribeInstanceNewConnectionsResponseBody.InstanceNewConnections?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instanceNewConnections?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceNewConnections != nil {
            map["InstanceNewConnections"] = self.instanceNewConnections?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceNewConnections") && dict["InstanceNewConnections"] != nil {
            var model = DescribeInstanceNewConnectionsResponseBody.InstanceNewConnections()
            model.fromMap(dict["InstanceNewConnections"] as! [String: Any])
            self.instanceNewConnections = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeInstanceNewConnectionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstanceNewConnectionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeInstanceNewConnectionsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeInstancePacketsRequest : Tea.TeaModel {
    public var endTime: String?

    public var instanceId: String?

    public var sbcName: String?

    public var securityToken: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.sbcName != nil {
            map["SbcName"] = self.sbcName!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("SbcName") && dict["SbcName"] != nil {
            self.sbcName = dict["SbcName"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeInstancePacketsResponseBody : Tea.TeaModel {
    public class InstancePackets : Tea.TeaModel {
        public class MonitorItem : Tea.TeaModel {
            public var item: String?

            public var itemTime: String?

            public var itemValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.item != nil {
                    map["Item"] = self.item!
                }
                if self.itemTime != nil {
                    map["ItemTime"] = self.itemTime!
                }
                if self.itemValue != nil {
                    map["ItemValue"] = self.itemValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Item") && dict["Item"] != nil {
                    self.item = dict["Item"] as! String
                }
                if dict.keys.contains("ItemTime") && dict["ItemTime"] != nil {
                    self.itemTime = dict["ItemTime"] as! String
                }
                if dict.keys.contains("ItemValue") && dict["ItemValue"] != nil {
                    self.itemValue = dict["ItemValue"] as! String
                }
            }
        }
        public var monitorItem: [DescribeInstancePacketsResponseBody.InstancePackets.MonitorItem]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.monitorItem != nil {
                var tmp : [Any] = []
                for k in self.monitorItem! {
                    tmp.append(k.toMap())
                }
                map["MonitorItem"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MonitorItem") && dict["MonitorItem"] != nil {
                var tmp : [DescribeInstancePacketsResponseBody.InstancePackets.MonitorItem] = []
                for v in dict["MonitorItem"] as! [Any] {
                    var model = DescribeInstancePacketsResponseBody.InstancePackets.MonitorItem()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.monitorItem = tmp
            }
        }
    }
    public var instancePackets: DescribeInstancePacketsResponseBody.InstancePackets?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instancePackets?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instancePackets != nil {
            map["InstancePackets"] = self.instancePackets?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstancePackets") && dict["InstancePackets"] != nil {
            var model = DescribeInstancePacketsResponseBody.InstancePackets()
            model.fromMap(dict["InstancePackets"] as! [String: Any])
            self.instancePackets = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeInstancePacketsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstancePacketsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeInstancePacketsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeInstanceQpsRequest : Tea.TeaModel {
    public var endTime: String?

    public var instanceId: String?

    public var securityToken: String?

    public var stageName: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.stageName != nil {
            map["StageName"] = self.stageName!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StageName") && dict["StageName"] != nil {
            self.stageName = dict["StageName"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeInstanceQpsResponseBody : Tea.TeaModel {
    public class InstanceQps : Tea.TeaModel {
        public class MonitorItem : Tea.TeaModel {
            public var itemTime: String?

            public var itemValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.itemTime != nil {
                    map["ItemTime"] = self.itemTime!
                }
                if self.itemValue != nil {
                    map["ItemValue"] = self.itemValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ItemTime") && dict["ItemTime"] != nil {
                    self.itemTime = dict["ItemTime"] as! String
                }
                if dict.keys.contains("ItemValue") && dict["ItemValue"] != nil {
                    self.itemValue = dict["ItemValue"] as! String
                }
            }
        }
        public var monitorItem: [DescribeInstanceQpsResponseBody.InstanceQps.MonitorItem]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.monitorItem != nil {
                var tmp : [Any] = []
                for k in self.monitorItem! {
                    tmp.append(k.toMap())
                }
                map["MonitorItem"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MonitorItem") && dict["MonitorItem"] != nil {
                var tmp : [DescribeInstanceQpsResponseBody.InstanceQps.MonitorItem] = []
                for v in dict["MonitorItem"] as! [Any] {
                    var model = DescribeInstanceQpsResponseBody.InstanceQps.MonitorItem()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.monitorItem = tmp
            }
        }
    }
    public var instanceQps: DescribeInstanceQpsResponseBody.InstanceQps?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instanceQps?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceQps != nil {
            map["InstanceQps"] = self.instanceQps?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceQps") && dict["InstanceQps"] != nil {
            var model = DescribeInstanceQpsResponseBody.InstanceQps()
            model.fromMap(dict["InstanceQps"] as! [String: Any])
            self.instanceQps = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeInstanceQpsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstanceQpsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeInstanceQpsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeInstanceSlbConnectRequest : Tea.TeaModel {
    public var endTime: String?

    public var instanceId: String?

    public var sbcName: String?

    public var securityToken: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.sbcName != nil {
            map["SbcName"] = self.sbcName!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("SbcName") && dict["SbcName"] != nil {
            self.sbcName = dict["SbcName"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeInstanceSlbConnectResponseBody : Tea.TeaModel {
    public class InstanceSlbConnect : Tea.TeaModel {
        public class MonitorItem : Tea.TeaModel {
            public var item: String?

            public var itemTime: String?

            public var itemValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.item != nil {
                    map["Item"] = self.item!
                }
                if self.itemTime != nil {
                    map["ItemTime"] = self.itemTime!
                }
                if self.itemValue != nil {
                    map["ItemValue"] = self.itemValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Item") && dict["Item"] != nil {
                    self.item = dict["Item"] as! String
                }
                if dict.keys.contains("ItemTime") && dict["ItemTime"] != nil {
                    self.itemTime = dict["ItemTime"] as! String
                }
                if dict.keys.contains("ItemValue") && dict["ItemValue"] != nil {
                    self.itemValue = dict["ItemValue"] as! String
                }
            }
        }
        public var monitorItem: [DescribeInstanceSlbConnectResponseBody.InstanceSlbConnect.MonitorItem]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.monitorItem != nil {
                var tmp : [Any] = []
                for k in self.monitorItem! {
                    tmp.append(k.toMap())
                }
                map["MonitorItem"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MonitorItem") && dict["MonitorItem"] != nil {
                var tmp : [DescribeInstanceSlbConnectResponseBody.InstanceSlbConnect.MonitorItem] = []
                for v in dict["MonitorItem"] as! [Any] {
                    var model = DescribeInstanceSlbConnectResponseBody.InstanceSlbConnect.MonitorItem()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.monitorItem = tmp
            }
        }
    }
    public var instanceSlbConnect: DescribeInstanceSlbConnectResponseBody.InstanceSlbConnect?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instanceSlbConnect?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceSlbConnect != nil {
            map["InstanceSlbConnect"] = self.instanceSlbConnect?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceSlbConnect") && dict["InstanceSlbConnect"] != nil {
            var model = DescribeInstanceSlbConnectResponseBody.InstanceSlbConnect()
            model.fromMap(dict["InstanceSlbConnect"] as! [String: Any])
            self.instanceSlbConnect = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeInstanceSlbConnectResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstanceSlbConnectResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeInstanceSlbConnectResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeInstanceTrafficRequest : Tea.TeaModel {
    public var endTime: String?

    public var instanceId: String?

    public var securityToken: String?

    public var stageName: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.stageName != nil {
            map["StageName"] = self.stageName!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StageName") && dict["StageName"] != nil {
            self.stageName = dict["StageName"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeInstanceTrafficResponseBody : Tea.TeaModel {
    public class InstanceTraffic : Tea.TeaModel {
        public class MonitorItem : Tea.TeaModel {
            public var item: String?

            public var itemTime: String?

            public var itemValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.item != nil {
                    map["Item"] = self.item!
                }
                if self.itemTime != nil {
                    map["ItemTime"] = self.itemTime!
                }
                if self.itemValue != nil {
                    map["ItemValue"] = self.itemValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Item") && dict["Item"] != nil {
                    self.item = dict["Item"] as! String
                }
                if dict.keys.contains("ItemTime") && dict["ItemTime"] != nil {
                    self.itemTime = dict["ItemTime"] as! String
                }
                if dict.keys.contains("ItemValue") && dict["ItemValue"] != nil {
                    self.itemValue = dict["ItemValue"] as! String
                }
            }
        }
        public var monitorItem: [DescribeInstanceTrafficResponseBody.InstanceTraffic.MonitorItem]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.monitorItem != nil {
                var tmp : [Any] = []
                for k in self.monitorItem! {
                    tmp.append(k.toMap())
                }
                map["MonitorItem"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MonitorItem") && dict["MonitorItem"] != nil {
                var tmp : [DescribeInstanceTrafficResponseBody.InstanceTraffic.MonitorItem] = []
                for v in dict["MonitorItem"] as! [Any] {
                    var model = DescribeInstanceTrafficResponseBody.InstanceTraffic.MonitorItem()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.monitorItem = tmp
            }
        }
    }
    public var instanceTraffic: DescribeInstanceTrafficResponseBody.InstanceTraffic?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instanceTraffic?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceTraffic != nil {
            map["InstanceTraffic"] = self.instanceTraffic?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceTraffic") && dict["InstanceTraffic"] != nil {
            var model = DescribeInstanceTrafficResponseBody.InstanceTraffic()
            model.fromMap(dict["InstanceTraffic"] as! [String: Any])
            self.instanceTraffic = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeInstanceTrafficResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstanceTrafficResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeInstanceTrafficResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeInstancesRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var enableTagAuthorization: Bool?

    public var instanceId: String?

    public var language: String?

    public var securityToken: String?

    public var tag: [DescribeInstancesRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.enableTagAuthorization != nil {
            map["EnableTagAuthorization"] = self.enableTagAuthorization!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnableTagAuthorization") && dict["EnableTagAuthorization"] != nil {
            self.enableTagAuthorization = dict["EnableTagAuthorization"] as! Bool
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Language") && dict["Language"] != nil {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("Tag") && dict["Tag"] != nil {
            var tmp : [DescribeInstancesRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = DescribeInstancesRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class DescribeInstancesResponseBody : Tea.TeaModel {
    public class Instances : Tea.TeaModel {
        public class InstanceAttribute : Tea.TeaModel {
            public class InstanceSpecAttributes : Tea.TeaModel {
                public class SpecAttribute : Tea.TeaModel {
                    public var localName: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.localName != nil {
                            map["LocalName"] = self.localName!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("LocalName") && dict["LocalName"] != nil {
                            self.localName = dict["LocalName"] as! String
                        }
                        if dict.keys.contains("Value") && dict["Value"] != nil {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var specAttribute: [DescribeInstancesResponseBody.Instances.InstanceAttribute.InstanceSpecAttributes.SpecAttribute]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.specAttribute != nil {
                        var tmp : [Any] = []
                        for k in self.specAttribute! {
                            tmp.append(k.toMap())
                        }
                        map["SpecAttribute"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("SpecAttribute") && dict["SpecAttribute"] != nil {
                        var tmp : [DescribeInstancesResponseBody.Instances.InstanceAttribute.InstanceSpecAttributes.SpecAttribute] = []
                        for v in dict["SpecAttribute"] as! [Any] {
                            var model = DescribeInstancesResponseBody.Instances.InstanceAttribute.InstanceSpecAttributes.SpecAttribute()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.specAttribute = tmp
                    }
                }
            }
            public class NetworkInterfaceAttributes : Tea.TeaModel {
                public class NetworkInterfaceAttribute : Tea.TeaModel {
                    public var cidrBlock: String?

                    public var securityGroupId: String?

                    public var vswitchId: String?

                    public var zoneId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.cidrBlock != nil {
                            map["CidrBlock"] = self.cidrBlock!
                        }
                        if self.securityGroupId != nil {
                            map["SecurityGroupId"] = self.securityGroupId!
                        }
                        if self.vswitchId != nil {
                            map["VswitchId"] = self.vswitchId!
                        }
                        if self.zoneId != nil {
                            map["ZoneId"] = self.zoneId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("CidrBlock") && dict["CidrBlock"] != nil {
                            self.cidrBlock = dict["CidrBlock"] as! String
                        }
                        if dict.keys.contains("SecurityGroupId") && dict["SecurityGroupId"] != nil {
                            self.securityGroupId = dict["SecurityGroupId"] as! String
                        }
                        if dict.keys.contains("VswitchId") && dict["VswitchId"] != nil {
                            self.vswitchId = dict["VswitchId"] as! String
                        }
                        if dict.keys.contains("ZoneId") && dict["ZoneId"] != nil {
                            self.zoneId = dict["ZoneId"] as! String
                        }
                    }
                }
                public var networkInterfaceAttribute: [DescribeInstancesResponseBody.Instances.InstanceAttribute.NetworkInterfaceAttributes.NetworkInterfaceAttribute]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.networkInterfaceAttribute != nil {
                        var tmp : [Any] = []
                        for k in self.networkInterfaceAttribute! {
                            tmp.append(k.toMap())
                        }
                        map["NetworkInterfaceAttribute"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("NetworkInterfaceAttribute") && dict["NetworkInterfaceAttribute"] != nil {
                        var tmp : [DescribeInstancesResponseBody.Instances.InstanceAttribute.NetworkInterfaceAttributes.NetworkInterfaceAttribute] = []
                        for v in dict["NetworkInterfaceAttribute"] as! [Any] {
                            var model = DescribeInstancesResponseBody.Instances.InstanceAttribute.NetworkInterfaceAttributes.NetworkInterfaceAttribute()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.networkInterfaceAttribute = tmp
                    }
                }
            }
            public class PrivateDnsList : Tea.TeaModel {
                public var privateDns: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.privateDns != nil {
                        map["PrivateDns"] = self.privateDns!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("PrivateDns") && dict["PrivateDns"] != nil {
                        self.privateDns = dict["PrivateDns"] as! [String]
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public class TagInfo : Tea.TeaModel {
                    public var key: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Key") && dict["Key"] != nil {
                            self.key = dict["Key"] as! String
                        }
                        if dict.keys.contains("Value") && dict["Value"] != nil {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var tagInfo: [DescribeInstancesResponseBody.Instances.InstanceAttribute.Tags.TagInfo]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tagInfo != nil {
                        var tmp : [Any] = []
                        for k in self.tagInfo! {
                            tmp.append(k.toMap())
                        }
                        map["TagInfo"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("TagInfo") && dict["TagInfo"] != nil {
                        var tmp : [DescribeInstancesResponseBody.Instances.InstanceAttribute.Tags.TagInfo] = []
                        for v in dict["TagInfo"] as! [Any] {
                            var model = DescribeInstancesResponseBody.Instances.InstanceAttribute.Tags.TagInfo()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.tagInfo = tmp
                    }
                }
            }
            public var aclId: String?

            public var aclName: String?

            public var aclStatus: String?

            public var aclType: String?

            public var classicEgressAddress: String?

            public var connectCidrBlocks: String?

            public var connectVpcId: String?

            public var createdTime: String?

            public var dedicatedInstanceType: String?

            public var egressIpv6Enable: Bool?

            public var expiredTime: String?

            public var httpsPolicies: String?

            public var IPV6AclId: String?

            public var IPV6AclName: String?

            public var IPV6AclStatus: String?

            public var IPV6AclType: String?

            public var instanceChargeType: String?

            public var instanceCidrBlock: String?

            public var instanceClusterId: String?

            public var instanceId: String?

            public var instanceName: String?

            public var instanceRpsLimit: Int32?

            public var instanceSpec: String?

            public var instanceSpecAttributes: DescribeInstancesResponseBody.Instances.InstanceAttribute.InstanceSpecAttributes?

            public var instanceType: String?

            public var internetEgressAddress: String?

            public var intranetSegments: String?

            public var maintainEndTime: String?

            public var maintainStartTime: String?

            public var networkInterfaceAttributes: DescribeInstancesResponseBody.Instances.InstanceAttribute.NetworkInterfaceAttributes?

            public var privateDnsList: DescribeInstancesResponseBody.Instances.InstanceAttribute.PrivateDnsList?

            public var regionId: String?

            public var status: String?

            public var supportIpv6: Bool?

            public var tags: DescribeInstancesResponseBody.Instances.InstanceAttribute.Tags?

            public var userVpcId: String?

            public var userVswitchId: String?

            public var vpcEgressAddress: String?

            public var vpcIntranetEnable: Bool?

            public var vpcOwnerId: Int64?

            public var vpcSlbIntranetEnable: Bool?

            public var zoneId: String?

            public var zoneLocalName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.instanceSpecAttributes?.validate()
                try self.networkInterfaceAttributes?.validate()
                try self.privateDnsList?.validate()
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.aclId != nil {
                    map["AclId"] = self.aclId!
                }
                if self.aclName != nil {
                    map["AclName"] = self.aclName!
                }
                if self.aclStatus != nil {
                    map["AclStatus"] = self.aclStatus!
                }
                if self.aclType != nil {
                    map["AclType"] = self.aclType!
                }
                if self.classicEgressAddress != nil {
                    map["ClassicEgressAddress"] = self.classicEgressAddress!
                }
                if self.connectCidrBlocks != nil {
                    map["ConnectCidrBlocks"] = self.connectCidrBlocks!
                }
                if self.connectVpcId != nil {
                    map["ConnectVpcId"] = self.connectVpcId!
                }
                if self.createdTime != nil {
                    map["CreatedTime"] = self.createdTime!
                }
                if self.dedicatedInstanceType != nil {
                    map["DedicatedInstanceType"] = self.dedicatedInstanceType!
                }
                if self.egressIpv6Enable != nil {
                    map["EgressIpv6Enable"] = self.egressIpv6Enable!
                }
                if self.expiredTime != nil {
                    map["ExpiredTime"] = self.expiredTime!
                }
                if self.httpsPolicies != nil {
                    map["HttpsPolicies"] = self.httpsPolicies!
                }
                if self.IPV6AclId != nil {
                    map["IPV6AclId"] = self.IPV6AclId!
                }
                if self.IPV6AclName != nil {
                    map["IPV6AclName"] = self.IPV6AclName!
                }
                if self.IPV6AclStatus != nil {
                    map["IPV6AclStatus"] = self.IPV6AclStatus!
                }
                if self.IPV6AclType != nil {
                    map["IPV6AclType"] = self.IPV6AclType!
                }
                if self.instanceChargeType != nil {
                    map["InstanceChargeType"] = self.instanceChargeType!
                }
                if self.instanceCidrBlock != nil {
                    map["InstanceCidrBlock"] = self.instanceCidrBlock!
                }
                if self.instanceClusterId != nil {
                    map["InstanceClusterId"] = self.instanceClusterId!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.instanceName != nil {
                    map["InstanceName"] = self.instanceName!
                }
                if self.instanceRpsLimit != nil {
                    map["InstanceRpsLimit"] = self.instanceRpsLimit!
                }
                if self.instanceSpec != nil {
                    map["InstanceSpec"] = self.instanceSpec!
                }
                if self.instanceSpecAttributes != nil {
                    map["InstanceSpecAttributes"] = self.instanceSpecAttributes?.toMap()
                }
                if self.instanceType != nil {
                    map["InstanceType"] = self.instanceType!
                }
                if self.internetEgressAddress != nil {
                    map["InternetEgressAddress"] = self.internetEgressAddress!
                }
                if self.intranetSegments != nil {
                    map["IntranetSegments"] = self.intranetSegments!
                }
                if self.maintainEndTime != nil {
                    map["MaintainEndTime"] = self.maintainEndTime!
                }
                if self.maintainStartTime != nil {
                    map["MaintainStartTime"] = self.maintainStartTime!
                }
                if self.networkInterfaceAttributes != nil {
                    map["NetworkInterfaceAttributes"] = self.networkInterfaceAttributes?.toMap()
                }
                if self.privateDnsList != nil {
                    map["PrivateDnsList"] = self.privateDnsList?.toMap()
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.supportIpv6 != nil {
                    map["SupportIpv6"] = self.supportIpv6!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                if self.userVpcId != nil {
                    map["UserVpcId"] = self.userVpcId!
                }
                if self.userVswitchId != nil {
                    map["UserVswitchId"] = self.userVswitchId!
                }
                if self.vpcEgressAddress != nil {
                    map["VpcEgressAddress"] = self.vpcEgressAddress!
                }
                if self.vpcIntranetEnable != nil {
                    map["VpcIntranetEnable"] = self.vpcIntranetEnable!
                }
                if self.vpcOwnerId != nil {
                    map["VpcOwnerId"] = self.vpcOwnerId!
                }
                if self.vpcSlbIntranetEnable != nil {
                    map["VpcSlbIntranetEnable"] = self.vpcSlbIntranetEnable!
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                if self.zoneLocalName != nil {
                    map["ZoneLocalName"] = self.zoneLocalName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AclId") && dict["AclId"] != nil {
                    self.aclId = dict["AclId"] as! String
                }
                if dict.keys.contains("AclName") && dict["AclName"] != nil {
                    self.aclName = dict["AclName"] as! String
                }
                if dict.keys.contains("AclStatus") && dict["AclStatus"] != nil {
                    self.aclStatus = dict["AclStatus"] as! String
                }
                if dict.keys.contains("AclType") && dict["AclType"] != nil {
                    self.aclType = dict["AclType"] as! String
                }
                if dict.keys.contains("ClassicEgressAddress") && dict["ClassicEgressAddress"] != nil {
                    self.classicEgressAddress = dict["ClassicEgressAddress"] as! String
                }
                if dict.keys.contains("ConnectCidrBlocks") && dict["ConnectCidrBlocks"] != nil {
                    self.connectCidrBlocks = dict["ConnectCidrBlocks"] as! String
                }
                if dict.keys.contains("ConnectVpcId") && dict["ConnectVpcId"] != nil {
                    self.connectVpcId = dict["ConnectVpcId"] as! String
                }
                if dict.keys.contains("CreatedTime") && dict["CreatedTime"] != nil {
                    self.createdTime = dict["CreatedTime"] as! String
                }
                if dict.keys.contains("DedicatedInstanceType") && dict["DedicatedInstanceType"] != nil {
                    self.dedicatedInstanceType = dict["DedicatedInstanceType"] as! String
                }
                if dict.keys.contains("EgressIpv6Enable") && dict["EgressIpv6Enable"] != nil {
                    self.egressIpv6Enable = dict["EgressIpv6Enable"] as! Bool
                }
                if dict.keys.contains("ExpiredTime") && dict["ExpiredTime"] != nil {
                    self.expiredTime = dict["ExpiredTime"] as! String
                }
                if dict.keys.contains("HttpsPolicies") && dict["HttpsPolicies"] != nil {
                    self.httpsPolicies = dict["HttpsPolicies"] as! String
                }
                if dict.keys.contains("IPV6AclId") && dict["IPV6AclId"] != nil {
                    self.IPV6AclId = dict["IPV6AclId"] as! String
                }
                if dict.keys.contains("IPV6AclName") && dict["IPV6AclName"] != nil {
                    self.IPV6AclName = dict["IPV6AclName"] as! String
                }
                if dict.keys.contains("IPV6AclStatus") && dict["IPV6AclStatus"] != nil {
                    self.IPV6AclStatus = dict["IPV6AclStatus"] as! String
                }
                if dict.keys.contains("IPV6AclType") && dict["IPV6AclType"] != nil {
                    self.IPV6AclType = dict["IPV6AclType"] as! String
                }
                if dict.keys.contains("InstanceChargeType") && dict["InstanceChargeType"] != nil {
                    self.instanceChargeType = dict["InstanceChargeType"] as! String
                }
                if dict.keys.contains("InstanceCidrBlock") && dict["InstanceCidrBlock"] != nil {
                    self.instanceCidrBlock = dict["InstanceCidrBlock"] as! String
                }
                if dict.keys.contains("InstanceClusterId") && dict["InstanceClusterId"] != nil {
                    self.instanceClusterId = dict["InstanceClusterId"] as! String
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
                    self.instanceName = dict["InstanceName"] as! String
                }
                if dict.keys.contains("InstanceRpsLimit") && dict["InstanceRpsLimit"] != nil {
                    self.instanceRpsLimit = dict["InstanceRpsLimit"] as! Int32
                }
                if dict.keys.contains("InstanceSpec") && dict["InstanceSpec"] != nil {
                    self.instanceSpec = dict["InstanceSpec"] as! String
                }
                if dict.keys.contains("InstanceSpecAttributes") && dict["InstanceSpecAttributes"] != nil {
                    var model = DescribeInstancesResponseBody.Instances.InstanceAttribute.InstanceSpecAttributes()
                    model.fromMap(dict["InstanceSpecAttributes"] as! [String: Any])
                    self.instanceSpecAttributes = model
                }
                if dict.keys.contains("InstanceType") && dict["InstanceType"] != nil {
                    self.instanceType = dict["InstanceType"] as! String
                }
                if dict.keys.contains("InternetEgressAddress") && dict["InternetEgressAddress"] != nil {
                    self.internetEgressAddress = dict["InternetEgressAddress"] as! String
                }
                if dict.keys.contains("IntranetSegments") && dict["IntranetSegments"] != nil {
                    self.intranetSegments = dict["IntranetSegments"] as! String
                }
                if dict.keys.contains("MaintainEndTime") && dict["MaintainEndTime"] != nil {
                    self.maintainEndTime = dict["MaintainEndTime"] as! String
                }
                if dict.keys.contains("MaintainStartTime") && dict["MaintainStartTime"] != nil {
                    self.maintainStartTime = dict["MaintainStartTime"] as! String
                }
                if dict.keys.contains("NetworkInterfaceAttributes") && dict["NetworkInterfaceAttributes"] != nil {
                    var model = DescribeInstancesResponseBody.Instances.InstanceAttribute.NetworkInterfaceAttributes()
                    model.fromMap(dict["NetworkInterfaceAttributes"] as! [String: Any])
                    self.networkInterfaceAttributes = model
                }
                if dict.keys.contains("PrivateDnsList") && dict["PrivateDnsList"] != nil {
                    var model = DescribeInstancesResponseBody.Instances.InstanceAttribute.PrivateDnsList()
                    model.fromMap(dict["PrivateDnsList"] as! [String: Any])
                    self.privateDnsList = model
                }
                if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("SupportIpv6") && dict["SupportIpv6"] != nil {
                    self.supportIpv6 = dict["SupportIpv6"] as! Bool
                }
                if dict.keys.contains("Tags") && dict["Tags"] != nil {
                    var model = DescribeInstancesResponseBody.Instances.InstanceAttribute.Tags()
                    model.fromMap(dict["Tags"] as! [String: Any])
                    self.tags = model
                }
                if dict.keys.contains("UserVpcId") && dict["UserVpcId"] != nil {
                    self.userVpcId = dict["UserVpcId"] as! String
                }
                if dict.keys.contains("UserVswitchId") && dict["UserVswitchId"] != nil {
                    self.userVswitchId = dict["UserVswitchId"] as! String
                }
                if dict.keys.contains("VpcEgressAddress") && dict["VpcEgressAddress"] != nil {
                    self.vpcEgressAddress = dict["VpcEgressAddress"] as! String
                }
                if dict.keys.contains("VpcIntranetEnable") && dict["VpcIntranetEnable"] != nil {
                    self.vpcIntranetEnable = dict["VpcIntranetEnable"] as! Bool
                }
                if dict.keys.contains("VpcOwnerId") && dict["VpcOwnerId"] != nil {
                    self.vpcOwnerId = dict["VpcOwnerId"] as! Int64
                }
                if dict.keys.contains("VpcSlbIntranetEnable") && dict["VpcSlbIntranetEnable"] != nil {
                    self.vpcSlbIntranetEnable = dict["VpcSlbIntranetEnable"] as! Bool
                }
                if dict.keys.contains("ZoneId") && dict["ZoneId"] != nil {
                    self.zoneId = dict["ZoneId"] as! String
                }
                if dict.keys.contains("ZoneLocalName") && dict["ZoneLocalName"] != nil {
                    self.zoneLocalName = dict["ZoneLocalName"] as! String
                }
            }
        }
        public var instanceAttribute: [DescribeInstancesResponseBody.Instances.InstanceAttribute]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceAttribute != nil {
                var tmp : [Any] = []
                for k in self.instanceAttribute! {
                    tmp.append(k.toMap())
                }
                map["InstanceAttribute"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceAttribute") && dict["InstanceAttribute"] != nil {
                var tmp : [DescribeInstancesResponseBody.Instances.InstanceAttribute] = []
                for v in dict["InstanceAttribute"] as! [Any] {
                    var model = DescribeInstancesResponseBody.Instances.InstanceAttribute()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.instanceAttribute = tmp
            }
        }
    }
    public var instances: DescribeInstancesResponseBody.Instances?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instances?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instances != nil {
            map["Instances"] = self.instances?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Instances") && dict["Instances"] != nil {
            var model = DescribeInstancesResponseBody.Instances()
            model.fromMap(dict["Instances"] as! [String: Any])
            self.instances = model
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeIpControlPolicyItemsRequest : Tea.TeaModel {
    public var ipControlId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var policyItemId: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ipControlId != nil {
            map["IpControlId"] = self.ipControlId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.policyItemId != nil {
            map["PolicyItemId"] = self.policyItemId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IpControlId") && dict["IpControlId"] != nil {
            self.ipControlId = dict["IpControlId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("PolicyItemId") && dict["PolicyItemId"] != nil {
            self.policyItemId = dict["PolicyItemId"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DescribeIpControlPolicyItemsResponseBody : Tea.TeaModel {
    public class IpControlPolicyItems : Tea.TeaModel {
        public class IpControlPolicyItem : Tea.TeaModel {
            public var appId: String?

            public var cidrIp: String?

            public var createTime: String?

            public var modifiedTime: String?

            public var policyItemId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.cidrIp != nil {
                    map["CidrIp"] = self.cidrIp!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.modifiedTime != nil {
                    map["ModifiedTime"] = self.modifiedTime!
                }
                if self.policyItemId != nil {
                    map["PolicyItemId"] = self.policyItemId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppId") && dict["AppId"] != nil {
                    self.appId = dict["AppId"] as! String
                }
                if dict.keys.contains("CidrIp") && dict["CidrIp"] != nil {
                    self.cidrIp = dict["CidrIp"] as! String
                }
                if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("ModifiedTime") && dict["ModifiedTime"] != nil {
                    self.modifiedTime = dict["ModifiedTime"] as! String
                }
                if dict.keys.contains("PolicyItemId") && dict["PolicyItemId"] != nil {
                    self.policyItemId = dict["PolicyItemId"] as! String
                }
            }
        }
        public var ipControlPolicyItem: [DescribeIpControlPolicyItemsResponseBody.IpControlPolicyItems.IpControlPolicyItem]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ipControlPolicyItem != nil {
                var tmp : [Any] = []
                for k in self.ipControlPolicyItem! {
                    tmp.append(k.toMap())
                }
                map["IpControlPolicyItem"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("IpControlPolicyItem") && dict["IpControlPolicyItem"] != nil {
                var tmp : [DescribeIpControlPolicyItemsResponseBody.IpControlPolicyItems.IpControlPolicyItem] = []
                for v in dict["IpControlPolicyItem"] as! [Any] {
                    var model = DescribeIpControlPolicyItemsResponseBody.IpControlPolicyItems.IpControlPolicyItem()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ipControlPolicyItem = tmp
            }
        }
    }
    public var ipControlPolicyItems: DescribeIpControlPolicyItemsResponseBody.IpControlPolicyItems?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.ipControlPolicyItems?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ipControlPolicyItems != nil {
            map["IpControlPolicyItems"] = self.ipControlPolicyItems?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IpControlPolicyItems") && dict["IpControlPolicyItems"] != nil {
            var model = DescribeIpControlPolicyItemsResponseBody.IpControlPolicyItems()
            model.fromMap(dict["IpControlPolicyItems"] as! [String: Any])
            self.ipControlPolicyItems = model
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeIpControlPolicyItemsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeIpControlPolicyItemsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeIpControlPolicyItemsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeIpControlsRequest : Tea.TeaModel {
    public var ipControlId: String?

    public var ipControlName: String?

    public var ipControlType: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ipControlId != nil {
            map["IpControlId"] = self.ipControlId!
        }
        if self.ipControlName != nil {
            map["IpControlName"] = self.ipControlName!
        }
        if self.ipControlType != nil {
            map["IpControlType"] = self.ipControlType!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IpControlId") && dict["IpControlId"] != nil {
            self.ipControlId = dict["IpControlId"] as! String
        }
        if dict.keys.contains("IpControlName") && dict["IpControlName"] != nil {
            self.ipControlName = dict["IpControlName"] as! String
        }
        if dict.keys.contains("IpControlType") && dict["IpControlType"] != nil {
            self.ipControlType = dict["IpControlType"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DescribeIpControlsResponseBody : Tea.TeaModel {
    public class IpControlInfos : Tea.TeaModel {
        public class IpControlInfo : Tea.TeaModel {
            public var createTime: String?

            public var description_: String?

            public var ipControlId: String?

            public var ipControlName: String?

            public var ipControlType: String?

            public var modifiedTime: String?

            public var regionId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.ipControlId != nil {
                    map["IpControlId"] = self.ipControlId!
                }
                if self.ipControlName != nil {
                    map["IpControlName"] = self.ipControlName!
                }
                if self.ipControlType != nil {
                    map["IpControlType"] = self.ipControlType!
                }
                if self.modifiedTime != nil {
                    map["ModifiedTime"] = self.modifiedTime!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("IpControlId") && dict["IpControlId"] != nil {
                    self.ipControlId = dict["IpControlId"] as! String
                }
                if dict.keys.contains("IpControlName") && dict["IpControlName"] != nil {
                    self.ipControlName = dict["IpControlName"] as! String
                }
                if dict.keys.contains("IpControlType") && dict["IpControlType"] != nil {
                    self.ipControlType = dict["IpControlType"] as! String
                }
                if dict.keys.contains("ModifiedTime") && dict["ModifiedTime"] != nil {
                    self.modifiedTime = dict["ModifiedTime"] as! String
                }
                if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                    self.regionId = dict["RegionId"] as! String
                }
            }
        }
        public var ipControlInfo: [DescribeIpControlsResponseBody.IpControlInfos.IpControlInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ipControlInfo != nil {
                var tmp : [Any] = []
                for k in self.ipControlInfo! {
                    tmp.append(k.toMap())
                }
                map["IpControlInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("IpControlInfo") && dict["IpControlInfo"] != nil {
                var tmp : [DescribeIpControlsResponseBody.IpControlInfos.IpControlInfo] = []
                for v in dict["IpControlInfo"] as! [Any] {
                    var model = DescribeIpControlsResponseBody.IpControlInfos.IpControlInfo()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ipControlInfo = tmp
            }
        }
    }
    public var ipControlInfos: DescribeIpControlsResponseBody.IpControlInfos?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.ipControlInfos?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ipControlInfos != nil {
            map["IpControlInfos"] = self.ipControlInfos?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IpControlInfos") && dict["IpControlInfos"] != nil {
            var model = DescribeIpControlsResponseBody.IpControlInfos()
            model.fromMap(dict["IpControlInfos"] as! [String: Any])
            self.ipControlInfos = model
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeIpControlsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeIpControlsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeIpControlsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLogConfigRequest : Tea.TeaModel {
    public var logType: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.logType != nil {
            map["LogType"] = self.logType!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LogType") && dict["LogType"] != nil {
            self.logType = dict["LogType"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DescribeLogConfigResponseBody : Tea.TeaModel {
    public class LogInfos : Tea.TeaModel {
        public class LogInfo : Tea.TeaModel {
            public var logType: String?

            public var regionId: String?

            public var slsLogStore: String?

            public var slsProject: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.logType != nil {
                    map["LogType"] = self.logType!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.slsLogStore != nil {
                    map["SlsLogStore"] = self.slsLogStore!
                }
                if self.slsProject != nil {
                    map["SlsProject"] = self.slsProject!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("LogType") && dict["LogType"] != nil {
                    self.logType = dict["LogType"] as! String
                }
                if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("SlsLogStore") && dict["SlsLogStore"] != nil {
                    self.slsLogStore = dict["SlsLogStore"] as! String
                }
                if dict.keys.contains("SlsProject") && dict["SlsProject"] != nil {
                    self.slsProject = dict["SlsProject"] as! String
                }
            }
        }
        public var logInfo: [DescribeLogConfigResponseBody.LogInfos.LogInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.logInfo != nil {
                var tmp : [Any] = []
                for k in self.logInfo! {
                    tmp.append(k.toMap())
                }
                map["LogInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LogInfo") && dict["LogInfo"] != nil {
                var tmp : [DescribeLogConfigResponseBody.LogInfos.LogInfo] = []
                for v in dict["LogInfo"] as! [Any] {
                    var model = DescribeLogConfigResponseBody.LogInfos.LogInfo()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.logInfo = tmp
            }
        }
    }
    public var logInfos: DescribeLogConfigResponseBody.LogInfos?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.logInfos?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.logInfos != nil {
            map["LogInfos"] = self.logInfos?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LogInfos") && dict["LogInfos"] != nil {
            var model = DescribeLogConfigResponseBody.LogInfos()
            model.fromMap(dict["LogInfos"] as! [String: Any])
            self.logInfos = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeLogConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLogConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeLogConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMarketRemainsQuotaRequest : Tea.TeaModel {
    public var domainName: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") && dict["DomainName"] != nil {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DescribeMarketRemainsQuotaResponseBody : Tea.TeaModel {
    public var remainsQuota: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.remainsQuota != nil {
            map["RemainsQuota"] = self.remainsQuota!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RemainsQuota") && dict["RemainsQuota"] != nil {
            self.remainsQuota = dict["RemainsQuota"] as! Int64
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeMarketRemainsQuotaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMarketRemainsQuotaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeMarketRemainsQuotaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeModelsRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var groupId: String?

    public var modelId: String?

    public var modelName: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var tag: [DescribeModelsRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.modelId != nil {
            map["ModelId"] = self.modelId!
        }
        if self.modelName != nil {
            map["ModelName"] = self.modelName!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("ModelId") && dict["ModelId"] != nil {
            self.modelId = dict["ModelId"] as! String
        }
        if dict.keys.contains("ModelName") && dict["ModelName"] != nil {
            self.modelName = dict["ModelName"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Tag") && dict["Tag"] != nil {
            var tmp : [DescribeModelsRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = DescribeModelsRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class DescribeModelsResponseBody : Tea.TeaModel {
    public class ModelDetails : Tea.TeaModel {
        public class ModelDetail : Tea.TeaModel {
            public class Tags : Tea.TeaModel {
                public class TagInfo : Tea.TeaModel {
                    public var key: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Key") && dict["Key"] != nil {
                            self.key = dict["Key"] as! String
                        }
                        if dict.keys.contains("Value") && dict["Value"] != nil {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var tagInfo: [DescribeModelsResponseBody.ModelDetails.ModelDetail.Tags.TagInfo]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tagInfo != nil {
                        var tmp : [Any] = []
                        for k in self.tagInfo! {
                            tmp.append(k.toMap())
                        }
                        map["TagInfo"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("TagInfo") && dict["TagInfo"] != nil {
                        var tmp : [DescribeModelsResponseBody.ModelDetails.ModelDetail.Tags.TagInfo] = []
                        for v in dict["TagInfo"] as! [Any] {
                            var model = DescribeModelsResponseBody.ModelDetails.ModelDetail.Tags.TagInfo()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.tagInfo = tmp
                    }
                }
            }
            public var createdTime: String?

            public var description_: String?

            public var groupId: String?

            public var modelId: String?

            public var modelName: String?

            public var modelRef: String?

            public var modifiedTime: String?

            public var schema: String?

            public var tags: DescribeModelsResponseBody.ModelDetails.ModelDetail.Tags?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createdTime != nil {
                    map["CreatedTime"] = self.createdTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.modelId != nil {
                    map["ModelId"] = self.modelId!
                }
                if self.modelName != nil {
                    map["ModelName"] = self.modelName!
                }
                if self.modelRef != nil {
                    map["ModelRef"] = self.modelRef!
                }
                if self.modifiedTime != nil {
                    map["ModifiedTime"] = self.modifiedTime!
                }
                if self.schema != nil {
                    map["Schema"] = self.schema!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreatedTime") && dict["CreatedTime"] != nil {
                    self.createdTime = dict["CreatedTime"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("ModelId") && dict["ModelId"] != nil {
                    self.modelId = dict["ModelId"] as! String
                }
                if dict.keys.contains("ModelName") && dict["ModelName"] != nil {
                    self.modelName = dict["ModelName"] as! String
                }
                if dict.keys.contains("ModelRef") && dict["ModelRef"] != nil {
                    self.modelRef = dict["ModelRef"] as! String
                }
                if dict.keys.contains("ModifiedTime") && dict["ModifiedTime"] != nil {
                    self.modifiedTime = dict["ModifiedTime"] as! String
                }
                if dict.keys.contains("Schema") && dict["Schema"] != nil {
                    self.schema = dict["Schema"] as! String
                }
                if dict.keys.contains("Tags") && dict["Tags"] != nil {
                    var model = DescribeModelsResponseBody.ModelDetails.ModelDetail.Tags()
                    model.fromMap(dict["Tags"] as! [String: Any])
                    self.tags = model
                }
            }
        }
        public var modelDetail: [DescribeModelsResponseBody.ModelDetails.ModelDetail]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.modelDetail != nil {
                var tmp : [Any] = []
                for k in self.modelDetail! {
                    tmp.append(k.toMap())
                }
                map["ModelDetail"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ModelDetail") && dict["ModelDetail"] != nil {
                var tmp : [DescribeModelsResponseBody.ModelDetails.ModelDetail] = []
                for v in dict["ModelDetail"] as! [Any] {
                    var model = DescribeModelsResponseBody.ModelDetails.ModelDetail()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.modelDetail = tmp
            }
        }
    }
    public var modelDetails: DescribeModelsResponseBody.ModelDetails?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.modelDetails?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.modelDetails != nil {
            map["ModelDetails"] = self.modelDetails?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ModelDetails") && dict["ModelDetails"] != nil {
            var model = DescribeModelsResponseBody.ModelDetails()
            model.fromMap(dict["ModelDetails"] as! [String: Any])
            self.modelDetails = model
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeModelsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeModelsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeModelsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePluginApisRequest : Tea.TeaModel {
    public var apiId: String?

    public var apiName: String?

    public var description_: String?

    public var groupId: String?

    public var method: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var path: String?

    public var pluginId: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.apiName != nil {
            map["ApiName"] = self.apiName!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.method != nil {
            map["Method"] = self.method!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.path != nil {
            map["Path"] = self.path!
        }
        if self.pluginId != nil {
            map["PluginId"] = self.pluginId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiId") && dict["ApiId"] != nil {
            self.apiId = dict["ApiId"] as! String
        }
        if dict.keys.contains("ApiName") && dict["ApiName"] != nil {
            self.apiName = dict["ApiName"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("Method") && dict["Method"] != nil {
            self.method = dict["Method"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Path") && dict["Path"] != nil {
            self.path = dict["Path"] as! String
        }
        if dict.keys.contains("PluginId") && dict["PluginId"] != nil {
            self.pluginId = dict["PluginId"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DescribePluginApisResponseBody : Tea.TeaModel {
    public class ApiSummarys : Tea.TeaModel {
        public class ApiPluginSummary : Tea.TeaModel {
            public var apiId: String?

            public var apiName: String?

            public var description_: String?

            public var groupId: String?

            public var groupName: String?

            public var method: String?

            public var path: String?

            public var regionId: String?

            public var stageAlias: String?

            public var stageName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.apiId != nil {
                    map["ApiId"] = self.apiId!
                }
                if self.apiName != nil {
                    map["ApiName"] = self.apiName!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.method != nil {
                    map["Method"] = self.method!
                }
                if self.path != nil {
                    map["Path"] = self.path!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.stageAlias != nil {
                    map["StageAlias"] = self.stageAlias!
                }
                if self.stageName != nil {
                    map["StageName"] = self.stageName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ApiId") && dict["ApiId"] != nil {
                    self.apiId = dict["ApiId"] as! String
                }
                if dict.keys.contains("ApiName") && dict["ApiName"] != nil {
                    self.apiName = dict["ApiName"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
                    self.groupName = dict["GroupName"] as! String
                }
                if dict.keys.contains("Method") && dict["Method"] != nil {
                    self.method = dict["Method"] as! String
                }
                if dict.keys.contains("Path") && dict["Path"] != nil {
                    self.path = dict["Path"] as! String
                }
                if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("StageAlias") && dict["StageAlias"] != nil {
                    self.stageAlias = dict["StageAlias"] as! String
                }
                if dict.keys.contains("StageName") && dict["StageName"] != nil {
                    self.stageName = dict["StageName"] as! String
                }
            }
        }
        public var apiPluginSummary: [DescribePluginApisResponseBody.ApiSummarys.ApiPluginSummary]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apiPluginSummary != nil {
                var tmp : [Any] = []
                for k in self.apiPluginSummary! {
                    tmp.append(k.toMap())
                }
                map["ApiPluginSummary"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApiPluginSummary") && dict["ApiPluginSummary"] != nil {
                var tmp : [DescribePluginApisResponseBody.ApiSummarys.ApiPluginSummary] = []
                for v in dict["ApiPluginSummary"] as! [Any] {
                    var model = DescribePluginApisResponseBody.ApiSummarys.ApiPluginSummary()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.apiPluginSummary = tmp
            }
        }
    }
    public var apiSummarys: DescribePluginApisResponseBody.ApiSummarys?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.apiSummarys?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiSummarys != nil {
            map["ApiSummarys"] = self.apiSummarys?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiSummarys") && dict["ApiSummarys"] != nil {
            var model = DescribePluginApisResponseBody.ApiSummarys()
            model.fromMap(dict["ApiSummarys"] as! [String: Any])
            self.apiSummarys = model
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribePluginApisResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePluginApisResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribePluginApisResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePluginSchemasRequest : Tea.TeaModel {
    public var language: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Language") && dict["Language"] != nil {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DescribePluginSchemasResponseBody : Tea.TeaModel {
    public class PluginSchemas : Tea.TeaModel {
        public class PluginSchema : Tea.TeaModel {
            public var description_: String?

            public var documentId: String?

            public var name: String?

            public var supportClassic: Bool?

            public var title: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.documentId != nil {
                    map["DocumentId"] = self.documentId!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.supportClassic != nil {
                    map["SupportClassic"] = self.supportClassic!
                }
                if self.title != nil {
                    map["Title"] = self.title!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("DocumentId") && dict["DocumentId"] != nil {
                    self.documentId = dict["DocumentId"] as! String
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("SupportClassic") && dict["SupportClassic"] != nil {
                    self.supportClassic = dict["SupportClassic"] as! Bool
                }
                if dict.keys.contains("Title") && dict["Title"] != nil {
                    self.title = dict["Title"] as! String
                }
            }
        }
        public var pluginSchema: [DescribePluginSchemasResponseBody.PluginSchemas.PluginSchema]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pluginSchema != nil {
                var tmp : [Any] = []
                for k in self.pluginSchema! {
                    tmp.append(k.toMap())
                }
                map["PluginSchema"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PluginSchema") && dict["PluginSchema"] != nil {
                var tmp : [DescribePluginSchemasResponseBody.PluginSchemas.PluginSchema] = []
                for v in dict["PluginSchema"] as! [Any] {
                    var model = DescribePluginSchemasResponseBody.PluginSchemas.PluginSchema()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.pluginSchema = tmp
            }
        }
    }
    public var pluginSchemas: DescribePluginSchemasResponseBody.PluginSchemas?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pluginSchemas?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pluginSchemas != nil {
            map["PluginSchemas"] = self.pluginSchemas?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PluginSchemas") && dict["PluginSchemas"] != nil {
            var model = DescribePluginSchemasResponseBody.PluginSchemas()
            model.fromMap(dict["PluginSchemas"] as! [String: Any])
            self.pluginSchemas = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribePluginSchemasResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePluginSchemasResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribePluginSchemasResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePluginTemplatesRequest : Tea.TeaModel {
    public var language: String?

    public var pluginName: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.pluginName != nil {
            map["PluginName"] = self.pluginName!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Language") && dict["Language"] != nil {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("PluginName") && dict["PluginName"] != nil {
            self.pluginName = dict["PluginName"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DescribePluginTemplatesResponseBody : Tea.TeaModel {
    public class Templates : Tea.TeaModel {
        public class Template : Tea.TeaModel {
            public var description_: String?

            public var documentAnchor: String?

            public var documentId: String?

            public var sample: String?

            public var title: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.documentAnchor != nil {
                    map["DocumentAnchor"] = self.documentAnchor!
                }
                if self.documentId != nil {
                    map["DocumentId"] = self.documentId!
                }
                if self.sample != nil {
                    map["Sample"] = self.sample!
                }
                if self.title != nil {
                    map["Title"] = self.title!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("DocumentAnchor") && dict["DocumentAnchor"] != nil {
                    self.documentAnchor = dict["DocumentAnchor"] as! String
                }
                if dict.keys.contains("DocumentId") && dict["DocumentId"] != nil {
                    self.documentId = dict["DocumentId"] as! String
                }
                if dict.keys.contains("Sample") && dict["Sample"] != nil {
                    self.sample = dict["Sample"] as! String
                }
                if dict.keys.contains("Title") && dict["Title"] != nil {
                    self.title = dict["Title"] as! String
                }
            }
        }
        public var template: [DescribePluginTemplatesResponseBody.Templates.Template]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.template != nil {
                var tmp : [Any] = []
                for k in self.template! {
                    tmp.append(k.toMap())
                }
                map["Template"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Template") && dict["Template"] != nil {
                var tmp : [DescribePluginTemplatesResponseBody.Templates.Template] = []
                for v in dict["Template"] as! [Any] {
                    var model = DescribePluginTemplatesResponseBody.Templates.Template()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.template = tmp
            }
        }
    }
    public var requestId: String?

    public var templates: DescribePluginTemplatesResponseBody.Templates?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.templates?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.templates != nil {
            map["Templates"] = self.templates?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Templates") && dict["Templates"] != nil {
            var model = DescribePluginTemplatesResponseBody.Templates()
            model.fromMap(dict["Templates"] as! [String: Any])
            self.templates = model
        }
    }
}

public class DescribePluginTemplatesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePluginTemplatesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribePluginTemplatesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePluginsRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var pluginId: String?

    public var pluginName: String?

    public var pluginType: String?

    public var securityToken: String?

    public var tag: [DescribePluginsRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.pluginId != nil {
            map["PluginId"] = self.pluginId!
        }
        if self.pluginName != nil {
            map["PluginName"] = self.pluginName!
        }
        if self.pluginType != nil {
            map["PluginType"] = self.pluginType!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("PluginId") && dict["PluginId"] != nil {
            self.pluginId = dict["PluginId"] as! String
        }
        if dict.keys.contains("PluginName") && dict["PluginName"] != nil {
            self.pluginName = dict["PluginName"] as! String
        }
        if dict.keys.contains("PluginType") && dict["PluginType"] != nil {
            self.pluginType = dict["PluginType"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("Tag") && dict["Tag"] != nil {
            var tmp : [DescribePluginsRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = DescribePluginsRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class DescribePluginsResponseBody : Tea.TeaModel {
    public class Plugins : Tea.TeaModel {
        public class PluginAttribute : Tea.TeaModel {
            public class Tags : Tea.TeaModel {
                public class TagInfo : Tea.TeaModel {
                    public var key: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Key") && dict["Key"] != nil {
                            self.key = dict["Key"] as! String
                        }
                        if dict.keys.contains("Value") && dict["Value"] != nil {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var tagInfo: [DescribePluginsResponseBody.Plugins.PluginAttribute.Tags.TagInfo]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tagInfo != nil {
                        var tmp : [Any] = []
                        for k in self.tagInfo! {
                            tmp.append(k.toMap())
                        }
                        map["TagInfo"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("TagInfo") && dict["TagInfo"] != nil {
                        var tmp : [DescribePluginsResponseBody.Plugins.PluginAttribute.Tags.TagInfo] = []
                        for v in dict["TagInfo"] as! [Any] {
                            var model = DescribePluginsResponseBody.Plugins.PluginAttribute.Tags.TagInfo()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.tagInfo = tmp
                    }
                }
            }
            public var createdTime: String?

            public var description_: String?

            public var modifiedTime: String?

            public var pluginData: String?

            public var pluginId: String?

            public var pluginName: String?

            public var pluginType: String?

            public var regionId: String?

            public var tags: DescribePluginsResponseBody.Plugins.PluginAttribute.Tags?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createdTime != nil {
                    map["CreatedTime"] = self.createdTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.modifiedTime != nil {
                    map["ModifiedTime"] = self.modifiedTime!
                }
                if self.pluginData != nil {
                    map["PluginData"] = self.pluginData!
                }
                if self.pluginId != nil {
                    map["PluginId"] = self.pluginId!
                }
                if self.pluginName != nil {
                    map["PluginName"] = self.pluginName!
                }
                if self.pluginType != nil {
                    map["PluginType"] = self.pluginType!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreatedTime") && dict["CreatedTime"] != nil {
                    self.createdTime = dict["CreatedTime"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("ModifiedTime") && dict["ModifiedTime"] != nil {
                    self.modifiedTime = dict["ModifiedTime"] as! String
                }
                if dict.keys.contains("PluginData") && dict["PluginData"] != nil {
                    self.pluginData = dict["PluginData"] as! String
                }
                if dict.keys.contains("PluginId") && dict["PluginId"] != nil {
                    self.pluginId = dict["PluginId"] as! String
                }
                if dict.keys.contains("PluginName") && dict["PluginName"] != nil {
                    self.pluginName = dict["PluginName"] as! String
                }
                if dict.keys.contains("PluginType") && dict["PluginType"] != nil {
                    self.pluginType = dict["PluginType"] as! String
                }
                if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("Tags") && dict["Tags"] != nil {
                    var model = DescribePluginsResponseBody.Plugins.PluginAttribute.Tags()
                    model.fromMap(dict["Tags"] as! [String: Any])
                    self.tags = model
                }
            }
        }
        public var pluginAttribute: [DescribePluginsResponseBody.Plugins.PluginAttribute]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pluginAttribute != nil {
                var tmp : [Any] = []
                for k in self.pluginAttribute! {
                    tmp.append(k.toMap())
                }
                map["PluginAttribute"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PluginAttribute") && dict["PluginAttribute"] != nil {
                var tmp : [DescribePluginsResponseBody.Plugins.PluginAttribute] = []
                for v in dict["PluginAttribute"] as! [Any] {
                    var model = DescribePluginsResponseBody.Plugins.PluginAttribute()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.pluginAttribute = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var plugins: DescribePluginsResponseBody.Plugins?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.plugins?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.plugins != nil {
            map["Plugins"] = self.plugins?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Plugins") && dict["Plugins"] != nil {
            var model = DescribePluginsResponseBody.Plugins()
            model.fromMap(dict["Plugins"] as! [String: Any])
            self.plugins = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribePluginsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePluginsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribePluginsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePluginsByApiRequest : Tea.TeaModel {
    public var apiId: String?

    public var groupId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var securityToken: String?

    public var stageName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.stageName != nil {
            map["StageName"] = self.stageName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiId") && dict["ApiId"] != nil {
            self.apiId = dict["ApiId"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StageName") && dict["StageName"] != nil {
            self.stageName = dict["StageName"] as! String
        }
    }
}

public class DescribePluginsByApiResponseBody : Tea.TeaModel {
    public class Plugins : Tea.TeaModel {
        public class PluginAttribute : Tea.TeaModel {
            public var createdTime: String?

            public var description_: String?

            public var modifiedTime: String?

            public var pluginData: String?

            public var pluginId: String?

            public var pluginName: String?

            public var pluginType: String?

            public var regionId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createdTime != nil {
                    map["CreatedTime"] = self.createdTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.modifiedTime != nil {
                    map["ModifiedTime"] = self.modifiedTime!
                }
                if self.pluginData != nil {
                    map["PluginData"] = self.pluginData!
                }
                if self.pluginId != nil {
                    map["PluginId"] = self.pluginId!
                }
                if self.pluginName != nil {
                    map["PluginName"] = self.pluginName!
                }
                if self.pluginType != nil {
                    map["PluginType"] = self.pluginType!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreatedTime") && dict["CreatedTime"] != nil {
                    self.createdTime = dict["CreatedTime"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("ModifiedTime") && dict["ModifiedTime"] != nil {
                    self.modifiedTime = dict["ModifiedTime"] as! String
                }
                if dict.keys.contains("PluginData") && dict["PluginData"] != nil {
                    self.pluginData = dict["PluginData"] as! String
                }
                if dict.keys.contains("PluginId") && dict["PluginId"] != nil {
                    self.pluginId = dict["PluginId"] as! String
                }
                if dict.keys.contains("PluginName") && dict["PluginName"] != nil {
                    self.pluginName = dict["PluginName"] as! String
                }
                if dict.keys.contains("PluginType") && dict["PluginType"] != nil {
                    self.pluginType = dict["PluginType"] as! String
                }
                if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                    self.regionId = dict["RegionId"] as! String
                }
            }
        }
        public var pluginAttribute: [DescribePluginsByApiResponseBody.Plugins.PluginAttribute]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pluginAttribute != nil {
                var tmp : [Any] = []
                for k in self.pluginAttribute! {
                    tmp.append(k.toMap())
                }
                map["PluginAttribute"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PluginAttribute") && dict["PluginAttribute"] != nil {
                var tmp : [DescribePluginsByApiResponseBody.Plugins.PluginAttribute] = []
                for v in dict["PluginAttribute"] as! [Any] {
                    var model = DescribePluginsByApiResponseBody.Plugins.PluginAttribute()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.pluginAttribute = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var plugins: DescribePluginsByApiResponseBody.Plugins?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.plugins?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.plugins != nil {
            map["Plugins"] = self.plugins?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Plugins") && dict["Plugins"] != nil {
            var model = DescribePluginsByApiResponseBody.Plugins()
            model.fromMap(dict["Plugins"] as! [String: Any])
            self.plugins = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribePluginsByApiResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePluginsByApiResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribePluginsByApiResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePurchasedApiGroupRequest : Tea.TeaModel {
    public var groupId: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DescribePurchasedApiGroupResponseBody : Tea.TeaModel {
    public class Domains : Tea.TeaModel {
        public class DomainItem : Tea.TeaModel {
            public var domainName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DomainName") && dict["DomainName"] != nil {
                    self.domainName = dict["DomainName"] as! String
                }
            }
        }
        public var domainItem: [DescribePurchasedApiGroupResponseBody.Domains.DomainItem]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.domainItem != nil {
                var tmp : [Any] = []
                for k in self.domainItem! {
                    tmp.append(k.toMap())
                }
                map["DomainItem"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DomainItem") && dict["DomainItem"] != nil {
                var tmp : [DescribePurchasedApiGroupResponseBody.Domains.DomainItem] = []
                for v in dict["DomainItem"] as! [Any] {
                    var model = DescribePurchasedApiGroupResponseBody.Domains.DomainItem()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.domainItem = tmp
            }
        }
    }
    public var description_: String?

    public var domains: DescribePurchasedApiGroupResponseBody.Domains?

    public var groupId: String?

    public var groupName: String?

    public var purchasedTime: String?

    public var regionId: String?

    public var requestId: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.domains?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.domains != nil {
            map["Domains"] = self.domains?.toMap()
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.purchasedTime != nil {
            map["PurchasedTime"] = self.purchasedTime!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Domains") && dict["Domains"] != nil {
            var model = DescribePurchasedApiGroupResponseBody.Domains()
            model.fromMap(dict["Domains"] as! [String: Any])
            self.domains = model
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("PurchasedTime") && dict["PurchasedTime"] != nil {
            self.purchasedTime = dict["PurchasedTime"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! String
        }
    }
}

public class DescribePurchasedApiGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePurchasedApiGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribePurchasedApiGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePurchasedApiGroupsRequest : Tea.TeaModel {
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DescribePurchasedApiGroupsResponseBody : Tea.TeaModel {
    public class PurchasedApiGroupAttributes : Tea.TeaModel {
        public class PurchasedApiGroupAttribute : Tea.TeaModel {
            public var billingType: String?

            public var description_: String?

            public var expireTime: String?

            public var groupId: String?

            public var groupName: String?

            public var invokeTimesMax: Int64?

            public var invokeTimesNow: Int64?

            public var purchasedTime: String?

            public var regionId: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.billingType != nil {
                    map["BillingType"] = self.billingType!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.expireTime != nil {
                    map["ExpireTime"] = self.expireTime!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.invokeTimesMax != nil {
                    map["InvokeTimesMax"] = self.invokeTimesMax!
                }
                if self.invokeTimesNow != nil {
                    map["InvokeTimesNow"] = self.invokeTimesNow!
                }
                if self.purchasedTime != nil {
                    map["PurchasedTime"] = self.purchasedTime!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BillingType") && dict["BillingType"] != nil {
                    self.billingType = dict["BillingType"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("ExpireTime") && dict["ExpireTime"] != nil {
                    self.expireTime = dict["ExpireTime"] as! String
                }
                if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
                    self.groupName = dict["GroupName"] as! String
                }
                if dict.keys.contains("InvokeTimesMax") && dict["InvokeTimesMax"] != nil {
                    self.invokeTimesMax = dict["InvokeTimesMax"] as! Int64
                }
                if dict.keys.contains("InvokeTimesNow") && dict["InvokeTimesNow"] != nil {
                    self.invokeTimesNow = dict["InvokeTimesNow"] as! Int64
                }
                if dict.keys.contains("PurchasedTime") && dict["PurchasedTime"] != nil {
                    self.purchasedTime = dict["PurchasedTime"] as! String
                }
                if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var purchasedApiGroupAttribute: [DescribePurchasedApiGroupsResponseBody.PurchasedApiGroupAttributes.PurchasedApiGroupAttribute]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.purchasedApiGroupAttribute != nil {
                var tmp : [Any] = []
                for k in self.purchasedApiGroupAttribute! {
                    tmp.append(k.toMap())
                }
                map["PurchasedApiGroupAttribute"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PurchasedApiGroupAttribute") && dict["PurchasedApiGroupAttribute"] != nil {
                var tmp : [DescribePurchasedApiGroupsResponseBody.PurchasedApiGroupAttributes.PurchasedApiGroupAttribute] = []
                for v in dict["PurchasedApiGroupAttribute"] as! [Any] {
                    var model = DescribePurchasedApiGroupsResponseBody.PurchasedApiGroupAttributes.PurchasedApiGroupAttribute()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.purchasedApiGroupAttribute = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var purchasedApiGroupAttributes: DescribePurchasedApiGroupsResponseBody.PurchasedApiGroupAttributes?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.purchasedApiGroupAttributes?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.purchasedApiGroupAttributes != nil {
            map["PurchasedApiGroupAttributes"] = self.purchasedApiGroupAttributes?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("PurchasedApiGroupAttributes") && dict["PurchasedApiGroupAttributes"] != nil {
            var model = DescribePurchasedApiGroupsResponseBody.PurchasedApiGroupAttributes()
            model.fromMap(dict["PurchasedApiGroupAttributes"] as! [String: Any])
            self.purchasedApiGroupAttributes = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribePurchasedApiGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePurchasedApiGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribePurchasedApiGroupsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePurchasedApisRequest : Tea.TeaModel {
    public var apiId: String?

    public var apiName: String?

    public var groupId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var securityToken: String?

    public var stageName: String?

    public var visibility: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.apiName != nil {
            map["ApiName"] = self.apiName!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.stageName != nil {
            map["StageName"] = self.stageName!
        }
        if self.visibility != nil {
            map["Visibility"] = self.visibility!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiId") && dict["ApiId"] != nil {
            self.apiId = dict["ApiId"] as! String
        }
        if dict.keys.contains("ApiName") && dict["ApiName"] != nil {
            self.apiName = dict["ApiName"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StageName") && dict["StageName"] != nil {
            self.stageName = dict["StageName"] as! String
        }
        if dict.keys.contains("Visibility") && dict["Visibility"] != nil {
            self.visibility = dict["Visibility"] as! String
        }
    }
}

public class DescribePurchasedApisResponseBody : Tea.TeaModel {
    public class PurchasedApis : Tea.TeaModel {
        public class PurchasedApi : Tea.TeaModel {
            public var apiId: String?

            public var apiName: String?

            public var deployedTime: String?

            public var description_: String?

            public var groupId: String?

            public var groupName: String?

            public var modifiedTime: String?

            public var purchasedTime: String?

            public var regionId: String?

            public var stageName: String?

            public var visibility: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.apiId != nil {
                    map["ApiId"] = self.apiId!
                }
                if self.apiName != nil {
                    map["ApiName"] = self.apiName!
                }
                if self.deployedTime != nil {
                    map["DeployedTime"] = self.deployedTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.modifiedTime != nil {
                    map["ModifiedTime"] = self.modifiedTime!
                }
                if self.purchasedTime != nil {
                    map["PurchasedTime"] = self.purchasedTime!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.stageName != nil {
                    map["StageName"] = self.stageName!
                }
                if self.visibility != nil {
                    map["Visibility"] = self.visibility!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ApiId") && dict["ApiId"] != nil {
                    self.apiId = dict["ApiId"] as! String
                }
                if dict.keys.contains("ApiName") && dict["ApiName"] != nil {
                    self.apiName = dict["ApiName"] as! String
                }
                if dict.keys.contains("DeployedTime") && dict["DeployedTime"] != nil {
                    self.deployedTime = dict["DeployedTime"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
                    self.groupName = dict["GroupName"] as! String
                }
                if dict.keys.contains("ModifiedTime") && dict["ModifiedTime"] != nil {
                    self.modifiedTime = dict["ModifiedTime"] as! String
                }
                if dict.keys.contains("PurchasedTime") && dict["PurchasedTime"] != nil {
                    self.purchasedTime = dict["PurchasedTime"] as! String
                }
                if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("StageName") && dict["StageName"] != nil {
                    self.stageName = dict["StageName"] as! String
                }
                if dict.keys.contains("Visibility") && dict["Visibility"] != nil {
                    self.visibility = dict["Visibility"] as! String
                }
            }
        }
        public var purchasedApi: [DescribePurchasedApisResponseBody.PurchasedApis.PurchasedApi]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.purchasedApi != nil {
                var tmp : [Any] = []
                for k in self.purchasedApi! {
                    tmp.append(k.toMap())
                }
                map["PurchasedApi"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PurchasedApi") && dict["PurchasedApi"] != nil {
                var tmp : [DescribePurchasedApisResponseBody.PurchasedApis.PurchasedApi] = []
                for v in dict["PurchasedApi"] as! [Any] {
                    var model = DescribePurchasedApisResponseBody.PurchasedApis.PurchasedApi()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.purchasedApi = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var purchasedApis: DescribePurchasedApisResponseBody.PurchasedApis?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.purchasedApis?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.purchasedApis != nil {
            map["PurchasedApis"] = self.purchasedApis?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("PurchasedApis") && dict["PurchasedApis"] != nil {
            var model = DescribePurchasedApisResponseBody.PurchasedApis()
            model.fromMap(dict["PurchasedApis"] as! [String: Any])
            self.purchasedApis = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribePurchasedApisResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePurchasedApisResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribePurchasedApisResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeRegionsRequest : Tea.TeaModel {
    public var language: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Language") && dict["Language"] != nil {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DescribeRegionsResponseBody : Tea.TeaModel {
    public class Regions : Tea.TeaModel {
        public class Region : Tea.TeaModel {
            public var localName: String?

            public var regionEndpoint: String?

            public var regionId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.localName != nil {
                    map["LocalName"] = self.localName!
                }
                if self.regionEndpoint != nil {
                    map["RegionEndpoint"] = self.regionEndpoint!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("LocalName") && dict["LocalName"] != nil {
                    self.localName = dict["LocalName"] as! String
                }
                if dict.keys.contains("RegionEndpoint") && dict["RegionEndpoint"] != nil {
                    self.regionEndpoint = dict["RegionEndpoint"] as! String
                }
                if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                    self.regionId = dict["RegionId"] as! String
                }
            }
        }
        public var region: [DescribeRegionsResponseBody.Regions.Region]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.region != nil {
                var tmp : [Any] = []
                for k in self.region! {
                    tmp.append(k.toMap())
                }
                map["Region"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Region") && dict["Region"] != nil {
                var tmp : [DescribeRegionsResponseBody.Regions.Region] = []
                for v in dict["Region"] as! [Any] {
                    var model = DescribeRegionsResponseBody.Regions.Region()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.region = tmp
            }
        }
    }
    public var regions: DescribeRegionsResponseBody.Regions?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.regions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regions != nil {
            map["Regions"] = self.regions?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Regions") && dict["Regions"] != nil {
            var model = DescribeRegionsResponseBody.Regions()
            model.fromMap(dict["Regions"] as! [String: Any])
            self.regions = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeRegionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRegionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeRegionsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSignaturesRequest : Tea.TeaModel {
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var securityToken: String?

    public var signatureId: String?

    public var signatureName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.signatureId != nil {
            map["SignatureId"] = self.signatureId!
        }
        if self.signatureName != nil {
            map["SignatureName"] = self.signatureName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("SignatureId") && dict["SignatureId"] != nil {
            self.signatureId = dict["SignatureId"] as! String
        }
        if dict.keys.contains("SignatureName") && dict["SignatureName"] != nil {
            self.signatureName = dict["SignatureName"] as! String
        }
    }
}

public class DescribeSignaturesResponseBody : Tea.TeaModel {
    public class SignatureInfos : Tea.TeaModel {
        public class SignatureInfo : Tea.TeaModel {
            public var createdTime: String?

            public var modifiedTime: String?

            public var regionId: String?

            public var signatureId: String?

            public var signatureKey: String?

            public var signatureName: String?

            public var signatureSecret: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createdTime != nil {
                    map["CreatedTime"] = self.createdTime!
                }
                if self.modifiedTime != nil {
                    map["ModifiedTime"] = self.modifiedTime!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.signatureId != nil {
                    map["SignatureId"] = self.signatureId!
                }
                if self.signatureKey != nil {
                    map["SignatureKey"] = self.signatureKey!
                }
                if self.signatureName != nil {
                    map["SignatureName"] = self.signatureName!
                }
                if self.signatureSecret != nil {
                    map["SignatureSecret"] = self.signatureSecret!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreatedTime") && dict["CreatedTime"] != nil {
                    self.createdTime = dict["CreatedTime"] as! String
                }
                if dict.keys.contains("ModifiedTime") && dict["ModifiedTime"] != nil {
                    self.modifiedTime = dict["ModifiedTime"] as! String
                }
                if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("SignatureId") && dict["SignatureId"] != nil {
                    self.signatureId = dict["SignatureId"] as! String
                }
                if dict.keys.contains("SignatureKey") && dict["SignatureKey"] != nil {
                    self.signatureKey = dict["SignatureKey"] as! String
                }
                if dict.keys.contains("SignatureName") && dict["SignatureName"] != nil {
                    self.signatureName = dict["SignatureName"] as! String
                }
                if dict.keys.contains("SignatureSecret") && dict["SignatureSecret"] != nil {
                    self.signatureSecret = dict["SignatureSecret"] as! String
                }
            }
        }
        public var signatureInfo: [DescribeSignaturesResponseBody.SignatureInfos.SignatureInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.signatureInfo != nil {
                var tmp : [Any] = []
                for k in self.signatureInfo! {
                    tmp.append(k.toMap())
                }
                map["SignatureInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SignatureInfo") && dict["SignatureInfo"] != nil {
                var tmp : [DescribeSignaturesResponseBody.SignatureInfos.SignatureInfo] = []
                for v in dict["SignatureInfo"] as! [Any] {
                    var model = DescribeSignaturesResponseBody.SignatureInfos.SignatureInfo()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.signatureInfo = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var signatureInfos: DescribeSignaturesResponseBody.SignatureInfos?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.signatureInfos?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.signatureInfos != nil {
            map["SignatureInfos"] = self.signatureInfos?.toMap()
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SignatureInfos") && dict["SignatureInfos"] != nil {
            var model = DescribeSignaturesResponseBody.SignatureInfos()
            model.fromMap(dict["SignatureInfos"] as! [String: Any])
            self.signatureInfos = model
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeSignaturesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSignaturesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeSignaturesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSignaturesByApiRequest : Tea.TeaModel {
    public var apiId: String?

    public var groupId: String?

    public var securityToken: String?

    public var stageName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.stageName != nil {
            map["StageName"] = self.stageName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiId") && dict["ApiId"] != nil {
            self.apiId = dict["ApiId"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StageName") && dict["StageName"] != nil {
            self.stageName = dict["StageName"] as! String
        }
    }
}

public class DescribeSignaturesByApiResponseBody : Tea.TeaModel {
    public class Signatures : Tea.TeaModel {
        public class SignatureItem : Tea.TeaModel {
            public var boundTime: String?

            public var signatureId: String?

            public var signatureName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.boundTime != nil {
                    map["BoundTime"] = self.boundTime!
                }
                if self.signatureId != nil {
                    map["SignatureId"] = self.signatureId!
                }
                if self.signatureName != nil {
                    map["SignatureName"] = self.signatureName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BoundTime") && dict["BoundTime"] != nil {
                    self.boundTime = dict["BoundTime"] as! String
                }
                if dict.keys.contains("SignatureId") && dict["SignatureId"] != nil {
                    self.signatureId = dict["SignatureId"] as! String
                }
                if dict.keys.contains("SignatureName") && dict["SignatureName"] != nil {
                    self.signatureName = dict["SignatureName"] as! String
                }
            }
        }
        public var signatureItem: [DescribeSignaturesByApiResponseBody.Signatures.SignatureItem]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.signatureItem != nil {
                var tmp : [Any] = []
                for k in self.signatureItem! {
                    tmp.append(k.toMap())
                }
                map["SignatureItem"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SignatureItem") && dict["SignatureItem"] != nil {
                var tmp : [DescribeSignaturesByApiResponseBody.Signatures.SignatureItem] = []
                for v in dict["SignatureItem"] as! [Any] {
                    var model = DescribeSignaturesByApiResponseBody.Signatures.SignatureItem()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.signatureItem = tmp
            }
        }
    }
    public var requestId: String?

    public var signatures: DescribeSignaturesByApiResponseBody.Signatures?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.signatures?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.signatures != nil {
            map["Signatures"] = self.signatures?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Signatures") && dict["Signatures"] != nil {
            var model = DescribeSignaturesByApiResponseBody.Signatures()
            model.fromMap(dict["Signatures"] as! [String: Any])
            self.signatures = model
        }
    }
}

public class DescribeSignaturesByApiResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSignaturesByApiResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeSignaturesByApiResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSummaryDataRequest : Tea.TeaModel {
    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DescribeSummaryDataResponseBody : Tea.TeaModel {
    public var expireInstanceNum: Int32?

    public var region: String?

    public var requestId: String?

    public var usageApiNum: Int32?

    public var usageGroupNum: Int32?

    public var usageInstanceNum: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.expireInstanceNum != nil {
            map["ExpireInstanceNum"] = self.expireInstanceNum!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.usageApiNum != nil {
            map["UsageApiNum"] = self.usageApiNum!
        }
        if self.usageGroupNum != nil {
            map["UsageGroupNum"] = self.usageGroupNum!
        }
        if self.usageInstanceNum != nil {
            map["UsageInstanceNum"] = self.usageInstanceNum!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ExpireInstanceNum") && dict["ExpireInstanceNum"] != nil {
            self.expireInstanceNum = dict["ExpireInstanceNum"] as! Int32
        }
        if dict.keys.contains("Region") && dict["Region"] != nil {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("UsageApiNum") && dict["UsageApiNum"] != nil {
            self.usageApiNum = dict["UsageApiNum"] as! Int32
        }
        if dict.keys.contains("UsageGroupNum") && dict["UsageGroupNum"] != nil {
            self.usageGroupNum = dict["UsageGroupNum"] as! Int32
        }
        if dict.keys.contains("UsageInstanceNum") && dict["UsageInstanceNum"] != nil {
            self.usageInstanceNum = dict["UsageInstanceNum"] as! Int32
        }
    }
}

public class DescribeSummaryDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSummaryDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeSummaryDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSystemParametersRequest : Tea.TeaModel {
    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DescribeSystemParametersResponseBody : Tea.TeaModel {
    public class SystemParams : Tea.TeaModel {
        public class SystemParamItem : Tea.TeaModel {
            public var demoValue: String?

            public var description_: String?

            public var paramName: String?

            public var paramType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.demoValue != nil {
                    map["DemoValue"] = self.demoValue!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.paramName != nil {
                    map["ParamName"] = self.paramName!
                }
                if self.paramType != nil {
                    map["ParamType"] = self.paramType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DemoValue") && dict["DemoValue"] != nil {
                    self.demoValue = dict["DemoValue"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("ParamName") && dict["ParamName"] != nil {
                    self.paramName = dict["ParamName"] as! String
                }
                if dict.keys.contains("ParamType") && dict["ParamType"] != nil {
                    self.paramType = dict["ParamType"] as! String
                }
            }
        }
        public var systemParamItem: [DescribeSystemParametersResponseBody.SystemParams.SystemParamItem]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.systemParamItem != nil {
                var tmp : [Any] = []
                for k in self.systemParamItem! {
                    tmp.append(k.toMap())
                }
                map["SystemParamItem"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SystemParamItem") && dict["SystemParamItem"] != nil {
                var tmp : [DescribeSystemParametersResponseBody.SystemParams.SystemParamItem] = []
                for v in dict["SystemParamItem"] as! [Any] {
                    var model = DescribeSystemParametersResponseBody.SystemParams.SystemParamItem()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.systemParamItem = tmp
            }
        }
    }
    public var requestId: String?

    public var systemParams: DescribeSystemParametersResponseBody.SystemParams?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.systemParams?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.systemParams != nil {
            map["SystemParams"] = self.systemParams?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SystemParams") && dict["SystemParams"] != nil {
            var model = DescribeSystemParametersResponseBody.SystemParams()
            model.fromMap(dict["SystemParams"] as! [String: Any])
            self.systemParams = model
        }
    }
}

public class DescribeSystemParametersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSystemParametersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeSystemParametersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeTrafficControlsRequest : Tea.TeaModel {
    public var apiId: String?

    public var groupId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var securityToken: String?

    public var stageName: String?

    public var trafficControlId: String?

    public var trafficControlName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.stageName != nil {
            map["StageName"] = self.stageName!
        }
        if self.trafficControlId != nil {
            map["TrafficControlId"] = self.trafficControlId!
        }
        if self.trafficControlName != nil {
            map["TrafficControlName"] = self.trafficControlName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiId") && dict["ApiId"] != nil {
            self.apiId = dict["ApiId"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StageName") && dict["StageName"] != nil {
            self.stageName = dict["StageName"] as! String
        }
        if dict.keys.contains("TrafficControlId") && dict["TrafficControlId"] != nil {
            self.trafficControlId = dict["TrafficControlId"] as! String
        }
        if dict.keys.contains("TrafficControlName") && dict["TrafficControlName"] != nil {
            self.trafficControlName = dict["TrafficControlName"] as! String
        }
    }
}

public class DescribeTrafficControlsResponseBody : Tea.TeaModel {
    public class TrafficControls : Tea.TeaModel {
        public class TrafficControl : Tea.TeaModel {
            public class SpecialPolicies : Tea.TeaModel {
                public class SpecialPolicy : Tea.TeaModel {
                    public class Specials : Tea.TeaModel {
                        public class Special : Tea.TeaModel {
                            public var specialKey: String?

                            public var trafficValue: Int32?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.specialKey != nil {
                                    map["SpecialKey"] = self.specialKey!
                                }
                                if self.trafficValue != nil {
                                    map["TrafficValue"] = self.trafficValue!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("SpecialKey") && dict["SpecialKey"] != nil {
                                    self.specialKey = dict["SpecialKey"] as! String
                                }
                                if dict.keys.contains("TrafficValue") && dict["TrafficValue"] != nil {
                                    self.trafficValue = dict["TrafficValue"] as! Int32
                                }
                            }
                        }
                        public var special: [DescribeTrafficControlsResponseBody.TrafficControls.TrafficControl.SpecialPolicies.SpecialPolicy.Specials.Special]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.special != nil {
                                var tmp : [Any] = []
                                for k in self.special! {
                                    tmp.append(k.toMap())
                                }
                                map["Special"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Special") && dict["Special"] != nil {
                                var tmp : [DescribeTrafficControlsResponseBody.TrafficControls.TrafficControl.SpecialPolicies.SpecialPolicy.Specials.Special] = []
                                for v in dict["Special"] as! [Any] {
                                    var model = DescribeTrafficControlsResponseBody.TrafficControls.TrafficControl.SpecialPolicies.SpecialPolicy.Specials.Special()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.special = tmp
                            }
                        }
                    }
                    public var specialType: String?

                    public var specials: DescribeTrafficControlsResponseBody.TrafficControls.TrafficControl.SpecialPolicies.SpecialPolicy.Specials?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.specials?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.specialType != nil {
                            map["SpecialType"] = self.specialType!
                        }
                        if self.specials != nil {
                            map["Specials"] = self.specials?.toMap()
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("SpecialType") && dict["SpecialType"] != nil {
                            self.specialType = dict["SpecialType"] as! String
                        }
                        if dict.keys.contains("Specials") && dict["Specials"] != nil {
                            var model = DescribeTrafficControlsResponseBody.TrafficControls.TrafficControl.SpecialPolicies.SpecialPolicy.Specials()
                            model.fromMap(dict["Specials"] as! [String: Any])
                            self.specials = model
                        }
                    }
                }
                public var specialPolicy: [DescribeTrafficControlsResponseBody.TrafficControls.TrafficControl.SpecialPolicies.SpecialPolicy]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.specialPolicy != nil {
                        var tmp : [Any] = []
                        for k in self.specialPolicy! {
                            tmp.append(k.toMap())
                        }
                        map["SpecialPolicy"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("SpecialPolicy") && dict["SpecialPolicy"] != nil {
                        var tmp : [DescribeTrafficControlsResponseBody.TrafficControls.TrafficControl.SpecialPolicies.SpecialPolicy] = []
                        for v in dict["SpecialPolicy"] as! [Any] {
                            var model = DescribeTrafficControlsResponseBody.TrafficControls.TrafficControl.SpecialPolicies.SpecialPolicy()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.specialPolicy = tmp
                    }
                }
            }
            public var apiDefault: Int32?

            public var appDefault: Int32?

            public var createdTime: String?

            public var description_: String?

            public var modifiedTime: String?

            public var specialPolicies: DescribeTrafficControlsResponseBody.TrafficControls.TrafficControl.SpecialPolicies?

            public var trafficControlId: String?

            public var trafficControlName: String?

            public var trafficControlUnit: String?

            public var userDefault: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.specialPolicies?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.apiDefault != nil {
                    map["ApiDefault"] = self.apiDefault!
                }
                if self.appDefault != nil {
                    map["AppDefault"] = self.appDefault!
                }
                if self.createdTime != nil {
                    map["CreatedTime"] = self.createdTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.modifiedTime != nil {
                    map["ModifiedTime"] = self.modifiedTime!
                }
                if self.specialPolicies != nil {
                    map["SpecialPolicies"] = self.specialPolicies?.toMap()
                }
                if self.trafficControlId != nil {
                    map["TrafficControlId"] = self.trafficControlId!
                }
                if self.trafficControlName != nil {
                    map["TrafficControlName"] = self.trafficControlName!
                }
                if self.trafficControlUnit != nil {
                    map["TrafficControlUnit"] = self.trafficControlUnit!
                }
                if self.userDefault != nil {
                    map["UserDefault"] = self.userDefault!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ApiDefault") && dict["ApiDefault"] != nil {
                    self.apiDefault = dict["ApiDefault"] as! Int32
                }
                if dict.keys.contains("AppDefault") && dict["AppDefault"] != nil {
                    self.appDefault = dict["AppDefault"] as! Int32
                }
                if dict.keys.contains("CreatedTime") && dict["CreatedTime"] != nil {
                    self.createdTime = dict["CreatedTime"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("ModifiedTime") && dict["ModifiedTime"] != nil {
                    self.modifiedTime = dict["ModifiedTime"] as! String
                }
                if dict.keys.contains("SpecialPolicies") && dict["SpecialPolicies"] != nil {
                    var model = DescribeTrafficControlsResponseBody.TrafficControls.TrafficControl.SpecialPolicies()
                    model.fromMap(dict["SpecialPolicies"] as! [String: Any])
                    self.specialPolicies = model
                }
                if dict.keys.contains("TrafficControlId") && dict["TrafficControlId"] != nil {
                    self.trafficControlId = dict["TrafficControlId"] as! String
                }
                if dict.keys.contains("TrafficControlName") && dict["TrafficControlName"] != nil {
                    self.trafficControlName = dict["TrafficControlName"] as! String
                }
                if dict.keys.contains("TrafficControlUnit") && dict["TrafficControlUnit"] != nil {
                    self.trafficControlUnit = dict["TrafficControlUnit"] as! String
                }
                if dict.keys.contains("UserDefault") && dict["UserDefault"] != nil {
                    self.userDefault = dict["UserDefault"] as! Int32
                }
            }
        }
        public var trafficControl: [DescribeTrafficControlsResponseBody.TrafficControls.TrafficControl]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.trafficControl != nil {
                var tmp : [Any] = []
                for k in self.trafficControl! {
                    tmp.append(k.toMap())
                }
                map["TrafficControl"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TrafficControl") && dict["TrafficControl"] != nil {
                var tmp : [DescribeTrafficControlsResponseBody.TrafficControls.TrafficControl] = []
                for v in dict["TrafficControl"] as! [Any] {
                    var model = DescribeTrafficControlsResponseBody.TrafficControls.TrafficControl()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.trafficControl = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public var trafficControls: DescribeTrafficControlsResponseBody.TrafficControls?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.trafficControls?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.trafficControls != nil {
            map["TrafficControls"] = self.trafficControls?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
        if dict.keys.contains("TrafficControls") && dict["TrafficControls"] != nil {
            var model = DescribeTrafficControlsResponseBody.TrafficControls()
            model.fromMap(dict["TrafficControls"] as! [String: Any])
            self.trafficControls = model
        }
    }
}

public class DescribeTrafficControlsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeTrafficControlsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeTrafficControlsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeTrafficControlsByApiRequest : Tea.TeaModel {
    public var apiId: String?

    public var groupId: String?

    public var securityToken: String?

    public var stageName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.stageName != nil {
            map["StageName"] = self.stageName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiId") && dict["ApiId"] != nil {
            self.apiId = dict["ApiId"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StageName") && dict["StageName"] != nil {
            self.stageName = dict["StageName"] as! String
        }
    }
}

public class DescribeTrafficControlsByApiResponseBody : Tea.TeaModel {
    public class TrafficControlItems : Tea.TeaModel {
        public class TrafficControlItem : Tea.TeaModel {
            public var boundTime: String?

            public var trafficControlItemId: String?

            public var trafficControlItemName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.boundTime != nil {
                    map["BoundTime"] = self.boundTime!
                }
                if self.trafficControlItemId != nil {
                    map["TrafficControlItemId"] = self.trafficControlItemId!
                }
                if self.trafficControlItemName != nil {
                    map["TrafficControlItemName"] = self.trafficControlItemName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BoundTime") && dict["BoundTime"] != nil {
                    self.boundTime = dict["BoundTime"] as! String
                }
                if dict.keys.contains("TrafficControlItemId") && dict["TrafficControlItemId"] != nil {
                    self.trafficControlItemId = dict["TrafficControlItemId"] as! String
                }
                if dict.keys.contains("TrafficControlItemName") && dict["TrafficControlItemName"] != nil {
                    self.trafficControlItemName = dict["TrafficControlItemName"] as! String
                }
            }
        }
        public var trafficControlItem: [DescribeTrafficControlsByApiResponseBody.TrafficControlItems.TrafficControlItem]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.trafficControlItem != nil {
                var tmp : [Any] = []
                for k in self.trafficControlItem! {
                    tmp.append(k.toMap())
                }
                map["TrafficControlItem"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TrafficControlItem") && dict["TrafficControlItem"] != nil {
                var tmp : [DescribeTrafficControlsByApiResponseBody.TrafficControlItems.TrafficControlItem] = []
                for v in dict["TrafficControlItem"] as! [Any] {
                    var model = DescribeTrafficControlsByApiResponseBody.TrafficControlItems.TrafficControlItem()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.trafficControlItem = tmp
            }
        }
    }
    public var requestId: String?

    public var trafficControlItems: DescribeTrafficControlsByApiResponseBody.TrafficControlItems?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.trafficControlItems?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.trafficControlItems != nil {
            map["TrafficControlItems"] = self.trafficControlItems?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TrafficControlItems") && dict["TrafficControlItems"] != nil {
            var model = DescribeTrafficControlsByApiResponseBody.TrafficControlItems()
            model.fromMap(dict["TrafficControlItems"] as! [String: Any])
            self.trafficControlItems = model
        }
    }
}

public class DescribeTrafficControlsByApiResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeTrafficControlsByApiResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeTrafficControlsByApiResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeUpdateBackendTaskRequest : Tea.TeaModel {
    public var operationUid: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.operationUid != nil {
            map["OperationUid"] = self.operationUid!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OperationUid") && dict["OperationUid"] != nil {
            self.operationUid = dict["OperationUid"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DescribeUpdateBackendTaskResponseBody : Tea.TeaModel {
    public class ApiUpdateBackendResults : Tea.TeaModel {
        public class ApiUpdateBackendResult : Tea.TeaModel {
            public var apiName: String?

            public var apiUid: String?

            public var backendId: String?

            public var errorMsg: String?

            public var groupId: String?

            public var groupName: String?

            public var stageId: String?

            public var stageName: String?

            public var updateStatus: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.apiName != nil {
                    map["ApiName"] = self.apiName!
                }
                if self.apiUid != nil {
                    map["ApiUid"] = self.apiUid!
                }
                if self.backendId != nil {
                    map["BackendId"] = self.backendId!
                }
                if self.errorMsg != nil {
                    map["ErrorMsg"] = self.errorMsg!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.stageId != nil {
                    map["StageId"] = self.stageId!
                }
                if self.stageName != nil {
                    map["StageName"] = self.stageName!
                }
                if self.updateStatus != nil {
                    map["UpdateStatus"] = self.updateStatus!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ApiName") && dict["ApiName"] != nil {
                    self.apiName = dict["ApiName"] as! String
                }
                if dict.keys.contains("ApiUid") && dict["ApiUid"] != nil {
                    self.apiUid = dict["ApiUid"] as! String
                }
                if dict.keys.contains("BackendId") && dict["BackendId"] != nil {
                    self.backendId = dict["BackendId"] as! String
                }
                if dict.keys.contains("ErrorMsg") && dict["ErrorMsg"] != nil {
                    self.errorMsg = dict["ErrorMsg"] as! String
                }
                if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
                    self.groupName = dict["GroupName"] as! String
                }
                if dict.keys.contains("StageId") && dict["StageId"] != nil {
                    self.stageId = dict["StageId"] as! String
                }
                if dict.keys.contains("StageName") && dict["StageName"] != nil {
                    self.stageName = dict["StageName"] as! String
                }
                if dict.keys.contains("UpdateStatus") && dict["UpdateStatus"] != nil {
                    self.updateStatus = dict["UpdateStatus"] as! String
                }
            }
        }
        public var apiUpdateBackendResult: [DescribeUpdateBackendTaskResponseBody.ApiUpdateBackendResults.ApiUpdateBackendResult]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apiUpdateBackendResult != nil {
                var tmp : [Any] = []
                for k in self.apiUpdateBackendResult! {
                    tmp.append(k.toMap())
                }
                map["ApiUpdateBackendResult"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApiUpdateBackendResult") && dict["ApiUpdateBackendResult"] != nil {
                var tmp : [DescribeUpdateBackendTaskResponseBody.ApiUpdateBackendResults.ApiUpdateBackendResult] = []
                for v in dict["ApiUpdateBackendResult"] as! [Any] {
                    var model = DescribeUpdateBackendTaskResponseBody.ApiUpdateBackendResults.ApiUpdateBackendResult()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.apiUpdateBackendResult = tmp
            }
        }
    }
    public var apiUpdateBackendResults: DescribeUpdateBackendTaskResponseBody.ApiUpdateBackendResults?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.apiUpdateBackendResults?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiUpdateBackendResults != nil {
            map["ApiUpdateBackendResults"] = self.apiUpdateBackendResults?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiUpdateBackendResults") && dict["ApiUpdateBackendResults"] != nil {
            var model = DescribeUpdateBackendTaskResponseBody.ApiUpdateBackendResults()
            model.fromMap(dict["ApiUpdateBackendResults"] as! [String: Any])
            self.apiUpdateBackendResults = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeUpdateBackendTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeUpdateBackendTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeUpdateBackendTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeUpdateVpcInfoTaskRequest : Tea.TeaModel {
    public var operationUid: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.operationUid != nil {
            map["OperationUid"] = self.operationUid!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OperationUid") && dict["OperationUid"] != nil {
            self.operationUid = dict["OperationUid"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DescribeUpdateVpcInfoTaskResponseBody : Tea.TeaModel {
    public class ApiUpdateVpcInfoResults : Tea.TeaModel {
        public class ApiUpdateVpcInfoResult : Tea.TeaModel {
            public var apiName: String?

            public var apiUid: String?

            public var errorMsg: String?

            public var groupId: String?

            public var groupName: String?

            public var stageId: String?

            public var stageName: String?

            public var updateStatus: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.apiName != nil {
                    map["ApiName"] = self.apiName!
                }
                if self.apiUid != nil {
                    map["ApiUid"] = self.apiUid!
                }
                if self.errorMsg != nil {
                    map["ErrorMsg"] = self.errorMsg!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.stageId != nil {
                    map["StageId"] = self.stageId!
                }
                if self.stageName != nil {
                    map["StageName"] = self.stageName!
                }
                if self.updateStatus != nil {
                    map["UpdateStatus"] = self.updateStatus!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ApiName") && dict["ApiName"] != nil {
                    self.apiName = dict["ApiName"] as! String
                }
                if dict.keys.contains("ApiUid") && dict["ApiUid"] != nil {
                    self.apiUid = dict["ApiUid"] as! String
                }
                if dict.keys.contains("ErrorMsg") && dict["ErrorMsg"] != nil {
                    self.errorMsg = dict["ErrorMsg"] as! String
                }
                if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
                    self.groupName = dict["GroupName"] as! String
                }
                if dict.keys.contains("StageId") && dict["StageId"] != nil {
                    self.stageId = dict["StageId"] as! String
                }
                if dict.keys.contains("StageName") && dict["StageName"] != nil {
                    self.stageName = dict["StageName"] as! String
                }
                if dict.keys.contains("UpdateStatus") && dict["UpdateStatus"] != nil {
                    self.updateStatus = dict["UpdateStatus"] as! String
                }
            }
        }
        public var apiUpdateVpcInfoResult: [DescribeUpdateVpcInfoTaskResponseBody.ApiUpdateVpcInfoResults.ApiUpdateVpcInfoResult]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apiUpdateVpcInfoResult != nil {
                var tmp : [Any] = []
                for k in self.apiUpdateVpcInfoResult! {
                    tmp.append(k.toMap())
                }
                map["ApiUpdateVpcInfoResult"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApiUpdateVpcInfoResult") && dict["ApiUpdateVpcInfoResult"] != nil {
                var tmp : [DescribeUpdateVpcInfoTaskResponseBody.ApiUpdateVpcInfoResults.ApiUpdateVpcInfoResult] = []
                for v in dict["ApiUpdateVpcInfoResult"] as! [Any] {
                    var model = DescribeUpdateVpcInfoTaskResponseBody.ApiUpdateVpcInfoResults.ApiUpdateVpcInfoResult()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.apiUpdateVpcInfoResult = tmp
            }
        }
    }
    public var apiUpdateVpcInfoResults: DescribeUpdateVpcInfoTaskResponseBody.ApiUpdateVpcInfoResults?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.apiUpdateVpcInfoResults?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiUpdateVpcInfoResults != nil {
            map["ApiUpdateVpcInfoResults"] = self.apiUpdateVpcInfoResults?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiUpdateVpcInfoResults") && dict["ApiUpdateVpcInfoResults"] != nil {
            var model = DescribeUpdateVpcInfoTaskResponseBody.ApiUpdateVpcInfoResults()
            model.fromMap(dict["ApiUpdateVpcInfoResults"] as! [String: Any])
            self.apiUpdateVpcInfoResults = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeUpdateVpcInfoTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeUpdateVpcInfoTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeUpdateVpcInfoTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVpcAccessesRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var accurateQuery: Bool?

    public var instanceId: String?

    public var name: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var port: String?

    public var securityToken: String?

    public var tag: [DescribeVpcAccessesRequest.Tag]?

    public var vpcAccessId: String?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accurateQuery != nil {
            map["AccurateQuery"] = self.accurateQuery!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.port != nil {
            map["Port"] = self.port!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.vpcAccessId != nil {
            map["VpcAccessId"] = self.vpcAccessId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccurateQuery") && dict["AccurateQuery"] != nil {
            self.accurateQuery = dict["AccurateQuery"] as! Bool
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Port") && dict["Port"] != nil {
            self.port = dict["Port"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("Tag") && dict["Tag"] != nil {
            var tmp : [DescribeVpcAccessesRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = DescribeVpcAccessesRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("VpcAccessId") && dict["VpcAccessId"] != nil {
            self.vpcAccessId = dict["VpcAccessId"] as! String
        }
        if dict.keys.contains("VpcId") && dict["VpcId"] != nil {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class DescribeVpcAccessesResponseBody : Tea.TeaModel {
    public class VpcAccessAttributes : Tea.TeaModel {
        public class VpcAccessAttribute : Tea.TeaModel {
            public class Tags : Tea.TeaModel {
                public class TagInfo : Tea.TeaModel {
                    public var key: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Key") && dict["Key"] != nil {
                            self.key = dict["Key"] as! String
                        }
                        if dict.keys.contains("Value") && dict["Value"] != nil {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var tagInfo: [DescribeVpcAccessesResponseBody.VpcAccessAttributes.VpcAccessAttribute.Tags.TagInfo]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tagInfo != nil {
                        var tmp : [Any] = []
                        for k in self.tagInfo! {
                            tmp.append(k.toMap())
                        }
                        map["TagInfo"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("TagInfo") && dict["TagInfo"] != nil {
                        var tmp : [DescribeVpcAccessesResponseBody.VpcAccessAttributes.VpcAccessAttribute.Tags.TagInfo] = []
                        for v in dict["TagInfo"] as! [Any] {
                            var model = DescribeVpcAccessesResponseBody.VpcAccessAttributes.VpcAccessAttribute.Tags.TagInfo()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.tagInfo = tmp
                    }
                }
            }
            public var createdTime: String?

            public var description_: String?

            public var instanceId: String?

            public var name: String?

            public var port: Int32?

            public var regionId: String?

            public var tags: DescribeVpcAccessesResponseBody.VpcAccessAttributes.VpcAccessAttribute.Tags?

            public var vpcAccessId: String?

            public var vpcId: String?

            public var vpcTargetHostName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createdTime != nil {
                    map["CreatedTime"] = self.createdTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                if self.vpcAccessId != nil {
                    map["VpcAccessId"] = self.vpcAccessId!
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                if self.vpcTargetHostName != nil {
                    map["VpcTargetHostName"] = self.vpcTargetHostName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreatedTime") && dict["CreatedTime"] != nil {
                    self.createdTime = dict["CreatedTime"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Port") && dict["Port"] != nil {
                    self.port = dict["Port"] as! Int32
                }
                if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("Tags") && dict["Tags"] != nil {
                    var model = DescribeVpcAccessesResponseBody.VpcAccessAttributes.VpcAccessAttribute.Tags()
                    model.fromMap(dict["Tags"] as! [String: Any])
                    self.tags = model
                }
                if dict.keys.contains("VpcAccessId") && dict["VpcAccessId"] != nil {
                    self.vpcAccessId = dict["VpcAccessId"] as! String
                }
                if dict.keys.contains("VpcId") && dict["VpcId"] != nil {
                    self.vpcId = dict["VpcId"] as! String
                }
                if dict.keys.contains("VpcTargetHostName") && dict["VpcTargetHostName"] != nil {
                    self.vpcTargetHostName = dict["VpcTargetHostName"] as! String
                }
            }
        }
        public var vpcAccessAttribute: [DescribeVpcAccessesResponseBody.VpcAccessAttributes.VpcAccessAttribute]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.vpcAccessAttribute != nil {
                var tmp : [Any] = []
                for k in self.vpcAccessAttribute! {
                    tmp.append(k.toMap())
                }
                map["VpcAccessAttribute"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("VpcAccessAttribute") && dict["VpcAccessAttribute"] != nil {
                var tmp : [DescribeVpcAccessesResponseBody.VpcAccessAttributes.VpcAccessAttribute] = []
                for v in dict["VpcAccessAttribute"] as! [Any] {
                    var model = DescribeVpcAccessesResponseBody.VpcAccessAttributes.VpcAccessAttribute()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.vpcAccessAttribute = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public var vpcAccessAttributes: DescribeVpcAccessesResponseBody.VpcAccessAttributes?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.vpcAccessAttributes?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.vpcAccessAttributes != nil {
            map["VpcAccessAttributes"] = self.vpcAccessAttributes?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
        if dict.keys.contains("VpcAccessAttributes") && dict["VpcAccessAttributes"] != nil {
            var model = DescribeVpcAccessesResponseBody.VpcAccessAttributes()
            model.fromMap(dict["VpcAccessAttributes"] as! [String: Any])
            self.vpcAccessAttributes = model
        }
    }
}

public class DescribeVpcAccessesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVpcAccessesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeVpcAccessesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeZonesRequest : Tea.TeaModel {
    public var language: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Language") && dict["Language"] != nil {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DescribeZonesResponseBody : Tea.TeaModel {
    public class Zones : Tea.TeaModel {
        public class Zone : Tea.TeaModel {
            public var localName: String?

            public var zoneId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.localName != nil {
                    map["LocalName"] = self.localName!
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("LocalName") && dict["LocalName"] != nil {
                    self.localName = dict["LocalName"] as! String
                }
                if dict.keys.contains("ZoneId") && dict["ZoneId"] != nil {
                    self.zoneId = dict["ZoneId"] as! String
                }
            }
        }
        public var zone: [DescribeZonesResponseBody.Zones.Zone]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.zone != nil {
                var tmp : [Any] = []
                for k in self.zone! {
                    tmp.append(k.toMap())
                }
                map["Zone"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Zone") && dict["Zone"] != nil {
                var tmp : [DescribeZonesResponseBody.Zones.Zone] = []
                for v in dict["Zone"] as! [Any] {
                    var model = DescribeZonesResponseBody.Zones.Zone()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.zone = tmp
            }
        }
    }
    public var requestId: String?

    public var zones: DescribeZonesResponseBody.Zones?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.zones?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.zones != nil {
            map["Zones"] = self.zones?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Zones") && dict["Zones"] != nil {
            var model = DescribeZonesResponseBody.Zones()
            model.fromMap(dict["Zones"] as! [String: Any])
            self.zones = model
        }
    }
}

public class DescribeZonesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeZonesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeZonesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DetachApiProductRequest : Tea.TeaModel {
    public class Apis : Tea.TeaModel {
        public var apiId: String?

        public var stageName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apiId != nil {
                map["ApiId"] = self.apiId!
            }
            if self.stageName != nil {
                map["StageName"] = self.stageName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApiId") && dict["ApiId"] != nil {
                self.apiId = dict["ApiId"] as! String
            }
            if dict.keys.contains("StageName") && dict["StageName"] != nil {
                self.stageName = dict["StageName"] as! String
            }
        }
    }
    public var apiProductId: String?

    public var apis: [DetachApiProductRequest.Apis]?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiProductId != nil {
            map["ApiProductId"] = self.apiProductId!
        }
        if self.apis != nil {
            var tmp : [Any] = []
            for k in self.apis! {
                tmp.append(k.toMap())
            }
            map["Apis"] = tmp
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiProductId") && dict["ApiProductId"] != nil {
            self.apiProductId = dict["ApiProductId"] as! String
        }
        if dict.keys.contains("Apis") && dict["Apis"] != nil {
            var tmp : [DetachApiProductRequest.Apis] = []
            for v in dict["Apis"] as! [Any] {
                var model = DetachApiProductRequest.Apis()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.apis = tmp
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DetachApiProductResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DetachApiProductResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DetachApiProductResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DetachApiProductResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DetachPluginRequest : Tea.TeaModel {
    public var apiId: String?

    public var groupId: String?

    public var pluginId: String?

    public var securityToken: String?

    public var stageName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.pluginId != nil {
            map["PluginId"] = self.pluginId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.stageName != nil {
            map["StageName"] = self.stageName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiId") && dict["ApiId"] != nil {
            self.apiId = dict["ApiId"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("PluginId") && dict["PluginId"] != nil {
            self.pluginId = dict["PluginId"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StageName") && dict["StageName"] != nil {
            self.stageName = dict["StageName"] as! String
        }
    }
}

public class DetachPluginResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DetachPluginResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DetachPluginResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DetachPluginResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DisableInstanceAccessControlRequest : Tea.TeaModel {
    public var aclId: String?

    public var addressIPVersion: String?

    public var instanceId: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aclId != nil {
            map["AclId"] = self.aclId!
        }
        if self.addressIPVersion != nil {
            map["AddressIPVersion"] = self.addressIPVersion!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AclId") && dict["AclId"] != nil {
            self.aclId = dict["AclId"] as! String
        }
        if dict.keys.contains("AddressIPVersion") && dict["AddressIPVersion"] != nil {
            self.addressIPVersion = dict["AddressIPVersion"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DisableInstanceAccessControlResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DisableInstanceAccessControlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DisableInstanceAccessControlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DisableInstanceAccessControlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DryRunSwaggerRequest : Tea.TeaModel {
    public var data: String?

    public var dataFormat: String?

    public var globalCondition: [String: Any]?

    public var groupId: String?

    public var overwrite: Bool?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.dataFormat != nil {
            map["DataFormat"] = self.dataFormat!
        }
        if self.globalCondition != nil {
            map["GlobalCondition"] = self.globalCondition!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.overwrite != nil {
            map["Overwrite"] = self.overwrite!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("DataFormat") && dict["DataFormat"] != nil {
            self.dataFormat = dict["DataFormat"] as! String
        }
        if dict.keys.contains("GlobalCondition") && dict["GlobalCondition"] != nil {
            self.globalCondition = dict["GlobalCondition"] as! [String: Any]
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("Overwrite") && dict["Overwrite"] != nil {
            self.overwrite = dict["Overwrite"] as! Bool
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DryRunSwaggerShrinkRequest : Tea.TeaModel {
    public var data: String?

    public var dataFormat: String?

    public var globalConditionShrink: String?

    public var groupId: String?

    public var overwrite: Bool?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.dataFormat != nil {
            map["DataFormat"] = self.dataFormat!
        }
        if self.globalConditionShrink != nil {
            map["GlobalCondition"] = self.globalConditionShrink!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.overwrite != nil {
            map["Overwrite"] = self.overwrite!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("DataFormat") && dict["DataFormat"] != nil {
            self.dataFormat = dict["DataFormat"] as! String
        }
        if dict.keys.contains("GlobalCondition") && dict["GlobalCondition"] != nil {
            self.globalConditionShrink = dict["GlobalCondition"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("Overwrite") && dict["Overwrite"] != nil {
            self.overwrite = dict["Overwrite"] as! Bool
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DryRunSwaggerResponseBody : Tea.TeaModel {
    public class Failed : Tea.TeaModel {
        public class ApiImportSwaggerFailed : Tea.TeaModel {
            public var errorMsg: String?

            public var httpMethod: String?

            public var path: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.errorMsg != nil {
                    map["ErrorMsg"] = self.errorMsg!
                }
                if self.httpMethod != nil {
                    map["HttpMethod"] = self.httpMethod!
                }
                if self.path != nil {
                    map["Path"] = self.path!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ErrorMsg") && dict["ErrorMsg"] != nil {
                    self.errorMsg = dict["ErrorMsg"] as! String
                }
                if dict.keys.contains("HttpMethod") && dict["HttpMethod"] != nil {
                    self.httpMethod = dict["HttpMethod"] as! String
                }
                if dict.keys.contains("Path") && dict["Path"] != nil {
                    self.path = dict["Path"] as! String
                }
            }
        }
        public var apiImportSwaggerFailed: [DryRunSwaggerResponseBody.Failed.ApiImportSwaggerFailed]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apiImportSwaggerFailed != nil {
                var tmp : [Any] = []
                for k in self.apiImportSwaggerFailed! {
                    tmp.append(k.toMap())
                }
                map["ApiImportSwaggerFailed"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApiImportSwaggerFailed") && dict["ApiImportSwaggerFailed"] != nil {
                var tmp : [DryRunSwaggerResponseBody.Failed.ApiImportSwaggerFailed] = []
                for v in dict["ApiImportSwaggerFailed"] as! [Any] {
                    var model = DryRunSwaggerResponseBody.Failed.ApiImportSwaggerFailed()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.apiImportSwaggerFailed = tmp
            }
        }
    }
    public class ModelFailed : Tea.TeaModel {
        public class ApiImportModelFailed : Tea.TeaModel {
            public var errorMsg: String?

            public var groupId: String?

            public var modelName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.errorMsg != nil {
                    map["ErrorMsg"] = self.errorMsg!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.modelName != nil {
                    map["ModelName"] = self.modelName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ErrorMsg") && dict["ErrorMsg"] != nil {
                    self.errorMsg = dict["ErrorMsg"] as! String
                }
                if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("ModelName") && dict["ModelName"] != nil {
                    self.modelName = dict["ModelName"] as! String
                }
            }
        }
        public var apiImportModelFailed: [DryRunSwaggerResponseBody.ModelFailed.ApiImportModelFailed]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apiImportModelFailed != nil {
                var tmp : [Any] = []
                for k in self.apiImportModelFailed! {
                    tmp.append(k.toMap())
                }
                map["ApiImportModelFailed"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApiImportModelFailed") && dict["ApiImportModelFailed"] != nil {
                var tmp : [DryRunSwaggerResponseBody.ModelFailed.ApiImportModelFailed] = []
                for v in dict["ApiImportModelFailed"] as! [Any] {
                    var model = DryRunSwaggerResponseBody.ModelFailed.ApiImportModelFailed()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.apiImportModelFailed = tmp
            }
        }
    }
    public class ModelSuccess : Tea.TeaModel {
        public class ApiImportModelSuccess : Tea.TeaModel {
            public var groupId: String?

            public var modelName: String?

            public var modelOperation: String?

            public var modelUid: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.modelName != nil {
                    map["ModelName"] = self.modelName!
                }
                if self.modelOperation != nil {
                    map["ModelOperation"] = self.modelOperation!
                }
                if self.modelUid != nil {
                    map["ModelUid"] = self.modelUid!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("ModelName") && dict["ModelName"] != nil {
                    self.modelName = dict["ModelName"] as! String
                }
                if dict.keys.contains("ModelOperation") && dict["ModelOperation"] != nil {
                    self.modelOperation = dict["ModelOperation"] as! String
                }
                if dict.keys.contains("ModelUid") && dict["ModelUid"] != nil {
                    self.modelUid = dict["ModelUid"] as! String
                }
            }
        }
        public var apiImportModelSuccess: [DryRunSwaggerResponseBody.ModelSuccess.ApiImportModelSuccess]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apiImportModelSuccess != nil {
                var tmp : [Any] = []
                for k in self.apiImportModelSuccess! {
                    tmp.append(k.toMap())
                }
                map["ApiImportModelSuccess"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApiImportModelSuccess") && dict["ApiImportModelSuccess"] != nil {
                var tmp : [DryRunSwaggerResponseBody.ModelSuccess.ApiImportModelSuccess] = []
                for v in dict["ApiImportModelSuccess"] as! [Any] {
                    var model = DryRunSwaggerResponseBody.ModelSuccess.ApiImportModelSuccess()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.apiImportModelSuccess = tmp
            }
        }
    }
    public class Success : Tea.TeaModel {
        public class ApiDryRunSwaggerSuccess : Tea.TeaModel {
            public var apiOperation: String?

            public var apiSwagger: String?

            public var apiUid: String?

            public var httpMethod: String?

            public var path: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.apiOperation != nil {
                    map["ApiOperation"] = self.apiOperation!
                }
                if self.apiSwagger != nil {
                    map["ApiSwagger"] = self.apiSwagger!
                }
                if self.apiUid != nil {
                    map["ApiUid"] = self.apiUid!
                }
                if self.httpMethod != nil {
                    map["HttpMethod"] = self.httpMethod!
                }
                if self.path != nil {
                    map["Path"] = self.path!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ApiOperation") && dict["ApiOperation"] != nil {
                    self.apiOperation = dict["ApiOperation"] as! String
                }
                if dict.keys.contains("ApiSwagger") && dict["ApiSwagger"] != nil {
                    self.apiSwagger = dict["ApiSwagger"] as! String
                }
                if dict.keys.contains("ApiUid") && dict["ApiUid"] != nil {
                    self.apiUid = dict["ApiUid"] as! String
                }
                if dict.keys.contains("HttpMethod") && dict["HttpMethod"] != nil {
                    self.httpMethod = dict["HttpMethod"] as! String
                }
                if dict.keys.contains("Path") && dict["Path"] != nil {
                    self.path = dict["Path"] as! String
                }
            }
        }
        public var apiDryRunSwaggerSuccess: [DryRunSwaggerResponseBody.Success.ApiDryRunSwaggerSuccess]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apiDryRunSwaggerSuccess != nil {
                var tmp : [Any] = []
                for k in self.apiDryRunSwaggerSuccess! {
                    tmp.append(k.toMap())
                }
                map["ApiDryRunSwaggerSuccess"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApiDryRunSwaggerSuccess") && dict["ApiDryRunSwaggerSuccess"] != nil {
                var tmp : [DryRunSwaggerResponseBody.Success.ApiDryRunSwaggerSuccess] = []
                for v in dict["ApiDryRunSwaggerSuccess"] as! [Any] {
                    var model = DryRunSwaggerResponseBody.Success.ApiDryRunSwaggerSuccess()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.apiDryRunSwaggerSuccess = tmp
            }
        }
    }
    public var failed: DryRunSwaggerResponseBody.Failed?

    public var globalCondition: String?

    public var modelFailed: DryRunSwaggerResponseBody.ModelFailed?

    public var modelSuccess: DryRunSwaggerResponseBody.ModelSuccess?

    public var requestId: String?

    public var success: DryRunSwaggerResponseBody.Success?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.failed?.validate()
        try self.modelFailed?.validate()
        try self.modelSuccess?.validate()
        try self.success?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.failed != nil {
            map["Failed"] = self.failed?.toMap()
        }
        if self.globalCondition != nil {
            map["GlobalCondition"] = self.globalCondition!
        }
        if self.modelFailed != nil {
            map["ModelFailed"] = self.modelFailed?.toMap()
        }
        if self.modelSuccess != nil {
            map["ModelSuccess"] = self.modelSuccess?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Failed") && dict["Failed"] != nil {
            var model = DryRunSwaggerResponseBody.Failed()
            model.fromMap(dict["Failed"] as! [String: Any])
            self.failed = model
        }
        if dict.keys.contains("GlobalCondition") && dict["GlobalCondition"] != nil {
            self.globalCondition = dict["GlobalCondition"] as! String
        }
        if dict.keys.contains("ModelFailed") && dict["ModelFailed"] != nil {
            var model = DryRunSwaggerResponseBody.ModelFailed()
            model.fromMap(dict["ModelFailed"] as! [String: Any])
            self.modelFailed = model
        }
        if dict.keys.contains("ModelSuccess") && dict["ModelSuccess"] != nil {
            var model = DryRunSwaggerResponseBody.ModelSuccess()
            model.fromMap(dict["ModelSuccess"] as! [String: Any])
            self.modelSuccess = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            var model = DryRunSwaggerResponseBody.Success()
            model.fromMap(dict["Success"] as! [String: Any])
            self.success = model
        }
    }
}

public class DryRunSwaggerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DryRunSwaggerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DryRunSwaggerResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class EnableInstanceAccessControlRequest : Tea.TeaModel {
    public var aclId: String?

    public var aclType: String?

    public var addressIPVersion: String?

    public var instanceId: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aclId != nil {
            map["AclId"] = self.aclId!
        }
        if self.aclType != nil {
            map["AclType"] = self.aclType!
        }
        if self.addressIPVersion != nil {
            map["AddressIPVersion"] = self.addressIPVersion!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AclId") && dict["AclId"] != nil {
            self.aclId = dict["AclId"] as! String
        }
        if dict.keys.contains("AclType") && dict["AclType"] != nil {
            self.aclType = dict["AclType"] as! String
        }
        if dict.keys.contains("AddressIPVersion") && dict["AddressIPVersion"] != nil {
            self.addressIPVersion = dict["AddressIPVersion"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class EnableInstanceAccessControlResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class EnableInstanceAccessControlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EnableInstanceAccessControlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = EnableInstanceAccessControlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ImportOASRequest : Tea.TeaModel {
    public var authType: String?

    public var backendName: String?

    public var data: String?

    public var groupId: String?

    public var ignoreWarning: Bool?

    public var OASVersion: String?

    public var overwrite: Bool?

    public var requestMode: String?

    public var securityToken: String?

    public var skipDryRun: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.authType != nil {
            map["AuthType"] = self.authType!
        }
        if self.backendName != nil {
            map["BackendName"] = self.backendName!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.ignoreWarning != nil {
            map["IgnoreWarning"] = self.ignoreWarning!
        }
        if self.OASVersion != nil {
            map["OASVersion"] = self.OASVersion!
        }
        if self.overwrite != nil {
            map["Overwrite"] = self.overwrite!
        }
        if self.requestMode != nil {
            map["RequestMode"] = self.requestMode!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.skipDryRun != nil {
            map["SkipDryRun"] = self.skipDryRun!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AuthType") && dict["AuthType"] != nil {
            self.authType = dict["AuthType"] as! String
        }
        if dict.keys.contains("BackendName") && dict["BackendName"] != nil {
            self.backendName = dict["BackendName"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("IgnoreWarning") && dict["IgnoreWarning"] != nil {
            self.ignoreWarning = dict["IgnoreWarning"] as! Bool
        }
        if dict.keys.contains("OASVersion") && dict["OASVersion"] != nil {
            self.OASVersion = dict["OASVersion"] as! String
        }
        if dict.keys.contains("Overwrite") && dict["Overwrite"] != nil {
            self.overwrite = dict["Overwrite"] as! Bool
        }
        if dict.keys.contains("RequestMode") && dict["RequestMode"] != nil {
            self.requestMode = dict["RequestMode"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("SkipDryRun") && dict["SkipDryRun"] != nil {
            self.skipDryRun = dict["SkipDryRun"] as! Bool
        }
    }
}

public class ImportOASResponseBody : Tea.TeaModel {
    public class ErrorMessages : Tea.TeaModel {
        public var errorMessage: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.errorMessage != nil {
                map["ErrorMessage"] = self.errorMessage!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
                self.errorMessage = dict["ErrorMessage"] as! [String]
            }
        }
    }
    public class FailedApis : Tea.TeaModel {
        public class FailedApi : Tea.TeaModel {
            public var errorMsg: String?

            public var httpMethod: String?

            public var path: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.errorMsg != nil {
                    map["ErrorMsg"] = self.errorMsg!
                }
                if self.httpMethod != nil {
                    map["HttpMethod"] = self.httpMethod!
                }
                if self.path != nil {
                    map["Path"] = self.path!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ErrorMsg") && dict["ErrorMsg"] != nil {
                    self.errorMsg = dict["ErrorMsg"] as! String
                }
                if dict.keys.contains("HttpMethod") && dict["HttpMethod"] != nil {
                    self.httpMethod = dict["HttpMethod"] as! String
                }
                if dict.keys.contains("Path") && dict["Path"] != nil {
                    self.path = dict["Path"] as! String
                }
            }
        }
        public var failedApi: [ImportOASResponseBody.FailedApis.FailedApi]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.failedApi != nil {
                var tmp : [Any] = []
                for k in self.failedApi! {
                    tmp.append(k.toMap())
                }
                map["FailedApi"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FailedApi") && dict["FailedApi"] != nil {
                var tmp : [ImportOASResponseBody.FailedApis.FailedApi] = []
                for v in dict["FailedApi"] as! [Any] {
                    var model = ImportOASResponseBody.FailedApis.FailedApi()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.failedApi = tmp
            }
        }
    }
    public class FailedModels : Tea.TeaModel {
        public class FailedModel : Tea.TeaModel {
            public var errorMsg: String?

            public var groupId: String?

            public var modelName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.errorMsg != nil {
                    map["ErrorMsg"] = self.errorMsg!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.modelName != nil {
                    map["ModelName"] = self.modelName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ErrorMsg") && dict["ErrorMsg"] != nil {
                    self.errorMsg = dict["ErrorMsg"] as! String
                }
                if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("ModelName") && dict["ModelName"] != nil {
                    self.modelName = dict["ModelName"] as! String
                }
            }
        }
        public var failedModel: [ImportOASResponseBody.FailedModels.FailedModel]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.failedModel != nil {
                var tmp : [Any] = []
                for k in self.failedModel! {
                    tmp.append(k.toMap())
                }
                map["FailedModel"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FailedModel") && dict["FailedModel"] != nil {
                var tmp : [ImportOASResponseBody.FailedModels.FailedModel] = []
                for v in dict["FailedModel"] as! [Any] {
                    var model = ImportOASResponseBody.FailedModels.FailedModel()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.failedModel = tmp
            }
        }
    }
    public class SuccessApis : Tea.TeaModel {
        public class SuccessApi : Tea.TeaModel {
            public var apiId: String?

            public var apiOperation: String?

            public var httpMethod: String?

            public var path: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.apiId != nil {
                    map["ApiId"] = self.apiId!
                }
                if self.apiOperation != nil {
                    map["ApiOperation"] = self.apiOperation!
                }
                if self.httpMethod != nil {
                    map["HttpMethod"] = self.httpMethod!
                }
                if self.path != nil {
                    map["Path"] = self.path!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ApiId") && dict["ApiId"] != nil {
                    self.apiId = dict["ApiId"] as! String
                }
                if dict.keys.contains("ApiOperation") && dict["ApiOperation"] != nil {
                    self.apiOperation = dict["ApiOperation"] as! String
                }
                if dict.keys.contains("HttpMethod") && dict["HttpMethod"] != nil {
                    self.httpMethod = dict["HttpMethod"] as! String
                }
                if dict.keys.contains("Path") && dict["Path"] != nil {
                    self.path = dict["Path"] as! String
                }
            }
        }
        public var successApi: [ImportOASResponseBody.SuccessApis.SuccessApi]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.successApi != nil {
                var tmp : [Any] = []
                for k in self.successApi! {
                    tmp.append(k.toMap())
                }
                map["SuccessApi"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SuccessApi") && dict["SuccessApi"] != nil {
                var tmp : [ImportOASResponseBody.SuccessApis.SuccessApi] = []
                for v in dict["SuccessApi"] as! [Any] {
                    var model = ImportOASResponseBody.SuccessApis.SuccessApi()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.successApi = tmp
            }
        }
    }
    public class SuccessModels : Tea.TeaModel {
        public class SuccessModel : Tea.TeaModel {
            public var groupId: String?

            public var modelName: String?

            public var modelOperation: String?

            public var modelUid: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.modelName != nil {
                    map["ModelName"] = self.modelName!
                }
                if self.modelOperation != nil {
                    map["ModelOperation"] = self.modelOperation!
                }
                if self.modelUid != nil {
                    map["ModelUid"] = self.modelUid!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("ModelName") && dict["ModelName"] != nil {
                    self.modelName = dict["ModelName"] as! String
                }
                if dict.keys.contains("ModelOperation") && dict["ModelOperation"] != nil {
                    self.modelOperation = dict["ModelOperation"] as! String
                }
                if dict.keys.contains("ModelUid") && dict["ModelUid"] != nil {
                    self.modelUid = dict["ModelUid"] as! String
                }
            }
        }
        public var successModel: [ImportOASResponseBody.SuccessModels.SuccessModel]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.successModel != nil {
                var tmp : [Any] = []
                for k in self.successModel! {
                    tmp.append(k.toMap())
                }
                map["SuccessModel"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SuccessModel") && dict["SuccessModel"] != nil {
                var tmp : [ImportOASResponseBody.SuccessModels.SuccessModel] = []
                for v in dict["SuccessModel"] as! [Any] {
                    var model = ImportOASResponseBody.SuccessModels.SuccessModel()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.successModel = tmp
            }
        }
    }
    public class WarningMessages : Tea.TeaModel {
        public var warningMessage: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.warningMessage != nil {
                map["WarningMessage"] = self.warningMessage!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("WarningMessage") && dict["WarningMessage"] != nil {
                self.warningMessage = dict["WarningMessage"] as! [String]
            }
        }
    }
    public var errorMessages: ImportOASResponseBody.ErrorMessages?

    public var failedApis: ImportOASResponseBody.FailedApis?

    public var failedModels: ImportOASResponseBody.FailedModels?

    public var operationId: String?

    public var requestId: String?

    public var successApis: ImportOASResponseBody.SuccessApis?

    public var successModels: ImportOASResponseBody.SuccessModels?

    public var warningMessages: ImportOASResponseBody.WarningMessages?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.errorMessages?.validate()
        try self.failedApis?.validate()
        try self.failedModels?.validate()
        try self.successApis?.validate()
        try self.successModels?.validate()
        try self.warningMessages?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorMessages != nil {
            map["ErrorMessages"] = self.errorMessages?.toMap()
        }
        if self.failedApis != nil {
            map["FailedApis"] = self.failedApis?.toMap()
        }
        if self.failedModels != nil {
            map["FailedModels"] = self.failedModels?.toMap()
        }
        if self.operationId != nil {
            map["OperationId"] = self.operationId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.successApis != nil {
            map["SuccessApis"] = self.successApis?.toMap()
        }
        if self.successModels != nil {
            map["SuccessModels"] = self.successModels?.toMap()
        }
        if self.warningMessages != nil {
            map["WarningMessages"] = self.warningMessages?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorMessages") && dict["ErrorMessages"] != nil {
            var model = ImportOASResponseBody.ErrorMessages()
            model.fromMap(dict["ErrorMessages"] as! [String: Any])
            self.errorMessages = model
        }
        if dict.keys.contains("FailedApis") && dict["FailedApis"] != nil {
            var model = ImportOASResponseBody.FailedApis()
            model.fromMap(dict["FailedApis"] as! [String: Any])
            self.failedApis = model
        }
        if dict.keys.contains("FailedModels") && dict["FailedModels"] != nil {
            var model = ImportOASResponseBody.FailedModels()
            model.fromMap(dict["FailedModels"] as! [String: Any])
            self.failedModels = model
        }
        if dict.keys.contains("OperationId") && dict["OperationId"] != nil {
            self.operationId = dict["OperationId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SuccessApis") && dict["SuccessApis"] != nil {
            var model = ImportOASResponseBody.SuccessApis()
            model.fromMap(dict["SuccessApis"] as! [String: Any])
            self.successApis = model
        }
        if dict.keys.contains("SuccessModels") && dict["SuccessModels"] != nil {
            var model = ImportOASResponseBody.SuccessModels()
            model.fromMap(dict["SuccessModels"] as! [String: Any])
            self.successModels = model
        }
        if dict.keys.contains("WarningMessages") && dict["WarningMessages"] != nil {
            var model = ImportOASResponseBody.WarningMessages()
            model.fromMap(dict["WarningMessages"] as! [String: Any])
            self.warningMessages = model
        }
    }
}

public class ImportOASResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ImportOASResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ImportOASResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ImportSwaggerRequest : Tea.TeaModel {
    public var data: String?

    public var dataFormat: String?

    public var dryRun: Bool?

    public var globalCondition: [String: Any]?

    public var groupId: String?

    public var overwrite: Bool?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.dataFormat != nil {
            map["DataFormat"] = self.dataFormat!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.globalCondition != nil {
            map["GlobalCondition"] = self.globalCondition!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.overwrite != nil {
            map["Overwrite"] = self.overwrite!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("DataFormat") && dict["DataFormat"] != nil {
            self.dataFormat = dict["DataFormat"] as! String
        }
        if dict.keys.contains("DryRun") && dict["DryRun"] != nil {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("GlobalCondition") && dict["GlobalCondition"] != nil {
            self.globalCondition = dict["GlobalCondition"] as! [String: Any]
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("Overwrite") && dict["Overwrite"] != nil {
            self.overwrite = dict["Overwrite"] as! Bool
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class ImportSwaggerShrinkRequest : Tea.TeaModel {
    public var data: String?

    public var dataFormat: String?

    public var dryRun: Bool?

    public var globalConditionShrink: String?

    public var groupId: String?

    public var overwrite: Bool?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.dataFormat != nil {
            map["DataFormat"] = self.dataFormat!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.globalConditionShrink != nil {
            map["GlobalCondition"] = self.globalConditionShrink!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.overwrite != nil {
            map["Overwrite"] = self.overwrite!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("DataFormat") && dict["DataFormat"] != nil {
            self.dataFormat = dict["DataFormat"] as! String
        }
        if dict.keys.contains("DryRun") && dict["DryRun"] != nil {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("GlobalCondition") && dict["GlobalCondition"] != nil {
            self.globalConditionShrink = dict["GlobalCondition"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("Overwrite") && dict["Overwrite"] != nil {
            self.overwrite = dict["Overwrite"] as! Bool
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class ImportSwaggerResponseBody : Tea.TeaModel {
    public class Failed : Tea.TeaModel {
        public class ApiImportSwaggerFailed : Tea.TeaModel {
            public var errorMsg: String?

            public var httpMethod: String?

            public var path: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.errorMsg != nil {
                    map["ErrorMsg"] = self.errorMsg!
                }
                if self.httpMethod != nil {
                    map["HttpMethod"] = self.httpMethod!
                }
                if self.path != nil {
                    map["Path"] = self.path!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ErrorMsg") && dict["ErrorMsg"] != nil {
                    self.errorMsg = dict["ErrorMsg"] as! String
                }
                if dict.keys.contains("HttpMethod") && dict["HttpMethod"] != nil {
                    self.httpMethod = dict["HttpMethod"] as! String
                }
                if dict.keys.contains("Path") && dict["Path"] != nil {
                    self.path = dict["Path"] as! String
                }
            }
        }
        public var apiImportSwaggerFailed: [ImportSwaggerResponseBody.Failed.ApiImportSwaggerFailed]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apiImportSwaggerFailed != nil {
                var tmp : [Any] = []
                for k in self.apiImportSwaggerFailed! {
                    tmp.append(k.toMap())
                }
                map["ApiImportSwaggerFailed"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApiImportSwaggerFailed") && dict["ApiImportSwaggerFailed"] != nil {
                var tmp : [ImportSwaggerResponseBody.Failed.ApiImportSwaggerFailed] = []
                for v in dict["ApiImportSwaggerFailed"] as! [Any] {
                    var model = ImportSwaggerResponseBody.Failed.ApiImportSwaggerFailed()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.apiImportSwaggerFailed = tmp
            }
        }
    }
    public class ModelFailed : Tea.TeaModel {
        public class ApiImportModelFailed : Tea.TeaModel {
            public var errorMsg: String?

            public var groupId: String?

            public var modelName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.errorMsg != nil {
                    map["ErrorMsg"] = self.errorMsg!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.modelName != nil {
                    map["ModelName"] = self.modelName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ErrorMsg") && dict["ErrorMsg"] != nil {
                    self.errorMsg = dict["ErrorMsg"] as! String
                }
                if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("ModelName") && dict["ModelName"] != nil {
                    self.modelName = dict["ModelName"] as! String
                }
            }
        }
        public var apiImportModelFailed: [ImportSwaggerResponseBody.ModelFailed.ApiImportModelFailed]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apiImportModelFailed != nil {
                var tmp : [Any] = []
                for k in self.apiImportModelFailed! {
                    tmp.append(k.toMap())
                }
                map["ApiImportModelFailed"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApiImportModelFailed") && dict["ApiImportModelFailed"] != nil {
                var tmp : [ImportSwaggerResponseBody.ModelFailed.ApiImportModelFailed] = []
                for v in dict["ApiImportModelFailed"] as! [Any] {
                    var model = ImportSwaggerResponseBody.ModelFailed.ApiImportModelFailed()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.apiImportModelFailed = tmp
            }
        }
    }
    public class ModelSuccess : Tea.TeaModel {
        public class ApiImportModelSuccess : Tea.TeaModel {
            public var groupId: String?

            public var modelName: String?

            public var modelOperation: String?

            public var modelUid: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.modelName != nil {
                    map["ModelName"] = self.modelName!
                }
                if self.modelOperation != nil {
                    map["ModelOperation"] = self.modelOperation!
                }
                if self.modelUid != nil {
                    map["ModelUid"] = self.modelUid!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("ModelName") && dict["ModelName"] != nil {
                    self.modelName = dict["ModelName"] as! String
                }
                if dict.keys.contains("ModelOperation") && dict["ModelOperation"] != nil {
                    self.modelOperation = dict["ModelOperation"] as! String
                }
                if dict.keys.contains("ModelUid") && dict["ModelUid"] != nil {
                    self.modelUid = dict["ModelUid"] as! String
                }
            }
        }
        public var apiImportModelSuccess: [ImportSwaggerResponseBody.ModelSuccess.ApiImportModelSuccess]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apiImportModelSuccess != nil {
                var tmp : [Any] = []
                for k in self.apiImportModelSuccess! {
                    tmp.append(k.toMap())
                }
                map["ApiImportModelSuccess"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApiImportModelSuccess") && dict["ApiImportModelSuccess"] != nil {
                var tmp : [ImportSwaggerResponseBody.ModelSuccess.ApiImportModelSuccess] = []
                for v in dict["ApiImportModelSuccess"] as! [Any] {
                    var model = ImportSwaggerResponseBody.ModelSuccess.ApiImportModelSuccess()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.apiImportModelSuccess = tmp
            }
        }
    }
    public class Success : Tea.TeaModel {
        public class ApiImportSwaggerSuccess : Tea.TeaModel {
            public var apiOperation: String?

            public var apiUid: String?

            public var httpMethod: String?

            public var path: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.apiOperation != nil {
                    map["ApiOperation"] = self.apiOperation!
                }
                if self.apiUid != nil {
                    map["ApiUid"] = self.apiUid!
                }
                if self.httpMethod != nil {
                    map["HttpMethod"] = self.httpMethod!
                }
                if self.path != nil {
                    map["Path"] = self.path!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ApiOperation") && dict["ApiOperation"] != nil {
                    self.apiOperation = dict["ApiOperation"] as! String
                }
                if dict.keys.contains("ApiUid") && dict["ApiUid"] != nil {
                    self.apiUid = dict["ApiUid"] as! String
                }
                if dict.keys.contains("HttpMethod") && dict["HttpMethod"] != nil {
                    self.httpMethod = dict["HttpMethod"] as! String
                }
                if dict.keys.contains("Path") && dict["Path"] != nil {
                    self.path = dict["Path"] as! String
                }
            }
        }
        public var apiImportSwaggerSuccess: [ImportSwaggerResponseBody.Success.ApiImportSwaggerSuccess]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apiImportSwaggerSuccess != nil {
                var tmp : [Any] = []
                for k in self.apiImportSwaggerSuccess! {
                    tmp.append(k.toMap())
                }
                map["ApiImportSwaggerSuccess"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApiImportSwaggerSuccess") && dict["ApiImportSwaggerSuccess"] != nil {
                var tmp : [ImportSwaggerResponseBody.Success.ApiImportSwaggerSuccess] = []
                for v in dict["ApiImportSwaggerSuccess"] as! [Any] {
                    var model = ImportSwaggerResponseBody.Success.ApiImportSwaggerSuccess()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.apiImportSwaggerSuccess = tmp
            }
        }
    }
    public var failed: ImportSwaggerResponseBody.Failed?

    public var modelFailed: ImportSwaggerResponseBody.ModelFailed?

    public var modelSuccess: ImportSwaggerResponseBody.ModelSuccess?

    public var requestId: String?

    public var success: ImportSwaggerResponseBody.Success?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.failed?.validate()
        try self.modelFailed?.validate()
        try self.modelSuccess?.validate()
        try self.success?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.failed != nil {
            map["Failed"] = self.failed?.toMap()
        }
        if self.modelFailed != nil {
            map["ModelFailed"] = self.modelFailed?.toMap()
        }
        if self.modelSuccess != nil {
            map["ModelSuccess"] = self.modelSuccess?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Failed") && dict["Failed"] != nil {
            var model = ImportSwaggerResponseBody.Failed()
            model.fromMap(dict["Failed"] as! [String: Any])
            self.failed = model
        }
        if dict.keys.contains("ModelFailed") && dict["ModelFailed"] != nil {
            var model = ImportSwaggerResponseBody.ModelFailed()
            model.fromMap(dict["ModelFailed"] as! [String: Any])
            self.modelFailed = model
        }
        if dict.keys.contains("ModelSuccess") && dict["ModelSuccess"] != nil {
            var model = ImportSwaggerResponseBody.ModelSuccess()
            model.fromMap(dict["ModelSuccess"] as! [String: Any])
            self.modelSuccess = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            var model = ImportSwaggerResponseBody.Success()
            model.fromMap(dict["Success"] as! [String: Any])
            self.success = model
        }
    }
}

public class ImportSwaggerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ImportSwaggerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ImportSwaggerResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListTagResourcesRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var nextToken: String?

    public var resourceId: [String]?

    public var resourceType: String?

    public var tag: [ListTagResourcesRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NextToken") && dict["NextToken"] != nil {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("ResourceId") && dict["ResourceId"] != nil {
            self.resourceId = dict["ResourceId"] as! [String]
        }
        if dict.keys.contains("ResourceType") && dict["ResourceType"] != nil {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("Tag") && dict["Tag"] != nil {
            var tmp : [ListTagResourcesRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = ListTagResourcesRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class ListTagResourcesResponseBody : Tea.TeaModel {
    public class TagResources : Tea.TeaModel {
        public class TagResource : Tea.TeaModel {
            public var resourceId: String?

            public var resourceType: String?

            public var tagKey: String?

            public var tagValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.resourceId != nil {
                    map["ResourceId"] = self.resourceId!
                }
                if self.resourceType != nil {
                    map["ResourceType"] = self.resourceType!
                }
                if self.tagKey != nil {
                    map["TagKey"] = self.tagKey!
                }
                if self.tagValue != nil {
                    map["TagValue"] = self.tagValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ResourceId") && dict["ResourceId"] != nil {
                    self.resourceId = dict["ResourceId"] as! String
                }
                if dict.keys.contains("ResourceType") && dict["ResourceType"] != nil {
                    self.resourceType = dict["ResourceType"] as! String
                }
                if dict.keys.contains("TagKey") && dict["TagKey"] != nil {
                    self.tagKey = dict["TagKey"] as! String
                }
                if dict.keys.contains("TagValue") && dict["TagValue"] != nil {
                    self.tagValue = dict["TagValue"] as! String
                }
            }
        }
        public var tagResource: [ListTagResourcesResponseBody.TagResources.TagResource]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tagResource != nil {
                var tmp : [Any] = []
                for k in self.tagResource! {
                    tmp.append(k.toMap())
                }
                map["TagResource"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TagResource") && dict["TagResource"] != nil {
                var tmp : [ListTagResourcesResponseBody.TagResources.TagResource] = []
                for v in dict["TagResource"] as! [Any] {
                    var model = ListTagResourcesResponseBody.TagResources.TagResource()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tagResource = tmp
            }
        }
    }
    public var nextToken: String?

    public var requestId: String?

    public var tagResources: ListTagResourcesResponseBody.TagResources?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tagResources?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.tagResources != nil {
            map["TagResources"] = self.tagResources?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NextToken") && dict["NextToken"] != nil {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TagResources") && dict["TagResources"] != nil {
            var model = ListTagResourcesResponseBody.TagResources()
            model.fromMap(dict["TagResources"] as! [String: Any])
            self.tagResources = model
        }
    }
}

public class ListTagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListTagResourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyApiRequest : Tea.TeaModel {
    public var allowSignatureMethod: String?

    public var apiId: String?

    public var apiName: String?

    public var appCodeAuthType: String?

    public var authType: String?

    public var backendEnable: Bool?

    public var backendId: String?

    public var constantParameters: String?

    public var description_: String?

    public var disableInternet: Bool?

    public var errorCodeSamples: String?

    public var failResultSample: String?

    public var forceNonceCheck: Bool?

    public var groupId: String?

    public var openIdConnectConfig: String?

    public var requestConfig: String?

    public var requestParameters: String?

    public var resultBodyModel: String?

    public var resultDescriptions: String?

    public var resultSample: String?

    public var resultType: String?

    public var securityToken: String?

    public var serviceConfig: String?

    public var serviceParameters: String?

    public var serviceParametersMap: String?

    public var systemParameters: String?

    public var visibility: String?

    public var webSocketApiType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.allowSignatureMethod != nil {
            map["AllowSignatureMethod"] = self.allowSignatureMethod!
        }
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.apiName != nil {
            map["ApiName"] = self.apiName!
        }
        if self.appCodeAuthType != nil {
            map["AppCodeAuthType"] = self.appCodeAuthType!
        }
        if self.authType != nil {
            map["AuthType"] = self.authType!
        }
        if self.backendEnable != nil {
            map["BackendEnable"] = self.backendEnable!
        }
        if self.backendId != nil {
            map["BackendId"] = self.backendId!
        }
        if self.constantParameters != nil {
            map["ConstantParameters"] = self.constantParameters!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.disableInternet != nil {
            map["DisableInternet"] = self.disableInternet!
        }
        if self.errorCodeSamples != nil {
            map["ErrorCodeSamples"] = self.errorCodeSamples!
        }
        if self.failResultSample != nil {
            map["FailResultSample"] = self.failResultSample!
        }
        if self.forceNonceCheck != nil {
            map["ForceNonceCheck"] = self.forceNonceCheck!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.openIdConnectConfig != nil {
            map["OpenIdConnectConfig"] = self.openIdConnectConfig!
        }
        if self.requestConfig != nil {
            map["RequestConfig"] = self.requestConfig!
        }
        if self.requestParameters != nil {
            map["RequestParameters"] = self.requestParameters!
        }
        if self.resultBodyModel != nil {
            map["ResultBodyModel"] = self.resultBodyModel!
        }
        if self.resultDescriptions != nil {
            map["ResultDescriptions"] = self.resultDescriptions!
        }
        if self.resultSample != nil {
            map["ResultSample"] = self.resultSample!
        }
        if self.resultType != nil {
            map["ResultType"] = self.resultType!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.serviceConfig != nil {
            map["ServiceConfig"] = self.serviceConfig!
        }
        if self.serviceParameters != nil {
            map["ServiceParameters"] = self.serviceParameters!
        }
        if self.serviceParametersMap != nil {
            map["ServiceParametersMap"] = self.serviceParametersMap!
        }
        if self.systemParameters != nil {
            map["SystemParameters"] = self.systemParameters!
        }
        if self.visibility != nil {
            map["Visibility"] = self.visibility!
        }
        if self.webSocketApiType != nil {
            map["WebSocketApiType"] = self.webSocketApiType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AllowSignatureMethod") && dict["AllowSignatureMethod"] != nil {
            self.allowSignatureMethod = dict["AllowSignatureMethod"] as! String
        }
        if dict.keys.contains("ApiId") && dict["ApiId"] != nil {
            self.apiId = dict["ApiId"] as! String
        }
        if dict.keys.contains("ApiName") && dict["ApiName"] != nil {
            self.apiName = dict["ApiName"] as! String
        }
        if dict.keys.contains("AppCodeAuthType") && dict["AppCodeAuthType"] != nil {
            self.appCodeAuthType = dict["AppCodeAuthType"] as! String
        }
        if dict.keys.contains("AuthType") && dict["AuthType"] != nil {
            self.authType = dict["AuthType"] as! String
        }
        if dict.keys.contains("BackendEnable") && dict["BackendEnable"] != nil {
            self.backendEnable = dict["BackendEnable"] as! Bool
        }
        if dict.keys.contains("BackendId") && dict["BackendId"] != nil {
            self.backendId = dict["BackendId"] as! String
        }
        if dict.keys.contains("ConstantParameters") && dict["ConstantParameters"] != nil {
            self.constantParameters = dict["ConstantParameters"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DisableInternet") && dict["DisableInternet"] != nil {
            self.disableInternet = dict["DisableInternet"] as! Bool
        }
        if dict.keys.contains("ErrorCodeSamples") && dict["ErrorCodeSamples"] != nil {
            self.errorCodeSamples = dict["ErrorCodeSamples"] as! String
        }
        if dict.keys.contains("FailResultSample") && dict["FailResultSample"] != nil {
            self.failResultSample = dict["FailResultSample"] as! String
        }
        if dict.keys.contains("ForceNonceCheck") && dict["ForceNonceCheck"] != nil {
            self.forceNonceCheck = dict["ForceNonceCheck"] as! Bool
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("OpenIdConnectConfig") && dict["OpenIdConnectConfig"] != nil {
            self.openIdConnectConfig = dict["OpenIdConnectConfig"] as! String
        }
        if dict.keys.contains("RequestConfig") && dict["RequestConfig"] != nil {
            self.requestConfig = dict["RequestConfig"] as! String
        }
        if dict.keys.contains("RequestParameters") && dict["RequestParameters"] != nil {
            self.requestParameters = dict["RequestParameters"] as! String
        }
        if dict.keys.contains("ResultBodyModel") && dict["ResultBodyModel"] != nil {
            self.resultBodyModel = dict["ResultBodyModel"] as! String
        }
        if dict.keys.contains("ResultDescriptions") && dict["ResultDescriptions"] != nil {
            self.resultDescriptions = dict["ResultDescriptions"] as! String
        }
        if dict.keys.contains("ResultSample") && dict["ResultSample"] != nil {
            self.resultSample = dict["ResultSample"] as! String
        }
        if dict.keys.contains("ResultType") && dict["ResultType"] != nil {
            self.resultType = dict["ResultType"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("ServiceConfig") && dict["ServiceConfig"] != nil {
            self.serviceConfig = dict["ServiceConfig"] as! String
        }
        if dict.keys.contains("ServiceParameters") && dict["ServiceParameters"] != nil {
            self.serviceParameters = dict["ServiceParameters"] as! String
        }
        if dict.keys.contains("ServiceParametersMap") && dict["ServiceParametersMap"] != nil {
            self.serviceParametersMap = dict["ServiceParametersMap"] as! String
        }
        if dict.keys.contains("SystemParameters") && dict["SystemParameters"] != nil {
            self.systemParameters = dict["SystemParameters"] as! String
        }
        if dict.keys.contains("Visibility") && dict["Visibility"] != nil {
            self.visibility = dict["Visibility"] as! String
        }
        if dict.keys.contains("WebSocketApiType") && dict["WebSocketApiType"] != nil {
            self.webSocketApiType = dict["WebSocketApiType"] as! String
        }
    }
}

public class ModifyApiResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyApiResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyApiResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyApiResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyApiConfigurationRequest : Tea.TeaModel {
    public var allowSignatureMethod: String?

    public var apiId: String?

    public var apiName: String?

    public var appCodeAuthType: String?

    public var authType: String?

    public var backendName: String?

    public var bodyFormat: String?

    public var bodyModel: String?

    public var contentTypeCategory: String?

    public var contentTypeValue: String?

    public var description_: String?

    public var disableInternet: Bool?

    public var errorCodeSamples: String?

    public var failResultSample: String?

    public var forceNonceCheck: Bool?

    public var functionComputeConfig: String?

    public var httpConfig: String?

    public var mockConfig: String?

    public var modelName: String?

    public var ossConfig: String?

    public var postBodyDescription: String?

    public var requestHttpMethod: String?

    public var requestMode: String?

    public var requestParameters: String?

    public var requestPath: String?

    public var requestProtocol: String?

    public var resultSample: String?

    public var resultType: String?

    public var securityToken: String?

    public var serviceParameters: String?

    public var serviceParametersMap: String?

    public var serviceProtocol: String?

    public var serviceTimeout: Int32?

    public var useBackendService: Bool?

    public var visibility: String?

    public var vpcConfig: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.allowSignatureMethod != nil {
            map["AllowSignatureMethod"] = self.allowSignatureMethod!
        }
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.apiName != nil {
            map["ApiName"] = self.apiName!
        }
        if self.appCodeAuthType != nil {
            map["AppCodeAuthType"] = self.appCodeAuthType!
        }
        if self.authType != nil {
            map["AuthType"] = self.authType!
        }
        if self.backendName != nil {
            map["BackendName"] = self.backendName!
        }
        if self.bodyFormat != nil {
            map["BodyFormat"] = self.bodyFormat!
        }
        if self.bodyModel != nil {
            map["BodyModel"] = self.bodyModel!
        }
        if self.contentTypeCategory != nil {
            map["ContentTypeCategory"] = self.contentTypeCategory!
        }
        if self.contentTypeValue != nil {
            map["ContentTypeValue"] = self.contentTypeValue!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.disableInternet != nil {
            map["DisableInternet"] = self.disableInternet!
        }
        if self.errorCodeSamples != nil {
            map["ErrorCodeSamples"] = self.errorCodeSamples!
        }
        if self.failResultSample != nil {
            map["FailResultSample"] = self.failResultSample!
        }
        if self.forceNonceCheck != nil {
            map["ForceNonceCheck"] = self.forceNonceCheck!
        }
        if self.functionComputeConfig != nil {
            map["FunctionComputeConfig"] = self.functionComputeConfig!
        }
        if self.httpConfig != nil {
            map["HttpConfig"] = self.httpConfig!
        }
        if self.mockConfig != nil {
            map["MockConfig"] = self.mockConfig!
        }
        if self.modelName != nil {
            map["ModelName"] = self.modelName!
        }
        if self.ossConfig != nil {
            map["OssConfig"] = self.ossConfig!
        }
        if self.postBodyDescription != nil {
            map["PostBodyDescription"] = self.postBodyDescription!
        }
        if self.requestHttpMethod != nil {
            map["RequestHttpMethod"] = self.requestHttpMethod!
        }
        if self.requestMode != nil {
            map["RequestMode"] = self.requestMode!
        }
        if self.requestParameters != nil {
            map["RequestParameters"] = self.requestParameters!
        }
        if self.requestPath != nil {
            map["RequestPath"] = self.requestPath!
        }
        if self.requestProtocol != nil {
            map["RequestProtocol"] = self.requestProtocol!
        }
        if self.resultSample != nil {
            map["ResultSample"] = self.resultSample!
        }
        if self.resultType != nil {
            map["ResultType"] = self.resultType!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.serviceParameters != nil {
            map["ServiceParameters"] = self.serviceParameters!
        }
        if self.serviceParametersMap != nil {
            map["ServiceParametersMap"] = self.serviceParametersMap!
        }
        if self.serviceProtocol != nil {
            map["ServiceProtocol"] = self.serviceProtocol!
        }
        if self.serviceTimeout != nil {
            map["ServiceTimeout"] = self.serviceTimeout!
        }
        if self.useBackendService != nil {
            map["UseBackendService"] = self.useBackendService!
        }
        if self.visibility != nil {
            map["Visibility"] = self.visibility!
        }
        if self.vpcConfig != nil {
            map["VpcConfig"] = self.vpcConfig!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AllowSignatureMethod") && dict["AllowSignatureMethod"] != nil {
            self.allowSignatureMethod = dict["AllowSignatureMethod"] as! String
        }
        if dict.keys.contains("ApiId") && dict["ApiId"] != nil {
            self.apiId = dict["ApiId"] as! String
        }
        if dict.keys.contains("ApiName") && dict["ApiName"] != nil {
            self.apiName = dict["ApiName"] as! String
        }
        if dict.keys.contains("AppCodeAuthType") && dict["AppCodeAuthType"] != nil {
            self.appCodeAuthType = dict["AppCodeAuthType"] as! String
        }
        if dict.keys.contains("AuthType") && dict["AuthType"] != nil {
            self.authType = dict["AuthType"] as! String
        }
        if dict.keys.contains("BackendName") && dict["BackendName"] != nil {
            self.backendName = dict["BackendName"] as! String
        }
        if dict.keys.contains("BodyFormat") && dict["BodyFormat"] != nil {
            self.bodyFormat = dict["BodyFormat"] as! String
        }
        if dict.keys.contains("BodyModel") && dict["BodyModel"] != nil {
            self.bodyModel = dict["BodyModel"] as! String
        }
        if dict.keys.contains("ContentTypeCategory") && dict["ContentTypeCategory"] != nil {
            self.contentTypeCategory = dict["ContentTypeCategory"] as! String
        }
        if dict.keys.contains("ContentTypeValue") && dict["ContentTypeValue"] != nil {
            self.contentTypeValue = dict["ContentTypeValue"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DisableInternet") && dict["DisableInternet"] != nil {
            self.disableInternet = dict["DisableInternet"] as! Bool
        }
        if dict.keys.contains("ErrorCodeSamples") && dict["ErrorCodeSamples"] != nil {
            self.errorCodeSamples = dict["ErrorCodeSamples"] as! String
        }
        if dict.keys.contains("FailResultSample") && dict["FailResultSample"] != nil {
            self.failResultSample = dict["FailResultSample"] as! String
        }
        if dict.keys.contains("ForceNonceCheck") && dict["ForceNonceCheck"] != nil {
            self.forceNonceCheck = dict["ForceNonceCheck"] as! Bool
        }
        if dict.keys.contains("FunctionComputeConfig") && dict["FunctionComputeConfig"] != nil {
            self.functionComputeConfig = dict["FunctionComputeConfig"] as! String
        }
        if dict.keys.contains("HttpConfig") && dict["HttpConfig"] != nil {
            self.httpConfig = dict["HttpConfig"] as! String
        }
        if dict.keys.contains("MockConfig") && dict["MockConfig"] != nil {
            self.mockConfig = dict["MockConfig"] as! String
        }
        if dict.keys.contains("ModelName") && dict["ModelName"] != nil {
            self.modelName = dict["ModelName"] as! String
        }
        if dict.keys.contains("OssConfig") && dict["OssConfig"] != nil {
            self.ossConfig = dict["OssConfig"] as! String
        }
        if dict.keys.contains("PostBodyDescription") && dict["PostBodyDescription"] != nil {
            self.postBodyDescription = dict["PostBodyDescription"] as! String
        }
        if dict.keys.contains("RequestHttpMethod") && dict["RequestHttpMethod"] != nil {
            self.requestHttpMethod = dict["RequestHttpMethod"] as! String
        }
        if dict.keys.contains("RequestMode") && dict["RequestMode"] != nil {
            self.requestMode = dict["RequestMode"] as! String
        }
        if dict.keys.contains("RequestParameters") && dict["RequestParameters"] != nil {
            self.requestParameters = dict["RequestParameters"] as! String
        }
        if dict.keys.contains("RequestPath") && dict["RequestPath"] != nil {
            self.requestPath = dict["RequestPath"] as! String
        }
        if dict.keys.contains("RequestProtocol") && dict["RequestProtocol"] != nil {
            self.requestProtocol = dict["RequestProtocol"] as! String
        }
        if dict.keys.contains("ResultSample") && dict["ResultSample"] != nil {
            self.resultSample = dict["ResultSample"] as! String
        }
        if dict.keys.contains("ResultType") && dict["ResultType"] != nil {
            self.resultType = dict["ResultType"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("ServiceParameters") && dict["ServiceParameters"] != nil {
            self.serviceParameters = dict["ServiceParameters"] as! String
        }
        if dict.keys.contains("ServiceParametersMap") && dict["ServiceParametersMap"] != nil {
            self.serviceParametersMap = dict["ServiceParametersMap"] as! String
        }
        if dict.keys.contains("ServiceProtocol") && dict["ServiceProtocol"] != nil {
            self.serviceProtocol = dict["ServiceProtocol"] as! String
        }
        if dict.keys.contains("ServiceTimeout") && dict["ServiceTimeout"] != nil {
            self.serviceTimeout = dict["ServiceTimeout"] as! Int32
        }
        if dict.keys.contains("UseBackendService") && dict["UseBackendService"] != nil {
            self.useBackendService = dict["UseBackendService"] as! Bool
        }
        if dict.keys.contains("Visibility") && dict["Visibility"] != nil {
            self.visibility = dict["Visibility"] as! String
        }
        if dict.keys.contains("VpcConfig") && dict["VpcConfig"] != nil {
            self.vpcConfig = dict["VpcConfig"] as! String
        }
    }
}

public class ModifyApiConfigurationResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyApiConfigurationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyApiConfigurationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyApiConfigurationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyApiGroupRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var basePath: String?

    public var compatibleFlags: String?

    public var customTraceConfig: String?

    public var customerConfigs: String?

    public var defaultDomain: String?

    public var description_: String?

    public var groupId: String?

    public var groupName: String?

    public var passthroughHeaders: String?

    public var rpcPattern: String?

    public var securityToken: String?

    public var supportSSE: String?

    public var tag: [ModifyApiGroupRequest.Tag]?

    public var userLogConfig: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.basePath != nil {
            map["BasePath"] = self.basePath!
        }
        if self.compatibleFlags != nil {
            map["CompatibleFlags"] = self.compatibleFlags!
        }
        if self.customTraceConfig != nil {
            map["CustomTraceConfig"] = self.customTraceConfig!
        }
        if self.customerConfigs != nil {
            map["CustomerConfigs"] = self.customerConfigs!
        }
        if self.defaultDomain != nil {
            map["DefaultDomain"] = self.defaultDomain!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.passthroughHeaders != nil {
            map["PassthroughHeaders"] = self.passthroughHeaders!
        }
        if self.rpcPattern != nil {
            map["RpcPattern"] = self.rpcPattern!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.supportSSE != nil {
            map["SupportSSE"] = self.supportSSE!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.userLogConfig != nil {
            map["UserLogConfig"] = self.userLogConfig!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BasePath") && dict["BasePath"] != nil {
            self.basePath = dict["BasePath"] as! String
        }
        if dict.keys.contains("CompatibleFlags") && dict["CompatibleFlags"] != nil {
            self.compatibleFlags = dict["CompatibleFlags"] as! String
        }
        if dict.keys.contains("CustomTraceConfig") && dict["CustomTraceConfig"] != nil {
            self.customTraceConfig = dict["CustomTraceConfig"] as! String
        }
        if dict.keys.contains("CustomerConfigs") && dict["CustomerConfigs"] != nil {
            self.customerConfigs = dict["CustomerConfigs"] as! String
        }
        if dict.keys.contains("DefaultDomain") && dict["DefaultDomain"] != nil {
            self.defaultDomain = dict["DefaultDomain"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("PassthroughHeaders") && dict["PassthroughHeaders"] != nil {
            self.passthroughHeaders = dict["PassthroughHeaders"] as! String
        }
        if dict.keys.contains("RpcPattern") && dict["RpcPattern"] != nil {
            self.rpcPattern = dict["RpcPattern"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("SupportSSE") && dict["SupportSSE"] != nil {
            self.supportSSE = dict["SupportSSE"] as! String
        }
        if dict.keys.contains("Tag") && dict["Tag"] != nil {
            var tmp : [ModifyApiGroupRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = ModifyApiGroupRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("UserLogConfig") && dict["UserLogConfig"] != nil {
            self.userLogConfig = dict["UserLogConfig"] as! String
        }
    }
}

public class ModifyApiGroupResponseBody : Tea.TeaModel {
    public var basePath: String?

    public var description_: String?

    public var groupId: String?

    public var groupName: String?

    public var requestId: String?

    public var subDomain: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.basePath != nil {
            map["BasePath"] = self.basePath!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.subDomain != nil {
            map["SubDomain"] = self.subDomain!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BasePath") && dict["BasePath"] != nil {
            self.basePath = dict["BasePath"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SubDomain") && dict["SubDomain"] != nil {
            self.subDomain = dict["SubDomain"] as! String
        }
    }
}

public class ModifyApiGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyApiGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyApiGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyApiGroupInstanceRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var groupId: String?

    public var remark: String?

    public var securityToken: String?

    public var tag: [ModifyApiGroupInstanceRequest.Tag]?

    public var targetInstanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.targetInstanceId != nil {
            map["TargetInstanceId"] = self.targetInstanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("Remark") && dict["Remark"] != nil {
            self.remark = dict["Remark"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("Tag") && dict["Tag"] != nil {
            var tmp : [ModifyApiGroupInstanceRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = ModifyApiGroupInstanceRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("TargetInstanceId") && dict["TargetInstanceId"] != nil {
            self.targetInstanceId = dict["TargetInstanceId"] as! String
        }
    }
}

public class ModifyApiGroupInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyApiGroupInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyApiGroupInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyApiGroupInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyApiGroupNetworkPolicyRequest : Tea.TeaModel {
    public var groupId: String?

    public var httpsPolicy: String?

    public var innerDomainEnable: Bool?

    public var internetEnable: Bool?

    public var internetIPV6Enable: Bool?

    public var securityToken: String?

    public var vpcIntranetEnable: Bool?

    public var vpcSlbIntranetEnable: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.httpsPolicy != nil {
            map["HttpsPolicy"] = self.httpsPolicy!
        }
        if self.innerDomainEnable != nil {
            map["InnerDomainEnable"] = self.innerDomainEnable!
        }
        if self.internetEnable != nil {
            map["InternetEnable"] = self.internetEnable!
        }
        if self.internetIPV6Enable != nil {
            map["InternetIPV6Enable"] = self.internetIPV6Enable!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.vpcIntranetEnable != nil {
            map["VpcIntranetEnable"] = self.vpcIntranetEnable!
        }
        if self.vpcSlbIntranetEnable != nil {
            map["VpcSlbIntranetEnable"] = self.vpcSlbIntranetEnable!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("HttpsPolicy") && dict["HttpsPolicy"] != nil {
            self.httpsPolicy = dict["HttpsPolicy"] as! String
        }
        if dict.keys.contains("InnerDomainEnable") && dict["InnerDomainEnable"] != nil {
            self.innerDomainEnable = dict["InnerDomainEnable"] as! Bool
        }
        if dict.keys.contains("InternetEnable") && dict["InternetEnable"] != nil {
            self.internetEnable = dict["InternetEnable"] as! Bool
        }
        if dict.keys.contains("InternetIPV6Enable") && dict["InternetIPV6Enable"] != nil {
            self.internetIPV6Enable = dict["InternetIPV6Enable"] as! Bool
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("VpcIntranetEnable") && dict["VpcIntranetEnable"] != nil {
            self.vpcIntranetEnable = dict["VpcIntranetEnable"] as! Bool
        }
        if dict.keys.contains("VpcSlbIntranetEnable") && dict["VpcSlbIntranetEnable"] != nil {
            self.vpcSlbIntranetEnable = dict["VpcSlbIntranetEnable"] as! Bool
        }
    }
}

public class ModifyApiGroupNetworkPolicyResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyApiGroupNetworkPolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyApiGroupNetworkPolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyApiGroupNetworkPolicyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyApiGroupVpcWhitelistRequest : Tea.TeaModel {
    public var groupId: String?

    public var securityToken: String?

    public var vpcIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.vpcIds != nil {
            map["VpcIds"] = self.vpcIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("VpcIds") && dict["VpcIds"] != nil {
            self.vpcIds = dict["VpcIds"] as! String
        }
    }
}

public class ModifyApiGroupVpcWhitelistResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyApiGroupVpcWhitelistResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyApiGroupVpcWhitelistResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyApiGroupVpcWhitelistResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyAppRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var appId: Int64?

    public var appName: String?

    public var description_: String?

    public var extend: String?

    public var securityToken: String?

    public var tag: [ModifyAppRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.extend != nil {
            map["Extend"] = self.extend!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! Int64
        }
        if dict.keys.contains("AppName") && dict["AppName"] != nil {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Extend") && dict["Extend"] != nil {
            self.extend = dict["Extend"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("Tag") && dict["Tag"] != nil {
            var tmp : [ModifyAppRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = ModifyAppRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class ModifyAppResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyAppResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyAppResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyAppResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyBackendRequest : Tea.TeaModel {
    public var backendId: String?

    public var backendName: String?

    public var backendType: String?

    public var description_: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backendId != nil {
            map["BackendId"] = self.backendId!
        }
        if self.backendName != nil {
            map["BackendName"] = self.backendName!
        }
        if self.backendType != nil {
            map["BackendType"] = self.backendType!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BackendId") && dict["BackendId"] != nil {
            self.backendId = dict["BackendId"] as! String
        }
        if dict.keys.contains("BackendName") && dict["BackendName"] != nil {
            self.backendName = dict["BackendName"] as! String
        }
        if dict.keys.contains("BackendType") && dict["BackendType"] != nil {
            self.backendType = dict["BackendType"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class ModifyBackendResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyBackendResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyBackendResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyBackendResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyBackendModelRequest : Tea.TeaModel {
    public var backendId: String?

    public var backendModelData: String?

    public var backendModelId: String?

    public var backendType: String?

    public var description_: String?

    public var securityToken: String?

    public var stageName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backendId != nil {
            map["BackendId"] = self.backendId!
        }
        if self.backendModelData != nil {
            map["BackendModelData"] = self.backendModelData!
        }
        if self.backendModelId != nil {
            map["BackendModelId"] = self.backendModelId!
        }
        if self.backendType != nil {
            map["BackendType"] = self.backendType!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.stageName != nil {
            map["StageName"] = self.stageName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BackendId") && dict["BackendId"] != nil {
            self.backendId = dict["BackendId"] as! String
        }
        if dict.keys.contains("BackendModelData") && dict["BackendModelData"] != nil {
            self.backendModelData = dict["BackendModelData"] as! String
        }
        if dict.keys.contains("BackendModelId") && dict["BackendModelId"] != nil {
            self.backendModelId = dict["BackendModelId"] as! String
        }
        if dict.keys.contains("BackendType") && dict["BackendType"] != nil {
            self.backendType = dict["BackendType"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StageName") && dict["StageName"] != nil {
            self.stageName = dict["StageName"] as! String
        }
    }
}

public class ModifyBackendModelResponseBody : Tea.TeaModel {
    public var operationId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.operationId != nil {
            map["OperationId"] = self.operationId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OperationId") && dict["OperationId"] != nil {
            self.operationId = dict["OperationId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyBackendModelResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyBackendModelResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyBackendModelResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyDatasetRequest : Tea.TeaModel {
    public var datasetId: String?

    public var datasetName: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.datasetId != nil {
            map["DatasetId"] = self.datasetId!
        }
        if self.datasetName != nil {
            map["DatasetName"] = self.datasetName!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DatasetId") && dict["DatasetId"] != nil {
            self.datasetId = dict["DatasetId"] as! String
        }
        if dict.keys.contains("DatasetName") && dict["DatasetName"] != nil {
            self.datasetName = dict["DatasetName"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class ModifyDatasetResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyDatasetResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDatasetResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyDatasetResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyDatasetItemRequest : Tea.TeaModel {
    public var datasetId: String?

    public var datasetItemId: String?

    public var description_: String?

    public var expiredTime: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.datasetId != nil {
            map["DatasetId"] = self.datasetId!
        }
        if self.datasetItemId != nil {
            map["DatasetItemId"] = self.datasetItemId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.expiredTime != nil {
            map["ExpiredTime"] = self.expiredTime!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DatasetId") && dict["DatasetId"] != nil {
            self.datasetId = dict["DatasetId"] as! String
        }
        if dict.keys.contains("DatasetItemId") && dict["DatasetItemId"] != nil {
            self.datasetItemId = dict["DatasetItemId"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("ExpiredTime") && dict["ExpiredTime"] != nil {
            self.expiredTime = dict["ExpiredTime"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class ModifyDatasetItemResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyDatasetItemResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDatasetItemResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyDatasetItemResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyInstanceAttributeRequest : Tea.TeaModel {
    public class ToConnectVpcIpBlock : Tea.TeaModel {
        public var cidrBlock: String?

        public var customized: Bool?

        public var vswitchId: String?

        public var zoneId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cidrBlock != nil {
                map["CidrBlock"] = self.cidrBlock!
            }
            if self.customized != nil {
                map["Customized"] = self.customized!
            }
            if self.vswitchId != nil {
                map["VswitchId"] = self.vswitchId!
            }
            if self.zoneId != nil {
                map["ZoneId"] = self.zoneId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CidrBlock") && dict["CidrBlock"] != nil {
                self.cidrBlock = dict["CidrBlock"] as! String
            }
            if dict.keys.contains("Customized") && dict["Customized"] != nil {
                self.customized = dict["Customized"] as! Bool
            }
            if dict.keys.contains("VswitchId") && dict["VswitchId"] != nil {
                self.vswitchId = dict["VswitchId"] as! String
            }
            if dict.keys.contains("ZoneId") && dict["ZoneId"] != nil {
                self.zoneId = dict["ZoneId"] as! String
            }
        }
    }
    public var deleteVpcIpBlock: String?

    public var egressIpv6Enable: String?

    public var httpsPolicy: String?

    public var IPV6Enabled: String?

    public var instanceId: String?

    public var instanceName: String?

    public var intranetSegments: String?

    public var maintainEndTime: String?

    public var maintainStartTime: String?

    public var toConnectVpcIpBlock: ModifyInstanceAttributeRequest.ToConnectVpcIpBlock?

    public var token: String?

    public var vpcSlbIntranetEnable: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.toConnectVpcIpBlock?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deleteVpcIpBlock != nil {
            map["DeleteVpcIpBlock"] = self.deleteVpcIpBlock!
        }
        if self.egressIpv6Enable != nil {
            map["EgressIpv6Enable"] = self.egressIpv6Enable!
        }
        if self.httpsPolicy != nil {
            map["HttpsPolicy"] = self.httpsPolicy!
        }
        if self.IPV6Enabled != nil {
            map["IPV6Enabled"] = self.IPV6Enabled!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.intranetSegments != nil {
            map["IntranetSegments"] = self.intranetSegments!
        }
        if self.maintainEndTime != nil {
            map["MaintainEndTime"] = self.maintainEndTime!
        }
        if self.maintainStartTime != nil {
            map["MaintainStartTime"] = self.maintainStartTime!
        }
        if self.toConnectVpcIpBlock != nil {
            map["ToConnectVpcIpBlock"] = self.toConnectVpcIpBlock?.toMap()
        }
        if self.token != nil {
            map["Token"] = self.token!
        }
        if self.vpcSlbIntranetEnable != nil {
            map["VpcSlbIntranetEnable"] = self.vpcSlbIntranetEnable!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeleteVpcIpBlock") && dict["DeleteVpcIpBlock"] != nil {
            self.deleteVpcIpBlock = dict["DeleteVpcIpBlock"] as! String
        }
        if dict.keys.contains("EgressIpv6Enable") && dict["EgressIpv6Enable"] != nil {
            self.egressIpv6Enable = dict["EgressIpv6Enable"] as! String
        }
        if dict.keys.contains("HttpsPolicy") && dict["HttpsPolicy"] != nil {
            self.httpsPolicy = dict["HttpsPolicy"] as! String
        }
        if dict.keys.contains("IPV6Enabled") && dict["IPV6Enabled"] != nil {
            self.IPV6Enabled = dict["IPV6Enabled"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
            self.instanceName = dict["InstanceName"] as! String
        }
        if dict.keys.contains("IntranetSegments") && dict["IntranetSegments"] != nil {
            self.intranetSegments = dict["IntranetSegments"] as! String
        }
        if dict.keys.contains("MaintainEndTime") && dict["MaintainEndTime"] != nil {
            self.maintainEndTime = dict["MaintainEndTime"] as! String
        }
        if dict.keys.contains("MaintainStartTime") && dict["MaintainStartTime"] != nil {
            self.maintainStartTime = dict["MaintainStartTime"] as! String
        }
        if dict.keys.contains("ToConnectVpcIpBlock") && dict["ToConnectVpcIpBlock"] != nil {
            var model = ModifyInstanceAttributeRequest.ToConnectVpcIpBlock()
            model.fromMap(dict["ToConnectVpcIpBlock"] as! [String: Any])
            self.toConnectVpcIpBlock = model
        }
        if dict.keys.contains("Token") && dict["Token"] != nil {
            self.token = dict["Token"] as! String
        }
        if dict.keys.contains("VpcSlbIntranetEnable") && dict["VpcSlbIntranetEnable"] != nil {
            self.vpcSlbIntranetEnable = dict["VpcSlbIntranetEnable"] as! String
        }
    }
}

public class ModifyInstanceAttributeShrinkRequest : Tea.TeaModel {
    public var deleteVpcIpBlock: String?

    public var egressIpv6Enable: String?

    public var httpsPolicy: String?

    public var IPV6Enabled: String?

    public var instanceId: String?

    public var instanceName: String?

    public var intranetSegments: String?

    public var maintainEndTime: String?

    public var maintainStartTime: String?

    public var toConnectVpcIpBlockShrink: String?

    public var token: String?

    public var vpcSlbIntranetEnable: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deleteVpcIpBlock != nil {
            map["DeleteVpcIpBlock"] = self.deleteVpcIpBlock!
        }
        if self.egressIpv6Enable != nil {
            map["EgressIpv6Enable"] = self.egressIpv6Enable!
        }
        if self.httpsPolicy != nil {
            map["HttpsPolicy"] = self.httpsPolicy!
        }
        if self.IPV6Enabled != nil {
            map["IPV6Enabled"] = self.IPV6Enabled!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.intranetSegments != nil {
            map["IntranetSegments"] = self.intranetSegments!
        }
        if self.maintainEndTime != nil {
            map["MaintainEndTime"] = self.maintainEndTime!
        }
        if self.maintainStartTime != nil {
            map["MaintainStartTime"] = self.maintainStartTime!
        }
        if self.toConnectVpcIpBlockShrink != nil {
            map["ToConnectVpcIpBlock"] = self.toConnectVpcIpBlockShrink!
        }
        if self.token != nil {
            map["Token"] = self.token!
        }
        if self.vpcSlbIntranetEnable != nil {
            map["VpcSlbIntranetEnable"] = self.vpcSlbIntranetEnable!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeleteVpcIpBlock") && dict["DeleteVpcIpBlock"] != nil {
            self.deleteVpcIpBlock = dict["DeleteVpcIpBlock"] as! String
        }
        if dict.keys.contains("EgressIpv6Enable") && dict["EgressIpv6Enable"] != nil {
            self.egressIpv6Enable = dict["EgressIpv6Enable"] as! String
        }
        if dict.keys.contains("HttpsPolicy") && dict["HttpsPolicy"] != nil {
            self.httpsPolicy = dict["HttpsPolicy"] as! String
        }
        if dict.keys.contains("IPV6Enabled") && dict["IPV6Enabled"] != nil {
            self.IPV6Enabled = dict["IPV6Enabled"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
            self.instanceName = dict["InstanceName"] as! String
        }
        if dict.keys.contains("IntranetSegments") && dict["IntranetSegments"] != nil {
            self.intranetSegments = dict["IntranetSegments"] as! String
        }
        if dict.keys.contains("MaintainEndTime") && dict["MaintainEndTime"] != nil {
            self.maintainEndTime = dict["MaintainEndTime"] as! String
        }
        if dict.keys.contains("MaintainStartTime") && dict["MaintainStartTime"] != nil {
            self.maintainStartTime = dict["MaintainStartTime"] as! String
        }
        if dict.keys.contains("ToConnectVpcIpBlock") && dict["ToConnectVpcIpBlock"] != nil {
            self.toConnectVpcIpBlockShrink = dict["ToConnectVpcIpBlock"] as! String
        }
        if dict.keys.contains("Token") && dict["Token"] != nil {
            self.token = dict["Token"] as! String
        }
        if dict.keys.contains("VpcSlbIntranetEnable") && dict["VpcSlbIntranetEnable"] != nil {
            self.vpcSlbIntranetEnable = dict["VpcSlbIntranetEnable"] as! String
        }
    }
}

public class ModifyInstanceAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyInstanceAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyInstanceAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyInstanceAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyInstanceSpecRequest : Tea.TeaModel {
    public var autoPay: Bool?

    public var instanceId: String?

    public var instanceSpec: String?

    public var modifyAction: String?

    public var skipWaitSwitch: Bool?

    public var token: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceSpec != nil {
            map["InstanceSpec"] = self.instanceSpec!
        }
        if self.modifyAction != nil {
            map["ModifyAction"] = self.modifyAction!
        }
        if self.skipWaitSwitch != nil {
            map["SkipWaitSwitch"] = self.skipWaitSwitch!
        }
        if self.token != nil {
            map["Token"] = self.token!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoPay") && dict["AutoPay"] != nil {
            self.autoPay = dict["AutoPay"] as! Bool
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("InstanceSpec") && dict["InstanceSpec"] != nil {
            self.instanceSpec = dict["InstanceSpec"] as! String
        }
        if dict.keys.contains("ModifyAction") && dict["ModifyAction"] != nil {
            self.modifyAction = dict["ModifyAction"] as! String
        }
        if dict.keys.contains("SkipWaitSwitch") && dict["SkipWaitSwitch"] != nil {
            self.skipWaitSwitch = dict["SkipWaitSwitch"] as! Bool
        }
        if dict.keys.contains("Token") && dict["Token"] != nil {
            self.token = dict["Token"] as! String
        }
    }
}

public class ModifyInstanceSpecResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyInstanceSpecResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyInstanceSpecResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyInstanceSpecResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyIntranetDomainPolicyRequest : Tea.TeaModel {
    public var groupId: String?

    public var securityToken: String?

    public var vpcIntranetEnable: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.vpcIntranetEnable != nil {
            map["VpcIntranetEnable"] = self.vpcIntranetEnable!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("VpcIntranetEnable") && dict["VpcIntranetEnable"] != nil {
            self.vpcIntranetEnable = dict["VpcIntranetEnable"] as! Bool
        }
    }
}

public class ModifyIntranetDomainPolicyResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyIntranetDomainPolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyIntranetDomainPolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyIntranetDomainPolicyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyIpControlRequest : Tea.TeaModel {
    public var description_: String?

    public var ipControlId: String?

    public var ipControlName: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.ipControlId != nil {
            map["IpControlId"] = self.ipControlId!
        }
        if self.ipControlName != nil {
            map["IpControlName"] = self.ipControlName!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("IpControlId") && dict["IpControlId"] != nil {
            self.ipControlId = dict["IpControlId"] as! String
        }
        if dict.keys.contains("IpControlName") && dict["IpControlName"] != nil {
            self.ipControlName = dict["IpControlName"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class ModifyIpControlResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyIpControlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyIpControlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyIpControlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyIpControlPolicyItemRequest : Tea.TeaModel {
    public var appId: String?

    public var cidrIp: String?

    public var ipControlId: String?

    public var policyItemId: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.cidrIp != nil {
            map["CidrIp"] = self.cidrIp!
        }
        if self.ipControlId != nil {
            map["IpControlId"] = self.ipControlId!
        }
        if self.policyItemId != nil {
            map["PolicyItemId"] = self.policyItemId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("CidrIp") && dict["CidrIp"] != nil {
            self.cidrIp = dict["CidrIp"] as! String
        }
        if dict.keys.contains("IpControlId") && dict["IpControlId"] != nil {
            self.ipControlId = dict["IpControlId"] as! String
        }
        if dict.keys.contains("PolicyItemId") && dict["PolicyItemId"] != nil {
            self.policyItemId = dict["PolicyItemId"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class ModifyIpControlPolicyItemResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyIpControlPolicyItemResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyIpControlPolicyItemResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyIpControlPolicyItemResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyLogConfigRequest : Tea.TeaModel {
    public var logType: String?

    public var securityToken: String?

    public var slsLogStore: String?

    public var slsProject: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.logType != nil {
            map["LogType"] = self.logType!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.slsLogStore != nil {
            map["SlsLogStore"] = self.slsLogStore!
        }
        if self.slsProject != nil {
            map["SlsProject"] = self.slsProject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LogType") && dict["LogType"] != nil {
            self.logType = dict["LogType"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("SlsLogStore") && dict["SlsLogStore"] != nil {
            self.slsLogStore = dict["SlsLogStore"] as! String
        }
        if dict.keys.contains("SlsProject") && dict["SlsProject"] != nil {
            self.slsProject = dict["SlsProject"] as! String
        }
    }
}

public class ModifyLogConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyLogConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyLogConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyLogConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyModelRequest : Tea.TeaModel {
    public var description_: String?

    public var groupId: String?

    public var modelName: String?

    public var newModelName: String?

    public var schema: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.modelName != nil {
            map["ModelName"] = self.modelName!
        }
        if self.newModelName != nil {
            map["NewModelName"] = self.newModelName!
        }
        if self.schema != nil {
            map["Schema"] = self.schema!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("ModelName") && dict["ModelName"] != nil {
            self.modelName = dict["ModelName"] as! String
        }
        if dict.keys.contains("NewModelName") && dict["NewModelName"] != nil {
            self.newModelName = dict["NewModelName"] as! String
        }
        if dict.keys.contains("Schema") && dict["Schema"] != nil {
            self.schema = dict["Schema"] as! String
        }
    }
}

public class ModifyModelResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyModelResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyModelResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyModelResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyPluginRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var description_: String?

    public var pluginData: String?

    public var pluginId: String?

    public var pluginName: String?

    public var securityToken: String?

    public var tag: [ModifyPluginRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.pluginData != nil {
            map["PluginData"] = self.pluginData!
        }
        if self.pluginId != nil {
            map["PluginId"] = self.pluginId!
        }
        if self.pluginName != nil {
            map["PluginName"] = self.pluginName!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("PluginData") && dict["PluginData"] != nil {
            self.pluginData = dict["PluginData"] as! String
        }
        if dict.keys.contains("PluginId") && dict["PluginId"] != nil {
            self.pluginId = dict["PluginId"] as! String
        }
        if dict.keys.contains("PluginName") && dict["PluginName"] != nil {
            self.pluginName = dict["PluginName"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("Tag") && dict["Tag"] != nil {
            var tmp : [ModifyPluginRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = ModifyPluginRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class ModifyPluginResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyPluginResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyPluginResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyPluginResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifySignatureRequest : Tea.TeaModel {
    public var securityToken: String?

    public var signatureId: String?

    public var signatureKey: String?

    public var signatureName: String?

    public var signatureSecret: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.signatureId != nil {
            map["SignatureId"] = self.signatureId!
        }
        if self.signatureKey != nil {
            map["SignatureKey"] = self.signatureKey!
        }
        if self.signatureName != nil {
            map["SignatureName"] = self.signatureName!
        }
        if self.signatureSecret != nil {
            map["SignatureSecret"] = self.signatureSecret!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("SignatureId") && dict["SignatureId"] != nil {
            self.signatureId = dict["SignatureId"] as! String
        }
        if dict.keys.contains("SignatureKey") && dict["SignatureKey"] != nil {
            self.signatureKey = dict["SignatureKey"] as! String
        }
        if dict.keys.contains("SignatureName") && dict["SignatureName"] != nil {
            self.signatureName = dict["SignatureName"] as! String
        }
        if dict.keys.contains("SignatureSecret") && dict["SignatureSecret"] != nil {
            self.signatureSecret = dict["SignatureSecret"] as! String
        }
    }
}

public class ModifySignatureResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var signatureId: String?

    public var signatureName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.signatureId != nil {
            map["SignatureId"] = self.signatureId!
        }
        if self.signatureName != nil {
            map["SignatureName"] = self.signatureName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SignatureId") && dict["SignatureId"] != nil {
            self.signatureId = dict["SignatureId"] as! String
        }
        if dict.keys.contains("SignatureName") && dict["SignatureName"] != nil {
            self.signatureName = dict["SignatureName"] as! String
        }
    }
}

public class ModifySignatureResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifySignatureResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifySignatureResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyTrafficControlRequest : Tea.TeaModel {
    public var apiDefault: Int32?

    public var appDefault: Int32?

    public var description_: String?

    public var securityToken: String?

    public var trafficControlId: String?

    public var trafficControlName: String?

    public var trafficControlUnit: String?

    public var userDefault: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiDefault != nil {
            map["ApiDefault"] = self.apiDefault!
        }
        if self.appDefault != nil {
            map["AppDefault"] = self.appDefault!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.trafficControlId != nil {
            map["TrafficControlId"] = self.trafficControlId!
        }
        if self.trafficControlName != nil {
            map["TrafficControlName"] = self.trafficControlName!
        }
        if self.trafficControlUnit != nil {
            map["TrafficControlUnit"] = self.trafficControlUnit!
        }
        if self.userDefault != nil {
            map["UserDefault"] = self.userDefault!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiDefault") && dict["ApiDefault"] != nil {
            self.apiDefault = dict["ApiDefault"] as! Int32
        }
        if dict.keys.contains("AppDefault") && dict["AppDefault"] != nil {
            self.appDefault = dict["AppDefault"] as! Int32
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("TrafficControlId") && dict["TrafficControlId"] != nil {
            self.trafficControlId = dict["TrafficControlId"] as! String
        }
        if dict.keys.contains("TrafficControlName") && dict["TrafficControlName"] != nil {
            self.trafficControlName = dict["TrafficControlName"] as! String
        }
        if dict.keys.contains("TrafficControlUnit") && dict["TrafficControlUnit"] != nil {
            self.trafficControlUnit = dict["TrafficControlUnit"] as! String
        }
        if dict.keys.contains("UserDefault") && dict["UserDefault"] != nil {
            self.userDefault = dict["UserDefault"] as! Int32
        }
    }
}

public class ModifyTrafficControlResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyTrafficControlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyTrafficControlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyTrafficControlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyVpcAccessAndUpdateApisRequest : Tea.TeaModel {
    public var instanceId: String?

    public var name: String?

    public var needBatchWork: Bool?

    public var port: Int32?

    public var refresh: Bool?

    public var securityToken: String?

    public var token: String?

    public var vpcId: String?

    public var vpcTargetHostName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.needBatchWork != nil {
            map["NeedBatchWork"] = self.needBatchWork!
        }
        if self.port != nil {
            map["Port"] = self.port!
        }
        if self.refresh != nil {
            map["Refresh"] = self.refresh!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.token != nil {
            map["Token"] = self.token!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        if self.vpcTargetHostName != nil {
            map["VpcTargetHostName"] = self.vpcTargetHostName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("NeedBatchWork") && dict["NeedBatchWork"] != nil {
            self.needBatchWork = dict["NeedBatchWork"] as! Bool
        }
        if dict.keys.contains("Port") && dict["Port"] != nil {
            self.port = dict["Port"] as! Int32
        }
        if dict.keys.contains("Refresh") && dict["Refresh"] != nil {
            self.refresh = dict["Refresh"] as! Bool
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("Token") && dict["Token"] != nil {
            self.token = dict["Token"] as! String
        }
        if dict.keys.contains("VpcId") && dict["VpcId"] != nil {
            self.vpcId = dict["VpcId"] as! String
        }
        if dict.keys.contains("VpcTargetHostName") && dict["VpcTargetHostName"] != nil {
            self.vpcTargetHostName = dict["VpcTargetHostName"] as! String
        }
    }
}

public class ModifyVpcAccessAndUpdateApisResponseBody : Tea.TeaModel {
    public var operationId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.operationId != nil {
            map["OperationId"] = self.operationId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OperationId") && dict["OperationId"] != nil {
            self.operationId = dict["OperationId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyVpcAccessAndUpdateApisResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyVpcAccessAndUpdateApisResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyVpcAccessAndUpdateApisResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class OpenApiGatewayServiceResponseBody : Tea.TeaModel {
    public var orderId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
            self.orderId = dict["OrderId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class OpenApiGatewayServiceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: OpenApiGatewayServiceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = OpenApiGatewayServiceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryRequestLogsRequest : Tea.TeaModel {
    public var requestLogId: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestLogId != nil {
            map["RequestLogId"] = self.requestLogId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestLogId") && dict["RequestLogId"] != nil {
            self.requestLogId = dict["RequestLogId"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class QueryRequestLogsResponseBody : Tea.TeaModel {
    public class RequestLogs : Tea.TeaModel {
        public class RequestLog : Tea.TeaModel {
            public var apiId: String?

            public var apiName: String?

            public var appName: String?

            public var backendRequestEnd: Int64?

            public var backendRequestStart: Int64?

            public var backendResponseEnd: Int64?

            public var backendResponseStart: Int64?

            public var clientIp: String?

            public var clientNonce: String?

            public var consumerAppId: String?

            public var consumerAppKey: String?

            public var customTraceId: String?

            public var domain: String?

            public var errorCode: String?

            public var errorMessage: String?

            public var exception: String?

            public var frontRequestEnd: Int64?

            public var frontRequestStart: Int64?

            public var frontResponseEnd: Int64?

            public var frontResponseStart: Int64?

            public var groupId: String?

            public var groupName: String?

            public var httpMethod: String?

            public var httpPath: String?

            public var initialRequestId: String?

            public var instanceId: String?

            public var jwtClaims: String?

            public var region: String?

            public var requestBody: String?

            public var requestHeaders: String?

            public var requestId: String?

            public var requestProtocol: String?

            public var requestQueryString: String?

            public var requestSize: String?

            public var requestTime: String?

            public var responseBody: String?

            public var responseHeaders: String?

            public var responseSize: String?

            public var serviceLatency: String?

            public var stageId: String?

            public var stageName: String?

            public var statusCode: String?

            public var totalLatency: String?

            public var plugin: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.apiId != nil {
                    map["ApiId"] = self.apiId!
                }
                if self.apiName != nil {
                    map["ApiName"] = self.apiName!
                }
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.backendRequestEnd != nil {
                    map["BackendRequestEnd"] = self.backendRequestEnd!
                }
                if self.backendRequestStart != nil {
                    map["BackendRequestStart"] = self.backendRequestStart!
                }
                if self.backendResponseEnd != nil {
                    map["BackendResponseEnd"] = self.backendResponseEnd!
                }
                if self.backendResponseStart != nil {
                    map["BackendResponseStart"] = self.backendResponseStart!
                }
                if self.clientIp != nil {
                    map["ClientIp"] = self.clientIp!
                }
                if self.clientNonce != nil {
                    map["ClientNonce"] = self.clientNonce!
                }
                if self.consumerAppId != nil {
                    map["ConsumerAppId"] = self.consumerAppId!
                }
                if self.consumerAppKey != nil {
                    map["ConsumerAppKey"] = self.consumerAppKey!
                }
                if self.customTraceId != nil {
                    map["CustomTraceId"] = self.customTraceId!
                }
                if self.domain != nil {
                    map["Domain"] = self.domain!
                }
                if self.errorCode != nil {
                    map["ErrorCode"] = self.errorCode!
                }
                if self.errorMessage != nil {
                    map["ErrorMessage"] = self.errorMessage!
                }
                if self.exception != nil {
                    map["Exception"] = self.exception!
                }
                if self.frontRequestEnd != nil {
                    map["FrontRequestEnd"] = self.frontRequestEnd!
                }
                if self.frontRequestStart != nil {
                    map["FrontRequestStart"] = self.frontRequestStart!
                }
                if self.frontResponseEnd != nil {
                    map["FrontResponseEnd"] = self.frontResponseEnd!
                }
                if self.frontResponseStart != nil {
                    map["FrontResponseStart"] = self.frontResponseStart!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.httpMethod != nil {
                    map["HttpMethod"] = self.httpMethod!
                }
                if self.httpPath != nil {
                    map["HttpPath"] = self.httpPath!
                }
                if self.initialRequestId != nil {
                    map["InitialRequestId"] = self.initialRequestId!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jwtClaims != nil {
                    map["JwtClaims"] = self.jwtClaims!
                }
                if self.region != nil {
                    map["Region"] = self.region!
                }
                if self.requestBody != nil {
                    map["RequestBody"] = self.requestBody!
                }
                if self.requestHeaders != nil {
                    map["RequestHeaders"] = self.requestHeaders!
                }
                if self.requestId != nil {
                    map["RequestId"] = self.requestId!
                }
                if self.requestProtocol != nil {
                    map["RequestProtocol"] = self.requestProtocol!
                }
                if self.requestQueryString != nil {
                    map["RequestQueryString"] = self.requestQueryString!
                }
                if self.requestSize != nil {
                    map["RequestSize"] = self.requestSize!
                }
                if self.requestTime != nil {
                    map["RequestTime"] = self.requestTime!
                }
                if self.responseBody != nil {
                    map["ResponseBody"] = self.responseBody!
                }
                if self.responseHeaders != nil {
                    map["ResponseHeaders"] = self.responseHeaders!
                }
                if self.responseSize != nil {
                    map["ResponseSize"] = self.responseSize!
                }
                if self.serviceLatency != nil {
                    map["ServiceLatency"] = self.serviceLatency!
                }
                if self.stageId != nil {
                    map["StageId"] = self.stageId!
                }
                if self.stageName != nil {
                    map["StageName"] = self.stageName!
                }
                if self.statusCode != nil {
                    map["StatusCode"] = self.statusCode!
                }
                if self.totalLatency != nil {
                    map["TotalLatency"] = self.totalLatency!
                }
                if self.plugin != nil {
                    map["plugin"] = self.plugin!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ApiId") && dict["ApiId"] != nil {
                    self.apiId = dict["ApiId"] as! String
                }
                if dict.keys.contains("ApiName") && dict["ApiName"] != nil {
                    self.apiName = dict["ApiName"] as! String
                }
                if dict.keys.contains("AppName") && dict["AppName"] != nil {
                    self.appName = dict["AppName"] as! String
                }
                if dict.keys.contains("BackendRequestEnd") && dict["BackendRequestEnd"] != nil {
                    self.backendRequestEnd = dict["BackendRequestEnd"] as! Int64
                }
                if dict.keys.contains("BackendRequestStart") && dict["BackendRequestStart"] != nil {
                    self.backendRequestStart = dict["BackendRequestStart"] as! Int64
                }
                if dict.keys.contains("BackendResponseEnd") && dict["BackendResponseEnd"] != nil {
                    self.backendResponseEnd = dict["BackendResponseEnd"] as! Int64
                }
                if dict.keys.contains("BackendResponseStart") && dict["BackendResponseStart"] != nil {
                    self.backendResponseStart = dict["BackendResponseStart"] as! Int64
                }
                if dict.keys.contains("ClientIp") && dict["ClientIp"] != nil {
                    self.clientIp = dict["ClientIp"] as! String
                }
                if dict.keys.contains("ClientNonce") && dict["ClientNonce"] != nil {
                    self.clientNonce = dict["ClientNonce"] as! String
                }
                if dict.keys.contains("ConsumerAppId") && dict["ConsumerAppId"] != nil {
                    self.consumerAppId = dict["ConsumerAppId"] as! String
                }
                if dict.keys.contains("ConsumerAppKey") && dict["ConsumerAppKey"] != nil {
                    self.consumerAppKey = dict["ConsumerAppKey"] as! String
                }
                if dict.keys.contains("CustomTraceId") && dict["CustomTraceId"] != nil {
                    self.customTraceId = dict["CustomTraceId"] as! String
                }
                if dict.keys.contains("Domain") && dict["Domain"] != nil {
                    self.domain = dict["Domain"] as! String
                }
                if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
                    self.errorCode = dict["ErrorCode"] as! String
                }
                if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
                    self.errorMessage = dict["ErrorMessage"] as! String
                }
                if dict.keys.contains("Exception") && dict["Exception"] != nil {
                    self.exception = dict["Exception"] as! String
                }
                if dict.keys.contains("FrontRequestEnd") && dict["FrontRequestEnd"] != nil {
                    self.frontRequestEnd = dict["FrontRequestEnd"] as! Int64
                }
                if dict.keys.contains("FrontRequestStart") && dict["FrontRequestStart"] != nil {
                    self.frontRequestStart = dict["FrontRequestStart"] as! Int64
                }
                if dict.keys.contains("FrontResponseEnd") && dict["FrontResponseEnd"] != nil {
                    self.frontResponseEnd = dict["FrontResponseEnd"] as! Int64
                }
                if dict.keys.contains("FrontResponseStart") && dict["FrontResponseStart"] != nil {
                    self.frontResponseStart = dict["FrontResponseStart"] as! Int64
                }
                if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
                    self.groupName = dict["GroupName"] as! String
                }
                if dict.keys.contains("HttpMethod") && dict["HttpMethod"] != nil {
                    self.httpMethod = dict["HttpMethod"] as! String
                }
                if dict.keys.contains("HttpPath") && dict["HttpPath"] != nil {
                    self.httpPath = dict["HttpPath"] as! String
                }
                if dict.keys.contains("InitialRequestId") && dict["InitialRequestId"] != nil {
                    self.initialRequestId = dict["InitialRequestId"] as! String
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JwtClaims") && dict["JwtClaims"] != nil {
                    self.jwtClaims = dict["JwtClaims"] as! String
                }
                if dict.keys.contains("Region") && dict["Region"] != nil {
                    self.region = dict["Region"] as! String
                }
                if dict.keys.contains("RequestBody") && dict["RequestBody"] != nil {
                    self.requestBody = dict["RequestBody"] as! String
                }
                if dict.keys.contains("RequestHeaders") && dict["RequestHeaders"] != nil {
                    self.requestHeaders = dict["RequestHeaders"] as! String
                }
                if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
                    self.requestId = dict["RequestId"] as! String
                }
                if dict.keys.contains("RequestProtocol") && dict["RequestProtocol"] != nil {
                    self.requestProtocol = dict["RequestProtocol"] as! String
                }
                if dict.keys.contains("RequestQueryString") && dict["RequestQueryString"] != nil {
                    self.requestQueryString = dict["RequestQueryString"] as! String
                }
                if dict.keys.contains("RequestSize") && dict["RequestSize"] != nil {
                    self.requestSize = dict["RequestSize"] as! String
                }
                if dict.keys.contains("RequestTime") && dict["RequestTime"] != nil {
                    self.requestTime = dict["RequestTime"] as! String
                }
                if dict.keys.contains("ResponseBody") && dict["ResponseBody"] != nil {
                    self.responseBody = dict["ResponseBody"] as! String
                }
                if dict.keys.contains("ResponseHeaders") && dict["ResponseHeaders"] != nil {
                    self.responseHeaders = dict["ResponseHeaders"] as! String
                }
                if dict.keys.contains("ResponseSize") && dict["ResponseSize"] != nil {
                    self.responseSize = dict["ResponseSize"] as! String
                }
                if dict.keys.contains("ServiceLatency") && dict["ServiceLatency"] != nil {
                    self.serviceLatency = dict["ServiceLatency"] as! String
                }
                if dict.keys.contains("StageId") && dict["StageId"] != nil {
                    self.stageId = dict["StageId"] as! String
                }
                if dict.keys.contains("StageName") && dict["StageName"] != nil {
                    self.stageName = dict["StageName"] as! String
                }
                if dict.keys.contains("StatusCode") && dict["StatusCode"] != nil {
                    self.statusCode = dict["StatusCode"] as! String
                }
                if dict.keys.contains("TotalLatency") && dict["TotalLatency"] != nil {
                    self.totalLatency = dict["TotalLatency"] as! String
                }
                if dict.keys.contains("plugin") && dict["plugin"] != nil {
                    self.plugin = dict["plugin"] as! String
                }
            }
        }
        public var requestLog: [QueryRequestLogsResponseBody.RequestLogs.RequestLog]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.requestLog != nil {
                var tmp : [Any] = []
                for k in self.requestLog! {
                    tmp.append(k.toMap())
                }
                map["RequestLog"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("RequestLog") && dict["RequestLog"] != nil {
                var tmp : [QueryRequestLogsResponseBody.RequestLogs.RequestLog] = []
                for v in dict["RequestLog"] as! [Any] {
                    var model = QueryRequestLogsResponseBody.RequestLogs.RequestLog()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.requestLog = tmp
            }
        }
    }
    public var requestId: String?

    public var requestLogs: QueryRequestLogsResponseBody.RequestLogs?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.requestLogs?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.requestLogs != nil {
            map["RequestLogs"] = self.requestLogs?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RequestLogs") && dict["RequestLogs"] != nil {
            var model = QueryRequestLogsResponseBody.RequestLogs()
            model.fromMap(dict["RequestLogs"] as! [String: Any])
            self.requestLogs = model
        }
    }
}

public class QueryRequestLogsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryRequestLogsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryRequestLogsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ReactivateDomainRequest : Tea.TeaModel {
    public var domainName: String?

    public var groupId: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") && dict["DomainName"] != nil {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class ReactivateDomainResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ReactivateDomainResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ReactivateDomainResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ReactivateDomainResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemoveAccessControlListEntryRequest : Tea.TeaModel {
    public var aclEntrys: String?

    public var aclId: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aclEntrys != nil {
            map["AclEntrys"] = self.aclEntrys!
        }
        if self.aclId != nil {
            map["AclId"] = self.aclId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AclEntrys") && dict["AclEntrys"] != nil {
            self.aclEntrys = dict["AclEntrys"] as! String
        }
        if dict.keys.contains("AclId") && dict["AclId"] != nil {
            self.aclId = dict["AclId"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class RemoveAccessControlListEntryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RemoveAccessControlListEntryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveAccessControlListEntryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RemoveAccessControlListEntryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemoveApiProductsAuthoritiesRequest : Tea.TeaModel {
    public var apiProductIds: [String]?

    public var appId: Int64?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiProductIds != nil {
            map["ApiProductIds"] = self.apiProductIds!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiProductIds") && dict["ApiProductIds"] != nil {
            self.apiProductIds = dict["ApiProductIds"] as! [String]
        }
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! Int64
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class RemoveApiProductsAuthoritiesShrinkRequest : Tea.TeaModel {
    public var apiProductIdsShrink: String?

    public var appId: Int64?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiProductIdsShrink != nil {
            map["ApiProductIds"] = self.apiProductIdsShrink!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiProductIds") && dict["ApiProductIds"] != nil {
            self.apiProductIdsShrink = dict["ApiProductIds"] as! String
        }
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! Int64
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class RemoveApiProductsAuthoritiesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RemoveApiProductsAuthoritiesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveApiProductsAuthoritiesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RemoveApiProductsAuthoritiesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemoveApisAuthoritiesRequest : Tea.TeaModel {
    public var apiIds: String?

    public var appId: Int64?

    public var description_: String?

    public var groupId: String?

    public var securityToken: String?

    public var stageName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiIds != nil {
            map["ApiIds"] = self.apiIds!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.stageName != nil {
            map["StageName"] = self.stageName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiIds") && dict["ApiIds"] != nil {
            self.apiIds = dict["ApiIds"] as! String
        }
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! Int64
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StageName") && dict["StageName"] != nil {
            self.stageName = dict["StageName"] as! String
        }
    }
}

public class RemoveApisAuthoritiesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RemoveApisAuthoritiesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveApisAuthoritiesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RemoveApisAuthoritiesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemoveAppsAuthoritiesRequest : Tea.TeaModel {
    public var apiId: String?

    public var appIds: String?

    public var groupId: String?

    public var securityToken: String?

    public var stageName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.appIds != nil {
            map["AppIds"] = self.appIds!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.stageName != nil {
            map["StageName"] = self.stageName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiId") && dict["ApiId"] != nil {
            self.apiId = dict["ApiId"] as! String
        }
        if dict.keys.contains("AppIds") && dict["AppIds"] != nil {
            self.appIds = dict["AppIds"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StageName") && dict["StageName"] != nil {
            self.stageName = dict["StageName"] as! String
        }
    }
}

public class RemoveAppsAuthoritiesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RemoveAppsAuthoritiesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveAppsAuthoritiesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RemoveAppsAuthoritiesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemoveIpControlApisRequest : Tea.TeaModel {
    public var apiIds: String?

    public var groupId: String?

    public var ipControlId: String?

    public var securityToken: String?

    public var stageName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiIds != nil {
            map["ApiIds"] = self.apiIds!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.ipControlId != nil {
            map["IpControlId"] = self.ipControlId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.stageName != nil {
            map["StageName"] = self.stageName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiIds") && dict["ApiIds"] != nil {
            self.apiIds = dict["ApiIds"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("IpControlId") && dict["IpControlId"] != nil {
            self.ipControlId = dict["IpControlId"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StageName") && dict["StageName"] != nil {
            self.stageName = dict["StageName"] as! String
        }
    }
}

public class RemoveIpControlApisResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RemoveIpControlApisResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveIpControlApisResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RemoveIpControlApisResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemoveIpControlPolicyItemRequest : Tea.TeaModel {
    public var ipControlId: String?

    public var policyItemIds: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ipControlId != nil {
            map["IpControlId"] = self.ipControlId!
        }
        if self.policyItemIds != nil {
            map["PolicyItemIds"] = self.policyItemIds!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IpControlId") && dict["IpControlId"] != nil {
            self.ipControlId = dict["IpControlId"] as! String
        }
        if dict.keys.contains("PolicyItemIds") && dict["PolicyItemIds"] != nil {
            self.policyItemIds = dict["PolicyItemIds"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class RemoveIpControlPolicyItemResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RemoveIpControlPolicyItemResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveIpControlPolicyItemResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RemoveIpControlPolicyItemResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemoveSignatureApisRequest : Tea.TeaModel {
    public var apiIds: String?

    public var groupId: String?

    public var securityToken: String?

    public var signatureId: String?

    public var stageName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiIds != nil {
            map["ApiIds"] = self.apiIds!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.signatureId != nil {
            map["SignatureId"] = self.signatureId!
        }
        if self.stageName != nil {
            map["StageName"] = self.stageName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiIds") && dict["ApiIds"] != nil {
            self.apiIds = dict["ApiIds"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("SignatureId") && dict["SignatureId"] != nil {
            self.signatureId = dict["SignatureId"] as! String
        }
        if dict.keys.contains("StageName") && dict["StageName"] != nil {
            self.stageName = dict["StageName"] as! String
        }
    }
}

public class RemoveSignatureApisResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RemoveSignatureApisResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveSignatureApisResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RemoveSignatureApisResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemoveTrafficControlApisRequest : Tea.TeaModel {
    public var apiIds: String?

    public var groupId: String?

    public var securityToken: String?

    public var stageName: String?

    public var trafficControlId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiIds != nil {
            map["ApiIds"] = self.apiIds!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.stageName != nil {
            map["StageName"] = self.stageName!
        }
        if self.trafficControlId != nil {
            map["TrafficControlId"] = self.trafficControlId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiIds") && dict["ApiIds"] != nil {
            self.apiIds = dict["ApiIds"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StageName") && dict["StageName"] != nil {
            self.stageName = dict["StageName"] as! String
        }
        if dict.keys.contains("TrafficControlId") && dict["TrafficControlId"] != nil {
            self.trafficControlId = dict["TrafficControlId"] as! String
        }
    }
}

public class RemoveTrafficControlApisResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RemoveTrafficControlApisResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveTrafficControlApisResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RemoveTrafficControlApisResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemoveVpcAccessRequest : Tea.TeaModel {
    public var instanceId: String?

    public var needBatchWork: Bool?

    public var port: Int32?

    public var securityToken: String?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.needBatchWork != nil {
            map["NeedBatchWork"] = self.needBatchWork!
        }
        if self.port != nil {
            map["Port"] = self.port!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NeedBatchWork") && dict["NeedBatchWork"] != nil {
            self.needBatchWork = dict["NeedBatchWork"] as! Bool
        }
        if dict.keys.contains("Port") && dict["Port"] != nil {
            self.port = dict["Port"] as! Int32
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("VpcId") && dict["VpcId"] != nil {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class RemoveVpcAccessResponseBody : Tea.TeaModel {
    public class Apis : Tea.TeaModel {
        public class Api : Tea.TeaModel {
            public var apiId: String?

            public var groupId: String?

            public var stageId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.apiId != nil {
                    map["ApiId"] = self.apiId!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.stageId != nil {
                    map["StageId"] = self.stageId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ApiId") && dict["ApiId"] != nil {
                    self.apiId = dict["ApiId"] as! String
                }
                if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("StageId") && dict["StageId"] != nil {
                    self.stageId = dict["StageId"] as! String
                }
            }
        }
        public var api: [RemoveVpcAccessResponseBody.Apis.Api]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.api != nil {
                var tmp : [Any] = []
                for k in self.api! {
                    tmp.append(k.toMap())
                }
                map["Api"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Api") && dict["Api"] != nil {
                var tmp : [RemoveVpcAccessResponseBody.Apis.Api] = []
                for v in dict["Api"] as! [Any] {
                    var model = RemoveVpcAccessResponseBody.Apis.Api()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.api = tmp
            }
        }
    }
    public var apis: RemoveVpcAccessResponseBody.Apis?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.apis?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apis != nil {
            map["Apis"] = self.apis?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Apis") && dict["Apis"] != nil {
            var model = RemoveVpcAccessResponseBody.Apis()
            model.fromMap(dict["Apis"] as! [String: Any])
            self.apis = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RemoveVpcAccessResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveVpcAccessResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RemoveVpcAccessResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemoveVpcAccessAndAbolishApisRequest : Tea.TeaModel {
    public var instanceId: String?

    public var needBatchWork: Bool?

    public var port: Int32?

    public var securityToken: String?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.needBatchWork != nil {
            map["NeedBatchWork"] = self.needBatchWork!
        }
        if self.port != nil {
            map["Port"] = self.port!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NeedBatchWork") && dict["NeedBatchWork"] != nil {
            self.needBatchWork = dict["NeedBatchWork"] as! Bool
        }
        if dict.keys.contains("Port") && dict["Port"] != nil {
            self.port = dict["Port"] as! Int32
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("VpcId") && dict["VpcId"] != nil {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class RemoveVpcAccessAndAbolishApisResponseBody : Tea.TeaModel {
    public var operationId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.operationId != nil {
            map["OperationId"] = self.operationId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OperationId") && dict["OperationId"] != nil {
            self.operationId = dict["OperationId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RemoveVpcAccessAndAbolishApisResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveVpcAccessAndAbolishApisResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RemoveVpcAccessAndAbolishApisResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ResetAppCodeRequest : Tea.TeaModel {
    public var appCode: String?

    public var newAppCode: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appCode != nil {
            map["AppCode"] = self.appCode!
        }
        if self.newAppCode != nil {
            map["NewAppCode"] = self.newAppCode!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppCode") && dict["AppCode"] != nil {
            self.appCode = dict["AppCode"] as! String
        }
        if dict.keys.contains("NewAppCode") && dict["NewAppCode"] != nil {
            self.newAppCode = dict["NewAppCode"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class ResetAppCodeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ResetAppCodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ResetAppCodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ResetAppCodeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ResetAppSecretRequest : Tea.TeaModel {
    public var appKey: String?

    public var newAppKey: String?

    public var newAppSecret: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appKey != nil {
            map["AppKey"] = self.appKey!
        }
        if self.newAppKey != nil {
            map["NewAppKey"] = self.newAppKey!
        }
        if self.newAppSecret != nil {
            map["NewAppSecret"] = self.newAppSecret!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppKey") && dict["AppKey"] != nil {
            self.appKey = dict["AppKey"] as! String
        }
        if dict.keys.contains("NewAppKey") && dict["NewAppKey"] != nil {
            self.newAppKey = dict["NewAppKey"] as! String
        }
        if dict.keys.contains("NewAppSecret") && dict["NewAppSecret"] != nil {
            self.newAppSecret = dict["NewAppSecret"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class ResetAppSecretResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ResetAppSecretResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ResetAppSecretResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ResetAppSecretResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SdkGenerateByAppRequest : Tea.TeaModel {
    public var appId: Int64?

    public var language: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! Int64
        }
        if dict.keys.contains("Language") && dict["Language"] != nil {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class SdkGenerateByAppResponseBody : Tea.TeaModel {
    public var downloadLink: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.downloadLink != nil {
            map["DownloadLink"] = self.downloadLink!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DownloadLink") && dict["DownloadLink"] != nil {
            self.downloadLink = dict["DownloadLink"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SdkGenerateByAppResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SdkGenerateByAppResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SdkGenerateByAppResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SdkGenerateByAppForRegionRequest : Tea.TeaModel {
    public var appId: Int64?

    public var language: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! Int64
        }
        if dict.keys.contains("Language") && dict["Language"] != nil {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class SdkGenerateByAppForRegionResponseBody : Tea.TeaModel {
    public var downloadLink: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.downloadLink != nil {
            map["DownloadLink"] = self.downloadLink!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DownloadLink") && dict["DownloadLink"] != nil {
            self.downloadLink = dict["DownloadLink"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SdkGenerateByAppForRegionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SdkGenerateByAppForRegionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SdkGenerateByAppForRegionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SdkGenerateByGroupRequest : Tea.TeaModel {
    public var groupId: String?

    public var language: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("Language") && dict["Language"] != nil {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class SdkGenerateByGroupResponseBody : Tea.TeaModel {
    public var downloadLink: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.downloadLink != nil {
            map["DownloadLink"] = self.downloadLink!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DownloadLink") && dict["DownloadLink"] != nil {
            self.downloadLink = dict["DownloadLink"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SdkGenerateByGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SdkGenerateByGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SdkGenerateByGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetAccessControlListAttributeRequest : Tea.TeaModel {
    public var aclId: String?

    public var aclName: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aclId != nil {
            map["AclId"] = self.aclId!
        }
        if self.aclName != nil {
            map["AclName"] = self.aclName!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AclId") && dict["AclId"] != nil {
            self.aclId = dict["AclId"] as! String
        }
        if dict.keys.contains("AclName") && dict["AclName"] != nil {
            self.aclName = dict["AclName"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class SetAccessControlListAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetAccessControlListAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetAccessControlListAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SetAccessControlListAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetApiProductsAuthoritiesRequest : Tea.TeaModel {
    public var apiProductIds: [String]?

    public var appId: Int64?

    public var authValidTime: String?

    public var description_: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiProductIds != nil {
            map["ApiProductIds"] = self.apiProductIds!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.authValidTime != nil {
            map["AuthValidTime"] = self.authValidTime!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiProductIds") && dict["ApiProductIds"] != nil {
            self.apiProductIds = dict["ApiProductIds"] as! [String]
        }
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! Int64
        }
        if dict.keys.contains("AuthValidTime") && dict["AuthValidTime"] != nil {
            self.authValidTime = dict["AuthValidTime"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class SetApiProductsAuthoritiesShrinkRequest : Tea.TeaModel {
    public var apiProductIdsShrink: String?

    public var appId: Int64?

    public var authValidTime: String?

    public var description_: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiProductIdsShrink != nil {
            map["ApiProductIds"] = self.apiProductIdsShrink!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.authValidTime != nil {
            map["AuthValidTime"] = self.authValidTime!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiProductIds") && dict["ApiProductIds"] != nil {
            self.apiProductIdsShrink = dict["ApiProductIds"] as! String
        }
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! Int64
        }
        if dict.keys.contains("AuthValidTime") && dict["AuthValidTime"] != nil {
            self.authValidTime = dict["AuthValidTime"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class SetApiProductsAuthoritiesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetApiProductsAuthoritiesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetApiProductsAuthoritiesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SetApiProductsAuthoritiesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetApisAuthoritiesRequest : Tea.TeaModel {
    public var apiIds: String?

    public var appId: Int64?

    public var authValidTime: String?

    public var description_: String?

    public var groupId: String?

    public var securityToken: String?

    public var stageName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiIds != nil {
            map["ApiIds"] = self.apiIds!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.authValidTime != nil {
            map["AuthValidTime"] = self.authValidTime!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.stageName != nil {
            map["StageName"] = self.stageName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiIds") && dict["ApiIds"] != nil {
            self.apiIds = dict["ApiIds"] as! String
        }
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! Int64
        }
        if dict.keys.contains("AuthValidTime") && dict["AuthValidTime"] != nil {
            self.authValidTime = dict["AuthValidTime"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StageName") && dict["StageName"] != nil {
            self.stageName = dict["StageName"] as! String
        }
    }
}

public class SetApisAuthoritiesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetApisAuthoritiesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetApisAuthoritiesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SetApisAuthoritiesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetAppsAuthToApiProductRequest : Tea.TeaModel {
    public var apiProductId: String?

    public var appIds: [Int64]?

    public var authValidTime: String?

    public var description_: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiProductId != nil {
            map["ApiProductId"] = self.apiProductId!
        }
        if self.appIds != nil {
            map["AppIds"] = self.appIds!
        }
        if self.authValidTime != nil {
            map["AuthValidTime"] = self.authValidTime!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiProductId") && dict["ApiProductId"] != nil {
            self.apiProductId = dict["ApiProductId"] as! String
        }
        if dict.keys.contains("AppIds") && dict["AppIds"] != nil {
            self.appIds = dict["AppIds"] as! [Int64]
        }
        if dict.keys.contains("AuthValidTime") && dict["AuthValidTime"] != nil {
            self.authValidTime = dict["AuthValidTime"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class SetAppsAuthToApiProductResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetAppsAuthToApiProductResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetAppsAuthToApiProductResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SetAppsAuthToApiProductResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetAppsAuthoritiesRequest : Tea.TeaModel {
    public var apiId: String?

    public var appIds: String?

    public var authValidTime: String?

    public var description_: String?

    public var groupId: String?

    public var securityToken: String?

    public var stageName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.appIds != nil {
            map["AppIds"] = self.appIds!
        }
        if self.authValidTime != nil {
            map["AuthValidTime"] = self.authValidTime!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.stageName != nil {
            map["StageName"] = self.stageName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiId") && dict["ApiId"] != nil {
            self.apiId = dict["ApiId"] as! String
        }
        if dict.keys.contains("AppIds") && dict["AppIds"] != nil {
            self.appIds = dict["AppIds"] as! String
        }
        if dict.keys.contains("AuthValidTime") && dict["AuthValidTime"] != nil {
            self.authValidTime = dict["AuthValidTime"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StageName") && dict["StageName"] != nil {
            self.stageName = dict["StageName"] as! String
        }
    }
}

public class SetAppsAuthoritiesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetAppsAuthoritiesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetAppsAuthoritiesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SetAppsAuthoritiesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetDomainRequest : Tea.TeaModel {
    public var bindStageName: String?

    public var customDomainType: String?

    public var domainName: String?

    public var groupId: String?

    public var isForce: Bool?

    public var isHttpRedirectToHttps: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bindStageName != nil {
            map["BindStageName"] = self.bindStageName!
        }
        if self.customDomainType != nil {
            map["CustomDomainType"] = self.customDomainType!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.isForce != nil {
            map["IsForce"] = self.isForce!
        }
        if self.isHttpRedirectToHttps != nil {
            map["IsHttpRedirectToHttps"] = self.isHttpRedirectToHttps!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BindStageName") && dict["BindStageName"] != nil {
            self.bindStageName = dict["BindStageName"] as! String
        }
        if dict.keys.contains("CustomDomainType") && dict["CustomDomainType"] != nil {
            self.customDomainType = dict["CustomDomainType"] as! String
        }
        if dict.keys.contains("DomainName") && dict["DomainName"] != nil {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("IsForce") && dict["IsForce"] != nil {
            self.isForce = dict["IsForce"] as! Bool
        }
        if dict.keys.contains("IsHttpRedirectToHttps") && dict["IsHttpRedirectToHttps"] != nil {
            self.isHttpRedirectToHttps = dict["IsHttpRedirectToHttps"] as! Bool
        }
    }
}

public class SetDomainResponseBody : Tea.TeaModel {
    public var domainBindingStatus: String?

    public var domainLegalStatus: String?

    public var domainName: String?

    public var domainRemark: String?

    public var domainWebSocketStatus: String?

    public var groupId: String?

    public var requestId: String?

    public var subDomain: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainBindingStatus != nil {
            map["DomainBindingStatus"] = self.domainBindingStatus!
        }
        if self.domainLegalStatus != nil {
            map["DomainLegalStatus"] = self.domainLegalStatus!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.domainRemark != nil {
            map["DomainRemark"] = self.domainRemark!
        }
        if self.domainWebSocketStatus != nil {
            map["DomainWebSocketStatus"] = self.domainWebSocketStatus!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.subDomain != nil {
            map["SubDomain"] = self.subDomain!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainBindingStatus") && dict["DomainBindingStatus"] != nil {
            self.domainBindingStatus = dict["DomainBindingStatus"] as! String
        }
        if dict.keys.contains("DomainLegalStatus") && dict["DomainLegalStatus"] != nil {
            self.domainLegalStatus = dict["DomainLegalStatus"] as! String
        }
        if dict.keys.contains("DomainName") && dict["DomainName"] != nil {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("DomainRemark") && dict["DomainRemark"] != nil {
            self.domainRemark = dict["DomainRemark"] as! String
        }
        if dict.keys.contains("DomainWebSocketStatus") && dict["DomainWebSocketStatus"] != nil {
            self.domainWebSocketStatus = dict["DomainWebSocketStatus"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SubDomain") && dict["SubDomain"] != nil {
            self.subDomain = dict["SubDomain"] as! String
        }
    }
}

public class SetDomainResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetDomainResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SetDomainResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetDomainCertificateRequest : Tea.TeaModel {
    public var caCertificateBody: String?

    public var certificateBody: String?

    public var certificateName: String?

    public var certificatePrivateKey: String?

    public var domainName: String?

    public var groupId: String?

    public var securityToken: String?

    public var sslVerifyDepth: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.caCertificateBody != nil {
            map["CaCertificateBody"] = self.caCertificateBody!
        }
        if self.certificateBody != nil {
            map["CertificateBody"] = self.certificateBody!
        }
        if self.certificateName != nil {
            map["CertificateName"] = self.certificateName!
        }
        if self.certificatePrivateKey != nil {
            map["CertificatePrivateKey"] = self.certificatePrivateKey!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.sslVerifyDepth != nil {
            map["SslVerifyDepth"] = self.sslVerifyDepth!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CaCertificateBody") && dict["CaCertificateBody"] != nil {
            self.caCertificateBody = dict["CaCertificateBody"] as! String
        }
        if dict.keys.contains("CertificateBody") && dict["CertificateBody"] != nil {
            self.certificateBody = dict["CertificateBody"] as! String
        }
        if dict.keys.contains("CertificateName") && dict["CertificateName"] != nil {
            self.certificateName = dict["CertificateName"] as! String
        }
        if dict.keys.contains("CertificatePrivateKey") && dict["CertificatePrivateKey"] != nil {
            self.certificatePrivateKey = dict["CertificatePrivateKey"] as! String
        }
        if dict.keys.contains("DomainName") && dict["DomainName"] != nil {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("SslVerifyDepth") && dict["SslVerifyDepth"] != nil {
            self.sslVerifyDepth = dict["SslVerifyDepth"] as! String
        }
    }
}

public class SetDomainCertificateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetDomainCertificateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetDomainCertificateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SetDomainCertificateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetDomainWebSocketStatusRequest : Tea.TeaModel {
    public var actionValue: String?

    public var domainName: String?

    public var groupId: String?

    public var securityToken: String?

    public var WSSEnable: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.actionValue != nil {
            map["ActionValue"] = self.actionValue!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.WSSEnable != nil {
            map["WSSEnable"] = self.WSSEnable!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ActionValue") && dict["ActionValue"] != nil {
            self.actionValue = dict["ActionValue"] as! String
        }
        if dict.keys.contains("DomainName") && dict["DomainName"] != nil {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("WSSEnable") && dict["WSSEnable"] != nil {
            self.WSSEnable = dict["WSSEnable"] as! String
        }
    }
}

public class SetDomainWebSocketStatusResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetDomainWebSocketStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetDomainWebSocketStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SetDomainWebSocketStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetGroupAuthAppCodeRequest : Tea.TeaModel {
    public var authAppCode: String?

    public var groupId: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.authAppCode != nil {
            map["AuthAppCode"] = self.authAppCode!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AuthAppCode") && dict["AuthAppCode"] != nil {
            self.authAppCode = dict["AuthAppCode"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class SetGroupAuthAppCodeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetGroupAuthAppCodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetGroupAuthAppCodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SetGroupAuthAppCodeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetIpControlApisRequest : Tea.TeaModel {
    public var apiIds: String?

    public var groupId: String?

    public var ipControlId: String?

    public var securityToken: String?

    public var stageName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiIds != nil {
            map["ApiIds"] = self.apiIds!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.ipControlId != nil {
            map["IpControlId"] = self.ipControlId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.stageName != nil {
            map["StageName"] = self.stageName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiIds") && dict["ApiIds"] != nil {
            self.apiIds = dict["ApiIds"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("IpControlId") && dict["IpControlId"] != nil {
            self.ipControlId = dict["IpControlId"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StageName") && dict["StageName"] != nil {
            self.stageName = dict["StageName"] as! String
        }
    }
}

public class SetIpControlApisResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetIpControlApisResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetIpControlApisResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SetIpControlApisResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetSignatureApisRequest : Tea.TeaModel {
    public var apiIds: String?

    public var groupId: String?

    public var securityToken: String?

    public var signatureId: String?

    public var stageName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiIds != nil {
            map["ApiIds"] = self.apiIds!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.signatureId != nil {
            map["SignatureId"] = self.signatureId!
        }
        if self.stageName != nil {
            map["StageName"] = self.stageName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiIds") && dict["ApiIds"] != nil {
            self.apiIds = dict["ApiIds"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("SignatureId") && dict["SignatureId"] != nil {
            self.signatureId = dict["SignatureId"] as! String
        }
        if dict.keys.contains("StageName") && dict["StageName"] != nil {
            self.stageName = dict["StageName"] as! String
        }
    }
}

public class SetSignatureApisResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetSignatureApisResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetSignatureApisResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SetSignatureApisResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetTrafficControlApisRequest : Tea.TeaModel {
    public var apiIds: String?

    public var groupId: String?

    public var securityToken: String?

    public var stageName: String?

    public var trafficControlId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiIds != nil {
            map["ApiIds"] = self.apiIds!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.stageName != nil {
            map["StageName"] = self.stageName!
        }
        if self.trafficControlId != nil {
            map["TrafficControlId"] = self.trafficControlId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiIds") && dict["ApiIds"] != nil {
            self.apiIds = dict["ApiIds"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StageName") && dict["StageName"] != nil {
            self.stageName = dict["StageName"] as! String
        }
        if dict.keys.contains("TrafficControlId") && dict["TrafficControlId"] != nil {
            self.trafficControlId = dict["TrafficControlId"] as! String
        }
    }
}

public class SetTrafficControlApisResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetTrafficControlApisResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetTrafficControlApisResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SetTrafficControlApisResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetVpcAccessRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var description_: String?

    public var instanceId: String?

    public var name: String?

    public var port: Int32?

    public var securityToken: String?

    public var tag: [SetVpcAccessRequest.Tag]?

    public var vpcId: String?

    public var vpcTargetHostName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.port != nil {
            map["Port"] = self.port!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        if self.vpcTargetHostName != nil {
            map["VpcTargetHostName"] = self.vpcTargetHostName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Port") && dict["Port"] != nil {
            self.port = dict["Port"] as! Int32
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("Tag") && dict["Tag"] != nil {
            var tmp : [SetVpcAccessRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = SetVpcAccessRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("VpcId") && dict["VpcId"] != nil {
            self.vpcId = dict["VpcId"] as! String
        }
        if dict.keys.contains("VpcTargetHostName") && dict["VpcTargetHostName"] != nil {
            self.vpcTargetHostName = dict["VpcTargetHostName"] as! String
        }
    }
}

public class SetVpcAccessResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var vpcAccessId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.vpcAccessId != nil {
            map["VpcAccessId"] = self.vpcAccessId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("VpcAccessId") && dict["VpcAccessId"] != nil {
            self.vpcAccessId = dict["VpcAccessId"] as! String
        }
    }
}

public class SetVpcAccessResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetVpcAccessResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SetVpcAccessResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetWildcardDomainPatternsRequest : Tea.TeaModel {
    public var domainName: String?

    public var groupId: String?

    public var securityToken: String?

    public var wildcardDomainPatterns: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.wildcardDomainPatterns != nil {
            map["WildcardDomainPatterns"] = self.wildcardDomainPatterns!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") && dict["DomainName"] != nil {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("WildcardDomainPatterns") && dict["WildcardDomainPatterns"] != nil {
            self.wildcardDomainPatterns = dict["WildcardDomainPatterns"] as! String
        }
    }
}

public class SetWildcardDomainPatternsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetWildcardDomainPatternsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetWildcardDomainPatternsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SetWildcardDomainPatternsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SwitchApiRequest : Tea.TeaModel {
    public var apiId: String?

    public var description_: String?

    public var groupId: String?

    public var historyVersion: String?

    public var securityToken: String?

    public var stageName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.historyVersion != nil {
            map["HistoryVersion"] = self.historyVersion!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.stageName != nil {
            map["StageName"] = self.stageName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiId") && dict["ApiId"] != nil {
            self.apiId = dict["ApiId"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("HistoryVersion") && dict["HistoryVersion"] != nil {
            self.historyVersion = dict["HistoryVersion"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StageName") && dict["StageName"] != nil {
            self.stageName = dict["StageName"] as! String
        }
    }
}

public class SwitchApiResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SwitchApiResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SwitchApiResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SwitchApiResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class TagResourcesRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var resourceId: [String]?

    public var resourceType: String?

    public var securityToken: String?

    public var tag: [TagResourcesRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ResourceId") && dict["ResourceId"] != nil {
            self.resourceId = dict["ResourceId"] as! [String]
        }
        if dict.keys.contains("ResourceType") && dict["ResourceType"] != nil {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("Tag") && dict["Tag"] != nil {
            var tmp : [TagResourcesRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = TagResourcesRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class TagResourcesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class TagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: TagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = TagResourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UntagResourcesRequest : Tea.TeaModel {
    public var all: Bool?

    public var resourceId: [String]?

    public var resourceType: String?

    public var securityToken: String?

    public var tagKey: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.all != nil {
            map["All"] = self.all!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.tagKey != nil {
            map["TagKey"] = self.tagKey!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("All") && dict["All"] != nil {
            self.all = dict["All"] as! Bool
        }
        if dict.keys.contains("ResourceId") && dict["ResourceId"] != nil {
            self.resourceId = dict["ResourceId"] as! [String]
        }
        if dict.keys.contains("ResourceType") && dict["ResourceType"] != nil {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("TagKey") && dict["TagKey"] != nil {
            self.tagKey = dict["TagKey"] as! [String]
        }
    }
}

public class UntagResourcesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UntagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UntagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UntagResourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ValidateVpcConnectivityRequest : Tea.TeaModel {
    public var instanceId: String?

    public var securityToken: String?

    public var vpcAccessId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.vpcAccessId != nil {
            map["VpcAccessId"] = self.vpcAccessId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("VpcAccessId") && dict["VpcAccessId"] != nil {
            self.vpcAccessId = dict["VpcAccessId"] as! String
        }
    }
}

public class ValidateVpcConnectivityResponseBody : Tea.TeaModel {
    public var connected: Bool?

    public var ipType: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.connected != nil {
            map["Connected"] = self.connected!
        }
        if self.ipType != nil {
            map["IpType"] = self.ipType!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Connected") && dict["Connected"] != nil {
            self.connected = dict["Connected"] as! Bool
        }
        if dict.keys.contains("IpType") && dict["IpType"] != nil {
            self.ipType = dict["IpType"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ValidateVpcConnectivityResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ValidateVpcConnectivityResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ValidateVpcConnectivityResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}
